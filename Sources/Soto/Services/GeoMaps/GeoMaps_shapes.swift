//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension GeoMaps {
    // MARK: Enums

    public enum ColorScheme: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dark = "Dark"
        case light = "Light"
        public var description: String { return self.rawValue }
    }

    public enum LabelSize: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "Large"
        case small = "Small"
        public var description: String { return self.rawValue }
    }

    public enum MapFeatureMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum MapStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hybrid = "Hybrid"
        case monochrome = "Monochrome"
        case satellite = "Satellite"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum ScaleBarUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kilometers = "Kilometers"
        case kilometersMiles = "KilometersMiles"
        case miles = "Miles"
        case milesKilometers = "MilesKilometers"
        public var description: String { return self.rawValue }
    }

    public enum StaticMapStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case satellite = "Satellite"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        ///     The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotParse = "CannotParse"
        ///     The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldValidationFailed = "FieldValidationFailed"
        /// The required input is missing.
        case missing = "Missing"
        /// The input is invalid but no more specific reason is applicable.
        case other = "Other"
        /// No such field is supported.
        case unknownField = "UnknownField"
        /// No such operation is supported.
        case unknownOperation = "UnknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum Variant: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "Default"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct GetGlyphsRequest: AWSEncodableShape {
        /// Name of the FontStack to retrieve.  Example: Amazon Ember Bold,Noto Sans Bold. The supported font stacks are as follows:   Amazon Ember Bold   Amazon Ember Bold Italic   Amazon Ember Bold,Noto Sans Bold   Amazon Ember Bold,Noto Sans Bold,Noto Sans Arabic Bold   Amazon Ember Condensed RC BdItalic   Amazon Ember Condensed RC Bold   Amazon Ember Condensed RC Bold Italic   Amazon Ember Condensed RC Bold,Noto Sans Bold   Amazon Ember Condensed RC Bold,Noto Sans Bold,Noto Sans Arabic Condensed Bold   Amazon Ember Condensed RC Light   Amazon Ember Condensed RC Light Italic   Amazon Ember Condensed RC LtItalic   Amazon Ember Condensed RC Regular   Amazon Ember Condensed RC Regular Italic   Amazon Ember Condensed RC Regular,Noto Sans Regular   Amazon Ember Condensed RC Regular,Noto Sans Regular,Noto Sans Arabic Condensed Regular   Amazon Ember Condensed RC RgItalic   Amazon Ember Condensed RC ThItalic   Amazon Ember Condensed RC Thin   Amazon Ember Condensed RC Thin Italic   Amazon Ember Heavy   Amazon Ember Heavy Italic   Amazon Ember Light   Amazon Ember Light Italic   Amazon Ember Medium   Amazon Ember Medium Italic   Amazon Ember Medium,Noto Sans Medium   Amazon Ember Medium,Noto Sans Medium,Noto Sans Arabic Medium   Amazon Ember Regular   Amazon Ember Regular Italic   Amazon Ember Regular Italic,Noto Sans Italic   Amazon Ember Regular Italic,Noto Sans Italic,Noto Sans Arabic Regular   Amazon Ember Regular,Noto Sans Regular   Amazon Ember Regular,Noto Sans Regular,Noto Sans Arabic Regular   Amazon Ember Thin   Amazon Ember Thin Italic   AmazonEmberCdRC_Bd   AmazonEmberCdRC_BdIt   AmazonEmberCdRC_Lt   AmazonEmberCdRC_LtIt   AmazonEmberCdRC_Rg   AmazonEmberCdRC_RgIt   AmazonEmberCdRC_Th   AmazonEmberCdRC_ThIt   AmazonEmber_Bd   AmazonEmber_BdIt   AmazonEmber_He   AmazonEmber_HeIt   AmazonEmber_Lt   AmazonEmber_LtIt   AmazonEmber_Md   AmazonEmber_MdIt   AmazonEmber_Rg   AmazonEmber_RgIt   AmazonEmber_Th   AmazonEmber_ThIt   Noto Sans Black   Noto Sans Black Italic   Noto Sans Bold   Noto Sans Bold Italic   Noto Sans Extra Bold   Noto Sans Extra Bold Italic   Noto Sans Extra Light   Noto Sans Extra Light Italic   Noto Sans Italic   Noto Sans Light   Noto Sans Light Italic   Noto Sans Medium   Noto Sans Medium Italic   Noto Sans Regular   Noto Sans Semi Bold   Noto Sans Semi Bold Italic   Noto Sans Thin   Noto Sans Thin Italic   NotoSans-Bold   NotoSans-Italic   NotoSans-Medium   NotoSans-Regular   Open Sans Regular,Arial Unicode MS Regular
        public let fontStack: String
        /// A Unicode range of characters to download glyphs for. This must be aligned to multiples of 256.  Example: 0-255.pdf
        public let fontUnicodeRange: String

        @inlinable
        public init(fontStack: String, fontUnicodeRange: String) {
            self.fontStack = fontStack
            self.fontUnicodeRange = fontUnicodeRange
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fontStack, key: "FontStack")
            request.encodePath(self.fontUnicodeRange, key: "FontUnicodeRange")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGlyphsResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The Glyph, as a binary blob.
        public let blob: AWSHTTPBody
        /// Header that instructs caching configuration for the client.
        public let cacheControl: String?
        /// Header that represents the format of the response. The response returns the following as the HTTP body.
        public let contentType: String?
        /// The glyph's Etag.
        public let eTag: String?

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil, eTag: String? = nil) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
            self.eTag = eTag
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.eTag = try response.decodeHeaderIfPresent(String.self, key: "ETag")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSpritesRequest: AWSEncodableShape {
        /// Sets color tone for map such as dark and light for specific map styles. It applies to only vector map styles such as Standard and Monochrome. Example: Light  Default value: Light   Valid values for ColorScheme are case sensitive.
        public let colorScheme: ColorScheme
        ///  Sprites API: The name of the sprite ï¬le to retrieve, following pattern sprites(@2x)?\.(png|json). Example: sprites.png
        public let fileName: String
        /// Style specifies the desired map style for the Sprites APIs.
        public let style: MapStyle
        /// Optimizes map styles for specific use case or industry. You can choose allowed variant only with Standard map style. Example: Default   Valid values for Variant are case sensitive.
        public let variant: Variant

        @inlinable
        public init(colorScheme: ColorScheme, fileName: String, style: MapStyle, variant: Variant) {
            self.colorScheme = colorScheme
            self.fileName = fileName
            self.style = style
            self.variant = variant
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.colorScheme, key: "ColorScheme")
            request.encodePath(self.fileName, key: "FileName")
            request.encodePath(self.style, key: "Style")
            request.encodePath(self.variant, key: "Variant")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSpritesResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The body of the sprite sheet or JSON offset file (image/png or application/json, depending on input).
        public let blob: AWSHTTPBody
        /// Header that instructs caching configuration for the client.
        public let cacheControl: String?
        /// Header that represents the format of the response. The response returns the following as the HTTP body.
        public let contentType: String?
        /// The sprite's Etag.
        public let eTag: String?

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil, eTag: String? = nil) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
            self.eTag = eTag
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.eTag = try response.decodeHeaderIfPresent(String.self, key: "ETag")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStaticMapRequest: AWSEncodableShape {
        /// Takes in two or more pair of coordinates, [Lon, Lat], with each coordinate separated by a comma. The API will generate an image to encompass all of the provided coordinates.   Cannot be used with Zoom and or Radius   Example: 97.170451,78.039098,99.045536,27.176178
        public let boundedPositions: String?
        /// Takes in two pairs of coordinates, [Lon, Lat], denoting south-westerly and north-easterly edges of the image. The underlying area becomes the view of the image.  Example: -123.17075,49.26959,-123.08125,49.31429
        public let boundingBox: String?
        /// Takes in a pair of coordinates, [Lon, Lat], which becomes the center point of the image. This parameter requires that either zoom or radius is set.  Cannot be used with Zoom and or Radius   Example: 49.295,-123.108
        public let center: String?
        /// Sets color tone for map, such as dark and light for specific map styles. It only applies to vector map styles, such as Standard. Example: Light  Default value: Light   Valid values for ColorScheme are case sensitive.
        public let colorScheme: ColorScheme?
        /// Takes in a string to draw geometries on the image. The input is a comma separated format as follows format: [Lon, Lat]  Example: line:-122.407653,37.798557,-122.413291,37.802443;color=%23DD0000;width=7;outline-color=#00DD00;outline-width=5yd|point:-122.40572,37.80004;label=Fog Hill Market;size=large;text-color=%23DD0000;color=#EE4B2B   Currently it supports the following geometry types: point, line and polygon. It does not support multiPoint , multiLine and multiPolgyon.
        public let compactOverlay: String?
        /// It is a flag that takes in true or false. It prevents the labels that are on the edge of the image from being cut or obscured.
        public let cropLabels: Bool?
        /// The map scaling parameter to size the image, icons, and labels. It follows the pattern of ^map(@2x)?$. Example: map, map@2x
        public let fileName: String
        /// Takes in a string to draw geometries on the image. The input is a valid GeoJSON collection object.  Example: {"type":"FeatureCollection","features": [{"type":"Feature","geometry":{"type":"MultiPoint","coordinates": [[-90.076345,51.504107],[-0.074451,51.506892]]},"properties": {"color":"#00DD00"}}]}
        public let geoJsonOverlay: String?
        /// Specifies the height of the map image.
        public let height: Int
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// Overrides the label size auto-calculated by FileName. Takes in one of the values - Small or Large.
        public let labelSize: LabelSize?
        /// Specifies the language on the map labels using the BCP 47 language tag, limited to ISO 639-1 two-letter language codes. If the specified language data isn't available for the map image, the labels will default to the regional primary language. Supported codes:    ar     as     az     be     bg     bn     bs     ca     cs     cy     da     de     el     en     es     et     eu     fi     fo     fr     ga     gl     gn     gu     he     hi     hr     hu     hy     id     is     it     ja     ka     kk     km     kn     ko     ky     lt     lv     mk     ml     mr     ms     mt     my     nl     no     or     pa     pl     pt     ro     ru     sk     sl     sq     sr     sv     ta     te     th     tr     uk     uz     vi     zh
        public let language: String?
        /// Applies additional space (in pixels) around overlay feature to prevent them from being cut or obscured.  Value for max and min is determined by: Min: 1  Max: min(height, width)/4   Example: 100
        public let padding: Int?
        /// Determines if the result image will display icons representing points of interest on the map.
        public let pointsOfInterests: MapFeatureMode?
        /// Specifies the political view, using ISO 3166-2 or ISO 3166-3 country code format. The following political views are currently supported:    ARG: Argentina's view on the Southern Patagonian Ice Field and Tierra Del Fuego, including the Falkland Islands, South Georgia, and South Sandwich Islands    EGY: Egypt's view on Bir Tawil    IND: India's view on Gilgit-Baltistan    KEN: Kenya's view on the Ilemi Triangle    MAR: Morocco's view on Western Sahara    RUS: Russia's view on Crimea    SDN: Sudan's view on the Halaib Triangle    SRB: Serbia's view on Kosovo, Vukovar, and Sarengrad Islands    SUR: Suriname's view on the Courantyne Headwaters and Lawa Headwaters    SYR: Syria's view on the Golan Heights    TUR: Turkey's view on Cyprus and Northern Cyprus    TZA: Tanzania's view on Lake Malawi    URY: Uruguay's view on Rincon de Artigas    VNM: Vietnam's view on the Paracel Islands and Spratly Islands
        public let politicalView: String?
        /// Used with center parameter, it specifies the zoom of the image where you can control it on a granular level. Takes in any value &gt;= 1.  Example: 1500   Cannot be used with Zoom.   Unit: Meters
        public let radius: Int64?
        /// Displays a scale on the bottom right of the map image with the unit specified in the input.  Example: KilometersMiles, Miles, Kilometers, MilesKilometers
        public let scaleBarUnit: ScaleBarUnit?
        ///  Style specifies the desired map style.
        public let style: StaticMapStyle?
        /// Specifies the width of the map image.
        public let width: Int
        /// Specifies the zoom level of the map image.  Cannot be used with Radius.
        public let zoom: Float?

        @inlinable
        public init(boundedPositions: String? = nil, boundingBox: String? = nil, center: String? = nil, colorScheme: ColorScheme? = nil, compactOverlay: String? = nil, cropLabels: Bool? = nil, fileName: String, geoJsonOverlay: String? = nil, height: Int, key: String? = nil, labelSize: LabelSize? = nil, language: String? = nil, padding: Int? = nil, pointsOfInterests: MapFeatureMode? = nil, politicalView: String? = nil, radius: Int64? = nil, scaleBarUnit: ScaleBarUnit? = nil, style: StaticMapStyle? = nil, width: Int, zoom: Float? = nil) {
            self.boundedPositions = boundedPositions
            self.boundingBox = boundingBox
            self.center = center
            self.colorScheme = colorScheme
            self.compactOverlay = compactOverlay
            self.cropLabels = cropLabels
            self.fileName = fileName
            self.geoJsonOverlay = geoJsonOverlay
            self.height = height
            self.key = key
            self.labelSize = labelSize
            self.language = language
            self.padding = padding
            self.pointsOfInterests = pointsOfInterests
            self.politicalView = politicalView
            self.radius = radius
            self.scaleBarUnit = scaleBarUnit
            self.style = style
            self.width = width
            self.zoom = zoom
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.boundedPositions, key: "bounded-positions")
            request.encodeQuery(self.boundingBox, key: "bounding-box")
            request.encodeQuery(self.center, key: "center")
            request.encodeQuery(self.colorScheme, key: "color-scheme")
            request.encodeQuery(self.compactOverlay, key: "compact-overlay")
            request.encodeQuery(self.cropLabels, key: "crop-labels")
            request.encodePath(self.fileName, key: "FileName")
            request.encodeQuery(self.geoJsonOverlay, key: "geojson-overlay")
            request.encodeQuery(self.height, key: "height")
            request.encodeQuery(self.key, key: "key")
            request.encodeQuery(self.labelSize, key: "label-size")
            request.encodeQuery(self.language, key: "lang")
            request.encodeQuery(self.padding, key: "padding")
            request.encodeQuery(self.pointsOfInterests, key: "pois")
            request.encodeQuery(self.politicalView, key: "political-view")
            request.encodeQuery(self.radius, key: "radius")
            request.encodeQuery(self.scaleBarUnit, key: "scale-unit")
            request.encodeQuery(self.style, key: "style")
            request.encodeQuery(self.width, key: "width")
            request.encodeQuery(self.zoom, key: "zoom")
        }

        public func validate(name: String) throws {
            try self.validate(self.boundedPositions, name: "boundedPositions", parent: name, min: 7)
            try self.validate(self.boundedPositions, name: "boundedPositions", parent: name, pattern: "^(-?\\d{1,3}(\\.\\d{1,14})?,-?\\d{1,2}(\\.\\d{1,14})?)(,(-?\\d{1,3}(\\.\\d{1,14})?,-?\\d{1,2}(\\.\\d{1,14})?))*$")
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, min: 7)
            try self.validate(self.boundingBox, name: "boundingBox", parent: name, pattern: "^(-?\\d{1,3}(\\.\\d{1,14})?,-?\\d{1,2}(\\.\\d{1,14})?)(,(-?\\d{1,3}(\\.\\d{1,14})?,-?\\d{1,2}(\\.\\d{1,14})?))*$")
            try self.validate(self.center, name: "center", parent: name, max: 36)
            try self.validate(self.center, name: "center", parent: name, min: 3)
            try self.validate(self.center, name: "center", parent: name, pattern: "^-?\\d{1,3}(\\.\\d{1,14})?,-?\\d{1,2}(\\.\\d{1,14})?$")
            try self.validate(self.compactOverlay, name: "compactOverlay", parent: name, max: 7000)
            try self.validate(self.compactOverlay, name: "compactOverlay", parent: name, min: 1)
            try self.validate(self.geoJsonOverlay, name: "geoJsonOverlay", parent: name, max: 7000)
            try self.validate(self.geoJsonOverlay, name: "geoJsonOverlay", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.language, name: "language", parent: name, max: 35)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
            try self.validate(self.radius, name: "radius", parent: name, max: 4294967295)
            try self.validate(self.radius, name: "radius", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStaticMapResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The blob represents a map image as a jpeg for the GetStaticMap API.
        public let blob: AWSHTTPBody
        /// Header that instructs caching configuration for the client.
        public let cacheControl: String?
        /// Header that represents the format of the response. The response returns the following as the HTTP body.
        public let contentType: String?
        /// The static map's Etag.
        public let eTag: String?
        /// The pricing bucket for which the request is charged at.
        public let pricingBucket: String

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil, eTag: String? = nil, pricingBucket: String) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
            self.eTag = eTag
            self.pricingBucket = pricingBucket
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.eTag = try response.decodeHeaderIfPresent(String.self, key: "ETag")
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStyleDescriptorRequest: AWSEncodableShape {
        /// Sets color tone for map such as dark and light for specific map styles. It applies to only vector map styles such as Standard and Monochrome. Example: Light  Default value: Light   Valid values for ColorScheme are case sensitive.
        public let colorScheme: ColorScheme?
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// Specifies the political view using ISO 3166-2 or ISO 3166-3 country code format. The following political views are currently supported:    ARG: Argentina's view on the Southern Patagonian Ice Field and Tierra Del Fuego, including the Falkland Islands, South Georgia, and South Sandwich Islands    EGY: Egypt's view on Bir Tawil    IND: India's view on Gilgit-Baltistan    KEN: Kenya's view on the Ilemi Triangle    MAR: Morocco's view on Western Sahara    RUS: Russia's view on Crimea    SDN: Sudan's view on the Halaib Triangle    SRB: Serbia's view on Kosovo, Vukovar, and Sarengrad Islands    SUR: Suriname's view on the Courantyne Headwaters and Lawa Headwaters    SYR: Syria's view on the Golan Heights    TUR: Turkey's view on Cyprus and Northern Cyprus    TZA: Tanzania's view on Lake Malawi    URY: Uruguay's view on Rincon de Artigas    VNM: Vietnam's view on the Paracel Islands and Spratly Islands
        public let politicalView: String?
        /// Style specifies the desired map style.
        public let style: MapStyle

        @inlinable
        public init(colorScheme: ColorScheme? = nil, key: String? = nil, politicalView: String? = nil, style: MapStyle) {
            self.colorScheme = colorScheme
            self.key = key
            self.politicalView = politicalView
            self.style = style
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.colorScheme, key: "color-scheme")
            request.encodeQuery(self.key, key: "key")
            request.encodeQuery(self.politicalView, key: "political-view")
            request.encodePath(self.style, key: "Style")
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.politicalView, name: "politicalView", parent: name, max: 3)
            try self.validate(self.politicalView, name: "politicalView", parent: name, min: 2)
            try self.validate(self.politicalView, name: "politicalView", parent: name, pattern: "^([A-Z]{2}|[A-Z]{3})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStyleDescriptorResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// This Blob contains the body of the style descriptor which is in application/json format.
        public let blob: AWSHTTPBody
        /// Header that instructs caching configuration for the client.
        public let cacheControl: String?
        /// Header that represents the format of the response. The response returns the following as the HTTP body.
        public let contentType: String?
        /// The style descriptor's Etag.
        public let eTag: String?

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil, eTag: String? = nil) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
            self.eTag = eTag
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.eTag = try response.decodeHeaderIfPresent(String.self, key: "ETag")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTileRequest: AWSEncodableShape {
        /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
        public let key: String?
        /// Specifies the desired tile set. Valid Values: raster.satellite | vector.basemap
        public let tileset: String
        /// The X axis value for the map tile. Must be between 0 and 19.
        public let x: String
        /// The Y axis value for the map tile.
        public let y: String
        /// The zoom value for the map tile.
        public let z: String

        @inlinable
        public init(key: String? = nil, tileset: String, x: String, y: String, z: String) {
            self.key = key
            self.tileset = tileset
            self.x = x
            self.y = y
            self.z = z
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.key, key: "key")
            request.encodePath(self.tileset, key: "Tileset")
            request.encodePath(self.x, key: "X")
            request.encodePath(self.y, key: "Y")
            request.encodePath(self.z, key: "Z")
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.tileset, name: "tileset", parent: name, max: 100)
            try self.validate(self.tileset, name: "tileset", parent: name, min: 1)
            try self.validate(self.tileset, name: "tileset", parent: name, pattern: "^[-.\\w]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTileResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The blob represents a vector tile in mvt or a raster tile in an image format.
        public let blob: AWSHTTPBody
        /// Header that instructs caching configuration for the client.
        public let cacheControl: String?
        /// Header that represents the format of the response. The response returns the following as the HTTP body.
        public let contentType: String?
        /// The pricing bucket for which the request is charged at.
        public let eTag: String?
        /// The pricing bucket for which the request is charged at.
        public let pricingBucket: String

        @inlinable
        public init(blob: AWSHTTPBody, cacheControl: String? = nil, contentType: String? = nil, eTag: String? = nil, pricingBucket: String) {
            self.blob = blob
            self.cacheControl = cacheControl
            self.contentType = contentType
            self.eTag = eTag
            self.pricingBucket = pricingBucket
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.blob = try container.decode(AWSHTTPBody.self)
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.eTag = try response.decodeHeaderIfPresent(String.self, key: "ETag")
            self.pricingBucket = try response.decodeHeader(String.self, key: "x-amz-geo-pricing-bucket")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ValidationException: AWSErrorShape {
        /// A message with the reason for the validation exception error.
        public let fieldList: [ValidationExceptionField]
        public let message: String
        /// The field where the invalid entry was detected.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField], message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The error message.
        public let message: String
        /// The name of the resource.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for GeoMaps
public struct GeoMapsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GeoMaps
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied because of insufficient access or permissions. Check with an administrator to verify your permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension GeoMapsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": GeoMaps.ValidationException.self
    ]
}

extension GeoMapsErrorType: Equatable {
    public static func == (lhs: GeoMapsErrorType, rhs: GeoMapsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GeoMapsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
