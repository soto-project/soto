//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AppSync {
    // MARK: Enums

    public enum ApiCacheStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case modifying = "MODIFYING"
        public var description: String { return self.rawValue }
    }

    public enum ApiCacheType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "LARGE"
        case large12X = "LARGE_12X"
        case large2X = "LARGE_2X"
        case large4X = "LARGE_4X"
        case large8X = "LARGE_8X"
        case medium = "MEDIUM"
        case r42Xlarge = "R4_2XLARGE"
        case r44Xlarge = "R4_4XLARGE"
        case r48Xlarge = "R4_8XLARGE"
        case r4Large = "R4_LARGE"
        case r4Xlarge = "R4_XLARGE"
        case small = "SMALL"
        case t2Medium = "T2_MEDIUM"
        case t2Small = "T2_SMALL"
        case xlarge = "XLARGE"
        public var description: String { return self.rawValue }
    }

    public enum ApiCachingBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullRequestCaching = "FULL_REQUEST_CACHING"
        case perResolverCaching = "PER_RESOLVER_CACHING"
        public var description: String { return self.rawValue }
    }

    public enum AssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case processing = "PROCESSING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonCognitoUserPools = "AMAZON_COGNITO_USER_POOLS"
        case apiKey = "API_KEY"
        case awsIam = "AWS_IAM"
        case awsLambda = "AWS_LAMBDA"
        case openidConnect = "OPENID_CONNECT"
        public var description: String { return self.rawValue }
    }

    public enum AuthorizationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIam = "AWS_IAM"
        public var description: String { return self.rawValue }
    }

    public enum CacheHealthMetricsConfig: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ConflictDetectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case version = "VERSION"
        public var description: String { return self.rawValue }
    }

    public enum ConflictHandlerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automerge = "AUTOMERGE"
        case lambda = "LAMBDA"
        case none = "NONE"
        case optimisticConcurrency = "OPTIMISTIC_CONCURRENCY"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceIntrospectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case processing = "PROCESSING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceLevelMetricsBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullRequestDataSourceMetrics = "FULL_REQUEST_DATA_SOURCE_METRICS"
        case perDataSourceMetrics = "PER_DATA_SOURCE_METRICS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceLevelMetricsConfig: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonDynamodb = "AMAZON_DYNAMODB"
        case amazonElasticsearch = "AMAZON_ELASTICSEARCH"
        case amazonEventbridge = "AMAZON_EVENTBRIDGE"
        case amazonOpensearchService = "AMAZON_OPENSEARCH_SERVICE"
        case awsLambda = "AWS_LAMBDA"
        case http = "HTTP"
        case none = "NONE"
        case relationalDatabase = "RELATIONAL_DATABASE"
        public var description: String { return self.rawValue }
    }

    public enum DefaultAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum FieldLogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case error = "ERROR"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GraphQLApiIntrospectionConfig: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum GraphQLApiType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case graphql = "GRAPHQL"
        case merged = "MERGED"
        public var description: String { return self.rawValue }
    }

    public enum GraphQLApiVisibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case global = "GLOBAL"
        public var description: String { return self.rawValue }
    }

    public enum MergeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoMerge = "AUTO_MERGE"
        case manualMerge = "MANUAL_MERGE"
        public var description: String { return self.rawValue }
    }

    public enum OperationLevelMetricsConfig: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum OutputType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case sdl = "SDL"
        public var description: String { return self.rawValue }
    }

    public enum Ownership: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case currentAccount = "CURRENT_ACCOUNT"
        case otherAccounts = "OTHER_ACCOUNTS"
        public var description: String { return self.rawValue }
    }

    public enum RelationalDatabaseSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rdsHttpEndpoint = "RDS_HTTP_ENDPOINT"
        public var description: String { return self.rawValue }
    }

    public enum ResolverKind: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pipeline = "PIPELINE"
        case unit = "UNIT"
        public var description: String { return self.rawValue }
    }

    public enum ResolverLevelMetricsBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullRequestResolverMetrics = "FULL_REQUEST_RESOLVER_METRICS"
        case perResolverMetrics = "PER_RESOLVER_METRICS"
        public var description: String { return self.rawValue }
    }

    public enum ResolverLevelMetricsConfig: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum RuntimeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case appsyncJs = "APPSYNC_JS"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        case failed = "FAILED"
        case notApplicable = "NOT_APPLICABLE"
        case processing = "PROCESSING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum SourceApiAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoMergeScheduleFailed = "AUTO_MERGE_SCHEDULE_FAILED"
        case deletionFailed = "DELETION_FAILED"
        case deletionInProgress = "DELETION_IN_PROGRESS"
        case deletionScheduled = "DELETION_SCHEDULED"
        case mergeFailed = "MERGE_FAILED"
        case mergeInProgress = "MERGE_IN_PROGRESS"
        case mergeScheduled = "MERGE_SCHEDULED"
        case mergeSuccess = "MERGE_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum TypeDefinitionFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case sdl = "SDL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AdditionalAuthenticationProvider: AWSEncodableShape & AWSDecodableShape {
        /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public let authenticationType: AuthenticationType?
        /// Configuration for Lambda function authorization.
        public let lambdaAuthorizerConfig: LambdaAuthorizerConfig?
        /// The OIDC configuration.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// The Amazon Cognito user pool configuration.
        public let userPoolConfig: CognitoUserPoolConfig?

        public init(authenticationType: AuthenticationType? = nil, lambdaAuthorizerConfig: LambdaAuthorizerConfig? = nil, openIDConnectConfig: OpenIDConnectConfig? = nil, userPoolConfig: CognitoUserPoolConfig? = nil) {
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.openIDConnectConfig = openIDConnectConfig
            self.userPoolConfig = userPoolConfig
        }

        public func validate(name: String) throws {
            try self.lambdaAuthorizerConfig?.validate(name: "\(name).lambdaAuthorizerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case lambdaAuthorizerConfig = "lambdaAuthorizerConfig"
            case openIDConnectConfig = "openIDConnectConfig"
            case userPoolConfig = "userPoolConfig"
        }
    }

    public struct ApiAssociation: AWSDecodableShape {
        /// The API ID.
        public let apiId: String?
        /// Identifies the status of an association.    PROCESSING: The API association is being created. You cannot modify association requests during processing.    SUCCESS: The API association was successful. You can modify associations after success.    FAILED: The API association has failed. You can modify associations after failure.
        public let associationStatus: AssociationStatus?
        /// Details about the last deployment status.
        public let deploymentDetail: String?
        /// The domain name.
        public let domainName: String?

        public init(apiId: String? = nil, associationStatus: AssociationStatus? = nil, deploymentDetail: String? = nil, domainName: String? = nil) {
            self.apiId = apiId
            self.associationStatus = associationStatus
            self.deploymentDetail = deploymentDetail
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case associationStatus = "associationStatus"
            case deploymentDetail = "deploymentDetail"
            case domainName = "domainName"
        }
    }

    public struct ApiCache: AWSDecodableShape {
        /// Caching behavior.    FULL_REQUEST_CACHING: All requests are fully cached.    PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
        public let apiCachingBehavior: ApiCachingBehavior?
        /// At-rest encryption flag for cache. You cannot update this setting after creation.
        public let atRestEncryptionEnabled: Bool?
        /// Controls how cache health metrics will be emitted to CloudWatch. Cache health metrics include:   NetworkBandwidthOutAllowanceExceeded: The network packets dropped because the throughput exceeded the aggregated bandwidth limit. This is useful for diagnosing bottlenecks in a cache configuration.   EngineCPUUtilization: The CPU utilization (percentage) allocated to the Redis process. This is useful for diagnosing bottlenecks in a cache configuration.   Metrics will be recorded by API ID. You can set the value to ENABLED or DISABLED.
        public let healthMetricsConfig: CacheHealthMetricsConfig?
        /// The cache instance status.    AVAILABLE: The instance is available for use.    CREATING: The instance is currently creating.    DELETING: The instance is currently deleting.    MODIFYING: The instance is currently modifying.    FAILED: The instance has failed creation.
        public let status: ApiCacheStatus?
        /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
        public let transitEncryptionEnabled: Bool?
        /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
        public let ttl: Int64?
        /// The cache instance type. Valid values are     SMALL     MEDIUM     LARGE     XLARGE     LARGE_2X     LARGE_4X     LARGE_8X (not available in all regions)    LARGE_12X    Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:    T2_SMALL: A t2.small instance type.    T2_MEDIUM: A t2.medium instance type.    R4_LARGE: A r4.large instance type.    R4_XLARGE: A r4.xlarge instance type.    R4_2XLARGE: A r4.2xlarge instance type.    R4_4XLARGE: A r4.4xlarge instance type.    R4_8XLARGE: A r4.8xlarge instance type.
        public let type: ApiCacheType?

        public init(apiCachingBehavior: ApiCachingBehavior? = nil, atRestEncryptionEnabled: Bool? = nil, healthMetricsConfig: CacheHealthMetricsConfig? = nil, status: ApiCacheStatus? = nil, transitEncryptionEnabled: Bool? = nil, ttl: Int64? = nil, type: ApiCacheType? = nil) {
            self.apiCachingBehavior = apiCachingBehavior
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.healthMetricsConfig = healthMetricsConfig
            self.status = status
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case apiCachingBehavior = "apiCachingBehavior"
            case atRestEncryptionEnabled = "atRestEncryptionEnabled"
            case healthMetricsConfig = "healthMetricsConfig"
            case status = "status"
            case transitEncryptionEnabled = "transitEncryptionEnabled"
            case ttl = "ttl"
            case type = "type"
        }
    }

    public struct ApiKey: AWSDecodableShape {
        /// The time after which the API key is deleted. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public let deletes: Int64?
        /// A description of the purpose of the API key.
        public let description: String?
        /// The time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public let expires: Int64?
        /// The API key ID.
        public let id: String?

        public init(deletes: Int64? = nil, description: String? = nil, expires: Int64? = nil, id: String? = nil) {
            self.deletes = deletes
            self.description = description
            self.expires = expires
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case deletes = "deletes"
            case description = "description"
            case expires = "expires"
            case id = "id"
        }
    }

    public struct AppSyncRuntime: AWSEncodableShape & AWSDecodableShape {
        /// The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
        public let name: RuntimeName
        /// The version of the runtime to use. Currently, the only allowed version is 1.0.0.
        public let runtimeVersion: String

        public init(name: RuntimeName, runtimeVersion: String) {
            self.name = name
            self.runtimeVersion = runtimeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case runtimeVersion = "runtimeVersion"
        }
    }

    public struct AssociateApiRequest: AWSEncodableShape {
        /// The API ID. Private APIs can not be associated with custom domains.
        public let apiId: String
        /// The domain name.
        public let domainName: String

        public init(apiId: String, domainName: String) {
            self.apiId = apiId
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.apiId, forKey: .apiId)
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(\\*[\\w\\d-]*\\.)?([\\w\\d-]+\\.)+[\\w\\d-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
        }
    }

    public struct AssociateApiResponse: AWSDecodableShape {
        /// The ApiAssociation object.
        public let apiAssociation: ApiAssociation?

        public init(apiAssociation: ApiAssociation? = nil) {
            self.apiAssociation = apiAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case apiAssociation = "apiAssociation"
        }
    }

    public struct AssociateMergedGraphqlApiRequest: AWSEncodableShape {
        /// The description field.
        public let description: String?
        /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
        public let mergedApiIdentifier: String
        /// The SourceApiAssociationConfig object data.
        public let sourceApiAssociationConfig: SourceApiAssociationConfig?
        /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
        public let sourceApiIdentifier: String

        public init(description: String? = nil, mergedApiIdentifier: String, sourceApiAssociationConfig: SourceApiAssociationConfig? = nil, sourceApiIdentifier: String) {
            self.description = description
            self.mergedApiIdentifier = mergedApiIdentifier
            self.sourceApiAssociationConfig = sourceApiAssociationConfig
            self.sourceApiIdentifier = sourceApiIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.mergedApiIdentifier, forKey: .mergedApiIdentifier)
            try container.encodeIfPresent(self.sourceApiAssociationConfig, forKey: .sourceApiAssociationConfig)
            request.encodePath(self.sourceApiIdentifier, key: "sourceApiIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case mergedApiIdentifier = "mergedApiIdentifier"
            case sourceApiAssociationConfig = "sourceApiAssociationConfig"
        }
    }

    public struct AssociateMergedGraphqlApiResponse: AWSDecodableShape {
        /// The SourceApiAssociation object data.
        public let sourceApiAssociation: SourceApiAssociation?

        public init(sourceApiAssociation: SourceApiAssociation? = nil) {
            self.sourceApiAssociation = sourceApiAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case sourceApiAssociation = "sourceApiAssociation"
        }
    }

    public struct AssociateSourceGraphqlApiRequest: AWSEncodableShape {
        /// The description field.
        public let description: String?
        /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
        public let mergedApiIdentifier: String
        /// The SourceApiAssociationConfig object data.
        public let sourceApiAssociationConfig: SourceApiAssociationConfig?
        /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
        public let sourceApiIdentifier: String

        public init(description: String? = nil, mergedApiIdentifier: String, sourceApiAssociationConfig: SourceApiAssociationConfig? = nil, sourceApiIdentifier: String) {
            self.description = description
            self.mergedApiIdentifier = mergedApiIdentifier
            self.sourceApiAssociationConfig = sourceApiAssociationConfig
            self.sourceApiIdentifier = sourceApiIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.mergedApiIdentifier, key: "mergedApiIdentifier")
            try container.encodeIfPresent(self.sourceApiAssociationConfig, forKey: .sourceApiAssociationConfig)
            try container.encode(self.sourceApiIdentifier, forKey: .sourceApiIdentifier)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case sourceApiAssociationConfig = "sourceApiAssociationConfig"
            case sourceApiIdentifier = "sourceApiIdentifier"
        }
    }

    public struct AssociateSourceGraphqlApiResponse: AWSDecodableShape {
        /// The SourceApiAssociation object data.
        public let sourceApiAssociation: SourceApiAssociation?

        public init(sourceApiAssociation: SourceApiAssociation? = nil) {
            self.sourceApiAssociation = sourceApiAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case sourceApiAssociation = "sourceApiAssociation"
        }
    }

    public struct AuthorizationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The authorization type that the HTTP endpoint requires.    AWS_IAM: The authorization type is Signature Version 4 (SigV4).
        public let authorizationType: AuthorizationType
        /// The Identity and Access Management (IAM) settings.
        public let awsIamConfig: AwsIamConfig?

        public init(authorizationType: AuthorizationType, awsIamConfig: AwsIamConfig? = nil) {
            self.authorizationType = authorizationType
            self.awsIamConfig = awsIamConfig
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationType = "authorizationType"
            case awsIamConfig = "awsIamConfig"
        }
    }

    public struct AwsIamConfig: AWSEncodableShape & AWSDecodableShape {
        /// The signing Amazon Web Services Region for IAM authorization.
        public let signingRegion: String?
        /// The signing service name for IAM authorization.
        public let signingServiceName: String?

        public init(signingRegion: String? = nil, signingServiceName: String? = nil) {
            self.signingRegion = signingRegion
            self.signingServiceName = signingServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case signingRegion = "signingRegion"
            case signingServiceName = "signingServiceName"
        }
    }

    public struct CachingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
        public let cachingKeys: [String]?
        /// The TTL in seconds for a resolver that has caching activated. Valid values are 1–3,600 seconds.
        public let ttl: Int64

        public init(cachingKeys: [String]? = nil, ttl: Int64) {
            self.cachingKeys = cachingKeys
            self.ttl = ttl
        }

        private enum CodingKeys: String, CodingKey {
            case cachingKeys = "cachingKeys"
            case ttl = "ttl"
        }
    }

    public struct CodeError: AWSDecodableShape {
        /// The type of code error.  Examples include, but aren't limited to: LINT_ERROR, PARSER_ERROR.
        public let errorType: String?
        /// The line, column, and span location of the error in the code.
        public let location: CodeErrorLocation?
        /// A user presentable error. Examples include, but aren't limited to: Parsing error: Unterminated string literal.
        public let value: String?

        public init(errorType: String? = nil, location: CodeErrorLocation? = nil, value: String? = nil) {
            self.errorType = errorType
            self.location = location
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case errorType = "errorType"
            case location = "location"
            case value = "value"
        }
    }

    public struct CodeErrorLocation: AWSDecodableShape {
        /// The column number in the code. Defaults to 0 if unknown.
        public let column: Int?
        /// The line number in the code. Defaults to 0 if unknown.
        public let line: Int?
        /// The span/length of the error. Defaults to -1 if unknown.
        public let span: Int?

        public init(column: Int? = nil, line: Int? = nil, span: Int? = nil) {
            self.column = column
            self.line = line
            self.span = span
        }

        private enum CodingKeys: String, CodingKey {
            case column = "column"
            case line = "line"
            case span = "span"
        }
    }

    public struct CognitoUserPoolConfig: AWSEncodableShape & AWSDecodableShape {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.
        public let appIdClientRegex: String?
        /// The Amazon Web Services Region in which the user pool was created.
        public let awsRegion: String
        /// The user pool ID.
        public let userPoolId: String

        public init(appIdClientRegex: String? = nil, awsRegion: String, userPoolId: String) {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.userPoolId = userPoolId
        }

        private enum CodingKeys: String, CodingKey {
            case appIdClientRegex = "appIdClientRegex"
            case awsRegion = "awsRegion"
            case userPoolId = "userPoolId"
        }
    }

    public struct CreateApiCacheRequest: AWSEncodableShape {
        /// Caching behavior.    FULL_REQUEST_CACHING: All requests are fully cached.    PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
        public let apiCachingBehavior: ApiCachingBehavior
        /// The GraphQL API ID.
        public let apiId: String
        /// At-rest encryption flag for cache. You cannot update this setting after creation.
        public let atRestEncryptionEnabled: Bool?
        /// Controls how cache health metrics will be emitted to CloudWatch. Cache health metrics include:   NetworkBandwidthOutAllowanceExceeded: The network packets dropped because the throughput exceeded the aggregated bandwidth limit. This is useful for diagnosing bottlenecks in a cache configuration.   EngineCPUUtilization: The CPU utilization (percentage) allocated to the Redis process. This is useful for diagnosing bottlenecks in a cache configuration.   Metrics will be recorded by API ID. You can set the value to ENABLED or DISABLED.
        public let healthMetricsConfig: CacheHealthMetricsConfig?
        /// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
        public let transitEncryptionEnabled: Bool?
        /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
        public let ttl: Int64
        /// The cache instance type. Valid values are     SMALL     MEDIUM     LARGE     XLARGE     LARGE_2X     LARGE_4X     LARGE_8X (not available in all regions)    LARGE_12X    Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:    T2_SMALL: A t2.small instance type.    T2_MEDIUM: A t2.medium instance type.    R4_LARGE: A r4.large instance type.    R4_XLARGE: A r4.xlarge instance type.    R4_2XLARGE: A r4.2xlarge instance type.    R4_4XLARGE: A r4.4xlarge instance type.    R4_8XLARGE: A r4.8xlarge instance type.
        public let type: ApiCacheType

        public init(apiCachingBehavior: ApiCachingBehavior, apiId: String, atRestEncryptionEnabled: Bool? = nil, healthMetricsConfig: CacheHealthMetricsConfig? = nil, transitEncryptionEnabled: Bool? = nil, ttl: Int64 = 0, type: ApiCacheType) {
            self.apiCachingBehavior = apiCachingBehavior
            self.apiId = apiId
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.healthMetricsConfig = healthMetricsConfig
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.apiCachingBehavior, forKey: .apiCachingBehavior)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
            try container.encodeIfPresent(self.healthMetricsConfig, forKey: .healthMetricsConfig)
            try container.encodeIfPresent(self.transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
            try container.encode(self.ttl, forKey: .ttl)
            try container.encode(self.type, forKey: .type)
        }

        private enum CodingKeys: String, CodingKey {
            case apiCachingBehavior = "apiCachingBehavior"
            case atRestEncryptionEnabled = "atRestEncryptionEnabled"
            case healthMetricsConfig = "healthMetricsConfig"
            case transitEncryptionEnabled = "transitEncryptionEnabled"
            case ttl = "ttl"
            case type = "type"
        }
    }

    public struct CreateApiCacheResponse: AWSDecodableShape {
        /// The ApiCache object.
        public let apiCache: ApiCache?

        public init(apiCache: ApiCache? = nil) {
            self.apiCache = apiCache
        }

        private enum CodingKeys: String, CodingKey {
            case apiCache = "apiCache"
        }
    }

    public struct CreateApiKeyRequest: AWSEncodableShape {
        /// The ID for your GraphQL API.
        public let apiId: String
        /// A description of the purpose of the API key.
        public let description: String?
        /// From the creation time, the time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .
        public let expires: Int64?

        public init(apiId: String, description: String? = nil, expires: Int64? = nil) {
            self.apiId = apiId
            self.description = description
            self.expires = expires
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.expires, forKey: .expires)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case expires = "expires"
        }
    }

    public struct CreateApiKeyResponse: AWSDecodableShape {
        /// The API key.
        public let apiKey: ApiKey?

        public init(apiKey: ApiKey? = nil) {
            self.apiKey = apiKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        /// The API ID for the GraphQL API for the DataSource.
        public let apiId: String
        /// A description of the DataSource.
        public let description: String?
        /// Amazon DynamoDB settings.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// Amazon OpenSearch Service settings. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use CreateDataSourceRequest$openSearchServiceConfig to create an OpenSearch data source.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// Amazon EventBridge settings.
        public let eventBridgeConfig: EventBridgeDataSourceConfig?
        /// HTTP endpoint settings.
        public let httpConfig: HttpDataSourceConfig?
        /// Lambda settings.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// Enables or disables enhanced data source metrics for specified data sources. Note that metricsConfig won't be used unless the dataSourceLevelMetricsBehavior value is set to PER_DATA_SOURCE_METRICS. If the dataSourceLevelMetricsBehavior is set to FULL_REQUEST_DATA_SOURCE_METRICS instead, metricsConfig will be ignored. However, you can still set its value.  metricsConfig can be ENABLED or DISABLED.
        public let metricsConfig: DataSourceLevelMetricsConfig?
        /// A user-supplied name for the DataSource.
        public let name: String
        /// Amazon OpenSearch Service settings.
        public let openSearchServiceConfig: OpenSearchServiceDataSourceConfig?
        /// Relational database settings.
        public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
        /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
        public let serviceRoleArn: String?
        /// The type of the DataSource.
        public let type: DataSourceType

        public init(apiId: String, description: String? = nil, dynamodbConfig: DynamodbDataSourceConfig? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, eventBridgeConfig: EventBridgeDataSourceConfig? = nil, httpConfig: HttpDataSourceConfig? = nil, lambdaConfig: LambdaDataSourceConfig? = nil, metricsConfig: DataSourceLevelMetricsConfig? = nil, name: String, openSearchServiceConfig: OpenSearchServiceDataSourceConfig? = nil, relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil, serviceRoleArn: String? = nil, type: DataSourceType) {
            self.apiId = apiId
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.eventBridgeConfig = eventBridgeConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.metricsConfig = metricsConfig
            self.name = name
            self.openSearchServiceConfig = openSearchServiceConfig
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dynamodbConfig, forKey: .dynamodbConfig)
            try container.encodeIfPresent(self.elasticsearchConfig, forKey: .elasticsearchConfig)
            try container.encodeIfPresent(self.eventBridgeConfig, forKey: .eventBridgeConfig)
            try container.encodeIfPresent(self.httpConfig, forKey: .httpConfig)
            try container.encodeIfPresent(self.lambdaConfig, forKey: .lambdaConfig)
            try container.encodeIfPresent(self.metricsConfig, forKey: .metricsConfig)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.openSearchServiceConfig, forKey: .openSearchServiceConfig)
            try container.encodeIfPresent(self.relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
            try container.encodeIfPresent(self.serviceRoleArn, forKey: .serviceRoleArn)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 65536)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dynamodbConfig = "dynamodbConfig"
            case elasticsearchConfig = "elasticsearchConfig"
            case eventBridgeConfig = "eventBridgeConfig"
            case httpConfig = "httpConfig"
            case lambdaConfig = "lambdaConfig"
            case metricsConfig = "metricsConfig"
            case name = "name"
            case openSearchServiceConfig = "openSearchServiceConfig"
            case relationalDatabaseConfig = "relationalDatabaseConfig"
            case serviceRoleArn = "serviceRoleArn"
            case type = "type"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        /// The DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct CreateDomainNameRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
        public let certificateArn: String
        /// A description of the DomainName.
        public let description: String?
        /// The domain name.
        public let domainName: String

        public init(certificateArn: String, description: String? = nil, domainName: String) {
            self.certificateArn = certificateArn
            self.description = description
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, max: 2048)
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, min: 20)
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "^arn:[a-z-]*:(acm|iam):[a-z0-9-]*:\\d{12}:(certificate|server-certificate)/[0-9A-Za-z_/-]*$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(\\*[\\w\\d-]*\\.)?([\\w\\d-]+\\.)+[\\w\\d-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
            case description = "description"
            case domainName = "domainName"
        }
    }

    public struct CreateDomainNameResponse: AWSDecodableShape {
        /// The configuration for the DomainName.
        public let domainNameConfig: DomainNameConfig?

        public init(domainNameConfig: DomainNameConfig? = nil) {
            self.domainNameConfig = domainNameConfig
        }

        private enum CodingKeys: String, CodingKey {
            case domainNameConfig = "domainNameConfig"
        }
    }

    public struct CreateFunctionRequest: AWSEncodableShape {
        /// The GraphQL API ID.
        public let apiId: String
        /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public let code: String?
        /// The Function DataSource name.
        public let dataSourceName: String
        /// The Function description.
        public let description: String?
        /// The version of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the functionVersion is required.
        public let functionVersion: String?
        /// The maximum batching size for a resolver.
        public let maxBatchSize: Int?
        /// The Function name. The function name does not have to be unique.
        public let name: String
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public let requestMappingTemplate: String?
        /// The Function response mapping template.
        public let responseMappingTemplate: String?
        public let runtime: AppSyncRuntime?
        public let syncConfig: SyncConfig?

        public init(apiId: String, code: String? = nil, dataSourceName: String, description: String? = nil, functionVersion: String? = nil, maxBatchSize: Int? = nil, name: String, requestMappingTemplate: String? = nil, responseMappingTemplate: String? = nil, runtime: AppSyncRuntime? = nil, syncConfig: SyncConfig? = nil) {
            self.apiId = apiId
            self.code = code
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionVersion = functionVersion
            self.maxBatchSize = maxBatchSize
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.code, forKey: .code)
            try container.encode(self.dataSourceName, forKey: .dataSourceName)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.functionVersion, forKey: .functionVersion)
            try container.encodeIfPresent(self.maxBatchSize, forKey: .maxBatchSize)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.requestMappingTemplate, forKey: .requestMappingTemplate)
            try container.encodeIfPresent(self.responseMappingTemplate, forKey: .responseMappingTemplate)
            try container.encodeIfPresent(self.runtime, forKey: .runtime)
            try container.encodeIfPresent(self.syncConfig, forKey: .syncConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 32768)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, max: 2000)
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 65536)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, pattern: "^.*$")
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case dataSourceName = "dataSourceName"
            case description = "description"
            case functionVersion = "functionVersion"
            case maxBatchSize = "maxBatchSize"
            case name = "name"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
            case runtime = "runtime"
            case syncConfig = "syncConfig"
        }
    }

    public struct CreateFunctionResponse: AWSDecodableShape {
        /// The Function object.
        public let functionConfiguration: FunctionConfiguration?

        public init(functionConfiguration: FunctionConfiguration? = nil) {
            self.functionConfiguration = functionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case functionConfiguration = "functionConfiguration"
        }
    }

    public struct CreateGraphqlApiRequest: AWSEncodableShape {
        /// A list of additional authentication providers for the GraphqlApi API.
        public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
        /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
        public let apiType: GraphQLApiType?
        /// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public let authenticationType: AuthenticationType
        /// The enhancedMetricsConfig object.
        public let enhancedMetricsConfig: EnhancedMetricsConfig?
        /// Sets the value of the GraphQL API to enable (ENABLED) or disable (DISABLED) introspection. If no value is provided, the introspection configuration will be set to ENABLED by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled. For more information about introspection, see GraphQL introspection.
        public let introspectionConfig: GraphQLApiIntrospectionConfig?
        /// Configuration for Lambda function authorization.
        public let lambdaAuthorizerConfig: LambdaAuthorizerConfig?
        /// The Amazon CloudWatch Logs configuration.
        public let logConfig: LogConfig?
        /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
        public let mergedApiExecutionRoleArn: String?
        /// A user-supplied name for the GraphqlApi.
        public let name: String
        /// The OIDC configuration.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
        public let ownerContact: String?
        /// The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is 0 (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between 1 and 75 nested levels. This field will produce a limit error if the operation falls out of bounds. Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.
        public let queryDepthLimit: Int?
        /// The maximum number of resolvers that can be invoked in a single request. The default value is 0 (or unspecified), which will set the limit to 10000. When specified, the limit value can be between 1 and 10000. This field will produce a limit error if the operation falls out of bounds.
        public let resolverCountLimit: Int?
        /// A TagMap object.
        public let tags: [String: String]?
        /// The Amazon Cognito user pool configuration.
        public let userPoolConfig: UserPoolConfig?
        /// Sets the value of the GraphQL API to public (GLOBAL) or private (PRIVATE). If no value is provided, the visibility will be set to GLOBAL by default. This value cannot be changed once the API has been created.
        public let visibility: GraphQLApiVisibility?
        /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
        public let xrayEnabled: Bool?

        public init(additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil, apiType: GraphQLApiType? = nil, authenticationType: AuthenticationType, enhancedMetricsConfig: EnhancedMetricsConfig? = nil, introspectionConfig: GraphQLApiIntrospectionConfig? = nil, lambdaAuthorizerConfig: LambdaAuthorizerConfig? = nil, logConfig: LogConfig? = nil, mergedApiExecutionRoleArn: String? = nil, name: String, openIDConnectConfig: OpenIDConnectConfig? = nil, ownerContact: String? = nil, queryDepthLimit: Int? = nil, resolverCountLimit: Int? = nil, tags: [String: String]? = nil, userPoolConfig: UserPoolConfig? = nil, visibility: GraphQLApiVisibility? = nil, xrayEnabled: Bool? = nil) {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiType = apiType
            self.authenticationType = authenticationType
            self.enhancedMetricsConfig = enhancedMetricsConfig
            self.introspectionConfig = introspectionConfig
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.ownerContact = ownerContact
            self.queryDepthLimit = queryDepthLimit
            self.resolverCountLimit = resolverCountLimit
            self.tags = tags
            self.userPoolConfig = userPoolConfig
            self.visibility = visibility
            self.xrayEnabled = xrayEnabled
        }

        public func validate(name: String) throws {
            try self.additionalAuthenticationProviders?.forEach {
                try $0.validate(name: "\(name).additionalAuthenticationProviders[]")
            }
            try self.lambdaAuthorizerConfig?.validate(name: "\(name).lambdaAuthorizerConfig")
            try self.validate(self.queryDepthLimit, name: "queryDepthLimit", parent: name, max: 75)
            try self.validate(self.queryDepthLimit, name: "queryDepthLimit", parent: name, min: 0)
            try self.validate(self.resolverCountLimit, name: "resolverCountLimit", parent: name, max: 10000)
            try self.validate(self.resolverCountLimit, name: "resolverCountLimit", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[ a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthenticationProviders = "additionalAuthenticationProviders"
            case apiType = "apiType"
            case authenticationType = "authenticationType"
            case enhancedMetricsConfig = "enhancedMetricsConfig"
            case introspectionConfig = "introspectionConfig"
            case lambdaAuthorizerConfig = "lambdaAuthorizerConfig"
            case logConfig = "logConfig"
            case mergedApiExecutionRoleArn = "mergedApiExecutionRoleArn"
            case name = "name"
            case openIDConnectConfig = "openIDConnectConfig"
            case ownerContact = "ownerContact"
            case queryDepthLimit = "queryDepthLimit"
            case resolverCountLimit = "resolverCountLimit"
            case tags = "tags"
            case userPoolConfig = "userPoolConfig"
            case visibility = "visibility"
            case xrayEnabled = "xrayEnabled"
        }
    }

    public struct CreateGraphqlApiResponse: AWSDecodableShape {
        /// The GraphqlApi.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct CreateResolverRequest: AWSEncodableShape {
        /// The ID for the GraphQL API for which the resolver is being created.
        public let apiId: String
        /// The caching configuration for the resolver.
        public let cachingConfig: CachingConfig?
        /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public let code: String?
        /// The name of the data source for which the resolver is being created.
        public let dataSourceName: String?
        /// The name of the field to attach the resolver to.
        public let fieldName: String
        /// The resolver type.    UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.    PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
        public let kind: ResolverKind?
        /// The maximum batching size for a resolver.
        public let maxBatchSize: Int?
        /// Enables or disables enhanced resolver metrics for specified resolvers. Note that metricsConfig won't be used unless the resolverLevelMetricsBehavior value is set to PER_RESOLVER_METRICS. If the resolverLevelMetricsBehavior is set to FULL_REQUEST_RESOLVER_METRICS instead, metricsConfig will be ignored. However, you can still set its value.  metricsConfig can be ENABLED or DISABLED.
        public let metricsConfig: ResolverLevelMetricsConfig?
        /// The PipelineConfig.
        public let pipelineConfig: PipelineConfig?
        /// The mapping template to use for requests. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
        public let requestMappingTemplate: String?
        /// The mapping template to use for responses from the data source.
        public let responseMappingTemplate: String?
        public let runtime: AppSyncRuntime?
        /// The SyncConfig for a resolver attached to a versioned data source.
        public let syncConfig: SyncConfig?
        /// The name of the Type.
        public let typeName: String

        public init(apiId: String, cachingConfig: CachingConfig? = nil, code: String? = nil, dataSourceName: String? = nil, fieldName: String, kind: ResolverKind? = nil, maxBatchSize: Int? = nil, metricsConfig: ResolverLevelMetricsConfig? = nil, pipelineConfig: PipelineConfig? = nil, requestMappingTemplate: String? = nil, responseMappingTemplate: String? = nil, runtime: AppSyncRuntime? = nil, syncConfig: SyncConfig? = nil, typeName: String) {
            self.apiId = apiId
            self.cachingConfig = cachingConfig
            self.code = code
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.maxBatchSize = maxBatchSize
            self.metricsConfig = metricsConfig
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.cachingConfig, forKey: .cachingConfig)
            try container.encodeIfPresent(self.code, forKey: .code)
            try container.encodeIfPresent(self.dataSourceName, forKey: .dataSourceName)
            try container.encode(self.fieldName, forKey: .fieldName)
            try container.encodeIfPresent(self.kind, forKey: .kind)
            try container.encodeIfPresent(self.maxBatchSize, forKey: .maxBatchSize)
            try container.encodeIfPresent(self.metricsConfig, forKey: .metricsConfig)
            try container.encodeIfPresent(self.pipelineConfig, forKey: .pipelineConfig)
            try container.encodeIfPresent(self.requestMappingTemplate, forKey: .requestMappingTemplate)
            try container.encodeIfPresent(self.responseMappingTemplate, forKey: .responseMappingTemplate)
            try container.encodeIfPresent(self.runtime, forKey: .runtime)
            try container.encodeIfPresent(self.syncConfig, forKey: .syncConfig)
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 32768)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, max: 2000)
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, min: 0)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, pattern: "^.*$")
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, pattern: "^.*$")
            try self.validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try self.validate(self.typeName, name: "typeName", parent: name, min: 1)
            try self.validate(self.typeName, name: "typeName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case cachingConfig = "cachingConfig"
            case code = "code"
            case dataSourceName = "dataSourceName"
            case fieldName = "fieldName"
            case kind = "kind"
            case maxBatchSize = "maxBatchSize"
            case metricsConfig = "metricsConfig"
            case pipelineConfig = "pipelineConfig"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
            case runtime = "runtime"
            case syncConfig = "syncConfig"
        }
    }

    public struct CreateResolverResponse: AWSDecodableShape {
        /// The Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct CreateTypeRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The type definition, in GraphQL Schema Definition Language (SDL) format. For more information, see the GraphQL SDL documentation.
        public let definition: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat

        public init(apiId: String, definition: String, format: TypeDefinitionFormat) {
            self.apiId = apiId
            self.definition = definition
            self.format = format
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encode(self.definition, forKey: .definition)
            try container.encode(self.format, forKey: .format)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case format = "format"
        }
    }

    public struct CreateTypeResponse: AWSDecodableShape {
        /// The Type object.
        public let type: `Type`?

        public init(type: `Type`? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The data source Amazon Resource Name (ARN).
        public let dataSourceArn: String?
        /// The description of the data source.
        public let description: String?
        /// DynamoDB settings.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// Amazon OpenSearch Service settings.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// Amazon EventBridge settings.
        public let eventBridgeConfig: EventBridgeDataSourceConfig?
        /// HTTP endpoint settings.
        public let httpConfig: HttpDataSourceConfig?
        /// Lambda settings.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// Enables or disables enhanced data source metrics for specified data sources. Note that metricsConfig won't be used unless the dataSourceLevelMetricsBehavior value is set to PER_DATA_SOURCE_METRICS. If the dataSourceLevelMetricsBehavior is set to FULL_REQUEST_DATA_SOURCE_METRICS instead, metricsConfig will be ignored. However, you can still set its value.  metricsConfig can be ENABLED or DISABLED.
        public let metricsConfig: DataSourceLevelMetricsConfig?
        /// The name of the data source.
        public let name: String?
        /// Amazon OpenSearch Service settings.
        public let openSearchServiceConfig: OpenSearchServiceDataSourceConfig?
        /// Relational database settings.
        public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
        /// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
        public let serviceRoleArn: String?
        /// The type of the data source.    AWS_LAMBDA: The data source is an Lambda function.    AMAZON_DYNAMODB: The data source is an Amazon DynamoDB table.    AMAZON_ELASTICSEARCH: The data source is an Amazon OpenSearch Service domain.    AMAZON_OPENSEARCH_SERVICE: The data source is an Amazon OpenSearch Service domain.    AMAZON_EVENTBRIDGE: The data source is an Amazon EventBridge configuration.    NONE: There is no data source. Use this type when you want to invoke a GraphQL operation without connecting to a data source, such as when you're performing data transformation with resolvers or invoking a subscription from a mutation.    HTTP: The data source is an HTTP endpoint.    RELATIONAL_DATABASE: The data source is a relational database.
        public let type: DataSourceType?

        public init(dataSourceArn: String? = nil, description: String? = nil, dynamodbConfig: DynamodbDataSourceConfig? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, eventBridgeConfig: EventBridgeDataSourceConfig? = nil, httpConfig: HttpDataSourceConfig? = nil, lambdaConfig: LambdaDataSourceConfig? = nil, metricsConfig: DataSourceLevelMetricsConfig? = nil, name: String? = nil, openSearchServiceConfig: OpenSearchServiceDataSourceConfig? = nil, relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil, serviceRoleArn: String? = nil, type: DataSourceType? = nil) {
            self.dataSourceArn = dataSourceArn
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.eventBridgeConfig = eventBridgeConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.metricsConfig = metricsConfig
            self.name = name
            self.openSearchServiceConfig = openSearchServiceConfig
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "dataSourceArn"
            case description = "description"
            case dynamodbConfig = "dynamodbConfig"
            case elasticsearchConfig = "elasticsearchConfig"
            case eventBridgeConfig = "eventBridgeConfig"
            case httpConfig = "httpConfig"
            case lambdaConfig = "lambdaConfig"
            case metricsConfig = "metricsConfig"
            case name = "name"
            case openSearchServiceConfig = "openSearchServiceConfig"
            case relationalDatabaseConfig = "relationalDatabaseConfig"
            case serviceRoleArn = "serviceRoleArn"
            case type = "type"
        }
    }

    public struct DataSourceIntrospectionModel: AWSDecodableShape {
        /// The DataSourceIntrospectionModelField object data.
        public let fields: [DataSourceIntrospectionModelField]?
        /// The array of DataSourceIntrospectionModelIndex objects.
        public let indexes: [DataSourceIntrospectionModelIndex]?
        /// The name of the model. For example, this could be the name of a single table in a database.
        public let name: String?
        /// The primary key stored as a DataSourceIntrospectionModelIndex object.
        public let primaryKey: DataSourceIntrospectionModelIndex?
        /// Contains the output of the SDL that was generated from the introspected types. This is controlled by the includeModelsSDL parameter of the GetDataSourceIntrospection operation.
        public let sdl: String?

        public init(fields: [DataSourceIntrospectionModelField]? = nil, indexes: [DataSourceIntrospectionModelIndex]? = nil, name: String? = nil, primaryKey: DataSourceIntrospectionModelIndex? = nil, sdl: String? = nil) {
            self.fields = fields
            self.indexes = indexes
            self.name = name
            self.primaryKey = primaryKey
            self.sdl = sdl
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case indexes = "indexes"
            case name = "name"
            case primaryKey = "primaryKey"
            case sdl = "sdl"
        }
    }

    public struct DataSourceIntrospectionModelField: AWSDecodableShape {
        /// The length value of the introspected field.
        public let length: Int64?
        /// The name of the field that was retrieved from the introspected data.
        public let name: String?
        /// The DataSourceIntrospectionModelFieldType object data.
        public let type: DataSourceIntrospectionModelFieldType?

        public init(length: Int64? = nil, name: String? = nil, type: DataSourceIntrospectionModelFieldType? = nil) {
            self.length = length
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case length = "length"
            case name = "name"
            case type = "type"
        }
    }

    public final class DataSourceIntrospectionModelFieldType: AWSDecodableShape {
        /// Specifies the classification of data. For example, this could be set to values like Scalar or NonNull to indicate a fundamental property of the field. Valid values include:    Scalar: Indicates the value is a primitive type (scalar).    NonNull: Indicates the field cannot be null.    List: Indicates the field contains a list.
        public let kind: String?
        /// The name of the data type that represents the field. For example, String is a valid name value.
        public let name: String?
        /// The DataSourceIntrospectionModelFieldType object data. The type is only present if DataSourceIntrospectionModelFieldType.kind is set to NonNull or List.  The type typically contains its own kind and name fields to represent the actual type data. For instance, type could contain a kind value of Scalar with a name value of String. The values Scalar and String will be collectively stored in the values field.
        public let type: DataSourceIntrospectionModelFieldType?
        /// The values of the type field. This field represents the AppSync data type equivalent of the introspected field.
        public let values: [String]?

        public init(kind: String? = nil, name: String? = nil, type: DataSourceIntrospectionModelFieldType? = nil, values: [String]? = nil) {
            self.kind = kind
            self.name = name
            self.type = type
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case kind = "kind"
            case name = "name"
            case type = "type"
            case values = "values"
        }
    }

    public struct DataSourceIntrospectionModelIndex: AWSDecodableShape {
        /// The fields of the index.
        public let fields: [String]?
        /// The name of the index.
        public let name: String?

        public init(fields: [String]? = nil, name: String? = nil) {
            self.fields = fields
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case name = "name"
        }
    }

    public struct DataSourceIntrospectionResult: AWSDecodableShape {
        /// The array of DataSourceIntrospectionModel objects.
        public let models: [DataSourceIntrospectionModel]?
        /// Determines the number of types to be returned in a single response before paginating. This value is typically taken from nextToken value from the previous response.
        public let nextToken: String?

        public init(models: [DataSourceIntrospectionModel]? = nil, nextToken: String? = nil) {
            self.models = models
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case models = "models"
            case nextToken = "nextToken"
        }
    }

    public struct DeleteApiCacheRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApiCacheResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteApiKeyRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The ID for the API key.
        public let id: String

        public init(apiId: String, id: String) {
            self.apiId = apiId
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApiKeyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The name of the data source.
        public let name: String

        public init(apiId: String, name: String) {
            self.apiId = apiId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 65536)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDomainNameRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(\\*[\\w\\d-]*\\.)?([\\w\\d-]+\\.)+[\\w\\d-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainNameResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFunctionRequest: AWSEncodableShape {
        /// The GraphQL API ID.
        public let apiId: String
        /// The Function ID.
        public let functionId: String

        public init(apiId: String, functionId: String) {
            self.apiId = apiId
            self.functionId = functionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.functionId, key: "functionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionId, name: "functionId", parent: name, max: 65536)
            try self.validate(self.functionId, name: "functionId", parent: name, min: 1)
            try self.validate(self.functionId, name: "functionId", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGraphqlApiRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGraphqlApiResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResolverRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The resolver field name.
        public let fieldName: String
        /// The name of the resolver type.
        public let typeName: String

        public init(apiId: String, fieldName: String, typeName: String) {
            self.apiId = apiId
            self.fieldName = fieldName
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.fieldName, key: "fieldName")
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try self.validate(self.typeName, name: "typeName", parent: name, min: 1)
            try self.validate(self.typeName, name: "typeName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResolverResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTypeRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The type name.
        public let typeName: String

        public init(apiId: String, typeName: String) {
            self.apiId = apiId
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try self.validate(self.typeName, name: "typeName", parent: name, min: 1)
            try self.validate(self.typeName, name: "typeName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTypeResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeltaSyncConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of minutes that an Item is stored in the data source.
        public let baseTableTTL: Int64?
        /// The Delta Sync table name.
        public let deltaSyncTableName: String?
        /// The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
        public let deltaSyncTableTTL: Int64?

        public init(baseTableTTL: Int64? = nil, deltaSyncTableName: String? = nil, deltaSyncTableTTL: Int64? = nil) {
            self.baseTableTTL = baseTableTTL
            self.deltaSyncTableName = deltaSyncTableName
            self.deltaSyncTableTTL = deltaSyncTableTTL
        }

        private enum CodingKeys: String, CodingKey {
            case baseTableTTL = "baseTableTTL"
            case deltaSyncTableName = "deltaSyncTableName"
            case deltaSyncTableTTL = "deltaSyncTableTTL"
        }
    }

    public struct DisassociateApiRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(\\*[\\w\\d-]*\\.)?([\\w\\d-]+\\.)+[\\w\\d-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateApiResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMergedGraphqlApiRequest: AWSEncodableShape {
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String
        /// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
        public let sourceApiIdentifier: String

        public init(associationId: String, sourceApiIdentifier: String) {
            self.associationId = associationId
            self.sourceApiIdentifier = sourceApiIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "associationId")
            request.encodePath(self.sourceApiIdentifier, key: "sourceApiIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMergedGraphqlApiResponse: AWSDecodableShape {
        /// The state of the source API association.
        public let sourceApiAssociationStatus: SourceApiAssociationStatus?

        public init(sourceApiAssociationStatus: SourceApiAssociationStatus? = nil) {
            self.sourceApiAssociationStatus = sourceApiAssociationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case sourceApiAssociationStatus = "sourceApiAssociationStatus"
        }
    }

    public struct DisassociateSourceGraphqlApiRequest: AWSEncodableShape {
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String
        /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
        public let mergedApiIdentifier: String

        public init(associationId: String, mergedApiIdentifier: String) {
            self.associationId = associationId
            self.mergedApiIdentifier = mergedApiIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "associationId")
            request.encodePath(self.mergedApiIdentifier, key: "mergedApiIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateSourceGraphqlApiResponse: AWSDecodableShape {
        /// The state of the source API association.
        public let sourceApiAssociationStatus: SourceApiAssociationStatus?

        public init(sourceApiAssociationStatus: SourceApiAssociationStatus? = nil) {
            self.sourceApiAssociationStatus = sourceApiAssociationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case sourceApiAssociationStatus = "sourceApiAssociationStatus"
        }
    }

    public struct DomainNameConfig: AWSDecodableShape {
        /// The domain name that AppSync provides.
        public let appsyncDomainName: String?
        /// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
        public let certificateArn: String?
        /// A description of the DomainName configuration.
        public let description: String?
        /// The domain name.
        public let domainName: String?
        /// The ID of your Amazon Route 53 hosted zone.
        public let hostedZoneId: String?

        public init(appsyncDomainName: String? = nil, certificateArn: String? = nil, description: String? = nil, domainName: String? = nil, hostedZoneId: String? = nil) {
            self.appsyncDomainName = appsyncDomainName
            self.certificateArn = certificateArn
            self.description = description
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }

        private enum CodingKeys: String, CodingKey {
            case appsyncDomainName = "appsyncDomainName"
            case certificateArn = "certificateArn"
            case description = "description"
            case domainName = "domainName"
            case hostedZoneId = "hostedZoneId"
        }
    }

    public struct DynamodbDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Region.
        public let awsRegion: String
        /// The DeltaSyncConfig for a versioned data source.
        public let deltaSyncConfig: DeltaSyncConfig?
        /// The table name.
        public let tableName: String
        /// Set to TRUE to use Amazon Cognito credentials with this data source.
        public let useCallerCredentials: Bool?
        /// Set to TRUE to use Conflict Detection and Resolution with this data source.
        public let versioned: Bool?

        public init(awsRegion: String, deltaSyncConfig: DeltaSyncConfig? = nil, tableName: String, useCallerCredentials: Bool? = nil, versioned: Bool? = nil) {
            self.awsRegion = awsRegion
            self.deltaSyncConfig = deltaSyncConfig
            self.tableName = tableName
            self.useCallerCredentials = useCallerCredentials
            self.versioned = versioned
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case deltaSyncConfig = "deltaSyncConfig"
            case tableName = "tableName"
            case useCallerCredentials = "useCallerCredentials"
            case versioned = "versioned"
        }
    }

    public struct ElasticsearchDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Region.
        public let awsRegion: String
        /// The endpoint.
        public let endpoint: String

        public init(awsRegion: String, endpoint: String) {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case endpoint = "endpoint"
        }
    }

    public struct EnhancedMetricsConfig: AWSEncodableShape & AWSDecodableShape {
        /// Controls how data source metrics will be emitted to CloudWatch. Data source metrics include:   Requests: The number of invocations that occured during a request.   Latency: The time to complete a data source invocation.   Errors:  The number of errors that occurred during a data source invocation.   These metrics can be emitted to CloudWatch per data source or for all data sources in the request. Metrics will be recorded by API ID and data source name. dataSourceLevelMetricsBehavior accepts one of these values at a time:    FULL_REQUEST_DATA_SOURCE_METRICS: Records and emits metric data for all data sources in the request.    PER_DATA_SOURCE_METRICS: Records and emits metric data for data sources that have the metricsConfig value set to ENABLED.
        public let dataSourceLevelMetricsBehavior: DataSourceLevelMetricsBehavior
        ///  Controls how operation metrics will be emitted to CloudWatch. Operation metrics include:   Requests: The number of times a specified GraphQL operation was called.   GraphQL errors: The number of GraphQL errors that occurred during a specified GraphQL operation.   Metrics will be recorded by API ID and operation name. You can set the value to ENABLED or DISABLED.
        public let operationLevelMetricsConfig: OperationLevelMetricsConfig
        /// Controls how resolver metrics will be emitted to CloudWatch. Resolver metrics include:   GraphQL errors: The number of GraphQL errors that occurred.   Requests: The number of invocations that occurred during a request.    Latency: The time to complete a resolver invocation.   Cache hits: The number of cache hits during a request.   Cache misses: The number of cache misses during a request.   These metrics can be emitted to CloudWatch per resolver or for all resolvers in the request. Metrics will be recorded by API ID and resolver name. resolverLevelMetricsBehavior accepts one of these values at a time:    FULL_REQUEST_RESOLVER_METRICS: Records and emits metric data for all resolvers in the request.    PER_RESOLVER_METRICS: Records and emits metric data for resolvers that have the metricsConfig value set to ENABLED.
        public let resolverLevelMetricsBehavior: ResolverLevelMetricsBehavior

        public init(dataSourceLevelMetricsBehavior: DataSourceLevelMetricsBehavior, operationLevelMetricsConfig: OperationLevelMetricsConfig, resolverLevelMetricsBehavior: ResolverLevelMetricsBehavior) {
            self.dataSourceLevelMetricsBehavior = dataSourceLevelMetricsBehavior
            self.operationLevelMetricsConfig = operationLevelMetricsConfig
            self.resolverLevelMetricsBehavior = resolverLevelMetricsBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceLevelMetricsBehavior = "dataSourceLevelMetricsBehavior"
            case operationLevelMetricsConfig = "operationLevelMetricsConfig"
            case resolverLevelMetricsBehavior = "resolverLevelMetricsBehavior"
        }
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// The error payload.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct EvaluateCodeErrorDetail: AWSDecodableShape {
        /// Contains the list of CodeError objects.
        public let codeErrors: [CodeError]?
        /// The error payload.
        public let message: String?

        public init(codeErrors: [CodeError]? = nil, message: String? = nil) {
            self.codeErrors = codeErrors
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case codeErrors = "codeErrors"
            case message = "message"
        }
    }

    public struct EvaluateCodeRequest: AWSEncodableShape {
        /// The code definition to be evaluated. Note that code and runtime are both required for this action. The runtime value must be APPSYNC_JS.
        public let code: String
        /// The map that holds all of the contextual information for your resolver invocation. A context is required for this action.
        public let context: String
        /// The function within the code to be evaluated. If provided, the valid values are request and response.
        public let function: String?
        /// The runtime to be used when evaluating the code. Currently, only the APPSYNC_JS runtime is supported.
        public let runtime: AppSyncRuntime

        public init(code: String, context: String, function: String? = nil, runtime: AppSyncRuntime) {
            self.code = code
            self.context = context
            self.function = function
            self.runtime = runtime
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 32768)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.context, name: "context", parent: name, max: 28000)
            try self.validate(self.context, name: "context", parent: name, min: 2)
            try self.validate(self.context, name: "context", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case context = "context"
            case function = "function"
            case runtime = "runtime"
        }
    }

    public struct EvaluateCodeResponse: AWSDecodableShape {
        /// Contains the payload of the response error.
        public let error: EvaluateCodeErrorDetail?
        /// The result of the evaluation operation.
        public let evaluationResult: String?
        /// A list of logs that were generated by calls to util.log.info and util.log.error in the evaluated code.
        public let logs: [String]?

        public init(error: EvaluateCodeErrorDetail? = nil, evaluationResult: String? = nil, logs: [String]? = nil) {
            self.error = error
            self.evaluationResult = evaluationResult
            self.logs = logs
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case evaluationResult = "evaluationResult"
            case logs = "logs"
        }
    }

    public struct EvaluateMappingTemplateRequest: AWSEncodableShape {
        /// The map that holds all of the contextual information for your resolver invocation. A context is required for this action.
        public let context: String
        /// The mapping template; this can be a request or response template. A template is required for this action.
        public let template: String

        public init(context: String, template: String) {
            self.context = context
            self.template = template
        }

        public func validate(name: String) throws {
            try self.validate(self.context, name: "context", parent: name, max: 28000)
            try self.validate(self.context, name: "context", parent: name, min: 2)
            try self.validate(self.context, name: "context", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.template, name: "template", parent: name, max: 65536)
            try self.validate(self.template, name: "template", parent: name, min: 2)
            try self.validate(self.template, name: "template", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case template = "template"
        }
    }

    public struct EvaluateMappingTemplateResponse: AWSDecodableShape {
        /// The ErrorDetail object.
        public let error: ErrorDetail?
        /// The mapping template; this can be a request or response template.
        public let evaluationResult: String?
        /// A list of logs that were generated by calls to util.log.info and util.log.error in the evaluated code.
        public let logs: [String]?

        public init(error: ErrorDetail? = nil, evaluationResult: String? = nil, logs: [String]? = nil) {
            self.error = error
            self.evaluationResult = evaluationResult
            self.logs = logs
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case evaluationResult = "evaluationResult"
            case logs = "logs"
        }
    }

    public struct EventBridgeDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the event bus. For more information about event buses, see Amazon EventBridge event buses.
        public let eventBusArn: String

        public init(eventBusArn: String) {
            self.eventBusArn = eventBusArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventBusArn = "eventBusArn"
        }
    }

    public struct FlushApiCacheRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct FlushApiCacheResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FunctionConfiguration: AWSDecodableShape {
        /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public let code: String?
        /// The name of the DataSource.
        public let dataSourceName: String?
        /// The Function description.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the Function object.
        public let functionArn: String?
        /// A unique ID representing the Function object.
        public let functionId: String?
        /// The version of the request mapping template. Currently, only the 2018-05-29 version of the template is supported.
        public let functionVersion: String?
        /// The maximum batching size for a resolver.
        public let maxBatchSize: Int?
        /// The name of the Function object.
        public let name: String?
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public let requestMappingTemplate: String?
        /// The Function response mapping template.
        public let responseMappingTemplate: String?
        public let runtime: AppSyncRuntime?
        public let syncConfig: SyncConfig?

        public init(code: String? = nil, dataSourceName: String? = nil, description: String? = nil, functionArn: String? = nil, functionId: String? = nil, functionVersion: String? = nil, maxBatchSize: Int? = nil, name: String? = nil, requestMappingTemplate: String? = nil, responseMappingTemplate: String? = nil, runtime: AppSyncRuntime? = nil, syncConfig: SyncConfig? = nil) {
            self.code = code
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionArn = functionArn
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.maxBatchSize = maxBatchSize
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case dataSourceName = "dataSourceName"
            case description = "description"
            case functionArn = "functionArn"
            case functionId = "functionId"
            case functionVersion = "functionVersion"
            case maxBatchSize = "maxBatchSize"
            case name = "name"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
            case runtime = "runtime"
            case syncConfig = "syncConfig"
        }
    }

    public struct GetApiAssociationRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(\\*[\\w\\d-]*\\.)?([\\w\\d-]+\\.)+[\\w\\d-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApiAssociationResponse: AWSDecodableShape {
        /// The ApiAssociation object.
        public let apiAssociation: ApiAssociation?

        public init(apiAssociation: ApiAssociation? = nil) {
            self.apiAssociation = apiAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case apiAssociation = "apiAssociation"
        }
    }

    public struct GetApiCacheRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApiCacheResponse: AWSDecodableShape {
        /// The ApiCache object.
        public let apiCache: ApiCache?

        public init(apiCache: ApiCache? = nil) {
            self.apiCache = apiCache
        }

        private enum CodingKeys: String, CodingKey {
            case apiCache = "apiCache"
        }
    }

    public struct GetDataSourceIntrospectionRequest: AWSEncodableShape {
        /// A boolean flag that determines whether SDL should be generated for introspected types or not. If set to true, each model will contain an sdl property that contains the SDL for that type. The SDL only contains the type data and no additional metadata or directives.
        public let includeModelsSDL: Bool?
        /// The introspection ID. Each introspection contains a unique ID that can be used to reference the instrospection record.
        public let introspectionId: String
        /// The maximum number of introspected types that will be returned in a single response.
        public let maxResults: Int?
        /// Determines the number of types to be returned in a single response before paginating. This value is typically taken from nextToken value from the previous response.
        public let nextToken: String?

        public init(includeModelsSDL: Bool? = nil, introspectionId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeModelsSDL = includeModelsSDL
            self.introspectionId = introspectionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeModelsSDL, key: "includeModelsSDL")
            request.encodePath(self.introspectionId, key: "introspectionId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceIntrospectionResponse: AWSDecodableShape {
        /// The introspection ID. Each introspection contains a unique ID that can be used to reference the instrospection record.
        public let introspectionId: String?
        /// The DataSourceIntrospectionResult object data.
        public let introspectionResult: DataSourceIntrospectionResult?
        /// The status of the introspection during retrieval. By default, when a new instrospection is being retrieved, the status will be set to PROCESSING. Once the operation has been completed, the status will change to SUCCESS or FAILED depending on how the data was parsed. A FAILED operation will return an error and its details as an introspectionStatusDetail.
        public let introspectionStatus: DataSourceIntrospectionStatus?
        /// The error detail field. When a FAILED introspectionStatus is returned, the introspectionStatusDetail will also return the exact error that was generated during the operation.
        public let introspectionStatusDetail: String?

        public init(introspectionId: String? = nil, introspectionResult: DataSourceIntrospectionResult? = nil, introspectionStatus: DataSourceIntrospectionStatus? = nil, introspectionStatusDetail: String? = nil) {
            self.introspectionId = introspectionId
            self.introspectionResult = introspectionResult
            self.introspectionStatus = introspectionStatus
            self.introspectionStatusDetail = introspectionStatusDetail
        }

        private enum CodingKeys: String, CodingKey {
            case introspectionId = "introspectionId"
            case introspectionResult = "introspectionResult"
            case introspectionStatus = "introspectionStatus"
            case introspectionStatusDetail = "introspectionStatusDetail"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The name of the data source.
        public let name: String

        public init(apiId: String, name: String) {
            self.apiId = apiId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 65536)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {
        /// The DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct GetDomainNameRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(\\*[\\w\\d-]*\\.)?([\\w\\d-]+\\.)+[\\w\\d-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainNameResponse: AWSDecodableShape {
        /// The configuration for the DomainName.
        public let domainNameConfig: DomainNameConfig?

        public init(domainNameConfig: DomainNameConfig? = nil) {
            self.domainNameConfig = domainNameConfig
        }

        private enum CodingKeys: String, CodingKey {
            case domainNameConfig = "domainNameConfig"
        }
    }

    public struct GetFunctionRequest: AWSEncodableShape {
        /// The GraphQL API ID.
        public let apiId: String
        /// The Function ID.
        public let functionId: String

        public init(apiId: String, functionId: String) {
            self.apiId = apiId
            self.functionId = functionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.functionId, key: "functionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.functionId, name: "functionId", parent: name, max: 65536)
            try self.validate(self.functionId, name: "functionId", parent: name, min: 1)
            try self.validate(self.functionId, name: "functionId", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionResponse: AWSDecodableShape {
        /// The Function object.
        public let functionConfiguration: FunctionConfiguration?

        public init(functionConfiguration: FunctionConfiguration? = nil) {
            self.functionConfiguration = functionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case functionConfiguration = "functionConfiguration"
        }
    }

    public struct GetGraphqlApiEnvironmentVariablesRequest: AWSEncodableShape {
        /// The ID of the API from which the environmental variable list will be retrieved.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphqlApiEnvironmentVariablesResponse: AWSDecodableShape {
        /// The payload containing each environmental variable in the "key" : "value" format.
        public let environmentVariables: [String: String]?

        public init(environmentVariables: [String: String]? = nil) {
            self.environmentVariables = environmentVariables
        }

        private enum CodingKeys: String, CodingKey {
            case environmentVariables = "environmentVariables"
        }
    }

    public struct GetGraphqlApiRequest: AWSEncodableShape {
        /// The API ID for the GraphQL API.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphqlApiResponse: AWSDecodableShape {
        /// The GraphqlApi object.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct GetIntrospectionSchemaRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The schema format: SDL or JSON.
        public let format: OutputType
        /// A flag that specifies whether the schema introspection should contain directives.
        public let includeDirectives: Bool?

        public init(apiId: String, format: OutputType, includeDirectives: Bool? = nil) {
            self.apiId = apiId
            self.format = format
            self.includeDirectives = includeDirectives
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.includeDirectives, key: "includeDirectives")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIntrospectionSchemaResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The schema, in GraphQL Schema Definition Language (SDL) format. For more information, see the GraphQL SDL documentation.
        public let schema: AWSHTTPBody

        public init(schema: AWSHTTPBody) {
            self.schema = schema
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.schema = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResolverRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The resolver field name.
        public let fieldName: String
        /// The resolver type name.
        public let typeName: String

        public init(apiId: String, fieldName: String, typeName: String) {
            self.apiId = apiId
            self.fieldName = fieldName
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.fieldName, key: "fieldName")
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try self.validate(self.typeName, name: "typeName", parent: name, min: 1)
            try self.validate(self.typeName, name: "typeName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResolverResponse: AWSDecodableShape {
        /// The Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct GetSchemaCreationStatusRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaCreationStatusResponse: AWSDecodableShape {
        /// Detailed information about the status of the schema creation operation.
        public let details: String?
        /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
        public let status: SchemaStatus?

        public init(details: String? = nil, status: SchemaStatus? = nil) {
            self.details = details
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case status = "status"
        }
    }

    public struct GetSourceApiAssociationRequest: AWSEncodableShape {
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String
        /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
        public let mergedApiIdentifier: String

        public init(associationId: String, mergedApiIdentifier: String) {
            self.associationId = associationId
            self.mergedApiIdentifier = mergedApiIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "associationId")
            request.encodePath(self.mergedApiIdentifier, key: "mergedApiIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSourceApiAssociationResponse: AWSDecodableShape {
        /// The SourceApiAssociation object data.
        public let sourceApiAssociation: SourceApiAssociation?

        public init(sourceApiAssociation: SourceApiAssociation? = nil) {
            self.sourceApiAssociation = sourceApiAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case sourceApiAssociation = "sourceApiAssociation"
        }
    }

    public struct GetTypeRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat
        /// The type name.
        public let typeName: String

        public init(apiId: String, format: TypeDefinitionFormat, typeName: String) {
            self.apiId = apiId
            self.format = format
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.format, key: "format")
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try self.validate(self.typeName, name: "typeName", parent: name, min: 1)
            try self.validate(self.typeName, name: "typeName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTypeResponse: AWSDecodableShape {
        /// The Type object.
        public let type: `Type`?

        public init(type: `Type`? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct GraphqlApi: AWSDecodableShape {
        /// A list of additional authentication providers for the GraphqlApi API.
        public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
        /// The API ID.
        public let apiId: String?
        /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
        public let apiType: GraphQLApiType?
        /// The Amazon Resource Name (ARN).
        public let arn: String?
        /// The authentication type.
        public let authenticationType: AuthenticationType?
        /// The DNS records for the API.
        public let dns: [String: String]?
        /// The enhancedMetricsConfig object.
        public let enhancedMetricsConfig: EnhancedMetricsConfig?
        /// Sets the value of the GraphQL API to enable (ENABLED) or disable (DISABLED) introspection. If no value is provided, the introspection configuration will be set to ENABLED by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled. For more information about introspection, see GraphQL introspection.
        public let introspectionConfig: GraphQLApiIntrospectionConfig?
        /// Configuration for Lambda function authorization.
        public let lambdaAuthorizerConfig: LambdaAuthorizerConfig?
        /// The Amazon CloudWatch Logs configuration.
        public let logConfig: LogConfig?
        /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
        public let mergedApiExecutionRoleArn: String?
        /// The API name.
        public let name: String?
        /// The OpenID Connect configuration.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// The account owner of the GraphQL API.
        public let owner: String?
        /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
        public let ownerContact: String?
        /// The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is 0 (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between 1 and 75 nested levels. This field will produce a limit error if the operation falls out of bounds. Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.
        public let queryDepthLimit: Int?
        /// The maximum number of resolvers that can be invoked in a single request. The default value is 0 (or unspecified), which will set the limit to 10000. When specified, the limit value can be between 1 and 10000. This field will produce a limit error if the operation falls out of bounds.
        public let resolverCountLimit: Int?
        /// The tags.
        public let tags: [String: String]?
        /// The URIs.
        public let uris: [String: String]?
        /// The Amazon Cognito user pool configuration.
        public let userPoolConfig: UserPoolConfig?
        /// Sets the value of the GraphQL API to public (GLOBAL) or private (PRIVATE). If no value is provided, the visibility will be set to GLOBAL by default. This value cannot be changed once the API has been created.
        public let visibility: GraphQLApiVisibility?
        /// The ARN of the WAF access control list (ACL) associated with this GraphqlApi, if one exists.
        public let wafWebAclArn: String?
        /// A flag indicating whether to use X-Ray tracing for this GraphqlApi.
        public let xrayEnabled: Bool?

        public init(additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil, apiId: String? = nil, apiType: GraphQLApiType? = nil, arn: String? = nil, authenticationType: AuthenticationType? = nil, dns: [String: String]? = nil, enhancedMetricsConfig: EnhancedMetricsConfig? = nil, introspectionConfig: GraphQLApiIntrospectionConfig? = nil, lambdaAuthorizerConfig: LambdaAuthorizerConfig? = nil, logConfig: LogConfig? = nil, mergedApiExecutionRoleArn: String? = nil, name: String? = nil, openIDConnectConfig: OpenIDConnectConfig? = nil, owner: String? = nil, ownerContact: String? = nil, queryDepthLimit: Int? = nil, resolverCountLimit: Int? = nil, tags: [String: String]? = nil, uris: [String: String]? = nil, userPoolConfig: UserPoolConfig? = nil, visibility: GraphQLApiVisibility? = nil, wafWebAclArn: String? = nil, xrayEnabled: Bool? = nil) {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.apiType = apiType
            self.arn = arn
            self.authenticationType = authenticationType
            self.dns = dns
            self.enhancedMetricsConfig = enhancedMetricsConfig
            self.introspectionConfig = introspectionConfig
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.owner = owner
            self.ownerContact = ownerContact
            self.queryDepthLimit = queryDepthLimit
            self.resolverCountLimit = resolverCountLimit
            self.tags = tags
            self.uris = uris
            self.userPoolConfig = userPoolConfig
            self.visibility = visibility
            self.wafWebAclArn = wafWebAclArn
            self.xrayEnabled = xrayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthenticationProviders = "additionalAuthenticationProviders"
            case apiId = "apiId"
            case apiType = "apiType"
            case arn = "arn"
            case authenticationType = "authenticationType"
            case dns = "dns"
            case enhancedMetricsConfig = "enhancedMetricsConfig"
            case introspectionConfig = "introspectionConfig"
            case lambdaAuthorizerConfig = "lambdaAuthorizerConfig"
            case logConfig = "logConfig"
            case mergedApiExecutionRoleArn = "mergedApiExecutionRoleArn"
            case name = "name"
            case openIDConnectConfig = "openIDConnectConfig"
            case owner = "owner"
            case ownerContact = "ownerContact"
            case queryDepthLimit = "queryDepthLimit"
            case resolverCountLimit = "resolverCountLimit"
            case tags = "tags"
            case uris = "uris"
            case userPoolConfig = "userPoolConfig"
            case visibility = "visibility"
            case wafWebAclArn = "wafWebAclArn"
            case xrayEnabled = "xrayEnabled"
        }
    }

    public struct HttpDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The authorization configuration in case the HTTP endpoint requires authorization.
        public let authorizationConfig: AuthorizationConfig?
        /// The HTTP URL endpoint. You can specify either the domain name or IP, and port combination, and the URL scheme must be HTTP or HTTPS. If you don't specify the port, AppSync uses the default port 80 for the HTTP endpoint and port 443 for HTTPS endpoints.
        public let endpoint: String?

        public init(authorizationConfig: AuthorizationConfig? = nil, endpoint: String? = nil) {
            self.authorizationConfig = authorizationConfig
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationConfig = "authorizationConfig"
            case endpoint = "endpoint"
        }
    }

    public struct LambdaAuthorizerConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of seconds a response should be cached for. The default is 0 seconds, which disables caching. If you don't specify a value for authorizerResultTtlInSeconds, the default value is used. The maximum value is one hour (3600 seconds). The Lambda function can override this by returning a ttlOverride key in its response.
        public let authorizerResultTtlInSeconds: Int?
        /// The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a standard Lambda ARN, a version ARN (.../v3), or an alias ARN.   Note: This Lambda function must have the following resource-based policy assigned to it. When configuring Lambda authorizers in the console, this is done for you. To use the Command Line Interface (CLI), run the following:  aws lambda add-permission --function-name "arn:aws:lambda:us-east-2:111122223333:function:my-function" --statement-id "appsync" --principal appsync.amazonaws.com --action lambda:InvokeFunction
        public let authorizerUri: String
        /// A regular expression for validation of tokens before the Lambda function is called.
        public let identityValidationExpression: String?

        public init(authorizerResultTtlInSeconds: Int? = nil, authorizerUri: String, identityValidationExpression: String? = nil) {
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.identityValidationExpression = identityValidationExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizerResultTtlInSeconds, name: "authorizerResultTtlInSeconds", parent: name, max: 3600)
            try self.validate(self.authorizerResultTtlInSeconds, name: "authorizerResultTtlInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
            case authorizerUri = "authorizerUri"
            case identityValidationExpression = "identityValidationExpression"
        }
    }

    public struct LambdaConflictHandlerConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Lambda function to use as the Conflict Handler.
        public let lambdaConflictHandlerArn: String?

        public init(lambdaConflictHandlerArn: String? = nil) {
            self.lambdaConflictHandlerArn = lambdaConflictHandlerArn
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaConflictHandlerArn = "lambdaConflictHandlerArn"
        }
    }

    public struct LambdaDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Lambda function.
        public let lambdaFunctionArn: String

        public init(lambdaFunctionArn: String) {
            self.lambdaFunctionArn = lambdaFunctionArn
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctionArn = "lambdaFunctionArn"
        }
    }

    public struct ListApiKeysRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApiKeysResponse: AWSDecodableShape {
        /// The ApiKey objects.
        public let apiKeys: [ApiKey]?
        /// An identifier to pass in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(apiKeys: [ApiKey]? = nil, nextToken: String? = nil) {
            self.apiKeys = apiKeys
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeys = "apiKeys"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// The DataSource objects.
        public let dataSources: [DataSource]?
        /// An identifier to pass in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(dataSources: [DataSource]? = nil, nextToken: String? = nil) {
            self.dataSources = dataSources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "dataSources"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainNamesRequest: AWSEncodableShape {
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainNamesResponse: AWSDecodableShape {
        /// Lists configurations for multiple domain names.
        public let domainNameConfigs: [DomainNameConfig]?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(domainNameConfigs: [DomainNameConfig]? = nil, nextToken: String? = nil) {
            self.domainNameConfigs = domainNameConfigs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domainNameConfigs = "domainNameConfigs"
            case nextToken = "nextToken"
        }
    }

    public struct ListFunctionsRequest: AWSEncodableShape {
        /// The GraphQL API ID.
        public let apiId: String
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionsResponse: AWSDecodableShape {
        /// A list of Function objects.
        public let functions: [FunctionConfiguration]?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(functions: [FunctionConfiguration]? = nil, nextToken: String? = nil) {
            self.functions = functions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "functions"
            case nextToken = "nextToken"
        }
    }

    public struct ListGraphqlApisRequest: AWSEncodableShape {
        /// The value that indicates whether the GraphQL API is a standard API (GRAPHQL) or merged API (MERGED).
        public let apiType: GraphQLApiType?
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?
        /// The account owner of the GraphQL API.
        public let owner: Ownership?

        public init(apiType: GraphQLApiType? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.apiType = apiType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.apiType, key: "apiType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.owner, key: "owner")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGraphqlApisResponse: AWSDecodableShape {
        /// The GraphqlApi objects.
        public let graphqlApis: [GraphqlApi]?
        /// An identifier to pass in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(graphqlApis: [GraphqlApi]? = nil, nextToken: String? = nil) {
            self.graphqlApis = graphqlApis
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApis = "graphqlApis"
            case nextToken = "nextToken"
        }
    }

    public struct ListResolversByFunctionRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The function ID.
        public let functionId: String
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, functionId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.functionId = functionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodePath(self.functionId, key: "functionId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResolversByFunctionResponse: AWSDecodableShape {
        /// An identifier that you can use to return the next set of items in the list.
        public let nextToken: String?
        /// The list of resolvers.
        public let resolvers: [Resolver]?

        public init(nextToken: String? = nil, resolvers: [Resolver]? = nil) {
            self.nextToken = nextToken
            self.resolvers = resolvers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resolvers = "resolvers"
        }
    }

    public struct ListResolversRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?
        /// The type name.
        public let typeName: String

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil, typeName: String) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResolversResponse: AWSDecodableShape {
        /// An identifier to pass in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// The Resolver objects.
        public let resolvers: [Resolver]?

        public init(nextToken: String? = nil, resolvers: [Resolver]? = nil) {
            self.nextToken = nextToken
            self.resolvers = resolvers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resolvers = "resolvers"
        }
    }

    public struct ListSourceApiAssociationsRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSourceApiAssociationsResponse: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?
        /// The SourceApiAssociationSummary object data.
        public let sourceApiAssociationSummaries: [SourceApiAssociationSummary]?

        public init(nextToken: String? = nil, sourceApiAssociationSummaries: [SourceApiAssociationSummary]? = nil) {
            self.nextToken = nextToken
            self.sourceApiAssociationSummaries = sourceApiAssociationSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sourceApiAssociationSummaries = "sourceApiAssociationSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The GraphqlApi Amazon Resource Name (ARN).
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 75)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 70)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\\d{12}:apis/[0-9A-Za-z_-]{26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A TagMap object.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTypesByAssociationRequest: AWSEncodableShape {
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String
        /// The format type.
        public let format: TypeDefinitionFormat
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
        public let mergedApiIdentifier: String
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(associationId: String, format: TypeDefinitionFormat, maxResults: Int? = nil, mergedApiIdentifier: String, nextToken: String? = nil) {
            self.associationId = associationId
            self.format = format
            self.maxResults = maxResults
            self.mergedApiIdentifier = mergedApiIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "associationId")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.mergedApiIdentifier, key: "mergedApiIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTypesByAssociationResponse: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?
        /// The Type objects.
        public let types: [`Type`]?

        public init(nextToken: String? = nil, types: [`Type`]? = nil) {
            self.nextToken = nextToken
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case types = "types"
        }
    }

    public struct ListTypesRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat
        /// The maximum number of results that you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, format: TypeDefinitionFormat, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.format = format
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            request.encodeQuery(self.format, key: "format")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTypesResponse: AWSDecodableShape {
        /// An identifier to pass in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// The Type objects.
        public let types: [`Type`]?

        public init(nextToken: String? = nil, types: [`Type`]? = nil) {
            self.nextToken = nextToken
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case types = "types"
        }
    }

    public struct LogConfig: AWSEncodableShape & AWSDecodableShape {
        /// The service role that AppSync assumes to publish to CloudWatch logs in your account.
        public let cloudWatchLogsRoleArn: String
        /// Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.
        public let excludeVerboseContent: Bool?
        /// The field logging level. Values can be NONE, ERROR, or ALL.    NONE: No field-level logs are captured.    ERROR: Logs the following information only for the fields that are in error:   The error section in the server response.   Field-level errors.   The generated request/response functions that got resolved for error fields.      ALL: The following information is logged for all fields in the query:   Field-level tracing information.   The generated request/response functions that got resolved for each field.
        public let fieldLogLevel: FieldLogLevel

        public init(cloudWatchLogsRoleArn: String, excludeVerboseContent: Bool? = nil, fieldLogLevel: FieldLogLevel) {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsRoleArn = "cloudWatchLogsRoleArn"
            case excludeVerboseContent = "excludeVerboseContent"
            case fieldLogLevel = "fieldLogLevel"
        }
    }

    public struct OpenIDConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of milliseconds that a token is valid after being authenticated.
        public let authTTL: Int64?
        /// The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that AppSync can validate against multiple client identifiers at a time.
        public let clientId: String?
        /// The number of milliseconds that a token is valid after it's issued to a user.
        public let iatTTL: Int64?
        /// The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of iss in the ID token.
        public let issuer: String

        public init(authTTL: Int64? = nil, clientId: String? = nil, iatTTL: Int64? = nil, issuer: String) {
            self.authTTL = authTTL
            self.clientId = clientId
            self.iatTTL = iatTTL
            self.issuer = issuer
        }

        private enum CodingKeys: String, CodingKey {
            case authTTL = "authTTL"
            case clientId = "clientId"
            case iatTTL = "iatTTL"
            case issuer = "issuer"
        }
    }

    public struct OpenSearchServiceDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Region.
        public let awsRegion: String
        /// The endpoint.
        public let endpoint: String

        public init(awsRegion: String, endpoint: String) {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case endpoint = "endpoint"
        }
    }

    public struct PipelineConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of Function objects.
        public let functions: [String]?

        public init(functions: [String]? = nil) {
            self.functions = functions
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "functions"
        }
    }

    public struct PutGraphqlApiEnvironmentVariablesRequest: AWSEncodableShape {
        /// The ID of the API to which the environmental variable list will be written.
        public let apiId: String
        /// The list of environmental variables to add to the API. When creating an environmental variable key-value pair, it must follow the additional constraints below:   Keys must begin with a letter.   Keys must be at least two characters long.   Keys can only contain letters, numbers, and the underscore character (_).   Values can be up to 512 characters long.   You can configure up to 50 key-value pairs in a GraphQL API.   You can create a list of environmental variables by adding it to the environmentVariables payload as a list in the format {"key1":"value1","key2":"value2", …}. Note that each call of the PutGraphqlApiEnvironmentVariables action will result in the overwriting of the existing environmental variable list of that API. This means the existing environmental variables will be lost. To avoid this, you must include all existing and new environmental variables in the list each time you call this action.
        public let environmentVariables: [String: String]

        public init(apiId: String, environmentVariables: [String: String]) {
            self.apiId = apiId
            self.environmentVariables = environmentVariables
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encode(self.environmentVariables, forKey: .environmentVariables)
        }

        public func validate(name: String) throws {
            try self.environmentVariables.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 64)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 2)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^[A-Za-z]+\\w*$")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 512)
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case environmentVariables = "environmentVariables"
        }
    }

    public struct PutGraphqlApiEnvironmentVariablesResponse: AWSDecodableShape {
        /// The payload containing each environmental variable in the "key" : "value" format.
        public let environmentVariables: [String: String]?

        public init(environmentVariables: [String: String]? = nil) {
            self.environmentVariables = environmentVariables
        }

        private enum CodingKeys: String, CodingKey {
            case environmentVariables = "environmentVariables"
        }
    }

    public struct RdsDataApiConfig: AWSEncodableShape {
        /// The name of the database in the cluster.
        public let databaseName: String
        /// The resource ARN of the RDS cluster.
        public let resourceArn: String
        /// The secret's ARN that was obtained from Secrets Manager. A secret consists of secret information, the secret value, plus metadata about the secret. A secret value can be a string or binary. It typically includes the ARN, secret name and description, policies, tags, encryption key from the Key Management Service, and key rotation data.
        public let secretArn: String

        public init(databaseName: String, resourceArn: String, secretArn: String) {
            self.databaseName = databaseName
            self.resourceArn = resourceArn
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 128)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*:rds:[a-z0-9-]*:\\d{12}:cluster:[0-9A-Za-z_/-]*$")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 2048)
            try self.validate(self.secretArn, name: "secretArn", parent: name, min: 20)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[a-z-]*:secretsmanager:[a-z0-9-]*:\\d{12}:secret:[0-9A-Za-z_/-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case resourceArn = "resourceArn"
            case secretArn = "secretArn"
        }
    }

    public struct RdsHttpEndpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// Amazon Web Services Region for Amazon RDS HTTP endpoint.
        public let awsRegion: String?
        /// Amazon Web Services secret store Amazon Resource Name (ARN) for database credentials.
        public let awsSecretStoreArn: String?
        /// Logical database name.
        public let databaseName: String?
        /// Amazon RDS cluster Amazon Resource Name (ARN).
        public let dbClusterIdentifier: String?
        /// Logical schema name.
        public let schema: String?

        public init(awsRegion: String? = nil, awsSecretStoreArn: String? = nil, databaseName: String? = nil, dbClusterIdentifier: String? = nil, schema: String? = nil) {
            self.awsRegion = awsRegion
            self.awsSecretStoreArn = awsSecretStoreArn
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case awsSecretStoreArn = "awsSecretStoreArn"
            case databaseName = "databaseName"
            case dbClusterIdentifier = "dbClusterIdentifier"
            case schema = "schema"
        }
    }

    public struct RelationalDatabaseDataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Amazon RDS HTTP endpoint settings.
        public let rdsHttpEndpointConfig: RdsHttpEndpointConfig?
        /// Source type for the relational database.    RDS_HTTP_ENDPOINT: The relational database source type is an Amazon Relational Database Service (Amazon RDS) HTTP endpoint.
        public let relationalDatabaseSourceType: RelationalDatabaseSourceType?

        public init(rdsHttpEndpointConfig: RdsHttpEndpointConfig? = nil, relationalDatabaseSourceType: RelationalDatabaseSourceType? = nil) {
            self.rdsHttpEndpointConfig = rdsHttpEndpointConfig
            self.relationalDatabaseSourceType = relationalDatabaseSourceType
        }

        private enum CodingKeys: String, CodingKey {
            case rdsHttpEndpointConfig = "rdsHttpEndpointConfig"
            case relationalDatabaseSourceType = "relationalDatabaseSourceType"
        }
    }

    public struct Resolver: AWSDecodableShape {
        /// The caching configuration for the resolver.
        public let cachingConfig: CachingConfig?
        /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public let code: String?
        /// The resolver data source name.
        public let dataSourceName: String?
        /// The resolver field name.
        public let fieldName: String?
        /// The resolver type.    UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.    PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
        public let kind: ResolverKind?
        /// The maximum batching size for a resolver.
        public let maxBatchSize: Int?
        /// Enables or disables enhanced resolver metrics for specified resolvers. Note that metricsConfig won't be used unless the resolverLevelMetricsBehavior value is set to PER_RESOLVER_METRICS. If the resolverLevelMetricsBehavior is set to FULL_REQUEST_RESOLVER_METRICS instead, metricsConfig will be ignored. However, you can still set its value.  metricsConfig can be ENABLED or DISABLED.
        public let metricsConfig: ResolverLevelMetricsConfig?
        /// The PipelineConfig.
        public let pipelineConfig: PipelineConfig?
        /// The request mapping template.
        public let requestMappingTemplate: String?
        /// The resolver Amazon Resource Name (ARN).
        public let resolverArn: String?
        /// The response mapping template.
        public let responseMappingTemplate: String?
        public let runtime: AppSyncRuntime?
        /// The SyncConfig for a resolver attached to a versioned data source.
        public let syncConfig: SyncConfig?
        /// The resolver type name.
        public let typeName: String?

        public init(cachingConfig: CachingConfig? = nil, code: String? = nil, dataSourceName: String? = nil, fieldName: String? = nil, kind: ResolverKind? = nil, maxBatchSize: Int? = nil, metricsConfig: ResolverLevelMetricsConfig? = nil, pipelineConfig: PipelineConfig? = nil, requestMappingTemplate: String? = nil, resolverArn: String? = nil, responseMappingTemplate: String? = nil, runtime: AppSyncRuntime? = nil, syncConfig: SyncConfig? = nil, typeName: String? = nil) {
            self.cachingConfig = cachingConfig
            self.code = code
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.maxBatchSize = maxBatchSize
            self.metricsConfig = metricsConfig
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.resolverArn = resolverArn
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
            self.typeName = typeName
        }

        private enum CodingKeys: String, CodingKey {
            case cachingConfig = "cachingConfig"
            case code = "code"
            case dataSourceName = "dataSourceName"
            case fieldName = "fieldName"
            case kind = "kind"
            case maxBatchSize = "maxBatchSize"
            case metricsConfig = "metricsConfig"
            case pipelineConfig = "pipelineConfig"
            case requestMappingTemplate = "requestMappingTemplate"
            case resolverArn = "resolverArn"
            case responseMappingTemplate = "responseMappingTemplate"
            case runtime = "runtime"
            case syncConfig = "syncConfig"
            case typeName = "typeName"
        }
    }

    public struct SourceApiAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the source API association.
        public let associationArn: String?
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String?
        /// The description field.
        public let description: String?
        /// The datetime value of the last successful merge of the source API association. The result will be in UTC format and your local time zone.
        public let lastSuccessfulMergeDate: Date?
        /// The Amazon Resource Name (ARN) of the AppSync Merged API.
        public let mergedApiArn: String?
        /// The ID of the AppSync Merged API.
        public let mergedApiId: String?
        /// The Amazon Resource Name (ARN) of the AppSync source API.
        public let sourceApiArn: String?
        /// The SourceApiAssociationConfig object data.
        public let sourceApiAssociationConfig: SourceApiAssociationConfig?
        /// The state of the source API association.
        public let sourceApiAssociationStatus: SourceApiAssociationStatus?
        /// The detailed message related to the current state of the source API association.
        public let sourceApiAssociationStatusDetail: String?
        /// The ID of the AppSync source API.
        public let sourceApiId: String?

        public init(associationArn: String? = nil, associationId: String? = nil, description: String? = nil, lastSuccessfulMergeDate: Date? = nil, mergedApiArn: String? = nil, mergedApiId: String? = nil, sourceApiArn: String? = nil, sourceApiAssociationConfig: SourceApiAssociationConfig? = nil, sourceApiAssociationStatus: SourceApiAssociationStatus? = nil, sourceApiAssociationStatusDetail: String? = nil, sourceApiId: String? = nil) {
            self.associationArn = associationArn
            self.associationId = associationId
            self.description = description
            self.lastSuccessfulMergeDate = lastSuccessfulMergeDate
            self.mergedApiArn = mergedApiArn
            self.mergedApiId = mergedApiId
            self.sourceApiArn = sourceApiArn
            self.sourceApiAssociationConfig = sourceApiAssociationConfig
            self.sourceApiAssociationStatus = sourceApiAssociationStatus
            self.sourceApiAssociationStatusDetail = sourceApiAssociationStatusDetail
            self.sourceApiId = sourceApiId
        }

        private enum CodingKeys: String, CodingKey {
            case associationArn = "associationArn"
            case associationId = "associationId"
            case description = "description"
            case lastSuccessfulMergeDate = "lastSuccessfulMergeDate"
            case mergedApiArn = "mergedApiArn"
            case mergedApiId = "mergedApiId"
            case sourceApiArn = "sourceApiArn"
            case sourceApiAssociationConfig = "sourceApiAssociationConfig"
            case sourceApiAssociationStatus = "sourceApiAssociationStatus"
            case sourceApiAssociationStatusDetail = "sourceApiAssociationStatusDetail"
            case sourceApiId = "sourceApiId"
        }
    }

    public struct SourceApiAssociationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The property that indicates which merging option is enabled in the source API association. Valid merge types are MANUAL_MERGE (default) and AUTO_MERGE. Manual merges are the default behavior and require the user to trigger any changes from the source APIs to the merged API manually. Auto merges subscribe the merged API to the changes performed on the source APIs so that any change in the source APIs are also made to the merged API. Auto merges use MergedApiExecutionRoleArn to perform merge operations.
        public let mergeType: MergeType?

        public init(mergeType: MergeType? = nil) {
            self.mergeType = mergeType
        }

        private enum CodingKeys: String, CodingKey {
            case mergeType = "mergeType"
        }
    }

    public struct SourceApiAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the source API association.
        public let associationArn: String?
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String?
        /// The description field.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the AppSync Merged API.
        public let mergedApiArn: String?
        /// The ID of the AppSync Merged API.
        public let mergedApiId: String?
        /// The Amazon Resource Name (ARN) of the AppSync Source API.
        public let sourceApiArn: String?
        /// The ID of the AppSync source API.
        public let sourceApiId: String?

        public init(associationArn: String? = nil, associationId: String? = nil, description: String? = nil, mergedApiArn: String? = nil, mergedApiId: String? = nil, sourceApiArn: String? = nil, sourceApiId: String? = nil) {
            self.associationArn = associationArn
            self.associationId = associationId
            self.description = description
            self.mergedApiArn = mergedApiArn
            self.mergedApiId = mergedApiId
            self.sourceApiArn = sourceApiArn
            self.sourceApiId = sourceApiId
        }

        private enum CodingKeys: String, CodingKey {
            case associationArn = "associationArn"
            case associationId = "associationId"
            case description = "description"
            case mergedApiArn = "mergedApiArn"
            case mergedApiId = "mergedApiId"
            case sourceApiArn = "sourceApiArn"
            case sourceApiId = "sourceApiId"
        }
    }

    public struct StartDataSourceIntrospectionRequest: AWSEncodableShape {
        /// The rdsDataApiConfig object data.
        public let rdsDataApiConfig: RdsDataApiConfig?

        public init(rdsDataApiConfig: RdsDataApiConfig? = nil) {
            self.rdsDataApiConfig = rdsDataApiConfig
        }

        public func validate(name: String) throws {
            try self.rdsDataApiConfig?.validate(name: "\(name).rdsDataApiConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case rdsDataApiConfig = "rdsDataApiConfig"
        }
    }

    public struct StartDataSourceIntrospectionResponse: AWSDecodableShape {
        /// The introspection ID. Each introspection contains a unique ID that can be used to reference the instrospection record.
        public let introspectionId: String?
        /// The status of the introspection during creation. By default, when a new instrospection has been created, the status will be set to PROCESSING. Once the operation has been completed, the status will change to SUCCESS or FAILED depending on how the data was parsed. A FAILED operation will return an error and its details as an introspectionStatusDetail.
        public let introspectionStatus: DataSourceIntrospectionStatus?
        /// The error detail field. When a FAILED introspectionStatus is returned, the introspectionStatusDetail will also return the exact error that was generated during the operation.
        public let introspectionStatusDetail: String?

        public init(introspectionId: String? = nil, introspectionStatus: DataSourceIntrospectionStatus? = nil, introspectionStatusDetail: String? = nil) {
            self.introspectionId = introspectionId
            self.introspectionStatus = introspectionStatus
            self.introspectionStatusDetail = introspectionStatusDetail
        }

        private enum CodingKeys: String, CodingKey {
            case introspectionId = "introspectionId"
            case introspectionStatus = "introspectionStatus"
            case introspectionStatusDetail = "introspectionStatusDetail"
        }
    }

    public struct StartSchemaCreationRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The schema definition, in GraphQL schema language format.
        public let definition: AWSBase64Data

        public init(apiId: String, definition: AWSBase64Data) {
            self.apiId = apiId
            self.definition = definition
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encode(self.definition, forKey: .definition)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
        }
    }

    public struct StartSchemaCreationResponse: AWSDecodableShape {
        /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
        public let status: SchemaStatus?

        public init(status: SchemaStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct StartSchemaMergeRequest: AWSEncodableShape {
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String
        /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
        public let mergedApiIdentifier: String

        public init(associationId: String, mergedApiIdentifier: String) {
            self.associationId = associationId
            self.mergedApiIdentifier = mergedApiIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "associationId")
            request.encodePath(self.mergedApiIdentifier, key: "mergedApiIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartSchemaMergeResponse: AWSDecodableShape {
        /// The state of the source API association.
        public let sourceApiAssociationStatus: SourceApiAssociationStatus?

        public init(sourceApiAssociationStatus: SourceApiAssociationStatus? = nil) {
            self.sourceApiAssociationStatus = sourceApiAssociationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case sourceApiAssociationStatus = "sourceApiAssociationStatus"
        }
    }

    public struct SyncConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Conflict Detection strategy to use.    VERSION: Detect conflicts based on object versions for this resolver.    NONE: Do not detect conflicts when invoking this resolver.
        public let conflictDetection: ConflictDetectionType?
        /// The Conflict Resolution strategy to perform in the event of a conflict.    OPTIMISTIC_CONCURRENCY: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.    AUTOMERGE: Resolve conflicts with the Automerge conflict resolution strategy.    LAMBDA: Resolve conflicts with an Lambda function supplied in the LambdaConflictHandlerConfig.
        public let conflictHandler: ConflictHandlerType?
        /// The LambdaConflictHandlerConfig when configuring LAMBDA as the Conflict Handler.
        public let lambdaConflictHandlerConfig: LambdaConflictHandlerConfig?

        public init(conflictDetection: ConflictDetectionType? = nil, conflictHandler: ConflictHandlerType? = nil, lambdaConflictHandlerConfig: LambdaConflictHandlerConfig? = nil) {
            self.conflictDetection = conflictDetection
            self.conflictHandler = conflictHandler
            self.lambdaConflictHandlerConfig = lambdaConflictHandlerConfig
        }

        private enum CodingKeys: String, CodingKey {
            case conflictDetection = "conflictDetection"
            case conflictHandler = "conflictHandler"
            case lambdaConflictHandlerConfig = "lambdaConflictHandlerConfig"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The GraphqlApi Amazon Resource Name (ARN).
        public let resourceArn: String
        /// A TagMap object.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 75)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 70)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\\d{12}:apis/[0-9A-Za-z_-]{26}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[ a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct `Type`: AWSDecodableShape {
        /// The type Amazon Resource Name (ARN).
        public let arn: String?
        /// The type definition.
        public let definition: String?
        /// The type description.
        public let description: String?
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat?
        /// The type name.
        public let name: String?

        public init(arn: String? = nil, definition: String? = nil, description: String? = nil, format: TypeDefinitionFormat? = nil, name: String? = nil) {
            self.arn = arn
            self.definition = definition
            self.description = description
            self.format = format
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case definition = "definition"
            case description = "description"
            case format = "format"
            case name = "name"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The GraphqlApi Amazon Resource Name (ARN).
        public let resourceArn: String
        /// A list of TagKey objects.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 75)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 70)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\\d{12}:apis/[0-9A-Za-z_-]{26}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[ a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApiCacheRequest: AWSEncodableShape {
        /// Caching behavior.    FULL_REQUEST_CACHING: All requests are fully cached.    PER_RESOLVER_CACHING: Individual resolvers that you specify are cached.
        public let apiCachingBehavior: ApiCachingBehavior
        /// The GraphQL API ID.
        public let apiId: String
        /// Controls how cache health metrics will be emitted to CloudWatch. Cache health metrics include:   NetworkBandwidthOutAllowanceExceeded: The network packets dropped because the throughput exceeded the aggregated bandwidth limit. This is useful for diagnosing bottlenecks in a cache configuration.   EngineCPUUtilization: The CPU utilization (percentage) allocated to the Redis process. This is useful for diagnosing bottlenecks in a cache configuration.   Metrics will be recorded by API ID. You can set the value to ENABLED or DISABLED.
        public let healthMetricsConfig: CacheHealthMetricsConfig?
        /// TTL in seconds for cache entries. Valid values are 1–3,600 seconds.
        public let ttl: Int64
        /// The cache instance type. Valid values are     SMALL     MEDIUM     LARGE     XLARGE     LARGE_2X     LARGE_4X     LARGE_8X (not available in all regions)    LARGE_12X    Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used. The following legacy instance types are available, but their use is discouraged:    T2_SMALL: A t2.small instance type.    T2_MEDIUM: A t2.medium instance type.    R4_LARGE: A r4.large instance type.    R4_XLARGE: A r4.xlarge instance type.    R4_2XLARGE: A r4.2xlarge instance type.    R4_4XLARGE: A r4.4xlarge instance type.    R4_8XLARGE: A r4.8xlarge instance type.
        public let type: ApiCacheType

        public init(apiCachingBehavior: ApiCachingBehavior, apiId: String, healthMetricsConfig: CacheHealthMetricsConfig? = nil, ttl: Int64 = 0, type: ApiCacheType) {
            self.apiCachingBehavior = apiCachingBehavior
            self.apiId = apiId
            self.healthMetricsConfig = healthMetricsConfig
            self.ttl = ttl
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.apiCachingBehavior, forKey: .apiCachingBehavior)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.healthMetricsConfig, forKey: .healthMetricsConfig)
            try container.encode(self.ttl, forKey: .ttl)
            try container.encode(self.type, forKey: .type)
        }

        private enum CodingKeys: String, CodingKey {
            case apiCachingBehavior = "apiCachingBehavior"
            case healthMetricsConfig = "healthMetricsConfig"
            case ttl = "ttl"
            case type = "type"
        }
    }

    public struct UpdateApiCacheResponse: AWSDecodableShape {
        /// The ApiCache object.
        public let apiCache: ApiCache?

        public init(apiCache: ApiCache? = nil) {
            self.apiCache = apiCache
        }

        private enum CodingKeys: String, CodingKey {
            case apiCache = "apiCache"
        }
    }

    public struct UpdateApiKeyRequest: AWSEncodableShape {
        /// The ID for the GraphQL API.
        public let apiId: String
        /// A description of the purpose of the API key.
        public let description: String?
        /// From the update time, the time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .
        public let expires: Int64?
        /// The API key ID.
        public let id: String

        public init(apiId: String, description: String? = nil, expires: Int64? = nil, id: String) {
            self.apiId = apiId
            self.description = description
            self.expires = expires
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.expires, forKey: .expires)
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case expires = "expires"
        }
    }

    public struct UpdateApiKeyResponse: AWSDecodableShape {
        /// The API key.
        public let apiKey: ApiKey?

        public init(apiKey: ApiKey? = nil) {
            self.apiKey = apiKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The new description for the data source.
        public let description: String?
        /// The new Amazon DynamoDB configuration.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// The new OpenSearch configuration. As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. Instead, use UpdateDataSourceRequest$openSearchServiceConfig to update an OpenSearch data source.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// The new Amazon EventBridge settings.
        public let eventBridgeConfig: EventBridgeDataSourceConfig?
        /// The new HTTP endpoint configuration.
        public let httpConfig: HttpDataSourceConfig?
        /// The new Lambda configuration.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// Enables or disables enhanced data source metrics for specified data sources. Note that metricsConfig won't be used unless the dataSourceLevelMetricsBehavior value is set to PER_DATA_SOURCE_METRICS. If the dataSourceLevelMetricsBehavior is set to FULL_REQUEST_DATA_SOURCE_METRICS instead, metricsConfig will be ignored. However, you can still set its value.  metricsConfig can be ENABLED or DISABLED.
        public let metricsConfig: DataSourceLevelMetricsConfig?
        /// The new name for the data source.
        public let name: String
        /// The new OpenSearch configuration.
        public let openSearchServiceConfig: OpenSearchServiceDataSourceConfig?
        /// The new relational database configuration.
        public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
        /// The new service role Amazon Resource Name (ARN) for the data source.
        public let serviceRoleArn: String?
        /// The new data source type.
        public let type: DataSourceType

        public init(apiId: String, description: String? = nil, dynamodbConfig: DynamodbDataSourceConfig? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, eventBridgeConfig: EventBridgeDataSourceConfig? = nil, httpConfig: HttpDataSourceConfig? = nil, lambdaConfig: LambdaDataSourceConfig? = nil, metricsConfig: DataSourceLevelMetricsConfig? = nil, name: String, openSearchServiceConfig: OpenSearchServiceDataSourceConfig? = nil, relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil, serviceRoleArn: String? = nil, type: DataSourceType) {
            self.apiId = apiId
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.eventBridgeConfig = eventBridgeConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.metricsConfig = metricsConfig
            self.name = name
            self.openSearchServiceConfig = openSearchServiceConfig
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dynamodbConfig, forKey: .dynamodbConfig)
            try container.encodeIfPresent(self.elasticsearchConfig, forKey: .elasticsearchConfig)
            try container.encodeIfPresent(self.eventBridgeConfig, forKey: .eventBridgeConfig)
            try container.encodeIfPresent(self.httpConfig, forKey: .httpConfig)
            try container.encodeIfPresent(self.lambdaConfig, forKey: .lambdaConfig)
            try container.encodeIfPresent(self.metricsConfig, forKey: .metricsConfig)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.openSearchServiceConfig, forKey: .openSearchServiceConfig)
            try container.encodeIfPresent(self.relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
            try container.encodeIfPresent(self.serviceRoleArn, forKey: .serviceRoleArn)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 65536)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dynamodbConfig = "dynamodbConfig"
            case elasticsearchConfig = "elasticsearchConfig"
            case eventBridgeConfig = "eventBridgeConfig"
            case httpConfig = "httpConfig"
            case lambdaConfig = "lambdaConfig"
            case metricsConfig = "metricsConfig"
            case openSearchServiceConfig = "openSearchServiceConfig"
            case relationalDatabaseConfig = "relationalDatabaseConfig"
            case serviceRoleArn = "serviceRoleArn"
            case type = "type"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        /// The updated DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct UpdateDomainNameRequest: AWSEncodableShape {
        /// A description of the DomainName.
        public let description: String?
        /// The domain name.
        public let domainName: String

        public init(description: String? = nil, domainName: String) {
            self.description = description
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(\\*[\\w\\d-]*\\.)?([\\w\\d-]+\\.)+[\\w\\d-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateDomainNameResponse: AWSDecodableShape {
        /// The configuration for the DomainName.
        public let domainNameConfig: DomainNameConfig?

        public init(domainNameConfig: DomainNameConfig? = nil) {
            self.domainNameConfig = domainNameConfig
        }

        private enum CodingKeys: String, CodingKey {
            case domainNameConfig = "domainNameConfig"
        }
    }

    public struct UpdateFunctionRequest: AWSEncodableShape {
        /// The GraphQL API ID.
        public let apiId: String
        /// The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public let code: String?
        /// The Function DataSource name.
        public let dataSourceName: String
        /// The Function description.
        public let description: String?
        /// The function ID.
        public let functionId: String
        /// The version of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the functionVersion is required.
        public let functionVersion: String?
        /// The maximum batching size for a resolver.
        public let maxBatchSize: Int?
        /// The Function name.
        public let name: String
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public let requestMappingTemplate: String?
        /// The Function request mapping template.
        public let responseMappingTemplate: String?
        public let runtime: AppSyncRuntime?
        public let syncConfig: SyncConfig?

        public init(apiId: String, code: String? = nil, dataSourceName: String, description: String? = nil, functionId: String, functionVersion: String? = nil, maxBatchSize: Int? = nil, name: String, requestMappingTemplate: String? = nil, responseMappingTemplate: String? = nil, runtime: AppSyncRuntime? = nil, syncConfig: SyncConfig? = nil) {
            self.apiId = apiId
            self.code = code
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.maxBatchSize = maxBatchSize
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.code, forKey: .code)
            try container.encode(self.dataSourceName, forKey: .dataSourceName)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.functionId, key: "functionId")
            try container.encodeIfPresent(self.functionVersion, forKey: .functionVersion)
            try container.encodeIfPresent(self.maxBatchSize, forKey: .maxBatchSize)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.requestMappingTemplate, forKey: .requestMappingTemplate)
            try container.encodeIfPresent(self.responseMappingTemplate, forKey: .responseMappingTemplate)
            try container.encodeIfPresent(self.runtime, forKey: .runtime)
            try container.encodeIfPresent(self.syncConfig, forKey: .syncConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 32768)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.functionId, name: "functionId", parent: name, max: 65536)
            try self.validate(self.functionId, name: "functionId", parent: name, min: 1)
            try self.validate(self.functionId, name: "functionId", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, max: 2000)
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 65536)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, pattern: "^.*$")
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case dataSourceName = "dataSourceName"
            case description = "description"
            case functionVersion = "functionVersion"
            case maxBatchSize = "maxBatchSize"
            case name = "name"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
            case runtime = "runtime"
            case syncConfig = "syncConfig"
        }
    }

    public struct UpdateFunctionResponse: AWSDecodableShape {
        /// The Function object.
        public let functionConfiguration: FunctionConfiguration?

        public init(functionConfiguration: FunctionConfiguration? = nil) {
            self.functionConfiguration = functionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case functionConfiguration = "functionConfiguration"
        }
    }

    public struct UpdateGraphqlApiRequest: AWSEncodableShape {
        /// A list of additional authentication providers for the GraphqlApi API.
        public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
        /// The API ID.
        public let apiId: String
        /// The new authentication type for the GraphqlApi object.
        public let authenticationType: AuthenticationType?
        /// The enhancedMetricsConfig object.
        public let enhancedMetricsConfig: EnhancedMetricsConfig?
        /// Sets the value of the GraphQL API to enable (ENABLED) or disable (DISABLED) introspection. If no value is provided, the introspection configuration will be set to ENABLED by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled. For more information about introspection, see GraphQL introspection.
        public let introspectionConfig: GraphQLApiIntrospectionConfig?
        /// Configuration for Lambda function authorization.
        public let lambdaAuthorizerConfig: LambdaAuthorizerConfig?
        /// The Amazon CloudWatch Logs configuration for the GraphqlApi object.
        public let logConfig: LogConfig?
        /// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the AUTO_MERGE to update the merged API endpoint with the source API changes automatically.
        public let mergedApiExecutionRoleArn: String?
        /// The new name for the GraphqlApi object.
        public let name: String
        /// The OpenID Connect configuration for the GraphqlApi object.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// The owner contact information for an API resource. This field accepts any string input with a length of 0 - 256 characters.
        public let ownerContact: String?
        /// The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is 0 (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between 1 and 75 nested levels. This field will produce a limit error if the operation falls out of bounds. Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.
        public let queryDepthLimit: Int?
        /// The maximum number of resolvers that can be invoked in a single request. The default value is 0 (or unspecified), which will set the limit to 10000. When specified, the limit value can be between 1 and 10000. This field will produce a limit error if the operation falls out of bounds.
        public let resolverCountLimit: Int?
        /// The new Amazon Cognito user pool configuration for the ~GraphqlApi object.
        public let userPoolConfig: UserPoolConfig?
        /// A flag indicating whether to use X-Ray tracing for the GraphqlApi.
        public let xrayEnabled: Bool?

        public init(additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil, apiId: String, authenticationType: AuthenticationType? = nil, enhancedMetricsConfig: EnhancedMetricsConfig? = nil, introspectionConfig: GraphQLApiIntrospectionConfig? = nil, lambdaAuthorizerConfig: LambdaAuthorizerConfig? = nil, logConfig: LogConfig? = nil, mergedApiExecutionRoleArn: String? = nil, name: String, openIDConnectConfig: OpenIDConnectConfig? = nil, ownerContact: String? = nil, queryDepthLimit: Int? = nil, resolverCountLimit: Int? = nil, userPoolConfig: UserPoolConfig? = nil, xrayEnabled: Bool? = nil) {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.authenticationType = authenticationType
            self.enhancedMetricsConfig = enhancedMetricsConfig
            self.introspectionConfig = introspectionConfig
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.mergedApiExecutionRoleArn = mergedApiExecutionRoleArn
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.ownerContact = ownerContact
            self.queryDepthLimit = queryDepthLimit
            self.resolverCountLimit = resolverCountLimit
            self.userPoolConfig = userPoolConfig
            self.xrayEnabled = xrayEnabled
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalAuthenticationProviders, forKey: .additionalAuthenticationProviders)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.authenticationType, forKey: .authenticationType)
            try container.encodeIfPresent(self.enhancedMetricsConfig, forKey: .enhancedMetricsConfig)
            try container.encodeIfPresent(self.introspectionConfig, forKey: .introspectionConfig)
            try container.encodeIfPresent(self.lambdaAuthorizerConfig, forKey: .lambdaAuthorizerConfig)
            try container.encodeIfPresent(self.logConfig, forKey: .logConfig)
            try container.encodeIfPresent(self.mergedApiExecutionRoleArn, forKey: .mergedApiExecutionRoleArn)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.openIDConnectConfig, forKey: .openIDConnectConfig)
            try container.encodeIfPresent(self.ownerContact, forKey: .ownerContact)
            try container.encodeIfPresent(self.queryDepthLimit, forKey: .queryDepthLimit)
            try container.encodeIfPresent(self.resolverCountLimit, forKey: .resolverCountLimit)
            try container.encodeIfPresent(self.userPoolConfig, forKey: .userPoolConfig)
            try container.encodeIfPresent(self.xrayEnabled, forKey: .xrayEnabled)
        }

        public func validate(name: String) throws {
            try self.additionalAuthenticationProviders?.forEach {
                try $0.validate(name: "\(name).additionalAuthenticationProviders[]")
            }
            try self.lambdaAuthorizerConfig?.validate(name: "\(name).lambdaAuthorizerConfig")
            try self.validate(self.queryDepthLimit, name: "queryDepthLimit", parent: name, max: 75)
            try self.validate(self.queryDepthLimit, name: "queryDepthLimit", parent: name, min: 0)
            try self.validate(self.resolverCountLimit, name: "resolverCountLimit", parent: name, max: 10000)
            try self.validate(self.resolverCountLimit, name: "resolverCountLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthenticationProviders = "additionalAuthenticationProviders"
            case authenticationType = "authenticationType"
            case enhancedMetricsConfig = "enhancedMetricsConfig"
            case introspectionConfig = "introspectionConfig"
            case lambdaAuthorizerConfig = "lambdaAuthorizerConfig"
            case logConfig = "logConfig"
            case mergedApiExecutionRoleArn = "mergedApiExecutionRoleArn"
            case name = "name"
            case openIDConnectConfig = "openIDConnectConfig"
            case ownerContact = "ownerContact"
            case queryDepthLimit = "queryDepthLimit"
            case resolverCountLimit = "resolverCountLimit"
            case userPoolConfig = "userPoolConfig"
            case xrayEnabled = "xrayEnabled"
        }
    }

    public struct UpdateGraphqlApiResponse: AWSDecodableShape {
        /// The updated GraphqlApi object.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct UpdateResolverRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The caching configuration for the resolver.
        public let cachingConfig: CachingConfig?
        /// The resolver code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
        public let code: String?
        /// The new data source name.
        public let dataSourceName: String?
        /// The new field name.
        public let fieldName: String
        /// The resolver type.    UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.    PIPELINE: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of Function objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.
        public let kind: ResolverKind?
        /// The maximum batching size for a resolver.
        public let maxBatchSize: Int?
        /// Enables or disables enhanced resolver metrics for specified resolvers. Note that metricsConfig won't be used unless the resolverLevelMetricsBehavior value is set to PER_RESOLVER_METRICS. If the resolverLevelMetricsBehavior is set to FULL_REQUEST_RESOLVER_METRICS instead, metricsConfig will be ignored. However, you can still set its value.  metricsConfig can be ENABLED or DISABLED.
        public let metricsConfig: ResolverLevelMetricsConfig?
        /// The PipelineConfig.
        public let pipelineConfig: PipelineConfig?
        /// The new request mapping template. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL). VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.
        public let requestMappingTemplate: String?
        /// The new response mapping template.
        public let responseMappingTemplate: String?
        public let runtime: AppSyncRuntime?
        /// The SyncConfig for a resolver attached to a versioned data source.
        public let syncConfig: SyncConfig?
        /// The new type name.
        public let typeName: String

        public init(apiId: String, cachingConfig: CachingConfig? = nil, code: String? = nil, dataSourceName: String? = nil, fieldName: String, kind: ResolverKind? = nil, maxBatchSize: Int? = nil, metricsConfig: ResolverLevelMetricsConfig? = nil, pipelineConfig: PipelineConfig? = nil, requestMappingTemplate: String? = nil, responseMappingTemplate: String? = nil, runtime: AppSyncRuntime? = nil, syncConfig: SyncConfig? = nil, typeName: String) {
            self.apiId = apiId
            self.cachingConfig = cachingConfig
            self.code = code
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.maxBatchSize = maxBatchSize
            self.metricsConfig = metricsConfig
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.runtime = runtime
            self.syncConfig = syncConfig
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.cachingConfig, forKey: .cachingConfig)
            try container.encodeIfPresent(self.code, forKey: .code)
            try container.encodeIfPresent(self.dataSourceName, forKey: .dataSourceName)
            request.encodePath(self.fieldName, key: "fieldName")
            try container.encodeIfPresent(self.kind, forKey: .kind)
            try container.encodeIfPresent(self.maxBatchSize, forKey: .maxBatchSize)
            try container.encodeIfPresent(self.metricsConfig, forKey: .metricsConfig)
            try container.encodeIfPresent(self.pipelineConfig, forKey: .pipelineConfig)
            try container.encodeIfPresent(self.requestMappingTemplate, forKey: .requestMappingTemplate)
            try container.encodeIfPresent(self.responseMappingTemplate, forKey: .responseMappingTemplate)
            try container.encodeIfPresent(self.runtime, forKey: .runtime)
            try container.encodeIfPresent(self.syncConfig, forKey: .syncConfig)
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 32768)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try self.validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, max: 2000)
            try self.validate(self.maxBatchSize, name: "maxBatchSize", parent: name, min: 0)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try self.validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, pattern: "^.*$")
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
            try self.validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, pattern: "^.*$")
            try self.validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try self.validate(self.typeName, name: "typeName", parent: name, min: 1)
            try self.validate(self.typeName, name: "typeName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case cachingConfig = "cachingConfig"
            case code = "code"
            case dataSourceName = "dataSourceName"
            case kind = "kind"
            case maxBatchSize = "maxBatchSize"
            case metricsConfig = "metricsConfig"
            case pipelineConfig = "pipelineConfig"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
            case runtime = "runtime"
            case syncConfig = "syncConfig"
        }
    }

    public struct UpdateResolverResponse: AWSDecodableShape {
        /// The updated Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct UpdateSourceApiAssociationRequest: AWSEncodableShape {
        /// The ID generated by the AppSync service for the source API association.
        public let associationId: String
        /// The description field.
        public let description: String?
        /// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
        public let mergedApiIdentifier: String
        /// The SourceApiAssociationConfig object data.
        public let sourceApiAssociationConfig: SourceApiAssociationConfig?

        public init(associationId: String, description: String? = nil, mergedApiIdentifier: String, sourceApiAssociationConfig: SourceApiAssociationConfig? = nil) {
            self.associationId = associationId
            self.description = description
            self.mergedApiIdentifier = mergedApiIdentifier
            self.sourceApiAssociationConfig = sourceApiAssociationConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "associationId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.mergedApiIdentifier, key: "mergedApiIdentifier")
            try container.encodeIfPresent(self.sourceApiAssociationConfig, forKey: .sourceApiAssociationConfig)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case sourceApiAssociationConfig = "sourceApiAssociationConfig"
        }
    }

    public struct UpdateSourceApiAssociationResponse: AWSDecodableShape {
        /// The SourceApiAssociation object data.
        public let sourceApiAssociation: SourceApiAssociation?

        public init(sourceApiAssociation: SourceApiAssociation? = nil) {
            self.sourceApiAssociation = sourceApiAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case sourceApiAssociation = "sourceApiAssociation"
        }
    }

    public struct UpdateTypeRequest: AWSEncodableShape {
        /// The API ID.
        public let apiId: String
        /// The new definition.
        public let definition: String?
        /// The new type format: SDL or JSON.
        public let format: TypeDefinitionFormat
        /// The new type name.
        public let typeName: String

        public init(apiId: String, definition: String? = nil, format: TypeDefinitionFormat, typeName: String) {
            self.apiId = apiId
            self.definition = definition
            self.format = format
            self.typeName = typeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "apiId")
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encode(self.format, forKey: .format)
            request.encodePath(self.typeName, key: "typeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try self.validate(self.typeName, name: "typeName", parent: name, min: 1)
            try self.validate(self.typeName, name: "typeName", parent: name, pattern: "^[_A-Za-z][_0-9A-Za-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case format = "format"
        }
    }

    public struct UpdateTypeResponse: AWSDecodableShape {
        /// The updated Type object.
        public let type: `Type`?

        public init(type: `Type`? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct UserPoolConfig: AWSEncodableShape & AWSDecodableShape {
        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.
        public let appIdClientRegex: String?
        /// The Amazon Web Services Region in which the user pool was created.
        public let awsRegion: String
        /// The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pool authentication doesn't match the Amazon Cognito user pool configuration.
        public let defaultAction: DefaultAction
        /// The user pool ID.
        public let userPoolId: String

        public init(appIdClientRegex: String? = nil, awsRegion: String, defaultAction: DefaultAction, userPoolId: String) {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }

        private enum CodingKeys: String, CodingKey {
            case appIdClientRegex = "appIdClientRegex"
            case awsRegion = "awsRegion"
            case defaultAction = "defaultAction"
            case userPoolId = "userPoolId"
        }
    }
}

// MARK: - Errors

/// Error enum for AppSync
public struct AppSyncErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case apiKeyLimitExceededException = "ApiKeyLimitExceededException"
        case apiKeyValidityOutOfBoundsException = "ApiKeyValidityOutOfBoundsException"
        case apiLimitExceededException = "ApiLimitExceededException"
        case badRequestException = "BadRequestException"
        case concurrentModificationException = "ConcurrentModificationException"
        case graphQLSchemaException = "GraphQLSchemaException"
        case internalFailureException = "InternalFailureException"
        case limitExceededException = "LimitExceededException"
        case notFoundException = "NotFoundException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AppSync
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have access to perform this operation on this resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The API key exceeded a limit. Try your request again.
    public static var apiKeyLimitExceededException: Self { .init(.apiKeyLimitExceededException) }
    /// The API key expiration must be set to a value between 1 and 365 days from creation (for CreateApiKey) or from update (for UpdateApiKey).
    public static var apiKeyValidityOutOfBoundsException: Self { .init(.apiKeyValidityOutOfBoundsException) }
    /// The GraphQL API exceeded a limit. Try your request again.
    public static var apiLimitExceededException: Self { .init(.apiLimitExceededException) }
    /// The request is not well formed. For example, a value is invalid or a required field is missing. Check the field values, and then try again.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// Another modification is in progress at this time and it must complete before you can make your change.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// The GraphQL schema is not valid.
    public static var graphQLSchemaException: Self { .init(.graphQLSchemaException) }
    /// An internal AppSync error occurred. Try your request again.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// The request exceeded a limit. Try your request again.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The resource specified in the request was not found. Check the resource, and then try again.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// You aren't authorized to perform this operation.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension AppSyncErrorType: Equatable {
    public static func == (lhs: AppSyncErrorType, rhs: AppSyncErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppSyncErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
