//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension ECR {
    // MARK: Enums

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case aes256 = "AES256"
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum FindingSeverity: String, CustomStringConvertible, Codable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case informational = "INFORMATIONAL"
        case low = "LOW"
        case medium = "MEDIUM"
        case undefined = "UNDEFINED"
        public var description: String { return self.rawValue }
    }

    public enum ImageActionType: String, CustomStringConvertible, Codable {
        case expire = "EXPIRE"
        public var description: String { return self.rawValue }
    }

    public enum ImageFailureCode: String, CustomStringConvertible, Codable {
        case imagenotfound = "ImageNotFound"
        case imagereferencedbymanifestlist = "ImageReferencedByManifestList"
        case imagetagdoesnotmatchdigest = "ImageTagDoesNotMatchDigest"
        case invalidimagedigest = "InvalidImageDigest"
        case invalidimagetag = "InvalidImageTag"
        case kmserror = "KmsError"
        case missingdigestandtag = "MissingDigestAndTag"
        public var description: String { return self.rawValue }
    }

    public enum ImageTagMutability: String, CustomStringConvertible, Codable {
        case immutable = "IMMUTABLE"
        case mutable = "MUTABLE"
        public var description: String { return self.rawValue }
    }

    public enum LayerAvailability: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum LayerFailureCode: String, CustomStringConvertible, Codable {
        case invalidlayerdigest = "InvalidLayerDigest"
        case missinglayerdigest = "MissingLayerDigest"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyPreviewStatus: String, CustomStringConvertible, Codable {
        case complete = "COMPLETE"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatus: String, CustomStringConvertible, Codable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TagStatus: String, CustomStringConvertible, Codable {
        case any = "ANY"
        case tagged = "TAGGED"
        case untagged = "UNTAGGED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Attribute: AWSDecodableShape {
        /// The attribute key.
        public let key: String
        /// The value assigned to the attribute key.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct AuthorizationData: AWSDecodableShape {
        /// A base64-encoded string that contains authorization data for the specified Amazon ECR registry. When the string is decoded, it is presented in the format user:password for private registry authentication using docker login.
        public let authorizationToken: String?
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public let expiresAt: Date?
        /// The registry URL to use for this authorization token in a docker login command. The Amazon ECR registry URL format is https://aws_account_id.dkr.ecr.region.amazonaws.com. For example, https://012345678910.dkr.ecr.us-east-1.amazonaws.com..
        public let proxyEndpoint: String?

        public init(authorizationToken: String? = nil, expiresAt: Date? = nil, proxyEndpoint: String? = nil) {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
            self.proxyEndpoint = proxyEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationToken
            case expiresAt
            case proxyEndpoint
        }
    }

    public struct BatchCheckLayerAvailabilityRequest: AWSEncodableShape {
        /// The digests of the image layers to check.
        public let layerDigests: [String]
        /// The AWS account ID associated with the registry that contains the image layers to check. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the image layers to check.
        public let repositoryName: String

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, max: 1000)
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests
            case registryId
            case repositoryName
        }
    }

    public struct BatchCheckLayerAvailabilityResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [LayerFailure]?
        /// A list of image layer objects corresponding to the image layer references in the request.
        public let layers: [Layer]?

        public init(failures: [LayerFailure]? = nil, layers: [Layer]? = nil) {
            self.failures = failures
            self.layers = layers
        }

        private enum CodingKeys: String, CodingKey {
            case failures
            case layers
        }
    }

    public struct BatchDeleteImageRequest: AWSEncodableShape {
        /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The AWS account ID associated with the registry that contains the image to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository that contains the image to delete.
        public let repositoryName: String

        public init(imageIds: [ImageIdentifier], registryId: String? = nil, repositoryName: String) {
            self.imageIds = imageIds
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds
            case registryId
            case repositoryName
        }
    }

    public struct BatchDeleteImageResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?
        /// The image IDs of the deleted images.
        public let imageIds: [ImageIdentifier]?

        public init(failures: [ImageFailure]? = nil, imageIds: [ImageIdentifier]? = nil) {
            self.failures = failures
            self.imageIds = imageIds
        }

        private enum CodingKeys: String, CodingKey {
            case failures
            case imageIds
        }
    }

    public struct BatchGetImageRequest: AWSEncodableShape {
        /// The accepted media types for the request. Valid values: application/vnd.docker.distribution.manifest.v1+json | application/vnd.docker.distribution.manifest.v2+json | application/vnd.oci.image.manifest.v1+json
        public let acceptedMediaTypes: [String]?
        /// A list of image ID references that correspond to images to describe. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The AWS account ID associated with the registry that contains the images to describe. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository that contains the images to describe.
        public let repositoryName: String

        public init(acceptedMediaTypes: [String]? = nil, imageIds: [ImageIdentifier], registryId: String? = nil, repositoryName: String) {
            self.acceptedMediaTypes = acceptedMediaTypes
            self.imageIds = imageIds
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptedMediaTypes, name: "acceptedMediaTypes", parent: name, max: 100)
            try self.validate(self.acceptedMediaTypes, name: "acceptedMediaTypes", parent: name, min: 1)
            try self.imageIds.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedMediaTypes
            case imageIds
            case registryId
            case repositoryName
        }
    }

    public struct BatchGetImageResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?
        /// A list of image objects corresponding to the image references in the request.
        public let images: [Image]?

        public init(failures: [ImageFailure]? = nil, images: [Image]? = nil) {
            self.failures = failures
            self.images = images
        }

        private enum CodingKeys: String, CodingKey {
            case failures
            case images
        }
    }

    public struct CompleteLayerUploadRequest: AWSEncodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigests: [String]
        /// The AWS account ID associated with the registry to which to upload layers. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to associate with the image layer.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the image layer.
        public let uploadId: String

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, pattern: "[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+")
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests
            case registryId
            case repositoryName
            case uploadId
        }
    }

    public struct CompleteLayerUploadResponse: AWSDecodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The upload ID associated with the layer.
        public let uploadId: String?

        public init(layerDigest: String? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest
            case registryId
            case repositoryName
            case uploadId
        }
    }

    public struct CreateRepositoryRequest: AWSEncodableShape {
        /// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        public let imageTagMutability: ImageTagMutability?
        /// The name to use for the repository. The repository name may be specified on its own (such as nginx-web-app) or it can be prepended with a namespace to group the repository into a category (such as project-a/nginx-web-app).
        public let repositoryName: String
        /// The metadata that you apply to the repository to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]?

        public init(encryptionConfiguration: EncryptionConfiguration? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTagMutability: ImageTagMutability? = nil, repositoryName: String, tags: [Tag]? = nil) {
            self.encryptionConfiguration = encryptionConfiguration
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.repositoryName = repositoryName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration
            case imageScanningConfiguration
            case imageTagMutability
            case repositoryName
            case tags
        }
    }

    public struct CreateRepositoryResponse: AWSDecodableShape {
        /// The repository that was created.
        public let repository: Repository?

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct DeleteLifecyclePolicyRequest: AWSEncodableShape {
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct DeleteLifecyclePolicyResponse: AWSDecodableShape {
        /// The time stamp of the last time that the lifecycle policy was run.
        public let lastEvaluatedAt: Date?
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(lastEvaluatedAt: Date? = nil, lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.lastEvaluatedAt = lastEvaluatedAt
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case lastEvaluatedAt
            case lifecyclePolicyText
            case registryId
            case repositoryName
        }
    }

    public struct DeleteRegistryPolicyRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteRegistryPolicyResponse: AWSDecodableShape {
        /// The contents of the registry permissions policy that was deleted.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?

        public init(policyText: String? = nil, registryId: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
        }
    }

    public struct DeleteRepositoryPolicyRequest: AWSEncodableShape {
        /// The AWS account ID associated with the registry that contains the repository policy to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the repository policy to delete.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct DeleteRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy that was deleted from the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct DeleteRepositoryRequest: AWSEncodableShape {
        ///  If a repository contains images, forces the deletion.
        public let force: Bool?
        /// The AWS account ID associated with the registry that contains the repository to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to delete.
        public let repositoryName: String

        public init(force: Bool? = nil, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case force
            case registryId
            case repositoryName
        }
    }

    public struct DeleteRepositoryResponse: AWSDecodableShape {
        /// The repository that was deleted.
        public let repository: Repository?

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository
        }
    }

    public struct DescribeImageScanFindingsRequest: AWSEncodableShape {
        public let imageId: ImageIdentifier
        /// The maximum number of image scan results returned by DescribeImageScanFindings in paginated output. When this parameter is used, DescribeImageScanFindings only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImageScanFindings request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImageScanFindings returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeImageScanFindings request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The AWS account ID associated with the registry that contains the repository in which to describe the image scan findings for. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository for the image for which to describe the scan findings.
        public let repositoryName: String

        public init(imageId: ImageIdentifier, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageId = imageId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageId.validate(name: "\(name).imageId")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageId
            case maxResults
            case nextToken
            case registryId
            case repositoryName
        }
    }

    public struct DescribeImageScanFindingsResponse: AWSDecodableShape {
        public let imageId: ImageIdentifier?
        /// The information contained in the image scan findings.
        public let imageScanFindings: ImageScanFindings?
        /// The current state of the scan.
        public let imageScanStatus: ImageScanStatus?
        /// The nextToken value to include in a future DescribeImageScanFindings request. When the results of a DescribeImageScanFindings request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(imageId: ImageIdentifier? = nil, imageScanFindings: ImageScanFindings? = nil, imageScanStatus: ImageScanStatus? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageScanFindings = imageScanFindings
            self.imageScanStatus = imageScanStatus
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId
            case imageScanFindings
            case imageScanStatus
            case nextToken
            case registryId
            case repositoryName
        }
    }

    public struct DescribeImagesFilter: AWSEncodableShape {
        /// The tag status with which to filter your DescribeImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public let tagStatus: TagStatus?

        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus
        }
    }

    public struct DescribeImagesRequest: AWSEncodableShape {
        /// The filter key and value with which to filter your DescribeImages results.
        public let filter: DescribeImagesFilter?
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?
        /// The maximum number of repository results returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImages returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The AWS account ID associated with the registry that contains the repository in which to describe images. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository that contains the images to describe.
        public let repositoryName: String

        public init(filter: DescribeImagesFilter? = nil, imageIds: [ImageIdentifier]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.filter = filter
            self.imageIds = imageIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds?.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case imageIds
            case maxResults
            case nextToken
            case registryId
            case repositoryName
        }
    }

    public struct DescribeImagesResponse: AWSDecodableShape {
        /// A list of ImageDetail objects that contain data about the image.
        public let imageDetails: [ImageDetail]?
        /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(imageDetails: [ImageDetail]? = nil, nextToken: String? = nil) {
            self.imageDetails = imageDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageDetails
            case nextToken
        }
    }

    public struct DescribeRegistryRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeRegistryResponse: AWSDecodableShape {
        /// The ID of the registry.
        public let registryId: String?
        /// The replication configuration for the registry.
        public let replicationConfiguration: ReplicationConfiguration?

        public init(registryId: String? = nil, replicationConfiguration: ReplicationConfiguration? = nil) {
            self.registryId = registryId
            self.replicationConfiguration = replicationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case replicationConfiguration
        }
    }

    public struct DescribeRepositoriesRequest: AWSEncodableShape {
        /// The maximum number of repository results returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify repositories with repositoryNames.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify repositories with repositoryNames.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The AWS account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public let repositoryNames: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryNames: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryNames = repositoryNames
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.repositoryNames?.forEach {
                try validate($0, name: "repositoryNames[]", parent: name, max: 256)
                try validate($0, name: "repositoryNames[]", parent: name, min: 2)
                try validate($0, name: "repositoryNames[]", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
            }
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, max: 100)
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case registryId
            case repositoryNames
        }
    }

    public struct DescribeRepositoriesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of repository objects corresponding to valid repositories.
        public let repositories: [Repository]?

        public init(nextToken: String? = nil, repositories: [Repository]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case repositories
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The encryption type to use. If you use the KMS encryption type, the contents of the repository will be encrypted using server-side encryption with customer master keys (CMKs) stored in AWS KMS. When you use AWS KMS to encrypt your data, you can either use the default AWS managed CMK for Amazon ECR, or specify your own CMK, which you already created. For more information, see Protecting Data Using Server-Side Encryption with CMKs Stored in AWS Key Management Service (SSE-KMS) in the Amazon Simple Storage Service Console Developer Guide.. If you use the AES256 encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES-256 encryption algorithm. For more information, see Protecting Data Using Server-Side Encryption with Amazon S3-Managed Encryption Keys (SSE-S3) in the Amazon Simple Storage Service Console Developer Guide..
        public let encryptionType: EncryptionType
        /// If you use the KMS encryption type, specify the CMK to use for encryption. The alias, key ID, or full ARN of the CMK can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed CMK for Amazon ECR will be used.
        public let kmsKey: String?

        public init(encryptionType: EncryptionType, kmsKey: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType
            case kmsKey
        }
    }

    public struct GetAuthorizationTokenRequest: AWSEncodableShape {
        /// A list of AWS account IDs that are associated with the registries for which to get AuthorizationData objects. If you do not specify a registry, the default registry is assumed.
        public let registryIds: [String]?

        public init(registryIds: [String]? = nil) {
            self.registryIds = registryIds
        }

        public func validate(name: String) throws {
            try self.registryIds?.forEach {
                try validate($0, name: "registryIds[]", parent: name, pattern: "[0-9]{12}")
            }
            try self.validate(self.registryIds, name: "registryIds", parent: name, max: 10)
            try self.validate(self.registryIds, name: "registryIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case registryIds
        }
    }

    public struct GetAuthorizationTokenResponse: AWSDecodableShape {
        /// A list of authorization token data objects that correspond to the registryIds values in the request.
        public let authorizationData: [AuthorizationData]?

        public init(authorizationData: [AuthorizationData]? = nil) {
            self.authorizationData = authorizationData
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationData
        }
    }

    public struct GetDownloadUrlForLayerRequest: AWSEncodableShape {
        /// The digest of the image layer to download.
        public let layerDigest: String
        /// The AWS account ID associated with the registry that contains the image layer to download. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the image layer to download.
        public let repositoryName: String

        public init(layerDigest: String, registryId: String? = nil, repositoryName: String) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.layerDigest, name: "layerDigest", parent: name, pattern: "[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest
            case registryId
            case repositoryName
        }
    }

    public struct GetDownloadUrlForLayerResponse: AWSDecodableShape {
        /// The pre-signed Amazon S3 download URL for the requested layer.
        public let downloadUrl: String?
        /// The digest of the image layer to download.
        public let layerDigest: String?

        public init(downloadUrl: String? = nil, layerDigest: String? = nil) {
            self.downloadUrl = downloadUrl
            self.layerDigest = layerDigest
        }

        private enum CodingKeys: String, CodingKey {
            case downloadUrl
            case layerDigest
        }
    }

    public struct GetLifecyclePolicyPreviewRequest: AWSEncodableShape {
        /// An optional parameter that filters results based on image tag status and all tags, if tagged.
        public let filter: LifecyclePolicyPreviewFilter?
        /// The list of imageIDs to be included.
        public let imageIds: [ImageIdentifier]?
        /// The maximum number of repository results returned by GetLifecyclePolicyPreviewRequest in  paginated output. When this parameter is used, GetLifecyclePolicyPreviewRequest only returns  maxResults results in a single page along with a nextToken  response element. The remaining results of the initial request can be seen by sending  another GetLifecyclePolicyPreviewRequest request with the returned nextToken  value. This value can be between 1 and 1000. If this  parameter is not used, then GetLifecyclePolicyPreviewRequest returns up to  100 results and a nextToken value, if  applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated  GetLifecyclePolicyPreviewRequest request where maxResults was used and the  results exceeded the value of that parameter. Pagination continues from the end of the  previous results that returned the nextToken value. This value is  null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        public init(filter: LifecyclePolicyPreviewFilter? = nil, imageIds: [ImageIdentifier]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.filter = filter
            self.imageIds = imageIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds?.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case imageIds
            case maxResults
            case nextToken
            case registryId
            case repositoryName
        }
    }

    public struct GetLifecyclePolicyPreviewResponse: AWSDecodableShape {
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The nextToken value to include in a future GetLifecyclePolicyPreview request. When the results of a GetLifecyclePolicyPreview request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The results of the lifecycle policy preview request.
        public let previewResults: [LifecyclePolicyPreviewResult]?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The status of the lifecycle policy preview request.
        public let status: LifecyclePolicyPreviewStatus?
        /// The list of images that is returned as a result of the action.
        public let summary: LifecyclePolicyPreviewSummary?

        public init(lifecyclePolicyText: String? = nil, nextToken: String? = nil, previewResults: [LifecyclePolicyPreviewResult]? = nil, registryId: String? = nil, repositoryName: String? = nil, status: LifecyclePolicyPreviewStatus? = nil, summary: LifecyclePolicyPreviewSummary? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.nextToken = nextToken
            self.previewResults = previewResults
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.status = status
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText
            case nextToken
            case previewResults
            case registryId
            case repositoryName
            case status
            case summary
        }
    }

    public struct GetLifecyclePolicyRequest: AWSEncodableShape {
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct GetLifecyclePolicyResponse: AWSDecodableShape {
        /// The time stamp of the last time that the lifecycle policy was run.
        public let lastEvaluatedAt: Date?
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(lastEvaluatedAt: Date? = nil, lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.lastEvaluatedAt = lastEvaluatedAt
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case lastEvaluatedAt
            case lifecyclePolicyText
            case registryId
            case repositoryName
        }
    }

    public struct GetRegistryPolicyRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetRegistryPolicyResponse: AWSDecodableShape {
        /// The JSON text of the permissions policy for a registry.
        public let policyText: String?
        /// The ID of the registry.
        public let registryId: String?

        public init(policyText: String? = nil, registryId: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
        }
    }

    public struct GetRepositoryPolicyRequest: AWSEncodableShape {
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository with the policy to retrieve.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct GetRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text associated with the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct Image: AWSDecodableShape {
        /// An object containing the image tag and image digest associated with an image.
        public let imageId: ImageIdentifier?
        /// The image manifest associated with the image.
        public let imageManifest: String?
        /// The manifest media type of the image.
        public let imageManifestMediaType: String?
        /// The AWS account ID associated with the registry containing the image.
        public let registryId: String?
        /// The name of the repository associated with the image.
        public let repositoryName: String?

        public init(imageId: ImageIdentifier? = nil, imageManifest: String? = nil, imageManifestMediaType: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId
            case imageManifest
            case imageManifestMediaType
            case registryId
            case repositoryName
        }
    }

    public struct ImageDetail: AWSDecodableShape {
        /// The artifact media type of the image.
        public let artifactMediaType: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The media type of the image manifest.
        public let imageManifestMediaType: String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public let imagePushedAt: Date?
        /// A summary of the last completed image scan.
        public let imageScanFindingsSummary: ImageScanFindingsSummary?
        /// The current state of the scan.
        public let imageScanStatus: ImageScanStatus?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this will be the max size of all manifests in the list.  Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by DescribeImages.
        public let imageSizeInBytes: Int64?
        /// The list of tags associated with this image.
        public let imageTags: [String]?
        /// The AWS account ID associated with the registry to which this image belongs.
        public let registryId: String?
        /// The name of the repository to which this image belongs.
        public let repositoryName: String?

        public init(artifactMediaType: String? = nil, imageDigest: String? = nil, imageManifestMediaType: String? = nil, imagePushedAt: Date? = nil, imageScanFindingsSummary: ImageScanFindingsSummary? = nil, imageScanStatus: ImageScanStatus? = nil, imageSizeInBytes: Int64? = nil, imageTags: [String]? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageScanFindingsSummary = imageScanFindingsSummary
            self.imageScanStatus = imageScanStatus
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case artifactMediaType
            case imageDigest
            case imageManifestMediaType
            case imagePushedAt
            case imageScanFindingsSummary
            case imageScanStatus
            case imageSizeInBytes
            case imageTags
            case registryId
            case repositoryName
        }
    }

    public struct ImageFailure: AWSDecodableShape {
        /// The code associated with the failure.
        public let failureCode: ImageFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The image ID associated with the failure.
        public let imageId: ImageIdentifier?

        public init(failureCode: ImageFailureCode? = nil, failureReason: String? = nil, imageId: ImageIdentifier? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode
            case failureReason
            case imageId
        }
    }

    public struct ImageIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The tag used for the image.
        public let imageTag: String?

        public init(imageDigest: String? = nil, imageTag: String? = nil) {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }

        public func validate(name: String) throws {
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest
            case imageTag
        }
    }

    public struct ImageScanFinding: AWSDecodableShape {
        /// A collection of attributes of the host from which the finding is generated.
        public let attributes: [Attribute]?
        /// The description of the finding.
        public let description: String?
        /// The name associated with the finding, usually a CVE number.
        public let name: String?
        /// The finding severity.
        public let severity: FindingSeverity?
        /// A link containing additional details about the security vulnerability.
        public let uri: String?

        public init(attributes: [Attribute]? = nil, description: String? = nil, name: String? = nil, severity: FindingSeverity? = nil, uri: String? = nil) {
            self.attributes = attributes
            self.description = description
            self.name = name
            self.severity = severity
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case attributes
            case description
            case name
            case severity
            case uri
        }
    }

    public struct ImageScanFindings: AWSDecodableShape {
        /// The findings from the image scan.
        public let findings: [ImageScanFinding]?
        /// The image vulnerability counts, sorted by severity.
        public let findingSeverityCounts: [FindingSeverity: Int]?
        /// The time of the last completed image scan.
        public let imageScanCompletedAt: Date?
        /// The time when the vulnerability data was last scanned.
        public let vulnerabilitySourceUpdatedAt: Date?

        public init(findings: [ImageScanFinding]? = nil, findingSeverityCounts: [FindingSeverity: Int]? = nil, imageScanCompletedAt: Date? = nil, vulnerabilitySourceUpdatedAt: Date? = nil) {
            self.findings = findings
            self.findingSeverityCounts = findingSeverityCounts
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case findings
            case findingSeverityCounts
            case imageScanCompletedAt
            case vulnerabilitySourceUpdatedAt
        }
    }

    public struct ImageScanFindingsSummary: AWSDecodableShape {
        /// The image vulnerability counts, sorted by severity.
        public let findingSeverityCounts: [FindingSeverity: Int]?
        /// The time of the last completed image scan.
        public let imageScanCompletedAt: Date?
        /// The time when the vulnerability data was last scanned.
        public let vulnerabilitySourceUpdatedAt: Date?

        public init(findingSeverityCounts: [FindingSeverity: Int]? = nil, imageScanCompletedAt: Date? = nil, vulnerabilitySourceUpdatedAt: Date? = nil) {
            self.findingSeverityCounts = findingSeverityCounts
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case findingSeverityCounts
            case imageScanCompletedAt
            case vulnerabilitySourceUpdatedAt
        }
    }

    public struct ImageScanStatus: AWSDecodableShape {
        /// The description of the image scan status.
        public let description: String?
        /// The current state of an image scan.
        public let status: ScanStatus?

        public init(description: String? = nil, status: ScanStatus? = nil) {
            self.description = description
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case status
        }
    }

    public struct ImageScanningConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The setting that determines whether images are scanned after being pushed to a repository. If set to true, images will be scanned after being pushed. If this parameter is not specified, it will default to false and images will not be scanned unless a scan is manually started with the StartImageScan API.
        public let scanOnPush: Bool?

        public init(scanOnPush: Bool? = nil) {
            self.scanOnPush = scanOnPush
        }

        private enum CodingKeys: String, CodingKey {
            case scanOnPush
        }
    }

    public struct InitiateLayerUploadRequest: AWSEncodableShape {
        /// The AWS account ID associated with the registry to which you intend to upload layers. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to which you intend to upload layers.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId
            case repositoryName
        }
    }

    public struct InitiateLayerUploadResponse: AWSDecodableShape {
        /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
        public let partSize: Int64?
        /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload operations.
        public let uploadId: String?

        public init(partSize: Int64? = nil, uploadId: String? = nil) {
            self.partSize = partSize
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case partSize
            case uploadId
        }
    }

    public struct Layer: AWSDecodableShape {
        /// The availability status of the image layer.
        public let layerAvailability: LayerAvailability?
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The size, in bytes, of the image layer.
        public let layerSize: Int64?
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public let mediaType: String?

        public init(layerAvailability: LayerAvailability? = nil, layerDigest: String? = nil, layerSize: Int64? = nil, mediaType: String? = nil) {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }

        private enum CodingKeys: String, CodingKey {
            case layerAvailability
            case layerDigest
            case layerSize
            case mediaType
        }
    }

    public struct LayerFailure: AWSDecodableShape {
        /// The failure code associated with the failure.
        public let failureCode: LayerFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The layer digest associated with the failure.
        public let layerDigest: String?

        public init(failureCode: LayerFailureCode? = nil, failureReason: String? = nil, layerDigest: String? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode
            case failureReason
            case layerDigest
        }
    }

    public struct LifecyclePolicyPreviewFilter: AWSEncodableShape {
        /// The tag status of the image.
        public let tagStatus: TagStatus?

        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus
        }
    }

    public struct LifecyclePolicyPreviewResult: AWSDecodableShape {
        /// The type of action to be taken.
        public let action: LifecyclePolicyRuleAction?
        /// The priority of the applied rule.
        public let appliedRulePriority: Int?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public let imagePushedAt: Date?
        /// The list of tags associated with this image.
        public let imageTags: [String]?

        public init(action: LifecyclePolicyRuleAction? = nil, appliedRulePriority: Int? = nil, imageDigest: String? = nil, imagePushedAt: Date? = nil, imageTags: [String]? = nil) {
            self.action = action
            self.appliedRulePriority = appliedRulePriority
            self.imageDigest = imageDigest
            self.imagePushedAt = imagePushedAt
            self.imageTags = imageTags
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case appliedRulePriority
            case imageDigest
            case imagePushedAt
            case imageTags
        }
    }

    public struct LifecyclePolicyPreviewSummary: AWSDecodableShape {
        /// The number of expiring images.
        public let expiringImageTotalCount: Int?

        public init(expiringImageTotalCount: Int? = nil) {
            self.expiringImageTotalCount = expiringImageTotalCount
        }

        private enum CodingKeys: String, CodingKey {
            case expiringImageTotalCount
        }
    }

    public struct LifecyclePolicyRuleAction: AWSDecodableShape {
        /// The type of action to be taken.
        public let type: ImageActionType?

        public init(type: ImageActionType? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type
        }
    }

    public struct ListImagesFilter: AWSEncodableShape {
        /// The tag status with which to filter your ListImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public let tagStatus: TagStatus?

        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus
        }
    }

    public struct ListImagesRequest: AWSEncodableShape {
        /// The filter key and value with which to filter your ListImages results.
        public let filter: ListImagesFilter?
        /// The maximum number of image results returned by ListImages in paginated output. When this parameter is used, ListImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then ListImages returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated ListImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The AWS account ID associated with the registry that contains the repository in which to list images. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository with image IDs to be listed.
        public let repositoryName: String

        public init(filter: ListImagesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case maxResults
            case nextToken
            case registryId
            case repositoryName
        }
    }

    public struct ListImagesResponse: AWSDecodableShape {
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?
        /// The nextToken value to include in a future ListImages request. When the results of a ListImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(imageIds: [ImageIdentifier]? = nil, nextToken: String? = nil) {
            self.imageIds = imageIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the only supported resource is an Amazon ECR repository.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct PutImageRequest: AWSEncodableShape {
        /// The image digest of the image manifest corresponding to the image.
        public let imageDigest: String?
        /// The image manifest corresponding to the image to be uploaded.
        public let imageManifest: String
        /// The media type of the image manifest. If you push an image manifest that does not contain the mediaType field, you must specify the imageManifestMediaType in the request.
        public let imageManifestMediaType: String?
        /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
        public let imageTag: String?
        /// The AWS account ID associated with the registry that contains the repository in which to put the image. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository in which to put the image.
        public let repositoryName: String

        public init(imageDigest: String? = nil, imageManifest: String, imageManifestMediaType: String? = nil, imageTag: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageDigest = imageDigest
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.imageTag = imageTag
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, max: 4_194_304)
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, min: 1)
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest
            case imageManifest
            case imageManifestMediaType
            case imageTag
            case registryId
            case repositoryName
        }
    }

    public struct PutImageResponse: AWSDecodableShape {
        /// Details of the image uploaded.
        public let image: Image?

        public init(image: Image? = nil) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image
        }
    }

    public struct PutImageScanningConfigurationRequest: AWSEncodableShape {
        /// The image scanning configuration for the repository. This setting determines whether images are scanned for known vulnerabilities after being pushed to the repository.
        public let imageScanningConfiguration: ImageScanningConfiguration
        /// The AWS account ID associated with the registry that contains the repository in which to update the image scanning configuration setting. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository in which to update the image scanning configuration setting.
        public let repositoryName: String

        public init(imageScanningConfiguration: ImageScanningConfiguration, registryId: String? = nil, repositoryName: String) {
            self.imageScanningConfiguration = imageScanningConfiguration
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageScanningConfiguration
            case registryId
            case repositoryName
        }
    }

    public struct PutImageScanningConfigurationResponse: AWSDecodableShape {
        /// The image scanning configuration setting for the repository.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(imageScanningConfiguration: ImageScanningConfiguration? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageScanningConfiguration = imageScanningConfiguration
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageScanningConfiguration
            case registryId
            case repositoryName
        }
    }

    public struct PutImageTagMutabilityRequest: AWSEncodableShape {
        /// The tag mutability setting for the repository. If MUTABLE is specified, image tags can be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        public let imageTagMutability: ImageTagMutability
        /// The AWS account ID associated with the registry that contains the repository in which to update the image tag mutability settings. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository in which to update the image tag mutability settings.
        public let repositoryName: String

        public init(imageTagMutability: ImageTagMutability, registryId: String? = nil, repositoryName: String) {
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageTagMutability
            case registryId
            case repositoryName
        }
    }

    public struct PutImageTagMutabilityResponse: AWSDecodableShape {
        /// The image tag mutability setting for the repository.
        public let imageTagMutability: ImageTagMutability?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(imageTagMutability: ImageTagMutability? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageTagMutability
            case registryId
            case repositoryName
        }
    }

    public struct PutLifecyclePolicyRequest: AWSEncodableShape {
        /// The JSON repository policy text to apply to the repository.
        public let lifecyclePolicyText: String
        /// The AWS account ID associated with the registry that contains the repository. If you do  not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to receive the policy.
        public let repositoryName: String

        public init(lifecyclePolicyText: String, registryId: String? = nil, repositoryName: String) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, max: 30720)
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, min: 100)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText
            case registryId
            case repositoryName
        }
    }

    public struct PutLifecyclePolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText
            case registryId
            case repositoryName
        }
    }

    public struct PutRegistryPolicyRequest: AWSEncodableShape {
        /// The JSON policy text to apply to your registry. The policy text follows the same format as IAM policy text. For more information, see Registry permissions in the Amazon Elastic Container Registry User Guide.
        public let policyText: String

        public init(policyText: String) {
            self.policyText = policyText
        }

        public func validate(name: String) throws {
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10240)
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
        }
    }

    public struct PutRegistryPolicyResponse: AWSDecodableShape {
        /// The JSON policy text for your registry.
        public let policyText: String?
        /// The registry ID.
        public let registryId: String?

        public init(policyText: String? = nil, registryId: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
        }
    }

    public struct PutReplicationConfigurationRequest: AWSEncodableShape {
        /// An object representing the replication configuration for a registry.
        public let replicationConfiguration: ReplicationConfiguration

        public init(replicationConfiguration: ReplicationConfiguration) {
            self.replicationConfiguration = replicationConfiguration
        }

        public func validate(name: String) throws {
            try self.replicationConfiguration.validate(name: "\(name).replicationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfiguration
        }
    }

    public struct PutReplicationConfigurationResponse: AWSDecodableShape {
        /// The contents of the replication configuration for the registry.
        public let replicationConfiguration: ReplicationConfiguration?

        public init(replicationConfiguration: ReplicationConfiguration? = nil) {
            self.replicationConfiguration = replicationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfiguration
        }
    }

    public struct ReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects representing the replication rules for a replication configuration. A replication configuration may contain only one replication rule but the rule may contain one or more replication destinations.
        public let rules: [ReplicationRule]

        public init(rules: [ReplicationRule]) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rules
        }
    }

    public struct ReplicationDestination: AWSEncodableShape & AWSDecodableShape {
        /// A Region to replicate to.
        public let region: String
        /// The account ID of the destination registry to replicate to.
        public let registryId: String

        public init(region: String, registryId: String) {
            self.region = region
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.region, name: "region", parent: name, max: 25)
            try self.validate(self.region, name: "region", parent: name, min: 2)
            try self.validate(self.region, name: "region", parent: name, pattern: "[0-9a-z-]{2,25}")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case region
            case registryId
        }
    }

    public struct ReplicationRule: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects representing the details of a replication destination.
        public let destinations: [ReplicationDestination]

        public init(destinations: [ReplicationDestination]) {
            self.destinations = destinations
        }

        public func validate(name: String) throws {
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.destinations, name: "destinations", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case destinations
        }
    }

    public struct Repository: AWSDecodableShape {
        /// The date and time, in JavaScript date format, when the repository was created.
        public let createdAt: Date?
        /// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
        public let encryptionConfiguration: EncryptionConfiguration?
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The tag mutability setting for the repository.
        public let imageTagMutability: ImageTagMutability?
        /// The AWS account ID associated with the registry that contains the repository.
        public let registryId: String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, AWS account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository/test.
        public let repositoryArn: String?
        /// The name of the repository.
        public let repositoryName: String?
        /// The URI for the repository. You can use this URI for container image push and pull operations.
        public let repositoryUri: String?

        public init(createdAt: Date? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTagMutability: ImageTagMutability? = nil, registryId: String? = nil, repositoryArn: String? = nil, repositoryName: String? = nil, repositoryUri: String? = nil) {
            self.createdAt = createdAt
            self.encryptionConfiguration = encryptionConfiguration
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case encryptionConfiguration
            case imageScanningConfiguration
            case imageTagMutability
            case registryId
            case repositoryArn
            case repositoryName
            case repositoryUri
        }
    }

    public struct SetRepositoryPolicyRequest: AWSEncodableShape {
        /// If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental repository lock outs.
        public let force: Bool?
        /// The JSON repository policy text to apply to the repository. For more information, see Amazon ECR Repository Policies in the Amazon Elastic Container Registry User Guide.
        public let policyText: String
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to receive the policy.
        public let repositoryName: String

        public init(force: Bool? = nil, policyText: String, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10240)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case force
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct SetRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text applied to the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText
            case registryId
            case repositoryName
        }
    }

    public struct StartImageScanRequest: AWSEncodableShape {
        public let imageId: ImageIdentifier
        /// The AWS account ID associated with the registry that contains the repository in which to start an image scan request. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that contains the images to scan.
        public let repositoryName: String

        public init(imageId: ImageIdentifier, registryId: String? = nil, repositoryName: String) {
            self.imageId = imageId
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageId.validate(name: "\(name).imageId")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case imageId
            case registryId
            case repositoryName
        }
    }

    public struct StartImageScanResponse: AWSDecodableShape {
        public let imageId: ImageIdentifier?
        /// The current state of the scan.
        public let imageScanStatus: ImageScanStatus?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(imageId: ImageIdentifier? = nil, imageScanStatus: ImageScanStatus? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageScanStatus = imageScanStatus
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId
            case imageScanStatus
            case registryId
            case repositoryName
        }
    }

    public struct StartLifecyclePolicyPreviewRequest: AWSEncodableShape {
        /// The policy to be evaluated against. If you do not specify a policy, the current policy for the repository is used.
        public let lifecyclePolicyText: String?
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to be evaluated.
        public let repositoryName: String

        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, max: 30720)
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, min: 100)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText
            case registryId
            case repositoryName
        }
    }

    public struct StartLifecyclePolicyPreviewResponse: AWSDecodableShape {
        /// The JSON repository policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The status of the lifecycle policy preview request.
        public let status: LifecyclePolicyPreviewStatus?

        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil, status: LifecyclePolicyPreviewStatus? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText
            case registryId
            case repositoryName
            case status
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the the resource to which to add tags. Currently, the only supported resource is an Amazon ECR repository.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove tags. Currently, the only supported resource is an Amazon ECR repository.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn
            case tagKeys
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UploadLayerPartRequest: AWSEncodableShape {
        /// The base64-encoded layer part payload.
        public let layerPartBlob: Data
        /// The position of the first byte of the layer part witin the overall image layer.
        public let partFirstByte: Int64
        /// The position of the last byte of the layer part within the overall image layer.
        public let partLastByte: Int64
        /// The AWS account ID associated with the registry to which you are uploading layer parts. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to which you are uploading layer parts.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the layer part upload.
        public let uploadId: String

        public init(layerPartBlob: Data, partFirstByte: Int64, partLastByte: Int64, registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerPartBlob = layerPartBlob
            self.partFirstByte = partFirstByte
            self.partLastByte = partLastByte
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.validate(self.layerPartBlob, name: "layerPartBlob", parent: name, max: 20_971_520)
            try self.validate(self.partFirstByte, name: "partFirstByte", parent: name, min: 0)
            try self.validate(self.partLastByte, name: "partLastByte", parent: name, min: 0)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "[0-9]{12}")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case layerPartBlob
            case partFirstByte
            case partLastByte
            case registryId
            case repositoryName
            case uploadId
        }
    }

    public struct UploadLayerPartResponse: AWSDecodableShape {
        /// The integer value of the last byte received in the request.
        public let lastByteReceived: Int64?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The upload ID associated with the request.
        public let uploadId: String?

        public init(lastByteReceived: Int64? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.lastByteReceived = lastByteReceived
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case lastByteReceived
            case registryId
            case repositoryName
            case uploadId
        }
    }
}
