//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ECR {
    // MARK: Enums

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes256 = "AES256"
        case kms = "KMS"
        case kmsDsse = "KMS_DSSE"
        public var description: String { return self.rawValue }
    }

    public enum FindingSeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case informational = "INFORMATIONAL"
        case low = "LOW"
        case medium = "MEDIUM"
        case undefined = "UNDEFINED"
        public var description: String { return self.rawValue }
    }

    public enum ImageActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case expire = "EXPIRE"
        public var description: String { return self.rawValue }
    }

    public enum ImageFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case imageNotFound = "ImageNotFound"
        case imageReferencedByManifestList = "ImageReferencedByManifestList"
        case imageTagDoesNotMatchDigest = "ImageTagDoesNotMatchDigest"
        case invalidImageDigest = "InvalidImageDigest"
        case invalidImageTag = "InvalidImageTag"
        case kmsError = "KmsError"
        case missingDigestAndTag = "MissingDigestAndTag"
        case upstreamAccessDenied = "UpstreamAccessDenied"
        case upstreamTooManyRequests = "UpstreamTooManyRequests"
        case upstreamUnavailable = "UpstreamUnavailable"
        public var description: String { return self.rawValue }
    }

    public enum ImageTagMutability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case immutable = "IMMUTABLE"
        case mutable = "MUTABLE"
        public var description: String { return self.rawValue }
    }

    public enum LayerAvailability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum LayerFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalidLayerDigest = "InvalidLayerDigest"
        case missingLayerDigest = "MissingLayerDigest"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyPreviewStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum RCTAppliedFor: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pullThroughCache = "PULL_THROUGH_CACHE"
        case replication = "REPLICATION"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum RepositoryFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case prefixMatch = "PREFIX_MATCH"
        public var description: String { return self.rawValue }
    }

    public enum ScanFrequency: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuousScan = "CONTINUOUS_SCAN"
        case manual = "MANUAL"
        case scanOnPush = "SCAN_ON_PUSH"
        public var description: String { return self.rawValue }
    }

    public enum ScanStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case complete = "COMPLETE"
        case failed = "FAILED"
        case findingsUnavailable = "FINDINGS_UNAVAILABLE"
        case inProgress = "IN_PROGRESS"
        case limitExceeded = "LIMIT_EXCEEDED"
        case pending = "PENDING"
        case scanEligibilityExpired = "SCAN_ELIGIBILITY_EXPIRED"
        case unsupportedImage = "UNSUPPORTED_IMAGE"
        public var description: String { return self.rawValue }
    }

    public enum ScanType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case enhanced = "ENHANCED"
        public var description: String { return self.rawValue }
    }

    public enum ScanningConfigurationFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case repositoryNotFound = "REPOSITORY_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum ScanningRepositoryFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case wildcard = "WILDCARD"
        public var description: String { return self.rawValue }
    }

    public enum TagStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case any = "ANY"
        case tagged = "TAGGED"
        case untagged = "UNTAGGED"
        public var description: String { return self.rawValue }
    }

    public enum UpstreamRegistry: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case azureContainerRegistry = "azure-container-registry"
        case dockerHub = "docker-hub"
        case ecr = "ecr"
        case ecrPublic = "ecr-public"
        case gitHubContainerRegistry = "github-container-registry"
        case gitLabContainerRegistry = "gitlab-container-registry"
        case k8s = "k8s"
        case quay = "quay"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Attribute: AWSDecodableShape {
        /// The attribute key.
        public let key: String
        /// The value assigned to the attribute key.
        public let value: String?

        @inlinable
        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct AuthorizationData: AWSDecodableShape {
        /// A base64-encoded string that contains authorization data for the specified Amazon ECR registry. When the string is decoded, it is presented in the format user:password for private registry authentication using docker login.
        public let authorizationToken: String?
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public let expiresAt: Date?
        /// The registry URL to use for this authorization token in a docker login command. The Amazon ECR registry URL format is https://aws_account_id.dkr.ecr.region.amazonaws.com. For example, https://012345678910.dkr.ecr.us-east-1.amazonaws.com..
        public let proxyEndpoint: String?

        @inlinable
        public init(authorizationToken: String? = nil, expiresAt: Date? = nil, proxyEndpoint: String? = nil) {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
            self.proxyEndpoint = proxyEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationToken = "authorizationToken"
            case expiresAt = "expiresAt"
            case proxyEndpoint = "proxyEndpoint"
        }
    }

    public struct AwsEcrContainerImageDetails: AWSDecodableShape {
        /// The architecture of the Amazon ECR container image.
        public let architecture: String?
        /// The image author of the Amazon ECR container image.
        public let author: String?
        /// The image hash of the Amazon ECR container image.
        public let imageHash: String?
        /// The image tags attached to the Amazon ECR container image.
        public let imageTags: [String]?
        /// The platform of the Amazon ECR container image.
        public let platform: String?
        /// The date and time the Amazon ECR container image was pushed.
        public let pushedAt: Date?
        /// The registry the Amazon ECR container image belongs to.
        public let registry: String?
        /// The name of the repository the Amazon ECR container image resides in.
        public let repositoryName: String?

        @inlinable
        public init(architecture: String? = nil, author: String? = nil, imageHash: String? = nil, imageTags: [String]? = nil, platform: String? = nil, pushedAt: Date? = nil, registry: String? = nil, repositoryName: String? = nil) {
            self.architecture = architecture
            self.author = author
            self.imageHash = imageHash
            self.imageTags = imageTags
            self.platform = platform
            self.pushedAt = pushedAt
            self.registry = registry
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case author = "author"
            case imageHash = "imageHash"
            case imageTags = "imageTags"
            case platform = "platform"
            case pushedAt = "pushedAt"
            case registry = "registry"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchCheckLayerAvailabilityRequest: AWSEncodableShape {
        /// The digests of the image layers to check.
        public let layerDigests: [String]
        /// The Amazon Web Services account ID associated with the registry that contains the image layers to check. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the image layers to check.
        public let repositoryName: String

        @inlinable
        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, max: 1000)
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests = "layerDigests"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchCheckLayerAvailabilityResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [LayerFailure]?
        /// A list of image layer objects corresponding to the image layer references in the request.
        public let layers: [Layer]?

        @inlinable
        public init(failures: [LayerFailure]? = nil, layers: [Layer]? = nil) {
            self.failures = failures
            self.layers = layers
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case layers = "layers"
        }
    }

    public struct BatchDeleteImageRequest: AWSEncodableShape {
        /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The Amazon Web Services account ID associated with the registry that contains the image to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository that contains the image to delete.
        public let repositoryName: String

        @inlinable
        public init(imageIds: [ImageIdentifier], registryId: String? = nil, repositoryName: String) {
            self.imageIds = imageIds
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds = "imageIds"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchDeleteImageResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?
        /// The image IDs of the deleted images.
        public let imageIds: [ImageIdentifier]?

        @inlinable
        public init(failures: [ImageFailure]? = nil, imageIds: [ImageIdentifier]? = nil) {
            self.failures = failures
            self.imageIds = imageIds
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case imageIds = "imageIds"
        }
    }

    public struct BatchGetImageRequest: AWSEncodableShape {
        /// The accepted media types for the request. Valid values: application/vnd.docker.distribution.manifest.v1+json | application/vnd.docker.distribution.manifest.v2+json | application/vnd.oci.image.manifest.v1+json
        public let acceptedMediaTypes: [String]?
        /// A list of image ID references that correspond to images to describe. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The Amazon Web Services account ID associated with the registry that contains the images to describe. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository that contains the images to describe.
        public let repositoryName: String

        @inlinable
        public init(acceptedMediaTypes: [String]? = nil, imageIds: [ImageIdentifier], registryId: String? = nil, repositoryName: String) {
            self.acceptedMediaTypes = acceptedMediaTypes
            self.imageIds = imageIds
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptedMediaTypes, name: "acceptedMediaTypes", parent: name, max: 100)
            try self.validate(self.acceptedMediaTypes, name: "acceptedMediaTypes", parent: name, min: 1)
            try self.imageIds.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedMediaTypes = "acceptedMediaTypes"
            case imageIds = "imageIds"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchGetImageResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?
        /// A list of image objects corresponding to the image references in the request.
        public let images: [Image]?

        @inlinable
        public init(failures: [ImageFailure]? = nil, images: [Image]? = nil) {
            self.failures = failures
            self.images = images
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case images = "images"
        }
    }

    public struct BatchGetRepositoryScanningConfigurationRequest: AWSEncodableShape {
        /// One or more repository names to get the scanning configuration for.
        public let repositoryNames: [String]

        @inlinable
        public init(repositoryNames: [String]) {
            self.repositoryNames = repositoryNames
        }

        public func validate(name: String) throws {
            try self.repositoryNames.forEach {
                try validate($0, name: "repositoryNames[]", parent: name, max: 256)
                try validate($0, name: "repositoryNames[]", parent: name, min: 2)
                try validate($0, name: "repositoryNames[]", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            }
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, max: 25)
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryNames = "repositoryNames"
        }
    }

    public struct BatchGetRepositoryScanningConfigurationResponse: AWSDecodableShape {
        /// Any failures associated with the call.
        public let failures: [RepositoryScanningConfigurationFailure]?
        /// The scanning configuration for the requested repositories.
        public let scanningConfigurations: [RepositoryScanningConfiguration]?

        @inlinable
        public init(failures: [RepositoryScanningConfigurationFailure]? = nil, scanningConfigurations: [RepositoryScanningConfiguration]? = nil) {
            self.failures = failures
            self.scanningConfigurations = scanningConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case scanningConfigurations = "scanningConfigurations"
        }
    }

    public struct CompleteLayerUploadRequest: AWSEncodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigests: [String]
        /// The Amazon Web Services account ID associated with the registry to which to upload layers. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to associate with the image layer.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the image layer.
        public let uploadId: String

        @inlinable
        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.layerDigests.forEach {
                try validate($0, name: "layerDigests[]", parent: name, pattern: "^[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+$")
            }
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, max: 100)
            try self.validate(self.layerDigests, name: "layerDigests", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests = "layerDigests"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct CompleteLayerUploadResponse: AWSDecodableShape {
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The upload ID associated with the layer.
        public let uploadId: String?

        @inlinable
        public init(layerDigest: String? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest = "layerDigest"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct CreatePullThroughCacheRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that identifies the credentials to authenticate to the upstream registry.
        public let credentialArn: String?
        /// Amazon Resource Name (ARN) of the IAM role to be assumed by Amazon ECR to authenticate to the ECR upstream registry. This role must be in the same account as the registry that you are configuring.
        public let customRoleArn: String?
        /// The repository name prefix to use when caching images from the source registry.  There is always an assumed / applied to the end of the prefix. If you specify ecr-public as the prefix, Amazon ECR treats that as ecr-public/.
        public let ecrRepositoryPrefix: String
        /// The Amazon Web Services account ID associated with the registry to create the pull through cache rule for. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the upstream registry.
        public let upstreamRegistry: UpstreamRegistry?
        /// The registry URL of the upstream public registry to use as the source for the pull through cache rule. The following is the syntax to use for each supported upstream registry.   Amazon ECR (ecr) – .dkr.ecr..amazonaws.com    Amazon ECR Public (ecr-public) – public.ecr.aws    Docker Hub (docker-hub) – registry-1.docker.io    GitHub Container Registry (github-container-registry) – ghcr.io    GitLab Container Registry (gitlab-container-registry) – registry.gitlab.com    Kubernetes (k8s) – registry.k8s.io    Microsoft Azure Container Registry (azure-container-registry) – .azurecr.io    Quay (quay) – quay.io
        public let upstreamRegistryUrl: String
        /// The repository name prefix of the upstream registry to match with the upstream repository name. When this field isn't specified, Amazon ECR will use the ROOT.
        public let upstreamRepositoryPrefix: String?

        @inlinable
        public init(credentialArn: String? = nil, customRoleArn: String? = nil, ecrRepositoryPrefix: String, registryId: String? = nil, upstreamRegistry: UpstreamRegistry? = nil, upstreamRegistryUrl: String, upstreamRepositoryPrefix: String? = nil) {
            self.credentialArn = credentialArn
            self.customRoleArn = customRoleArn
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
            self.upstreamRegistry = upstreamRegistry
            self.upstreamRegistryUrl = upstreamRegistryUrl
            self.upstreamRepositoryPrefix = upstreamRepositoryPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialArn, name: "credentialArn", parent: name, max: 612)
            try self.validate(self.credentialArn, name: "credentialArn", parent: name, min: 50)
            try self.validate(self.credentialArn, name: "credentialArn", parent: name, pattern: "^arn:aws:secretsmanager:[a-zA-Z0-9-:]+:secret:ecr\\-pullthroughcache\\/[a-zA-Z0-9\\/_+=.@-]+$")
            try self.validate(self.customRoleArn, name: "customRoleArn", parent: name, max: 2048)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, max: 30)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, min: 2)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.upstreamRepositoryPrefix, name: "upstreamRepositoryPrefix", parent: name, max: 30)
            try self.validate(self.upstreamRepositoryPrefix, name: "upstreamRepositoryPrefix", parent: name, min: 2)
            try self.validate(self.upstreamRepositoryPrefix, name: "upstreamRepositoryPrefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialArn = "credentialArn"
            case customRoleArn = "customRoleArn"
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
            case upstreamRegistry = "upstreamRegistry"
            case upstreamRegistryUrl = "upstreamRegistryUrl"
            case upstreamRepositoryPrefix = "upstreamRepositoryPrefix"
        }
    }

    public struct CreatePullThroughCacheRuleResponse: AWSDecodableShape {
        /// The date and time, in JavaScript date format, when the pull through cache rule was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret associated with the pull through cache rule.
        public let credentialArn: String?
        /// The ARN of the IAM role associated with the pull through cache rule.
        public let customRoleArn: String?
        /// The Amazon ECR repository prefix associated with the pull through cache rule.
        public let ecrRepositoryPrefix: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The name of the upstream registry associated with the pull through cache rule.
        public let upstreamRegistry: UpstreamRegistry?
        /// The upstream registry URL associated with the pull through cache rule.
        public let upstreamRegistryUrl: String?
        /// The upstream repository prefix associated with the pull through cache rule.
        public let upstreamRepositoryPrefix: String?

        @inlinable
        public init(createdAt: Date? = nil, credentialArn: String? = nil, customRoleArn: String? = nil, ecrRepositoryPrefix: String? = nil, registryId: String? = nil, upstreamRegistry: UpstreamRegistry? = nil, upstreamRegistryUrl: String? = nil, upstreamRepositoryPrefix: String? = nil) {
            self.createdAt = createdAt
            self.credentialArn = credentialArn
            self.customRoleArn = customRoleArn
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
            self.upstreamRegistry = upstreamRegistry
            self.upstreamRegistryUrl = upstreamRegistryUrl
            self.upstreamRepositoryPrefix = upstreamRepositoryPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialArn = "credentialArn"
            case customRoleArn = "customRoleArn"
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
            case upstreamRegistry = "upstreamRegistry"
            case upstreamRegistryUrl = "upstreamRegistryUrl"
            case upstreamRepositoryPrefix = "upstreamRepositoryPrefix"
        }
    }

    public struct CreateRepositoryCreationTemplateRequest: AWSEncodableShape {
        /// A list of enumerable strings representing the Amazon ECR repository creation scenarios that this template will apply towards. The two supported scenarios are PULL_THROUGH_CACHE and REPLICATION
        public let appliedFor: [RCTAppliedFor]
        /// The ARN of the role to be assumed by Amazon ECR. This role must be in the same account as the registry that you are configuring. Amazon ECR will assume your supplied role when the customRoleArn is specified. When this field isn't specified, Amazon ECR will use the service-linked role for the repository creation template.
        public let customRoleArn: String?
        /// A description for the repository creation template.
        public let description: String?
        /// The encryption configuration to use for repositories created using the template.
        public let encryptionConfiguration: EncryptionConfigurationForRepositoryCreationTemplate?
        /// The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        public let imageTagMutability: ImageTagMutability?
        /// The lifecycle policy to use for repositories created using the template.
        public let lifecyclePolicy: String?
        /// The repository namespace prefix to associate with the template. All repositories created using this namespace prefix will have the settings defined in this template applied. For example, a prefix of prod would apply to all repositories beginning with prod/. Similarly, a prefix of prod/team would apply to all repositories beginning with prod/team/. To apply a template to all repositories in your registry that don't have an associated creation template, you can use ROOT as the prefix.  There is always an assumed / applied to the end of the prefix. If you specify ecr-public as the prefix, Amazon ECR treats that as ecr-public/. When using a pull through cache rule, the repository prefix you specify during rule creation is what you should specify as your repository creation template prefix as well.
        public let prefix: String
        /// The repository policy to apply to repositories created using the template. A repository policy is a permissions policy associated with a repository to control access permissions.
        public let repositoryPolicy: String?
        /// The metadata to apply to the repository to help you categorize and organize. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let resourceTags: [Tag]?

        @inlinable
        public init(appliedFor: [RCTAppliedFor], customRoleArn: String? = nil, description: String? = nil, encryptionConfiguration: EncryptionConfigurationForRepositoryCreationTemplate? = nil, imageTagMutability: ImageTagMutability? = nil, lifecyclePolicy: String? = nil, prefix: String, repositoryPolicy: String? = nil, resourceTags: [Tag]? = nil) {
            self.appliedFor = appliedFor
            self.customRoleArn = customRoleArn
            self.description = description
            self.encryptionConfiguration = encryptionConfiguration
            self.imageTagMutability = imageTagMutability
            self.lifecyclePolicy = lifecyclePolicy
            self.prefix = prefix
            self.repositoryPolicy = repositoryPolicy
            self.resourceTags = resourceTags
        }

        public func validate(name: String) throws {
            try self.validate(self.customRoleArn, name: "customRoleArn", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.lifecyclePolicy, name: "lifecyclePolicy", parent: name, max: 30720)
            try self.validate(self.prefix, name: "prefix", parent: name, max: 256)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            try self.validate(self.repositoryPolicy, name: "repositoryPolicy", parent: name, max: 10240)
        }

        private enum CodingKeys: String, CodingKey {
            case appliedFor = "appliedFor"
            case customRoleArn = "customRoleArn"
            case description = "description"
            case encryptionConfiguration = "encryptionConfiguration"
            case imageTagMutability = "imageTagMutability"
            case lifecyclePolicy = "lifecyclePolicy"
            case prefix = "prefix"
            case repositoryPolicy = "repositoryPolicy"
            case resourceTags = "resourceTags"
        }
    }

    public struct CreateRepositoryCreationTemplateResponse: AWSDecodableShape {
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The details of the repository creation template associated with the request.
        public let repositoryCreationTemplate: RepositoryCreationTemplate?

        @inlinable
        public init(registryId: String? = nil, repositoryCreationTemplate: RepositoryCreationTemplate? = nil) {
            self.registryId = registryId
            self.repositoryCreationTemplate = repositoryCreationTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryCreationTemplate = "repositoryCreationTemplate"
        }
    }

    public struct CreateRepositoryRequest: AWSEncodableShape {
        /// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        public let imageTagMutability: ImageTagMutability?
        /// The Amazon Web Services account ID associated with the registry to create the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name to use for the repository. The repository name may be specified on its own (such as nginx-web-app) or it can be prepended with a namespace to group the repository into a category (such as project-a/nginx-web-app). The repository name must start with a letter and can only contain lowercase letters, numbers, hyphens, underscores, and forward slashes.
        public let repositoryName: String
        /// The metadata that you apply to the repository to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]?

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTagMutability: ImageTagMutability? = nil, registryId: String? = nil, repositoryName: String, tags: [Tag]? = nil) {
            self.encryptionConfiguration = encryptionConfiguration
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "encryptionConfiguration"
            case imageScanningConfiguration = "imageScanningConfiguration"
            case imageTagMutability = "imageTagMutability"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case tags = "tags"
        }
    }

    public struct CreateRepositoryResponse: AWSDecodableShape {
        /// The repository that was created.
        public let repository: Repository?

        @inlinable
        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct CvssScore: AWSDecodableShape {
        /// The base CVSS score used for the finding.
        public let baseScore: Double?
        /// The vector string of the CVSS score.
        public let scoringVector: String?
        /// The source of the CVSS score.
        public let source: String?
        /// The version of CVSS used for the score.
        public let version: String?

        @inlinable
        public init(baseScore: Double? = nil, scoringVector: String? = nil, source: String? = nil, version: String? = nil) {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case baseScore = "baseScore"
            case scoringVector = "scoringVector"
            case source = "source"
            case version = "version"
        }
    }

    public struct CvssScoreAdjustment: AWSDecodableShape {
        /// The metric used to adjust the CVSS score.
        public let metric: String?
        /// The reason the CVSS score has been adjustment.
        public let reason: String?

        @inlinable
        public init(metric: String? = nil, reason: String? = nil) {
            self.metric = metric
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "metric"
            case reason = "reason"
        }
    }

    public struct CvssScoreDetails: AWSDecodableShape {
        /// An object that contains details about adjustment Amazon Inspector made to the CVSS score.
        public let adjustments: [CvssScoreAdjustment]?
        /// The CVSS score.
        public let score: Double?
        /// The source for the CVSS score.
        public let scoreSource: String?
        /// The vector for the CVSS score.
        public let scoringVector: String?
        /// The CVSS version used in scoring.
        public let version: String?

        @inlinable
        public init(adjustments: [CvssScoreAdjustment]? = nil, score: Double? = nil, scoreSource: String? = nil, scoringVector: String? = nil, version: String? = nil) {
            self.adjustments = adjustments
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case adjustments = "adjustments"
            case score = "score"
            case scoreSource = "scoreSource"
            case scoringVector = "scoringVector"
            case version = "version"
        }
    }

    public struct DeleteLifecyclePolicyRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        @inlinable
        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteLifecyclePolicyResponse: AWSDecodableShape {
        /// The time stamp of the last time that the lifecycle policy was run.
        public let lastEvaluatedAt: Date?
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(lastEvaluatedAt: Date? = nil, lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.lastEvaluatedAt = lastEvaluatedAt
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case lastEvaluatedAt = "lastEvaluatedAt"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeletePullThroughCacheRuleRequest: AWSEncodableShape {
        /// The Amazon ECR repository prefix associated with the pull through cache rule to delete.
        public let ecrRepositoryPrefix: String
        /// The Amazon Web Services account ID associated with the registry that contains the pull through cache rule. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?

        @inlinable
        public init(ecrRepositoryPrefix: String, registryId: String? = nil) {
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, max: 30)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, min: 2)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
        }
    }

    public struct DeletePullThroughCacheRuleResponse: AWSDecodableShape {
        /// The timestamp associated with the pull through cache rule.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret associated with the pull through cache rule.
        public let credentialArn: String?
        /// The ARN of the IAM role associated with the pull through cache rule.
        public let customRoleArn: String?
        /// The Amazon ECR repository prefix associated with the request.
        public let ecrRepositoryPrefix: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The upstream registry URL associated with the pull through cache rule.
        public let upstreamRegistryUrl: String?
        /// The upstream repository prefix associated with the pull through cache rule.
        public let upstreamRepositoryPrefix: String?

        @inlinable
        public init(createdAt: Date? = nil, credentialArn: String? = nil, customRoleArn: String? = nil, ecrRepositoryPrefix: String? = nil, registryId: String? = nil, upstreamRegistryUrl: String? = nil, upstreamRepositoryPrefix: String? = nil) {
            self.createdAt = createdAt
            self.credentialArn = credentialArn
            self.customRoleArn = customRoleArn
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
            self.upstreamRegistryUrl = upstreamRegistryUrl
            self.upstreamRepositoryPrefix = upstreamRepositoryPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialArn = "credentialArn"
            case customRoleArn = "customRoleArn"
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
            case upstreamRegistryUrl = "upstreamRegistryUrl"
            case upstreamRepositoryPrefix = "upstreamRepositoryPrefix"
        }
    }

    public struct DeleteRegistryPolicyRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteRegistryPolicyResponse: AWSDecodableShape {
        /// The contents of the registry permissions policy that was deleted.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?

        @inlinable
        public init(policyText: String? = nil, registryId: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
        }
    }

    public struct DeleteRepositoryCreationTemplateRequest: AWSEncodableShape {
        /// The repository namespace prefix associated with the repository creation template.
        public let prefix: String

        @inlinable
        public init(prefix: String) {
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.prefix, name: "prefix", parent: name, max: 256)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "prefix"
        }
    }

    public struct DeleteRepositoryCreationTemplateResponse: AWSDecodableShape {
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The details of the repository creation template that was deleted.
        public let repositoryCreationTemplate: RepositoryCreationTemplate?

        @inlinable
        public init(registryId: String? = nil, repositoryCreationTemplate: RepositoryCreationTemplate? = nil) {
            self.registryId = registryId
            self.repositoryCreationTemplate = repositoryCreationTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryCreationTemplate = "repositoryCreationTemplate"
        }
    }

    public struct DeleteRepositoryPolicyRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID associated with the registry that contains the repository policy to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the repository policy to delete.
        public let repositoryName: String

        @inlinable
        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy that was deleted from the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryRequest: AWSEncodableShape {
        /// If true, deleting the repository force deletes the contents of the repository. If false, the repository must be empty before attempting to delete it.
        public let force: Bool?
        /// The Amazon Web Services account ID associated with the registry that contains the repository to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to delete.
        public let repositoryName: String

        @inlinable
        public init(force: Bool? = nil, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case force = "force"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryResponse: AWSDecodableShape {
        /// The repository that was deleted.
        public let repository: Repository?

        @inlinable
        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public struct DescribeImageReplicationStatusRequest: AWSEncodableShape {
        public let imageId: ImageIdentifier
        /// The Amazon Web Services account ID associated with the registry. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that the image is in.
        public let repositoryName: String

        @inlinable
        public init(imageId: ImageIdentifier, registryId: String? = nil, repositoryName: String) {
            self.imageId = imageId
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageId.validate(name: "\(name).imageId")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImageReplicationStatusResponse: AWSDecodableShape {
        public let imageId: ImageIdentifier?
        /// The replication status details for the images in the specified repository.
        public let replicationStatuses: [ImageReplicationStatus]?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(imageId: ImageIdentifier? = nil, replicationStatuses: [ImageReplicationStatus]? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.replicationStatuses = replicationStatuses
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case replicationStatuses = "replicationStatuses"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImageScanFindingsRequest: AWSEncodableShape {
        public let imageId: ImageIdentifier
        /// The maximum number of image scan results returned by DescribeImageScanFindings in paginated output. When this parameter is used, DescribeImageScanFindings only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImageScanFindings request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImageScanFindings returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeImageScanFindings request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The Amazon Web Services account ID associated with the registry that contains the repository in which to describe the image scan findings for. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository for the image for which to describe the scan findings.
        public let repositoryName: String

        @inlinable
        public init(imageId: ImageIdentifier, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageId = imageId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageId.validate(name: "\(name).imageId")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImageScanFindingsResponse: AWSDecodableShape {
        public let imageId: ImageIdentifier?
        /// The information contained in the image scan findings.
        public let imageScanFindings: ImageScanFindings?
        /// The current state of the scan.
        public let imageScanStatus: ImageScanStatus?
        /// The nextToken value to include in a future DescribeImageScanFindings request. When the results of a DescribeImageScanFindings request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(imageId: ImageIdentifier? = nil, imageScanFindings: ImageScanFindings? = nil, imageScanStatus: ImageScanStatus? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageScanFindings = imageScanFindings
            self.imageScanStatus = imageScanStatus
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case imageScanFindings = "imageScanFindings"
            case imageScanStatus = "imageScanStatus"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImagesFilter: AWSEncodableShape {
        /// The tag status with which to filter your DescribeImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public let tagStatus: TagStatus?

        @inlinable
        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus = "tagStatus"
        }
    }

    public struct DescribeImagesRequest: AWSEncodableShape {
        /// The filter key and value with which to filter your DescribeImages results.
        public let filter: DescribeImagesFilter?
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?
        /// The maximum number of repository results returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImages returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The Amazon Web Services account ID associated with the registry that contains the repository in which to describe images. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository that contains the images to describe.
        public let repositoryName: String

        @inlinable
        public init(filter: DescribeImagesFilter? = nil, imageIds: [ImageIdentifier]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.filter = filter
            self.imageIds = imageIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds?.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case imageIds = "imageIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImagesResponse: AWSDecodableShape {
        /// A list of ImageDetail objects that contain data about the image.
        public let imageDetails: [ImageDetail]?
        /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(imageDetails: [ImageDetail]? = nil, nextToken: String? = nil) {
            self.imageDetails = imageDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageDetails = "imageDetails"
            case nextToken = "nextToken"
        }
    }

    public struct DescribePullThroughCacheRulesRequest: AWSEncodableShape {
        /// The Amazon ECR repository prefixes associated with the pull through cache rules to return. If no repository prefix value is specified, all pull through cache rules are returned.
        public let ecrRepositoryPrefixes: [String]?
        /// The maximum number of pull through cache rules returned by DescribePullThroughCacheRulesRequest in paginated output. When this parameter is used, DescribePullThroughCacheRulesRequest only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribePullThroughCacheRulesRequest request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribePullThroughCacheRulesRequest returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribePullThroughCacheRulesRequest request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The Amazon Web Services account ID associated with the registry to return the pull through cache rules for. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?

        @inlinable
        public init(ecrRepositoryPrefixes: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil) {
            self.ecrRepositoryPrefixes = ecrRepositoryPrefixes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.ecrRepositoryPrefixes?.forEach {
                try validate($0, name: "ecrRepositoryPrefixes[]", parent: name, max: 30)
                try validate($0, name: "ecrRepositoryPrefixes[]", parent: name, min: 2)
                try validate($0, name: "ecrRepositoryPrefixes[]", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            }
            try self.validate(self.ecrRepositoryPrefixes, name: "ecrRepositoryPrefixes", parent: name, max: 100)
            try self.validate(self.ecrRepositoryPrefixes, name: "ecrRepositoryPrefixes", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case ecrRepositoryPrefixes = "ecrRepositoryPrefixes"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
        }
    }

    public struct DescribePullThroughCacheRulesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribePullThroughCacheRulesRequest request. When the results of a DescribePullThroughCacheRulesRequest request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The details of the pull through cache rules.
        public let pullThroughCacheRules: [PullThroughCacheRule]?

        @inlinable
        public init(nextToken: String? = nil, pullThroughCacheRules: [PullThroughCacheRule]? = nil) {
            self.nextToken = nextToken
            self.pullThroughCacheRules = pullThroughCacheRules
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case pullThroughCacheRules = "pullThroughCacheRules"
        }
    }

    public struct DescribeRegistryRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeRegistryResponse: AWSDecodableShape {
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The replication configuration for the registry.
        public let replicationConfiguration: ReplicationConfiguration?

        @inlinable
        public init(registryId: String? = nil, replicationConfiguration: ReplicationConfiguration? = nil) {
            self.registryId = registryId
            self.replicationConfiguration = replicationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case replicationConfiguration = "replicationConfiguration"
        }
    }

    public struct DescribeRepositoriesRequest: AWSEncodableShape {
        /// The maximum number of repository results returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify repositories with repositoryNames.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify repositories with repositoryNames.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The Amazon Web Services account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public let repositoryNames: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryNames: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryNames = repositoryNames
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.repositoryNames?.forEach {
                try validate($0, name: "repositoryNames[]", parent: name, max: 256)
                try validate($0, name: "repositoryNames[]", parent: name, min: 2)
                try validate($0, name: "repositoryNames[]", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            }
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, max: 100)
            try self.validate(self.repositoryNames, name: "repositoryNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryNames = "repositoryNames"
        }
    }

    public struct DescribeRepositoriesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of repository objects corresponding to valid repositories.
        public let repositories: [Repository]?

        @inlinable
        public init(nextToken: String? = nil, repositories: [Repository]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct DescribeRepositoryCreationTemplatesRequest: AWSEncodableShape {
        /// The maximum number of repository results returned by DescribeRepositoryCreationTemplatesRequest in paginated output. When this parameter is used, DescribeRepositoryCreationTemplatesRequest only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositoryCreationTemplatesRequest request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRepositoryCreationTemplatesRequest returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeRepositoryCreationTemplates request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The repository namespace prefixes associated with the repository creation templates to describe. If this value is not specified, all repository creation templates are returned.
        public let prefixes: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, prefixes: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.prefixes = prefixes
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.prefixes?.forEach {
                try validate($0, name: "prefixes[]", parent: name, max: 256)
                try validate($0, name: "prefixes[]", parent: name, min: 1)
                try validate($0, name: "prefixes[]", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case prefixes = "prefixes"
        }
    }

    public struct DescribeRepositoryCreationTemplatesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future DescribeRepositoryCreationTemplates request. When the results of a DescribeRepositoryCreationTemplates request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The details of the repository creation templates.
        public let repositoryCreationTemplates: [RepositoryCreationTemplate]?

        @inlinable
        public init(nextToken: String? = nil, registryId: String? = nil, repositoryCreationTemplates: [RepositoryCreationTemplate]? = nil) {
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryCreationTemplates = repositoryCreationTemplates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryCreationTemplates = "repositoryCreationTemplates"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The encryption type to use. If you use the KMS encryption type, the contents of the repository will be encrypted using server-side encryption with Key Management Service key stored in KMS. When you use KMS to encrypt your data, you can either use the default Amazon Web Services managed KMS key for Amazon ECR, or specify your own KMS key, which you already created. If you use the KMS_DSSE encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the KMS Management Service key stored in KMS. Similar to the KMS encryption type, you can either use the default Amazon Web Services managed KMS key for Amazon ECR, or specify your own KMS key, which you've already created.  If you use the AES256 encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm. For more information, see Amazon ECR encryption at rest in the Amazon Elastic Container Registry User Guide.
        public let encryptionType: EncryptionType
        /// If you use the KMS encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default Amazon Web Services managed KMS key for Amazon ECR will be used.
        public let kmsKey: String?

        @inlinable
        public init(encryptionType: EncryptionType, kmsKey: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKey = "kmsKey"
        }
    }

    public struct EncryptionConfigurationForRepositoryCreationTemplate: AWSEncodableShape & AWSDecodableShape {
        /// The encryption type to use. If you use the KMS encryption type, the contents of the repository will be encrypted using server-side encryption with Key Management Service key stored in KMS. When you use KMS to encrypt your data, you can either use the default Amazon Web Services managed KMS key for Amazon ECR, or specify your own KMS key, which you already created. For more information, see Protecting data using server-side encryption with an KMS key stored in Key Management Service (SSE-KMS) in the Amazon Simple Storage Service Console Developer Guide. If you use the AES256 encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm. For more information, see Protecting data using server-side encryption with Amazon S3-managed encryption keys (SSE-S3) in the Amazon Simple Storage Service Console Developer Guide.
        public let encryptionType: EncryptionType
        /// If you use the KMS encryption type, specify the KMS key to use for encryption. The full ARN of the KMS key must be specified. The key must exist in the same Region as the repository. If no key is specified, the default Amazon Web Services managed KMS key for Amazon ECR will be used.
        public let kmsKey: String?

        @inlinable
        public init(encryptionType: EncryptionType, kmsKey: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 2048)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "^$|arn:aws:kms:[a-z0-9-]+:[0-9]{12}:key\\/[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKey = "kmsKey"
        }
    }

    public struct EnhancedImageScanFinding: AWSDecodableShape {
        /// The Amazon Web Services account ID associated with the image.
        public let awsAccountId: String?
        /// The description of the finding.
        public let description: String?
        /// If a finding discovered in your environment has an exploit available.
        public let exploitAvailable: String?
        /// The Amazon Resource Number (ARN) of the finding.
        public let findingArn: String?
        /// The date and time that the finding was first observed.
        public let firstObservedAt: Date?
        /// Details on whether a fix is available through a version update. This value can be YES, NO, or PARTIAL. A PARTIAL fix means that some, but not all, of the packages identified in the finding have fixes available through updated versions.
        public let fixAvailable: String?
        /// The date and time that the finding was last observed.
        public let lastObservedAt: Date?
        /// An object that contains the details of a package vulnerability finding.
        public let packageVulnerabilityDetails: PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate a finding.
        public let remediation: Remediation?
        /// Contains information on the resources involved in a finding.
        public let resources: [Resource]?
        /// The Amazon Inspector score given to the finding.
        public let score: Double?
        /// An object that contains details of the Amazon Inspector score.
        public let scoreDetails: ScoreDetails?
        /// The severity of the finding.
        public let severity: String?
        /// The status of the finding.
        public let status: String?
        /// The title of the finding.
        public let title: String?
        /// The type of the finding.
        public let type: String?
        /// The date and time the finding was last updated at.
        public let updatedAt: Date?

        @inlinable
        public init(awsAccountId: String? = nil, description: String? = nil, exploitAvailable: String? = nil, findingArn: String? = nil, firstObservedAt: Date? = nil, fixAvailable: String? = nil, lastObservedAt: Date? = nil, packageVulnerabilityDetails: PackageVulnerabilityDetails? = nil, remediation: Remediation? = nil, resources: [Resource]? = nil, score: Double? = nil, scoreDetails: ScoreDetails? = nil, severity: String? = nil, status: String? = nil, title: String? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.exploitAvailable = exploitAvailable
            self.findingArn = findingArn
            self.firstObservedAt = firstObservedAt
            self.fixAvailable = fixAvailable
            self.lastObservedAt = lastObservedAt
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.resources = resources
            self.score = score
            self.scoreDetails = scoreDetails
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case description = "description"
            case exploitAvailable = "exploitAvailable"
            case findingArn = "findingArn"
            case firstObservedAt = "firstObservedAt"
            case fixAvailable = "fixAvailable"
            case lastObservedAt = "lastObservedAt"
            case packageVulnerabilityDetails = "packageVulnerabilityDetails"
            case remediation = "remediation"
            case resources = "resources"
            case score = "score"
            case scoreDetails = "scoreDetails"
            case severity = "severity"
            case status = "status"
            case title = "title"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetAccountSettingRequest: AWSEncodableShape {
        /// The name of the account setting, such as BASIC_SCAN_TYPE_VERSION or REGISTRY_POLICY_SCOPE.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct GetAccountSettingResponse: AWSDecodableShape {
        /// Retrieves the name of the account setting.
        public let name: String?
        /// The setting value for the setting name. The following are valid values for the basic scan type being used: AWS_NATIVE or CLAIR. The following are valid values for the registry policy scope being used: V1 or V2.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct GetAuthorizationTokenRequest: AWSEncodableShape {
        /// A list of Amazon Web Services account IDs that are associated with the registries for which to get AuthorizationData objects. If you do not specify a registry, the default registry is assumed.
        public let registryIds: [String]?

        @inlinable
        public init() {
            self.registryIds = nil
        }

        @available(*, deprecated, message: "Members registryIds have been deprecated")
        @inlinable
        public init(registryIds: [String]? = nil) {
            self.registryIds = registryIds
        }

        public func validate(name: String) throws {
            try self.registryIds?.forEach {
                try validate($0, name: "registryIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.registryIds, name: "registryIds", parent: name, max: 10)
            try self.validate(self.registryIds, name: "registryIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case registryIds = "registryIds"
        }
    }

    public struct GetAuthorizationTokenResponse: AWSDecodableShape {
        /// A list of authorization token data objects that correspond to the registryIds values in the request.  The size of the authorization token returned by Amazon ECR is not fixed. We recommend that you don't make assumptions about the maximum size.
        public let authorizationData: [AuthorizationData]?

        @inlinable
        public init(authorizationData: [AuthorizationData]? = nil) {
            self.authorizationData = authorizationData
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationData = "authorizationData"
        }
    }

    public struct GetDownloadUrlForLayerRequest: AWSEncodableShape {
        /// The digest of the image layer to download.
        public let layerDigest: String
        /// The Amazon Web Services account ID associated with the registry that contains the image layer to download. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the image layer to download.
        public let repositoryName: String

        @inlinable
        public init(layerDigest: String, registryId: String? = nil, repositoryName: String) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.layerDigest, name: "layerDigest", parent: name, pattern: "^[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+$")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest = "layerDigest"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetDownloadUrlForLayerResponse: AWSDecodableShape {
        /// The pre-signed Amazon S3 download URL for the requested layer.
        public let downloadUrl: String?
        /// The digest of the image layer to download.
        public let layerDigest: String?

        @inlinable
        public init(downloadUrl: String? = nil, layerDigest: String? = nil) {
            self.downloadUrl = downloadUrl
            self.layerDigest = layerDigest
        }

        private enum CodingKeys: String, CodingKey {
            case downloadUrl = "downloadUrl"
            case layerDigest = "layerDigest"
        }
    }

    public struct GetLifecyclePolicyPreviewRequest: AWSEncodableShape {
        /// An optional parameter that filters results based on image tag status and all tags, if tagged.
        public let filter: LifecyclePolicyPreviewFilter?
        /// The list of imageIDs to be included.
        public let imageIds: [ImageIdentifier]?
        /// The maximum number of repository results returned by GetLifecyclePolicyPreviewRequest in  paginated output. When this parameter is used, GetLifecyclePolicyPreviewRequest only returns  maxResults results in a single page along with a nextToken  response element. The remaining results of the initial request can be seen by sending  another GetLifecyclePolicyPreviewRequest request with the returned nextToken  value. This value can be between 1 and 1000. If this  parameter is not used, then GetLifecyclePolicyPreviewRequest returns up to  100 results and a nextToken value, if  applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated  GetLifecyclePolicyPreviewRequest request where maxResults was used and the  results exceeded the value of that parameter. Pagination continues from the end of the  previous results that returned the nextToken value. This value is  null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        @inlinable
        public init(filter: LifecyclePolicyPreviewFilter? = nil, imageIds: [ImageIdentifier]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.filter = filter
            self.imageIds = imageIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageIds?.forEach {
                try $0.validate(name: "\(name).imageIds[]")
            }
            try self.validate(self.imageIds, name: "imageIds", parent: name, max: 100)
            try self.validate(self.imageIds, name: "imageIds", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case imageIds = "imageIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetLifecyclePolicyPreviewResponse: AWSDecodableShape {
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The nextToken value to include in a future GetLifecyclePolicyPreview request. When the results of a GetLifecyclePolicyPreview request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The results of the lifecycle policy preview request.
        public let previewResults: [LifecyclePolicyPreviewResult]?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The status of the lifecycle policy preview request.
        public let status: LifecyclePolicyPreviewStatus?
        /// The list of images that is returned as a result of the action.
        public let summary: LifecyclePolicyPreviewSummary?

        @inlinable
        public init(lifecyclePolicyText: String? = nil, nextToken: String? = nil, previewResults: [LifecyclePolicyPreviewResult]? = nil, registryId: String? = nil, repositoryName: String? = nil, status: LifecyclePolicyPreviewStatus? = nil, summary: LifecyclePolicyPreviewSummary? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.nextToken = nextToken
            self.previewResults = previewResults
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.status = status
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText = "lifecyclePolicyText"
            case nextToken = "nextToken"
            case previewResults = "previewResults"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case status = "status"
            case summary = "summary"
        }
    }

    public struct GetLifecyclePolicyRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        @inlinable
        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetLifecyclePolicyResponse: AWSDecodableShape {
        /// The time stamp of the last time that the lifecycle policy was run.
        public let lastEvaluatedAt: Date?
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(lastEvaluatedAt: Date? = nil, lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.lastEvaluatedAt = lastEvaluatedAt
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case lastEvaluatedAt = "lastEvaluatedAt"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetRegistryPolicyRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetRegistryPolicyResponse: AWSDecodableShape {
        /// The JSON text of the permissions policy for a registry.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?

        @inlinable
        public init(policyText: String? = nil, registryId: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
        }
    }

    public struct GetRegistryScanningConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetRegistryScanningConfigurationResponse: AWSDecodableShape {
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The scanning configuration for the registry.
        public let scanningConfiguration: RegistryScanningConfiguration?

        @inlinable
        public init(registryId: String? = nil, scanningConfiguration: RegistryScanningConfiguration? = nil) {
            self.registryId = registryId
            self.scanningConfiguration = scanningConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case scanningConfiguration = "scanningConfiguration"
        }
    }

    public struct GetRepositoryPolicyRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository with the policy to retrieve.
        public let repositoryName: String

        @inlinable
        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text associated with the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct Image: AWSDecodableShape {
        /// An object containing the image tag and image digest associated with an image.
        public let imageId: ImageIdentifier?
        /// The image manifest associated with the image.
        public let imageManifest: String?
        /// The manifest media type of the image.
        public let imageManifestMediaType: String?
        /// The Amazon Web Services account ID associated with the registry containing the image.
        public let registryId: String?
        /// The name of the repository associated with the image.
        public let repositoryName: String?

        @inlinable
        public init(imageId: ImageIdentifier? = nil, imageManifest: String? = nil, imageManifestMediaType: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case imageManifest = "imageManifest"
            case imageManifestMediaType = "imageManifestMediaType"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct ImageDetail: AWSDecodableShape {
        /// The artifact media type of the image.
        public let artifactMediaType: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The media type of the image manifest.
        public let imageManifestMediaType: String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public let imagePushedAt: Date?
        /// A summary of the last completed image scan.
        public let imageScanFindingsSummary: ImageScanFindingsSummary?
        /// The current state of the scan.
        public let imageScanStatus: ImageScanStatus?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this will be the max size of all manifests in the list.  Starting with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size. Therefore, Docker might return a larger image than the image shown in the Amazon Web Services Management Console.
        public let imageSizeInBytes: Int64?
        /// The list of tags associated with this image.
        public let imageTags: [String]?
        /// The date and time, expressed in standard JavaScript date format, when Amazon ECR recorded the last image pull.  Amazon ECR refreshes the last image pull timestamp at least once every 24 hours. For example, if you pull an image once a day then the lastRecordedPullTime timestamp will indicate the exact time that the image was last pulled. However, if you pull an image once an hour, because Amazon ECR refreshes the lastRecordedPullTime timestamp at least once every 24 hours, the result may not be the exact time that the image was last pulled.
        public let lastRecordedPullTime: Date?
        /// The Amazon Web Services account ID associated with the registry to which this image belongs.
        public let registryId: String?
        /// The name of the repository to which this image belongs.
        public let repositoryName: String?

        @inlinable
        public init(artifactMediaType: String? = nil, imageDigest: String? = nil, imageManifestMediaType: String? = nil, imagePushedAt: Date? = nil, imageScanFindingsSummary: ImageScanFindingsSummary? = nil, imageScanStatus: ImageScanStatus? = nil, imageSizeInBytes: Int64? = nil, imageTags: [String]? = nil, lastRecordedPullTime: Date? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageScanFindingsSummary = imageScanFindingsSummary
            self.imageScanStatus = imageScanStatus
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.lastRecordedPullTime = lastRecordedPullTime
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case artifactMediaType = "artifactMediaType"
            case imageDigest = "imageDigest"
            case imageManifestMediaType = "imageManifestMediaType"
            case imagePushedAt = "imagePushedAt"
            case imageScanFindingsSummary = "imageScanFindingsSummary"
            case imageScanStatus = "imageScanStatus"
            case imageSizeInBytes = "imageSizeInBytes"
            case imageTags = "imageTags"
            case lastRecordedPullTime = "lastRecordedPullTime"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct ImageFailure: AWSDecodableShape {
        /// The code associated with the failure.
        public let failureCode: ImageFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The image ID associated with the failure.
        public let imageId: ImageIdentifier?

        @inlinable
        public init(failureCode: ImageFailureCode? = nil, failureReason: String? = nil, imageId: ImageIdentifier? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case imageId = "imageId"
        }
    }

    public struct ImageIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The tag used for the image.
        public let imageTag: String?

        @inlinable
        public init(imageDigest: String? = nil, imageTag: String? = nil) {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }

        public func validate(name: String) throws {
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest = "imageDigest"
            case imageTag = "imageTag"
        }
    }

    public struct ImageReplicationStatus: AWSDecodableShape {
        /// The failure code for a replication that has failed.
        public let failureCode: String?
        /// The destination Region for the image replication.
        public let region: String?
        /// The Amazon Web Services account ID associated with the registry to which the image belongs.
        public let registryId: String?
        /// The image replication status.
        public let status: ReplicationStatus?

        @inlinable
        public init(failureCode: String? = nil, region: String? = nil, registryId: String? = nil, status: ReplicationStatus? = nil) {
            self.failureCode = failureCode
            self.region = region
            self.registryId = registryId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case region = "region"
            case registryId = "registryId"
            case status = "status"
        }
    }

    public struct ImageScanFinding: AWSDecodableShape {
        /// A collection of attributes of the host from which the finding is generated.
        public let attributes: [Attribute]?
        /// The description of the finding.
        public let description: String?
        /// The name associated with the finding, usually a CVE number.
        public let name: String?
        /// The finding severity.
        public let severity: FindingSeverity?
        /// A link containing additional details about the security vulnerability.
        public let uri: String?

        @inlinable
        public init(attributes: [Attribute]? = nil, description: String? = nil, name: String? = nil, severity: FindingSeverity? = nil, uri: String? = nil) {
            self.attributes = attributes
            self.description = description
            self.name = name
            self.severity = severity
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case description = "description"
            case name = "name"
            case severity = "severity"
            case uri = "uri"
        }
    }

    public struct ImageScanFindings: AWSDecodableShape {
        /// Details about the enhanced scan findings from Amazon Inspector.
        public let enhancedFindings: [EnhancedImageScanFinding]?
        /// The findings from the image scan.
        public let findings: [ImageScanFinding]?
        /// The image vulnerability counts, sorted by severity.
        public let findingSeverityCounts: [FindingSeverity: Int]?
        /// The time of the last completed image scan.
        public let imageScanCompletedAt: Date?
        /// The time when the vulnerability data was last scanned.
        public let vulnerabilitySourceUpdatedAt: Date?

        @inlinable
        public init(enhancedFindings: [EnhancedImageScanFinding]? = nil, findings: [ImageScanFinding]? = nil, findingSeverityCounts: [FindingSeverity: Int]? = nil, imageScanCompletedAt: Date? = nil, vulnerabilitySourceUpdatedAt: Date? = nil) {
            self.enhancedFindings = enhancedFindings
            self.findings = findings
            self.findingSeverityCounts = findingSeverityCounts
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case enhancedFindings = "enhancedFindings"
            case findings = "findings"
            case findingSeverityCounts = "findingSeverityCounts"
            case imageScanCompletedAt = "imageScanCompletedAt"
            case vulnerabilitySourceUpdatedAt = "vulnerabilitySourceUpdatedAt"
        }
    }

    public struct ImageScanFindingsSummary: AWSDecodableShape {
        /// The image vulnerability counts, sorted by severity.
        public let findingSeverityCounts: [FindingSeverity: Int]?
        /// The time of the last completed image scan.
        public let imageScanCompletedAt: Date?
        /// The time when the vulnerability data was last scanned.
        public let vulnerabilitySourceUpdatedAt: Date?

        @inlinable
        public init(findingSeverityCounts: [FindingSeverity: Int]? = nil, imageScanCompletedAt: Date? = nil, vulnerabilitySourceUpdatedAt: Date? = nil) {
            self.findingSeverityCounts = findingSeverityCounts
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case findingSeverityCounts = "findingSeverityCounts"
            case imageScanCompletedAt = "imageScanCompletedAt"
            case vulnerabilitySourceUpdatedAt = "vulnerabilitySourceUpdatedAt"
        }
    }

    public struct ImageScanStatus: AWSDecodableShape {
        /// The description of the image scan status.
        public let description: String?
        /// The current state of an image scan.
        public let status: ScanStatus?

        @inlinable
        public init(description: String? = nil, status: ScanStatus? = nil) {
            self.description = description
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case status = "status"
        }
    }

    public struct ImageScanningConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The setting that determines whether images are scanned after being pushed to a repository. If set to true, images will be scanned after being pushed. If this parameter is not specified, it will default to false and images will not be scanned unless a scan is manually started with the API_StartImageScan API.
        public let scanOnPush: Bool?

        @inlinable
        public init(scanOnPush: Bool? = nil) {
            self.scanOnPush = scanOnPush
        }

        private enum CodingKeys: String, CodingKey {
            case scanOnPush = "scanOnPush"
        }
    }

    public struct InitiateLayerUploadRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID associated with the registry to which you intend to upload layers. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to which you intend to upload layers.
        public let repositoryName: String

        @inlinable
        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct InitiateLayerUploadResponse: AWSDecodableShape {
        /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
        public let partSize: Int64?
        /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload operations.
        public let uploadId: String?

        @inlinable
        public init(partSize: Int64? = nil, uploadId: String? = nil) {
            self.partSize = partSize
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case partSize = "partSize"
            case uploadId = "uploadId"
        }
    }

    public struct InvalidLayerPartException: AWSErrorShape {
        /// The last valid byte received from the layer part upload that is associated with the exception.
        public let lastValidByteReceived: Int64?
        /// The error message associated with the exception.
        public let message: String?
        /// The registry ID associated with the exception.
        public let registryId: String?
        /// The repository name associated with the exception.
        public let repositoryName: String?
        /// The upload ID associated with the exception.
        public let uploadId: String?

        @inlinable
        public init(lastValidByteReceived: Int64? = nil, message: String? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.lastValidByteReceived = lastValidByteReceived
            self.message = message
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case lastValidByteReceived = "lastValidByteReceived"
            case message = "message"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct KmsException: AWSErrorShape {
        /// The error code returned by KMS.
        public let kmsError: String?
        public let message: String?

        @inlinable
        public init(kmsError: String? = nil, message: String? = nil) {
            self.kmsError = kmsError
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case kmsError = "kmsError"
            case message = "message"
        }
    }

    public struct Layer: AWSDecodableShape {
        /// The availability status of the image layer.
        public let layerAvailability: LayerAvailability?
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The size, in bytes, of the image layer.
        public let layerSize: Int64?
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public let mediaType: String?

        @inlinable
        public init(layerAvailability: LayerAvailability? = nil, layerDigest: String? = nil, layerSize: Int64? = nil, mediaType: String? = nil) {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }

        private enum CodingKeys: String, CodingKey {
            case layerAvailability = "layerAvailability"
            case layerDigest = "layerDigest"
            case layerSize = "layerSize"
            case mediaType = "mediaType"
        }
    }

    public struct LayerFailure: AWSDecodableShape {
        /// The failure code associated with the failure.
        public let failureCode: LayerFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The layer digest associated with the failure.
        public let layerDigest: String?

        @inlinable
        public init(failureCode: LayerFailureCode? = nil, failureReason: String? = nil, layerDigest: String? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case layerDigest = "layerDigest"
        }
    }

    public struct LifecyclePolicyPreviewFilter: AWSEncodableShape {
        /// The tag status of the image.
        public let tagStatus: TagStatus?

        @inlinable
        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus = "tagStatus"
        }
    }

    public struct LifecyclePolicyPreviewResult: AWSDecodableShape {
        /// The type of action to be taken.
        public let action: LifecyclePolicyRuleAction?
        /// The priority of the applied rule.
        public let appliedRulePriority: Int?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public let imagePushedAt: Date?
        /// The list of tags associated with this image.
        public let imageTags: [String]?

        @inlinable
        public init(action: LifecyclePolicyRuleAction? = nil, appliedRulePriority: Int? = nil, imageDigest: String? = nil, imagePushedAt: Date? = nil, imageTags: [String]? = nil) {
            self.action = action
            self.appliedRulePriority = appliedRulePriority
            self.imageDigest = imageDigest
            self.imagePushedAt = imagePushedAt
            self.imageTags = imageTags
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case appliedRulePriority = "appliedRulePriority"
            case imageDigest = "imageDigest"
            case imagePushedAt = "imagePushedAt"
            case imageTags = "imageTags"
        }
    }

    public struct LifecyclePolicyPreviewSummary: AWSDecodableShape {
        /// The number of expiring images.
        public let expiringImageTotalCount: Int?

        @inlinable
        public init(expiringImageTotalCount: Int? = nil) {
            self.expiringImageTotalCount = expiringImageTotalCount
        }

        private enum CodingKeys: String, CodingKey {
            case expiringImageTotalCount = "expiringImageTotalCount"
        }
    }

    public struct LifecyclePolicyRuleAction: AWSDecodableShape {
        /// The type of action to be taken.
        public let type: ImageActionType?

        @inlinable
        public init(type: ImageActionType? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct ListImagesFilter: AWSEncodableShape {
        /// The tag status with which to filter your ListImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public let tagStatus: TagStatus?

        @inlinable
        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus = "tagStatus"
        }
    }

    public struct ListImagesRequest: AWSEncodableShape {
        /// The filter key and value with which to filter your ListImages results.
        public let filter: ListImagesFilter?
        /// The maximum number of image results returned by ListImages in paginated output. When this parameter is used, ListImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then ListImages returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated ListImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The Amazon Web Services account ID associated with the registry that contains the repository in which to list images. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository with image IDs to be listed.
        public let repositoryName: String

        @inlinable
        public init(filter: ListImagesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct ListImagesResponse: AWSDecodableShape {
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?
        /// The nextToken value to include in a future ListImages request. When the results of a ListImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(imageIds: [ImageIdentifier]? = nil, nextToken: String? = nil) {
            self.imageIds = imageIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds = "imageIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the only supported resource is an Amazon ECR repository.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct PackageVulnerabilityDetails: AWSDecodableShape {
        /// An object that contains details about the CVSS score of a finding.
        public let cvss: [CvssScore]?
        /// One or more URLs that contain details about this vulnerability type.
        public let referenceUrls: [String]?
        /// One or more vulnerabilities related to the one identified in this finding.
        public let relatedVulnerabilities: [String]?
        /// The source of the vulnerability information.
        public let source: String?
        /// A URL to the source of the vulnerability information.
        public let sourceUrl: String?
        /// The date and time that this vulnerability was first added to the vendor's database.
        public let vendorCreatedAt: Date?
        /// The severity the vendor has given to this vulnerability type.
        public let vendorSeverity: String?
        /// The date and time the vendor last updated this vulnerability in their database.
        public let vendorUpdatedAt: Date?
        /// The ID given to this vulnerability.
        public let vulnerabilityId: String?
        /// The packages impacted by this vulnerability.
        public let vulnerablePackages: [VulnerablePackage]?

        @inlinable
        public init(cvss: [CvssScore]? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil, source: String? = nil, sourceUrl: String? = nil, vendorCreatedAt: Date? = nil, vendorSeverity: String? = nil, vendorUpdatedAt: Date? = nil, vulnerabilityId: String? = nil, vulnerablePackages: [VulnerablePackage]? = nil) {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }

        private enum CodingKeys: String, CodingKey {
            case cvss = "cvss"
            case referenceUrls = "referenceUrls"
            case relatedVulnerabilities = "relatedVulnerabilities"
            case source = "source"
            case sourceUrl = "sourceUrl"
            case vendorCreatedAt = "vendorCreatedAt"
            case vendorSeverity = "vendorSeverity"
            case vendorUpdatedAt = "vendorUpdatedAt"
            case vulnerabilityId = "vulnerabilityId"
            case vulnerablePackages = "vulnerablePackages"
        }
    }

    public struct PullThroughCacheRule: AWSDecodableShape {
        /// The date and time the pull through cache was created.
        public let createdAt: Date?
        /// The ARN of the Secrets Manager secret associated with the pull through cache rule.
        public let credentialArn: String?
        /// The ARN of the IAM role associated with the pull through cache rule.
        public let customRoleArn: String?
        /// The Amazon ECR repository prefix associated with the pull through cache rule.
        public let ecrRepositoryPrefix: String?
        /// The Amazon Web Services account ID associated with the registry the pull through cache rule is associated with.
        public let registryId: String?
        /// The date and time, in JavaScript date format, when the pull through cache rule was last updated.
        public let updatedAt: Date?
        /// The name of the upstream source registry associated with the pull through cache rule.
        public let upstreamRegistry: UpstreamRegistry?
        /// The upstream registry URL associated with the pull through cache rule.
        public let upstreamRegistryUrl: String?
        /// The upstream repository prefix associated with the pull through cache rule.
        public let upstreamRepositoryPrefix: String?

        @inlinable
        public init(createdAt: Date? = nil, credentialArn: String? = nil, customRoleArn: String? = nil, ecrRepositoryPrefix: String? = nil, registryId: String? = nil, updatedAt: Date? = nil, upstreamRegistry: UpstreamRegistry? = nil, upstreamRegistryUrl: String? = nil, upstreamRepositoryPrefix: String? = nil) {
            self.createdAt = createdAt
            self.credentialArn = credentialArn
            self.customRoleArn = customRoleArn
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
            self.updatedAt = updatedAt
            self.upstreamRegistry = upstreamRegistry
            self.upstreamRegistryUrl = upstreamRegistryUrl
            self.upstreamRepositoryPrefix = upstreamRepositoryPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case credentialArn = "credentialArn"
            case customRoleArn = "customRoleArn"
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
            case updatedAt = "updatedAt"
            case upstreamRegistry = "upstreamRegistry"
            case upstreamRegistryUrl = "upstreamRegistryUrl"
            case upstreamRepositoryPrefix = "upstreamRepositoryPrefix"
        }
    }

    public struct PutAccountSettingRequest: AWSEncodableShape {
        /// The name of the account setting, such as BASIC_SCAN_TYPE_VERSION or REGISTRY_POLICY_SCOPE.
        public let name: String
        /// Setting value that is specified. The following are valid values for the basic scan type being used: AWS_NATIVE or CLAIR. The following are valid values for the registry policy scope being used: V1 or V2.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct PutAccountSettingResponse: AWSDecodableShape {
        /// Retrieves the name of the account setting.
        public let name: String?
        /// Retrieves the value of the specified account setting.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct PutImageRequest: AWSEncodableShape {
        /// The image digest of the image manifest corresponding to the image.
        public let imageDigest: String?
        /// The image manifest corresponding to the image to be uploaded.
        public let imageManifest: String
        /// The media type of the image manifest. If you push an image manifest that does not contain the mediaType field, you must specify the imageManifestMediaType in the request.
        public let imageManifestMediaType: String?
        /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
        public let imageTag: String?
        /// The Amazon Web Services account ID associated with the registry that contains the repository in which to put the image. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository in which to put the image.
        public let repositoryName: String

        @inlinable
        public init(imageDigest: String? = nil, imageManifest: String, imageManifestMediaType: String? = nil, imageTag: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.imageDigest = imageDigest
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.imageTag = imageTag
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, max: 4194304)
            try self.validate(self.imageManifest, name: "imageManifest", parent: name, min: 1)
            try self.validate(self.imageTag, name: "imageTag", parent: name, max: 300)
            try self.validate(self.imageTag, name: "imageTag", parent: name, min: 1)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest = "imageDigest"
            case imageManifest = "imageManifest"
            case imageManifestMediaType = "imageManifestMediaType"
            case imageTag = "imageTag"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutImageResponse: AWSDecodableShape {
        /// Details of the image uploaded.
        public let image: Image?

        @inlinable
        public init(image: Image? = nil) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
        }
    }

    public struct PutImageScanningConfigurationRequest: AWSEncodableShape {
        /// The image scanning configuration for the repository. This setting determines whether images are scanned for known vulnerabilities after being pushed to the repository.
        public let imageScanningConfiguration: ImageScanningConfiguration
        /// The Amazon Web Services account ID associated with the registry that contains the repository in which to update the image scanning configuration setting. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository in which to update the image scanning configuration setting.
        public let repositoryName: String

        @inlinable
        public init(imageScanningConfiguration: ImageScanningConfiguration, registryId: String? = nil, repositoryName: String) {
            self.imageScanningConfiguration = imageScanningConfiguration
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageScanningConfiguration = "imageScanningConfiguration"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutImageScanningConfigurationResponse: AWSDecodableShape {
        /// The image scanning configuration setting for the repository.
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(imageScanningConfiguration: ImageScanningConfiguration? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageScanningConfiguration = imageScanningConfiguration
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageScanningConfiguration = "imageScanningConfiguration"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutImageTagMutabilityRequest: AWSEncodableShape {
        /// The tag mutability setting for the repository. If MUTABLE is specified, image tags can be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        public let imageTagMutability: ImageTagMutability
        /// The Amazon Web Services account ID associated with the registry that contains the repository in which to update the image tag mutability settings. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository in which to update the image tag mutability settings.
        public let repositoryName: String

        @inlinable
        public init(imageTagMutability: ImageTagMutability, registryId: String? = nil, repositoryName: String) {
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageTagMutability = "imageTagMutability"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutImageTagMutabilityResponse: AWSDecodableShape {
        /// The image tag mutability setting for the repository.
        public let imageTagMutability: ImageTagMutability?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(imageTagMutability: ImageTagMutability? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageTagMutability = "imageTagMutability"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutLifecyclePolicyRequest: AWSEncodableShape {
        /// The JSON repository policy text to apply to the repository.
        public let lifecyclePolicyText: String
        /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do  not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to receive the policy.
        public let repositoryName: String

        @inlinable
        public init(lifecyclePolicyText: String, registryId: String? = nil, repositoryName: String) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, max: 30720)
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, min: 100)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText = "lifecyclePolicyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutLifecyclePolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText = "lifecyclePolicyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutRegistryPolicyRequest: AWSEncodableShape {
        /// The JSON policy text to apply to your registry. The policy text follows the same format as IAM policy text. For more information, see Registry permissions in the Amazon Elastic Container Registry User Guide.
        public let policyText: String

        @inlinable
        public init(policyText: String) {
            self.policyText = policyText
        }

        public func validate(name: String) throws {
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10240)
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
        }
    }

    public struct PutRegistryPolicyResponse: AWSDecodableShape {
        /// The JSON policy text for your registry.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?

        @inlinable
        public init(policyText: String? = nil, registryId: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
        }
    }

    public struct PutRegistryScanningConfigurationRequest: AWSEncodableShape {
        /// The scanning rules to use for the registry. A scanning rule is used to determine which repository filters are used and at what frequency scanning will occur.
        public let rules: [RegistryScanningRule]?
        /// The scanning type to set for the registry. When a registry scanning configuration is not defined, by default the BASIC scan type is used. When basic scanning is used, you may specify filters to determine which individual repositories, or all repositories, are scanned when new images are pushed to those repositories. Alternatively, you can do manual scans of images with basic scanning. When the ENHANCED scan type is set, Amazon Inspector provides automated vulnerability scanning. You may choose between continuous scanning or scan on push and you may specify filters to determine which individual repositories, or all repositories, are scanned.
        public let scanType: ScanType?

        @inlinable
        public init(rules: [RegistryScanningRule]? = nil, scanType: ScanType? = nil) {
            self.rules = rules
            self.scanType = scanType
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
            case scanType = "scanType"
        }
    }

    public struct PutRegistryScanningConfigurationResponse: AWSDecodableShape {
        /// The scanning configuration for your registry.
        public let registryScanningConfiguration: RegistryScanningConfiguration?

        @inlinable
        public init(registryScanningConfiguration: RegistryScanningConfiguration? = nil) {
            self.registryScanningConfiguration = registryScanningConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case registryScanningConfiguration = "registryScanningConfiguration"
        }
    }

    public struct PutReplicationConfigurationRequest: AWSEncodableShape {
        /// An object representing the replication configuration for a registry.
        public let replicationConfiguration: ReplicationConfiguration

        @inlinable
        public init(replicationConfiguration: ReplicationConfiguration) {
            self.replicationConfiguration = replicationConfiguration
        }

        public func validate(name: String) throws {
            try self.replicationConfiguration.validate(name: "\(name).replicationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfiguration = "replicationConfiguration"
        }
    }

    public struct PutReplicationConfigurationResponse: AWSDecodableShape {
        /// The contents of the replication configuration for the registry.
        public let replicationConfiguration: ReplicationConfiguration?

        @inlinable
        public init(replicationConfiguration: ReplicationConfiguration? = nil) {
            self.replicationConfiguration = replicationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfiguration = "replicationConfiguration"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The recommended course of action to remediate the finding.
        public let text: String?
        /// The URL address to the CVE remediation recommendations.
        public let url: String?

        @inlinable
        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case url = "url"
        }
    }

    public struct RegistryScanningConfiguration: AWSDecodableShape {
        /// The scanning rules associated with the registry.
        public let rules: [RegistryScanningRule]?
        /// The type of scanning configured for the registry.
        public let scanType: ScanType?

        @inlinable
        public init(rules: [RegistryScanningRule]? = nil, scanType: ScanType? = nil) {
            self.rules = rules
            self.scanType = scanType
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
            case scanType = "scanType"
        }
    }

    public struct RegistryScanningRule: AWSEncodableShape & AWSDecodableShape {
        /// The repository filters associated with the scanning configuration for a private registry.
        public let repositoryFilters: [ScanningRepositoryFilter]
        /// The frequency that scans are performed at for a private registry. When the ENHANCED scan type is specified, the supported scan frequencies are CONTINUOUS_SCAN and SCAN_ON_PUSH. When the BASIC scan type is specified, the SCAN_ON_PUSH scan frequency is supported. If scan on push is not specified, then the MANUAL scan frequency is set by default.
        public let scanFrequency: ScanFrequency

        @inlinable
        public init(repositoryFilters: [ScanningRepositoryFilter], scanFrequency: ScanFrequency) {
            self.repositoryFilters = repositoryFilters
            self.scanFrequency = scanFrequency
        }

        public func validate(name: String) throws {
            try self.repositoryFilters.forEach {
                try $0.validate(name: "\(name).repositoryFilters[]")
            }
            try self.validate(self.repositoryFilters, name: "repositoryFilters", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryFilters = "repositoryFilters"
            case scanFrequency = "scanFrequency"
        }
    }

    public struct Remediation: AWSDecodableShape {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public let recommendation: Recommendation?

        @inlinable
        public init(recommendation: Recommendation? = nil) {
            self.recommendation = recommendation
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "recommendation"
        }
    }

    public struct ReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects representing the replication destinations and repository filters for a replication configuration.
        public let rules: [ReplicationRule]

        @inlinable
        public init(rules: [ReplicationRule]) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
        }
    }

    public struct ReplicationDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Region to replicate to.
        public let region: String
        /// The Amazon Web Services account ID of the Amazon ECR private registry to replicate to. When configuring cross-Region replication within your own registry, specify your own account ID.
        public let registryId: String

        @inlinable
        public init(region: String, registryId: String) {
            self.region = region
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.region, name: "region", parent: name, max: 25)
            try self.validate(self.region, name: "region", parent: name, min: 2)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[0-9a-z-]{2,25}$")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case region = "region"
            case registryId = "registryId"
        }
    }

    public struct ReplicationRule: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects representing the destination for a replication rule.
        public let destinations: [ReplicationDestination]
        /// An array of objects representing the filters for a replication rule. Specifying a repository filter for a replication rule provides a method for controlling which repositories in a private registry are replicated.
        public let repositoryFilters: [RepositoryFilter]?

        @inlinable
        public init(destinations: [ReplicationDestination], repositoryFilters: [RepositoryFilter]? = nil) {
            self.destinations = destinations
            self.repositoryFilters = repositoryFilters
        }

        public func validate(name: String) throws {
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.destinations, name: "destinations", parent: name, max: 100)
            try self.repositoryFilters?.forEach {
                try $0.validate(name: "\(name).repositoryFilters[]")
            }
            try self.validate(self.repositoryFilters, name: "repositoryFilters", parent: name, max: 100)
            try self.validate(self.repositoryFilters, name: "repositoryFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
            case repositoryFilters = "repositoryFilters"
        }
    }

    public struct Repository: AWSDecodableShape {
        /// The date and time, in JavaScript date format, when the repository was created.
        public let createdAt: Date?
        /// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
        public let encryptionConfiguration: EncryptionConfiguration?
        public let imageScanningConfiguration: ImageScanningConfiguration?
        /// The tag mutability setting for the repository.
        public let imageTagMutability: ImageTagMutability?
        /// The Amazon Web Services account ID associated with the registry that contains the repository.
        public let registryId: String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, Amazon Web Services account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository-namespace/repository-name.
        public let repositoryArn: String?
        /// The name of the repository.
        public let repositoryName: String?
        /// The URI for the repository. You can use this URI for container image push and pull operations.
        public let repositoryUri: String?

        @inlinable
        public init(createdAt: Date? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, imageScanningConfiguration: ImageScanningConfiguration? = nil, imageTagMutability: ImageTagMutability? = nil, registryId: String? = nil, repositoryArn: String? = nil, repositoryName: String? = nil, repositoryUri: String? = nil) {
            self.createdAt = createdAt
            self.encryptionConfiguration = encryptionConfiguration
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case encryptionConfiguration = "encryptionConfiguration"
            case imageScanningConfiguration = "imageScanningConfiguration"
            case imageTagMutability = "imageTagMutability"
            case registryId = "registryId"
            case repositoryArn = "repositoryArn"
            case repositoryName = "repositoryName"
            case repositoryUri = "repositoryUri"
        }
    }

    public struct RepositoryCreationTemplate: AWSDecodableShape {
        /// A list of enumerable Strings representing the repository creation scenarios that this template will apply towards. The two supported scenarios are PULL_THROUGH_CACHE and REPLICATION
        public let appliedFor: [RCTAppliedFor]?
        /// The date and time, in JavaScript date format, when the repository creation template was created.
        public let createdAt: Date?
        /// The ARN of the role to be assumed by Amazon ECR. Amazon ECR will assume your supplied role when the customRoleArn is specified. When this field isn't specified, Amazon ECR will use the service-linked role for the repository creation template.
        public let customRoleArn: String?
        /// The description associated with the repository creation template.
        public let description: String?
        /// The encryption configuration associated with the repository creation template.
        public let encryptionConfiguration: EncryptionConfigurationForRepositoryCreationTemplate?
        /// The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        public let imageTagMutability: ImageTagMutability?
        /// The lifecycle policy to use for repositories created using the template.
        public let lifecyclePolicy: String?
        /// The repository namespace prefix associated with the repository creation template.
        public let prefix: String?
        /// The repository policy to apply to repositories created using the template. A repository policy is a permissions policy associated with a repository to control access permissions.
        public let repositoryPolicy: String?
        /// The metadata to apply to the repository to help you categorize and organize. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let resourceTags: [Tag]?
        /// The date and time, in JavaScript date format, when the repository creation template was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(appliedFor: [RCTAppliedFor]? = nil, createdAt: Date? = nil, customRoleArn: String? = nil, description: String? = nil, encryptionConfiguration: EncryptionConfigurationForRepositoryCreationTemplate? = nil, imageTagMutability: ImageTagMutability? = nil, lifecyclePolicy: String? = nil, prefix: String? = nil, repositoryPolicy: String? = nil, resourceTags: [Tag]? = nil, updatedAt: Date? = nil) {
            self.appliedFor = appliedFor
            self.createdAt = createdAt
            self.customRoleArn = customRoleArn
            self.description = description
            self.encryptionConfiguration = encryptionConfiguration
            self.imageTagMutability = imageTagMutability
            self.lifecyclePolicy = lifecyclePolicy
            self.prefix = prefix
            self.repositoryPolicy = repositoryPolicy
            self.resourceTags = resourceTags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case appliedFor = "appliedFor"
            case createdAt = "createdAt"
            case customRoleArn = "customRoleArn"
            case description = "description"
            case encryptionConfiguration = "encryptionConfiguration"
            case imageTagMutability = "imageTagMutability"
            case lifecyclePolicy = "lifecyclePolicy"
            case prefix = "prefix"
            case repositoryPolicy = "repositoryPolicy"
            case resourceTags = "resourceTags"
            case updatedAt = "updatedAt"
        }
    }

    public struct RepositoryFilter: AWSEncodableShape & AWSDecodableShape {
        /// The repository filter details. When the PREFIX_MATCH filter type is specified, this value is required and should be the repository name prefix to configure replication for.
        public let filter: String
        /// The repository filter type. The only supported value is PREFIX_MATCH, which is a repository name prefix specified with the filter parameter.
        public let filterType: RepositoryFilterType

        @inlinable
        public init(filter: String, filterType: RepositoryFilterType) {
            self.filter = filter
            self.filterType = filterType
        }

        public func validate(name: String) throws {
            try self.validate(self.filter, name: "filter", parent: name, max: 256)
            try self.validate(self.filter, name: "filter", parent: name, min: 2)
            try self.validate(self.filter, name: "filter", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]*)*/)*[a-z0-9]*(?:[._-][a-z0-9]*)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case filterType = "filterType"
        }
    }

    public struct RepositoryScanningConfiguration: AWSDecodableShape {
        /// The scan filters applied to the repository.
        public let appliedScanFilters: [ScanningRepositoryFilter]?
        /// The ARN of the repository.
        public let repositoryArn: String?
        /// The name of the repository.
        public let repositoryName: String?
        /// The scan frequency for the repository.
        public let scanFrequency: ScanFrequency?
        /// Whether or not scan on push is configured for the repository.
        public let scanOnPush: Bool?

        @inlinable
        public init(appliedScanFilters: [ScanningRepositoryFilter]? = nil, repositoryArn: String? = nil, repositoryName: String? = nil, scanFrequency: ScanFrequency? = nil, scanOnPush: Bool? = nil) {
            self.appliedScanFilters = appliedScanFilters
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.scanFrequency = scanFrequency
            self.scanOnPush = scanOnPush
        }

        private enum CodingKeys: String, CodingKey {
            case appliedScanFilters = "appliedScanFilters"
            case repositoryArn = "repositoryArn"
            case repositoryName = "repositoryName"
            case scanFrequency = "scanFrequency"
            case scanOnPush = "scanOnPush"
        }
    }

    public struct RepositoryScanningConfigurationFailure: AWSDecodableShape {
        /// The failure code.
        public let failureCode: ScanningConfigurationFailureCode?
        /// The reason for the failure.
        public let failureReason: String?
        /// The name of the repository.
        public let repositoryName: String?

        @inlinable
        public init(failureCode: ScanningConfigurationFailureCode? = nil, failureReason: String? = nil, repositoryName: String? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case repositoryName = "repositoryName"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// An object that contains details about the resource involved in a finding.
        public let details: ResourceDetails?
        /// The ID of the resource.
        public let id: String?
        /// The tags attached to the resource.
        public let tags: [String: String]?
        /// The type of resource.
        public let type: String?

        @inlinable
        public init(details: ResourceDetails? = nil, id: String? = nil, tags: [String: String]? = nil, type: String? = nil) {
            self.details = details
            self.id = id
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case id = "id"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct ResourceDetails: AWSDecodableShape {
        /// An object that contains details about the Amazon ECR container image involved in the finding.
        public let awsEcrContainerImage: AwsEcrContainerImageDetails?

        @inlinable
        public init(awsEcrContainerImage: AwsEcrContainerImageDetails? = nil) {
            self.awsEcrContainerImage = awsEcrContainerImage
        }

        private enum CodingKeys: String, CodingKey {
            case awsEcrContainerImage = "awsEcrContainerImage"
        }
    }

    public struct ScanningRepositoryFilter: AWSEncodableShape & AWSDecodableShape {
        /// The filter to use when scanning.
        public let filter: String
        /// The type associated with the filter.
        public let filterType: ScanningRepositoryFilterType

        @inlinable
        public init(filter: String, filterType: ScanningRepositoryFilterType) {
            self.filter = filter
            self.filterType = filterType
        }

        public func validate(name: String) throws {
            try self.validate(self.filter, name: "filter", parent: name, max: 255)
            try self.validate(self.filter, name: "filter", parent: name, min: 1)
            try self.validate(self.filter, name: "filter", parent: name, pattern: "^[a-z0-9*](?:[._\\-/a-z0-9*]?[a-z0-9*]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case filterType = "filterType"
        }
    }

    public struct ScoreDetails: AWSDecodableShape {
        /// An object that contains details about the CVSS score given to a finding.
        public let cvss: CvssScoreDetails?

        @inlinable
        public init(cvss: CvssScoreDetails? = nil) {
            self.cvss = cvss
        }

        private enum CodingKeys: String, CodingKey {
            case cvss = "cvss"
        }
    }

    public struct SetRepositoryPolicyRequest: AWSEncodableShape {
        /// If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental repository lock outs.
        public let force: Bool?
        /// The JSON repository policy text to apply to the repository. For more information, see Amazon ECR repository policies in the Amazon Elastic Container Registry User Guide.
        public let policyText: String
        /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to receive the policy.
        public let repositoryName: String

        @inlinable
        public init(force: Bool? = nil, policyText: String, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyText, name: "policyText", parent: name, max: 10240)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case force = "force"
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct SetRepositoryPolicyResponse: AWSDecodableShape {
        /// The JSON repository policy text applied to the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct StartImageScanRequest: AWSEncodableShape {
        public let imageId: ImageIdentifier
        /// The Amazon Web Services account ID associated with the registry that contains the repository in which to start an image scan request. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that contains the images to scan.
        public let repositoryName: String

        @inlinable
        public init(imageId: ImageIdentifier, registryId: String? = nil, repositoryName: String) {
            self.imageId = imageId
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.imageId.validate(name: "\(name).imageId")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct StartImageScanResponse: AWSDecodableShape {
        public let imageId: ImageIdentifier?
        /// The current state of the scan.
        public let imageScanStatus: ImageScanStatus?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        @inlinable
        public init(imageId: ImageIdentifier? = nil, imageScanStatus: ImageScanStatus? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.imageId = imageId
            self.imageScanStatus = imageScanStatus
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case imageScanStatus = "imageScanStatus"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct StartLifecyclePolicyPreviewRequest: AWSEncodableShape {
        /// The policy to be evaluated against. If you do not specify a policy, the current policy for the repository is used.
        public let lifecyclePolicyText: String?
        /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to be evaluated.
        public let repositoryName: String

        @inlinable
        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, max: 30720)
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, min: 100)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText = "lifecyclePolicyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct StartLifecyclePolicyPreviewResponse: AWSDecodableShape {
        /// The JSON repository policy text.
        public let lifecyclePolicyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The status of the lifecycle policy preview request.
        public let status: LifecyclePolicyPreviewStatus?

        @inlinable
        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil, status: LifecyclePolicyPreviewStatus? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText = "lifecyclePolicyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case status = "status"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String
        /// A value acts as a descriptor within a tag category (key).
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the the resource to which to add tags. Currently, the only supported resource is an Amazon ECR repository.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove tags. Currently, the only supported resource is an Amazon ECR repository.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePullThroughCacheRuleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that identifies the credentials to authenticate to the upstream registry.
        public let credentialArn: String?
        /// Amazon Resource Name (ARN) of the IAM role to be assumed by Amazon ECR to authenticate to the ECR upstream registry. This role must be in the same account as the registry that you are configuring.
        public let customRoleArn: String?
        /// The repository name prefix to use when caching images from the source registry.
        public let ecrRepositoryPrefix: String
        /// The Amazon Web Services account ID associated with the registry associated with the pull through cache rule. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?

        @inlinable
        public init(credentialArn: String? = nil, customRoleArn: String? = nil, ecrRepositoryPrefix: String, registryId: String? = nil) {
            self.credentialArn = credentialArn
            self.customRoleArn = customRoleArn
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialArn, name: "credentialArn", parent: name, max: 612)
            try self.validate(self.credentialArn, name: "credentialArn", parent: name, min: 50)
            try self.validate(self.credentialArn, name: "credentialArn", parent: name, pattern: "^arn:aws:secretsmanager:[a-zA-Z0-9-:]+:secret:ecr\\-pullthroughcache\\/[a-zA-Z0-9\\/_+=.@-]+$")
            try self.validate(self.customRoleArn, name: "customRoleArn", parent: name, max: 2048)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, max: 30)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, min: 2)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialArn = "credentialArn"
            case customRoleArn = "customRoleArn"
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
        }
    }

    public struct UpdatePullThroughCacheRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret associated with the pull through cache rule.
        public let credentialArn: String?
        /// The ARN of the IAM role associated with the pull through cache rule.
        public let customRoleArn: String?
        /// The Amazon ECR repository prefix associated with the pull through cache rule.
        public let ecrRepositoryPrefix: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The date and time, in JavaScript date format, when the pull through cache rule was updated.
        public let updatedAt: Date?
        /// The upstream repository prefix associated with the pull through cache rule.
        public let upstreamRepositoryPrefix: String?

        @inlinable
        public init(credentialArn: String? = nil, customRoleArn: String? = nil, ecrRepositoryPrefix: String? = nil, registryId: String? = nil, updatedAt: Date? = nil, upstreamRepositoryPrefix: String? = nil) {
            self.credentialArn = credentialArn
            self.customRoleArn = customRoleArn
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
            self.updatedAt = updatedAt
            self.upstreamRepositoryPrefix = upstreamRepositoryPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case credentialArn = "credentialArn"
            case customRoleArn = "customRoleArn"
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
            case updatedAt = "updatedAt"
            case upstreamRepositoryPrefix = "upstreamRepositoryPrefix"
        }
    }

    public struct UpdateRepositoryCreationTemplateRequest: AWSEncodableShape {
        /// Updates the list of enumerable strings representing the Amazon ECR repository creation scenarios that this template will apply towards. The two supported scenarios are PULL_THROUGH_CACHE and REPLICATION
        public let appliedFor: [RCTAppliedFor]?
        /// The ARN of the role to be assumed by Amazon ECR. This role must be in the same account as the registry that you are configuring. Amazon ECR will assume your supplied role when the customRoleArn is specified. When this field isn't specified, Amazon ECR will use the service-linked role for the repository creation template.
        public let customRoleArn: String?
        /// A description for the repository creation template.
        public let description: String?
        public let encryptionConfiguration: EncryptionConfigurationForRepositoryCreationTemplate?
        /// Updates the tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        public let imageTagMutability: ImageTagMutability?
        /// Updates the lifecycle policy associated with the specified repository creation template.
        public let lifecyclePolicy: String?
        /// The repository namespace prefix that matches an existing repository creation template in the registry. All repositories created using this namespace prefix will have the settings defined in this template applied. For example, a prefix of prod would apply to all repositories beginning with prod/. This includes a repository named prod/team1 as well as a repository named prod/repository1. To apply a template to all repositories in your registry that don't have an associated creation template, you can use ROOT as the prefix.
        public let prefix: String
        /// Updates the repository policy created using the template. A repository policy is a permissions policy associated with a repository to control access permissions.
        public let repositoryPolicy: String?
        /// The metadata to apply to the repository to help you categorize and organize. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let resourceTags: [Tag]?

        @inlinable
        public init(appliedFor: [RCTAppliedFor]? = nil, customRoleArn: String? = nil, description: String? = nil, encryptionConfiguration: EncryptionConfigurationForRepositoryCreationTemplate? = nil, imageTagMutability: ImageTagMutability? = nil, lifecyclePolicy: String? = nil, prefix: String, repositoryPolicy: String? = nil, resourceTags: [Tag]? = nil) {
            self.appliedFor = appliedFor
            self.customRoleArn = customRoleArn
            self.description = description
            self.encryptionConfiguration = encryptionConfiguration
            self.imageTagMutability = imageTagMutability
            self.lifecyclePolicy = lifecyclePolicy
            self.prefix = prefix
            self.repositoryPolicy = repositoryPolicy
            self.resourceTags = resourceTags
        }

        public func validate(name: String) throws {
            try self.validate(self.customRoleArn, name: "customRoleArn", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.lifecyclePolicy, name: "lifecyclePolicy", parent: name, max: 30720)
            try self.validate(self.prefix, name: "prefix", parent: name, max: 256)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            try self.validate(self.repositoryPolicy, name: "repositoryPolicy", parent: name, max: 10240)
        }

        private enum CodingKeys: String, CodingKey {
            case appliedFor = "appliedFor"
            case customRoleArn = "customRoleArn"
            case description = "description"
            case encryptionConfiguration = "encryptionConfiguration"
            case imageTagMutability = "imageTagMutability"
            case lifecyclePolicy = "lifecyclePolicy"
            case prefix = "prefix"
            case repositoryPolicy = "repositoryPolicy"
            case resourceTags = "resourceTags"
        }
    }

    public struct UpdateRepositoryCreationTemplateResponse: AWSDecodableShape {
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The details of the repository creation template associated with the request.
        public let repositoryCreationTemplate: RepositoryCreationTemplate?

        @inlinable
        public init(registryId: String? = nil, repositoryCreationTemplate: RepositoryCreationTemplate? = nil) {
            self.registryId = registryId
            self.repositoryCreationTemplate = repositoryCreationTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryCreationTemplate = "repositoryCreationTemplate"
        }
    }

    public struct UploadLayerPartRequest: AWSEncodableShape {
        /// The base64-encoded layer part payload.
        public let layerPartBlob: AWSBase64Data
        /// The position of the first byte of the layer part witin the overall image layer.
        public let partFirstByte: Int64
        /// The position of the last byte of the layer part within the overall image layer.
        public let partLastByte: Int64
        /// The Amazon Web Services account ID associated with the registry to which you are uploading layer parts. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to which you are uploading layer parts.
        public let repositoryName: String
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the layer part upload.
        public let uploadId: String

        @inlinable
        public init(layerPartBlob: AWSBase64Data, partFirstByte: Int64, partLastByte: Int64, registryId: String? = nil, repositoryName: String, uploadId: String) {
            self.layerPartBlob = layerPartBlob
            self.partFirstByte = partFirstByte
            self.partLastByte = partLastByte
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.validate(self.layerPartBlob, name: "layerPartBlob", parent: name, max: 20971520)
            try self.validate(self.partFirstByte, name: "partFirstByte", parent: name, min: 0)
            try self.validate(self.partLastByte, name: "partLastByte", parent: name, min: 0)
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 256)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 2)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$")
            try self.validate(self.uploadId, name: "uploadId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case layerPartBlob = "layerPartBlob"
            case partFirstByte = "partFirstByte"
            case partLastByte = "partLastByte"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct UploadLayerPartResponse: AWSDecodableShape {
        /// The integer value of the last byte received in the request.
        public let lastByteReceived: Int64?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The upload ID associated with the request.
        public let uploadId: String?

        @inlinable
        public init(lastByteReceived: Int64? = nil, registryId: String? = nil, repositoryName: String? = nil, uploadId: String? = nil) {
            self.lastByteReceived = lastByteReceived
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case lastByteReceived = "lastByteReceived"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case uploadId = "uploadId"
        }
    }

    public struct ValidatePullThroughCacheRuleRequest: AWSEncodableShape {
        /// The repository name prefix associated with the pull through cache rule.
        public let ecrRepositoryPrefix: String
        /// The registry ID associated with the pull through cache rule. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?

        @inlinable
        public init(ecrRepositoryPrefix: String, registryId: String? = nil) {
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, max: 30)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, min: 2)
            try self.validate(self.ecrRepositoryPrefix, name: "ecrRepositoryPrefix", parent: name, pattern: "^((?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*/?|ROOT)$")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case registryId = "registryId"
        }
    }

    public struct ValidatePullThroughCacheRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret associated with the pull through cache rule.
        public let credentialArn: String?
        /// The ARN of the IAM role associated with the pull through cache rule.
        public let customRoleArn: String?
        /// The Amazon ECR repository prefix associated with the pull through cache rule.
        public let ecrRepositoryPrefix: String?
        /// The reason the validation failed. For more details about possible causes and how to address them, see Using pull through cache rules in the Amazon Elastic Container Registry User Guide.
        public let failure: String?
        /// Whether or not the pull through cache rule was validated. If true, Amazon ECR was able to reach the upstream registry and authentication was successful. If false, there was an issue and validation failed. The failure reason indicates the cause.
        public let isValid: Bool?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The upstream registry URL associated with the pull through cache rule.
        public let upstreamRegistryUrl: String?
        /// The upstream repository prefix associated with the pull through cache rule.
        public let upstreamRepositoryPrefix: String?

        @inlinable
        public init(credentialArn: String? = nil, customRoleArn: String? = nil, ecrRepositoryPrefix: String? = nil, failure: String? = nil, isValid: Bool? = nil, registryId: String? = nil, upstreamRegistryUrl: String? = nil, upstreamRepositoryPrefix: String? = nil) {
            self.credentialArn = credentialArn
            self.customRoleArn = customRoleArn
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.failure = failure
            self.isValid = isValid
            self.registryId = registryId
            self.upstreamRegistryUrl = upstreamRegistryUrl
            self.upstreamRepositoryPrefix = upstreamRepositoryPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case credentialArn = "credentialArn"
            case customRoleArn = "customRoleArn"
            case ecrRepositoryPrefix = "ecrRepositoryPrefix"
            case failure = "failure"
            case isValid = "isValid"
            case registryId = "registryId"
            case upstreamRegistryUrl = "upstreamRegistryUrl"
            case upstreamRepositoryPrefix = "upstreamRepositoryPrefix"
        }
    }

    public struct VulnerablePackage: AWSDecodableShape {
        /// The architecture of the vulnerable package.
        public let arch: String?
        /// The epoch of the vulnerable package.
        public let epoch: Int?
        /// The file path of the vulnerable package.
        public let filePath: String?
        /// The version of the package that contains the vulnerability fix.
        public let fixedInVersion: String?
        /// The name of the vulnerable package.
        public let name: String?
        /// The package manager of the vulnerable package.
        public let packageManager: String?
        /// The release of the vulnerable package.
        public let release: String?
        /// The source layer hash of the vulnerable package.
        public let sourceLayerHash: String?
        /// The version of the vulnerable package.
        public let version: String?

        @inlinable
        public init(arch: String? = nil, epoch: Int? = nil, filePath: String? = nil, fixedInVersion: String? = nil, name: String? = nil, packageManager: String? = nil, release: String? = nil, sourceLayerHash: String? = nil, version: String? = nil) {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arch = "arch"
            case epoch = "epoch"
            case filePath = "filePath"
            case fixedInVersion = "fixedInVersion"
            case name = "name"
            case packageManager = "packageManager"
            case release = "release"
            case sourceLayerHash = "sourceLayerHash"
            case version = "version"
        }
    }
}

// MARK: - Errors

/// Error enum for ECR
public struct ECRErrorType: AWSErrorType {
    enum Code: String {
        case emptyUploadException = "EmptyUploadException"
        case imageAlreadyExistsException = "ImageAlreadyExistsException"
        case imageDigestDoesNotMatchException = "ImageDigestDoesNotMatchException"
        case imageNotFoundException = "ImageNotFoundException"
        case imageTagAlreadyExistsException = "ImageTagAlreadyExistsException"
        case invalidLayerException = "InvalidLayerException"
        case invalidLayerPartException = "InvalidLayerPartException"
        case invalidParameterException = "InvalidParameterException"
        case invalidTagParameterException = "InvalidTagParameterException"
        case kmsException = "KmsException"
        case layerAlreadyExistsException = "LayerAlreadyExistsException"
        case layerInaccessibleException = "LayerInaccessibleException"
        case layerPartTooSmallException = "LayerPartTooSmallException"
        case layersNotFoundException = "LayersNotFoundException"
        case lifecyclePolicyNotFoundException = "LifecyclePolicyNotFoundException"
        case lifecyclePolicyPreviewInProgressException = "LifecyclePolicyPreviewInProgressException"
        case lifecyclePolicyPreviewNotFoundException = "LifecyclePolicyPreviewNotFoundException"
        case limitExceededException = "LimitExceededException"
        case pullThroughCacheRuleAlreadyExistsException = "PullThroughCacheRuleAlreadyExistsException"
        case pullThroughCacheRuleNotFoundException = "PullThroughCacheRuleNotFoundException"
        case referencedImagesNotFoundException = "ReferencedImagesNotFoundException"
        case registryPolicyNotFoundException = "RegistryPolicyNotFoundException"
        case repositoryAlreadyExistsException = "RepositoryAlreadyExistsException"
        case repositoryNotEmptyException = "RepositoryNotEmptyException"
        case repositoryNotFoundException = "RepositoryNotFoundException"
        case repositoryPolicyNotFoundException = "RepositoryPolicyNotFoundException"
        case scanNotFoundException = "ScanNotFoundException"
        case secretNotFoundException = "SecretNotFoundException"
        case serverException = "ServerException"
        case templateAlreadyExistsException = "TemplateAlreadyExistsException"
        case templateNotFoundException = "TemplateNotFoundException"
        case tooManyTagsException = "TooManyTagsException"
        case unableToAccessSecretException = "UnableToAccessSecretException"
        case unableToDecryptSecretValueException = "UnableToDecryptSecretValueException"
        case unableToGetUpstreamImageException = "UnableToGetUpstreamImageException"
        case unableToGetUpstreamLayerException = "UnableToGetUpstreamLayerException"
        case unsupportedImageTypeException = "UnsupportedImageTypeException"
        case unsupportedUpstreamRegistryException = "UnsupportedUpstreamRegistryException"
        case uploadNotFoundException = "UploadNotFoundException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ECR
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The specified layer upload does not contain any layer parts.
    public static var emptyUploadException: Self { .init(.emptyUploadException) }
    /// The specified image has already been pushed, and there were no changes to the manifest or image tag after the last push.
    public static var imageAlreadyExistsException: Self { .init(.imageAlreadyExistsException) }
    /// The specified image digest does not match the digest that Amazon ECR calculated for the image.
    public static var imageDigestDoesNotMatchException: Self { .init(.imageDigestDoesNotMatchException) }
    /// The image requested does not exist in the specified repository.
    public static var imageNotFoundException: Self { .init(.imageNotFoundException) }
    /// The specified image is tagged with a tag that already exists. The repository is configured for tag immutability.
    public static var imageTagAlreadyExistsException: Self { .init(.imageTagAlreadyExistsException) }
    /// The layer digest calculation performed by Amazon ECR upon receipt of the image layer does not match the digest specified.
    public static var invalidLayerException: Self { .init(.invalidLayerException) }
    /// The layer part size is not valid, or the first byte specified is not consecutive to the last byte of a previous layer part upload.
    public static var invalidLayerPartException: Self { .init(.invalidLayerPartException) }
    /// The specified parameter is invalid. Review the available parameters for the API request.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public static var invalidTagParameterException: Self { .init(.invalidTagParameterException) }
    /// The operation failed due to a KMS exception.
    public static var kmsException: Self { .init(.kmsException) }
    /// The image layer already exists in the associated repository.
    public static var layerAlreadyExistsException: Self { .init(.layerAlreadyExistsException) }
    /// The specified layer is not available because it is not associated with an image. Unassociated image layers may be cleaned up at any time.
    public static var layerInaccessibleException: Self { .init(.layerInaccessibleException) }
    /// Layer parts must be at least 5 MiB in size.
    public static var layerPartTooSmallException: Self { .init(.layerPartTooSmallException) }
    /// The specified layers could not be found, or the specified layer is not valid for this repository.
    public static var layersNotFoundException: Self { .init(.layersNotFoundException) }
    /// The lifecycle policy could not be found, and no policy is set to the repository.
    public static var lifecyclePolicyNotFoundException: Self { .init(.lifecyclePolicyNotFoundException) }
    /// The previous lifecycle policy preview request has not completed. Wait and try again.
    public static var lifecyclePolicyPreviewInProgressException: Self { .init(.lifecyclePolicyPreviewInProgressException) }
    /// There is no dry run for this repository.
    public static var lifecyclePolicyPreviewNotFoundException: Self { .init(.lifecyclePolicyPreviewNotFoundException) }
    /// The operation did not succeed because it would have exceeded a service limit for your account. For more information, see Amazon ECR service quotas in the Amazon Elastic Container Registry User Guide.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// A pull through cache rule with these settings already exists for the private registry.
    public static var pullThroughCacheRuleAlreadyExistsException: Self { .init(.pullThroughCacheRuleAlreadyExistsException) }
    /// The pull through cache rule was not found. Specify a valid pull through cache rule and try again.
    public static var pullThroughCacheRuleNotFoundException: Self { .init(.pullThroughCacheRuleNotFoundException) }
    /// The manifest list is referencing an image that does not exist.
    public static var referencedImagesNotFoundException: Self { .init(.referencedImagesNotFoundException) }
    /// The registry doesn't have an associated registry policy.
    public static var registryPolicyNotFoundException: Self { .init(.registryPolicyNotFoundException) }
    /// The specified repository already exists in the specified registry.
    public static var repositoryAlreadyExistsException: Self { .init(.repositoryAlreadyExistsException) }
    /// The specified repository contains images. To delete a repository that contains images, you must force the deletion with the force parameter.
    public static var repositoryNotEmptyException: Self { .init(.repositoryNotEmptyException) }
    /// The specified repository could not be found. Check the spelling of the specified repository and ensure that you are performing operations on the correct registry.
    public static var repositoryNotFoundException: Self { .init(.repositoryNotFoundException) }
    /// The specified repository and registry combination does not have an associated repository policy.
    public static var repositoryPolicyNotFoundException: Self { .init(.repositoryPolicyNotFoundException) }
    /// The specified image scan could not be found. Ensure that image scanning is enabled on the repository and try again.
    public static var scanNotFoundException: Self { .init(.scanNotFoundException) }
    /// The ARN of the secret specified in the pull through cache rule was not found. Update the pull through cache rule with a valid secret ARN and try again.
    public static var secretNotFoundException: Self { .init(.secretNotFoundException) }
    /// These errors are usually caused by a server-side issue.
    public static var serverException: Self { .init(.serverException) }
    /// The repository creation template already exists. Specify a unique prefix and try again.
    public static var templateAlreadyExistsException: Self { .init(.templateAlreadyExistsException) }
    /// The specified repository creation template can't be found. Verify the registry ID and prefix and try again.
    public static var templateNotFoundException: Self { .init(.templateNotFoundException) }
    /// The list of tags on the repository is over the limit. The maximum number of tags that can be applied to a repository is 50.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The secret is unable to be accessed. Verify the resource permissions for the secret and try again.
    public static var unableToAccessSecretException: Self { .init(.unableToAccessSecretException) }
    /// The secret is accessible but is unable to be decrypted. Verify the resource permisisons and try again.
    public static var unableToDecryptSecretValueException: Self { .init(.unableToDecryptSecretValueException) }
    /// The image or images were unable to be pulled using the pull through cache rule. This is usually caused because of an issue with the Secrets Manager secret containing the credentials for the upstream registry.
    public static var unableToGetUpstreamImageException: Self { .init(.unableToGetUpstreamImageException) }
    /// There was an issue getting the upstream layer matching the pull through cache rule.
    public static var unableToGetUpstreamLayerException: Self { .init(.unableToGetUpstreamLayerException) }
    /// The image is of a type that cannot be scanned.
    public static var unsupportedImageTypeException: Self { .init(.unsupportedImageTypeException) }
    /// The specified upstream registry isn't supported.
    public static var unsupportedUpstreamRegistryException: Self { .init(.unsupportedUpstreamRegistryException) }
    /// The upload could not be found, or the specified upload ID is not valid for this repository.
    public static var uploadNotFoundException: Self { .init(.uploadNotFoundException) }
    /// There was an exception validating this request.
    public static var validationException: Self { .init(.validationException) }
}

extension ECRErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "InvalidLayerPartException": ECR.InvalidLayerPartException.self,
        "KmsException": ECR.KmsException.self
    ]
}

extension ECRErrorType: Equatable {
    public static func == (lhs: ECRErrorType, rhs: ECRErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ECRErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
