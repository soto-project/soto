//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ApplicationInsights {
    // MARK: Enums

    public enum CloudWatchEventSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case codeDeploy = "CODE_DEPLOY"
        case ec2 = "EC2"
        case health = "HEALTH"
        case rds = "RDS"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationEventResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudformation = "CLOUDFORMATION"
        case cloudwatchAlarm = "CLOUDWATCH_ALARM"
        case cloudwatchLog = "CLOUDWATCH_LOG"
        case ssmAssociation = "SSM_ASSOCIATION"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationEventStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum DiscoveryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountBased = "ACCOUNT_BASED"
        case resourceGroupBased = "RESOURCE_GROUP_BASED"
        public var description: String { return self.rawValue }
    }

    public enum FeedbackKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case insightsFeedback = "INSIGHTS_FEEDBACK"
        public var description: String { return self.rawValue }
    }

    public enum FeedbackValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notSpecified = "NOT_SPECIFIED"
        case notUseful = "NOT_USEFUL"
        case useful = "USEFUL"
        public var description: String { return self.rawValue }
    }

    public enum GroupingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountBased = "ACCOUNT_BASED"
        public var description: String { return self.rawValue }
    }

    public enum LogFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum OsType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case infraOnly = "INFRA_ONLY"
        case workloadOnly = "WORKLOAD_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum ResolutionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automatic = "AUTOMATIC"
        case manual = "MANUAL"
        case unresolved = "UNRESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum SeverityLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "High"
        case informative = "Informative"
        case low = "Low"
        case medium = "Medium"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ignore = "IGNORE"
        case pending = "PENDING"
        case recovering = "RECOVERING"
        case recurring = "RECURRING"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum Tier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case activeDirectory = "ACTIVE_DIRECTORY"
        case custom = "CUSTOM"
        case dotNetCore = "DOT_NET_CORE"
        case dotNetWeb = "DOT_NET_WEB"
        case dotNetWebTier = "DOT_NET_WEB_TIER"
        case dotNetWorker = "DOT_NET_WORKER"
        case javaJmx = "JAVA_JMX"
        case mysql = "MYSQL"
        case oracle = "ORACLE"
        case postgresql = "POSTGRESQL"
        case sapHanaHighAvailability = "SAP_HANA_HIGH_AVAILABILITY"
        case sapHanaMultiNode = "SAP_HANA_MULTI_NODE"
        case sapHanaSingleNode = "SAP_HANA_SINGLE_NODE"
        case sapNetweaverDistributed = "SAP_NETWEAVER_DISTRIBUTED"
        case sapNetweaverHighAvailability = "SAP_NETWEAVER_HIGH_AVAILABILITY"
        case sapNetweaverStandard = "SAP_NETWEAVER_STANDARD"
        case sharepoint = "SHAREPOINT"
        case sqlServer = "SQL_SERVER"
        case sqlServerAlwaysonAvailabilityGroup = "SQL_SERVER_ALWAYSON_AVAILABILITY_GROUP"
        case sqlServerFailoverClusterInstance = "SQL_SERVER_FAILOVER_CLUSTER_INSTANCE"
        public var description: String { return self.rawValue }
    }

    public enum UpdateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum Visibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ignored = "IGNORED"
        case visible = "VISIBLE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddWorkloadRequest: AWSEncodableShape {
        /// The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
        public let workloadConfiguration: WorkloadConfiguration

        public init(componentName: String, resourceGroupName: String, workloadConfiguration: WorkloadConfiguration) {
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
            self.workloadConfiguration = workloadConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.workloadConfiguration.validate(name: "\(name).workloadConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
            case workloadConfiguration = "WorkloadConfiguration"
        }
    }

    public struct AddWorkloadResponse: AWSDecodableShape {
        /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
        public let workloadConfiguration: WorkloadConfiguration?
        /// The ID of the workload.
        public let workloadId: String?

        public init(workloadConfiguration: WorkloadConfiguration? = nil, workloadId: String? = nil) {
            self.workloadConfiguration = workloadConfiguration
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case workloadConfiguration = "WorkloadConfiguration"
            case workloadId = "WorkloadId"
        }
    }

    public struct ApplicationComponent: AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        ///  If logging is supported for the resource type, indicates whether the component has configured logs to be monitored.
        public let componentRemarks: String?
        ///  Workloads detected in the application component.
        public let detectedWorkload: [Tier: [String: String]]?
        /// Indicates whether the application component is monitored.
        public let monitor: Bool?
        ///  The operating system of the component.
        public let osType: OsType?
        /// The resource type. Supported resource types include EC2 instances, Auto Scaling group, Classic ELB, Application ELB, and SQS Queue.
        public let resourceType: String?
        /// The stack tier of the application component.
        public let tier: Tier?

        public init(componentName: String? = nil, componentRemarks: String? = nil, detectedWorkload: [Tier: [String: String]]? = nil, monitor: Bool? = nil, osType: OsType? = nil, resourceType: String? = nil, tier: Tier? = nil) {
            self.componentName = componentName
            self.componentRemarks = componentRemarks
            self.detectedWorkload = detectedWorkload
            self.monitor = monitor
            self.osType = osType
            self.resourceType = resourceType
            self.tier = tier
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case componentRemarks = "ComponentRemarks"
            case detectedWorkload = "DetectedWorkload"
            case monitor = "Monitor"
            case osType = "OsType"
            case resourceType = "ResourceType"
            case tier = "Tier"
        }
    }

    public struct ApplicationInfo: AWSDecodableShape {
        /// The AWS account ID for the owner of the application.
        public let accountId: String?
        /// If set to true, the managed policies for SSM and CW will be attached to the instance roles if they are missing.
        public let attachMissingPermission: Bool?
        ///  Indicates whether auto-configuration is turned on for this application.
        public let autoConfigEnabled: Bool?
        ///  Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
        public let cweMonitorEnabled: Bool?
        ///  The method used by Application Insights to onboard your resources.
        public let discoveryType: DiscoveryType?
        /// The lifecycle of the application.
        public let lifeCycle: String?
        ///  Indicates whether Application Insights will create opsItems for any problem detected by Application Insights for an application.
        public let opsCenterEnabled: Bool?
        ///  The SNS topic provided to Application Insights that is associated to the created opsItems to receive SNS notifications for opsItem updates.
        public let opsItemSNSTopicArn: String?
        /// The issues on the user side that block Application Insights from successfully monitoring an application. Example remarks include:   “Configuring application, detected 1 Errors, 3 Warnings”   “Configuring application, detected 1 Unconfigured Components”
        public let remarks: String?
        /// The name of the resource group used for the application.
        public let resourceGroupName: String?

        public init(accountId: String? = nil, attachMissingPermission: Bool? = nil, autoConfigEnabled: Bool? = nil, cweMonitorEnabled: Bool? = nil, discoveryType: DiscoveryType? = nil, lifeCycle: String? = nil, opsCenterEnabled: Bool? = nil, opsItemSNSTopicArn: String? = nil, remarks: String? = nil, resourceGroupName: String? = nil) {
            self.accountId = accountId
            self.attachMissingPermission = attachMissingPermission
            self.autoConfigEnabled = autoConfigEnabled
            self.cweMonitorEnabled = cweMonitorEnabled
            self.discoveryType = discoveryType
            self.lifeCycle = lifeCycle
            self.opsCenterEnabled = opsCenterEnabled
            self.opsItemSNSTopicArn = opsItemSNSTopicArn
            self.remarks = remarks
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case attachMissingPermission = "AttachMissingPermission"
            case autoConfigEnabled = "AutoConfigEnabled"
            case cweMonitorEnabled = "CWEMonitorEnabled"
            case discoveryType = "DiscoveryType"
            case lifeCycle = "LifeCycle"
            case opsCenterEnabled = "OpsCenterEnabled"
            case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
            case remarks = "Remarks"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ConfigurationEvent: AWSDecodableShape {
        /// The AWS account ID for the owner of the application to which the configuration event belongs.
        public let accountId: String?
        ///  The details of the event in plain text.
        public let eventDetail: String?
        ///  The name of the resource Application Insights attempted to configure.
        public let eventResourceName: String?
        ///  The resource type that Application Insights attempted to configure, for example, CLOUDWATCH_ALARM.
        public let eventResourceType: ConfigurationEventResourceType?
        ///  The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
        public let eventStatus: ConfigurationEventStatus?
        ///  The timestamp of the event.
        public let eventTime: Date?
        ///  The resource monitored by Application Insights.
        public let monitoredResourceARN: String?
        /// The name of the resource group of the application to which the configuration event belongs.
        public let resourceGroupName: String?

        public init(accountId: String? = nil, eventDetail: String? = nil, eventResourceName: String? = nil, eventResourceType: ConfigurationEventResourceType? = nil, eventStatus: ConfigurationEventStatus? = nil, eventTime: Date? = nil, monitoredResourceARN: String? = nil, resourceGroupName: String? = nil) {
            self.accountId = accountId
            self.eventDetail = eventDetail
            self.eventResourceName = eventResourceName
            self.eventResourceType = eventResourceType
            self.eventStatus = eventStatus
            self.eventTime = eventTime
            self.monitoredResourceARN = monitoredResourceARN
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case eventDetail = "EventDetail"
            case eventResourceName = "EventResourceName"
            case eventResourceType = "EventResourceType"
            case eventStatus = "EventStatus"
            case eventTime = "EventTime"
            case monitoredResourceARN = "MonitoredResourceARN"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// If set to true, the managed policies for SSM and CW will be attached to the instance roles if they are missing.
        public let attachMissingPermission: Bool?
        ///  Indicates whether Application Insights automatically configures unmonitored resources in the resource group.
        public let autoConfigEnabled: Bool?
        ///  Configures all of the resources in the resource group by applying the recommended configurations.
        public let autoCreate: Bool?
        ///  Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
        public let cweMonitorEnabled: Bool?
        /// Application Insights can create applications based on a resource group or on an account. To create an account-based application using all of the resources in the account, set this parameter to ACCOUNT_BASED.
        public let groupingType: GroupingType?
        ///  When set to true, creates opsItems for any problems detected on an application.
        public let opsCenterEnabled: Bool?
        ///  The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
        public let opsItemSNSTopicArn: String?
        /// The name of the resource group.
        public let resourceGroupName: String?
        /// List of tags to add to the application. tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
        public let tags: [Tag]?

        public init(attachMissingPermission: Bool? = nil, autoConfigEnabled: Bool? = nil, autoCreate: Bool? = nil, cweMonitorEnabled: Bool? = nil, groupingType: GroupingType? = nil, opsCenterEnabled: Bool? = nil, opsItemSNSTopicArn: String? = nil, resourceGroupName: String? = nil, tags: [Tag]? = nil) {
            self.attachMissingPermission = attachMissingPermission
            self.autoConfigEnabled = autoConfigEnabled
            self.autoCreate = autoCreate
            self.cweMonitorEnabled = cweMonitorEnabled
            self.groupingType = groupingType
            self.opsCenterEnabled = opsCenterEnabled
            self.opsItemSNSTopicArn = opsItemSNSTopicArn
            self.resourceGroupName = resourceGroupName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.opsItemSNSTopicArn, name: "opsItemSNSTopicArn", parent: name, max: 300)
            try self.validate(self.opsItemSNSTopicArn, name: "opsItemSNSTopicArn", parent: name, min: 20)
            try self.validate(self.opsItemSNSTopicArn, name: "opsItemSNSTopicArn", parent: name, pattern: "^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case attachMissingPermission = "AttachMissingPermission"
            case autoConfigEnabled = "AutoConfigEnabled"
            case autoCreate = "AutoCreate"
            case cweMonitorEnabled = "CWEMonitorEnabled"
            case groupingType = "GroupingType"
            case opsCenterEnabled = "OpsCenterEnabled"
            case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
            case resourceGroupName = "ResourceGroupName"
            case tags = "Tags"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// Information about the application.
        public let applicationInfo: ApplicationInfo?

        public init(applicationInfo: ApplicationInfo? = nil) {
            self.applicationInfo = applicationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInfo = "ApplicationInfo"
        }
    }

    public struct CreateComponentRequest: AWSEncodableShape {
        /// The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The list of resource ARNs that belong to the component.
        public let resourceList: [String]

        public init(componentName: String, resourceGroupName: String, resourceList: [String]) {
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
            self.resourceList = resourceList
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 128)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[\\d\\w\\-_\\.+]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.resourceList.forEach {
                try validate($0, name: "resourceList[]", parent: name, max: 1011)
                try validate($0, name: "resourceList[]", parent: name, min: 1)
                try validate($0, name: "resourceList[]", parent: name, pattern: "^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
            case resourceList = "ResourceList"
        }
    }

    public struct CreateComponentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateLogPatternRequest: AWSEncodableShape {
        /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
        public let pattern: String
        /// The name of the log pattern.
        public let patternName: String
        /// The name of the log pattern set.
        public let patternSetName: String
        /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
        public let rank: Int
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(pattern: String, patternName: String, patternSetName: String, rank: Int = 0, resourceGroupName: String) {
            self.pattern = pattern
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.rank = rank
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.pattern, name: "pattern", parent: name, max: 50)
            try self.validate(self.pattern, name: "pattern", parent: name, min: 1)
            try self.validate(self.pattern, name: "pattern", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.patternName, name: "patternName", parent: name, max: 50)
            try self.validate(self.patternName, name: "patternName", parent: name, min: 1)
            try self.validate(self.patternName, name: "patternName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, max: 30)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, min: 1)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case pattern = "Pattern"
            case patternName = "PatternName"
            case patternSetName = "PatternSetName"
            case rank = "Rank"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct CreateLogPatternResponse: AWSDecodableShape {
        /// The successfully created log pattern.
        public let logPattern: LogPattern?
        /// The name of the resource group.
        public let resourceGroupName: String?

        public init(logPattern: LogPattern? = nil, resourceGroupName: String? = nil) {
            self.logPattern = logPattern
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logPattern = "LogPattern"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(resourceGroupName: String) {
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteComponentRequest: AWSEncodableShape {
        /// The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(componentName: String, resourceGroupName: String) {
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 128)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[\\d\\w\\-_\\.+]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DeleteComponentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLogPatternRequest: AWSEncodableShape {
        /// The name of the log pattern.
        public let patternName: String
        /// The name of the log pattern set.
        public let patternSetName: String
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(patternName: String, patternSetName: String, resourceGroupName: String) {
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.patternName, name: "patternName", parent: name, max: 50)
            try self.validate(self.patternName, name: "patternName", parent: name, min: 1)
            try self.validate(self.patternName, name: "patternName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, max: 30)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, min: 1)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case patternName = "PatternName"
            case patternSetName = "PatternSetName"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DeleteLogPatternResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeApplicationRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, resourceGroupName: String) {
            self.accountId = accountId
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DescribeApplicationResponse: AWSDecodableShape {
        /// Information about the application.
        public let applicationInfo: ApplicationInfo?

        public init(applicationInfo: ApplicationInfo? = nil) {
            self.applicationInfo = applicationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInfo = "ApplicationInfo"
        }
    }

    public struct DescribeComponentConfigurationRecommendationRequest: AWSEncodableShape {
        /// The name of the component.
        public let componentName: String
        /// The recommended configuration type.
        public let recommendationType: RecommendationType?
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The tier of the application component.
        public let tier: Tier
        /// The name of the workload.
        public let workloadName: String?

        public init(componentName: String, recommendationType: RecommendationType? = nil, resourceGroupName: String, tier: Tier, workloadName: String? = nil) {
            self.componentName = componentName
            self.recommendationType = recommendationType
            self.resourceGroupName = resourceGroupName
            self.tier = tier
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 8)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case recommendationType = "RecommendationType"
            case resourceGroupName = "ResourceGroupName"
            case tier = "Tier"
            case workloadName = "WorkloadName"
        }
    }

    public struct DescribeComponentConfigurationRecommendationResponse: AWSDecodableShape {
        /// The recommended configuration settings of the component. The value is the escaped JSON of the configuration.
        public let componentConfiguration: String?

        public init(componentConfiguration: String? = nil) {
            self.componentConfiguration = componentConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case componentConfiguration = "ComponentConfiguration"
        }
    }

    public struct DescribeComponentConfigurationRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, componentName: String, resourceGroupName: String) {
            self.accountId = accountId
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DescribeComponentConfigurationResponse: AWSDecodableShape {
        /// The configuration settings of the component. The value is the escaped JSON of the configuration.
        public let componentConfiguration: String?
        /// Indicates whether the application component is monitored.
        public let monitor: Bool?
        /// The tier of the application component. Supported tiers include DOT_NET_CORE, DOT_NET_WORKER, DOT_NET_WEB, SQL_SERVER, and DEFAULT
        public let tier: Tier?

        public init(componentConfiguration: String? = nil, monitor: Bool? = nil, tier: Tier? = nil) {
            self.componentConfiguration = componentConfiguration
            self.monitor = monitor
            self.tier = tier
        }

        private enum CodingKeys: String, CodingKey {
            case componentConfiguration = "ComponentConfiguration"
            case monitor = "Monitor"
            case tier = "Tier"
        }
    }

    public struct DescribeComponentRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, componentName: String, resourceGroupName: String) {
            self.accountId = accountId
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DescribeComponentResponse: AWSDecodableShape {
        public let applicationComponent: ApplicationComponent?
        /// The list of resource ARNs that belong to the component.
        public let resourceList: [String]?

        public init(applicationComponent: ApplicationComponent? = nil, resourceList: [String]? = nil) {
            self.applicationComponent = applicationComponent
            self.resourceList = resourceList
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponent = "ApplicationComponent"
            case resourceList = "ResourceList"
        }
    }

    public struct DescribeLogPatternRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The name of the log pattern.
        public let patternName: String
        /// The name of the log pattern set.
        public let patternSetName: String
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, patternName: String, patternSetName: String, resourceGroupName: String) {
            self.accountId = accountId
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.patternName, name: "patternName", parent: name, max: 50)
            try self.validate(self.patternName, name: "patternName", parent: name, min: 1)
            try self.validate(self.patternName, name: "patternName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, max: 30)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, min: 1)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case patternName = "PatternName"
            case patternSetName = "PatternSetName"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DescribeLogPatternResponse: AWSDecodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The successfully created log pattern.
        public let logPattern: LogPattern?
        /// The name of the resource group.
        public let resourceGroupName: String?

        public init(accountId: String? = nil, logPattern: LogPattern? = nil, resourceGroupName: String? = nil) {
            self.accountId = accountId
            self.logPattern = logPattern
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case logPattern = "LogPattern"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct DescribeObservationRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The ID of the observation.
        public let observationId: String

        public init(accountId: String? = nil, observationId: String) {
            self.accountId = accountId
            self.observationId = observationId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.observationId, name: "observationId", parent: name, max: 38)
            try self.validate(self.observationId, name: "observationId", parent: name, min: 38)
            try self.validate(self.observationId, name: "observationId", parent: name, pattern: "^o-[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case observationId = "ObservationId"
        }
    }

    public struct DescribeObservationResponse: AWSDecodableShape {
        /// Information about the observation.
        public let observation: Observation?

        public init(observation: Observation? = nil) {
            self.observation = observation
        }

        private enum CodingKeys: String, CodingKey {
            case observation = "Observation"
        }
    }

    public struct DescribeProblemObservationsRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The ID of the problem.
        public let problemId: String

        public init(accountId: String? = nil, problemId: String) {
            self.accountId = accountId
            self.problemId = problemId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.problemId, name: "problemId", parent: name, max: 38)
            try self.validate(self.problemId, name: "problemId", parent: name, min: 38)
            try self.validate(self.problemId, name: "problemId", parent: name, pattern: "^p-[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case problemId = "ProblemId"
        }
    }

    public struct DescribeProblemObservationsResponse: AWSDecodableShape {
        /// Observations related to the problem.
        public let relatedObservations: RelatedObservations?

        public init(relatedObservations: RelatedObservations? = nil) {
            self.relatedObservations = relatedObservations
        }

        private enum CodingKeys: String, CodingKey {
            case relatedObservations = "RelatedObservations"
        }
    }

    public struct DescribeProblemRequest: AWSEncodableShape {
        /// The AWS account ID for the owner of the resource group affected by the problem.
        public let accountId: String?
        /// The ID of the problem.
        public let problemId: String

        public init(accountId: String? = nil, problemId: String) {
            self.accountId = accountId
            self.problemId = problemId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.problemId, name: "problemId", parent: name, max: 38)
            try self.validate(self.problemId, name: "problemId", parent: name, min: 38)
            try self.validate(self.problemId, name: "problemId", parent: name, pattern: "^p-[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case problemId = "ProblemId"
        }
    }

    public struct DescribeProblemResponse: AWSDecodableShape {
        /// Information about the problem.
        public let problem: Problem?

        public init(problem: Problem? = nil) {
            self.problem = problem
        }

        private enum CodingKeys: String, CodingKey {
            case problem = "Problem"
        }
    }

    public struct DescribeWorkloadRequest: AWSEncodableShape {
        /// The AWS account ID for the workload owner.
        public let accountId: String?
        /// The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The ID of the workload.
        public let workloadId: String

        public init(accountId: String? = nil, componentName: String, resourceGroupName: String, workloadId: String) {
            self.accountId = accountId
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.workloadId, name: "workloadId", parent: name, max: 38)
            try self.validate(self.workloadId, name: "workloadId", parent: name, min: 38)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^w-[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
            case workloadId = "WorkloadId"
        }
    }

    public struct DescribeWorkloadResponse: AWSDecodableShape {
        /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
        public let workloadConfiguration: WorkloadConfiguration?
        /// The ID of the workload.
        public let workloadId: String?
        /// If logging is supported for the resource type, shows whether the component has configured logs to be monitored.
        public let workloadRemarks: String?

        public init(workloadConfiguration: WorkloadConfiguration? = nil, workloadId: String? = nil, workloadRemarks: String? = nil) {
            self.workloadConfiguration = workloadConfiguration
            self.workloadId = workloadId
            self.workloadRemarks = workloadRemarks
        }

        private enum CodingKeys: String, CodingKey {
            case workloadConfiguration = "WorkloadConfiguration"
            case workloadId = "WorkloadId"
            case workloadRemarks = "WorkloadRemarks"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        public init(accountId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 40)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// The list of applications.
        public let applicationInfoList: [ApplicationInfo]?
        /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(applicationInfoList: [ApplicationInfo]? = nil, nextToken: String? = nil) {
            self.applicationInfoList = applicationInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInfoList = "ApplicationInfoList"
            case nextToken = "NextToken"
        }
    }

    public struct ListComponentsRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceGroupName: String) {
            self.accountId = accountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 40)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ListComponentsResponse: AWSDecodableShape {
        /// The list of application components.
        public let applicationComponentList: [ApplicationComponent]?
        /// The token to request the next page of results.
        public let nextToken: String?

        public init(applicationComponentList: [ApplicationComponent]? = nil, nextToken: String? = nil) {
            self.applicationComponentList = applicationComponentList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentList = "ApplicationComponentList"
            case nextToken = "NextToken"
        }
    }

    public struct ListConfigurationHistoryRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The end time of the event.
        public let endTime: Date?
        /// The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
        public let eventStatus: ConfigurationEventStatus?
        ///  The maximum number of results returned by ListConfigurationHistory in paginated output. When this parameter is used, ListConfigurationHistory returns only MaxResults in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another ListConfigurationHistory request with the returned NextToken value. If this parameter is not used, then ListConfigurationHistory returns all results.
        public let maxResults: Int?
        /// The NextToken value returned from a previous paginated ListConfigurationHistory request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Resource group to which the application belongs.
        public let resourceGroupName: String?
        /// The start time of the event.
        public let startTime: Date?

        public init(accountId: String? = nil, endTime: Date? = nil, eventStatus: ConfigurationEventStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceGroupName: String? = nil, startTime: Date? = nil) {
            self.accountId = accountId
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceGroupName = resourceGroupName
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 40)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case endTime = "EndTime"
            case eventStatus = "EventStatus"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceGroupName = "ResourceGroupName"
            case startTime = "StartTime"
        }
    }

    public struct ListConfigurationHistoryResponse: AWSDecodableShape {
        ///  The list of configuration events and their corresponding details.
        public let eventList: [ConfigurationEvent]?
        /// The NextToken value to include in a future ListConfigurationHistory request. When the results of a ListConfigurationHistory request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(eventList: [ConfigurationEvent]? = nil, nextToken: String? = nil) {
            self.eventList = eventList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventList = "EventList"
            case nextToken = "NextToken"
        }
    }

    public struct ListLogPatternSetsRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceGroupName: String) {
            self.accountId = accountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 40)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ListLogPatternSetsResponse: AWSDecodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The list of log pattern sets.
        public let logPatternSets: [String]?
        /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The name of the resource group.
        public let resourceGroupName: String?

        public init(accountId: String? = nil, logPatternSets: [String]? = nil, nextToken: String? = nil, resourceGroupName: String? = nil) {
            self.accountId = accountId
            self.logPatternSets = logPatternSets
            self.nextToken = nextToken
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case logPatternSets = "LogPatternSets"
            case nextToken = "NextToken"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ListLogPatternsRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The name of the log pattern set.
        public let patternSetName: String?
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, patternSetName: String? = nil, resourceGroupName: String) {
            self.accountId = accountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.patternSetName = patternSetName
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 40)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, max: 30)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, min: 1)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case patternSetName = "PatternSetName"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ListLogPatternsResponse: AWSDecodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The list of log patterns.
        public let logPatterns: [LogPattern]?
        /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The name of the resource group.
        public let resourceGroupName: String?

        public init(accountId: String? = nil, logPatterns: [LogPattern]? = nil, nextToken: String? = nil, resourceGroupName: String? = nil) {
            self.accountId = accountId
            self.logPatterns = logPatterns
            self.nextToken = nextToken
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case logPatterns = "LogPatterns"
            case nextToken = "NextToken"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ListProblemsRequest: AWSEncodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        ///  The name of the component.
        public let componentName: String?
        /// The time when the problem ended, in epoch seconds. If not specified, problems within the past seven days are returned.
        public let endTime: Date?
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The name of the resource group.
        public let resourceGroupName: String?
        /// The time when the problem was detected, in epoch seconds. If you don't specify a time frame for the request, problems within the past seven days are returned.
        public let startTime: Date?
        /// Specifies whether or not you can view the problem. If not specified, visible and ignored problems are returned.
        public let visibility: Visibility?

        public init(accountId: String? = nil, componentName: String? = nil, endTime: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceGroupName: String? = nil, startTime: Date? = nil, visibility: Visibility? = nil) {
            self.accountId = accountId
            self.componentName = componentName
            self.endTime = endTime
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceGroupName = resourceGroupName
            self.startTime = startTime
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 40)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case componentName = "ComponentName"
            case endTime = "EndTime"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceGroupName = "ResourceGroupName"
            case startTime = "StartTime"
            case visibility = "Visibility"
        }
    }

    public struct ListProblemsResponse: AWSDecodableShape {
        /// The AWS account ID for the resource group owner.
        public let accountId: String?
        /// The token used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of problems.
        public let problemList: [Problem]?
        ///  The name of the resource group.
        public let resourceGroupName: String?

        public init(accountId: String? = nil, nextToken: String? = nil, problemList: [Problem]? = nil, resourceGroupName: String? = nil) {
            self.accountId = accountId
            self.nextToken = nextToken
            self.problemList = problemList
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case nextToken = "NextToken"
            case problemList = "ProblemList"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application that you want to retrieve tag information for.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// An array that lists all the tags that are associated with the application. Each tag consists of a required tag key (Key) and an associated tag value (Value).
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListWorkloadsRequest: AWSEncodableShape {
        /// The AWS account ID of the owner of the workload.
        public let accountId: String?
        /// The name of the component.
        public let componentName: String
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(accountId: String? = nil, componentName: String, maxResults: Int? = nil, nextToken: String? = nil, resourceGroupName: String) {
            self.accountId = accountId
            self.componentName = componentName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 40)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case componentName = "ComponentName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct ListWorkloadsResponse: AWSDecodableShape {
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The list of workloads.
        public let workloadList: [Workload]?

        public init(nextToken: String? = nil, workloadList: [Workload]? = nil) {
            self.nextToken = nextToken
            self.workloadList = workloadList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workloadList = "WorkloadList"
        }
    }

    public struct LogPattern: AWSDecodableShape {
        /// A regular expression that defines the log pattern. A log pattern can contain as many as 50 characters, and it cannot be empty. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
        public let pattern: String?
        /// The name of the log pattern. A log pattern name can contain as many as 50 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public let patternName: String?
        /// The name of the log pattern. A log pattern name can contain as many as 30 characters, and it cannot be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.
        public let patternSetName: String?
        /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
        public let rank: Int?

        public init(pattern: String? = nil, patternName: String? = nil, patternSetName: String? = nil, rank: Int? = nil) {
            self.pattern = pattern
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.rank = rank
        }

        private enum CodingKeys: String, CodingKey {
            case pattern = "Pattern"
            case patternName = "PatternName"
            case patternSetName = "PatternSetName"
            case rank = "Rank"
        }
    }

    public struct Observation: AWSDecodableShape {
        ///  The detail type of the CloudWatch Event-based observation, for example, EC2 Instance State-change Notification.
        public let cloudWatchEventDetailType: String?
        ///  The ID of the CloudWatch Event-based observation related to the detected problem.
        public let cloudWatchEventId: String?
        ///  The source of the CloudWatch Event.
        public let cloudWatchEventSource: CloudWatchEventSource?
        ///  The CodeDeploy application to which the deployment belongs.
        public let codeDeployApplication: String?
        ///  The deployment group to which the CodeDeploy deployment belongs.
        public let codeDeployDeploymentGroup: String?
        ///  The deployment ID of the CodeDeploy-based observation related to the detected problem.
        public let codeDeployDeploymentId: String?
        ///  The instance group to which the CodeDeploy instance belongs.
        public let codeDeployInstanceGroupId: String?
        ///  The status of the CodeDeploy deployment, for example SUCCESS or  FAILURE.
        public let codeDeployState: String?
        ///  The cause of an EBS CloudWatch event.
        public let ebsCause: String?
        ///  The type of EBS CloudWatch event, such as createVolume, deleteVolume or attachVolume.
        public let ebsEvent: String?
        ///  The request ID of an EBS CloudWatch event.
        public let ebsRequestId: String?
        ///  The result of an EBS CloudWatch event, such as failed or succeeded.
        public let ebsResult: String?
        ///  The state of the instance, such as STOPPING or TERMINATING.
        public let ec2State: String?
        /// The time when the observation ended, in epoch seconds.
        public let endTime: Date?
        ///  The Amazon Resource Name (ARN) of the AWS Health Event-based observation.
        public let healthEventArn: String?
        ///  The description of the AWS Health event provided by the service, such as Amazon EC2.
        public let healthEventDescription: String?
        ///  The category of the AWS Health event, such as issue.
        public let healthEventTypeCategory: String?
        ///  The type of the AWS Health event, for example, AWS_EC2_POWER_CONNECTIVITY_ISSUE.
        public let healthEventTypeCode: String?
        ///  The service to which the AWS Health Event belongs, such as EC2.
        public let healthService: String?
        /// The ID of the observation type.
        public let id: String?
        /// The timestamp in the CloudWatch Logs that specifies when the matched line occurred.
        public let lineTime: Date?
        /// The log filter of the observation.
        public let logFilter: LogFilter?
        /// The log group name.
        public let logGroup: String?
        /// The log text of the observation.
        public let logText: String?
        /// The name of the observation metric.
        public let metricName: String?
        /// The namespace of the observation metric.
        public let metricNamespace: String?
        ///  The category of an RDS event.
        public let rdsEventCategories: String?
        ///  The message of an RDS event.
        public let rdsEventMessage: String?
        ///  The name of the S3 CloudWatch Event-based observation.
        public let s3EventName: String?
        /// The source resource ARN of the observation.
        public let sourceARN: String?
        /// The source type of the observation.
        public let sourceType: String?
        /// The time when the observation was first detected, in epoch seconds.
        public let startTime: Date?
        ///  The Amazon Resource Name (ARN) of the step function-based observation.
        public let statesArn: String?
        ///  The Amazon Resource Name (ARN) of the step function execution-based observation.
        public let statesExecutionArn: String?
        ///  The input to the step function-based observation.
        public let statesInput: String?
        ///  The status of the step function-related observation.
        public let statesStatus: String?
        /// The unit of the source observation metric.
        public let unit: String?
        /// The value of the source observation metric.
        public let value: Double?
        ///  The X-Ray request error percentage for this node.
        public let xRayErrorPercent: Int?
        ///  The X-Ray request fault percentage for this node.
        public let xRayFaultPercent: Int?
        ///  The name of the X-Ray node.
        public let xRayNodeName: String?
        ///  The type of the X-Ray node.
        public let xRayNodeType: String?
        ///  The X-Ray node request average latency for this node.
        public let xRayRequestAverageLatency: Int64?
        ///  The X-Ray request count for this node.
        public let xRayRequestCount: Int?
        ///  The X-Ray request throttle percentage for this node.
        public let xRayThrottlePercent: Int?

        public init(cloudWatchEventDetailType: String? = nil, cloudWatchEventId: String? = nil, cloudWatchEventSource: CloudWatchEventSource? = nil, codeDeployApplication: String? = nil, codeDeployDeploymentGroup: String? = nil, codeDeployDeploymentId: String? = nil, codeDeployInstanceGroupId: String? = nil, codeDeployState: String? = nil, ebsCause: String? = nil, ebsEvent: String? = nil, ebsRequestId: String? = nil, ebsResult: String? = nil, ec2State: String? = nil, endTime: Date? = nil, healthEventArn: String? = nil, healthEventDescription: String? = nil, healthEventTypeCategory: String? = nil, healthEventTypeCode: String? = nil, healthService: String? = nil, id: String? = nil, lineTime: Date? = nil, logFilter: LogFilter? = nil, logGroup: String? = nil, logText: String? = nil, metricName: String? = nil, metricNamespace: String? = nil, rdsEventCategories: String? = nil, rdsEventMessage: String? = nil, s3EventName: String? = nil, sourceARN: String? = nil, sourceType: String? = nil, startTime: Date? = nil, statesArn: String? = nil, statesExecutionArn: String? = nil, statesInput: String? = nil, statesStatus: String? = nil, unit: String? = nil, value: Double? = nil, xRayErrorPercent: Int? = nil, xRayFaultPercent: Int? = nil, xRayNodeName: String? = nil, xRayNodeType: String? = nil, xRayRequestAverageLatency: Int64? = nil, xRayRequestCount: Int? = nil, xRayThrottlePercent: Int? = nil) {
            self.cloudWatchEventDetailType = cloudWatchEventDetailType
            self.cloudWatchEventId = cloudWatchEventId
            self.cloudWatchEventSource = cloudWatchEventSource
            self.codeDeployApplication = codeDeployApplication
            self.codeDeployDeploymentGroup = codeDeployDeploymentGroup
            self.codeDeployDeploymentId = codeDeployDeploymentId
            self.codeDeployInstanceGroupId = codeDeployInstanceGroupId
            self.codeDeployState = codeDeployState
            self.ebsCause = ebsCause
            self.ebsEvent = ebsEvent
            self.ebsRequestId = ebsRequestId
            self.ebsResult = ebsResult
            self.ec2State = ec2State
            self.endTime = endTime
            self.healthEventArn = healthEventArn
            self.healthEventDescription = healthEventDescription
            self.healthEventTypeCategory = healthEventTypeCategory
            self.healthEventTypeCode = healthEventTypeCode
            self.healthService = healthService
            self.id = id
            self.lineTime = lineTime
            self.logFilter = logFilter
            self.logGroup = logGroup
            self.logText = logText
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.rdsEventCategories = rdsEventCategories
            self.rdsEventMessage = rdsEventMessage
            self.s3EventName = s3EventName
            self.sourceARN = sourceARN
            self.sourceType = sourceType
            self.startTime = startTime
            self.statesArn = statesArn
            self.statesExecutionArn = statesExecutionArn
            self.statesInput = statesInput
            self.statesStatus = statesStatus
            self.unit = unit
            self.value = value
            self.xRayErrorPercent = xRayErrorPercent
            self.xRayFaultPercent = xRayFaultPercent
            self.xRayNodeName = xRayNodeName
            self.xRayNodeType = xRayNodeType
            self.xRayRequestAverageLatency = xRayRequestAverageLatency
            self.xRayRequestCount = xRayRequestCount
            self.xRayThrottlePercent = xRayThrottlePercent
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEventDetailType = "CloudWatchEventDetailType"
            case cloudWatchEventId = "CloudWatchEventId"
            case cloudWatchEventSource = "CloudWatchEventSource"
            case codeDeployApplication = "CodeDeployApplication"
            case codeDeployDeploymentGroup = "CodeDeployDeploymentGroup"
            case codeDeployDeploymentId = "CodeDeployDeploymentId"
            case codeDeployInstanceGroupId = "CodeDeployInstanceGroupId"
            case codeDeployState = "CodeDeployState"
            case ebsCause = "EbsCause"
            case ebsEvent = "EbsEvent"
            case ebsRequestId = "EbsRequestId"
            case ebsResult = "EbsResult"
            case ec2State = "Ec2State"
            case endTime = "EndTime"
            case healthEventArn = "HealthEventArn"
            case healthEventDescription = "HealthEventDescription"
            case healthEventTypeCategory = "HealthEventTypeCategory"
            case healthEventTypeCode = "HealthEventTypeCode"
            case healthService = "HealthService"
            case id = "Id"
            case lineTime = "LineTime"
            case logFilter = "LogFilter"
            case logGroup = "LogGroup"
            case logText = "LogText"
            case metricName = "MetricName"
            case metricNamespace = "MetricNamespace"
            case rdsEventCategories = "RdsEventCategories"
            case rdsEventMessage = "RdsEventMessage"
            case s3EventName = "S3EventName"
            case sourceARN = "SourceARN"
            case sourceType = "SourceType"
            case startTime = "StartTime"
            case statesArn = "StatesArn"
            case statesExecutionArn = "StatesExecutionArn"
            case statesInput = "StatesInput"
            case statesStatus = "StatesStatus"
            case unit = "Unit"
            case value = "Value"
            case xRayErrorPercent = "XRayErrorPercent"
            case xRayFaultPercent = "XRayFaultPercent"
            case xRayNodeName = "XRayNodeName"
            case xRayNodeType = "XRayNodeType"
            case xRayRequestAverageLatency = "XRayRequestAverageLatency"
            case xRayRequestCount = "XRayRequestCount"
            case xRayThrottlePercent = "XRayThrottlePercent"
        }
    }

    public struct Problem: AWSDecodableShape {
        /// The AWS account ID for the owner of the resource group affected by the problem.
        public let accountId: String?
        /// The resource affected by the problem.
        public let affectedResource: String?
        /// The time when the problem ended, in epoch seconds.
        public let endTime: Date?
        /// Feedback provided by the user about the problem.
        public let feedback: [FeedbackKey: FeedbackValue]?
        /// The ID of the problem.
        public let id: String?
        /// A detailed analysis of the problem using machine learning.
        public let insights: String?
        ///  The last time that the problem reoccurred after its last resolution.
        public let lastRecurrenceTime: Date?
        ///  The number of times that the same problem reoccurred after the first time it was resolved.
        public let recurringCount: Int64?
        /// Specifies how the problem was resolved. If the value is AUTOMATIC, the system resolved the problem. If the value is MANUAL, the user resolved the problem. If the value is UNRESOLVED, then the problem is not resolved.
        public let resolutionMethod: ResolutionMethod?
        /// The name of the resource group affected by the problem.
        public let resourceGroupName: String?
        /// A measure of the level of impact of the problem.
        public let severityLevel: SeverityLevel?
        /// The time when the problem started, in epoch seconds.
        public let startTime: Date?
        /// The status of the problem.
        public let status: Status?
        /// The name of the problem.
        public let title: String?
        /// Specifies whether or not you can view the problem. Updates to ignored problems do not generate notifications.
        public let visibility: Visibility?

        public init(accountId: String? = nil, affectedResource: String? = nil, endTime: Date? = nil, feedback: [FeedbackKey: FeedbackValue]? = nil, id: String? = nil, insights: String? = nil, lastRecurrenceTime: Date? = nil, recurringCount: Int64? = nil, resolutionMethod: ResolutionMethod? = nil, resourceGroupName: String? = nil, severityLevel: SeverityLevel? = nil, startTime: Date? = nil, status: Status? = nil, title: String? = nil, visibility: Visibility? = nil) {
            self.accountId = accountId
            self.affectedResource = affectedResource
            self.endTime = endTime
            self.feedback = feedback
            self.id = id
            self.insights = insights
            self.lastRecurrenceTime = lastRecurrenceTime
            self.recurringCount = recurringCount
            self.resolutionMethod = resolutionMethod
            self.resourceGroupName = resourceGroupName
            self.severityLevel = severityLevel
            self.startTime = startTime
            self.status = status
            self.title = title
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case affectedResource = "AffectedResource"
            case endTime = "EndTime"
            case feedback = "Feedback"
            case id = "Id"
            case insights = "Insights"
            case lastRecurrenceTime = "LastRecurrenceTime"
            case recurringCount = "RecurringCount"
            case resolutionMethod = "ResolutionMethod"
            case resourceGroupName = "ResourceGroupName"
            case severityLevel = "SeverityLevel"
            case startTime = "StartTime"
            case status = "Status"
            case title = "Title"
            case visibility = "Visibility"
        }
    }

    public struct RelatedObservations: AWSDecodableShape {
        /// The list of observations related to the problem.
        public let observationList: [Observation]?

        public init(observationList: [Observation]? = nil) {
            self.observationList = observationList
        }

        private enum CodingKeys: String, CodingKey {
            case observationList = "ObservationList"
        }
    }

    public struct RemoveWorkloadRequest: AWSEncodableShape {
        /// The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The ID of the workload.
        public let workloadId: String

        public init(componentName: String, resourceGroupName: String, workloadId: String) {
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.workloadId, name: "workloadId", parent: name, max: 38)
            try self.validate(self.workloadId, name: "workloadId", parent: name, min: 38)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^w-[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
            case workloadId = "WorkloadId"
        }
    }

    public struct RemoveWorkloadResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that defines a tag. The maximum length of a tag key is 128 characters. The minimum length is 1 character.
        public let key: String
        /// The optional part of a key-value pair that defines a tag. The maximum length of a tag value is 256 characters. The minimum length is 0 characters. If you don't want an application to have a specific tag value, don't specify a value for this parameter.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application that you want to add one or more tags to.
        public let resourceARN: String
        /// A list of tags that to add to the application. A tag consists of a required tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the application that you want to remove one or more tags from.
        public let resourceARN: String
        /// The tags (tag keys) that you want to remove from the resource. When you specify a tag key, the action removes both that key and its associated tag value. To remove more than one tag from the application, append the TagKeys parameter and argument for each additional tag to remove, separated by an ampersand.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// If set to true, the managed policies for SSM and CW will be attached to the instance roles if they are missing.
        public let attachMissingPermission: Bool?
        ///  Turns auto-configuration on or off.
        public let autoConfigEnabled: Bool?
        ///  Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as instance terminated, failed deployment, and others.
        public let cweMonitorEnabled: Bool?
        ///  When set to true, creates opsItems for any problems detected on an application.
        public let opsCenterEnabled: Bool?
        ///  The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to receive notifications for updates to the opsItem.
        public let opsItemSNSTopicArn: String?
        ///  Disassociates the SNS topic from the opsItem created for detected problems.
        public let removeSNSTopic: Bool?
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(attachMissingPermission: Bool? = nil, autoConfigEnabled: Bool? = nil, cweMonitorEnabled: Bool? = nil, opsCenterEnabled: Bool? = nil, opsItemSNSTopicArn: String? = nil, removeSNSTopic: Bool? = nil, resourceGroupName: String) {
            self.attachMissingPermission = attachMissingPermission
            self.autoConfigEnabled = autoConfigEnabled
            self.cweMonitorEnabled = cweMonitorEnabled
            self.opsCenterEnabled = opsCenterEnabled
            self.opsItemSNSTopicArn = opsItemSNSTopicArn
            self.removeSNSTopic = removeSNSTopic
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.opsItemSNSTopicArn, name: "opsItemSNSTopicArn", parent: name, max: 300)
            try self.validate(self.opsItemSNSTopicArn, name: "opsItemSNSTopicArn", parent: name, min: 20)
            try self.validate(self.opsItemSNSTopicArn, name: "opsItemSNSTopicArn", parent: name, pattern: "^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case attachMissingPermission = "AttachMissingPermission"
            case autoConfigEnabled = "AutoConfigEnabled"
            case cweMonitorEnabled = "CWEMonitorEnabled"
            case opsCenterEnabled = "OpsCenterEnabled"
            case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
            case removeSNSTopic = "RemoveSNSTopic"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        /// Information about the application.
        public let applicationInfo: ApplicationInfo?

        public init(applicationInfo: ApplicationInfo? = nil) {
            self.applicationInfo = applicationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case applicationInfo = "ApplicationInfo"
        }
    }

    public struct UpdateComponentConfigurationRequest: AWSEncodableShape {
        ///  Automatically configures the component by applying the recommended configurations.
        public let autoConfigEnabled: Bool?
        /// The configuration settings of the component. The value is the escaped JSON of the configuration. For more information about the JSON format, see Working with JSON. You can send a request to DescribeComponentConfigurationRecommendation to see the recommended configuration for a component. For the complete format of the component configuration file, see Component Configuration.
        public let componentConfiguration: String?
        /// The name of the component.
        public let componentName: String
        /// Indicates whether the application component is monitored.
        public let monitor: Bool?
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The tier of the application component.
        public let tier: Tier?

        public init(autoConfigEnabled: Bool? = nil, componentConfiguration: String? = nil, componentName: String, monitor: Bool? = nil, resourceGroupName: String, tier: Tier? = nil) {
            self.autoConfigEnabled = autoConfigEnabled
            self.componentConfiguration = componentConfiguration
            self.componentName = componentName
            self.monitor = monitor
            self.resourceGroupName = resourceGroupName
            self.tier = tier
        }

        public func validate(name: String) throws {
            try self.validate(self.componentConfiguration, name: "componentConfiguration", parent: name, max: 10000)
            try self.validate(self.componentConfiguration, name: "componentConfiguration", parent: name, min: 1)
            try self.validate(self.componentConfiguration, name: "componentConfiguration", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case autoConfigEnabled = "AutoConfigEnabled"
            case componentConfiguration = "ComponentConfiguration"
            case componentName = "ComponentName"
            case monitor = "Monitor"
            case resourceGroupName = "ResourceGroupName"
            case tier = "Tier"
        }
    }

    public struct UpdateComponentConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateComponentRequest: AWSEncodableShape {
        /// The name of the component.
        public let componentName: String
        /// The new name of the component.
        public let newComponentName: String?
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The list of resource ARNs that belong to the component.
        public let resourceList: [String]?

        public init(componentName: String, newComponentName: String? = nil, resourceGroupName: String, resourceList: [String]? = nil) {
            self.componentName = componentName
            self.newComponentName = newComponentName
            self.resourceGroupName = resourceGroupName
            self.resourceList = resourceList
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 128)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[\\d\\w\\-_\\.+]*$")
            try self.validate(self.newComponentName, name: "newComponentName", parent: name, max: 128)
            try self.validate(self.newComponentName, name: "newComponentName", parent: name, min: 1)
            try self.validate(self.newComponentName, name: "newComponentName", parent: name, pattern: "^[\\d\\w\\-_\\.+]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.resourceList?.forEach {
                try validate($0, name: "resourceList[]", parent: name, max: 1011)
                try validate($0, name: "resourceList[]", parent: name, min: 1)
                try validate($0, name: "resourceList[]", parent: name, pattern: "^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case newComponentName = "NewComponentName"
            case resourceGroupName = "ResourceGroupName"
            case resourceList = "ResourceList"
        }
    }

    public struct UpdateComponentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLogPatternRequest: AWSEncodableShape {
        /// The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.
        public let pattern: String?
        /// The name of the log pattern.
        public let patternName: String
        /// The name of the log pattern set.
        public let patternSetName: String
        /// Rank of the log pattern. Must be a value between 1 and 1,000,000. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank 1 will be the first to get matched to a log line. A pattern of rank 1,000,000 will be last to get matched. When you configure custom log patterns from the console, a Low severity pattern translates to a 750,000 rank. A Medium severity pattern translates to a 500,000 rank. And a High severity pattern translates to a 250,000 rank. Rank values less than 1 or greater than 1,000,000 are reserved for AWS-provided patterns.
        public let rank: Int?
        /// The name of the resource group.
        public let resourceGroupName: String

        public init(pattern: String? = nil, patternName: String, patternSetName: String, rank: Int? = nil, resourceGroupName: String) {
            self.pattern = pattern
            self.patternName = patternName
            self.patternSetName = patternSetName
            self.rank = rank
            self.resourceGroupName = resourceGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.pattern, name: "pattern", parent: name, max: 50)
            try self.validate(self.pattern, name: "pattern", parent: name, min: 1)
            try self.validate(self.pattern, name: "pattern", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.patternName, name: "patternName", parent: name, max: 50)
            try self.validate(self.patternName, name: "patternName", parent: name, min: 1)
            try self.validate(self.patternName, name: "patternName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, max: 30)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, min: 1)
            try self.validate(self.patternSetName, name: "patternSetName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case pattern = "Pattern"
            case patternName = "PatternName"
            case patternSetName = "PatternSetName"
            case rank = "Rank"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct UpdateLogPatternResponse: AWSDecodableShape {
        /// The successfully created log pattern.
        public let logPattern: LogPattern?
        /// The name of the resource group.
        public let resourceGroupName: String?

        public init(logPattern: LogPattern? = nil, resourceGroupName: String? = nil) {
            self.logPattern = logPattern
            self.resourceGroupName = resourceGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logPattern = "LogPattern"
            case resourceGroupName = "ResourceGroupName"
        }
    }

    public struct UpdateProblemRequest: AWSEncodableShape {
        /// The ID of the problem.
        public let problemId: String
        /// The status of the problem. Arguments can be passed for only problems that show a status of RECOVERING.
        public let updateStatus: UpdateStatus?
        /// The visibility of a problem. When you pass a value of IGNORED, the problem is removed from the default view, and all notifications for the problem are suspended. When VISIBLE is passed, the IGNORED action is reversed.
        public let visibility: Visibility?

        public init(problemId: String, updateStatus: UpdateStatus? = nil, visibility: Visibility? = nil) {
            self.problemId = problemId
            self.updateStatus = updateStatus
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.problemId, name: "problemId", parent: name, max: 38)
            try self.validate(self.problemId, name: "problemId", parent: name, min: 38)
            try self.validate(self.problemId, name: "problemId", parent: name, pattern: "^p-[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case problemId = "ProblemId"
            case updateStatus = "UpdateStatus"
            case visibility = "Visibility"
        }
    }

    public struct UpdateProblemResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWorkloadRequest: AWSEncodableShape {
        ///  The name of the component.
        public let componentName: String
        /// The name of the resource group.
        public let resourceGroupName: String
        /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
        public let workloadConfiguration: WorkloadConfiguration
        /// The ID of the workload.
        public let workloadId: String?

        public init(componentName: String, resourceGroupName: String, workloadConfiguration: WorkloadConfiguration, workloadId: String? = nil) {
            self.componentName = componentName
            self.resourceGroupName = resourceGroupName
            self.workloadConfiguration = workloadConfiguration
            self.workloadId = workloadId
        }

        public func validate(name: String) throws {
            try self.validate(self.componentName, name: "componentName", parent: name, max: 1011)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^(?:^[\\d\\w\\-_\\.+]*$)|(?:^arn:aws(-\\w+)*:[\\w\\d-]+:([\\w\\d-]*)?:[\\w\\d_-]*([:/].+)*$)$")
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, max: 256)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, min: 1)
            try self.validate(self.resourceGroupName, name: "resourceGroupName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
            try self.workloadConfiguration.validate(name: "\(name).workloadConfiguration")
            try self.validate(self.workloadId, name: "workloadId", parent: name, max: 38)
            try self.validate(self.workloadId, name: "workloadId", parent: name, min: 38)
            try self.validate(self.workloadId, name: "workloadId", parent: name, pattern: "^w-[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case resourceGroupName = "ResourceGroupName"
            case workloadConfiguration = "WorkloadConfiguration"
            case workloadId = "WorkloadId"
        }
    }

    public struct UpdateWorkloadResponse: AWSDecodableShape {
        /// The configuration settings of the workload. The value is the escaped JSON of the configuration.
        public let workloadConfiguration: WorkloadConfiguration?
        /// The ID of the workload.
        public let workloadId: String?

        public init(workloadConfiguration: WorkloadConfiguration? = nil, workloadId: String? = nil) {
            self.workloadConfiguration = workloadConfiguration
            self.workloadId = workloadId
        }

        private enum CodingKeys: String, CodingKey {
            case workloadConfiguration = "WorkloadConfiguration"
            case workloadId = "WorkloadId"
        }
    }

    public struct Workload: AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        /// The tier of the workload.
        public let tier: Tier?
        /// The ID of the workload.
        public let workloadId: String?
        /// The name of the workload.
        public let workloadName: String?
        /// If logging is supported for the resource type, shows whether the component has configured logs to be monitored.
        public let workloadRemarks: String?

        public init(componentName: String? = nil, tier: Tier? = nil, workloadId: String? = nil, workloadName: String? = nil, workloadRemarks: String? = nil) {
            self.componentName = componentName
            self.tier = tier
            self.workloadId = workloadId
            self.workloadName = workloadName
            self.workloadRemarks = workloadRemarks
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case tier = "Tier"
            case workloadId = "WorkloadId"
            case workloadName = "WorkloadName"
            case workloadRemarks = "WorkloadRemarks"
        }
    }

    public struct WorkloadConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration settings of the workload.
        public let configuration: String?
        /// The configuration of the workload tier.
        public let tier: Tier?
        /// The name of the workload.
        public let workloadName: String?

        public init(configuration: String? = nil, tier: Tier? = nil, workloadName: String? = nil) {
            self.configuration = configuration
            self.tier = tier
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.configuration, name: "configuration", parent: name, max: 10000)
            try self.validate(self.configuration, name: "configuration", parent: name, min: 1)
            try self.validate(self.configuration, name: "configuration", parent: name, pattern: "^[\\S\\s]+$")
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 8)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[a-zA-Z0-9\\.\\-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case tier = "Tier"
            case workloadName = "WorkloadName"
        }
    }
}

// MARK: - Errors

/// Error enum for ApplicationInsights
public struct ApplicationInsightsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case internalServerException = "InternalServerException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case tagsAlreadyExistException = "TagsAlreadyExistException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ApplicationInsights
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  User does not have permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request is not understood by the server.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The server encountered an internal error and is unable to complete the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource is already created or in use.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The resource does not exist in the customer account.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Tags are already registered for the specified application ARN.
    public static var tagsAlreadyExistException: Self { .init(.tagsAlreadyExistException) }
    /// The number of the provided tags is beyond the limit, or the number of total tags you are trying to attach to the specified resource exceeds the limit.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The parameter is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension ApplicationInsightsErrorType: Equatable {
    public static func == (lhs: ApplicationInsightsErrorType, rhs: ApplicationInsightsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ApplicationInsightsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
