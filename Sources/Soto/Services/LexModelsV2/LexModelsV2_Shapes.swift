//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension LexModelsV2 {
    // MARK: Enums

    public enum BotAliasStatus: String, CustomStringConvertible, Codable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public enum BotFilterName: String, CustomStringConvertible, Codable {
        case botname = "BotName"
        public var description: String { return self.rawValue }
    }

    public enum BotFilterOperator: String, CustomStringConvertible, Codable {
        case co = "CO"
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleFilterName: String, CustomStringConvertible, Codable {
        case botlocalename = "BotLocaleName"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleFilterOperator: String, CustomStringConvertible, Codable {
        case co = "CO"
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleSortAttribute: String, CustomStringConvertible, Codable {
        case botlocalename = "BotLocaleName"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleStatus: String, CustomStringConvertible, Codable {
        case building = "Building"
        case built = "Built"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case notbuilt = "NotBuilt"
        case readyexpresstesting = "ReadyExpressTesting"
        public var description: String { return self.rawValue }
    }

    public enum BotSortAttribute: String, CustomStringConvertible, Codable {
        case botname = "BotName"
        public var description: String { return self.rawValue }
    }

    public enum BotStatus: String, CustomStringConvertible, Codable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case inactive = "Inactive"
        case versioning = "Versioning"
        public var description: String { return self.rawValue }
    }

    public enum BotVersionSortAttribute: String, CustomStringConvertible, Codable {
        case botversion = "BotVersion"
        public var description: String { return self.rawValue }
    }

    public enum BuiltInIntentSortAttribute: String, CustomStringConvertible, Codable {
        case intentsignature = "IntentSignature"
        public var description: String { return self.rawValue }
    }

    public enum BuiltInSlotTypeSortAttribute: String, CustomStringConvertible, Codable {
        case slottypesignature = "SlotTypeSignature"
        public var description: String { return self.rawValue }
    }

    public enum IntentFilterName: String, CustomStringConvertible, Codable {
        case intentname = "IntentName"
        public var description: String { return self.rawValue }
    }

    public enum IntentFilterOperator: String, CustomStringConvertible, Codable {
        case co = "CO"
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum IntentSortAttribute: String, CustomStringConvertible, Codable {
        case intentname = "IntentName"
        case lastupdateddatetime = "LastUpdatedDateTime"
        public var description: String { return self.rawValue }
    }

    public enum ObfuscationSettingType: String, CustomStringConvertible, Codable {
        case defaultobfuscation = "DefaultObfuscation"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum SlotConstraint: String, CustomStringConvertible, Codable {
        case optional = "Optional"
        case required = "Required"
        public var description: String { return self.rawValue }
    }

    public enum SlotFilterName: String, CustomStringConvertible, Codable {
        case slotname = "SlotName"
        public var description: String { return self.rawValue }
    }

    public enum SlotFilterOperator: String, CustomStringConvertible, Codable {
        case co = "CO"
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum SlotSortAttribute: String, CustomStringConvertible, Codable {
        case lastupdateddatetime = "LastUpdatedDateTime"
        case slotname = "SlotName"
        public var description: String { return self.rawValue }
    }

    public enum SlotTypeFilterName: String, CustomStringConvertible, Codable {
        case slottypename = "SlotTypeName"
        public var description: String { return self.rawValue }
    }

    public enum SlotTypeFilterOperator: String, CustomStringConvertible, Codable {
        case co = "CO"
        case eq = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum SlotTypeSortAttribute: String, CustomStringConvertible, Codable {
        case lastupdateddatetime = "LastUpdatedDateTime"
        case slottypename = "SlotTypeName"
        public var description: String { return self.rawValue }
    }

    public enum SlotValueResolutionStrategy: String, CustomStringConvertible, Codable {
        case originalvalue = "OriginalValue"
        case topresolution = "TopResolution"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AudioLogDestination: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon S3 bucket where the audio log files are stored. The IAM role specified in the roleArn parameter of the CreateBot operation must have permission to write to this bucket.
        public let s3Bucket: S3BucketLogDestination

        public init(s3Bucket: S3BucketLogDestination) {
            self.s3Bucket = s3Bucket
        }

        public func validate(name: String) throws {
            try self.s3Bucket.validate(name: "\(name).s3Bucket")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
        }
    }

    public struct AudioLogSetting: AWSEncodableShape & AWSDecodableShape {

        public let destination: AudioLogDestination
        /// Determines whether audio logging in enabled for the bot.
        public let enabled: Bool

        public init(destination: AudioLogDestination, enabled: Bool) {
            self.destination = destination
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case enabled = "enabled"
        }
    }

    public struct BotAliasHistoryEvent: AWSDecodableShape {

        /// The version of the bot that was used in the event.
        public let botVersion: String?
        /// The date and time that the event ended.
        public let endDate: Date?
        /// The date and time that the event started.
        public let startDate: Date?

        public init(botVersion: String? = nil, endDate: Date? = nil, startDate: Date? = nil) {
            self.botVersion = botVersion
            self.endDate = endDate
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case botVersion = "botVersion"
            case endDate = "endDate"
            case startDate = "startDate"
        }
    }

    public struct BotAliasLocaleSettings: AWSEncodableShape & AWSDecodableShape {

        /// Specifies the Lambda function that should be used in the locale.
        public let codeHookSpecification: CodeHookSpecification?
        /// Determines whether the locale is enabled for the bot. If the value is false, the locale isn't available for use.
        public let enabled: Bool

        public init(codeHookSpecification: CodeHookSpecification? = nil, enabled: Bool) {
            self.codeHookSpecification = codeHookSpecification
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.codeHookSpecification?.validate(name: "\(name).codeHookSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case codeHookSpecification = "codeHookSpecification"
            case enabled = "enabled"
        }
    }

    public struct BotAliasSummary: AWSDecodableShape {

        /// The unique identifier assigned to the bot alias. You can use this ID to get detailed information about the alias using the DescribeBotAlias operation.
        public let botAliasId: String?
        /// The name of the bot alias.
        public let botAliasName: String?
        /// The current state of the bot alias. If the status is Available, the alias is ready for use.
        public let botAliasStatus: BotAliasStatus?
        /// The version of the bot that the bot alias references.
        public let botVersion: String?
        /// A timestamp of the date and time that the bot alias was created.
        public let creationDateTime: Date?
        /// The description of the bot alias.
        public let description: String?
        /// A timestamp of the date and time that the bot alias was last updated.
        public let lastUpdatedDateTime: Date?

        public init(botAliasId: String? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil) {
            self.botAliasId = botAliasId
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
        }
    }

    public struct BotFilter: AWSEncodableShape {

        /// The name of the field to filter the list of bots.
        public let name: BotFilterName
        /// The operator to use for the filter. Specify EQ when the ListBots operation should return only aliases that equal the specified value. Specify CO when the ListBots operation should return aliases that contain the specified value.
        public let `operator`: BotFilterOperator
        /// The value to use for filtering the list of bots.
        public let values: [String]

        public init(name: BotFilterName, operator: BotFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct BotLocaleFilter: AWSEncodableShape {

        /// The name of the field to filter the list of bots.
        public let name: BotLocaleFilterName
        /// The operator to use for the filter. Specify EQ when the ListBotLocales operation should return only aliases that equal the specified value. Specify CO when the ListBotLocales operation should return aliases that contain the specified value.
        public let `operator`: BotLocaleFilterOperator
        /// The value to use for filtering the list of bots.
        public let values: [String]

        public init(name: BotLocaleFilterName, operator: BotLocaleFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct BotLocaleHistoryEvent: AWSDecodableShape {

        /// A description of the event that occurred.
        public let event: String
        /// A timestamp of the date and time that the event occurred.
        public let eventDate: Date

        public init(event: String, eventDate: Date) {
            self.event = event
            self.eventDate = eventDate
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case eventDate = "eventDate"
        }
    }

    public struct BotLocaleSortBy: AWSEncodableShape {

        /// The bot locale attribute to sort by.
        public let attribute: BotLocaleSortAttribute
        /// Specifies whether to sort the bot locales in ascending or descending order.
        public let order: SortOrder

        public init(attribute: BotLocaleSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BotLocaleSummary: AWSDecodableShape {

        /// The current status of the bot locale. When the status is Built the locale is ready for use.
        public let botLocaleStatus: BotLocaleStatus?
        /// The description of the bot locale.
        public let description: String?
        /// A timestamp of the date and time that the bot locale was last built.
        public let lastBuildSubmittedDateTime: Date?
        /// A timestamp of the date and time that the bot locale was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale of the bot locale.
        public let localeId: String?
        /// The name of the bot locale.
        public let localeName: String?

        public init(botLocaleStatus: BotLocaleStatus? = nil, description: String? = nil, lastBuildSubmittedDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, localeName: String? = nil) {
            self.botLocaleStatus = botLocaleStatus
            self.description = description
            self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.localeName = localeName
        }

        private enum CodingKeys: String, CodingKey {
            case botLocaleStatus = "botLocaleStatus"
            case description = "description"
            case lastBuildSubmittedDateTime = "lastBuildSubmittedDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case localeName = "localeName"
        }
    }

    public struct BotSortBy: AWSEncodableShape {

        /// The attribute to use to sort the list of bots.
        public let attribute: BotSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        public init(attribute: BotSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BotSummary: AWSDecodableShape {

        /// The unique identifier assigned to the bot. Use this ID to get detailed information about the bot with the DescribeBot operation.
        public let botId: String?
        /// The name of the bot.
        public let botName: String?
        /// The current status of the bot. When the status is Available the bot is ready for use.
        public let botStatus: BotStatus?
        /// The description of the bot.
        public let description: String?
        /// The date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The latest numerical version in use for the bot.
        public let latestBotVersion: String?

        public init(botId: String? = nil, botName: String? = nil, botStatus: BotStatus? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, latestBotVersion: String? = nil) {
            self.botId = botId
            self.botName = botName
            self.botStatus = botStatus
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestBotVersion = latestBotVersion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botName = "botName"
            case botStatus = "botStatus"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestBotVersion = "latestBotVersion"
        }
    }

    public struct BotVersionLocaleDetails: AWSEncodableShape & AWSDecodableShape {

        /// The version of a bot used for a bot locale.
        public let sourceBotVersion: String

        public init(sourceBotVersion: String) {
            self.sourceBotVersion = sourceBotVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceBotVersion, name: "sourceBotVersion", parent: name, max: 5)
            try self.validate(self.sourceBotVersion, name: "sourceBotVersion", parent: name, min: 1)
            try self.validate(self.sourceBotVersion, name: "sourceBotVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceBotVersion = "sourceBotVersion"
        }
    }

    public struct BotVersionSortBy: AWSEncodableShape {

        /// The attribute to use to sort the list of versions.
        public let attribute: BotVersionSortAttribute
        /// The order to sort the list. You can specify ascending or descending order.
        public let order: SortOrder

        public init(attribute: BotVersionSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BotVersionSummary: AWSDecodableShape {

        /// The name of the bot associated with the version.
        public let botName: String?
        /// The status of the bot. When the status is available, the version of the bot is ready for use.
        public let botStatus: BotStatus?
        /// The numeric version of the bot, or DRAFT to indicate that this is the version of the bot that can be updated..
        public let botVersion: String?
        /// A timestamp of the date and time that the version was created.
        public let creationDateTime: Date?
        /// The description of the version.
        public let description: String?

        public init(botName: String? = nil, botStatus: BotStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil) {
            self.botName = botName
            self.botStatus = botStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case botName = "botName"
            case botStatus = "botStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
        }
    }

    public struct BuildBotLocaleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot to build. The identifier is returned in the response from the operation.
        public let botId: String
        /// The version of the bot to build. This can only be the draft version of the bot.
        public let botVersion: String
        /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String

        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct BuildBotLocaleResponse: AWSDecodableShape {

        /// The identifier of the specified bot.
        public let botId: String?
        /// The bot's build status. When the status is ReadyExpressTesting you can test the bot using the utterances defined for the intents and slot types. When the status is Built, the bot is ready for use and can be tested using any utterance.
        public let botLocaleStatus: BotLocaleStatus?
        /// The version of the bot that was built. This is only the draft version of the bot.
        public let botVersion: String?
        /// A timestamp indicating the date and time that the bot was last built for this locale.
        public let lastBuildSubmittedDateTime: Date?
        /// The language and locale specified of where the bot can be used.
        public let localeId: String?

        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, lastBuildSubmittedDateTime: Date? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case lastBuildSubmittedDateTime = "lastBuildSubmittedDateTime"
            case localeId = "localeId"
        }
    }

    public struct BuiltInIntentSortBy: AWSEncodableShape {

        /// The attribute to use to sort the list of built-in intents.
        public let attribute: BuiltInIntentSortAttribute
        /// The order to sort the list. You can specify ascending or descending order.
        public let order: SortOrder

        public init(attribute: BuiltInIntentSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BuiltInIntentSummary: AWSDecodableShape {

        /// The description of the intent.
        public let description: String?
        /// The signature of the built-in intent. Use this to specify the parent intent of a derived intent.
        public let intentSignature: String?

        public init(description: String? = nil, intentSignature: String? = nil) {
            self.description = description
            self.intentSignature = intentSignature
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case intentSignature = "intentSignature"
        }
    }

    public struct BuiltInSlotTypeSortBy: AWSEncodableShape {

        /// The attribute to use to sort the list of built-in intents.
        public let attribute: BuiltInSlotTypeSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        public init(attribute: BuiltInSlotTypeSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BuiltInSlotTypeSummary: AWSDecodableShape {

        /// The description of the built-in slot type.
        public let description: String?
        /// The signature of the built-in slot type. Use this to specify the parent slot type of a derived slot type.
        public let slotTypeSignature: String?

        public init(description: String? = nil, slotTypeSignature: String? = nil) {
            self.description = description
            self.slotTypeSignature = slotTypeSignature
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case slotTypeSignature = "slotTypeSignature"
        }
    }

    public struct Button: AWSEncodableShape & AWSDecodableShape {

        /// The text that appears on the button. Use this to tell the user what value is returned when they choose this button.
        public let text: String
        /// The value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
        public let value: String

        public init(text: String, value: String) {
            self.text = text
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 50)
            try self.validate(self.text, name: "text", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 50)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case value = "value"
        }
    }

    public struct CloudWatchLogGroupLogDestination: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the log group where text and metadata logs are delivered.
        public let cloudWatchLogGroupArn: String
        /// The prefix of the log stream name within the log group that you specified
        public let logPrefix: String

        public init(cloudWatchLogGroupArn: String, logPrefix: String) {
            self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
            self.logPrefix = logPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupArn, name: "cloudWatchLogGroupArn", parent: name, max: 2048)
            try self.validate(self.cloudWatchLogGroupArn, name: "cloudWatchLogGroupArn", parent: name, min: 1)
            try self.validate(self.cloudWatchLogGroupArn, name: "cloudWatchLogGroupArn", parent: name, pattern: "^arn:[\\w\\-]+:logs:[\\w\\-]+:[\\d]{12}:log-group:[\\.\\-_/#A-Za-z0-9]{1,512}(?::\\*)?$")
            try self.validate(self.logPrefix, name: "logPrefix", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogGroupArn = "cloudWatchLogGroupArn"
            case logPrefix = "logPrefix"
        }
    }

    public struct CodeHookSpecification: AWSEncodableShape & AWSDecodableShape {

        public let lambdaCodeHook: LambdaCodeHook

        public init(lambdaCodeHook: LambdaCodeHook) {
            self.lambdaCodeHook = lambdaCodeHook
        }

        public func validate(name: String) throws {
            try self.lambdaCodeHook.validate(name: "\(name).lambdaCodeHook")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaCodeHook = "lambdaCodeHook"
        }
    }

    public struct ConversationLogSettings: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon S3 settings for logging audio to an S3 bucket.
        public let audioLogSettings: [AudioLogSetting]?
        /// The Amazon CloudWatch Logs settings for logging text and metadata.
        public let textLogSettings: [TextLogSetting]?

        public init(audioLogSettings: [AudioLogSetting]? = nil, textLogSettings: [TextLogSetting]? = nil) {
            self.audioLogSettings = audioLogSettings
            self.textLogSettings = textLogSettings
        }

        public func validate(name: String) throws {
            try self.audioLogSettings?.forEach {
                try $0.validate(name: "\(name).audioLogSettings[]")
            }
            try self.validate(self.audioLogSettings, name: "audioLogSettings", parent: name, max: 1)
            try self.validate(self.audioLogSettings, name: "audioLogSettings", parent: name, min: 1)
            try self.textLogSettings?.forEach {
                try $0.validate(name: "\(name).textLogSettings[]")
            }
            try self.validate(self.textLogSettings, name: "textLogSettings", parent: name, max: 1)
            try self.validate(self.textLogSettings, name: "textLogSettings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audioLogSettings = "audioLogSettings"
            case textLogSettings = "textLogSettings"
        }
    }

    public struct CreateBotAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// Maps configuration information to a specific locale. You can use this parameter to specify a specific Lambda function to run different functions in different locales.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The alias to create. The name must be unique for the bot.
        public let botAliasName: String
        /// The unique identifier of the bot that the alias applies to.
        public let botId: String
        /// The version of the bot that this alias points to. You can use the operation to change the bot version associated with the alias.
        public let botVersion: String?
        /// Specifies whether Amazon Lex logs text and audio for a conversation with the bot. When you enable conversation logs, text logs store text input, transcripts of audio input, and associated metadata in Amazon CloudWatch Logs. Audio logs store audio input in Amazon S3.
        public let conversationLogSettings: ConversationLogSettings?
        /// A description of the alias. Use this description to help identify the alias.
        public let description: String?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?
        /// A list of tags to add to the bot alias. You can only add tags when you create an alias, you can't use the UpdateBotAlias operation to update the tags on a bot alias. To update tags, use the TagResource operation.
        public let tags: [String: String]?

        public init(botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String, botId: String, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, description: String? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil, tags: [String: String]? = nil) {
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.description = description
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.botAliasLocaleSettings?.forEach {
                try $0.value.validate(name: "\(name).botAliasLocaleSettings[\"\($0.key)\"]")
            }
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, max: 100)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, min: 1)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^[0-9]+$")
            try self.conversationLogSettings?.validate(name: "\(name).conversationLogSettings")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case description = "description"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
            case tags = "tags"
        }
    }

    public struct CreateBotAliasResponse: AWSDecodableShape {

        /// The unique identifier of the bot alias.
        public let botAliasId: String?
        /// Configuration information for a specific locale.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The name specified for the bot alias.
        public let botAliasName: String?
        /// The current status of the alias. The alias is first put into the Creating state. When the alias is ready to be used, it is put into the Available state. You can use the DescribeBotAlias operation to get the current state of an alias.
        public let botAliasStatus: BotAliasStatus?
        /// The unique identifier of the bot that this alias applies to.
        public let botId: String?
        /// The version of the bot associated with this alias.
        public let botVersion: String?
        /// The conversation log settings specified for the alias.
        public let conversationLogSettings: ConversationLogSettings?
        /// A Unix timestamp indicating the date and time that the bot alias was created.
        public let creationDateTime: Date?
        /// The description specified for the bot alias.
        public let description: String?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?
        /// A list of tags associated with the bot alias.
        public let tags: [String: String]?

        public init(botAliasId: String? = nil, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, creationDateTime: Date? = nil, description: String? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil, tags: [String: String]? = nil) {
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.creationDateTime = creationDateTime
            self.description = description
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
            case tags = "tags"
        }
    }

    public struct CreateBotLocaleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion"))
        ]

        /// The identifier of the bot to create the locale for.
        public let botId: String
        /// The version of the bot to create the locale for. This can only be the draft version of the bot.
        public let botVersion: String
        /// A description of the bot locale. Use this to help identify the bot locale in lists.
        public let description: String?
        /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// Determines the threshold where Amazon Lex will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot. For example, suppose a bot is configured with the confidence threshold of 0.80 and the AMAZON.FallbackIntent. Amazon Lex returns three alternative intents with the following confidence scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the PostText operation would be:   AMAZON.FallbackIntent   IntentA   IntentB   IntentC
        public let nluIntentConfidenceThreshold: Double
        /// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        public init(botId: String, botVersion: String, description: String? = nil, localeId: String, nluIntentConfidenceThreshold: Double, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.localeId = localeId
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, max: 1)
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case localeId = "localeId"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct CreateBotLocaleResponse: AWSDecodableShape {

        /// The specified bot identifier.
        public let botId: String?
        /// The status of the bot. When the status is Creating the bot locale is being configured. When the status is Building Amazon Lex is building the bot for testing and use. If the status of the bot is ReadyExpressTesting, you can test the bot using the exact utterances specified in the bots' intents. When the bot is ready for full testing or to run, the status is Built. If there was a problem with building the bot, the status is Failed. If the bot was saved but not built, the status is NotBuilt.
        public let botLocaleStatus: BotLocaleStatus?
        /// The specified bot version.
        public let botVersion: String?
        /// A timestamp specifying the date and time that the bot locale was created.
        public let creationDateTime: Date?
        /// The specified description of the bot locale.
        public let description: String?
        /// The specified locale identifier.
        public let localeId: String?
        /// The specified locale name.
        public let localeName: String?
        /// The specified confidence threshold for inserting the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents.
        public let nluIntentConfidenceThreshold: Double?
        /// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, localeId: String? = nil, localeName: String? = nil, nluIntentConfidenceThreshold: Double? = nil, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.localeId = localeId
            self.localeName = localeName
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case localeId = "localeId"
            case localeName = "localeName"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct CreateBotRequest: AWSEncodableShape {

        /// The name of the bot. The bot name must be unique in the account that creates the bot.
        public let botName: String
        /// A list of tags to add to the bot. You can only add tags when you create a bot. You can't use the UpdateBot operation to update tags. To update tags, use the TagResource operation.
        public let botTags: [String: String]?
        /// Provides information on additional privacy protections Amazon Lex should use with the bot's data.
        public let dataPrivacy: DataPrivacy
        /// A description of the bot. It appears in lists to help you identify a particular bot.
        public let description: String?
        /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot.  A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
        public let idleSessionTTLInSeconds: Int
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot.
        public let roleArn: String
        /// A list of tags to add to the test alias for a bot. You can only add tags when you create a bot. You can't use the UpdateAlias operation to update tags. To update tags on the test alias, use the TagResource operation.
        public let testBotAliasTags: [String: String]?

        public init(botName: String, botTags: [String: String]? = nil, dataPrivacy: DataPrivacy, description: String? = nil, idleSessionTTLInSeconds: Int, roleArn: String, testBotAliasTags: [String: String]? = nil) {
            self.botName = botName
            self.botTags = botTags
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
            self.testBotAliasTags = testBotAliasTags
        }

        public func validate(name: String) throws {
            try self.validate(self.botName, name: "botName", parent: name, max: 100)
            try self.validate(self.botName, name: "botName", parent: name, min: 1)
            try self.validate(self.botName, name: "botName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.botTags?.forEach {
                try validate($0.key, name: "botTags.key", parent: name, max: 128)
                try validate($0.key, name: "botTags.key", parent: name, min: 1)
                try validate($0.value, name: "botTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "botTags[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 86400)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/.*$")
            try self.testBotAliasTags?.forEach {
                try validate($0.key, name: "testBotAliasTags.key", parent: name, max: 128)
                try validate($0.key, name: "testBotAliasTags.key", parent: name, min: 1)
                try validate($0.value, name: "testBotAliasTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "testBotAliasTags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case botName = "botName"
            case botTags = "botTags"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
            case testBotAliasTags = "testBotAliasTags"
        }
    }

    public struct CreateBotResponse: AWSDecodableShape {

        /// A unique identifier for a particular bot. You use this to identify the bot when you call other Amazon Lex API operations.
        public let botId: String?
        /// The name specified for the bot.
        public let botName: String?
        /// Shows the current status of the bot. The bot is first in the Creating status. Once the bot is read for use, it changes to the Available status. After the bot is created, you can use the Draft version of the bot.
        public let botStatus: BotStatus?
        /// A list of tags associated with the bot.
        public let botTags: [String: String]?
        /// A timestamp indicating the date and time that the bot was created.
        public let creationDateTime: Date?
        /// The data privacy settings specified for the bot.
        public let dataPrivacy: DataPrivacy?
        /// The description specified for the bot.
        public let description: String?
        /// The session idle time specified for the bot.
        public let idleSessionTTLInSeconds: Int?
        /// The IAM role specified for the bot.
        public let roleArn: String?
        /// A list of tags associated with the test alias for the bot.
        public let testBotAliasTags: [String: String]?

        public init(botId: String? = nil, botName: String? = nil, botStatus: BotStatus? = nil, botTags: [String: String]? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, idleSessionTTLInSeconds: Int? = nil, roleArn: String? = nil, testBotAliasTags: [String: String]? = nil) {
            self.botId = botId
            self.botName = botName
            self.botStatus = botStatus
            self.botTags = botTags
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
            self.testBotAliasTags = testBotAliasTags
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botName = "botName"
            case botStatus = "botStatus"
            case botTags = "botTags"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
            case testBotAliasTags = "testBotAliasTags"
        }
    }

    public struct CreateBotVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// The identifier of the bot to create the version for.
        public let botId: String
        /// Specifies the locales that Amazon Lex adds to this version. You can choose the Draft version or any other previously published version for each locale. When you specify a source version, the locale data is copied from the source version to the new version.
        public let botVersionLocaleSpecification: [String: BotVersionLocaleDetails]
        /// A description of the version. Use the description to help identify the version in lists.
        public let description: String?

        public init(botId: String, botVersionLocaleSpecification: [String: BotVersionLocaleDetails], description: String? = nil) {
            self.botId = botId
            self.botVersionLocaleSpecification = botVersionLocaleSpecification
            self.description = description
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.botVersionLocaleSpecification.forEach {
                try $0.value.validate(name: "\(name).botVersionLocaleSpecification[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case botVersionLocaleSpecification = "botVersionLocaleSpecification"
            case description = "description"
        }
    }

    public struct CreateBotVersionResponse: AWSDecodableShape {

        /// The bot identifier specified in the request.
        public let botId: String?
        /// When you send a request to create or update a bot, Amazon Lex sets the status response element to Creating. After Amazon Lex builds the bot, it sets status to Available. If Amazon Lex can't build the bot, it sets status to Failed.
        public let botStatus: BotStatus?
        /// The version number assigned to the version.
        public let botVersion: String?
        /// The source versions used for each locale in the new version.
        public let botVersionLocaleSpecification: [String: BotVersionLocaleDetails]?
        /// A timestamp of the date and time that the version was created.
        public let creationDateTime: Date?
        /// The description of the version specified in the request.
        public let description: String?

        public init(botId: String? = nil, botStatus: BotStatus? = nil, botVersion: String? = nil, botVersionLocaleSpecification: [String: BotVersionLocaleDetails]? = nil, creationDateTime: Date? = nil, description: String? = nil) {
            self.botId = botId
            self.botStatus = botStatus
            self.botVersion = botVersion
            self.botVersionLocaleSpecification = botVersionLocaleSpecification
            self.creationDateTime = creationDateTime
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botStatus = "botStatus"
            case botVersion = "botVersion"
            case botVersionLocaleSpecification = "botVersionLocaleSpecification"
            case creationDateTime = "creationDateTime"
            case description = "description"
        }
    }

    public struct CreateIntentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot associated with this intent.
        public let botId: String
        /// The identifier of the version of the bot associated with this intent.
        public let botVersion: String
        /// A description of the intent. Use the description to help identify the intent in lists.
        public let description: String?
        /// Specifies that Amazon Lex invokes the alias Lambda function for each user input. You can invoke this Lambda function to personalize user interaction. For example, suppose that your bot determines that the user's name is John. You Lambda function might retrieve John's information from a backend database and prepopulate some of the values. For example, if you find that John is gluten intolerant, you might set the corresponding intent slot, glutenIntolerant to true. You might find John's phone number and set the corresponding session attribute.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// Specifies that Amazon Lex invokes the alias Lambda function when the intent is ready for fulfillment. You can invoke this function to complete the bot's transaction with the user. For example, in a pizza ordering bot, the Lambda function can look up the closest pizza restaurant to the customer's location and then place an order on the customer's behalf.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// A list of contexts that must be active for this intent to be considered by Amazon Lex. When an intent has an input context list, Amazon Lex only considers using the intent in an interaction with the user when the specified contexts are included in the active context list for the session. If the contexts are not active, then Amazon Lex will not use the intent. A context can be automatically activated using the outputContexts property or it can be set at runtime.  For example, if there are two intents with different input contexts that respond to the same utterances, only the intent with the active context will respond. An intent may have up to 5 input contexts. If an intent has multiple input contexts, all of the contexts must be active to consider the intent.
        public let inputContexts: [InputContext]?
        /// Sets the response that Amazon Lex sends to the user when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// Provides prompts that Amazon Lex sends to the user to confirm the completion of an intent. If the user answers "no," the settings contain a statement that is sent to the user to end the intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The name of the intent. Intent names must be unique in the locale that contains the intent and cannot match the name of any built-in intent.
        public let intentName: String
        /// Configuration information required to use the AMAZON.KendraSearchIntent intent to connect to an Amazon Kendra index. The AMAZON.KendraSearchIntent intent is called when Amazon Lex can't determine another intent to invoke.
        public let kendraConfiguration: KendraConfiguration?
        /// The identifier of the language and locale where this intent is used. All of the bots, slot types, and slots used by the intent must have the same locale.
        public let localeId: String
        /// A lists of contexts that the intent activates when it is fulfilled. You can use an output context to indicate the intents that Amazon Lex should consider for the next turn of the conversation with a customer.  When you use the outputContextsList property, all of the contexts specified in the list are activated when the intent is fulfilled. You can set up to 10 output contexts. You can also set the number of conversation turns that the context should be active, or the length of time that the context should be active.
        public let outputContexts: [OutputContext]?
        /// A unique identifier for the built-in intent to base this intent on.
        public let parentIntentSignature: String?
        /// An array of strings that a user might say to signal the intent. For example, "I want a pizza", or "I want a {PizzaSize} pizza".  In an utterance, slot names are enclosed in curly braces ("{", "}") to indicate where they should be displayed in the utterance shown to the user..
        public let sampleUtterances: [SampleUtterance]?

        public init(botId: String, botVersion: String, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentName: String, kendraConfiguration: KendraConfiguration? = nil, localeId: String, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, sampleUtterances: [SampleUtterance]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.sampleUtterances = sampleUtterances
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.inputContexts?.forEach {
                try $0.validate(name: "\(name).inputContexts[]")
            }
            try self.validate(self.inputContexts, name: "inputContexts", parent: name, max: 5)
            try self.validate(self.inputContexts, name: "inputContexts", parent: name, min: 0)
            try self.intentClosingSetting?.validate(name: "\(name).intentClosingSetting")
            try self.intentConfirmationSetting?.validate(name: "\(name).intentConfirmationSetting")
            try self.validate(self.intentName, name: "intentName", parent: name, max: 100)
            try self.validate(self.intentName, name: "intentName", parent: name, min: 1)
            try self.validate(self.intentName, name: "intentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.kendraConfiguration?.validate(name: "\(name).kendraConfiguration")
            try self.outputContexts?.forEach {
                try $0.validate(name: "\(name).outputContexts[]")
            }
            try self.validate(self.outputContexts, name: "outputContexts", parent: name, max: 10)
            try self.validate(self.outputContexts, name: "outputContexts", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case sampleUtterances = "sampleUtterances"
        }
    }

    public struct CreateIntentResponse: AWSDecodableShape {

        /// The identifier of the bot associated with the intent.
        public let botId: String?
        /// The identifier of the version of the bot associated with the intent.
        public let botVersion: String?
        /// A timestamp of the date and time that the intent was created.
        public let creationDateTime: Date?
        /// The description specified for the intent.
        public let description: String?
        /// The dialog Lambda function specified for the intent.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The fulfillment Lambda function specified for the intent.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// The list of input contexts specified for the intent.
        public let inputContexts: [InputContext]?
        /// The closing setting specified for the intent.
        public let intentClosingSetting: IntentClosingSetting?
        /// The confirmation setting specified for the intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// A unique identifier for the intent.
        public let intentId: String?
        /// The name specified for the intent.
        public let intentName: String?
        /// Configuration for searching a Amazon Kendra index specified for the intent.
        public let kendraConfiguration: KendraConfiguration?
        /// The locale that the intent is specified to use.
        public let localeId: String?
        /// The list of output contexts specified for the intent.
        public let outputContexts: [OutputContext]?
        /// The signature of the parent intent specified for the intent.
        public let parentIntentSignature: String?
        /// The sample utterances specified for the intent.
        public let sampleUtterances: [SampleUtterance]?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String? = nil, intentName: String? = nil, kendraConfiguration: KendraConfiguration? = nil, localeId: String? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, sampleUtterances: [SampleUtterance]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.sampleUtterances = sampleUtterances
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentId = "intentId"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case localeId = "localeId"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case sampleUtterances = "sampleUtterances"
        }
    }

    public struct CreateSlotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot associated with the slot.
        public let botId: String
        /// The version of the bot associated with the slot.
        public let botVersion: String
        /// A description of the slot. Use this to help identify the slot in lists.
        public let description: String?
        /// The identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale that the slot will be used in. The string must match one of the supported locales. All of the bots, intents, slot types used by the slot must have the same locale. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// Determines how slot values are used in Amazon CloudWatch logs. If the value of the obfuscationSetting parameter is DefaultObfuscation, slot values are obfuscated in the log output. If the value is None, the actual value is present in the log output. The default is to obfuscate values in the CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The name of the slot. Slot names must be unique within the bot that contains the slot.
        public let slotName: String
        /// The unique identifier for the slot type associated with this slot. The slot type determines the values that can be entered into the slot.
        public let slotTypeId: String
        /// Specifies prompts that Amazon Lex sends to the user to elicit a response that provides the value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting

        public init(botId: String, botVersion: String, description: String? = nil, intentId: String, localeId: String, obfuscationSetting: ObfuscationSetting? = nil, slotName: String, slotTypeId: String, valueElicitationSetting: SlotValueElicitationSetting) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.intentId = intentId
            self.localeId = localeId
            self.obfuscationSetting = obfuscationSetting
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationSetting = valueElicitationSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotName, name: "slotName", parent: name, max: 100)
            try self.validate(self.slotName, name: "slotName", parent: name, min: 1)
            try self.validate(self.slotName, name: "slotName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 25)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 1)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^((AMAZON\\.)[a-zA-Z_]+?|[0-9a-zA-Z]+)$")
            try self.valueElicitationSetting.validate(name: "\(name).valueElicitationSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case obfuscationSetting = "obfuscationSetting"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct CreateSlotResponse: AWSDecodableShape {

        /// The unique identifier of the bot associated with the slot.
        public let botId: String?
        /// The version of the bot associated with the slot.
        public let botVersion: String?
        /// The timestamp of the date and time that the slot was created.
        public let creationDateTime: Date?
        /// The description associated with the slot.
        public let description: String?
        /// The unique identifier of the intent associated with the slot.
        public let intentId: String?
        /// The language and local specified for the slot.
        public let localeId: String?
        /// Indicates whether the slot is configured to obfuscate values in Amazon CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier associated with the slot. Use this to identify the slot when you update or delete it.
        public let slotId: String?
        /// The name specified for the slot.
        public let slotName: String?
        /// The unique identifier of the slot type associated with this slot.
        public let slotTypeId: String?
        /// The value elicitation settings specified for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, intentId: String? = nil, localeId: String? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, valueElicitationSetting: SlotValueElicitationSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.intentId = intentId
            self.localeId = localeId
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationSetting = valueElicitationSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case intentId = "intentId"
            case localeId = "localeId"
            case obfuscationSetting = "obfuscationSetting"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct CreateSlotTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot associated with this slot type.
        public let botId: String
        /// The identifier of the bot version associated with this slot type.
        public let botVersion: String
        /// A description of the slot type. Use the description to help identify the slot type in lists.
        public let description: String?
        /// The identifier of the language and locale that the slot type will be used in. The string must match one of the supported locales. All of the bots, intents, and slots used by the slot type must have the same locale. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The built-in slot type used as a parent of this slot type. When you define a parent slot type, the new slot type has the configuration of the parent slot type. Only AMAZON.AlphaNumeric is supported.
        public let parentSlotTypeSignature: String?
        /// The name for the slot. A slot type name must be unique within the account.
        public let slotTypeName: String
        /// A list of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for a slot.
        public let slotTypeValues: [SlotTypeValue]?
        /// Determines the strategy that Amazon Lex uses to select a value from the list of possible values. The field can be set to one of the following values:    OriginalValue - Returns the value entered by the user, if the user value is similar to the slot value.    TopResolution - If there is a resolution list for the slot, return the first value in the resolution list. If there is no resolution list, return null.   If you don't specify the valueSelectionSetting parameter, the default is OriginalValue.
        public let valueSelectionSetting: SlotValueSelectionSetting

        public init(botId: String, botVersion: String, description: String? = nil, localeId: String, parentSlotTypeSignature: String? = nil, slotTypeName: String, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, max: 100)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, min: 1)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.slotTypeValues?.forEach {
                try $0.validate(name: "\(name).slotTypeValues[]")
            }
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, max: 10000)
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, min: 1)
            try self.valueSelectionSetting.validate(name: "\(name).valueSelectionSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct CreateSlotTypeResponse: AWSDecodableShape {

        /// The identifier for the bot associated with the slot type.
        public let botId: String?
        /// The version of the bot associated with the slot type.
        public let botVersion: String?
        /// A timestamp of the date and time that the slot type was created.
        public let creationDateTime: Date?
        /// The description specified for the slot type.
        public let description: String?
        /// The specified language and local specified for the slot type.
        public let localeId: String?
        /// The signature of the base slot type specified for the slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier assigned to the slot type. Use this to identify the slot type in the UpdateSlotType and DeleteSlotType operations.
        public let slotTypeId: String?
        /// The name specified for the slot type.
        public let slotTypeName: String?
        /// The list of values that the slot type can assume.
        public let slotTypeValues: [SlotTypeValue]?
        /// The strategy that Amazon Lex uses to select a value from the list of possible values.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, localeId: String? = nil, parentSlotTypeSignature: String? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case localeId = "localeId"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct CustomPayload: AWSEncodableShape & AWSDecodableShape {

        /// The string that is sent to your application.
        public let value: String

        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct DataPrivacy: AWSEncodableShape & AWSDecodableShape {

        /// For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying true or false in the childDirected field. By specifying true in the childDirected field, you confirm that your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. By specifying false in the childDirected field, you confirm that your use of Amazon Lex is not related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. You may not specify a default value for the childDirected field that does not accurately reflect whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. If your use of Amazon Lex relates to a website, program, or other application that is directed in whole or in part, to children under age 13, you must obtain any required verifiable parental consent under COPPA. For information regarding the use of Amazon Lex in connection with websites, programs, or other applications that are directed or targeted, in whole or in part, to children under age 13, see the Amazon Lex FAQ.
        public let childDirected: Bool

        public init(childDirected: Bool) {
            self.childDirected = childDirected
        }

        private enum CodingKeys: String, CodingKey {
            case childDirected = "childDirected"
        }
    }

    public struct DeleteBotAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botAliasId", location: .uri(locationName: "botAliasId")), 
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "skipResourceInUseCheck", location: .querystring(locationName: "skipResourceInUseCheck"))
        ]

        /// The unique identifier of the bot alias to delete.
        public let botAliasId: String
        /// The unique identifier of the bot associated with the alias to delete.
        public let botId: String
        /// When this parameter is true, Amazon Lex doesn't check to see if any other resource is using the alias before it is deleted.
        public let skipResourceInUseCheck: Bool?

        public init(botAliasId: String, botId: String, skipResourceInUseCheck: Bool? = nil) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotAliasResponse: AWSDecodableShape {

        /// The unique identifier of the bot alias to delete.
        public let botAliasId: String?
        /// The current status of the alias. The status is Deleting while the alias is in the process of being deleted. Once the alias is deleted, it will no longer appear in the list of aliases returned by the ListBotAliases operation.
        public let botAliasStatus: BotAliasStatus?
        /// The unique identifier of the bot that contains the alias to delete.
        public let botId: String?

        public init(botAliasId: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil) {
            self.botAliasId = botAliasId
            self.botAliasStatus = botAliasStatus
            self.botId = botId
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
        }
    }

    public struct DeleteBotLocaleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The unique identifier of the bot that contains the locale.
        public let botId: String
        /// The version of the bot that contains the locale.
        public let botVersion: String
        /// The identifier of the language and locale that will be deleted. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String

        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotLocaleResponse: AWSDecodableShape {

        /// The identifier of the bot that contained the deleted locale.
        public let botId: String?
        /// The status of deleting the bot locale. The locale first enters the Deleting status. Once the locale is deleted it no longer appears in the list of locales for the bot.
        public let botLocaleStatus: BotLocaleStatus?
        /// The version of the bot that contained the deleted locale.
        public let botVersion: String?
        /// The language and locale of the deleted locale.
        public let localeId: String?

        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case localeId = "localeId"
        }
    }

    public struct DeleteBotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "skipResourceInUseCheck", location: .querystring(locationName: "skipResourceInUseCheck"))
        ]

        /// The identifier of the bot to delete.
        public let botId: String
        /// When true, Amazon Lex doesn't check to see if another resource, such as an alias, is using the bot before it is deleted.
        public let skipResourceInUseCheck: Bool?

        public init(botId: String, skipResourceInUseCheck: Bool? = nil) {
            self.botId = botId
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotResponse: AWSDecodableShape {

        /// The unique identifier of the bot that Amazon Lex is deleting.
        public let botId: String?
        /// The current status of the bot. The status is Deleting while the bot and its associated resources are being deleted.
        public let botStatus: BotStatus?

        public init(botId: String? = nil, botStatus: BotStatus? = nil) {
            self.botId = botId
            self.botStatus = botStatus
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botStatus = "botStatus"
        }
    }

    public struct DeleteBotVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "skipResourceInUseCheck", location: .querystring(locationName: "skipResourceInUseCheck"))
        ]

        /// The identifier of the bot that contains the version.
        public let botId: String
        /// The version of the bot to delete.
        public let botVersion: String
        /// By default, the DeleteBotVersion operations throws a ResourceInUseException exception if you try to delete a bot version that has an alias pointing at it. Set the skipResourceInUseCheck parameter to true to skip this check and remove the version even if an alias points to it.
        public let skipResourceInUseCheck: Bool?

        public init(botId: String, botVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotVersionResponse: AWSDecodableShape {

        /// The identifier of the bot that is being deleted.
        public let botId: String?
        /// The current status of the bot.
        public let botStatus: BotStatus?
        /// The version of the bot that is being deleted.
        public let botVersion: String?

        public init(botId: String? = nil, botStatus: BotStatus? = nil, botVersion: String? = nil) {
            self.botId = botId
            self.botStatus = botStatus
            self.botVersion = botVersion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botStatus = "botStatus"
            case botVersion = "botVersion"
        }
    }

    public struct DeleteIntentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot associated with the intent.
        public let botId: String
        /// The version of the bot associated with the intent.
        public let botVersion: String
        /// The unique identifier of the intent to delete.
        public let intentId: String
        /// The identifier of the language and locale where the bot will be deleted. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String

        public init(botId: String, botVersion: String, intentId: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSlotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId")), 
            AWSMemberEncoding(label: "slotId", location: .uri(locationName: "slotId"))
        ]

        /// The identifier of the bot associated with the slot to delete.
        public let botId: String
        /// The version of the bot associated with the slot to delete.
        public let botVersion: String
        /// The identifier of the intent associated with the slot.
        public let intentId: String
        /// The identifier of the language and locale that the slot will be deleted from. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The identifier of the slot to delete.
        public let slotId: String

        public init(botId: String, botVersion: String, intentId: String, localeId: String, slotId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
            self.slotId = slotId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSlotTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId")), 
            AWSMemberEncoding(label: "skipResourceInUseCheck", location: .querystring(locationName: "skipResourceInUseCheck")), 
            AWSMemberEncoding(label: "slotTypeId", location: .uri(locationName: "slotTypeId"))
        ]

        /// The identifier of the bot associated with the slot type.
        public let botId: String
        /// The version of the bot associated with the slot type.
        public let botVersion: String
        /// The identifier of the language and locale that the slot type will be deleted from. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// By default, the DeleteSlotType operations throws a ResourceInUseException exception if you try to delete a slot type used by a slot. Set the skipResourceInUseCheck parameter to true to skip this check and remove the slot type even if a slot uses it.
        public let skipResourceInUseCheck: Bool?
        /// The identifier of the slot type to delete.
        public let slotTypeId: String

        public init(botId: String, botVersion: String, localeId: String, skipResourceInUseCheck: Bool? = nil, slotTypeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.skipResourceInUseCheck = skipResourceInUseCheck
            self.slotTypeId = slotTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botAliasId", location: .uri(locationName: "botAliasId")), 
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// The identifier of the bot alias to describe.
        public let botAliasId: String
        /// The identifier of the bot associated with the bot alias to describe.
        public let botId: String

        public init(botAliasId: String, botId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotAliasResponse: AWSDecodableShape {

        /// A list of events that affect a bot alias. For example, an event is recorded when the version that the alias points to changes.
        public let botAliasHistoryEvents: [BotAliasHistoryEvent]?
        /// The identifier of the bot alias.
        public let botAliasId: String?
        /// The locale settings that are unique to the alias.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The name of the bot alias.
        public let botAliasName: String?
        /// The current status of the alias. When the alias is Available, the alias is ready for use with your bot.
        public let botAliasStatus: BotAliasStatus?
        /// The identifier of the bot associated with the bot alias.
        public let botId: String?
        /// The version of the bot associated with the bot alias.
        public let botVersion: String?
        /// Specifics of how Amazon Lex logs text and audio conversations with the bot associated with the alias.
        public let conversationLogSettings: ConversationLogSettings?
        /// A timestamp of the date and time that the alias was created.
        public let creationDateTime: Date?
        /// The description of the bot alias.
        public let description: String?
        /// A timestamp of the date and time that the alias was last updated.
        public let lastUpdatedDateTime: Date?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?

        public init(botAliasHistoryEvents: [BotAliasHistoryEvent]? = nil, botAliasId: String? = nil, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil) {
            self.botAliasHistoryEvents = botAliasHistoryEvents
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasHistoryEvents = "botAliasHistoryEvents"
            case botAliasId = "botAliasId"
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
        }
    }

    public struct DescribeBotLocaleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot associated with the locale.
        public let botId: String
        /// The identifier of the version of the bot associated with the locale.
        public let botVersion: String
        /// The unique identifier of the locale to describe. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String

        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotLocaleResponse: AWSDecodableShape {

        /// The identifier of the bot associated with the locale.
        public let botId: String?
        /// History of changes, such as when a locale is used in an alias, that have taken place for the locale.
        public let botLocaleHistoryEvents: [BotLocaleHistoryEvent]?
        /// The status of the bot. If the status is Failed, the reasons for the failure are listed in the failureReasons field.
        public let botLocaleStatus: BotLocaleStatus?
        /// The identifier of the version of the bot associated with the locale.
        public let botVersion: String?
        /// The date and time that the locale was created.
        public let creationDateTime: Date?
        /// The description of the locale.
        public let description: String?
        /// if botLocaleStatus is Failed, Amazon Lex explains why it failed to build the bot.
        public let failureReasons: [String]?
        /// The number of intents defined for the locale.
        public let intentsCount: Int?
        /// The date and time that the locale was last submitted for building.
        public let lastBuildSubmittedDateTime: Date?
        /// The date and time that the locale was last updated.
        public let lastUpdatedDateTime: Date?
        /// The unique identifier of the described locale.
        public let localeId: String?
        /// The name of the locale.
        public let localeName: String?
        /// The confidence threshold where Amazon Lex inserts the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
        public let nluIntentConfidenceThreshold: Double?
        /// The number of slot types defined for the locale.
        public let slotTypesCount: Int?
        /// The Amazon Polly voice Amazon Lex uses for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        public init(botId: String? = nil, botLocaleHistoryEvents: [BotLocaleHistoryEvent]? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, failureReasons: [String]? = nil, intentsCount: Int? = nil, lastBuildSubmittedDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, localeName: String? = nil, nluIntentConfidenceThreshold: Double? = nil, slotTypesCount: Int? = nil, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botLocaleHistoryEvents = botLocaleHistoryEvents
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.failureReasons = failureReasons
            self.intentsCount = intentsCount
            self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.localeName = localeName
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.slotTypesCount = slotTypesCount
            self.voiceSettings = voiceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleHistoryEvents = "botLocaleHistoryEvents"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case failureReasons = "failureReasons"
            case intentsCount = "intentsCount"
            case lastBuildSubmittedDateTime = "lastBuildSubmittedDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case localeName = "localeName"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case slotTypesCount = "slotTypesCount"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct DescribeBotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// The unique identifier of the bot to describe.
        public let botId: String

        public init(botId: String) {
            self.botId = botId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotResponse: AWSDecodableShape {

        /// The unique identifier of the bot.
        public let botId: String?
        /// The name of the bot.
        public let botName: String?
        /// The current status of the bot. When the status is Available the bot is ready to be used in conversations with users.
        public let botStatus: BotStatus?
        /// A timestamp of the date and time that the bot was created.
        public let creationDateTime: Date?
        /// Settings for managing data privacy of the bot and its conversations with users.
        public let dataPrivacy: DataPrivacy?
        /// The description of the bot.
        public let description: String?
        /// The maximum time in seconds that Amazon Lex retains the data gathered in a conversation.
        public let idleSessionTTLInSeconds: Int?
        /// A timestamp of the date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot.
        public let roleArn: String?

        public init(botId: String? = nil, botName: String? = nil, botStatus: BotStatus? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, idleSessionTTLInSeconds: Int? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil) {
            self.botId = botId
            self.botName = botName
            self.botStatus = botStatus
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botName = "botName"
            case botStatus = "botStatus"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
        }
    }

    public struct DescribeBotVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion"))
        ]

        /// The identifier of the bot containing the version to return metadata for.
        public let botId: String
        /// The version of the bot to return metadata for.
        public let botVersion: String

        public init(botId: String, botVersion: String) {
            self.botId = botId
            self.botVersion = botVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotVersionResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the version.
        public let botId: String?
        /// The name of the bot that contains the version.
        public let botName: String?
        /// The current status of the bot. When the status is Available, the bot version is ready for use.
        public let botStatus: BotStatus?
        /// The version of the bot to describe.
        public let botVersion: String?
        /// A timestamp of the date and time that the bot version was created.
        public let creationDateTime: Date?
        /// Data privacy settings for the bot version.
        public let dataPrivacy: DataPrivacy?
        /// The description specified for the bot.
        public let description: String?
        /// If the botStatus is Failed, this contains a list of reasons that the version couldn't be built.
        public let failureReasons: [String]?
        /// The number of seconds that a session with the bot remains active before it is discarded by Amazon Lex.
        public let idleSessionTTLInSeconds: Int?
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot version.
        public let roleArn: String?

        public init(botId: String? = nil, botName: String? = nil, botStatus: BotStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, failureReasons: [String]? = nil, idleSessionTTLInSeconds: Int? = nil, roleArn: String? = nil) {
            self.botId = botId
            self.botName = botName
            self.botStatus = botStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.failureReasons = failureReasons
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botName = "botName"
            case botStatus = "botStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case failureReasons = "failureReasons"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
        }
    }

    public struct DescribeIntentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot associated with the intent.
        public let botId: String
        /// The version of the bot associated with the intent.
        public let botVersion: String
        /// The identifier of the intent to describe.
        public let intentId: String
        /// The identifier of the language and locale of the intent to describe. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String

        public init(botId: String, botVersion: String, intentId: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIntentResponse: AWSDecodableShape {

        /// The identifier of the bot associated with the intent.
        public let botId: String?
        /// The version of the bot associated with the intent.
        public let botVersion: String?
        /// A timestamp of the date and time that the intent was created.
        public let creationDateTime: Date?
        /// The description of the intent.
        public let description: String?
        /// The Lambda function called during each turn of a conversation with the intent.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The Lambda function called when the intent is complete and ready for fulfillment.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// A list of contexts that must be active for the intent to be considered for sending to the user.
        public let inputContexts: [InputContext]?
        /// The response that Amazon Lex sends to when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// Prompts that Amazon Lex sends to the user to confirm completion of an intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The unique identifier assigned to the intent when it was created.
        public let intentId: String?
        /// The name specified for the intent.
        public let intentName: String?
        /// Configuration information required to use the AMAZON.KendraSearchIntent intent.
        public let kendraConfiguration: KendraConfiguration?
        /// A timestamp of the date and time that the intent was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale specified for the intent.
        public let localeId: String?
        /// A list of contexts that are activated when the intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// The identifier of the built-in intent that this intent is derived from, if any.
        public let parentIntentSignature: String?
        /// User utterances that trigger this intent.
        public let sampleUtterances: [SampleUtterance]?
        /// The list that determines the priority that slots should be elicited from the user.
        public let slotPriorities: [SlotPriority]?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String? = nil, intentName: String? = nil, kendraConfiguration: KendraConfiguration? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, sampleUtterances: [SampleUtterance]? = nil, slotPriorities: [SlotPriority]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.sampleUtterances = sampleUtterances
            self.slotPriorities = slotPriorities
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentId = "intentId"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case sampleUtterances = "sampleUtterances"
            case slotPriorities = "slotPriorities"
        }
    }

    public struct DescribeSlotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId")), 
            AWSMemberEncoding(label: "slotId", location: .uri(locationName: "slotId"))
        ]

        /// The identifier of the bot associated with the slot.
        public let botId: String
        /// The version of the bot associated with the slot.
        public let botVersion: String
        /// The identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale of the slot to describe. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The unique identifier for the slot.
        public let slotId: String

        public init(botId: String, botVersion: String, intentId: String, localeId: String, slotId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
            self.slotId = slotId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSlotResponse: AWSDecodableShape {

        /// The identifier of the bot associated with the slot.
        public let botId: String?
        /// The version of the bot associated with the slot.
        public let botVersion: String?
        /// A timestamp of the date and time that the slot was created.
        public let creationDateTime: Date?
        /// The description specified for the slot.
        public let description: String?
        /// The identifier of the intent associated with the slot.
        public let intentId: String?
        /// A timestamp of the date and time that the slot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale specified for the slot.
        public let localeId: String?
        /// Whether slot values are shown in Amazon CloudWatch logs. If the value is None, the actual value of the slot is shown in logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier generated for the slot.
        public let slotId: String?
        /// The name specified for the slot.
        public let slotName: String?
        /// The identifier of the slot type that determines the values entered into the slot.
        public let slotTypeId: String?
        /// Prompts that Amazon Lex uses to elicit a value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, intentId: String? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, valueElicitationSetting: SlotValueElicitationSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.intentId = intentId
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationSetting = valueElicitationSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case intentId = "intentId"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case obfuscationSetting = "obfuscationSetting"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct DescribeSlotTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId")), 
            AWSMemberEncoding(label: "slotTypeId", location: .uri(locationName: "slotTypeId"))
        ]

        /// The identifier of the bot associated with the slot type.
        public let botId: String
        /// The version of the bot associated with the slot type.
        public let botVersion: String
        /// The identifier of the language and locale of the slot type to describe. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The identifier of the slot type.
        public let slotTypeId: String

        public init(botId: String, botVersion: String, localeId: String, slotTypeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.slotTypeId = slotTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSlotTypeResponse: AWSDecodableShape {

        /// The identifier of the bot associated with the slot type.
        public let botId: String?
        /// The version of the bot associated with the slot type.
        public let botVersion: String?
        /// A timestamp of the date and time that the slot type was created.
        public let creationDateTime: Date?
        /// The description specified for the slot type.
        public let description: String?
        /// A timestamp of the date and time that the slot type was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale specified for the slot type.
        public let localeId: String?
        /// The built in slot type used as a parent to this slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier for the slot type.
        public let slotTypeId: String?
        /// The name specified for the slot type.
        public let slotTypeName: String?
        /// The values that the slot type can take. Includes any synonyms for the slot type values.
        public let slotTypeValues: [SlotTypeValue]?
        /// The strategy that Amazon Lex uses to choose a value from a list of possible values.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, parentSlotTypeSignature: String? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct DialogCodeHookSettings: AWSEncodableShape & AWSDecodableShape {

        /// Enables the dialog code hook so that it processes user requests.
        public let enabled: Bool

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct FulfillmentCodeHookSettings: AWSEncodableShape & AWSDecodableShape {

        /// Indicates whether a Lambda function should be invoked to fulfill a specific intent.
        public let enabled: Bool

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct ImageResponseCard: AWSEncodableShape & AWSDecodableShape {

        /// A list of buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button.
        public let buttons: [Button]?
        /// The URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
        public let imageUrl: String?
        /// The subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
        public let subtitle: String?
        /// The title to display on the response card. The format of the title is determined by the platform displaying the response card.
        public let title: String

        public init(buttons: [Button]? = nil, imageUrl: String? = nil, subtitle: String? = nil, title: String) {
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subtitle = subtitle
            self.title = title
        }

        public func validate(name: String) throws {
            try self.buttons?.forEach {
                try $0.validate(name: "\(name).buttons[]")
            }
            try self.validate(self.buttons, name: "buttons", parent: name, max: 5)
            try self.validate(self.buttons, name: "buttons", parent: name, min: 0)
            try self.validate(self.imageUrl, name: "imageUrl", parent: name, max: 250)
            try self.validate(self.imageUrl, name: "imageUrl", parent: name, min: 1)
            try self.validate(self.subtitle, name: "subtitle", parent: name, max: 250)
            try self.validate(self.subtitle, name: "subtitle", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 250)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case buttons = "buttons"
            case imageUrl = "imageUrl"
            case subtitle = "subtitle"
            case title = "title"
        }
    }

    public struct InputContext: AWSEncodableShape & AWSDecodableShape {

        /// The name of the context.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct IntentClosingSetting: AWSEncodableShape & AWSDecodableShape {

        /// The response that Amazon Lex sends to the user when the intent is complete.
        public let closingResponse: ResponseSpecification

        public init(closingResponse: ResponseSpecification) {
            self.closingResponse = closingResponse
        }

        public func validate(name: String) throws {
            try self.closingResponse.validate(name: "\(name).closingResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case closingResponse = "closingResponse"
        }
    }

    public struct IntentConfirmationSetting: AWSEncodableShape & AWSDecodableShape {

        /// When the user answers "no" to the question defined in promptSpecification, Amazon Lex responds with this response to acknowledge that the intent was canceled.
        public let declinationResponse: ResponseSpecification
        /// Prompts the user to confirm the intent. This question should have a yes or no answer. Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the OrderPizza intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information.
        public let promptSpecification: PromptSpecification

        public init(declinationResponse: ResponseSpecification, promptSpecification: PromptSpecification) {
            self.declinationResponse = declinationResponse
            self.promptSpecification = promptSpecification
        }

        public func validate(name: String) throws {
            try self.declinationResponse.validate(name: "\(name).declinationResponse")
            try self.promptSpecification.validate(name: "\(name).promptSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case declinationResponse = "declinationResponse"
            case promptSpecification = "promptSpecification"
        }
    }

    public struct IntentFilter: AWSEncodableShape {

        /// The name of the field to use for the filter.
        public let name: IntentFilterName
        /// The operator to use for the filter. Specify EQ when the ListIntents operation should return only aliases that equal the specified value. Specify CO when the ListIntents operation should return aliases that contain the specified value.
        public let `operator`: IntentFilterOperator
        /// The value to use for the filter.
        public let values: [String]

        public init(name: IntentFilterName, operator: IntentFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct IntentSortBy: AWSEncodableShape {

        /// The attribute to use to sort the list of intents.
        public let attribute: IntentSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        public init(attribute: IntentSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct IntentSummary: AWSDecodableShape {

        /// The description of the intent.
        public let description: String?
        /// The input contexts that must be active for this intent to be considered for recognition.
        public let inputContexts: [InputContext]?
        /// The unique identifier assigned to the intent. Use this ID to get detailed information about the intent with the DescribeIntent operation.
        public let intentId: String?
        /// The name of the intent.
        public let intentName: String?
        /// The timestamp of the date and time that the intent was last updated.
        public let lastUpdatedDateTime: Date?
        /// The output contexts that are activated when this intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// If this intent is derived from a built-in intent, the name of the parent intent.
        public let parentIntentSignature: String?

        public init(description: String? = nil, inputContexts: [InputContext]? = nil, intentId: String? = nil, intentName: String? = nil, lastUpdatedDateTime: Date? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil) {
            self.description = description
            self.inputContexts = inputContexts
            self.intentId = intentId
            self.intentName = intentName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputContexts = "inputContexts"
            case intentId = "intentId"
            case intentName = "intentName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
        }
    }

    public struct KendraConfiguration: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the AMAZON.KendraSearchIntent intent to search. The index must be in the same account and Region as the Amazon Lex bot.
        public let kendraIndex: String
        /// A query filter that Amazon Lex sends to Amazon Kendra to filter the response from a query. The filter is in the format defined by Amazon Kendra. For more information, see Filtering queries.
        public let queryFilterString: String?
        /// Determines whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
        public let queryFilterStringEnabled: Bool?

        public init(kendraIndex: String, queryFilterString: String? = nil, queryFilterStringEnabled: Bool? = nil) {
            self.kendraIndex = kendraIndex
            self.queryFilterString = queryFilterString
            self.queryFilterStringEnabled = queryFilterStringEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, max: 2048)
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, min: 32)
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, pattern: "^arn:aws:kendra:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:index\\/[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.queryFilterString, name: "queryFilterString", parent: name, max: 5000)
            try self.validate(self.queryFilterString, name: "queryFilterString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kendraIndex = "kendraIndex"
            case queryFilterString = "queryFilterString"
            case queryFilterStringEnabled = "queryFilterStringEnabled"
        }
    }

    public struct LambdaCodeHook: AWSEncodableShape & AWSDecodableShape {

        /// The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        public let codeHookInterfaceVersion: String
        /// The Amazon Resource Name (ARN) of the Lambda function.
        public let lambdaARN: String

        public init(codeHookInterfaceVersion: String, lambdaARN: String) {
            self.codeHookInterfaceVersion = codeHookInterfaceVersion
            self.lambdaARN = lambdaARN
        }

        public func validate(name: String) throws {
            try self.validate(self.codeHookInterfaceVersion, name: "codeHookInterfaceVersion", parent: name, max: 5)
            try self.validate(self.codeHookInterfaceVersion, name: "codeHookInterfaceVersion", parent: name, min: 1)
            try self.validate(self.lambdaARN, name: "lambdaARN", parent: name, max: 2048)
            try self.validate(self.lambdaARN, name: "lambdaARN", parent: name, min: 20)
            try self.validate(self.lambdaARN, name: "lambdaARN", parent: name, pattern: "arn:aws:lambda:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:function:[a-zA-Z0-9-_]+(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?(:[a-zA-Z0-9-_]+)?")
        }

        private enum CodingKeys: String, CodingKey {
            case codeHookInterfaceVersion = "codeHookInterfaceVersion"
            case lambdaARN = "lambdaARN"
        }
    }

    public struct ListBotAliasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// The identifier of the bot to list aliases for.
        public let botId: String
        /// The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBotAliases operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?

        public init(botId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotAliasesResponse: AWSDecodableShape {

        /// Summary information for the bot aliases that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more aliases available, the nextToken field contains a token to get the next page of results.
        public let botAliasSummaries: [BotAliasSummary]?
        /// The identifier of the bot associated with the aliases.
        public let botId: String?
        /// A token that indicates whether there are more results to return in a response to the ListBotAliases operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
        public let nextToken: String?

        public init(botAliasSummaries: [BotAliasSummary]? = nil, botId: String? = nil, nextToken: String? = nil) {
            self.botAliasSummaries = botAliasSummaries
            self.botId = botId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasSummaries = "botAliasSummaries"
            case botId = "botId"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotLocalesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion"))
        ]

        /// The identifier of the bot to list locales for.
        public let botId: String
        /// The version of the bot to list locales for.
        public let botVersion: String
        /// Provides the specification for a filter used to limit the response to only those locales that match the filter specification. You can only specify one filter and one value to filter on.
        public let filters: [BotLocaleFilter]?
        /// The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBotLocales operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token as the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of locales. You can sort by locale name in ascending or descending order.
        public let sortBy: BotLocaleSortBy?

        public init(botId: String, botVersion: String, filters: [BotLocaleFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BotLocaleSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotLocalesResponse: AWSDecodableShape {

        /// The identifier of the bot to list locales for.
        public let botId: String?
        /// Summary information for the locales that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more locales available, the nextToken field contains a token to get the next page of results.
        public let botLocaleSummaries: [BotLocaleSummary]?
        /// The version of the bot.
        public let botVersion: String?
        /// A token that indicates whether there are more results to return in a response to the ListBotLocales operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotLocales operation request to get the next page of results.
        public let nextToken: String?

        public init(botId: String? = nil, botLocaleSummaries: [BotLocaleSummary]? = nil, botVersion: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botLocaleSummaries = botLocaleSummaries
            self.botVersion = botVersion
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleSummaries = "botLocaleSummaries"
            case botVersion = "botVersion"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// The identifier of the bot to list versions for.
        public let botId: String
        /// The maximum number of versions to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response to the ListBotVersion operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of versions. You can specify that the list be sorted by version name in either ascending or descending order.
        public let sortBy: BotVersionSortBy?

        public init(botId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BotVersionSortBy? = nil) {
            self.botId = botId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotVersionsResponse: AWSDecodableShape {

        /// The identifier of the bot to list versions for.
        public let botId: String?
        /// Summary information for the bot versions that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more versions available, the nextToken field contains a token to get the next page of results.
        public let botVersionSummaries: [BotVersionSummary]?
        /// A token that indicates whether there are more results to return in a response to the ListBotVersions operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
        public let nextToken: String?

        public init(botId: String? = nil, botVersionSummaries: [BotVersionSummary]? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersionSummaries = botVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersionSummaries = "botVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotsRequest: AWSEncodableShape {

        /// Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
        public let filters: [BotFilter]?
        /// The maximum number of bots to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBots operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of bots. You can specify that the list be sorted by bot name in ascending or descending order.
        public let sortBy: BotSortBy?

        public init(filters: [BotFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BotSortBy? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotsResponse: AWSDecodableShape {

        /// Summary information for the bots that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more bots available, the nextToken field contains a token to the next page of results.
        public let botSummaries: [BotSummary]?
        /// A token that indicates whether there are more results to return in a response to the ListBots operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBots operation request to get the next page of results.
        public let nextToken: String?

        public init(botSummaries: [BotSummary]? = nil, nextToken: String? = nil) {
            self.botSummaries = botSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botSummaries = "botSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBuiltInIntentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The maximum number of built-in intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBuiltInIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of built-in intents. You can specify that the list be sorted by the built-in intent signature in either ascending or descending order.
        public let sortBy: BuiltInIntentSortBy?

        public init(localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BuiltInIntentSortBy? = nil) {
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBuiltInIntentsResponse: AWSDecodableShape {

        /// Summary information for the built-in intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
        public let builtInIntentSummaries: [BuiltInIntentSummary]?
        /// The language and locale of the intents in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListBuiltInIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
        public let nextToken: String?

        public init(builtInIntentSummaries: [BuiltInIntentSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.builtInIntentSummaries = builtInIntentSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case builtInIntentSummaries = "builtInIntentSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListBuiltInSlotTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The maximum number of built-in slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBuiltInSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListBuiltInSlotTypes operation. You can choose to sort by the slot type signature in either ascending or descending order.
        public let sortBy: BuiltInSlotTypeSortBy?

        public init(localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BuiltInSlotTypeSortBy? = nil) {
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBuiltInSlotTypesResponse: AWSDecodableShape {

        /// Summary information for the built-in slot types that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slot types available, the nextToken field contains a token to get the next page of results.
        public let builtInSlotTypeSummaries: [BuiltInSlotTypeSummary]?
        /// The language and locale of the slot types in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListBuiltInSlotTypes operation. If the nextToken field is present, you send the contents as the nextToken parameter of a LIstBuiltInSlotTypes operation request to get the next page of results.
        public let nextToken: String?

        public init(builtInSlotTypeSummaries: [BuiltInSlotTypeSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.builtInSlotTypeSummaries = builtInSlotTypeSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case builtInSlotTypeSummaries = "builtInSlotTypeSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListIntentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The unique identifier of the bot that contains the intent.
        public let botId: String
        /// The version of the bot that contains the intent.
        public let botVersion: String
        /// Provides the specification of a filter used to limit the intents in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
        public let filters: [IntentFilter]?
        /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The maximum number of intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListIntents operation. You can choose to sort by the intent name or last updated date in either ascending or descending order.
        public let sortBy: IntentSortBy?

        public init(botId: String, botVersion: String, filters: [IntentFilter]? = nil, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: IntentSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListIntentsResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the intent.
        public let botId: String?
        /// The version of the bot that contains the intent.
        public let botVersion: String?
        /// Summary information for the intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
        public let intentSummaries: [IntentSummary]?
        /// The language and locale of the intents in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListIntents operation request to get the next page of results.
        public let nextToken: String?

        public init(botId: String? = nil, botVersion: String? = nil, intentSummaries: [IntentSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentSummaries = intentSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case intentSummaries = "intentSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListSlotTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The unique identifier of the bot that contains the slot types.
        public let botId: String
        /// The version of the bot that contains the slot type.
        public let botVersion: String
        /// Provides the specification of a filter used to limit the slot types in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
        public let filters: [SlotTypeFilter]?
        /// The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The maximum number of slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListSlotTypes operation. You can choose to sort by the slot type name or last updated date in either ascending or descending order.
        public let sortBy: SlotTypeSortBy?

        public init(botId: String, botVersion: String, filters: [SlotTypeFilter]? = nil, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SlotTypeSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListSlotTypesResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the slot types.
        public let botId: String?
        /// The version of the bot that contains the slot types.
        public let botVersion: String?
        /// The language and local of the slot types in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListSlotTypes operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListSlotTypes operation request to get the next page of results.
        public let nextToken: String?
        /// Summary information for the slot types that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slot types available, the nextToken field contains a token to get the next page of results.
        public let slotTypeSummaries: [SlotTypeSummary]?

        public init(botId: String? = nil, botVersion: String? = nil, localeId: String? = nil, nextToken: String? = nil, slotTypeSummaries: [SlotTypeSummary]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.nextToken = nextToken
            self.slotTypeSummaries = slotTypeSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case localeId = "localeId"
            case nextToken = "nextToken"
            case slotTypeSummaries = "slotTypeSummaries"
        }
    }

    public struct ListSlotsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot that contains the slot.
        public let botId: String
        /// The version of the bot that contains the slot.
        public let botVersion: String
        /// Provides the specification of a filter used to limit the slots in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
        public let filters: [SlotFilter]?
        /// The unique identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale of the slots to list. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The maximum number of slots to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListSlots operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListSlots operation. You can choose to sort by the slot name or last updated date in either ascending or descending order.
        public let sortBy: SlotSortBy?

        public init(botId: String, botVersion: String, filters: [SlotFilter]? = nil, intentId: String, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SlotSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.intentId = intentId
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListSlotsResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the slots.
        public let botId: String?
        /// The version of the bot that contains the slots.
        public let botVersion: String?
        /// The identifier of the intent that contains the slots.
        public let intentId: String?
        /// The language and locale of the slots in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListSlots operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListSlots operation request to get the next page of results.
        public let nextToken: String?
        /// Summary information for the slots that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slots available, the nextToken field contains a token to get the next page of results.
        public let slotSummaries: [SlotSummary]?

        public init(botId: String? = nil, botVersion: String? = nil, intentId: String? = nil, localeId: String? = nil, nextToken: String? = nil, slotSummaries: [SlotSummary]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
            self.nextToken = nextToken
            self.slotSummaries = slotSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case intentId = "intentId"
            case localeId = "localeId"
            case nextToken = "nextToken"
            case slotSummaries = "slotSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceARN", location: .uri(locationName: "resourceARN"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to get a list of tags for.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        /// The tags associated with a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Message: AWSEncodableShape & AWSDecodableShape {

        /// A message in a custom format defined by the client application.
        public let customPayload: CustomPayload?
        /// A message that defines a response card that the client application can show to the user.
        public let imageResponseCard: ImageResponseCard?
        /// A message in plain text format.
        public let plainTextMessage: PlainTextMessage?
        /// A message in Speech Synthesis Markup Language (SSML).
        public let ssmlMessage: SSMLMessage?

        public init(customPayload: CustomPayload? = nil, imageResponseCard: ImageResponseCard? = nil, plainTextMessage: PlainTextMessage? = nil, ssmlMessage: SSMLMessage? = nil) {
            self.customPayload = customPayload
            self.imageResponseCard = imageResponseCard
            self.plainTextMessage = plainTextMessage
            self.ssmlMessage = ssmlMessage
        }

        public func validate(name: String) throws {
            try self.customPayload?.validate(name: "\(name).customPayload")
            try self.imageResponseCard?.validate(name: "\(name).imageResponseCard")
            try self.plainTextMessage?.validate(name: "\(name).plainTextMessage")
            try self.ssmlMessage?.validate(name: "\(name).ssmlMessage")
        }

        private enum CodingKeys: String, CodingKey {
            case customPayload = "customPayload"
            case imageResponseCard = "imageResponseCard"
            case plainTextMessage = "plainTextMessage"
            case ssmlMessage = "ssmlMessage"
        }
    }

    public struct MessageGroup: AWSEncodableShape & AWSDecodableShape {

        /// The primary message that Amazon Lex should send to the user.
        public let message: Message
        /// Message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user.
        public let variations: [Message]?

        public init(message: Message, variations: [Message]? = nil) {
            self.message = message
            self.variations = variations
        }

        public func validate(name: String) throws {
            try self.message.validate(name: "\(name).message")
            try self.variations?.forEach {
                try $0.validate(name: "\(name).variations[]")
            }
            try self.validate(self.variations, name: "variations", parent: name, max: 2)
            try self.validate(self.variations, name: "variations", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case variations = "variations"
        }
    }

    public struct ObfuscationSetting: AWSEncodableShape & AWSDecodableShape {

        /// Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        public let obfuscationSettingType: ObfuscationSettingType

        public init(obfuscationSettingType: ObfuscationSettingType) {
            self.obfuscationSettingType = obfuscationSettingType
        }

        private enum CodingKeys: String, CodingKey {
            case obfuscationSettingType = "obfuscationSettingType"
        }
    }

    public struct OutputContext: AWSEncodableShape & AWSDecodableShape {

        /// The name of the output context.
        public let name: String
        /// The amount of time, in seconds, that the output context should remain active. The time is figured from the first time the context is sent to the user.
        public let timeToLiveInSeconds: Int
        /// The number of conversation turns that the output context should remain active. The number of turns is counted from the first time that the context is sent to the user.
        public let turnsToLive: Int

        public init(name: String, timeToLiveInSeconds: Int, turnsToLive: Int) {
            self.name = name
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, max: 86400)
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, min: 5)
            try self.validate(self.turnsToLive, name: "turnsToLive", parent: name, max: 20)
            try self.validate(self.turnsToLive, name: "turnsToLive", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case timeToLiveInSeconds = "timeToLiveInSeconds"
            case turnsToLive = "turnsToLive"
        }
    }

    public struct PlainTextMessage: AWSEncodableShape & AWSDecodableShape {

        /// The message to send to the user.
        public let value: String

        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct PromptSpecification: AWSEncodableShape & AWSDecodableShape {

        /// Indicates whether the user can interrupt a speech prompt from the bot.
        public let allowInterrupt: Bool?
        /// The maximum number of times the bot tries to elicit a resonse from the user using this prompt.
        public let maxRetries: Int
        /// A collection of messages that Amazon Lex can send to the user. Amazon Lex chooses the actual message to send at runtime.
        public let messageGroups: [MessageGroup]

        public init(allowInterrupt: Bool? = nil, maxRetries: Int, messageGroups: [MessageGroup]) {
            self.allowInterrupt = allowInterrupt
            self.maxRetries = maxRetries
            self.messageGroups = messageGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, max: 5)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case maxRetries = "maxRetries"
            case messageGroups = "messageGroups"
        }
    }

    public struct ResponseSpecification: AWSEncodableShape & AWSDecodableShape {

        /// Indicates whether the user can interrupt a speech response from Amazon Lex.
        public let allowInterrupt: Bool?
        /// A collection of responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime.
        public let messageGroups: [MessageGroup]

        public init(allowInterrupt: Bool? = nil, messageGroups: [MessageGroup]) {
            self.allowInterrupt = allowInterrupt
            self.messageGroups = messageGroups
        }

        public func validate(name: String) throws {
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case messageGroups = "messageGroups"
        }
    }

    public struct S3BucketLogDestination: AWSEncodableShape & AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        public let kmsKeyArn: String?
        /// The S3 prefix to assign to audio log files.
        public let logPrefix: String
        /// The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        public let s3BucketArn: String

        public init(kmsKeyArn: String? = nil, logPrefix: String, s3BucketArn: String) {
            self.kmsKeyArn = kmsKeyArn
            self.logPrefix = logPrefix
            self.s3BucketArn = s3BucketArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:[\\w\\-]+:kms:[\\w\\-]+:[\\d]{12}:(?:key\\/[\\w\\-]+|alias\\/[a-zA-Z0-9:\\/_\\-]{1,256})$")
            try self.validate(self.logPrefix, name: "logPrefix", parent: name, max: 1024)
            try self.validate(self.s3BucketArn, name: "s3BucketArn", parent: name, max: 2048)
            try self.validate(self.s3BucketArn, name: "s3BucketArn", parent: name, min: 1)
            try self.validate(self.s3BucketArn, name: "s3BucketArn", parent: name, pattern: "^arn:[\\w\\-]+:s3:::[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case logPrefix = "logPrefix"
            case s3BucketArn = "s3BucketArn"
        }
    }

    public struct SSMLMessage: AWSEncodableShape & AWSDecodableShape {

        /// The SSML text that defines the prompt.
        public let value: String

        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct SampleUtterance: AWSEncodableShape & AWSDecodableShape {

        /// The sample utterance that Amazon Lex uses to build its machine-learning model to recognize intents.
        public let utterance: String

        public init(utterance: String) {
            self.utterance = utterance
        }

        private enum CodingKeys: String, CodingKey {
            case utterance = "utterance"
        }
    }

    public struct SampleValue: AWSEncodableShape & AWSDecodableShape {

        /// The value that can be used for a slot type.
        public let value: String

        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 140)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct SentimentAnalysisSettings: AWSEncodableShape & AWSDecodableShape {

        /// Sets whether Amazon Lex uses Amazon Comprehend to detect the sentiment of user utterances.
        public let detectSentiment: Bool

        public init(detectSentiment: Bool) {
            self.detectSentiment = detectSentiment
        }

        private enum CodingKeys: String, CodingKey {
            case detectSentiment = "detectSentiment"
        }
    }

    public struct SlotDefaultValue: AWSEncodableShape & AWSDecodableShape {

        /// The default value to use when a user doesn't provide a value for a slot.
        public let defaultValue: String

        public init(defaultValue: String) {
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 202)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
        }
    }

    public struct SlotDefaultValueSpecification: AWSEncodableShape & AWSDecodableShape {

        /// A list of default values. Amazon Lex chooses the default value to use in the order that they are presented in the list.
        public let defaultValueList: [SlotDefaultValue]

        public init(defaultValueList: [SlotDefaultValue]) {
            self.defaultValueList = defaultValueList
        }

        public func validate(name: String) throws {
            try self.defaultValueList.forEach {
                try $0.validate(name: "\(name).defaultValueList[]")
            }
            try self.validate(self.defaultValueList, name: "defaultValueList", parent: name, max: 10)
            try self.validate(self.defaultValueList, name: "defaultValueList", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValueList = "defaultValueList"
        }
    }

    public struct SlotFilter: AWSEncodableShape {

        /// The name of the field to use for filtering.
        public let name: SlotFilterName
        /// The operator to use for the filter. Specify EQ when the ListSlots operation should return only aliases that equal the specified value. Specify CO when the ListSlots operation should return aliases that contain the specified value.
        public let `operator`: SlotFilterOperator
        /// The value to use to filter the response.
        public let values: [String]

        public init(name: SlotFilterName, operator: SlotFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SlotPriority: AWSEncodableShape & AWSDecodableShape {

        /// The priority that a slot should be elicited.
        public let priority: Int
        /// The unique identifier of the slot.
        public let slotId: String

        public init(priority: Int, slotId: String) {
            self.priority = priority
            self.slotId = slotId
        }

        public func validate(name: String) throws {
            try self.validate(self.priority, name: "priority", parent: name, max: 25)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "priority"
            case slotId = "slotId"
        }
    }

    public struct SlotSortBy: AWSEncodableShape {

        /// The attribute to use to sort the list.
        public let attribute: SlotSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        public init(attribute: SlotSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct SlotSummary: AWSDecodableShape {

        /// The description of the slot.
        public let description: String?
        /// The timestamp of the last date and time that the slot was updated.
        public let lastUpdatedDateTime: Date?
        /// Whether the slot is required or optional. An intent is complete when all required slots are filled.
        public let slotConstraint: SlotConstraint?
        /// The unique identifier of the slot.
        public let slotId: String?
        /// The name given to the slot.
        public let slotName: String?
        /// The unique identifier for the slot type that defines the values for the slot.
        public let slotTypeId: String?
        /// Prompts that are sent to the user to elicit a value for the slot.
        public let valueElicitationPromptSpecification: PromptSpecification?

        public init(description: String? = nil, lastUpdatedDateTime: Date? = nil, slotConstraint: SlotConstraint? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, valueElicitationPromptSpecification: PromptSpecification? = nil) {
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.slotConstraint = slotConstraint
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationPromptSpecification = valueElicitationPromptSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case slotConstraint = "slotConstraint"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case valueElicitationPromptSpecification = "valueElicitationPromptSpecification"
        }
    }

    public struct SlotTypeFilter: AWSEncodableShape {

        /// The name of the field to use for filtering.
        public let name: SlotTypeFilterName
        /// The operator to use for the filter. Specify EQ when the ListSlotTypes operation should return only aliases that equal the specified value. Specify CO when the ListSlotTypes operation should return aliases that contain the specified value.
        public let `operator`: SlotTypeFilterOperator
        /// The value to use to filter the response.
        public let values: [String]

        public init(name: SlotTypeFilterName, operator: SlotTypeFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SlotTypeSortBy: AWSEncodableShape {

        /// The attribute to use to sort the list of slot types.
        public let attribute: SlotTypeSortAttribute
        /// The order to sort the list. You can say ascending or descending.
        public let order: SortOrder

        public init(attribute: SlotTypeSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct SlotTypeSummary: AWSDecodableShape {

        /// The description of the slot type.
        public let description: String?
        /// A timestamp of the date and time that the slot type was last updated.
        public let lastUpdatedDateTime: Date?
        /// If the slot type is derived from a built-on slot type, the name of the parent slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier assigned to the slot type.
        public let slotTypeId: String?
        /// The name of the slot type.
        public let slotTypeName: String?

        public init(description: String? = nil, lastUpdatedDateTime: Date? = nil, parentSlotTypeSignature: String? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil) {
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
        }
    }

    public struct SlotTypeValue: AWSEncodableShape & AWSDecodableShape {

        /// The value of the slot type entry.
        public let sampleValue: SampleValue?
        /// Additional values releated to the slot type entry.
        public let synonyms: [SampleValue]?

        public init(sampleValue: SampleValue? = nil, synonyms: [SampleValue]? = nil) {
            self.sampleValue = sampleValue
            self.synonyms = synonyms
        }

        public func validate(name: String) throws {
            try self.sampleValue?.validate(name: "\(name).sampleValue")
            try self.synonyms?.forEach {
                try $0.validate(name: "\(name).synonyms[]")
            }
            try self.validate(self.synonyms, name: "synonyms", parent: name, max: 10000)
            try self.validate(self.synonyms, name: "synonyms", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sampleValue = "sampleValue"
            case synonyms = "synonyms"
        }
    }

    public struct SlotValueElicitationSetting: AWSEncodableShape & AWSDecodableShape {

        /// A list of default values for a slot. Default values are used when Amazon Lex hasn't determined a value for a slot. You can specify default values from context variables, sesion attributes, and defined values.
        public let defaultValueSpecification: SlotDefaultValueSpecification?
        /// The prompt that Amazon Lex uses to elicit the slot value from the user.
        public let promptSpecification: PromptSpecification?
        /// If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances.
        public let sampleUtterances: [SampleUtterance]?
        /// Specifies whether the slot is required or optional.
        public let slotConstraint: SlotConstraint
        public let waitAndContinueSpecification: WaitAndContinueSpecification?

        public init(defaultValueSpecification: SlotDefaultValueSpecification? = nil, promptSpecification: PromptSpecification? = nil, sampleUtterances: [SampleUtterance]? = nil, slotConstraint: SlotConstraint, waitAndContinueSpecification: WaitAndContinueSpecification? = nil) {
            self.defaultValueSpecification = defaultValueSpecification
            self.promptSpecification = promptSpecification
            self.sampleUtterances = sampleUtterances
            self.slotConstraint = slotConstraint
            self.waitAndContinueSpecification = waitAndContinueSpecification
        }

        public func validate(name: String) throws {
            try self.defaultValueSpecification?.validate(name: "\(name).defaultValueSpecification")
            try self.promptSpecification?.validate(name: "\(name).promptSpecification")
            try self.waitAndContinueSpecification?.validate(name: "\(name).waitAndContinueSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValueSpecification = "defaultValueSpecification"
            case promptSpecification = "promptSpecification"
            case sampleUtterances = "sampleUtterances"
            case slotConstraint = "slotConstraint"
            case waitAndContinueSpecification = "waitAndContinueSpecification"
        }
    }

    public struct SlotValueRegexFilter: AWSEncodableShape & AWSDecodableShape {

        /// A regular expression used to validate the value of a slot.  Use a standard regular expression. Amazon Lex supports the following characters in the regular expression:    A-Z, a-z   0-9   Unicode characters ("\ u&lt;Unicode&gt;")    Represent Unicode characters with four digits, for example "\u0041" or "\u005A".   The following regular expression operators are not supported:    Infinite repeaters: *, +, or {x,} with no upper bound.   Wild card (.)
        public let pattern: String

        public init(pattern: String) {
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.pattern, name: "pattern", parent: name, max: 100)
            try self.validate(self.pattern, name: "pattern", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pattern = "pattern"
        }
    }

    public struct SlotValueSelectionSetting: AWSEncodableShape & AWSDecodableShape {

        /// A regular expression used to validate the value of a slot.
        public let regexFilter: SlotValueRegexFilter?
        /// Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:   OriginalValue - Returns the value entered by the user, if the user value is similar to the slot value.   TopResolution - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.   If you don't specify the valueSelectionStrategy, the default is OriginalValue.
        public let resolutionStrategy: SlotValueResolutionStrategy

        public init(regexFilter: SlotValueRegexFilter? = nil, resolutionStrategy: SlotValueResolutionStrategy) {
            self.regexFilter = regexFilter
            self.resolutionStrategy = resolutionStrategy
        }

        public func validate(name: String) throws {
            try self.regexFilter?.validate(name: "\(name).regexFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case regexFilter = "regexFilter"
            case resolutionStrategy = "resolutionStrategy"
        }
    }

    public struct StillWaitingResponseSpecification: AWSEncodableShape & AWSDecodableShape {

        /// Indicates that the user can interrupt the response by speaking while the message is being played.
        public let allowInterrupt: Bool?
        /// How often a message should be sent to the user. Minimum of 1 second, maximum of 5 minutes.
        public let frequencyInSeconds: Int
        /// One or more message groups, each containing one or more messages, that define the prompts that Amazon Lex sends to the user.
        public let messageGroups: [MessageGroup]
        /// If Amazon Lex waits longer than this length of time for a response, it will stop sending messages.
        public let timeoutInSeconds: Int

        public init(allowInterrupt: Bool? = nil, frequencyInSeconds: Int, messageGroups: [MessageGroup], timeoutInSeconds: Int) {
            self.allowInterrupt = allowInterrupt
            self.frequencyInSeconds = frequencyInSeconds
            self.messageGroups = messageGroups
            self.timeoutInSeconds = timeoutInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.frequencyInSeconds, name: "frequencyInSeconds", parent: name, max: 300)
            try self.validate(self.frequencyInSeconds, name: "frequencyInSeconds", parent: name, min: 1)
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, max: 900)
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case frequencyInSeconds = "frequencyInSeconds"
            case messageGroups = "messageGroups"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceARN", location: .uri(locationName: "resourceARN"))
        ]

        /// The Amazon Resource Name (ARN) of the bot, bot alias, or bot channel to tag.
        public let resourceARN: String
        /// A list of tag keys to add to the resource. If a tag key already exists, the existing value is replaced with the new value.
        public let tags: [String: String]

        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct TextLogDestination: AWSEncodableShape & AWSDecodableShape {

        /// Defines the Amazon CloudWatch Logs log group where text and metadata logs are delivered.
        public let cloudWatch: CloudWatchLogGroupLogDestination

        public init(cloudWatch: CloudWatchLogGroupLogDestination) {
            self.cloudWatch = cloudWatch
        }

        public func validate(name: String) throws {
            try self.cloudWatch.validate(name: "\(name).cloudWatch")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatch = "cloudWatch"
        }
    }

    public struct TextLogSetting: AWSEncodableShape & AWSDecodableShape {

        public let destination: TextLogDestination
        /// Determines whether conversation logs should be stored for an alias.
        public let enabled: Bool

        public init(destination: TextLogDestination, enabled: Bool) {
            self.destination = destination
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case enabled = "enabled"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceARN", location: .uri(locationName: "resourceARN")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to remove the tags from.
        public let resourceARN: String
        /// A list of tag keys to remove from the resource. If a tag key does not exist on the resource, it is ignored.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateBotAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botAliasId", location: .uri(locationName: "botAliasId")), 
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// The unique identifier of the bot alias.
        public let botAliasId: String
        /// The new Lambda functions to use in each locale for the bot alias.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The new name to assign to the bot alias.
        public let botAliasName: String
        /// The identifier of the bot with the updated alias.
        public let botId: String
        /// The new bot version to assign to the bot alias.
        public let botVersion: String?
        /// The new settings for storing conversation logs in Amazon CloudWatch Logs and Amazon S3 buckets.
        public let conversationLogSettings: ConversationLogSettings?
        /// The new description to assign to the bot alias.
        public let description: String?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?

        public init(botAliasId: String, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String, botId: String, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, description: String? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil) {
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.description = description
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.botAliasLocaleSettings?.forEach {
                try $0.value.validate(name: "\(name).botAliasLocaleSettings[\"\($0.key)\"]")
            }
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, max: 100)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, min: 1)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.conversationLogSettings?.validate(name: "\(name).conversationLogSettings")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case description = "description"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
        }
    }

    public struct UpdateBotAliasResponse: AWSDecodableShape {

        /// The identifier of the updated bot alias.
        public let botAliasId: String?
        /// The updated Lambda functions to use in each locale for the bot alias.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The updated name of the bot alias.
        public let botAliasName: String?
        /// The current status of the bot alias. When the status is Available the alias is ready for use.
        public let botAliasStatus: BotAliasStatus?
        /// The identifier of the bot with the updated alias.
        public let botId: String?
        /// The updated version of the bot that the alias points to.
        public let botVersion: String?
        /// The updated settings for storing conversation logs in Amazon CloudWatch Logs and Amazon S3 buckets.
        public let conversationLogSettings: ConversationLogSettings?
        /// A timestamp of the date and time that the bot was created.
        public let creationDateTime: Date?
        /// The updated description of the bot alias.
        public let description: String?
        /// A timestamp of the date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?

        public init(botAliasId: String? = nil, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil) {
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
        }
    }

    public struct UpdateBotLocaleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The unique identifier of the bot that contains the locale.
        public let botId: String
        /// The version of the bot that contains the locale to be updated. The version can only be the DRAFT version.
        public let botVersion: String
        /// The new description of the locale.
        public let description: String?
        /// The identifier of the language and locale to update. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The new confidence threshold where Amazon Lex inserts the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
        public let nluIntentConfidenceThreshold: Double
        /// The new Amazon Polly voice Amazon Lex should use for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        public init(botId: String, botVersion: String, description: String? = nil, localeId: String, nluIntentConfidenceThreshold: Double, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.localeId = localeId
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, max: 1)
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct UpdateBotLocaleResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the updated locale.
        public let botId: String?
        /// The current status of the locale. When the bot status is Built the locale is ready for use.
        public let botLocaleStatus: BotLocaleStatus?
        /// The version of the bot that contains the updated locale.
        public let botVersion: String?
        /// A timestamp of the date and time that the locale was created.
        public let creationDateTime: Date?
        /// The updated description of the locale.
        public let description: String?
        /// If the botLocaleStatus is Failed, the failureReasons field lists the errors that occurred while building the bot.
        public let failureReasons: [String]?
        /// A timestamp of the date and time that the locale was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale of the updated bot locale.
        public let localeId: String?
        /// The updated locale name for the locale.
        public let localeName: String?
        /// The updated confidence threshold for inserting the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
        public let nluIntentConfidenceThreshold: Double?
        /// The updated Amazon Polly voice to use for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, failureReasons: [String]? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, localeName: String? = nil, nluIntentConfidenceThreshold: Double? = nil, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.failureReasons = failureReasons
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.localeName = localeName
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case failureReasons = "failureReasons"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case localeName = "localeName"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct UpdateBotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId"))
        ]

        /// The unique identifier of the bot to update. This identifier is returned by the CreateBot operation.
        public let botId: String
        /// The new name of the bot. The name must be unique in the account that creates the bot.
        public let botName: String
        /// Provides information on additional privacy protections Amazon Lex should use with the bot's data.
        public let dataPrivacy: DataPrivacy
        /// A description of the bot.
        public let description: String?
        /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
        public let idleSessionTTLInSeconds: Int
        /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the bot.
        public let roleArn: String

        public init(botId: String, botName: String, dataPrivacy: DataPrivacy, description: String? = nil, idleSessionTTLInSeconds: Int, roleArn: String) {
            self.botId = botId
            self.botName = botName
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botName, name: "botName", parent: name, max: 100)
            try self.validate(self.botName, name: "botName", parent: name, min: 1)
            try self.validate(self.botName, name: "botName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 86400)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case botName = "botName"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateBotResponse: AWSDecodableShape {

        /// The unique identifier of the bot that was updated.
        public let botId: String?
        /// The name of the bot after the update.
        public let botName: String?
        /// Shows the current status of the bot. The bot is first in the Creating status. Once the bot is read for use, it changes to the Available status. After the bot is created, you can use the DRAFT version of the bot.
        public let botStatus: BotStatus?
        /// A timestamp of the date and time that the bot was created.
        public let creationDateTime: Date?
        /// The data privacy settings for the bot after the update.
        public let dataPrivacy: DataPrivacy?
        /// The description of the bot after the update.
        public let description: String?
        /// The session timeout, in seconds, for the bot after the update.
        public let idleSessionTTLInSeconds: Int?
        /// A timestamp of the date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the IAM role used by the bot after the update.
        public let roleArn: String?

        public init(botId: String? = nil, botName: String? = nil, botStatus: BotStatus? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, idleSessionTTLInSeconds: Int? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil) {
            self.botId = botId
            self.botName = botName
            self.botStatus = botStatus
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botName = "botName"
            case botStatus = "botStatus"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateIntentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId"))
        ]

        /// The identifier of the bot that contains the intent.
        public let botId: String
        /// The version of the bot that contains the intent. Must be DRAFT.
        public let botVersion: String
        /// The new description of the intent.
        public let description: String?
        /// The new Lambda function to use between each turn of the conversation with the bot.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The new Lambda function to call when all of the intents required slots are provided and the intent is ready for fulfillment.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// A new list of contexts that must be active in order for Amazon Lex to consider the intent.
        public let inputContexts: [InputContext]?
        /// The new response that Amazon Lex sends the user when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// New prompts that Amazon Lex sends to the user to confirm the completion of an intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The unique identifier of the intent to update.
        public let intentId: String
        /// The new name for the intent.
        public let intentName: String
        /// New configuration settings for connecting to an Amazon Kendra index.
        public let kendraConfiguration: KendraConfiguration?
        /// The identifier of the language and locale where this intent is used. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// A new list of contexts that Amazon Lex activates when the intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// The signature of the new built-in intent to use as the parent of this intent.
        public let parentIntentSignature: String?
        /// New utterances used to invoke the intent.
        public let sampleUtterances: [SampleUtterance]?
        /// A new list of slots and their priorities that are contained by the intent.
        public let slotPriorities: [SlotPriority]?

        public init(botId: String, botVersion: String, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String, intentName: String, kendraConfiguration: KendraConfiguration? = nil, localeId: String, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, sampleUtterances: [SampleUtterance]? = nil, slotPriorities: [SlotPriority]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.sampleUtterances = sampleUtterances
            self.slotPriorities = slotPriorities
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.inputContexts?.forEach {
                try $0.validate(name: "\(name).inputContexts[]")
            }
            try self.validate(self.inputContexts, name: "inputContexts", parent: name, max: 5)
            try self.validate(self.inputContexts, name: "inputContexts", parent: name, min: 0)
            try self.intentClosingSetting?.validate(name: "\(name).intentClosingSetting")
            try self.intentConfirmationSetting?.validate(name: "\(name).intentConfirmationSetting")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.intentName, name: "intentName", parent: name, max: 100)
            try self.validate(self.intentName, name: "intentName", parent: name, min: 1)
            try self.validate(self.intentName, name: "intentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.kendraConfiguration?.validate(name: "\(name).kendraConfiguration")
            try self.outputContexts?.forEach {
                try $0.validate(name: "\(name).outputContexts[]")
            }
            try self.validate(self.outputContexts, name: "outputContexts", parent: name, max: 10)
            try self.validate(self.outputContexts, name: "outputContexts", parent: name, min: 0)
            try self.slotPriorities?.forEach {
                try $0.validate(name: "\(name).slotPriorities[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case sampleUtterances = "sampleUtterances"
            case slotPriorities = "slotPriorities"
        }
    }

    public struct UpdateIntentResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the intent.
        public let botId: String?
        /// The version of the bot that contains the intent. Will always be DRAFT.
        public let botVersion: String?
        /// A timestamp of when the intent was created.
        public let creationDateTime: Date?
        /// The updated description of the intent.
        public let description: String?
        /// The updated Lambda function called during each turn of the conversation with the user.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The updated Lambda function called when the intent is ready for fulfillment.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// The updated list of contexts that must be active for the intent to be considered by Amazon Lex.
        public let inputContexts: [InputContext]?
        /// The updated response that Amazon Lex sends the user when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// The updated prompts that Amazon Lex sends to the user to confirm the completion of an intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The identifier of the intent that was updated.
        public let intentId: String?
        /// The updated name of the intent.
        public let intentName: String?
        /// The updated configuration for connecting to an Amazon Kendra index with the AMAZON.KendraSearchIntent intent.
        public let kendraConfiguration: KendraConfiguration?
        /// A timestamp of the last time that the intent was modified.
        public let lastUpdatedDateTime: Date?
        /// The updated language and locale of the intent.
        public let localeId: String?
        /// The updated list of contexts that Amazon Lex activates when the intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// The updated built-in intent that is the parent of this intent.
        public let parentIntentSignature: String?
        /// The updated list of sample utterances for the intent.
        public let sampleUtterances: [SampleUtterance]?
        /// The updated list of slots and their priorities that are elicited from the user for the intent.
        public let slotPriorities: [SlotPriority]?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String? = nil, intentName: String? = nil, kendraConfiguration: KendraConfiguration? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, sampleUtterances: [SampleUtterance]? = nil, slotPriorities: [SlotPriority]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.sampleUtterances = sampleUtterances
            self.slotPriorities = slotPriorities
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentId = "intentId"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case sampleUtterances = "sampleUtterances"
            case slotPriorities = "slotPriorities"
        }
    }

    public struct UpdateSlotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "intentId", location: .uri(locationName: "intentId")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId")), 
            AWSMemberEncoding(label: "slotId", location: .uri(locationName: "slotId"))
        ]

        /// The unique identifier of the bot that contains the slot.
        public let botId: String
        /// The version of the bot that contains the slot. Must always be DRAFT.
        public let botVersion: String
        /// The new description for the slot.
        public let description: String?
        /// The identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale that contains the slot. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// New settings that determine how slot values are formatted in Amazon CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier for the slot to update.
        public let slotId: String
        /// The new name for the slot.
        public let slotName: String
        /// The unique identifier of the new slot type to associate with this slot.
        public let slotTypeId: String
        /// A new set of prompts that Amazon Lex sends to the user to elicit a response the provides a value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting

        public init(botId: String, botVersion: String, description: String? = nil, intentId: String, localeId: String, obfuscationSetting: ObfuscationSetting? = nil, slotId: String, slotName: String, slotTypeId: String, valueElicitationSetting: SlotValueElicitationSetting) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.intentId = intentId
            self.localeId = localeId
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationSetting = valueElicitationSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotName, name: "slotName", parent: name, max: 100)
            try self.validate(self.slotName, name: "slotName", parent: name, min: 1)
            try self.validate(self.slotName, name: "slotName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 25)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 1)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^((AMAZON\\.)[a-zA-Z_]+?|[0-9a-zA-Z]+)$")
            try self.valueElicitationSetting.validate(name: "\(name).valueElicitationSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case obfuscationSetting = "obfuscationSetting"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct UpdateSlotResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the slot.
        public let botId: String?
        /// The identifier of the slot version that contains the slot. Will always be DRAFT.
        public let botVersion: String?
        /// The timestamp of the date and time that the slot was created.
        public let creationDateTime: Date?
        /// The updated description of the bot.
        public let description: String?
        /// The intent that contains the slot.
        public let intentId: String?
        /// The timestamp of the date and time that the slot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The locale that contains the slot.
        public let localeId: String?
        /// The updated setting that determines whether the slot value is obfuscated in the Amazon CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier of the slot that was updated.
        public let slotId: String?
        /// The updated name of the slot.
        public let slotName: String?
        /// The updated identifier of the slot type that provides values for the slot.
        public let slotTypeId: String?
        /// The updated prompts that Amazon Lex sends to the user to elicit a response that provides a value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, intentId: String? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, valueElicitationSetting: SlotValueElicitationSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.intentId = intentId
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationSetting = valueElicitationSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case intentId = "intentId"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case obfuscationSetting = "obfuscationSetting"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct UpdateSlotTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botId", location: .uri(locationName: "botId")), 
            AWSMemberEncoding(label: "botVersion", location: .uri(locationName: "botVersion")), 
            AWSMemberEncoding(label: "localeId", location: .uri(locationName: "localeId")), 
            AWSMemberEncoding(label: "slotTypeId", location: .uri(locationName: "slotTypeId"))
        ]

        /// The identifier of the bot that contains the slot type.
        public let botId: String
        /// The version of the bot that contains the slot type. Must be DRAFT.
        public let botVersion: String
        /// The new description of the slot type.
        public let description: String?
        /// The identifier of the language and locale that contains the slot type. The string must match one of the supported locales. For more information, see https://docs.aws.amazon.com/lex/latest/dg/supported-locales.html.
        public let localeId: String
        /// The new built-in slot type that should be used as the parent of this slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier of the slot type to update.
        public let slotTypeId: String
        /// The new name of the slot type.
        public let slotTypeName: String
        /// A new list of values and their optional synonyms that define the values that the slot type can take.
        public let slotTypeValues: [SlotTypeValue]?
        /// The strategy that Amazon Lex should use when deciding on a value from the list of slot type values.
        public let valueSelectionSetting: SlotValueSelectionSetting

        public init(botId: String, botVersion: String, description: String? = nil, localeId: String, parentSlotTypeSignature: String? = nil, slotTypeId: String, slotTypeName: String, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, max: 100)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, min: 1)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.slotTypeValues?.forEach {
                try $0.validate(name: "\(name).slotTypeValues[]")
            }
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, max: 10000)
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, min: 1)
            try self.valueSelectionSetting.validate(name: "\(name).valueSelectionSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct UpdateSlotTypeResponse: AWSDecodableShape {

        /// The identifier of the bot that contains the slot type.
        public let botId: String?
        /// The version of the bot that contains the slot type. This is always DRAFT.
        public let botVersion: String?
        /// The timestamp of the date and time that the slot type was created.
        public let creationDateTime: Date?
        /// The updated description of the slot type.
        public let description: String?
        /// A timestamp of the date and time that the slot type was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale of the updated slot type.
        public let localeId: String?
        /// The updated signature of the built-in slot type that is the parent of this slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier of the updated slot type.
        public let slotTypeId: String?
        /// The updated name of the slot type.
        public let slotTypeName: String?
        /// The updated values that the slot type provides.
        public let slotTypeValues: [SlotTypeValue]?
        /// The updated strategy that Amazon Lex uses to determine which value to select from the slot type.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, parentSlotTypeSignature: String? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct VoiceSettings: AWSEncodableShape & AWSDecodableShape {

        /// The identifier of the Amazon Polly voice to use.
        public let voiceId: String

        public init(voiceId: String) {
            self.voiceId = voiceId
        }

        private enum CodingKeys: String, CodingKey {
            case voiceId = "voiceId"
        }
    }

    public struct WaitAndContinueSpecification: AWSEncodableShape & AWSDecodableShape {

        /// The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        public let continueResponse: ResponseSpecification
        /// A response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        public let stillWaitingResponse: StillWaitingResponseSpecification?
        /// The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        public let waitingResponse: ResponseSpecification

        public init(continueResponse: ResponseSpecification, stillWaitingResponse: StillWaitingResponseSpecification? = nil, waitingResponse: ResponseSpecification) {
            self.continueResponse = continueResponse
            self.stillWaitingResponse = stillWaitingResponse
            self.waitingResponse = waitingResponse
        }

        public func validate(name: String) throws {
            try self.continueResponse.validate(name: "\(name).continueResponse")
            try self.stillWaitingResponse?.validate(name: "\(name).stillWaitingResponse")
            try self.waitingResponse.validate(name: "\(name).waitingResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case continueResponse = "continueResponse"
            case stillWaitingResponse = "stillWaitingResponse"
            case waitingResponse = "waitingResponse"
        }
    }
}
