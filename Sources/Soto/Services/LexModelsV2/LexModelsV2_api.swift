//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS LexModelsV2 service.
public struct LexModelsV2: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the LexModelsV2 client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "LexModelsV2",
            serviceIdentifier: "models-v2-lex",
            signingName: "lex",
            serviceProtocol: .restjson,
            apiVersion: "2020-08-07",
            endpoint: endpoint,
            errorType: LexModelsV2ErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Create a batch of custom vocabulary items for a given bot locale's  custom vocabulary.
    @Sendable
    public func batchCreateCustomVocabularyItem(_ input: BatchCreateCustomVocabularyItemRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreateCustomVocabularyItemResponse {
        return try await self.client.execute(
            operation: "BatchCreateCustomVocabularyItem", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchcreate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Delete a batch of custom vocabulary items for a given bot locale's  custom vocabulary.
    @Sendable
    public func batchDeleteCustomVocabularyItem(_ input: BatchDeleteCustomVocabularyItemRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteCustomVocabularyItemResponse {
        return try await self.client.execute(
            operation: "BatchDeleteCustomVocabularyItem", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchdelete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Update a batch of custom vocabulary items for a given bot locale's custom  vocabulary.
    @Sendable
    public func batchUpdateCustomVocabularyItem(_ input: BatchUpdateCustomVocabularyItemRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateCustomVocabularyItemResponse {
        return try await self.client.execute(
            operation: "BatchUpdateCustomVocabularyItem", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchupdate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Builds a bot, its intents, and its slot types into a specific  locale. A bot can be built into multiple locales. At runtime the locale is used to choose a specific build of the bot.
    @Sendable
    public func buildBotLocale(_ input: BuildBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BuildBotLocaleResponse {
        return try await self.client.execute(
            operation: "BuildBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an Amazon Lex conversational bot.
    @Sendable
    public func createBot(_ input: CreateBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotResponse {
        return try await self.client.execute(
            operation: "CreateBot", 
            path: "/bots", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an alias for the specified version of a bot. Use an alias to enable you to change the version of a bot without updating applications that use the bot. For example, you can create an alias called "PROD" that your applications use to call the Amazon Lex bot.
    @Sendable
    public func createBotAlias(_ input: CreateBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotAliasResponse {
        return try await self.client.execute(
            operation: "CreateBotAlias", 
            path: "/bots/{botId}/botaliases", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a locale in the bot. The locale contains the intents and slot types that the bot uses in conversations with users in the specified language and locale. You must add a locale to a bot before you can add intents and slot types to the bot.
    @Sendable
    public func createBotLocale(_ input: CreateBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotLocaleResponse {
        return try await self.client.execute(
            operation: "CreateBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Action to create a replication of the source bot in the secondary region.
    @Sendable
    public func createBotReplica(_ input: CreateBotReplicaRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotReplicaResponse {
        return try await self.client.execute(
            operation: "CreateBotReplica", 
            path: "/bots/{botId}/replicas", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an immutable version of the bot. When you create the first  version of a bot, Amazon Lex sets the version number to 1. Subsequent bot versions increase  in an increment of 1. The version number will always represent the total number  of versions created of the bot, not the current number of versions. If a bot version is deleted, that bot version number will not be reused.
    @Sendable
    public func createBotVersion(_ input: CreateBotVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotVersionResponse {
        return try await self.client.execute(
            operation: "CreateBotVersion", 
            path: "/bots/{botId}/botversions", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a zip archive containing the contents of a bot or a bot locale. The archive contains a directory structure that contains JSON files that define the bot. You can create an archive that contains the complete definition of a bot, or you can specify that the archive contain only the definition of a single bot locale. For more information about exporting bots, and about the structure of the export archive, see  Importing and exporting bots
    @Sendable
    public func createExport(_ input: CreateExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateExportResponse {
        return try await self.client.execute(
            operation: "CreateExport", 
            path: "/exports", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an intent. To define the interaction between the user and your bot, you define one or more intents. For example, for a pizza ordering bot you would create an OrderPizza intent. When you create an intent, you must provide a name. You can optionally provide the following:   Sample utterances. For example, "I want to order a pizza" and "Can I order a pizza." You can't provide utterances for built-in intents.   Information to be gathered. You specify slots for the information that you bot requests from the user. You can specify standard slot types, such as date and time, or custom slot types for your application.   How the intent is fulfilled. You can provide a Lambda function or configure the intent to return the intent information to your client application. If you use a Lambda function, Amazon Lex invokes the function when all of the intent information is available.   A confirmation prompt to send to the user to confirm an intent. For example, "Shall I order your pizza?"   A conclusion statement to send to the user after the intent is fulfilled. For example, "I ordered your pizza."   A follow-up prompt that asks the user for additional activity. For example, "Do you want a drink with your pizza?"
    @Sendable
    public func createIntent(_ input: CreateIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIntentResponse {
        return try await self.client.execute(
            operation: "CreateIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new resource policy with the specified policy statements.
    @Sendable
    public func createResourcePolicy(_ input: CreateResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResourcePolicyResponse {
        return try await self.client.execute(
            operation: "CreateResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Adds a new resource policy statement to a bot or bot alias. If a resource policy exists, the statement is added to the current resource policy. If a policy doesn't exist, a new policy is created. You can't create a resource policy statement that allows cross-account access.
    @Sendable
    public func createResourcePolicyStatement(_ input: CreateResourcePolicyStatementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResourcePolicyStatementResponse {
        return try await self.client.execute(
            operation: "CreateResourcePolicyStatement", 
            path: "/policy/{resourceArn}/statements", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a slot in an intent. A slot is a variable needed to fulfill an intent. For example, an OrderPizza intent might need slots for size, crust, and number of pizzas. For each slot, you define one or more utterances that Amazon Lex uses to elicit a response from the user.
    @Sendable
    public func createSlot(_ input: CreateSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSlotResponse {
        return try await self.client.execute(
            operation: "CreateSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a custom slot type To create a custom slot type, specify a name for the slot type and a set of enumeration values, the values that a slot of this type can assume.
    @Sendable
    public func createSlotType(_ input: CreateSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSlotTypeResponse {
        return try await self.client.execute(
            operation: "CreateSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Create a report that describes the differences between the bot and the test set.
    @Sendable
    public func createTestSetDiscrepancyReport(_ input: CreateTestSetDiscrepancyReportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTestSetDiscrepancyReportResponse {
        return try await self.client.execute(
            operation: "CreateTestSetDiscrepancyReport", 
            path: "/testsets/{testSetId}/testsetdiscrepancy", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a pre-signed S3 write URL that you use to upload the zip archive when importing a bot or a bot locale.
    @Sendable
    public func createUploadUrl(_ input: CreateUploadUrlRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateUploadUrlResponse {
        return try await self.client.execute(
            operation: "CreateUploadUrl", 
            path: "/createuploadurl", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes all versions of a bot, including the Draft version. To delete a specific version, use the DeleteBotVersion operation. When you delete a bot, all of the resources contained in the bot are also deleted. Deleting a bot removes all locales, intents, slot, and slot types defined for the bot. If a bot has an alias, the DeleteBot operation returns a ResourceInUseException exception. If you want to delete the bot and the alias, set the skipResourceInUseCheck parameter to true.
    @Sendable
    public func deleteBot(_ input: DeleteBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotResponse {
        return try await self.client.execute(
            operation: "DeleteBot", 
            path: "/bots/{botId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified bot alias.
    @Sendable
    public func deleteBotAlias(_ input: DeleteBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotAliasResponse {
        return try await self.client.execute(
            operation: "DeleteBotAlias", 
            path: "/bots/{botId}/botaliases/{botAliasId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes a locale from a bot. When you delete a locale, all intents, slots, and slot types defined for the locale are also deleted.
    @Sendable
    public func deleteBotLocale(_ input: DeleteBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotLocaleResponse {
        return try await self.client.execute(
            operation: "DeleteBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The action to delete the replicated bot in the secondary region.
    @Sendable
    public func deleteBotReplica(_ input: DeleteBotReplicaRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotReplicaResponse {
        return try await self.client.execute(
            operation: "DeleteBotReplica", 
            path: "/bots/{botId}/replicas/{replicaRegion}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a specific version of a bot. To delete all versions of a bot, use the DeleteBot operation.
    @Sendable
    public func deleteBotVersion(_ input: DeleteBotVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotVersionResponse {
        return try await self.client.execute(
            operation: "DeleteBotVersion", 
            path: "/bots/{botId}/botversions/{botVersion}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes a custom vocabulary from the specified locale in the specified bot.
    @Sendable
    public func deleteCustomVocabulary(_ input: DeleteCustomVocabularyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCustomVocabularyResponse {
        return try await self.client.execute(
            operation: "DeleteCustomVocabulary", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes a previous export and the associated files stored in an S3 bucket.
    @Sendable
    public func deleteExport(_ input: DeleteExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteExportResponse {
        return try await self.client.execute(
            operation: "DeleteExport", 
            path: "/exports/{exportId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes a previous import and the associated file stored in an S3 bucket.
    @Sendable
    public func deleteImport(_ input: DeleteImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImportResponse {
        return try await self.client.execute(
            operation: "DeleteImport", 
            path: "/imports/{importId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes the specified intent. Deleting an intent also deletes the slots associated with the intent.
    @Sendable
    public func deleteIntent(_ input: DeleteIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes an existing policy from a bot or bot alias. If the resource doesn't have a policy attached, Amazon Lex returns an exception.
    @Sendable
    public func deleteResourcePolicy(_ input: DeleteResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResourcePolicyResponse {
        return try await self.client.execute(
            operation: "DeleteResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a policy statement from a resource policy. If you delete the last statement from a policy, the policy is deleted. If you specify a statement ID that doesn't exist in the policy, or if the bot or bot alias doesn't have a policy attached, Amazon Lex returns an exception.
    @Sendable
    public func deleteResourcePolicyStatement(_ input: DeleteResourcePolicyStatementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResourcePolicyStatementResponse {
        return try await self.client.execute(
            operation: "DeleteResourcePolicyStatement", 
            path: "/policy/{resourceArn}/statements/{statementId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified slot from an intent.
    @Sendable
    public func deleteSlot(_ input: DeleteSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a slot type from a bot locale. If a slot is using the slot type, Amazon Lex throws a ResourceInUseException exception. To avoid the exception, set the skipResourceInUseCheck parameter to true.
    @Sendable
    public func deleteSlotType(_ input: DeleteSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The action to delete the selected test set.
    @Sendable
    public func deleteTestSet(_ input: DeleteTestSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteTestSet", 
            path: "/testsets/{testSetId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes stored utterances. Amazon Lex stores the utterances that users send to your bot. Utterances are stored for 15 days for use with the ListAggregatedUtterances operation, and then stored indefinitely for use in improving the ability of your bot to respond to user input.. Use the DeleteUtterances operation to manually delete utterances for a specific session. When you use the DeleteUtterances operation, utterances stored for improving your bot's ability to respond to user input are deleted immediately. Utterances stored for use with the ListAggregatedUtterances operation are deleted after 15 days.
    @Sendable
    public func deleteUtterances(_ input: DeleteUtterancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteUtterancesResponse {
        return try await self.client.execute(
            operation: "DeleteUtterances", 
            path: "/bots/{botId}/utterances", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides metadata information about a bot.
    @Sendable
    public func describeBot(_ input: DescribeBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotResponse {
        return try await self.client.execute(
            operation: "DescribeBot", 
            path: "/bots/{botId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get information about a specific bot alias.
    @Sendable
    public func describeBotAlias(_ input: DescribeBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotAliasResponse {
        return try await self.client.execute(
            operation: "DescribeBotAlias", 
            path: "/bots/{botId}/botaliases/{botAliasId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Describes the settings that a bot has for a specific locale.
    @Sendable
    public func describeBotLocale(_ input: DescribeBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotLocaleResponse {
        return try await self.client.execute(
            operation: "DescribeBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides metadata information about a bot recommendation. This information will enable you to get a description on the request inputs, to download associated transcripts after processing is complete, and to download intents and slot-types generated by the bot recommendation.
    @Sendable
    public func describeBotRecommendation(_ input: DescribeBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotRecommendationResponse {
        return try await self.client.execute(
            operation: "DescribeBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Monitors the bot replication status through the UI console.
    @Sendable
    public func describeBotReplica(_ input: DescribeBotReplicaRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotReplicaResponse {
        return try await self.client.execute(
            operation: "DescribeBotReplica", 
            path: "/bots/{botId}/replicas/{replicaRegion}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about a request to generate a bot through natural language description, made through  the StartBotResource API. Use the generatedBotLocaleUrl  to retrieve the Amazon S3 object containing the bot locale configuration. You can  then modify and import this configuration.
    @Sendable
    public func describeBotResourceGeneration(_ input: DescribeBotResourceGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotResourceGenerationResponse {
        return try await self.client.execute(
            operation: "DescribeBotResourceGeneration", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generations/{generationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides metadata about a version of a bot.
    @Sendable
    public func describeBotVersion(_ input: DescribeBotVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotVersionResponse {
        return try await self.client.execute(
            operation: "DescribeBotVersion", 
            path: "/bots/{botId}/botversions/{botVersion}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides metadata information about a custom vocabulary.
    @Sendable
    public func describeCustomVocabularyMetadata(_ input: DescribeCustomVocabularyMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCustomVocabularyMetadataResponse {
        return try await self.client.execute(
            operation: "DescribeCustomVocabularyMetadata", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/metadata", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about a specific export.
    @Sendable
    public func describeExport(_ input: DescribeExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeExportResponse {
        return try await self.client.execute(
            operation: "DescribeExport", 
            path: "/exports/{exportId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about a specific import.
    @Sendable
    public func describeImport(_ input: DescribeImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeImportResponse {
        return try await self.client.execute(
            operation: "DescribeImport", 
            path: "/imports/{importId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns metadata about an intent.
    @Sendable
    public func describeIntent(_ input: DescribeIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeIntentResponse {
        return try await self.client.execute(
            operation: "DescribeIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets the resource policy and policy revision for a bot or bot alias.
    @Sendable
    public func describeResourcePolicy(_ input: DescribeResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeResourcePolicyResponse {
        return try await self.client.execute(
            operation: "DescribeResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets metadata information about a slot.
    @Sendable
    public func describeSlot(_ input: DescribeSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSlotResponse {
        return try await self.client.execute(
            operation: "DescribeSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets metadata information about a slot type.
    @Sendable
    public func describeSlotType(_ input: DescribeSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSlotTypeResponse {
        return try await self.client.execute(
            operation: "DescribeSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets metadata information about the test execution.
    @Sendable
    public func describeTestExecution(_ input: DescribeTestExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestExecutionResponse {
        return try await self.client.execute(
            operation: "DescribeTestExecution", 
            path: "/testexecutions/{testExecutionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets metadata information about the test set.
    @Sendable
    public func describeTestSet(_ input: DescribeTestSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestSetResponse {
        return try await self.client.execute(
            operation: "DescribeTestSet", 
            path: "/testsets/{testSetId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets metadata information about the test set discrepancy report.
    @Sendable
    public func describeTestSetDiscrepancyReport(_ input: DescribeTestSetDiscrepancyReportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestSetDiscrepancyReportResponse {
        return try await self.client.execute(
            operation: "DescribeTestSetDiscrepancyReport", 
            path: "/testsetdiscrepancy/{testSetDiscrepancyReportId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets metadata information about the test set generation.
    @Sendable
    public func describeTestSetGeneration(_ input: DescribeTestSetGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestSetGenerationResponse {
        return try await self.client.execute(
            operation: "DescribeTestSetGeneration", 
            path: "/testsetgenerations/{testSetGenerationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Generates sample utterances for an intent.
    @Sendable
    public func generateBotElement(_ input: GenerateBotElementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GenerateBotElementResponse {
        return try await self.client.execute(
            operation: "GenerateBotElement", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The pre-signed Amazon S3 URL to download the test execution result artifacts.
    @Sendable
    public func getTestExecutionArtifactsUrl(_ input: GetTestExecutionArtifactsUrlRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTestExecutionArtifactsUrlResponse {
        return try await self.client.execute(
            operation: "GetTestExecutionArtifactsUrl", 
            path: "/testexecutions/{testExecutionId}/artifacturl", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides a list of utterances that users have sent to the bot. Utterances are aggregated by the text of the utterance. For example, all instances where customers used the phrase "I want to order pizza" are aggregated into the same line in the response. You can see both detected utterances and missed utterances. A detected utterance is where the bot properly recognized the utterance and activated the associated intent. A missed utterance was not recognized by the bot and didn't activate an intent. Utterances can be aggregated for a bot alias or for a bot version, but not both at the same time. Utterances statistics are not generated under the following conditions:   The childDirected field was set to true when the bot was created.   You are using slot obfuscation with one or more slots.   You opted out of participating in improving Amazon Lex.
    @Sendable
    public func listAggregatedUtterances(_ input: ListAggregatedUtterancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAggregatedUtterancesResponse {
        return try await self.client.execute(
            operation: "ListAggregatedUtterances", 
            path: "/bots/{botId}/aggregatedutterances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The action to list the replicated bots created from the source bot alias.
    @Sendable
    public func listBotAliasReplicas(_ input: ListBotAliasReplicasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotAliasReplicasResponse {
        return try await self.client.execute(
            operation: "ListBotAliasReplicas", 
            path: "/bots/{botId}/replicas/{replicaRegion}/botaliases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of aliases for the specified bot.
    @Sendable
    public func listBotAliases(_ input: ListBotAliasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotAliasesResponse {
        return try await self.client.execute(
            operation: "ListBotAliases", 
            path: "/bots/{botId}/botaliases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of locales for the specified bot.
    @Sendable
    public func listBotLocales(_ input: ListBotLocalesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotLocalesResponse {
        return try await self.client.execute(
            operation: "ListBotLocales", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get a list of bot recommendations that meet the specified criteria.
    @Sendable
    public func listBotRecommendations(_ input: ListBotRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotRecommendationsResponse {
        return try await self.client.execute(
            operation: "ListBotRecommendations", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The action to list the replicated bots.
    @Sendable
    public func listBotReplicas(_ input: ListBotReplicasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotReplicasResponse {
        return try await self.client.execute(
            operation: "ListBotReplicas", 
            path: "/bots/{botId}/replicas", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the generation requests made for a bot locale.
    @Sendable
    public func listBotResourceGenerations(_ input: ListBotResourceGenerationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotResourceGenerationsResponse {
        return try await self.client.execute(
            operation: "ListBotResourceGenerations", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Contains information about all the versions replication statuses applicable for Global Resiliency.
    @Sendable
    public func listBotVersionReplicas(_ input: ListBotVersionReplicasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotVersionReplicasResponse {
        return try await self.client.execute(
            operation: "ListBotVersionReplicas", 
            path: "/bots/{botId}/replicas/{replicaRegion}/botversions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets information about all of the versions of a bot. The ListBotVersions operation returns a summary of each version of a bot. For example, if a bot has three numbered versions, the ListBotVersions operation returns for summaries, one for each numbered version and one for the DRAFT version. The ListBotVersions operation always returns at least one version, the DRAFT version.
    @Sendable
    public func listBotVersions(_ input: ListBotVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotVersionsResponse {
        return try await self.client.execute(
            operation: "ListBotVersions", 
            path: "/bots/{botId}/botversions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of available bots.
    @Sendable
    public func listBots(_ input: ListBotsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotsResponse {
        return try await self.client.execute(
            operation: "ListBots", 
            path: "/bots", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of built-in intents provided by Amazon Lex that you can use in your bot.  To use a built-in intent as a the base for your own intent, include the built-in intent signature in the parentIntentSignature parameter when you call the CreateIntent operation. For more information, see CreateIntent.
    @Sendable
    public func listBuiltInIntents(_ input: ListBuiltInIntentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBuiltInIntentsResponse {
        return try await self.client.execute(
            operation: "ListBuiltInIntents", 
            path: "/builtins/locales/{localeId}/intents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of built-in slot types that meet the specified criteria.
    @Sendable
    public func listBuiltInSlotTypes(_ input: ListBuiltInSlotTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBuiltInSlotTypesResponse {
        return try await self.client.execute(
            operation: "ListBuiltInSlotTypes", 
            path: "/builtins/locales/{localeId}/slottypes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Paginated list of custom vocabulary items for a given bot locale's  custom vocabulary.
    @Sendable
    public func listCustomVocabularyItems(_ input: ListCustomVocabularyItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCustomVocabularyItemsResponse {
        return try await self.client.execute(
            operation: "ListCustomVocabularyItems", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the exports for a bot, bot locale, or custom vocabulary. Exports are kept in the list for 7 days.
    @Sendable
    public func listExports(_ input: ListExportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListExportsResponse {
        return try await self.client.execute(
            operation: "ListExports", 
            path: "/exports", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists the imports for a bot, bot locale, or custom vocabulary. Imports are kept in the list for 7 days.
    @Sendable
    public func listImports(_ input: ListImportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImportsResponse {
        return try await self.client.execute(
            operation: "ListImports", 
            path: "/imports", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves summary metrics for the intents in your bot. The following fields are required:    metrics – A list of AnalyticsIntentMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can specify only one order in a given request.
    @Sendable
    public func listIntentMetrics(_ input: ListIntentMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentMetricsResponse {
        return try await self.client.execute(
            operation: "ListIntentMetrics", 
            path: "/bots/{botId}/analytics/intentmetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves summary statistics for a path of intents that users take over sessions with your bot. The following fields are required:    startDateTime and endDateTime – Define a time range for which you want to retrieve results.    intentPath – Define an order of intents for which you want to retrieve metrics. Separate intents in the path with a forward slash. For example, populate the intentPath field with /BookCar/BookHotel to see details about how many times users invoked the BookCar and BookHotel intents in that order.   Use the optional filters field to filter the results.
    @Sendable
    public func listIntentPaths(_ input: ListIntentPathsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentPathsResponse {
        return try await self.client.execute(
            operation: "ListIntentPaths", 
            path: "/bots/{botId}/analytics/intentpaths", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves summary metrics for the stages within intents in your bot. The following fields are required:    metrics – A list of AnalyticsIntentStageMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can only specify one order in a given request.
    @Sendable
    public func listIntentStageMetrics(_ input: ListIntentStageMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentStageMetricsResponse {
        return try await self.client.execute(
            operation: "ListIntentStageMetrics", 
            path: "/bots/{botId}/analytics/intentstagemetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get a list of intents that meet the specified criteria.
    @Sendable
    public func listIntents(_ input: ListIntentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentsResponse {
        return try await self.client.execute(
            operation: "ListIntents", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of recommended intents provided by the bot recommendation that you can use in your bot. Intents in the  response are ordered by relevance.
    @Sendable
    public func listRecommendedIntents(_ input: ListRecommendedIntentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRecommendedIntentsResponse {
        return try await self.client.execute(
            operation: "ListRecommendedIntents", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/intents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves a list of metadata for individual user sessions with your bot. The startDateTime and endDateTime fields are required. These fields define a time range for which you want to retrieve results. Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    @Sendable
    public func listSessionAnalyticsData(_ input: ListSessionAnalyticsDataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionAnalyticsDataResponse {
        return try await self.client.execute(
            operation: "ListSessionAnalyticsData", 
            path: "/bots/{botId}/analytics/sessions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves summary metrics for the user sessions with your bot. The following fields are required:    metrics – A list of AnalyticsSessionMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    @Sendable
    public func listSessionMetrics(_ input: ListSessionMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionMetricsResponse {
        return try await self.client.execute(
            operation: "ListSessionMetrics", 
            path: "/bots/{botId}/analytics/sessionmetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of slot types that match the specified criteria.
    @Sendable
    public func listSlotTypes(_ input: ListSlotTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSlotTypesResponse {
        return try await self.client.execute(
            operation: "ListSlotTypes", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of slots that match the specified criteria.
    @Sendable
    public func listSlots(_ input: ListSlotsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSlotsResponse {
        return try await self.client.execute(
            operation: "ListSlots", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of tags associated with a resource. Only bots, bot aliases, and bot channels can have tags associated with them.
    @Sendable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        return try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceARN}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a list of test execution result items.
    @Sendable
    public func listTestExecutionResultItems(_ input: ListTestExecutionResultItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestExecutionResultItemsResponse {
        return try await self.client.execute(
            operation: "ListTestExecutionResultItems", 
            path: "/testexecutions/{testExecutionId}/results", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The list of test set executions.
    @Sendable
    public func listTestExecutions(_ input: ListTestExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestExecutionsResponse {
        return try await self.client.execute(
            operation: "ListTestExecutions", 
            path: "/testexecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The list of test set records.
    @Sendable
    public func listTestSetRecords(_ input: ListTestSetRecordsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestSetRecordsResponse {
        return try await self.client.execute(
            operation: "ListTestSetRecords", 
            path: "/testsets/{testSetId}/records", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The list of the test sets
    @Sendable
    public func listTestSets(_ input: ListTestSetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestSetsResponse {
        return try await self.client.execute(
            operation: "ListTestSets", 
            path: "/testsets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves a list of metadata for individual user utterances to your bot. The following fields are required:    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    @Sendable
    public func listUtteranceAnalyticsData(_ input: ListUtteranceAnalyticsDataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListUtteranceAnalyticsDataResponse {
        return try await self.client.execute(
            operation: "ListUtteranceAnalyticsData", 
            path: "/bots/{botId}/analytics/utterances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves summary metrics for the utterances in your bot. The following fields are required:    metrics – A list of AnalyticsUtteranceMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    @Sendable
    public func listUtteranceMetrics(_ input: ListUtteranceMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListUtteranceMetricsResponse {
        return try await self.client.execute(
            operation: "ListUtteranceMetrics", 
            path: "/bots/{botId}/analytics/utterancemetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Search for associated transcripts that meet the specified criteria.
    @Sendable
    public func searchAssociatedTranscripts(_ input: SearchAssociatedTranscriptsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchAssociatedTranscriptsResponse {
        return try await self.client.execute(
            operation: "SearchAssociatedTranscripts", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/associatedtranscripts", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Use this to provide your transcript data, and to start the bot recommendation process.
    @Sendable
    public func startBotRecommendation(_ input: StartBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartBotRecommendationResponse {
        return try await self.client.execute(
            operation: "StartBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Starts a request for the descriptive bot builder to generate a bot locale configuration  based on the prompt you provide it. After you make this call, use the DescribeBotResourceGeneration  operation to check on the status of the generation and for the generatedBotLocaleUrl when the  generation is complete. Use that value to retrieve the Amazon S3 object containing the bot locale configuration. You can  then modify and import this configuration.
    @Sendable
    public func startBotResourceGeneration(_ input: StartBotResourceGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartBotResourceGenerationResponse {
        return try await self.client.execute(
            operation: "StartBotResourceGeneration", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/startgeneration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Starts importing a bot, bot locale, or custom vocabulary from a zip archive that you uploaded to an S3 bucket.
    @Sendable
    public func startImport(_ input: StartImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartImportResponse {
        return try await self.client.execute(
            operation: "StartImport", 
            path: "/imports", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The action to start test set execution.
    @Sendable
    public func startTestExecution(_ input: StartTestExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartTestExecutionResponse {
        return try await self.client.execute(
            operation: "StartTestExecution", 
            path: "/testsets/{testSetId}/testexecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The action to start the generation of test set.
    @Sendable
    public func startTestSetGeneration(_ input: StartTestSetGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartTestSetGenerationResponse {
        return try await self.client.execute(
            operation: "StartTestSetGeneration", 
            path: "/testsetgenerations", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Stop an already running Bot Recommendation request.
    @Sendable
    public func stopBotRecommendation(_ input: StopBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopBotRecommendationResponse {
        return try await self.client.execute(
            operation: "StopBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/stopbotrecommendation", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Adds the specified tags to the specified resource. If a tag key already exists, the existing value is replaced with the new value.
    @Sendable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        return try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceARN}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes tags from a bot, bot alias, or bot channel.
    @Sendable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        return try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceARN}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configuration of an existing bot.
    @Sendable
    public func updateBot(_ input: UpdateBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotResponse {
        return try await self.client.execute(
            operation: "UpdateBot", 
            path: "/bots/{botId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configuration of an existing bot alias.
    @Sendable
    public func updateBotAlias(_ input: UpdateBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotAliasResponse {
        return try await self.client.execute(
            operation: "UpdateBotAlias", 
            path: "/bots/{botId}/botaliases/{botAliasId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the settings that a bot has for a specific locale.
    @Sendable
    public func updateBotLocale(_ input: UpdateBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotLocaleResponse {
        return try await self.client.execute(
            operation: "UpdateBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates an existing bot recommendation request.
    @Sendable
    public func updateBotRecommendation(_ input: UpdateBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotRecommendationResponse {
        return try await self.client.execute(
            operation: "UpdateBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the password used to protect an export zip archive. The password is not required. If you don't supply a password, Amazon Lex generates a zip file that is not protected by a password. This is the archive that is available at the pre-signed S3 URL provided by the DescribeExport operation.
    @Sendable
    public func updateExport(_ input: UpdateExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateExportResponse {
        return try await self.client.execute(
            operation: "UpdateExport", 
            path: "/exports/{exportId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the settings for an intent.
    @Sendable
    public func updateIntent(_ input: UpdateIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIntentResponse {
        return try await self.client.execute(
            operation: "UpdateIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Replaces the existing resource policy for a bot or bot alias with a new one. If the policy doesn't exist, Amazon Lex returns an exception.
    @Sendable
    public func updateResourcePolicy(_ input: UpdateResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResourcePolicyResponse {
        return try await self.client.execute(
            operation: "UpdateResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the settings for a slot.
    @Sendable
    public func updateSlot(_ input: UpdateSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSlotResponse {
        return try await self.client.execute(
            operation: "UpdateSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates the configuration of an existing slot type.
    @Sendable
    public func updateSlotType(_ input: UpdateSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSlotTypeResponse {
        return try await self.client.execute(
            operation: "UpdateSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// The action to update the test set.
    @Sendable
    public func updateTestSet(_ input: UpdateTestSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTestSetResponse {
        return try await self.client.execute(
            operation: "UpdateTestSet", 
            path: "/testsets/{testSetId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
}

extension LexModelsV2 {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: LexModelsV2, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension LexModelsV2 {
    /// Provides a list of utterances that users have sent to the bot. Utterances are aggregated by the text of the utterance. For example, all instances where customers used the phrase "I want to order pizza" are aggregated into the same line in the response. You can see both detected utterances and missed utterances. A detected utterance is where the bot properly recognized the utterance and activated the associated intent. A missed utterance was not recognized by the bot and didn't activate an intent. Utterances can be aggregated for a bot alias or for a bot version, but not both at the same time. Utterances statistics are not generated under the following conditions:   The childDirected field was set to true when the bot was created.   You are using slot obfuscation with one or more slots.   You opted out of participating in improving Amazon Lex.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listAggregatedUtterancesPaginator(
        _ input: ListAggregatedUtterancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAggregatedUtterancesRequest, ListAggregatedUtterancesResponse> {
        return .init(
            input: input,
            command: self.listAggregatedUtterances,
            inputKey: \ListAggregatedUtterancesRequest.nextToken,
            outputKey: \ListAggregatedUtterancesResponse.nextToken,
            logger: logger
        )
    }

    /// The action to list the replicated bots created from the source bot alias.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotAliasReplicasPaginator(
        _ input: ListBotAliasReplicasRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotAliasReplicasRequest, ListBotAliasReplicasResponse> {
        return .init(
            input: input,
            command: self.listBotAliasReplicas,
            inputKey: \ListBotAliasReplicasRequest.nextToken,
            outputKey: \ListBotAliasReplicasResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of aliases for the specified bot.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotAliasesPaginator(
        _ input: ListBotAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotAliasesRequest, ListBotAliasesResponse> {
        return .init(
            input: input,
            command: self.listBotAliases,
            inputKey: \ListBotAliasesRequest.nextToken,
            outputKey: \ListBotAliasesResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of locales for the specified bot.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotLocalesPaginator(
        _ input: ListBotLocalesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotLocalesRequest, ListBotLocalesResponse> {
        return .init(
            input: input,
            command: self.listBotLocales,
            inputKey: \ListBotLocalesRequest.nextToken,
            outputKey: \ListBotLocalesResponse.nextToken,
            logger: logger
        )
    }

    /// Get a list of bot recommendations that meet the specified criteria.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotRecommendationsPaginator(
        _ input: ListBotRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotRecommendationsRequest, ListBotRecommendationsResponse> {
        return .init(
            input: input,
            command: self.listBotRecommendations,
            inputKey: \ListBotRecommendationsRequest.nextToken,
            outputKey: \ListBotRecommendationsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the generation requests made for a bot locale.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotResourceGenerationsPaginator(
        _ input: ListBotResourceGenerationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotResourceGenerationsRequest, ListBotResourceGenerationsResponse> {
        return .init(
            input: input,
            command: self.listBotResourceGenerations,
            inputKey: \ListBotResourceGenerationsRequest.nextToken,
            outputKey: \ListBotResourceGenerationsResponse.nextToken,
            logger: logger
        )
    }

    /// Contains information about all the versions replication statuses applicable for Global Resiliency.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotVersionReplicasPaginator(
        _ input: ListBotVersionReplicasRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotVersionReplicasRequest, ListBotVersionReplicasResponse> {
        return .init(
            input: input,
            command: self.listBotVersionReplicas,
            inputKey: \ListBotVersionReplicasRequest.nextToken,
            outputKey: \ListBotVersionReplicasResponse.nextToken,
            logger: logger
        )
    }

    /// Gets information about all of the versions of a bot. The ListBotVersions operation returns a summary of each version of a bot. For example, if a bot has three numbered versions, the ListBotVersions operation returns for summaries, one for each numbered version and one for the DRAFT version. The ListBotVersions operation always returns at least one version, the DRAFT version.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotVersionsPaginator(
        _ input: ListBotVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotVersionsRequest, ListBotVersionsResponse> {
        return .init(
            input: input,
            command: self.listBotVersions,
            inputKey: \ListBotVersionsRequest.nextToken,
            outputKey: \ListBotVersionsResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of available bots.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBotsPaginator(
        _ input: ListBotsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotsRequest, ListBotsResponse> {
        return .init(
            input: input,
            command: self.listBots,
            inputKey: \ListBotsRequest.nextToken,
            outputKey: \ListBotsResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of built-in intents provided by Amazon Lex that you can use in your bot.  To use a built-in intent as a the base for your own intent, include the built-in intent signature in the parentIntentSignature parameter when you call the CreateIntent operation. For more information, see CreateIntent.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBuiltInIntentsPaginator(
        _ input: ListBuiltInIntentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBuiltInIntentsRequest, ListBuiltInIntentsResponse> {
        return .init(
            input: input,
            command: self.listBuiltInIntents,
            inputKey: \ListBuiltInIntentsRequest.nextToken,
            outputKey: \ListBuiltInIntentsResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of built-in slot types that meet the specified criteria.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listBuiltInSlotTypesPaginator(
        _ input: ListBuiltInSlotTypesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBuiltInSlotTypesRequest, ListBuiltInSlotTypesResponse> {
        return .init(
            input: input,
            command: self.listBuiltInSlotTypes,
            inputKey: \ListBuiltInSlotTypesRequest.nextToken,
            outputKey: \ListBuiltInSlotTypesResponse.nextToken,
            logger: logger
        )
    }

    /// Paginated list of custom vocabulary items for a given bot locale's  custom vocabulary.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listCustomVocabularyItemsPaginator(
        _ input: ListCustomVocabularyItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCustomVocabularyItemsRequest, ListCustomVocabularyItemsResponse> {
        return .init(
            input: input,
            command: self.listCustomVocabularyItems,
            inputKey: \ListCustomVocabularyItemsRequest.nextToken,
            outputKey: \ListCustomVocabularyItemsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the exports for a bot, bot locale, or custom vocabulary. Exports are kept in the list for 7 days.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listExportsPaginator(
        _ input: ListExportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListExportsRequest, ListExportsResponse> {
        return .init(
            input: input,
            command: self.listExports,
            inputKey: \ListExportsRequest.nextToken,
            outputKey: \ListExportsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists the imports for a bot, bot locale, or custom vocabulary. Imports are kept in the list for 7 days.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImportsPaginator(
        _ input: ListImportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImportsRequest, ListImportsResponse> {
        return .init(
            input: input,
            command: self.listImports,
            inputKey: \ListImportsRequest.nextToken,
            outputKey: \ListImportsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves summary metrics for the intents in your bot. The following fields are required:    metrics – A list of AnalyticsIntentMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can specify only one order in a given request.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listIntentMetricsPaginator(
        _ input: ListIntentMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIntentMetricsRequest, ListIntentMetricsResponse> {
        return .init(
            input: input,
            command: self.listIntentMetrics,
            inputKey: \ListIntentMetricsRequest.nextToken,
            outputKey: \ListIntentMetricsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves summary metrics for the stages within intents in your bot. The following fields are required:    metrics – A list of AnalyticsIntentStageMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can only specify one order in a given request.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listIntentStageMetricsPaginator(
        _ input: ListIntentStageMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIntentStageMetricsRequest, ListIntentStageMetricsResponse> {
        return .init(
            input: input,
            command: self.listIntentStageMetrics,
            inputKey: \ListIntentStageMetricsRequest.nextToken,
            outputKey: \ListIntentStageMetricsResponse.nextToken,
            logger: logger
        )
    }

    /// Get a list of intents that meet the specified criteria.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listIntentsPaginator(
        _ input: ListIntentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIntentsRequest, ListIntentsResponse> {
        return .init(
            input: input,
            command: self.listIntents,
            inputKey: \ListIntentsRequest.nextToken,
            outputKey: \ListIntentsResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of recommended intents provided by the bot recommendation that you can use in your bot. Intents in the  response are ordered by relevance.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listRecommendedIntentsPaginator(
        _ input: ListRecommendedIntentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRecommendedIntentsRequest, ListRecommendedIntentsResponse> {
        return .init(
            input: input,
            command: self.listRecommendedIntents,
            inputKey: \ListRecommendedIntentsRequest.nextToken,
            outputKey: \ListRecommendedIntentsResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves a list of metadata for individual user sessions with your bot. The startDateTime and endDateTime fields are required. These fields define a time range for which you want to retrieve results. Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listSessionAnalyticsDataPaginator(
        _ input: ListSessionAnalyticsDataRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionAnalyticsDataRequest, ListSessionAnalyticsDataResponse> {
        return .init(
            input: input,
            command: self.listSessionAnalyticsData,
            inputKey: \ListSessionAnalyticsDataRequest.nextToken,
            outputKey: \ListSessionAnalyticsDataResponse.nextToken,
            logger: logger
        )
    }

    /// Retrieves summary metrics for the user sessions with your bot. The following fields are required:    metrics – A list of AnalyticsSessionMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listSessionMetricsPaginator(
        _ input: ListSessionMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionMetricsRequest, ListSessionMetricsResponse> {
        return .init(
            input: input,
            command: self.listSessionMetrics,
            inputKey: \ListSessionMetricsRequest.nextToken,
            outputKey: \ListSessionMetricsResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of slot types that match the specified criteria.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listSlotTypesPaginator(
        _ input: ListSlotTypesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSlotTypesRequest, ListSlotTypesResponse> {
        return .init(
            input: input,
            command: self.listSlotTypes,
            inputKey: \ListSlotTypesRequest.nextToken,
            outputKey: \ListSlotTypesResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of slots that match the specified criteria.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listSlotsPaginator(
        _ input: ListSlotsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSlotsRequest, ListSlotsResponse> {
        return .init(
            input: input,
            command: self.listSlots,
            inputKey: \ListSlotsRequest.nextToken,
            outputKey: \ListSlotsResponse.nextToken,
            logger: logger
        )
    }

    /// Gets a list of test execution result items.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listTestExecutionResultItemsPaginator(
        _ input: ListTestExecutionResultItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestExecutionResultItemsRequest, ListTestExecutionResultItemsResponse> {
        return .init(
            input: input,
            command: self.listTestExecutionResultItems,
            inputKey: \ListTestExecutionResultItemsRequest.nextToken,
            outputKey: \ListTestExecutionResultItemsResponse.nextToken,
            logger: logger
        )
    }

    /// The list of test set executions.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listTestExecutionsPaginator(
        _ input: ListTestExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestExecutionsRequest, ListTestExecutionsResponse> {
        return .init(
            input: input,
            command: self.listTestExecutions,
            inputKey: \ListTestExecutionsRequest.nextToken,
            outputKey: \ListTestExecutionsResponse.nextToken,
            logger: logger
        )
    }

    /// The list of test set records.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listTestSetRecordsPaginator(
        _ input: ListTestSetRecordsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestSetRecordsRequest, ListTestSetRecordsResponse> {
        return .init(
            input: input,
            command: self.listTestSetRecords,
            inputKey: \ListTestSetRecordsRequest.nextToken,
            outputKey: \ListTestSetRecordsResponse.nextToken,
            logger: logger
        )
    }

    /// The list of the test sets
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listTestSetsPaginator(
        _ input: ListTestSetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestSetsRequest, ListTestSetsResponse> {
        return .init(
            input: input,
            command: self.listTestSets,
            inputKey: \ListTestSetsRequest.nextToken,
            outputKey: \ListTestSetsResponse.nextToken,
            logger: logger
        )
    }

    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves a list of metadata for individual user utterances to your bot. The following fields are required:    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listUtteranceAnalyticsDataPaginator(
        _ input: ListUtteranceAnalyticsDataRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListUtteranceAnalyticsDataRequest, ListUtteranceAnalyticsDataResponse> {
        return .init(
            input: input,
            command: self.listUtteranceAnalyticsData,
            inputKey: \ListUtteranceAnalyticsDataRequest.nextToken,
            outputKey: \ListUtteranceAnalyticsDataResponse.nextToken,
            logger: logger
        )
    }

    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves summary metrics for the utterances in your bot. The following fields are required:    metrics – A list of AnalyticsUtteranceMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime – Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listUtteranceMetricsPaginator(
        _ input: ListUtteranceMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListUtteranceMetricsRequest, ListUtteranceMetricsResponse> {
        return .init(
            input: input,
            command: self.listUtteranceMetrics,
            inputKey: \ListUtteranceMetricsRequest.nextToken,
            outputKey: \ListUtteranceMetricsResponse.nextToken,
            logger: logger
        )
    }
}

extension LexModelsV2.ListAggregatedUtterancesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListAggregatedUtterancesRequest {
        return .init(
            aggregationDuration: self.aggregationDuration,
            botAliasId: self.botAliasId,
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotAliasReplicasRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotAliasReplicasRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            replicaRegion: self.replicaRegion
        )
    }
}

extension LexModelsV2.ListBotAliasesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotAliasesRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListBotLocalesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotLocalesRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotRecommendationsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListBotResourceGenerationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotResourceGenerationsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotVersionReplicasRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotVersionReplicasRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            replicaRegion: self.replicaRegion,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotVersionsRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBuiltInIntentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBuiltInIntentsRequest {
        return .init(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBuiltInSlotTypesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBuiltInSlotTypesRequest {
        return .init(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListCustomVocabularyItemsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListCustomVocabularyItemsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListExportsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListExportsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListImportsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListImportsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListIntentMetricsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListIntentMetricsRequest {
        return .init(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListIntentStageMetricsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListIntentStageMetricsRequest {
        return .init(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListIntentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListIntentsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListRecommendedIntentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListRecommendedIntentsRequest {
        return .init(
            botId: self.botId,
            botRecommendationId: self.botRecommendationId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListSessionAnalyticsDataRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSessionAnalyticsDataRequest {
        return .init(
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListSessionMetricsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSessionMetricsRequest {
        return .init(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListSlotTypesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSlotTypesRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListSlotsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSlotsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            intentId: self.intentId,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListTestExecutionResultItemsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestExecutionResultItemsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resultFilterBy: self.resultFilterBy,
            testExecutionId: self.testExecutionId
        )
    }
}

extension LexModelsV2.ListTestExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestExecutionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListTestSetRecordsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestSetRecordsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            testSetId: self.testSetId
        )
    }
}

extension LexModelsV2.ListTestSetsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestSetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListUtteranceAnalyticsDataRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListUtteranceAnalyticsDataRequest {
        return .init(
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListUtteranceMetricsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListUtteranceMetricsRequest {
        return .init(
            attributes: self.attributes,
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension LexModelsV2 {
    public func waitUntilBotAliasAvailable(
        _ input: DescribeBotAliasRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botAliasStatus", expected: "Available")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botAliasStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botAliasStatus", expected: "Deleting")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotAlias
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilBotAvailable(
        _ input: DescribeBotRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botStatus", expected: "Available")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Inactive")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBot
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilBotExportCompleted(
        _ input: DescribeExportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("exportStatus", expected: "Completed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("exportStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("exportStatus", expected: "Failed")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeExport
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilBotImportCompleted(
        _ input: DescribeImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("importStatus", expected: "Completed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("importStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("importStatus", expected: "Failed")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeImport
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilBotLocaleBuilt(
        _ input: DescribeBotLocaleRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Built")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "NotBuilt")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotLocale
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilBotLocaleCreated(
        _ input: DescribeBotLocaleRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Built")),
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "ReadyExpressTesting")),
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "NotBuilt")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Failed")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotLocale
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilBotLocaleExpressTestingAvailable(
        _ input: DescribeBotLocaleRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Built")),
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "ReadyExpressTesting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "NotBuilt")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotLocale
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilBotVersionAvailable(
        _ input: DescribeBotVersionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botStatus", expected: "Available")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Failed")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotVersion
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
}
