//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS LexModelsV2 service.
public struct LexModelsV2: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the LexModelsV2 client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "LexModelsV2",
            serviceIdentifier: "models-v2-lex",
            signingName: "lex",
            serviceProtocol: .restjson,
            apiVersion: "2020-08-07",
            endpoint: endpoint,
            errorType: LexModelsV2ErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Create a batch of custom vocabulary items for a given bot locale's  custom vocabulary.
    @Sendable
    @inlinable
    public func batchCreateCustomVocabularyItem(_ input: BatchCreateCustomVocabularyItemRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreateCustomVocabularyItemResponse {
        try await self.client.execute(
            operation: "BatchCreateCustomVocabularyItem", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchcreate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a batch of custom vocabulary items for a given bot locale's  custom vocabulary.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with this custom vocabulary.
    ///   - botVersion: The identifier of the version of the bot associated with this  custom vocabulary.
    ///   - customVocabularyItemList: A list of new custom vocabulary items. Each entry must contain a phrase and can optionally contain a displayAs and/or a weight.
    ///   - localeId: The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see  Supported Languages .
    ///   - logger: Logger use during operation
    @inlinable
    public func batchCreateCustomVocabularyItem(
        botId: String,
        botVersion: String,
        customVocabularyItemList: [NewCustomVocabularyItem],
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchCreateCustomVocabularyItemResponse {
        let input = BatchCreateCustomVocabularyItemRequest(
            botId: botId, 
            botVersion: botVersion, 
            customVocabularyItemList: customVocabularyItemList, 
            localeId: localeId
        )
        return try await self.batchCreateCustomVocabularyItem(input, logger: logger)
    }

    /// Delete a batch of custom vocabulary items for a given bot locale's  custom vocabulary.
    @Sendable
    @inlinable
    public func batchDeleteCustomVocabularyItem(_ input: BatchDeleteCustomVocabularyItemRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteCustomVocabularyItemResponse {
        try await self.client.execute(
            operation: "BatchDeleteCustomVocabularyItem", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchdelete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a batch of custom vocabulary items for a given bot locale's  custom vocabulary.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with this custom vocabulary.
    ///   - botVersion: The identifier of the version of the bot associated with this custom  vocabulary.
    ///   - customVocabularyItemList: A list of custom vocabulary items requested to be deleted. Each entry must contain the unique custom vocabulary entry identifier.
    ///   - localeId: The identifier of the language and locale where this custom vocabulary is  used. The string must match one of the supported locales.  For more information, see  Supported Languages .
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteCustomVocabularyItem(
        botId: String,
        botVersion: String,
        customVocabularyItemList: [CustomVocabularyEntryId],
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteCustomVocabularyItemResponse {
        let input = BatchDeleteCustomVocabularyItemRequest(
            botId: botId, 
            botVersion: botVersion, 
            customVocabularyItemList: customVocabularyItemList, 
            localeId: localeId
        )
        return try await self.batchDeleteCustomVocabularyItem(input, logger: logger)
    }

    /// Update a batch of custom vocabulary items for a given bot locale's custom  vocabulary.
    @Sendable
    @inlinable
    public func batchUpdateCustomVocabularyItem(_ input: BatchUpdateCustomVocabularyItemRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateCustomVocabularyItemResponse {
        try await self.client.execute(
            operation: "BatchUpdateCustomVocabularyItem", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/batchupdate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a batch of custom vocabulary items for a given bot locale's custom  vocabulary.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with this custom vocabulary
    ///   - botVersion: The identifier of the version of the bot associated with this custom  vocabulary.
    ///   - customVocabularyItemList: A list of custom vocabulary items with updated fields. Each entry must contain a phrase and can optionally contain a displayAs and/or a weight.
    ///   - localeId: The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see  Supported Languages .
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateCustomVocabularyItem(
        botId: String,
        botVersion: String,
        customVocabularyItemList: [CustomVocabularyItem],
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateCustomVocabularyItemResponse {
        let input = BatchUpdateCustomVocabularyItemRequest(
            botId: botId, 
            botVersion: botVersion, 
            customVocabularyItemList: customVocabularyItemList, 
            localeId: localeId
        )
        return try await self.batchUpdateCustomVocabularyItem(input, logger: logger)
    }

    /// Builds a bot, its intents, and its slot types into a specific  locale. A bot can be built into multiple locales. At runtime the locale is used to choose a specific build of the bot.
    @Sendable
    @inlinable
    public func buildBotLocale(_ input: BuildBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BuildBotLocaleResponse {
        try await self.client.execute(
            operation: "BuildBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Builds a bot, its intents, and its slot types into a specific  locale. A bot can be built into multiple locales. At runtime the locale is used to choose a specific build of the bot.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot to build. The identifier is returned in the response from the CreateBot operation.
    ///   - botVersion: The version of the bot to build. This can only be the draft version of the bot.
    ///   - localeId: The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see Supported languages.
    ///   - logger: Logger use during operation
    @inlinable
    public func buildBotLocale(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BuildBotLocaleResponse {
        let input = BuildBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        return try await self.buildBotLocale(input, logger: logger)
    }

    /// Creates an Amazon Lex conversational bot.
    @Sendable
    @inlinable
    public func createBot(_ input: CreateBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotResponse {
        try await self.client.execute(
            operation: "CreateBot", 
            path: "/bots", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an Amazon Lex conversational bot.
    ///
    /// Parameters:
    ///   - botMembers: The list of bot members in a network to be created.
    ///   - botName: The name of the bot. The bot name must be unique in the account that creates the bot.
    ///   - botTags: A list of tags to add to the bot. You can only add tags when you create a bot. You can't use the UpdateBot operation to update tags. To update tags, use the TagResource operation.
    ///   - botType: The type of a bot to create.
    ///   - dataPrivacy: Provides information on additional privacy protections Amazon Lex should use with the bot's data.
    ///   - description: A description of the bot. It appears in lists to help you identify a particular bot.
    ///   - errorLogSettings: Specifies the configuration for error logging during bot creation.
    ///   - idleSessionTTLInSeconds: The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot.  A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
    ///   - roleArn: The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot.
    ///   - testBotAliasTags: A list of tags to add to the test alias for a bot. You can only add tags when you create a bot. You can't use the UpdateAlias operation to update tags. To update tags on the test alias, use the TagResource operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBot(
        botMembers: [BotMember]? = nil,
        botName: String,
        botTags: [String: String]? = nil,
        botType: BotType? = nil,
        dataPrivacy: DataPrivacy,
        description: String? = nil,
        errorLogSettings: ErrorLogSettings? = nil,
        idleSessionTTLInSeconds: Int,
        roleArn: String,
        testBotAliasTags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBotResponse {
        let input = CreateBotRequest(
            botMembers: botMembers, 
            botName: botName, 
            botTags: botTags, 
            botType: botType, 
            dataPrivacy: dataPrivacy, 
            description: description, 
            errorLogSettings: errorLogSettings, 
            idleSessionTTLInSeconds: idleSessionTTLInSeconds, 
            roleArn: roleArn, 
            testBotAliasTags: testBotAliasTags
        )
        return try await self.createBot(input, logger: logger)
    }

    /// Creates an alias for the specified version of a bot. Use an alias to enable you to change the version of a bot without updating applications that use the bot. For example, you can create an alias called "PROD" that your applications use to call the Amazon Lex bot.
    @Sendable
    @inlinable
    public func createBotAlias(_ input: CreateBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotAliasResponse {
        try await self.client.execute(
            operation: "CreateBotAlias", 
            path: "/bots/{botId}/botaliases", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an alias for the specified version of a bot. Use an alias to enable you to change the version of a bot without updating applications that use the bot. For example, you can create an alias called "PROD" that your applications use to call the Amazon Lex bot.
    ///
    /// Parameters:
    ///   - botAliasLocaleSettings: Maps configuration information to a specific locale. You can use this parameter to specify a specific Lambda function to run different functions in different locales.
    ///   - botAliasName: The alias to create. The name must be unique for the bot.
    ///   - botId: The unique identifier of the bot that the alias applies to.
    ///   - botVersion: The version of the bot that this alias points to. You can use the UpdateBotAlias operation to change the bot version associated with the alias.
    ///   - conversationLogSettings: Specifies whether Amazon Lex logs text and audio for a conversation with the bot. When you enable conversation logs, text logs store text input, transcripts of audio input, and associated metadata in Amazon CloudWatch Logs. Audio logs store audio input in Amazon S3.
    ///   - description: A description of the alias. Use this description to help identify the alias.
    ///   - sentimentAnalysisSettings: 
    ///   - tags: A list of tags to add to the bot alias. You can only add tags when you create an alias, you can't use the UpdateBotAlias operation to update the tags on a bot alias. To update tags, use the TagResource operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBotAlias(
        botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil,
        botAliasName: String,
        botId: String,
        botVersion: String? = nil,
        conversationLogSettings: ConversationLogSettings? = nil,
        description: String? = nil,
        sentimentAnalysisSettings: SentimentAnalysisSettings? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBotAliasResponse {
        let input = CreateBotAliasRequest(
            botAliasLocaleSettings: botAliasLocaleSettings, 
            botAliasName: botAliasName, 
            botId: botId, 
            botVersion: botVersion, 
            conversationLogSettings: conversationLogSettings, 
            description: description, 
            sentimentAnalysisSettings: sentimentAnalysisSettings, 
            tags: tags
        )
        return try await self.createBotAlias(input, logger: logger)
    }

    /// Creates a locale in the bot. The locale contains the intents and slot types that the bot uses in conversations with users in the specified language and locale. You must add a locale to a bot before you can add intents and slot types to the bot.
    @Sendable
    @inlinable
    public func createBotLocale(_ input: CreateBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotLocaleResponse {
        try await self.client.execute(
            operation: "CreateBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a locale in the bot. The locale contains the intents and slot types that the bot uses in conversations with users in the specified language and locale. You must add a locale to a bot before you can add intents and slot types to the bot.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot to create the locale for.
    ///   - botVersion: The version of the bot to create the locale for. This can only be the draft version of the bot.
    ///   - description: A description of the bot locale. Use this to help identify the bot locale in lists.
    ///   - generativeAISettings: 
    ///   - localeId: The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see Supported languages.
    ///   - nluIntentConfidenceThreshold: Determines the threshold where Amazon Lex will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot. For example, suppose a bot is configured with the confidence threshold of 0.80 and the AMAZON.FallbackIntent. Amazon Lex returns three alternative intents with the following confidence scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the RecognizeText operation would be:   AMAZON.FallbackIntent   IntentA   IntentB   IntentC
    ///   - voiceSettings: The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBotLocale(
        botId: String,
        botVersion: String,
        description: String? = nil,
        generativeAISettings: GenerativeAISettings? = nil,
        localeId: String,
        nluIntentConfidenceThreshold: Double,
        voiceSettings: VoiceSettings? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBotLocaleResponse {
        let input = CreateBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            description: description, 
            generativeAISettings: generativeAISettings, 
            localeId: localeId, 
            nluIntentConfidenceThreshold: nluIntentConfidenceThreshold, 
            voiceSettings: voiceSettings
        )
        return try await self.createBotLocale(input, logger: logger)
    }

    /// Action to create a replication of the source bot in the secondary region.
    @Sendable
    @inlinable
    public func createBotReplica(_ input: CreateBotReplicaRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotReplicaResponse {
        try await self.client.execute(
            operation: "CreateBotReplica", 
            path: "/bots/{botId}/replicas", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Action to create a replication of the source bot in the secondary region.
    ///
    /// Parameters:
    ///   - botId: The request for the unique bot ID of the source bot to be replicated in the secondary region.
    ///   - replicaRegion: The request for the secondary region that will be used in the replication of the source bot.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBotReplica(
        botId: String,
        replicaRegion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBotReplicaResponse {
        let input = CreateBotReplicaRequest(
            botId: botId, 
            replicaRegion: replicaRegion
        )
        return try await self.createBotReplica(input, logger: logger)
    }

    /// Creates an immutable version of the bot. When you create the first  version of a bot, Amazon Lex sets the version number to 1. Subsequent bot versions increase  in an increment of 1. The version number will always represent the total number  of versions created of the bot, not the current number of versions. If a bot version is deleted, that bot version number will not be reused.
    @Sendable
    @inlinable
    public func createBotVersion(_ input: CreateBotVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBotVersionResponse {
        try await self.client.execute(
            operation: "CreateBotVersion", 
            path: "/bots/{botId}/botversions", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an immutable version of the bot. When you create the first  version of a bot, Amazon Lex sets the version number to 1. Subsequent bot versions increase  in an increment of 1. The version number will always represent the total number  of versions created of the bot, not the current number of versions. If a bot version is deleted, that bot version number will not be reused.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot to create the version for.
    ///   - botVersionLocaleSpecification: Specifies the locales that Amazon Lex adds to this version. You can choose the Draft version or any other previously published version for each locale. When you specify a source version, the locale data is copied from the source version to the new version.
    ///   - description: A description of the version. Use the description to help identify the version in lists.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBotVersion(
        botId: String,
        botVersionLocaleSpecification: [String: BotVersionLocaleDetails],
        description: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBotVersionResponse {
        let input = CreateBotVersionRequest(
            botId: botId, 
            botVersionLocaleSpecification: botVersionLocaleSpecification, 
            description: description
        )
        return try await self.createBotVersion(input, logger: logger)
    }

    /// Creates a zip archive containing the contents of a bot or a bot locale. The archive contains a directory structure that contains JSON files that define the bot. You can create an archive that contains the complete definition of a bot, or you can specify that the archive contain only the definition of a single bot locale. For more information about exporting bots, and about the structure of the export archive, see  Importing and exporting bots
    @Sendable
    @inlinable
    public func createExport(_ input: CreateExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateExportResponse {
        try await self.client.execute(
            operation: "CreateExport", 
            path: "/exports", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a zip archive containing the contents of a bot or a bot locale. The archive contains a directory structure that contains JSON files that define the bot. You can create an archive that contains the complete definition of a bot, or you can specify that the archive contain only the definition of a single bot locale. For more information about exporting bots, and about the structure of the export archive, see  Importing and exporting bots
    ///
    /// Parameters:
    ///   - fileFormat: The file format of the bot or bot locale definition files.
    ///   - filePassword: An password to use to encrypt the exported archive. Using a password is optional, but you should encrypt the archive to protect the data in transit between Amazon Lex and your local computer.
    ///   - resourceSpecification: Specifies the type of resource to export, either a bot or a bot locale. You can only specify one type of resource to export.
    ///   - logger: Logger use during operation
    @inlinable
    public func createExport(
        fileFormat: ImportExportFileFormat,
        filePassword: String? = nil,
        resourceSpecification: ExportResourceSpecification,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateExportResponse {
        let input = CreateExportRequest(
            fileFormat: fileFormat, 
            filePassword: filePassword, 
            resourceSpecification: resourceSpecification
        )
        return try await self.createExport(input, logger: logger)
    }

    /// Creates an intent. To define the interaction between the user and your bot, you define one or more intents. For example, for a pizza ordering bot you would create an OrderPizza intent. When you create an intent, you must provide a name. You can optionally provide the following:   Sample utterances. For example, "I want to order a pizza" and "Can I order a pizza." You can't provide utterances for built-in intents.   Information to be gathered. You specify slots for the information that you bot requests from the user. You can specify standard slot types, such as date and time, or custom slot types for your application.   How the intent is fulfilled. You can provide a Lambda function or configure the intent to return the intent information to your client application. If you use a Lambda function, Amazon Lex invokes the function when all of the intent information is available.   A confirmation prompt to send to the user to confirm an intent. For example, "Shall I order your pizza?"   A conclusion statement to send to the user after the intent is fulfilled. For example, "I ordered your pizza."   A follow-up prompt that asks the user for additional activity. For example, "Do you want a drink with your pizza?"
    @Sendable
    @inlinable
    public func createIntent(_ input: CreateIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIntentResponse {
        try await self.client.execute(
            operation: "CreateIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an intent. To define the interaction between the user and your bot, you define one or more intents. For example, for a pizza ordering bot you would create an OrderPizza intent. When you create an intent, you must provide a name. You can optionally provide the following:   Sample utterances. For example, "I want to order a pizza" and "Can I order a pizza." You can't provide utterances for built-in intents.   Information to be gathered. You specify slots for the information that you bot requests from the user. You can specify standard slot types, such as date and time, or custom slot types for your application.   How the intent is fulfilled. You can provide a Lambda function or configure the intent to return the intent information to your client application. If you use a Lambda function, Amazon Lex invokes the function when all of the intent information is available.   A confirmation prompt to send to the user to confirm an intent. For example, "Shall I order your pizza?"   A conclusion statement to send to the user after the intent is fulfilled. For example, "I ordered your pizza."   A follow-up prompt that asks the user for additional activity. For example, "Do you want a drink with your pizza?"
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with this intent.
    ///   - botVersion: The version of the bot associated with this intent.
    ///   - description: A description of the intent. Use the description to help identify the intent in lists.
    ///   - dialogCodeHook: Specifies that Amazon Lex invokes the alias Lambda function for each user input. You can invoke this Lambda function to personalize user interaction. For example, suppose that your bot determines that the user's name is John. You Lambda function might retrieve John's information from a backend database and prepopulate some of the values. For example, if you find that John is gluten intolerant, you might set the corresponding intent slot, glutenIntolerant to true. You might find John's phone number and set the corresponding session attribute.
    ///   - fulfillmentCodeHook: Specifies that Amazon Lex invokes the alias Lambda function when the intent is ready for fulfillment. You can invoke this function to complete the bot's transaction with the user. For example, in a pizza ordering bot, the Lambda function can look up the closest pizza restaurant to the customer's location and then place an order on the customer's behalf.
    ///   - initialResponseSetting: Configuration settings for the response that is sent to the user at the beginning of a conversation, before eliciting slot values.
    ///   - inputContexts: A list of contexts that must be active for this intent to be considered by Amazon Lex. When an intent has an input context list, Amazon Lex only considers using the intent in an interaction with the user when the specified contexts are included in the active context list for the session. If the contexts are not active, then Amazon Lex will not use the intent. A context can be automatically activated using the outputContexts property or it can be set at runtime. For example, if there are two intents with different input contexts that respond to the same utterances, only the intent with the active context will respond. An intent may have up to 5 input contexts. If an intent has multiple input contexts, all of the contexts must be active to consider the intent.
    ///   - intentClosingSetting: Sets the response that Amazon Lex sends to the user when the intent is closed.
    ///   - intentConfirmationSetting: Provides prompts that Amazon Lex sends to the user to confirm the completion of an intent. If the user answers "no," the settings contain a statement that is sent to the user to end the intent.
    ///   - intentName: The name of the intent. Intent names must be unique in the locale that contains the intent and cannot match the name of any built-in intent.
    ///   - kendraConfiguration: Configuration information required to use the AMAZON.KendraSearchIntent intent to connect to an Amazon Kendra index. The AMAZON.KendraSearchIntent intent is called when Amazon Lex can't determine another intent to invoke.
    ///   - localeId: The identifier of the language and locale where this intent is used. All of the bots, slot types, and slots used by the intent must have the same locale. For more information, see Supported languages.
    ///   - outputContexts: A lists of contexts that the intent activates when it is fulfilled. You can use an output context to indicate the intents that Amazon Lex should consider for the next turn of the conversation with a customer.  When you use the outputContextsList property, all of the contexts specified in the list are activated when the intent is fulfilled. You can set up to 10 output contexts. You can also set the number of conversation turns that the context should be active, or the length of time that the context should be active.
    ///   - parentIntentSignature: A unique identifier for the built-in intent to base this intent on.
    ///   - qInConnectIntentConfiguration: Qinconnect intent configuration details for the create intent request.
    ///   - qnAIntentConfiguration: Specifies the configuration of the built-in Amazon.QnAIntent. The AMAZON.QnAIntent intent is called when Amazon Lex can't determine another intent to invoke. If you specify this field, you can't specify the kendraConfiguration field.
    ///   - sampleUtterances: An array of strings that a user might say to signal the intent. For example, "I want a pizza", or "I want a {PizzaSize} pizza".  In an utterance, slot names are enclosed in curly braces ("{", "}") to indicate where they should be displayed in the utterance shown to the user..
    ///   - logger: Logger use during operation
    @inlinable
    public func createIntent(
        botId: String,
        botVersion: String,
        description: String? = nil,
        dialogCodeHook: DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil,
        initialResponseSetting: InitialResponseSetting? = nil,
        inputContexts: [InputContext]? = nil,
        intentClosingSetting: IntentClosingSetting? = nil,
        intentConfirmationSetting: IntentConfirmationSetting? = nil,
        intentName: String,
        kendraConfiguration: KendraConfiguration? = nil,
        localeId: String,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil,
        qInConnectIntentConfiguration: QInConnectIntentConfiguration? = nil,
        qnAIntentConfiguration: QnAIntentConfiguration? = nil,
        sampleUtterances: [SampleUtterance]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIntentResponse {
        let input = CreateIntentRequest(
            botId: botId, 
            botVersion: botVersion, 
            description: description, 
            dialogCodeHook: dialogCodeHook, 
            fulfillmentCodeHook: fulfillmentCodeHook, 
            initialResponseSetting: initialResponseSetting, 
            inputContexts: inputContexts, 
            intentClosingSetting: intentClosingSetting, 
            intentConfirmationSetting: intentConfirmationSetting, 
            intentName: intentName, 
            kendraConfiguration: kendraConfiguration, 
            localeId: localeId, 
            outputContexts: outputContexts, 
            parentIntentSignature: parentIntentSignature, 
            qInConnectIntentConfiguration: qInConnectIntentConfiguration, 
            qnAIntentConfiguration: qnAIntentConfiguration, 
            sampleUtterances: sampleUtterances
        )
        return try await self.createIntent(input, logger: logger)
    }

    /// Creates a new resource policy with the specified policy statements.
    @Sendable
    @inlinable
    public func createResourcePolicy(_ input: CreateResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResourcePolicyResponse {
        try await self.client.execute(
            operation: "CreateResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new resource policy with the specified policy statements.
    ///
    /// Parameters:
    ///   - policy: A resource policy to add to the resource. The policy is a JSON structure that contains one or more statements that define the policy. The policy must follow the IAM syntax. For more information about the contents of a JSON policy document, see  IAM JSON policy reference .  If the policy isn't valid, Amazon Lex returns a validation exception.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    ///   - logger: Logger use during operation
    @inlinable
    public func createResourcePolicy(
        policy: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateResourcePolicyResponse {
        let input = CreateResourcePolicyRequest(
            policy: policy, 
            resourceArn: resourceArn
        )
        return try await self.createResourcePolicy(input, logger: logger)
    }

    /// Adds a new resource policy statement to a bot or bot alias. If a resource policy exists, the statement is added to the current resource policy. If a policy doesn't exist, a new policy is created. You can't create a resource policy statement that allows cross-account access. You need to add the CreateResourcePolicy or UpdateResourcePolicy  action to the bot role in order to call the API.
    @Sendable
    @inlinable
    public func createResourcePolicyStatement(_ input: CreateResourcePolicyStatementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResourcePolicyStatementResponse {
        try await self.client.execute(
            operation: "CreateResourcePolicyStatement", 
            path: "/policy/{resourceArn}/statements", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a new resource policy statement to a bot or bot alias. If a resource policy exists, the statement is added to the current resource policy. If a policy doesn't exist, a new policy is created. You can't create a resource policy statement that allows cross-account access. You need to add the CreateResourcePolicy or UpdateResourcePolicy  action to the bot role in order to call the API.
    ///
    /// Parameters:
    ///   - action: The Amazon Lex action that this policy either allows or denies. The action must apply to the resource type of the specified ARN. For more information, see  Actions, resources, and condition keys for Amazon Lex V2.
    ///   - condition: Specifies a condition when the policy is in effect. If the principal of the policy is a service principal, you must provide two condition blocks, one with a SourceAccount global condition key and one with a SourceArn global condition key. For more information, see IAM JSON policy elements: Condition .
    ///   - effect: Determines whether the statement allows or denies access to the resource.
    ///   - expectedRevisionId: The identifier of the revision of the policy to edit. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex overwrites the contents of the policy with the new values.
    ///   - principal: An IAM principal, such as an IAM user, IAM role,  or Amazon Web Services services that is allowed or denied access to a resource. For more information, see Amazon Web Services JSON policy elements: Principal.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    ///   - statementId: The name of the statement. The ID is the same as the Sid IAM property. The statement name must be unique within the policy. For more information, see IAM JSON policy elements: Sid.
    ///   - logger: Logger use during operation
    @inlinable
    public func createResourcePolicyStatement(
        action: [String],
        condition: [String: [String: String]]? = nil,
        effect: Effect,
        expectedRevisionId: String? = nil,
        principal: [Principal],
        resourceArn: String,
        statementId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateResourcePolicyStatementResponse {
        let input = CreateResourcePolicyStatementRequest(
            action: action, 
            condition: condition, 
            effect: effect, 
            expectedRevisionId: expectedRevisionId, 
            principal: principal, 
            resourceArn: resourceArn, 
            statementId: statementId
        )
        return try await self.createResourcePolicyStatement(input, logger: logger)
    }

    /// Creates a slot in an intent. A slot is a variable needed to fulfill an intent. For example, an OrderPizza intent might need slots for size, crust, and number of pizzas. For each slot, you define one or more utterances that Amazon Lex uses to elicit a response from the user.
    @Sendable
    @inlinable
    public func createSlot(_ input: CreateSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSlotResponse {
        try await self.client.execute(
            operation: "CreateSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a slot in an intent. A slot is a variable needed to fulfill an intent. For example, an OrderPizza intent might need slots for size, crust, and number of pizzas. For each slot, you define one or more utterances that Amazon Lex uses to elicit a response from the user.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the slot.
    ///   - botVersion: The version of the bot associated with the slot.
    ///   - description: A description of the slot. Use this to help identify the slot in lists.
    ///   - intentId: The identifier of the intent that contains the slot.
    ///   - localeId: The identifier of the language and locale that the slot will be used in. The string must match one of the supported locales. All of the bots, intents, slot types used by the slot must have the same locale. For more information, see Supported languages.
    ///   - multipleValuesSetting: Indicates whether the slot returns multiple values in one response. Multi-value slots are only available in the en-US locale.  If you set this value to true in any other locale, Amazon Lex throws a ValidationException.  If the multipleValuesSetting is not set, the default value is false.
    ///   - obfuscationSetting: Determines how slot values are used in Amazon CloudWatch logs. If the value of the obfuscationSetting parameter is DefaultObfuscation, slot values are obfuscated in the log output. If the value is None, the actual value is present in the log output. The default is to obfuscate values in the CloudWatch logs.
    ///   - slotName: The name of the slot. Slot names must be unique within the bot that contains the slot.
    ///   - slotTypeId: The unique identifier for the slot type associated with this slot. The slot type determines the values that can be entered into the slot.
    ///   - subSlotSetting: Specifications for the constituent sub slots and the   expression for the composite slot.
    ///   - valueElicitationSetting: Specifies prompts that Amazon Lex sends to the user to elicit a response that provides the value for the slot.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSlot(
        botId: String,
        botVersion: String,
        description: String? = nil,
        intentId: String,
        localeId: String,
        multipleValuesSetting: MultipleValuesSetting? = nil,
        obfuscationSetting: ObfuscationSetting? = nil,
        slotName: String,
        slotTypeId: String? = nil,
        subSlotSetting: SubSlotSetting? = nil,
        valueElicitationSetting: SlotValueElicitationSetting,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSlotResponse {
        let input = CreateSlotRequest(
            botId: botId, 
            botVersion: botVersion, 
            description: description, 
            intentId: intentId, 
            localeId: localeId, 
            multipleValuesSetting: multipleValuesSetting, 
            obfuscationSetting: obfuscationSetting, 
            slotName: slotName, 
            slotTypeId: slotTypeId, 
            subSlotSetting: subSlotSetting, 
            valueElicitationSetting: valueElicitationSetting
        )
        return try await self.createSlot(input, logger: logger)
    }

    /// Creates a custom slot type To create a custom slot type, specify a name for the slot type and a set of enumeration values, the values that a slot of this type can assume.
    @Sendable
    @inlinable
    public func createSlotType(_ input: CreateSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSlotTypeResponse {
        try await self.client.execute(
            operation: "CreateSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a custom slot type To create a custom slot type, specify a name for the slot type and a set of enumeration values, the values that a slot of this type can assume.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with this slot type.
    ///   - botVersion: The identifier of the bot version associated with this slot type.
    ///   - compositeSlotTypeSetting: Specifications for a composite slot type.
    ///   - description: A description of the slot type. Use the description to help identify the slot type in lists.
    ///   - externalSourceSetting: Sets the type of external information used to create the slot type.
    ///   - localeId: The identifier of the language and locale that the slot type will be used in. The string must match one of the supported locales. All of the bots, intents, and slots used by the slot type must have the same locale. For more information, see Supported languages.
    ///   - parentSlotTypeSignature: The built-in slot type used as a parent of this slot type. When you define a parent slot type, the new slot type has the configuration of the parent slot type. Only AMAZON.AlphaNumeric is supported.
    ///   - slotTypeName: The name for the slot. A slot type name must be unique within the intent.
    ///   - slotTypeValues: A list of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for a slot.
    ///   - valueSelectionSetting: Determines the strategy that Amazon Lex uses to select a value from the list of possible values. The field can be set to one of the following values:    ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to the slot value.    TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list. If there is no resolution list, return null.   If you don't specify the valueSelectionSetting parameter, the default is ORIGINAL_VALUE.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSlotType(
        botId: String,
        botVersion: String,
        compositeSlotTypeSetting: CompositeSlotTypeSetting? = nil,
        description: String? = nil,
        externalSourceSetting: ExternalSourceSetting? = nil,
        localeId: String,
        parentSlotTypeSignature: String? = nil,
        slotTypeName: String,
        slotTypeValues: [SlotTypeValue]? = nil,
        valueSelectionSetting: SlotValueSelectionSetting? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSlotTypeResponse {
        let input = CreateSlotTypeRequest(
            botId: botId, 
            botVersion: botVersion, 
            compositeSlotTypeSetting: compositeSlotTypeSetting, 
            description: description, 
            externalSourceSetting: externalSourceSetting, 
            localeId: localeId, 
            parentSlotTypeSignature: parentSlotTypeSignature, 
            slotTypeName: slotTypeName, 
            slotTypeValues: slotTypeValues, 
            valueSelectionSetting: valueSelectionSetting
        )
        return try await self.createSlotType(input, logger: logger)
    }

    /// Create a report that describes the differences between the bot and the test set.
    @Sendable
    @inlinable
    public func createTestSetDiscrepancyReport(_ input: CreateTestSetDiscrepancyReportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTestSetDiscrepancyReportResponse {
        try await self.client.execute(
            operation: "CreateTestSetDiscrepancyReport", 
            path: "/testsets/{testSetId}/testsetdiscrepancy", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a report that describes the differences between the bot and the test set.
    ///
    /// Parameters:
    ///   - target: The target bot for the test set discrepancy report.
    ///   - testSetId: The test set Id for the test set discrepancy report.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTestSetDiscrepancyReport(
        target: TestSetDiscrepancyReportResourceTarget,
        testSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTestSetDiscrepancyReportResponse {
        let input = CreateTestSetDiscrepancyReportRequest(
            target: target, 
            testSetId: testSetId
        )
        return try await self.createTestSetDiscrepancyReport(input, logger: logger)
    }

    /// Gets a pre-signed S3 write URL that you use to upload the zip archive when importing a bot or a bot locale.
    @Sendable
    @inlinable
    public func createUploadUrl(_ input: CreateUploadUrlRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateUploadUrlResponse {
        try await self.client.execute(
            operation: "CreateUploadUrl", 
            path: "/createuploadurl", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a pre-signed S3 write URL that you use to upload the zip archive when importing a bot or a bot locale.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func createUploadUrl(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateUploadUrlResponse {
        let input = CreateUploadUrlRequest(
        )
        return try await self.createUploadUrl(input, logger: logger)
    }

    /// Deletes all versions of a bot, including the Draft version. To delete a specific version, use the DeleteBotVersion operation. When you delete a bot, all of the resources contained in the bot are also deleted. Deleting a bot removes all locales, intents, slot, and slot types defined for the bot. If a bot has an alias, the DeleteBot operation returns a ResourceInUseException exception. If you want to delete the bot and the alias, set the skipResourceInUseCheck parameter to true.
    @Sendable
    @inlinable
    public func deleteBot(_ input: DeleteBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotResponse {
        try await self.client.execute(
            operation: "DeleteBot", 
            path: "/bots/{botId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes all versions of a bot, including the Draft version. To delete a specific version, use the DeleteBotVersion operation. When you delete a bot, all of the resources contained in the bot are also deleted. Deleting a bot removes all locales, intents, slot, and slot types defined for the bot. If a bot has an alias, the DeleteBot operation returns a ResourceInUseException exception. If you want to delete the bot and the alias, set the skipResourceInUseCheck parameter to true.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot to delete.
    ///   - skipResourceInUseCheck: By default, Amazon Lex checks if any other resource, such as an alias or  bot network, is using the bot version before it is deleted and throws a  ResourceInUseException exception if the bot is  being used by another resource. Set this parameter to true to skip this check and remove the bot even if it is being used by  another resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBot(
        botId: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBotResponse {
        let input = DeleteBotRequest(
            botId: botId, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteBot(input, logger: logger)
    }

    /// Deletes the specified bot alias.
    @Sendable
    @inlinable
    public func deleteBotAlias(_ input: DeleteBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotAliasResponse {
        try await self.client.execute(
            operation: "DeleteBotAlias", 
            path: "/bots/{botId}/botaliases/{botAliasId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified bot alias.
    ///
    /// Parameters:
    ///   - botAliasId: The unique identifier of the bot alias to delete.
    ///   - botId: The unique identifier of the bot associated with the alias to delete.
    ///   - skipResourceInUseCheck: By default, Amazon Lex checks if any other resource, such as a bot network,  is using the bot alias before it is deleted and throws a  ResourceInUseException exception if the alias is  being used by another resource. Set this parameter to true to skip this check and remove the alias even if it is being used by  another resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBotAlias(
        botAliasId: String,
        botId: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBotAliasResponse {
        let input = DeleteBotAliasRequest(
            botAliasId: botAliasId, 
            botId: botId, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteBotAlias(input, logger: logger)
    }

    /// Removes a locale from a bot. When you delete a locale, all intents, slots, and slot types defined for the locale are also deleted.
    @Sendable
    @inlinable
    public func deleteBotLocale(_ input: DeleteBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotLocaleResponse {
        try await self.client.execute(
            operation: "DeleteBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a locale from a bot. When you delete a locale, all intents, slots, and slot types defined for the locale are also deleted.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the locale.
    ///   - botVersion: The version of the bot that contains the locale.
    ///   - localeId: The identifier of the language and locale that will be deleted. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBotLocale(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBotLocaleResponse {
        let input = DeleteBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        return try await self.deleteBotLocale(input, logger: logger)
    }

    /// The action to delete the replicated bot in the secondary region.
    @Sendable
    @inlinable
    public func deleteBotReplica(_ input: DeleteBotReplicaRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotReplicaResponse {
        try await self.client.execute(
            operation: "DeleteBotReplica", 
            path: "/bots/{botId}/replicas/{replicaRegion}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The action to delete the replicated bot in the secondary region.
    ///
    /// Parameters:
    ///   - botId: The unique ID of the replicated bot to be deleted from the secondary region
    ///   - replicaRegion: The secondary region of the replicated bot that will be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBotReplica(
        botId: String,
        replicaRegion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBotReplicaResponse {
        let input = DeleteBotReplicaRequest(
            botId: botId, 
            replicaRegion: replicaRegion
        )
        return try await self.deleteBotReplica(input, logger: logger)
    }

    /// Deletes a specific version of a bot. To delete all versions of a bot, use the DeleteBot operation.
    @Sendable
    @inlinable
    public func deleteBotVersion(_ input: DeleteBotVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBotVersionResponse {
        try await self.client.execute(
            operation: "DeleteBotVersion", 
            path: "/bots/{botId}/botversions/{botVersion}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specific version of a bot. To delete all versions of a bot, use the DeleteBot operation.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot that contains the version.
    ///   - botVersion: The version of the bot to delete.
    ///   - skipResourceInUseCheck: By default, Amazon Lex checks if any other resource, such as an alias or bot network,  is using the bot version before it is deleted and throws a  ResourceInUseException exception if the version is  being used by another resource. Set this parameter to true to skip this check and remove the version even if it is being used by  another resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBotVersion(
        botId: String,
        botVersion: String,
        skipResourceInUseCheck: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBotVersionResponse {
        let input = DeleteBotVersionRequest(
            botId: botId, 
            botVersion: botVersion, 
            skipResourceInUseCheck: skipResourceInUseCheck
        )
        return try await self.deleteBotVersion(input, logger: logger)
    }

    /// Removes a custom vocabulary from the specified locale in the specified bot.
    @Sendable
    @inlinable
    public func deleteCustomVocabulary(_ input: DeleteCustomVocabularyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCustomVocabularyResponse {
        try await self.client.execute(
            operation: "DeleteCustomVocabulary", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a custom vocabulary from the specified locale in the specified bot.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot to remove the custom vocabulary from.
    ///   - botVersion: The version of the bot to remove the custom vocabulary from.
    ///   - localeId: The locale identifier for the locale that contains the custom vocabulary to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCustomVocabulary(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCustomVocabularyResponse {
        let input = DeleteCustomVocabularyRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        return try await self.deleteCustomVocabulary(input, logger: logger)
    }

    /// Removes a previous export and the associated files stored in an S3 bucket.
    @Sendable
    @inlinable
    public func deleteExport(_ input: DeleteExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteExportResponse {
        try await self.client.execute(
            operation: "DeleteExport", 
            path: "/exports/{exportId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a previous export and the associated files stored in an S3 bucket.
    ///
    /// Parameters:
    ///   - exportId: The unique identifier of the export to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteExport(
        exportId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteExportResponse {
        let input = DeleteExportRequest(
            exportId: exportId
        )
        return try await self.deleteExport(input, logger: logger)
    }

    /// Removes a previous import and the associated file stored in an S3 bucket.
    @Sendable
    @inlinable
    public func deleteImport(_ input: DeleteImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImportResponse {
        try await self.client.execute(
            operation: "DeleteImport", 
            path: "/imports/{importId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a previous import and the associated file stored in an S3 bucket.
    ///
    /// Parameters:
    ///   - importId: The unique identifier of the import to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteImport(
        importId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteImportResponse {
        let input = DeleteImportRequest(
            importId: importId
        )
        return try await self.deleteImport(input, logger: logger)
    }

    /// Removes the specified intent. Deleting an intent also deletes the slots associated with the intent.
    @Sendable
    @inlinable
    public func deleteIntent(_ input: DeleteIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified intent. Deleting an intent also deletes the slots associated with the intent.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the intent.
    ///   - botVersion: The version of the bot associated with the intent.
    ///   - intentId: The unique identifier of the intent to delete.
    ///   - localeId: The identifier of the language and locale where the bot will be deleted. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIntent(
        botId: String,
        botVersion: String,
        intentId: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteIntentRequest(
            botId: botId, 
            botVersion: botVersion, 
            intentId: intentId, 
            localeId: localeId
        )
        return try await self.deleteIntent(input, logger: logger)
    }

    /// Removes an existing policy from a bot or bot alias. If the resource doesn't have a policy attached, Amazon Lex returns an exception.
    @Sendable
    @inlinable
    public func deleteResourcePolicy(_ input: DeleteResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResourcePolicyResponse {
        try await self.client.execute(
            operation: "DeleteResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes an existing policy from a bot or bot alias. If the resource doesn't have a policy attached, Amazon Lex returns an exception.
    ///
    /// Parameters:
    ///   - expectedRevisionId: The identifier of the revision to edit. If this ID doesn't match the current revision number, Amazon Lex returns an exception If you don't specify a revision ID, Amazon Lex will delete the current policy.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the bot or bot alias that has the resource policy attached.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResourcePolicy(
        expectedRevisionId: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResourcePolicyResponse {
        let input = DeleteResourcePolicyRequest(
            expectedRevisionId: expectedRevisionId, 
            resourceArn: resourceArn
        )
        return try await self.deleteResourcePolicy(input, logger: logger)
    }

    /// Deletes a policy statement from a resource policy. If you delete the last statement from a policy, the policy is deleted. If you specify a statement ID that doesn't exist in the policy, or if the bot or bot alias doesn't have a policy attached, Amazon Lex returns an exception. You need to add the DeleteResourcePolicy or UpdateResourcePolicy  action to the bot role in order to call the API.
    @Sendable
    @inlinable
    public func deleteResourcePolicyStatement(_ input: DeleteResourcePolicyStatementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResourcePolicyStatementResponse {
        try await self.client.execute(
            operation: "DeleteResourcePolicyStatement", 
            path: "/policy/{resourceArn}/statements/{statementId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a policy statement from a resource policy. If you delete the last statement from a policy, the policy is deleted. If you specify a statement ID that doesn't exist in the policy, or if the bot or bot alias doesn't have a policy attached, Amazon Lex returns an exception. You need to add the DeleteResourcePolicy or UpdateResourcePolicy  action to the bot role in order to call the API.
    ///
    /// Parameters:
    ///   - expectedRevisionId: The identifier of the revision of the policy to delete the statement from. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex removes the current contents of the statement.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    ///   - statementId: The name of the statement (SID) to delete from the policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResourcePolicyStatement(
        expectedRevisionId: String? = nil,
        resourceArn: String,
        statementId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResourcePolicyStatementResponse {
        let input = DeleteResourcePolicyStatementRequest(
            expectedRevisionId: expectedRevisionId, 
            resourceArn: resourceArn, 
            statementId: statementId
        )
        return try await self.deleteResourcePolicyStatement(input, logger: logger)
    }

    /// Deletes the specified slot from an intent.
    @Sendable
    @inlinable
    public func deleteSlot(_ input: DeleteSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified slot from an intent.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the slot to delete.
    ///   - botVersion: The version of the bot associated with the slot to delete.
    ///   - intentId: The identifier of the intent associated with the slot.
    ///   - localeId: The identifier of the language and locale that the slot will be deleted from. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - slotId: The identifier of the slot to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSlot(
        botId: String,
        botVersion: String,
        intentId: String,
        localeId: String,
        slotId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteSlotRequest(
            botId: botId, 
            botVersion: botVersion, 
            intentId: intentId, 
            localeId: localeId, 
            slotId: slotId
        )
        return try await self.deleteSlot(input, logger: logger)
    }

    /// Deletes a slot type from a bot locale. If a slot is using the slot type, Amazon Lex throws a ResourceInUseException exception. To avoid the exception, set the skipResourceInUseCheck parameter to true.
    @Sendable
    @inlinable
    public func deleteSlotType(_ input: DeleteSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a slot type from a bot locale. If a slot is using the slot type, Amazon Lex throws a ResourceInUseException exception. To avoid the exception, set the skipResourceInUseCheck parameter to true.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the slot type.
    ///   - botVersion: The version of the bot associated with the slot type.
    ///   - localeId: The identifier of the language and locale that the slot type will be deleted from. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - skipResourceInUseCheck: By default, the DeleteSlotType operations throws a ResourceInUseException exception if you try to delete a slot type used by a slot. Set the skipResourceInUseCheck parameter to true to skip this check and remove the slot type even if a slot uses it.
    ///   - slotTypeId: The identifier of the slot type to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSlotType(
        botId: String,
        botVersion: String,
        localeId: String,
        skipResourceInUseCheck: Bool? = nil,
        slotTypeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteSlotTypeRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            skipResourceInUseCheck: skipResourceInUseCheck, 
            slotTypeId: slotTypeId
        )
        return try await self.deleteSlotType(input, logger: logger)
    }

    /// The action to delete the selected test set.
    @Sendable
    @inlinable
    public func deleteTestSet(_ input: DeleteTestSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteTestSet", 
            path: "/testsets/{testSetId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The action to delete the selected test set.
    ///
    /// Parameters:
    ///   - testSetId: The test set Id of the test set to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTestSet(
        testSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteTestSetRequest(
            testSetId: testSetId
        )
        return try await self.deleteTestSet(input, logger: logger)
    }

    /// Deletes stored utterances. Amazon Lex stores the utterances that users send to your bot. Utterances are stored for 15 days for use with the ListAggregatedUtterances operation, and then stored indefinitely for use in improving the ability of your bot to respond to user input.. Use the DeleteUtterances operation to manually delete utterances for a specific session. When you use the DeleteUtterances operation, utterances stored for improving your bot's ability to respond to user input are deleted immediately. Utterances stored for use with the ListAggregatedUtterances operation are deleted after 15 days.
    @Sendable
    @inlinable
    public func deleteUtterances(_ input: DeleteUtterancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteUtterancesResponse {
        try await self.client.execute(
            operation: "DeleteUtterances", 
            path: "/bots/{botId}/utterances", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes stored utterances. Amazon Lex stores the utterances that users send to your bot. Utterances are stored for 15 days for use with the ListAggregatedUtterances operation, and then stored indefinitely for use in improving the ability of your bot to respond to user input.. Use the DeleteUtterances operation to manually delete utterances for a specific session. When you use the DeleteUtterances operation, utterances stored for improving your bot's ability to respond to user input are deleted immediately. Utterances stored for use with the ListAggregatedUtterances operation are deleted after 15 days.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the utterances.
    ///   - localeId: The identifier of the language and locale where the utterances were collected. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - sessionId: The unique identifier of the session with the user. The ID is returned in the response from the RecognizeText and RecognizeUtterance operations.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteUtterances(
        botId: String,
        localeId: String? = nil,
        sessionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteUtterancesResponse {
        let input = DeleteUtterancesRequest(
            botId: botId, 
            localeId: localeId, 
            sessionId: sessionId
        )
        return try await self.deleteUtterances(input, logger: logger)
    }

    /// Provides metadata information about a bot.
    @Sendable
    @inlinable
    public func describeBot(_ input: DescribeBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotResponse {
        try await self.client.execute(
            operation: "DescribeBot", 
            path: "/bots/{botId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides metadata information about a bot.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBot(
        botId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBotResponse {
        let input = DescribeBotRequest(
            botId: botId
        )
        return try await self.describeBot(input, logger: logger)
    }

    /// Get information about a specific bot alias.
    @Sendable
    @inlinable
    public func describeBotAlias(_ input: DescribeBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotAliasResponse {
        try await self.client.execute(
            operation: "DescribeBotAlias", 
            path: "/bots/{botId}/botaliases/{botAliasId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get information about a specific bot alias.
    ///
    /// Parameters:
    ///   - botAliasId: The identifier of the bot alias to describe.
    ///   - botId: The identifier of the bot associated with the bot alias to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBotAlias(
        botAliasId: String,
        botId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBotAliasResponse {
        let input = DescribeBotAliasRequest(
            botAliasId: botAliasId, 
            botId: botId
        )
        return try await self.describeBotAlias(input, logger: logger)
    }

    /// Describes the settings that a bot has for a specific locale.
    @Sendable
    @inlinable
    public func describeBotLocale(_ input: DescribeBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotLocaleResponse {
        try await self.client.execute(
            operation: "DescribeBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the settings that a bot has for a specific locale.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the locale.
    ///   - botVersion: The version of the bot associated with the locale.
    ///   - localeId: The unique identifier of the locale to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBotLocale(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBotLocaleResponse {
        let input = DescribeBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        return try await self.describeBotLocale(input, logger: logger)
    }

    /// Provides metadata information about a bot recommendation. This information will enable you to get a description on the request inputs, to download associated transcripts after processing is complete, and to download intents and slot-types generated by the bot recommendation.
    @Sendable
    @inlinable
    public func describeBotRecommendation(_ input: DescribeBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotRecommendationResponse {
        try await self.client.execute(
            operation: "DescribeBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides metadata information about a bot recommendation. This information will enable you to get a description on the request inputs, to download associated transcripts after processing is complete, and to download intents and slot-types generated by the bot recommendation.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot associated with the bot recommendation.
    ///   - botRecommendationId: The identifier of the bot recommendation to describe.
    ///   - botVersion: The version of the bot associated with the bot recommendation.
    ///   - localeId: The identifier of the language and locale of the bot recommendation to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBotRecommendation(
        botId: String,
        botRecommendationId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBotRecommendationResponse {
        let input = DescribeBotRecommendationRequest(
            botId: botId, 
            botRecommendationId: botRecommendationId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        return try await self.describeBotRecommendation(input, logger: logger)
    }

    /// Monitors the bot replication status through the UI console.
    @Sendable
    @inlinable
    public func describeBotReplica(_ input: DescribeBotReplicaRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotReplicaResponse {
        try await self.client.execute(
            operation: "DescribeBotReplica", 
            path: "/bots/{botId}/replicas/{replicaRegion}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Monitors the bot replication status through the UI console.
    ///
    /// Parameters:
    ///   - botId: The request for the unique bot ID of the replicated bot being monitored.
    ///   - replicaRegion: The request for the region of the replicated bot being monitored.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBotReplica(
        botId: String,
        replicaRegion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBotReplicaResponse {
        let input = DescribeBotReplicaRequest(
            botId: botId, 
            replicaRegion: replicaRegion
        )
        return try await self.describeBotReplica(input, logger: logger)
    }

    /// Returns information about a request to generate a bot through natural language description, made through  the StartBotResource API. Use the generatedBotLocaleUrl  to retrieve the Amazon S3 object containing the bot locale configuration. You can  then modify and import this configuration.
    @Sendable
    @inlinable
    public func describeBotResourceGeneration(_ input: DescribeBotResourceGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotResourceGenerationResponse {
        try await self.client.execute(
            operation: "DescribeBotResourceGeneration", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generations/{generationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a request to generate a bot through natural language description, made through  the StartBotResource API. Use the generatedBotLocaleUrl  to retrieve the Amazon S3 object containing the bot locale configuration. You can  then modify and import this configuration.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot for which to return the generation details.
    ///   - botVersion: The version of the bot for which to return the generation details.
    ///   - generationId: The unique identifier of the generation request for which to  return the generation details.
    ///   - localeId: The locale of the bot for which to return the generation details.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBotResourceGeneration(
        botId: String,
        botVersion: String,
        generationId: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBotResourceGenerationResponse {
        let input = DescribeBotResourceGenerationRequest(
            botId: botId, 
            botVersion: botVersion, 
            generationId: generationId, 
            localeId: localeId
        )
        return try await self.describeBotResourceGeneration(input, logger: logger)
    }

    /// Provides metadata about a version of a bot.
    @Sendable
    @inlinable
    public func describeBotVersion(_ input: DescribeBotVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeBotVersionResponse {
        try await self.client.execute(
            operation: "DescribeBotVersion", 
            path: "/bots/{botId}/botversions/{botVersion}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides metadata about a version of a bot.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot containing the version to return metadata for.
    ///   - botVersion: The version of the bot to return metadata for.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeBotVersion(
        botId: String,
        botVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeBotVersionResponse {
        let input = DescribeBotVersionRequest(
            botId: botId, 
            botVersion: botVersion
        )
        return try await self.describeBotVersion(input, logger: logger)
    }

    /// Provides metadata information about a custom vocabulary.
    @Sendable
    @inlinable
    public func describeCustomVocabularyMetadata(_ input: DescribeCustomVocabularyMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCustomVocabularyMetadataResponse {
        try await self.client.execute(
            operation: "DescribeCustomVocabularyMetadata", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/metadata", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides metadata information about a custom vocabulary.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the custom vocabulary.
    ///   - botVersion: The bot version of the bot to return metadata for.
    ///   - localeId: The locale to return the custom vocabulary information for. The locale must be en_GB.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCustomVocabularyMetadata(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeCustomVocabularyMetadataResponse {
        let input = DescribeCustomVocabularyMetadataRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        return try await self.describeCustomVocabularyMetadata(input, logger: logger)
    }

    /// Gets information about a specific export.
    @Sendable
    @inlinable
    public func describeExport(_ input: DescribeExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeExportResponse {
        try await self.client.execute(
            operation: "DescribeExport", 
            path: "/exports/{exportId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specific export.
    ///
    /// Parameters:
    ///   - exportId: The unique identifier of the export to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeExport(
        exportId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeExportResponse {
        let input = DescribeExportRequest(
            exportId: exportId
        )
        return try await self.describeExport(input, logger: logger)
    }

    /// Gets information about a specific import.
    @Sendable
    @inlinable
    public func describeImport(_ input: DescribeImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeImportResponse {
        try await self.client.execute(
            operation: "DescribeImport", 
            path: "/imports/{importId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about a specific import.
    ///
    /// Parameters:
    ///   - importId: The unique identifier of the import to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeImport(
        importId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeImportResponse {
        let input = DescribeImportRequest(
            importId: importId
        )
        return try await self.describeImport(input, logger: logger)
    }

    /// Returns metadata about an intent.
    @Sendable
    @inlinable
    public func describeIntent(_ input: DescribeIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeIntentResponse {
        try await self.client.execute(
            operation: "DescribeIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns metadata about an intent.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the intent.
    ///   - botVersion: The version of the bot associated with the intent.
    ///   - intentId: The identifier of the intent to describe.
    ///   - localeId: The identifier of the language and locale of the intent to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeIntent(
        botId: String,
        botVersion: String,
        intentId: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeIntentResponse {
        let input = DescribeIntentRequest(
            botId: botId, 
            botVersion: botVersion, 
            intentId: intentId, 
            localeId: localeId
        )
        return try await self.describeIntent(input, logger: logger)
    }

    /// Gets the resource policy and policy revision for a bot or bot alias.
    @Sendable
    @inlinable
    public func describeResourcePolicy(_ input: DescribeResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeResourcePolicyResponse {
        try await self.client.execute(
            operation: "DescribeResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the resource policy and policy revision for a bot or bot alias.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeResourcePolicy(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeResourcePolicyResponse {
        let input = DescribeResourcePolicyRequest(
            resourceArn: resourceArn
        )
        return try await self.describeResourcePolicy(input, logger: logger)
    }

    /// Gets metadata information about a slot.
    @Sendable
    @inlinable
    public func describeSlot(_ input: DescribeSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSlotResponse {
        try await self.client.execute(
            operation: "DescribeSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets metadata information about a slot.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the slot.
    ///   - botVersion: The version of the bot associated with the slot.
    ///   - intentId: The identifier of the intent that contains the slot.
    ///   - localeId: The identifier of the language and locale of the slot to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - slotId: The unique identifier for the slot.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSlot(
        botId: String,
        botVersion: String,
        intentId: String,
        localeId: String,
        slotId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSlotResponse {
        let input = DescribeSlotRequest(
            botId: botId, 
            botVersion: botVersion, 
            intentId: intentId, 
            localeId: localeId, 
            slotId: slotId
        )
        return try await self.describeSlot(input, logger: logger)
    }

    /// Gets metadata information about a slot type.
    @Sendable
    @inlinable
    public func describeSlotType(_ input: DescribeSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSlotTypeResponse {
        try await self.client.execute(
            operation: "DescribeSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets metadata information about a slot type.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot associated with the slot type.
    ///   - botVersion: The version of the bot associated with the slot type.
    ///   - localeId: The identifier of the language and locale of the slot type to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - slotTypeId: The identifier of the slot type.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSlotType(
        botId: String,
        botVersion: String,
        localeId: String,
        slotTypeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSlotTypeResponse {
        let input = DescribeSlotTypeRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            slotTypeId: slotTypeId
        )
        return try await self.describeSlotType(input, logger: logger)
    }

    /// Gets metadata information about the test execution.
    @Sendable
    @inlinable
    public func describeTestExecution(_ input: DescribeTestExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestExecutionResponse {
        try await self.client.execute(
            operation: "DescribeTestExecution", 
            path: "/testexecutions/{testExecutionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets metadata information about the test execution.
    ///
    /// Parameters:
    ///   - testExecutionId: The execution Id of the test set execution.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeTestExecution(
        testExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeTestExecutionResponse {
        let input = DescribeTestExecutionRequest(
            testExecutionId: testExecutionId
        )
        return try await self.describeTestExecution(input, logger: logger)
    }

    /// Gets metadata information about the test set.
    @Sendable
    @inlinable
    public func describeTestSet(_ input: DescribeTestSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestSetResponse {
        try await self.client.execute(
            operation: "DescribeTestSet", 
            path: "/testsets/{testSetId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets metadata information about the test set.
    ///
    /// Parameters:
    ///   - testSetId: The test set Id for the test set request.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeTestSet(
        testSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeTestSetResponse {
        let input = DescribeTestSetRequest(
            testSetId: testSetId
        )
        return try await self.describeTestSet(input, logger: logger)
    }

    /// Gets metadata information about the test set discrepancy report.
    @Sendable
    @inlinable
    public func describeTestSetDiscrepancyReport(_ input: DescribeTestSetDiscrepancyReportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestSetDiscrepancyReportResponse {
        try await self.client.execute(
            operation: "DescribeTestSetDiscrepancyReport", 
            path: "/testsetdiscrepancy/{testSetDiscrepancyReportId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets metadata information about the test set discrepancy report.
    ///
    /// Parameters:
    ///   - testSetDiscrepancyReportId: The unique identifier of the test set discrepancy report.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeTestSetDiscrepancyReport(
        testSetDiscrepancyReportId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeTestSetDiscrepancyReportResponse {
        let input = DescribeTestSetDiscrepancyReportRequest(
            testSetDiscrepancyReportId: testSetDiscrepancyReportId
        )
        return try await self.describeTestSetDiscrepancyReport(input, logger: logger)
    }

    /// Gets metadata information about the test set generation.
    @Sendable
    @inlinable
    public func describeTestSetGeneration(_ input: DescribeTestSetGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTestSetGenerationResponse {
        try await self.client.execute(
            operation: "DescribeTestSetGeneration", 
            path: "/testsetgenerations/{testSetGenerationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets metadata information about the test set generation.
    ///
    /// Parameters:
    ///   - testSetGenerationId: The unique identifier of the test set generation.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeTestSetGeneration(
        testSetGenerationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeTestSetGenerationResponse {
        let input = DescribeTestSetGenerationRequest(
            testSetGenerationId: testSetGenerationId
        )
        return try await self.describeTestSetGeneration(input, logger: logger)
    }

    /// Generates sample utterances for an intent.
    @Sendable
    @inlinable
    public func generateBotElement(_ input: GenerateBotElementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GenerateBotElementResponse {
        try await self.client.execute(
            operation: "GenerateBotElement", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generate", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Generates sample utterances for an intent.
    ///
    /// Parameters:
    ///   - botId: The bot unique Id for the bot request to generate utterances.
    ///   - botVersion: The bot version for the bot request to generate utterances.
    ///   - intentId: The intent unique Id for the bot request to generate utterances.
    ///   - localeId: The unique locale Id for the bot request to generate utterances.
    ///   - logger: Logger use during operation
    @inlinable
    public func generateBotElement(
        botId: String,
        botVersion: String,
        intentId: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GenerateBotElementResponse {
        let input = GenerateBotElementRequest(
            botId: botId, 
            botVersion: botVersion, 
            intentId: intentId, 
            localeId: localeId
        )
        return try await self.generateBotElement(input, logger: logger)
    }

    /// The pre-signed Amazon S3 URL to download the test execution result artifacts.
    @Sendable
    @inlinable
    public func getTestExecutionArtifactsUrl(_ input: GetTestExecutionArtifactsUrlRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTestExecutionArtifactsUrlResponse {
        try await self.client.execute(
            operation: "GetTestExecutionArtifactsUrl", 
            path: "/testexecutions/{testExecutionId}/artifacturl", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The pre-signed Amazon S3 URL to download the test execution result artifacts.
    ///
    /// Parameters:
    ///   - testExecutionId: The unique identifier of the completed test execution.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTestExecutionArtifactsUrl(
        testExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTestExecutionArtifactsUrlResponse {
        let input = GetTestExecutionArtifactsUrlRequest(
            testExecutionId: testExecutionId
        )
        return try await self.getTestExecutionArtifactsUrl(input, logger: logger)
    }

    /// Provides a list of utterances that users have sent to the bot. Utterances are aggregated by the text of the utterance. For example, all instances where customers used the phrase "I want to order pizza" are aggregated into the same line in the response. You can see both detected utterances and missed utterances. A detected utterance is where the bot properly recognized the utterance and activated the associated intent. A missed utterance was not recognized by the bot and didn't activate an intent. Utterances can be aggregated for a bot alias or for a bot version, but not both at the same time. Utterances statistics are not generated under the following conditions:   The childDirected field was set to true when the bot was created.   You are using slot obfuscation with one or more slots.   You opted out of participating in improving Amazon Lex.
    @Sendable
    @inlinable
    public func listAggregatedUtterances(_ input: ListAggregatedUtterancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAggregatedUtterancesResponse {
        try await self.client.execute(
            operation: "ListAggregatedUtterances", 
            path: "/bots/{botId}/aggregatedutterances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides a list of utterances that users have sent to the bot. Utterances are aggregated by the text of the utterance. For example, all instances where customers used the phrase "I want to order pizza" are aggregated into the same line in the response. You can see both detected utterances and missed utterances. A detected utterance is where the bot properly recognized the utterance and activated the associated intent. A missed utterance was not recognized by the bot and didn't activate an intent. Utterances can be aggregated for a bot alias or for a bot version, but not both at the same time. Utterances statistics are not generated under the following conditions:   The childDirected field was set to true when the bot was created.   You are using slot obfuscation with one or more slots.   You opted out of participating in improving Amazon Lex.
    ///
    /// Parameters:
    ///   - aggregationDuration: The time window for aggregating the utterance information. You can specify a time between one hour and two weeks.
    ///   - botAliasId: The identifier of the bot alias associated with this request. If you specify the bot alias, you can't specify the bot version.
    ///   - botId: The unique identifier of the bot associated with this request.
    ///   - botVersion: The identifier of the bot version associated with this request. If you specify the bot version, you can't specify the bot alias.
    ///   - filters: Provides the specification of a filter used to limit the utterances in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - localeId: The identifier of the language and locale where the utterances were collected. For more information, see Supported languages.
    ///   - maxResults: The maximum number of utterances to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned. If you don't specify the maxResults parameter, 1,000 results are returned.
    ///   - nextToken: If the response from the ListAggregatedUtterances operation contains more results that specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: Specifies sorting parameters for the list of utterances. You can sort by the hit count, the missed count, or the number of distinct sessions the utterance appeared in.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAggregatedUtterances(
        aggregationDuration: UtteranceAggregationDuration,
        botAliasId: String? = nil,
        botId: String,
        botVersion: String? = nil,
        filters: [AggregatedUtterancesFilter]? = nil,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: AggregatedUtterancesSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAggregatedUtterancesResponse {
        let input = ListAggregatedUtterancesRequest(
            aggregationDuration: aggregationDuration, 
            botAliasId: botAliasId, 
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listAggregatedUtterances(input, logger: logger)
    }

    /// The action to list the replicated bots created from the source bot alias.
    @Sendable
    @inlinable
    public func listBotAliasReplicas(_ input: ListBotAliasReplicasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotAliasReplicasResponse {
        try await self.client.execute(
            operation: "ListBotAliasReplicas", 
            path: "/bots/{botId}/replicas/{replicaRegion}/botaliases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The action to list the replicated bots created from the source bot alias.
    ///
    /// Parameters:
    ///   - botId: The request for the unique bot ID of the replicated bot created from the source bot alias.
    ///   - maxResults: The request for maximum results to list the replicated bots created from the source bot alias.
    ///   - nextToken: The request for the next token for the replicated bot created from the source bot alias.
    ///   - replicaRegion: The request for the secondary region of the replicated bot created from the source bot alias.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotAliasReplicas(
        botId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicaRegion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotAliasReplicasResponse {
        let input = ListBotAliasReplicasRequest(
            botId: botId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            replicaRegion: replicaRegion
        )
        return try await self.listBotAliasReplicas(input, logger: logger)
    }

    /// Gets a list of aliases for the specified bot.
    @Sendable
    @inlinable
    public func listBotAliases(_ input: ListBotAliasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotAliasesResponse {
        try await self.client.execute(
            operation: "ListBotAliases", 
            path: "/bots/{botId}/botaliases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of aliases for the specified bot.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot to list aliases for.
    ///   - maxResults: The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListBotAliases operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotAliases(
        botId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotAliasesResponse {
        let input = ListBotAliasesRequest(
            botId: botId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBotAliases(input, logger: logger)
    }

    /// Gets a list of locales for the specified bot.
    @Sendable
    @inlinable
    public func listBotLocales(_ input: ListBotLocalesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotLocalesResponse {
        try await self.client.execute(
            operation: "ListBotLocales", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of locales for the specified bot.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot to list locales for.
    ///   - botVersion: The version of the bot to list locales for.
    ///   - filters: Provides the specification for a filter used to limit the response to only those locales that match the filter specification. You can only specify one filter and one value to filter on.
    ///   - maxResults: The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListBotLocales operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token as the nextToken parameter to return the next page of results.
    ///   - sortBy: Specifies sorting parameters for the list of locales. You can sort by locale name in ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotLocales(
        botId: String,
        botVersion: String,
        filters: [BotLocaleFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BotLocaleSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotLocalesResponse {
        let input = ListBotLocalesRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listBotLocales(input, logger: logger)
    }

    /// Get a list of bot recommendations that meet the specified criteria.
    @Sendable
    @inlinable
    public func listBotRecommendations(_ input: ListBotRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotRecommendationsResponse {
        try await self.client.execute(
            operation: "ListBotRecommendations", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a list of bot recommendations that meet the specified criteria.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the bot recommendation list.
    ///   - botVersion: The version of the bot that contains the bot recommendation list.
    ///   - localeId: The identifier of the language and locale of the bot recommendation list.
    ///   - maxResults: The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListBotRecommendation operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotRecommendations(
        botId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotRecommendationsResponse {
        let input = ListBotRecommendationsRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listBotRecommendations(input, logger: logger)
    }

    /// The action to list the replicated bots.
    @Sendable
    @inlinable
    public func listBotReplicas(_ input: ListBotReplicasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotReplicasResponse {
        try await self.client.execute(
            operation: "ListBotReplicas", 
            path: "/bots/{botId}/replicas", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The action to list the replicated bots.
    ///
    /// Parameters:
    ///   - botId: The request for the unique bot IDs in the list of replicated bots.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotReplicas(
        botId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotReplicasResponse {
        let input = ListBotReplicasRequest(
            botId: botId
        )
        return try await self.listBotReplicas(input, logger: logger)
    }

    /// Lists the generation requests made for a bot locale.
    @Sendable
    @inlinable
    public func listBotResourceGenerations(_ input: ListBotResourceGenerationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotResourceGenerationsResponse {
        try await self.client.execute(
            operation: "ListBotResourceGenerations", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/generations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the generation requests made for a bot locale.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot whose generation  requests you want to view.
    ///   - botVersion: The version of the bot whose generation  requests you want to view.
    ///   - localeId: The locale of the bot whose generation  requests you want to view.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - nextToken: If the total number of results is greater than the number  specified in the maxResults, the response returns a token  in the nextToken field. Use this token when making a request to  return the next batch of results.
    ///   - sortBy: An object containing information about the attribute and the  method by which to sort the results
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotResourceGenerations(
        botId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: GenerationSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotResourceGenerationsResponse {
        let input = ListBotResourceGenerationsRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listBotResourceGenerations(input, logger: logger)
    }

    /// Contains information about all the versions replication statuses applicable for Global Resiliency.
    @Sendable
    @inlinable
    public func listBotVersionReplicas(_ input: ListBotVersionReplicasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotVersionReplicasResponse {
        try await self.client.execute(
            operation: "ListBotVersionReplicas", 
            path: "/bots/{botId}/replicas/{replicaRegion}/botversions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Contains information about all the versions replication statuses applicable for Global Resiliency.
    ///
    /// Parameters:
    ///   - botId: The request for the unique ID in the list of replicated bots.
    ///   - maxResults: The maximum results given in the list of replicated bots.
    ///   - nextToken: The next token given in the list of replicated bots.
    ///   - replicaRegion: The request for the region used in the list of replicated bots.
    ///   - sortBy: The requested sort category for the list of replicated bots.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotVersionReplicas(
        botId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicaRegion: String,
        sortBy: BotVersionReplicaSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotVersionReplicasResponse {
        let input = ListBotVersionReplicasRequest(
            botId: botId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            replicaRegion: replicaRegion, 
            sortBy: sortBy
        )
        return try await self.listBotVersionReplicas(input, logger: logger)
    }

    /// Gets information about all of the versions of a bot. The ListBotVersions operation returns a summary of each version of a bot. For example, if a bot has three numbered versions, the ListBotVersions operation returns for summaries, one for each numbered version and one for the DRAFT version. The ListBotVersions operation always returns at least one version, the DRAFT version.
    @Sendable
    @inlinable
    public func listBotVersions(_ input: ListBotVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotVersionsResponse {
        try await self.client.execute(
            operation: "ListBotVersions", 
            path: "/bots/{botId}/botversions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about all of the versions of a bot. The ListBotVersions operation returns a summary of each version of a bot. For example, if a bot has three numbered versions, the ListBotVersions operation returns for summaries, one for each numbered version and one for the DRAFT version. The ListBotVersions operation always returns at least one version, the DRAFT version.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot to list versions for.
    ///   - maxResults: The maximum number of versions to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response to the ListBotVersion operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: Specifies sorting parameters for the list of versions. You can specify that the list be sorted by version name in either ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBotVersions(
        botId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BotVersionSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotVersionsResponse {
        let input = ListBotVersionsRequest(
            botId: botId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listBotVersions(input, logger: logger)
    }

    /// Gets a list of available bots.
    @Sendable
    @inlinable
    public func listBots(_ input: ListBotsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBotsResponse {
        try await self.client.execute(
            operation: "ListBots", 
            path: "/bots", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of available bots.
    ///
    /// Parameters:
    ///   - filters: Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - maxResults: The maximum number of bots to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListBots operation contains more results than specified in the maxResults parameter, a token is returned in the response.  Use the returned token in the nextToken parameter of a ListBots request to return the next page of results. For a complete set of results, call the ListBots operation until the nextToken returned in the response is null.
    ///   - sortBy: Specifies sorting parameters for the list of bots. You can specify that the list be sorted by bot name in ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBots(
        filters: [BotFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BotSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBotsResponse {
        let input = ListBotsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listBots(input, logger: logger)
    }

    /// Gets a list of built-in intents provided by Amazon Lex that you can use in your bot.  To use a built-in intent as a the base for your own intent, include the built-in intent signature in the parentIntentSignature parameter when you call the CreateIntent operation. For more information, see CreateIntent.
    @Sendable
    @inlinable
    public func listBuiltInIntents(_ input: ListBuiltInIntentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBuiltInIntentsResponse {
        try await self.client.execute(
            operation: "ListBuiltInIntents", 
            path: "/builtins/locales/{localeId}/intents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of built-in intents provided by Amazon Lex that you can use in your bot.  To use a built-in intent as a the base for your own intent, include the built-in intent signature in the parentIntentSignature parameter when you call the CreateIntent operation. For more information, see CreateIntent.
    ///
    /// Parameters:
    ///   - localeId: The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of built-in intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListBuiltInIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: Specifies sorting parameters for the list of built-in intents. You can specify that the list be sorted by the built-in intent signature in either ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBuiltInIntents(
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BuiltInIntentSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBuiltInIntentsResponse {
        let input = ListBuiltInIntentsRequest(
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listBuiltInIntents(input, logger: logger)
    }

    /// Gets a list of built-in slot types that meet the specified criteria.
    @Sendable
    @inlinable
    public func listBuiltInSlotTypes(_ input: ListBuiltInSlotTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBuiltInSlotTypesResponse {
        try await self.client.execute(
            operation: "ListBuiltInSlotTypes", 
            path: "/builtins/locales/{localeId}/slottypes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of built-in slot types that meet the specified criteria.
    ///
    /// Parameters:
    ///   - localeId: The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of built-in slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListBuiltInSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: Determines the sort order for the response from the ListBuiltInSlotTypes operation. You can choose to sort by the slot type signature in either ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBuiltInSlotTypes(
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: BuiltInSlotTypeSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBuiltInSlotTypesResponse {
        let input = ListBuiltInSlotTypesRequest(
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listBuiltInSlotTypes(input, logger: logger)
    }

    /// Paginated list of custom vocabulary items for a given bot locale's  custom vocabulary.
    @Sendable
    @inlinable
    public func listCustomVocabularyItems(_ input: ListCustomVocabularyItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCustomVocabularyItemsResponse {
        try await self.client.execute(
            operation: "ListCustomVocabularyItems", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/customvocabulary/DEFAULT/list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Paginated list of custom vocabulary items for a given bot locale's  custom vocabulary.
    ///
    /// Parameters:
    ///   - botId: The identifier of the version of the bot associated with this custom  vocabulary.
    ///   - botVersion: The bot version of the bot to the list custom vocabulary  request.
    ///   - localeId: The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see Supported  languages (https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    ///   - maxResults: The maximum number of items returned by the list operation.
    ///   - nextToken: The nextToken identifier to the list custom vocabulary  request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCustomVocabularyItems(
        botId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCustomVocabularyItemsResponse {
        let input = ListCustomVocabularyItemsRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listCustomVocabularyItems(input, logger: logger)
    }

    /// Lists the exports for a bot, bot locale, or custom vocabulary. Exports are kept in the list for 7 days.
    @Sendable
    @inlinable
    public func listExports(_ input: ListExportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListExportsResponse {
        try await self.client.execute(
            operation: "ListExports", 
            path: "/exports", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the exports for a bot, bot locale, or custom vocabulary. Exports are kept in the list for 7 days.
    ///
    /// Parameters:
    ///   - botId: The unique identifier that Amazon Lex assigned to the bot.
    ///   - botVersion: The version of the bot to list exports for.
    ///   - filters: Provides the specification of a filter used to limit the exports in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - localeId: Specifies the resources that should be exported. If you don't specify a resource type in the filters parameter, both bot locales and custom vocabularies are exported.
    ///   - maxResults: The maximum number of exports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListExports operation contains more results that specified in the maxResults parameter, a token is returned in the response.  Use the returned token in the nextToken parameter of a ListExports request to return the next page of results. For a complete set of results, call the ListExports operation until the nextToken returned in the response is null.
    ///   - sortBy: Determines the field that the list of exports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listExports(
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [ExportFilter]? = nil,
        localeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: ExportSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListExportsResponse {
        let input = ListExportsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listExports(input, logger: logger)
    }

    /// Lists the imports for a bot, bot locale, or custom vocabulary. Imports are kept in the list for 7 days.
    @Sendable
    @inlinable
    public func listImports(_ input: ListImportsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImportsResponse {
        try await self.client.execute(
            operation: "ListImports", 
            path: "/imports", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the imports for a bot, bot locale, or custom vocabulary. Imports are kept in the list for 7 days.
    ///
    /// Parameters:
    ///   - botId: The unique identifier that Amazon Lex assigned to the bot.
    ///   - botVersion: The version of the bot to list imports for.
    ///   - filters: Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - localeId: Specifies the locale that should be present in the list. If you don't specify a resource type in the filters parameter, the list contains both bot locales and custom vocabularies.
    ///   - maxResults: The maximum number of imports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListImports operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListImports request to return the next page of results. For a complete set of results, call the ListImports operation until the nextToken returned in the response is null.
    ///   - sortBy: Determines the field that the list of imports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listImports(
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [ImportFilter]? = nil,
        localeId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: ImportSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImportsResponse {
        let input = ListImportsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listImports(input, logger: logger)
    }

    /// Retrieves summary metrics for the intents in your bot. The following fields are required:    metrics  A list of AnalyticsIntentMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can specify only one order in a given request.
    @Sendable
    @inlinable
    public func listIntentMetrics(_ input: ListIntentMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentMetricsResponse {
        try await self.client.execute(
            operation: "ListIntentMetrics", 
            path: "/bots/{botId}/analytics/intentmetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves summary metrics for the intents in your bot. The following fields are required:    metrics  A list of AnalyticsIntentMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can specify only one order in a given request.
    ///
    /// Parameters:
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve intent metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see intent metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    IntentName  The name of the intent.    IntentEndState  The final state of the intent. The possible end states are detailed in Key definitions in the user guide.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the order by which to organize the results.
    ///   - nextToken: If the response from the ListIntentMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentMetrics request to return the next page of results. For a complete set of results, call the ListIntentMetrics operation until the nextToken returned in the response is null.
    ///   - startDateTime: The timestamp that marks the beginning of the range of time for which you want to see intent metrics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIntentMetrics(
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsIntentFilter]? = nil,
        groupBy: [AnalyticsIntentGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsIntentMetric],
        nextToken: String? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIntentMetricsResponse {
        let input = ListIntentMetricsRequest(
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            nextToken: nextToken, 
            startDateTime: startDateTime
        )
        return try await self.listIntentMetrics(input, logger: logger)
    }

    /// Retrieves summary statistics for a path of intents that users take over sessions with your bot. The following fields are required:    startDateTime and endDateTime  Define a time range for which you want to retrieve results.    intentPath  Define an order of intents for which you want to retrieve metrics. Separate intents in the path with a forward slash. For example, populate the intentPath field with /BookCar/BookHotel to see details about how many times users invoked the BookCar and BookHotel intents in that order.   Use the optional filters field to filter the results.
    @Sendable
    @inlinable
    public func listIntentPaths(_ input: ListIntentPathsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentPathsResponse {
        try await self.client.execute(
            operation: "ListIntentPaths", 
            path: "/bots/{botId}/analytics/intentpaths", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves summary statistics for a path of intents that users take over sessions with your bot. The following fields are required:    startDateTime and endDateTime  Define a time range for which you want to retrieve results.    intentPath  Define an order of intents for which you want to retrieve metrics. Separate intents in the path with a forward slash. For example, populate the intentPath field with /BookCar/BookHotel to see details about how many times users invoked the BookCar and BookHotel intents in that order.   Use the optional filters field to filter the results.
    ///
    /// Parameters:
    ///   - botId: The identifier for the bot for which you want to retrieve intent path metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see intent path metrics.
    ///   - filters: A list of objects, each describes a condition by which you want to filter the results.
    ///   - intentPath: The intent path for which you want to retrieve metrics. Use a forward slash to separate intents in the path. For example:   /BookCar   /BookCar/BookHotel   /BookHotel/BookCar
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see intent path metrics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIntentPaths(
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsPathFilter]? = nil,
        intentPath: String,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIntentPathsResponse {
        let input = ListIntentPathsRequest(
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            intentPath: intentPath, 
            startDateTime: startDateTime
        )
        return try await self.listIntentPaths(input, logger: logger)
    }

    /// Retrieves summary metrics for the stages within intents in your bot. The following fields are required:    metrics  A list of AnalyticsIntentStageMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can only specify one order in a given request.
    @Sendable
    @inlinable
    public func listIntentStageMetrics(_ input: ListIntentStageMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentStageMetricsResponse {
        try await self.client.execute(
            operation: "ListIntentStageMetrics", 
            path: "/bots/{botId}/analytics/intentstagemetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves summary metrics for the stages within intents in your bot. The following fields are required:    metrics  A list of AnalyticsIntentStageMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. You can only specify one order in a given request.
    ///
    /// Parameters:
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve intent stage metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see intent stage metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    IntentStageName  The name of the intent stage.    SwitchedToIntent  The intent to which the conversation was switched (if any).
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    ///   - nextToken: If the response from the ListIntentStageMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentStageMetrics request to return the next page of results. For a complete set of results, call the ListIntentStageMetrics operation until the nextToken returned in the response is null.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see intent stage metrics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIntentStageMetrics(
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsIntentStageFilter]? = nil,
        groupBy: [AnalyticsIntentStageGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsIntentStageMetric],
        nextToken: String? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIntentStageMetricsResponse {
        let input = ListIntentStageMetricsRequest(
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            nextToken: nextToken, 
            startDateTime: startDateTime
        )
        return try await self.listIntentStageMetrics(input, logger: logger)
    }

    /// Get a list of intents that meet the specified criteria.
    @Sendable
    @inlinable
    public func listIntents(_ input: ListIntentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIntentsResponse {
        try await self.client.execute(
            operation: "ListIntents", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a list of intents that meet the specified criteria.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the intent.
    ///   - botVersion: The version of the bot that contains the intent.
    ///   - filters: Provides the specification of a filter used to limit the intents in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    ///   - localeId: The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntents request to return the next page of results. For a complete set of results, call the ListIntents operation until the nextToken returned in the response is null.
    ///   - sortBy: Determines the sort order for the response from the ListIntents operation. You can choose to sort by the intent name or last updated date in either ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIntents(
        botId: String,
        botVersion: String,
        filters: [IntentFilter]? = nil,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: IntentSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIntentsResponse {
        let input = ListIntentsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listIntents(input, logger: logger)
    }

    /// Gets a list of recommended intents provided by the bot recommendation that you can use in your bot. Intents in the  response are ordered by relevance.
    @Sendable
    @inlinable
    public func listRecommendedIntents(_ input: ListRecommendedIntentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRecommendedIntentsResponse {
        try await self.client.execute(
            operation: "ListRecommendedIntents", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/intents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of recommended intents provided by the bot recommendation that you can use in your bot. Intents in the  response are ordered by relevance.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot associated with the recommended intents.
    ///   - botRecommendationId: The identifier of the bot recommendation that contains the recommended intents.
    ///   - botVersion: The version of the bot that contains the recommended intents.
    ///   - localeId: The identifier of the language and locale of the recommended intents.
    ///   - maxResults: The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListRecommendedIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRecommendedIntents(
        botId: String,
        botRecommendationId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRecommendedIntentsResponse {
        let input = ListRecommendedIntentsRequest(
            botId: botId, 
            botRecommendationId: botRecommendationId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listRecommendedIntents(input, logger: logger)
    }

    /// Retrieves a list of metadata for individual user sessions with your bot. The startDateTime and endDateTime fields are required. These fields define a time range for which you want to retrieve results. Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    @Sendable
    @inlinable
    public func listSessionAnalyticsData(_ input: ListSessionAnalyticsDataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionAnalyticsDataResponse {
        try await self.client.execute(
            operation: "ListSessionAnalyticsData", 
            path: "/bots/{botId}/analytics/sessions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of metadata for individual user sessions with your bot. The startDateTime and endDateTime fields are required. These fields define a time range for which you want to retrieve results. Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    ///
    /// Parameters:
    ///   - botId: The identifier for the bot for which you want to retrieve session analytics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see session analytics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListSessionAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionAnalyticsData request to return the next page of results. For a complete set of results, call the ListSessionAnalyticsData operation until the nextToken returned in the response is null.
    ///   - sortBy: An object specifying the measure and method by which to sort the session analytics data.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see session analytics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSessionAnalyticsData(
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsSessionFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: SessionDataSortBy? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSessionAnalyticsDataResponse {
        let input = ListSessionAnalyticsDataRequest(
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy, 
            startDateTime: startDateTime
        )
        return try await self.listSessionAnalyticsData(input, logger: logger)
    }

    /// Retrieves summary metrics for the user sessions with your bot. The following fields are required:    metrics  A list of AnalyticsSessionMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    @Sendable
    @inlinable
    public func listSessionMetrics(_ input: ListSessionMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionMetricsResponse {
        try await self.client.execute(
            operation: "ListSessionMetrics", 
            path: "/bots/{botId}/analytics/sessionmetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves summary metrics for the user sessions with your bot. The following fields are required:    metrics  A list of AnalyticsSessionMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    ///
    /// Parameters:
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve session metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see session metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    ConversationEndState  The final state of the conversation. The possible end states are detailed in Key definitions in the user guide.    LocaleId  The unique identifier of the bot locale.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    ///   - nextToken: If the response from the ListSessionMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionMetrics request to return the next page of results. For a complete set of results, call the ListSessionMetrics operation until the nextToken returned in the response is null.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see session metrics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSessionMetrics(
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsSessionFilter]? = nil,
        groupBy: [AnalyticsSessionGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsSessionMetric],
        nextToken: String? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSessionMetricsResponse {
        let input = ListSessionMetricsRequest(
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            nextToken: nextToken, 
            startDateTime: startDateTime
        )
        return try await self.listSessionMetrics(input, logger: logger)
    }

    /// Gets a list of slot types that match the specified criteria.
    @Sendable
    @inlinable
    public func listSlotTypes(_ input: ListSlotTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSlotTypesResponse {
        try await self.client.execute(
            operation: "ListSlotTypes", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of slot types that match the specified criteria.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the slot types.
    ///   - botVersion: The version of the bot that contains the slot type.
    ///   - filters: Provides the specification of a filter used to limit the slot types in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    ///   - localeId: The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: Determines the sort order for the response from the ListSlotTypes operation. You can choose to sort by the slot type name or last updated date in either ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSlotTypes(
        botId: String,
        botVersion: String,
        filters: [SlotTypeFilter]? = nil,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: SlotTypeSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSlotTypesResponse {
        let input = ListSlotTypesRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listSlotTypes(input, logger: logger)
    }

    /// Gets a list of slots that match the specified criteria.
    @Sendable
    @inlinable
    public func listSlots(_ input: ListSlotsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSlotsResponse {
        try await self.client.execute(
            operation: "ListSlots", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of slots that match the specified criteria.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot that contains the slot.
    ///   - botVersion: The version of the bot that contains the slot.
    ///   - filters: Provides the specification of a filter used to limit the slots in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    ///   - intentId: The unique identifier of the intent that contains the slot.
    ///   - localeId: The identifier of the language and locale of the slots to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of slots to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListSlots operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: Determines the sort order for the response from the ListSlots operation. You can choose to sort by the slot name or last updated date in either ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSlots(
        botId: String,
        botVersion: String,
        filters: [SlotFilter]? = nil,
        intentId: String,
        localeId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: SlotSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSlotsResponse {
        let input = ListSlotsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            intentId: intentId, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listSlots(input, logger: logger)
    }

    /// Gets a list of tags associated with a resource. Only bots, bot aliases, and bot channels can have tags associated with them.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceARN}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of tags associated with a resource. Only bots, bot aliases, and bot channels can have tags associated with them.
    ///
    /// Parameters:
    ///   - resourceARN: The Amazon Resource Name (ARN) of the resource to get a list of tags for.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceARN: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceARN: resourceARN
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Gets a list of test execution result items.
    @Sendable
    @inlinable
    public func listTestExecutionResultItems(_ input: ListTestExecutionResultItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestExecutionResultItemsResponse {
        try await self.client.execute(
            operation: "ListTestExecutionResultItems", 
            path: "/testexecutions/{testExecutionId}/results", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of test execution result items.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of test execution result items to return in each  page. If there are fewer results than the max page size, only the actual  number of results are returned.
    ///   - nextToken: If the response from the ListTestExecutionResultItems operation  contains more results than specified in the maxResults parameter,  a token is returned in the response. Use that token in the nextToken  parameter to return the next page of results.
    ///   - resultFilterBy: The filter for the list of results from the test set execution.
    ///   - testExecutionId: The unique identifier of the test execution to list the result items.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTestExecutionResultItems(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resultFilterBy: TestExecutionResultFilterBy,
        testExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTestExecutionResultItemsResponse {
        let input = ListTestExecutionResultItemsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resultFilterBy: resultFilterBy, 
            testExecutionId: testExecutionId
        )
        return try await self.listTestExecutionResultItems(input, logger: logger)
    }

    /// The list of test set executions.
    @Sendable
    @inlinable
    public func listTestExecutions(_ input: ListTestExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestExecutionsResponse {
        try await self.client.execute(
            operation: "ListTestExecutions", 
            path: "/testexecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The list of test set executions.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of test executions to return in each page. If there are  fewer results than the max page size, only the actual number of results are  returned.
    ///   - nextToken: If the response from the ListTestExecutions operation contains more results  than specified in the maxResults parameter, a token is returned in the response.  Use that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: The sort order of the test set executions.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTestExecutions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: TestExecutionSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTestExecutionsResponse {
        let input = ListTestExecutionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listTestExecutions(input, logger: logger)
    }

    /// The list of test set records.
    @Sendable
    @inlinable
    public func listTestSetRecords(_ input: ListTestSetRecordsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestSetRecordsResponse {
        try await self.client.execute(
            operation: "ListTestSetRecords", 
            path: "/testsets/{testSetId}/records", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The list of test set records.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of test set records to return in each page. If there are  fewer records than the max page size, only the actual number of records are  returned.
    ///   - nextToken: If the response from the ListTestSetRecords operation contains more results  than specified in the maxResults parameter, a token is returned in the response.  Use that token in the nextToken parameter to return the next page of results.
    ///   - testSetId: The identifier of the test set to list its test set records.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTestSetRecords(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        testSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTestSetRecordsResponse {
        let input = ListTestSetRecordsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            testSetId: testSetId
        )
        return try await self.listTestSetRecords(input, logger: logger)
    }

    /// The list of the test sets
    @Sendable
    @inlinable
    public func listTestSets(_ input: ListTestSetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTestSetsResponse {
        try await self.client.execute(
            operation: "ListTestSets", 
            path: "/testsets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The list of the test sets
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of test sets to return in each page. If there are fewer  results than the max page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListTestSets operation contains more results than  specified in the maxResults parameter, a token is returned in the response. Use  that token in the nextToken parameter to return the next page of results.
    ///   - sortBy: The sort order for the list of test sets.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTestSets(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: TestSetSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTestSetsResponse {
        let input = ListTestSetsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy
        )
        return try await self.listTestSets(input, logger: logger)
    }

    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves a list of metadata for individual user utterances to your bot. The following fields are required:    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    @Sendable
    @inlinable
    public func listUtteranceAnalyticsData(_ input: ListUtteranceAnalyticsDataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListUtteranceAnalyticsDataResponse {
        try await self.client.execute(
            operation: "ListUtteranceAnalyticsData", 
            path: "/bots/{botId}/analytics/utterances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves a list of metadata for individual user utterances to your bot. The following fields are required:    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results and the sortBy field to specify the values by which to sort the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.
    ///
    /// Parameters:
    ///   - botId: The identifier for the bot for which you want to retrieve utterance analytics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see utterance analytics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - nextToken: If the response from the ListUtteranceAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceAnalyticsData request to return the next page of results. For a complete set of results, call the ListUtteranceAnalyticsData operation until the nextToken returned in the response is null.
    ///   - sortBy: An object specifying the measure and method by which to sort the utterance analytics data.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see utterance analytics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listUtteranceAnalyticsData(
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsUtteranceFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: UtteranceDataSortBy? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListUtteranceAnalyticsDataResponse {
        let input = ListUtteranceAnalyticsDataRequest(
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy, 
            startDateTime: startDateTime
        )
        return try await self.listUtteranceAnalyticsData(input, logger: logger)
    }

    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves summary metrics for the utterances in your bot. The following fields are required:    metrics  A list of AnalyticsUtteranceMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    @Sendable
    @inlinable
    public func listUtteranceMetrics(_ input: ListUtteranceMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListUtteranceMetricsResponse {
        try await self.client.execute(
            operation: "ListUtteranceMetrics", 
            path: "/bots/{botId}/analytics/utterancemetrics", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  To use this API operation, your IAM role must have permissions to perform the ListAggregatedUtterances operation, which provides access to utterance-related analytics. See Viewing utterance statistics for the IAM policy to apply to the IAM role.  Retrieves summary metrics for the utterances in your bot. The following fields are required:    metrics  A list of AnalyticsUtteranceMetric objects. In each object, use the name field to specify the metric to calculate, the statistic field to specify whether to calculate the Sum, Average, or Max number, and the order field to specify whether to sort the results in Ascending or Descending order.    startDateTime and endDateTime  Define a time range for which you want to retrieve results.   Of the optional fields, you can organize the results in the following ways:   Use the filters field to filter the results, the groupBy field to specify categories by which to group the results, and the binBy field to specify time intervals by which to group the results.   Use the maxResults field to limit the number of results to return in a single response and the nextToken field to return the next batch of results if the response does not return the full set of results.   Note that an order field exists in both binBy and metrics. Currently, you can specify it in either field, but not in both.
    ///
    /// Parameters:
    ///   - attributes: A list containing attributes related to the utterance that you want the response to return. The following attributes are possible:    LastUsedIntent  The last used intent at the time of the utterance.
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve utterance metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see utterance metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    UtteranceText  The transcription of the utterance.    UtteranceState  The state of the utterance. The possible states are detailed in Key definitions in the user guide.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    ///   - nextToken: If the response from the ListUtteranceMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceMetrics request to return the next page of results. For a complete set of results, call the ListUtteranceMetrics operation until the nextToken returned in the response is null.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see utterance metrics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listUtteranceMetrics(
        attributes: [AnalyticsUtteranceAttribute]? = nil,
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsUtteranceFilter]? = nil,
        groupBy: [AnalyticsUtteranceGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsUtteranceMetric],
        nextToken: String? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListUtteranceMetricsResponse {
        let input = ListUtteranceMetricsRequest(
            attributes: attributes, 
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            nextToken: nextToken, 
            startDateTime: startDateTime
        )
        return try await self.listUtteranceMetrics(input, logger: logger)
    }

    /// Search for associated transcripts that meet the specified criteria.
    @Sendable
    @inlinable
    public func searchAssociatedTranscripts(_ input: SearchAssociatedTranscriptsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchAssociatedTranscriptsResponse {
        try await self.client.execute(
            operation: "SearchAssociatedTranscripts", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/associatedtranscripts", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Search for associated transcripts that meet the specified criteria.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot associated with the transcripts that you are searching.
    ///   - botRecommendationId: The unique identifier of the bot recommendation associated with the transcripts to search.
    ///   - botVersion: The version of the bot containing the transcripts that you are searching.
    ///   - filters: A list of filter objects.
    ///   - localeId: The identifier of the language and locale of the transcripts to search. The string must match one of the supported locales. For more information, see Supported languages
    ///   - maxResults: The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - nextIndex: If the response from the SearchAssociatedTranscriptsRequest operation contains more results than specified in the maxResults parameter, an index is returned in the response. Use that index in the nextIndex parameter to return the next page of results.
    ///   - searchOrder: How SearchResults are ordered. Valid values are Ascending or Descending. The default is Descending.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchAssociatedTranscripts(
        botId: String,
        botRecommendationId: String,
        botVersion: String,
        filters: [AssociatedTranscriptFilter],
        localeId: String,
        maxResults: Int? = nil,
        nextIndex: Int? = nil,
        searchOrder: SearchOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchAssociatedTranscriptsResponse {
        let input = SearchAssociatedTranscriptsRequest(
            botId: botId, 
            botRecommendationId: botRecommendationId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            nextIndex: nextIndex, 
            searchOrder: searchOrder
        )
        return try await self.searchAssociatedTranscripts(input, logger: logger)
    }

    /// Use this to provide your transcript data, and to start the bot recommendation process.
    @Sendable
    @inlinable
    public func startBotRecommendation(_ input: StartBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartBotRecommendationResponse {
        try await self.client.execute(
            operation: "StartBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use this to provide your transcript data, and to start the bot recommendation process.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot containing the bot recommendation.
    ///   - botVersion: The version of the bot containing the bot recommendation.
    ///   - encryptionSetting: The object representing the passwords that will be used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
    ///   - localeId: The identifier of the language and locale of the bot recommendation to start. The string must match one of the supported locales. For more information, see Supported languages
    ///   - transcriptSourceSetting: The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
    ///   - logger: Logger use during operation
    @inlinable
    public func startBotRecommendation(
        botId: String,
        botVersion: String,
        encryptionSetting: EncryptionSetting? = nil,
        localeId: String,
        transcriptSourceSetting: TranscriptSourceSetting,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartBotRecommendationResponse {
        let input = StartBotRecommendationRequest(
            botId: botId, 
            botVersion: botVersion, 
            encryptionSetting: encryptionSetting, 
            localeId: localeId, 
            transcriptSourceSetting: transcriptSourceSetting
        )
        return try await self.startBotRecommendation(input, logger: logger)
    }

    /// Starts a request for the descriptive bot builder to generate a bot locale configuration  based on the prompt you provide it. After you make this call, use the DescribeBotResourceGeneration  operation to check on the status of the generation and for the generatedBotLocaleUrl when the  generation is complete. Use that value to retrieve the Amazon S3 object containing the bot locale configuration. You can  then modify and import this configuration.
    @Sendable
    @inlinable
    public func startBotResourceGeneration(_ input: StartBotResourceGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartBotResourceGenerationResponse {
        try await self.client.execute(
            operation: "StartBotResourceGeneration", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/startgeneration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a request for the descriptive bot builder to generate a bot locale configuration  based on the prompt you provide it. After you make this call, use the DescribeBotResourceGeneration  operation to check on the status of the generation and for the generatedBotLocaleUrl when the  generation is complete. Use that value to retrieve the Amazon S3 object containing the bot locale configuration. You can  then modify and import this configuration.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot for which to generate intents and slot types.
    ///   - botVersion: The version of the bot for which to generate intents and slot types.
    ///   - generationInputPrompt: The prompt to generate intents and slot types for the bot locale. Your description should be both detailed and precise to help generate appropriate and sufficient intents for your bot. Include a list of actions to improve the intent creation process.
    ///   - localeId: The locale of the bot for which to generate intents and slot types.
    ///   - logger: Logger use during operation
    @inlinable
    public func startBotResourceGeneration(
        botId: String,
        botVersion: String,
        generationInputPrompt: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartBotResourceGenerationResponse {
        let input = StartBotResourceGenerationRequest(
            botId: botId, 
            botVersion: botVersion, 
            generationInputPrompt: generationInputPrompt, 
            localeId: localeId
        )
        return try await self.startBotResourceGeneration(input, logger: logger)
    }

    /// Starts importing a bot, bot locale, or custom vocabulary from a zip archive that you uploaded to an S3 bucket.
    @Sendable
    @inlinable
    public func startImport(_ input: StartImportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartImportResponse {
        try await self.client.execute(
            operation: "StartImport", 
            path: "/imports", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts importing a bot, bot locale, or custom vocabulary from a zip archive that you uploaded to an S3 bucket.
    ///
    /// Parameters:
    ///   - filePassword: The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex.
    ///   - importId: The unique identifier for the import. It is included in the response from the CreateUploadUrl operation.
    ///   - mergeStrategy: The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is FailOnConflict existing resources are not overwritten and the import fails.
    ///   - resourceSpecification: Parameters for creating the bot, bot locale or custom vocabulary.
    ///   - logger: Logger use during operation
    @inlinable
    public func startImport(
        filePassword: String? = nil,
        importId: String,
        mergeStrategy: MergeStrategy,
        resourceSpecification: ImportResourceSpecification,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartImportResponse {
        let input = StartImportRequest(
            filePassword: filePassword, 
            importId: importId, 
            mergeStrategy: mergeStrategy, 
            resourceSpecification: resourceSpecification
        )
        return try await self.startImport(input, logger: logger)
    }

    /// The action to start test set execution.
    @Sendable
    @inlinable
    public func startTestExecution(_ input: StartTestExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartTestExecutionResponse {
        try await self.client.execute(
            operation: "StartTestExecution", 
            path: "/testsets/{testSetId}/testexecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The action to start test set execution.
    ///
    /// Parameters:
    ///   - apiMode: Indicates whether we use streaming or non-streaming APIs for the test set  execution. For streaming, StartConversation Runtime API is used. Whereas, for  non-streaming, RecognizeUtterance and RecognizeText Amazon Lex  Runtime API are used.
    ///   - target: The target bot for the test set execution.
    ///   - testExecutionModality: Indicates whether audio or text is used.
    ///   - testSetId: The test set Id for the test set execution.
    ///   - logger: Logger use during operation
    @inlinable
    public func startTestExecution(
        apiMode: TestExecutionApiMode,
        target: TestExecutionTarget,
        testExecutionModality: TestExecutionModality? = nil,
        testSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartTestExecutionResponse {
        let input = StartTestExecutionRequest(
            apiMode: apiMode, 
            target: target, 
            testExecutionModality: testExecutionModality, 
            testSetId: testSetId
        )
        return try await self.startTestExecution(input, logger: logger)
    }

    /// The action to start the generation of test set.
    @Sendable
    @inlinable
    public func startTestSetGeneration(_ input: StartTestSetGenerationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartTestSetGenerationResponse {
        try await self.client.execute(
            operation: "StartTestSetGeneration", 
            path: "/testsetgenerations", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The action to start the generation of test set.
    ///
    /// Parameters:
    ///   - description: The test set description for the test set generation request.
    ///   - generationDataSource: The data source for the test set generation.
    ///   - roleArn: The roleARN used for any operation in the test set to access  resources in the Amazon Web Services account.
    ///   - storageLocation: The Amazon S3 storage location for the test set generation.
    ///   - testSetName: The test set name for the test set generation request.
    ///   - testSetTags: A list of tags to add to the test set. You can only add tags when you import/generate a new test set. You can't use the UpdateTestSet operation to update tags. To update tags, use the TagResource operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func startTestSetGeneration(
        description: String? = nil,
        generationDataSource: TestSetGenerationDataSource,
        roleArn: String,
        storageLocation: TestSetStorageLocation,
        testSetName: String,
        testSetTags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartTestSetGenerationResponse {
        let input = StartTestSetGenerationRequest(
            description: description, 
            generationDataSource: generationDataSource, 
            roleArn: roleArn, 
            storageLocation: storageLocation, 
            testSetName: testSetName, 
            testSetTags: testSetTags
        )
        return try await self.startTestSetGeneration(input, logger: logger)
    }

    /// Stop an already running Bot Recommendation request.
    @Sendable
    @inlinable
    public func stopBotRecommendation(_ input: StopBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopBotRecommendationResponse {
        try await self.client.execute(
            operation: "StopBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}/stopbotrecommendation", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stop an already running Bot Recommendation request.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot containing the bot recommendation to be stopped.
    ///   - botRecommendationId: The unique identifier of the bot recommendation to be stopped.
    ///   - botVersion: The version of the bot containing the bot recommendation.
    ///   - localeId: The identifier of the language and locale of the bot recommendation to stop. The string must match one of the supported locales. For more information, see Supported languages
    ///   - logger: Logger use during operation
    @inlinable
    public func stopBotRecommendation(
        botId: String,
        botRecommendationId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopBotRecommendationResponse {
        let input = StopBotRecommendationRequest(
            botId: botId, 
            botRecommendationId: botRecommendationId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        return try await self.stopBotRecommendation(input, logger: logger)
    }

    /// Adds the specified tags to the specified resource. If a tag key already exists, the existing value is replaced with the new value.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceARN}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds the specified tags to the specified resource. If a tag key already exists, the existing value is replaced with the new value.
    ///
    /// Parameters:
    ///   - resourceARN: The Amazon Resource Name (ARN) of the bot, bot alias, or bot channel to tag.
    ///   - tags: A list of tag keys to add to the resource. If a tag key already exists, the existing value is replaced with the new value.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceARN: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceARN: resourceARN, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes tags from a bot, bot alias, or bot channel.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceARN}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags from a bot, bot alias, or bot channel.
    ///
    /// Parameters:
    ///   - resourceARN: The Amazon Resource Name (ARN) of the resource to remove the tags from.
    ///   - tagKeys: A list of tag keys to remove from the resource. If a tag key does not exist on the resource, it is ignored.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceARN: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceARN: resourceARN, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the configuration of an existing bot.
    @Sendable
    @inlinable
    public func updateBot(_ input: UpdateBotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotResponse {
        try await self.client.execute(
            operation: "UpdateBot", 
            path: "/bots/{botId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of an existing bot.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot to update. This identifier is returned by the CreateBot operation.
    ///   - botMembers: The list of bot members in the network associated  with the update action.
    ///   - botName: The new name of the bot. The name must be unique in the account that creates the bot.
    ///   - botType: The type of the bot to be updated.
    ///   - dataPrivacy: Provides information on additional privacy protections Amazon Lex should use with the bot's data.
    ///   - description: A description of the bot.
    ///   - errorLogSettings: Allows you to modify how Amazon Lex logs errors during bot interactions, including destinations for error logs and the types of errors to be captured.
    ///   - idleSessionTTLInSeconds: The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
    ///   - roleArn: The Amazon Resource Name (ARN) of an IAM role that has permissions to access the bot.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBot(
        botId: String,
        botMembers: [BotMember]? = nil,
        botName: String,
        botType: BotType? = nil,
        dataPrivacy: DataPrivacy,
        description: String? = nil,
        errorLogSettings: ErrorLogSettings? = nil,
        idleSessionTTLInSeconds: Int,
        roleArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBotResponse {
        let input = UpdateBotRequest(
            botId: botId, 
            botMembers: botMembers, 
            botName: botName, 
            botType: botType, 
            dataPrivacy: dataPrivacy, 
            description: description, 
            errorLogSettings: errorLogSettings, 
            idleSessionTTLInSeconds: idleSessionTTLInSeconds, 
            roleArn: roleArn
        )
        return try await self.updateBot(input, logger: logger)
    }

    /// Updates the configuration of an existing bot alias.
    @Sendable
    @inlinable
    public func updateBotAlias(_ input: UpdateBotAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotAliasResponse {
        try await self.client.execute(
            operation: "UpdateBotAlias", 
            path: "/bots/{botId}/botaliases/{botAliasId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of an existing bot alias.
    ///
    /// Parameters:
    ///   - botAliasId: The unique identifier of the bot alias.
    ///   - botAliasLocaleSettings: The new Lambda functions to use in each locale for the bot alias.
    ///   - botAliasName: The new name to assign to the bot alias.
    ///   - botId: The identifier of the bot with the updated alias.
    ///   - botVersion: The new bot version to assign to the bot alias.
    ///   - conversationLogSettings: The new settings for storing conversation logs in Amazon CloudWatch Logs and Amazon S3 buckets.
    ///   - description: The new description to assign to the bot alias.
    ///   - sentimentAnalysisSettings: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBotAlias(
        botAliasId: String,
        botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil,
        botAliasName: String,
        botId: String,
        botVersion: String? = nil,
        conversationLogSettings: ConversationLogSettings? = nil,
        description: String? = nil,
        sentimentAnalysisSettings: SentimentAnalysisSettings? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBotAliasResponse {
        let input = UpdateBotAliasRequest(
            botAliasId: botAliasId, 
            botAliasLocaleSettings: botAliasLocaleSettings, 
            botAliasName: botAliasName, 
            botId: botId, 
            botVersion: botVersion, 
            conversationLogSettings: conversationLogSettings, 
            description: description, 
            sentimentAnalysisSettings: sentimentAnalysisSettings
        )
        return try await self.updateBotAlias(input, logger: logger)
    }

    /// Updates the settings that a bot has for a specific locale.
    @Sendable
    @inlinable
    public func updateBotLocale(_ input: UpdateBotLocaleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotLocaleResponse {
        try await self.client.execute(
            operation: "UpdateBotLocale", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the settings that a bot has for a specific locale.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the locale.
    ///   - botVersion: The version of the bot that contains the locale to be updated. The version can only be the DRAFT version.
    ///   - description: The new description of the locale.
    ///   - generativeAISettings: Contains settings for generative AI features powered by Amazon Bedrock for your bot locale. Use this object to turn generative AI features on and off. Pricing  may differ if you turn a feature on. For more information, see LINK.
    ///   - localeId: The identifier of the language and locale to update. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - nluIntentConfidenceThreshold: The new confidence threshold where Amazon Lex inserts the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
    ///   - voiceSettings: The new Amazon Polly voice Amazon Lex should use for voice interaction with the user.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBotLocale(
        botId: String,
        botVersion: String,
        description: String? = nil,
        generativeAISettings: GenerativeAISettings? = nil,
        localeId: String,
        nluIntentConfidenceThreshold: Double,
        voiceSettings: VoiceSettings? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBotLocaleResponse {
        let input = UpdateBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            description: description, 
            generativeAISettings: generativeAISettings, 
            localeId: localeId, 
            nluIntentConfidenceThreshold: nluIntentConfidenceThreshold, 
            voiceSettings: voiceSettings
        )
        return try await self.updateBotLocale(input, logger: logger)
    }

    /// Updates an existing bot recommendation request.
    @Sendable
    @inlinable
    public func updateBotRecommendation(_ input: UpdateBotRecommendationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBotRecommendationResponse {
        try await self.client.execute(
            operation: "UpdateBotRecommendation", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/botrecommendations/{botRecommendationId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing bot recommendation request.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot containing the bot recommendation to be updated.
    ///   - botRecommendationId: The unique identifier of the bot recommendation to be updated.
    ///   - botVersion: The version of the bot containing the bot recommendation to be updated.
    ///   - encryptionSetting: The object representing the passwords that will be used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
    ///   - localeId: The identifier of the language and locale of the bot recommendation to update. The string must match one of the supported locales. For more information, see Supported languages
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBotRecommendation(
        botId: String,
        botRecommendationId: String,
        botVersion: String,
        encryptionSetting: EncryptionSetting,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBotRecommendationResponse {
        let input = UpdateBotRecommendationRequest(
            botId: botId, 
            botRecommendationId: botRecommendationId, 
            botVersion: botVersion, 
            encryptionSetting: encryptionSetting, 
            localeId: localeId
        )
        return try await self.updateBotRecommendation(input, logger: logger)
    }

    /// Updates the password used to protect an export zip archive. The password is not required. If you don't supply a password, Amazon Lex generates a zip file that is not protected by a password. This is the archive that is available at the pre-signed S3 URL provided by the DescribeExport operation.
    @Sendable
    @inlinable
    public func updateExport(_ input: UpdateExportRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateExportResponse {
        try await self.client.execute(
            operation: "UpdateExport", 
            path: "/exports/{exportId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the password used to protect an export zip archive. The password is not required. If you don't supply a password, Amazon Lex generates a zip file that is not protected by a password. This is the archive that is available at the pre-signed S3 URL provided by the DescribeExport operation.
    ///
    /// Parameters:
    ///   - exportId: The unique identifier Amazon Lex assigned to the export.
    ///   - filePassword: The new password to use to encrypt the export zip archive.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateExport(
        exportId: String,
        filePassword: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateExportResponse {
        let input = UpdateExportRequest(
            exportId: exportId, 
            filePassword: filePassword
        )
        return try await self.updateExport(input, logger: logger)
    }

    /// Updates the settings for an intent.
    @Sendable
    @inlinable
    public func updateIntent(_ input: UpdateIntentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIntentResponse {
        try await self.client.execute(
            operation: "UpdateIntent", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the settings for an intent.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot that contains the intent.
    ///   - botVersion: The version of the bot that contains the intent. Must be DRAFT.
    ///   - description: The new description of the intent.
    ///   - dialogCodeHook: The new Lambda function to use between each turn of the conversation with the bot.
    ///   - fulfillmentCodeHook: The new Lambda function to call when all of the intents required slots are provided and the intent is ready for fulfillment.
    ///   - initialResponseSetting: Configuration settings for a response sent to the user before Amazon Lex starts eliciting slots.
    ///   - inputContexts: A new list of contexts that must be active in order for Amazon Lex to consider the intent.
    ///   - intentClosingSetting: The new response that Amazon Lex sends the user when the intent is closed.
    ///   - intentConfirmationSetting: New prompts that Amazon Lex sends to the user to confirm the completion of an intent.
    ///   - intentId: The unique identifier of the intent to update.
    ///   - intentName: The new name for the intent.
    ///   - kendraConfiguration: New configuration settings for connecting to an Amazon Kendra index.
    ///   - localeId: The identifier of the language and locale where this intent is used. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - outputContexts: A new list of contexts that Amazon Lex activates when the intent is fulfilled.
    ///   - parentIntentSignature: The signature of the new built-in intent to use as the parent of this intent.
    ///   - qInConnectIntentConfiguration: Qinconnect intent configuration details for the update intent request.
    ///   - qnAIntentConfiguration: Specifies the configuration of the built-in Amazon.QnAIntent. The AMAZON.QnAIntent intent is called when Amazon Lex can't determine another intent to invoke. If you specify this field, you can't specify the kendraConfiguration field.
    ///   - sampleUtterances: New utterances used to invoke the intent.
    ///   - slotPriorities: A new list of slots and their priorities that are contained by the intent.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIntent(
        botId: String,
        botVersion: String,
        description: String? = nil,
        dialogCodeHook: DialogCodeHookSettings? = nil,
        fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil,
        initialResponseSetting: InitialResponseSetting? = nil,
        inputContexts: [InputContext]? = nil,
        intentClosingSetting: IntentClosingSetting? = nil,
        intentConfirmationSetting: IntentConfirmationSetting? = nil,
        intentId: String,
        intentName: String,
        kendraConfiguration: KendraConfiguration? = nil,
        localeId: String,
        outputContexts: [OutputContext]? = nil,
        parentIntentSignature: String? = nil,
        qInConnectIntentConfiguration: QInConnectIntentConfiguration? = nil,
        qnAIntentConfiguration: QnAIntentConfiguration? = nil,
        sampleUtterances: [SampleUtterance]? = nil,
        slotPriorities: [SlotPriority]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIntentResponse {
        let input = UpdateIntentRequest(
            botId: botId, 
            botVersion: botVersion, 
            description: description, 
            dialogCodeHook: dialogCodeHook, 
            fulfillmentCodeHook: fulfillmentCodeHook, 
            initialResponseSetting: initialResponseSetting, 
            inputContexts: inputContexts, 
            intentClosingSetting: intentClosingSetting, 
            intentConfirmationSetting: intentConfirmationSetting, 
            intentId: intentId, 
            intentName: intentName, 
            kendraConfiguration: kendraConfiguration, 
            localeId: localeId, 
            outputContexts: outputContexts, 
            parentIntentSignature: parentIntentSignature, 
            qInConnectIntentConfiguration: qInConnectIntentConfiguration, 
            qnAIntentConfiguration: qnAIntentConfiguration, 
            sampleUtterances: sampleUtterances, 
            slotPriorities: slotPriorities
        )
        return try await self.updateIntent(input, logger: logger)
    }

    /// Replaces the existing resource policy for a bot or bot alias with a new one. If the policy doesn't exist, Amazon Lex returns an exception.
    @Sendable
    @inlinable
    public func updateResourcePolicy(_ input: UpdateResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResourcePolicyResponse {
        try await self.client.execute(
            operation: "UpdateResourcePolicy", 
            path: "/policy/{resourceArn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Replaces the existing resource policy for a bot or bot alias with a new one. If the policy doesn't exist, Amazon Lex returns an exception.
    ///
    /// Parameters:
    ///   - expectedRevisionId: The identifier of the revision of the policy to update. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex overwrites the contents of the policy with the new values.
    ///   - policy: A resource policy to add to the resource. The policy is a JSON structure that contains one or more statements that define the policy. The policy must follow the IAM syntax. For more information about the contents of a JSON policy document, see  IAM JSON policy reference .  If the policy isn't valid, Amazon Lex returns a validation exception.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateResourcePolicy(
        expectedRevisionId: String? = nil,
        policy: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateResourcePolicyResponse {
        let input = UpdateResourcePolicyRequest(
            expectedRevisionId: expectedRevisionId, 
            policy: policy, 
            resourceArn: resourceArn
        )
        return try await self.updateResourcePolicy(input, logger: logger)
    }

    /// Updates the settings for a slot.
    @Sendable
    @inlinable
    public func updateSlot(_ input: UpdateSlotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSlotResponse {
        try await self.client.execute(
            operation: "UpdateSlot", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the settings for a slot.
    ///
    /// Parameters:
    ///   - botId: The unique identifier of the bot that contains the slot.
    ///   - botVersion: The version of the bot that contains the slot. Must always be DRAFT.
    ///   - description: The new description for the slot.
    ///   - intentId: The identifier of the intent that contains the slot.
    ///   - localeId: The identifier of the language and locale that contains the slot. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - multipleValuesSetting: Determines whether the slot accepts multiple values in one response. Multiple value slots are only available in the en-US locale. If you set this value to true in any other locale, Amazon Lex throws a ValidationException. If the multipleValuesSetting is not set, the default value is false.
    ///   - obfuscationSetting: New settings that determine how slot values are formatted in Amazon CloudWatch logs.
    ///   - slotId: The unique identifier for the slot to update.
    ///   - slotName: The new name for the slot.
    ///   - slotTypeId: The unique identifier of the new slot type to associate with this slot.
    ///   - subSlotSetting: Specifications for the constituent sub slots and the   expression for the composite slot.
    ///   - valueElicitationSetting: A new set of prompts that Amazon Lex sends to the user to elicit a response the provides a value for the slot.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSlot(
        botId: String,
        botVersion: String,
        description: String? = nil,
        intentId: String,
        localeId: String,
        multipleValuesSetting: MultipleValuesSetting? = nil,
        obfuscationSetting: ObfuscationSetting? = nil,
        slotId: String,
        slotName: String,
        slotTypeId: String? = nil,
        subSlotSetting: SubSlotSetting? = nil,
        valueElicitationSetting: SlotValueElicitationSetting,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSlotResponse {
        let input = UpdateSlotRequest(
            botId: botId, 
            botVersion: botVersion, 
            description: description, 
            intentId: intentId, 
            localeId: localeId, 
            multipleValuesSetting: multipleValuesSetting, 
            obfuscationSetting: obfuscationSetting, 
            slotId: slotId, 
            slotName: slotName, 
            slotTypeId: slotTypeId, 
            subSlotSetting: subSlotSetting, 
            valueElicitationSetting: valueElicitationSetting
        )
        return try await self.updateSlot(input, logger: logger)
    }

    /// Updates the configuration of an existing slot type.
    @Sendable
    @inlinable
    public func updateSlotType(_ input: UpdateSlotTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSlotTypeResponse {
        try await self.client.execute(
            operation: "UpdateSlotType", 
            path: "/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of an existing slot type.
    ///
    /// Parameters:
    ///   - botId: The identifier of the bot that contains the slot type.
    ///   - botVersion: The version of the bot that contains the slot type. Must be DRAFT.
    ///   - compositeSlotTypeSetting: Specifications for a composite slot type.
    ///   - description: The new description of the slot type.
    ///   - externalSourceSetting: 
    ///   - localeId: The identifier of the language and locale that contains the slot type. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - parentSlotTypeSignature: The new built-in slot type that should be used as the parent of this slot type.
    ///   - slotTypeId: The unique identifier of the slot type to update.
    ///   - slotTypeName: The new name of the slot type.
    ///   - slotTypeValues: A new list of values and their optional synonyms that define the values that the slot type can take.
    ///   - valueSelectionSetting: The strategy that Amazon Lex should use when deciding on a value from the list of slot type values.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSlotType(
        botId: String,
        botVersion: String,
        compositeSlotTypeSetting: CompositeSlotTypeSetting? = nil,
        description: String? = nil,
        externalSourceSetting: ExternalSourceSetting? = nil,
        localeId: String,
        parentSlotTypeSignature: String? = nil,
        slotTypeId: String,
        slotTypeName: String,
        slotTypeValues: [SlotTypeValue]? = nil,
        valueSelectionSetting: SlotValueSelectionSetting? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSlotTypeResponse {
        let input = UpdateSlotTypeRequest(
            botId: botId, 
            botVersion: botVersion, 
            compositeSlotTypeSetting: compositeSlotTypeSetting, 
            description: description, 
            externalSourceSetting: externalSourceSetting, 
            localeId: localeId, 
            parentSlotTypeSignature: parentSlotTypeSignature, 
            slotTypeId: slotTypeId, 
            slotTypeName: slotTypeName, 
            slotTypeValues: slotTypeValues, 
            valueSelectionSetting: valueSelectionSetting
        )
        return try await self.updateSlotType(input, logger: logger)
    }

    /// The action to update the test set.
    @Sendable
    @inlinable
    public func updateTestSet(_ input: UpdateTestSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTestSetResponse {
        try await self.client.execute(
            operation: "UpdateTestSet", 
            path: "/testsets/{testSetId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The action to update the test set.
    ///
    /// Parameters:
    ///   - description: The new test set description.
    ///   - testSetId: The test set Id for which update test operation to be performed.
    ///   - testSetName: The new test set name.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTestSet(
        description: String? = nil,
        testSetId: String,
        testSetName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTestSetResponse {
        let input = UpdateTestSetRequest(
            description: description, 
            testSetId: testSetId, 
            testSetName: testSetName
        )
        return try await self.updateTestSet(input, logger: logger)
    }
}

extension LexModelsV2 {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: LexModelsV2, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension LexModelsV2 {
    /// Return PaginatorSequence for operation ``listAggregatedUtterances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAggregatedUtterancesPaginator(
        _ input: ListAggregatedUtterancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAggregatedUtterancesRequest, ListAggregatedUtterancesResponse> {
        return .init(
            input: input,
            command: self.listAggregatedUtterances,
            inputKey: \ListAggregatedUtterancesRequest.nextToken,
            outputKey: \ListAggregatedUtterancesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAggregatedUtterances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - aggregationDuration: The time window for aggregating the utterance information. You can specify a time between one hour and two weeks.
    ///   - botAliasId: The identifier of the bot alias associated with this request. If you specify the bot alias, you can't specify the bot version.
    ///   - botId: The unique identifier of the bot associated with this request.
    ///   - botVersion: The identifier of the bot version associated with this request. If you specify the bot version, you can't specify the bot alias.
    ///   - filters: Provides the specification of a filter used to limit the utterances in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - localeId: The identifier of the language and locale where the utterances were collected. For more information, see Supported languages.
    ///   - maxResults: The maximum number of utterances to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned. If you don't specify the maxResults parameter, 1,000 results are returned.
    ///   - sortBy: Specifies sorting parameters for the list of utterances. You can sort by the hit count, the missed count, or the number of distinct sessions the utterance appeared in.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAggregatedUtterancesPaginator(
        aggregationDuration: UtteranceAggregationDuration,
        botAliasId: String? = nil,
        botId: String,
        botVersion: String? = nil,
        filters: [AggregatedUtterancesFilter]? = nil,
        localeId: String,
        maxResults: Int? = nil,
        sortBy: AggregatedUtterancesSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAggregatedUtterancesRequest, ListAggregatedUtterancesResponse> {
        let input = ListAggregatedUtterancesRequest(
            aggregationDuration: aggregationDuration, 
            botAliasId: botAliasId, 
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listAggregatedUtterancesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBotAliasReplicas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotAliasReplicasPaginator(
        _ input: ListBotAliasReplicasRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotAliasReplicasRequest, ListBotAliasReplicasResponse> {
        return .init(
            input: input,
            command: self.listBotAliasReplicas,
            inputKey: \ListBotAliasReplicasRequest.nextToken,
            outputKey: \ListBotAliasReplicasResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBotAliasReplicas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The request for the unique bot ID of the replicated bot created from the source bot alias.
    ///   - maxResults: The request for maximum results to list the replicated bots created from the source bot alias.
    ///   - replicaRegion: The request for the secondary region of the replicated bot created from the source bot alias.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotAliasReplicasPaginator(
        botId: String,
        maxResults: Int? = nil,
        replicaRegion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotAliasReplicasRequest, ListBotAliasReplicasResponse> {
        let input = ListBotAliasReplicasRequest(
            botId: botId, 
            maxResults: maxResults, 
            replicaRegion: replicaRegion
        )
        return self.listBotAliasReplicasPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBotAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotAliasesPaginator(
        _ input: ListBotAliasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotAliasesRequest, ListBotAliasesResponse> {
        return .init(
            input: input,
            command: self.listBotAliases,
            inputKey: \ListBotAliasesRequest.nextToken,
            outputKey: \ListBotAliasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBotAliases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot to list aliases for.
    ///   - maxResults: The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotAliasesPaginator(
        botId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotAliasesRequest, ListBotAliasesResponse> {
        let input = ListBotAliasesRequest(
            botId: botId, 
            maxResults: maxResults
        )
        return self.listBotAliasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBotLocales(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotLocalesPaginator(
        _ input: ListBotLocalesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotLocalesRequest, ListBotLocalesResponse> {
        return .init(
            input: input,
            command: self.listBotLocales,
            inputKey: \ListBotLocalesRequest.nextToken,
            outputKey: \ListBotLocalesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBotLocales(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot to list locales for.
    ///   - botVersion: The version of the bot to list locales for.
    ///   - filters: Provides the specification for a filter used to limit the response to only those locales that match the filter specification. You can only specify one filter and one value to filter on.
    ///   - maxResults: The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Specifies sorting parameters for the list of locales. You can sort by locale name in ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotLocalesPaginator(
        botId: String,
        botVersion: String,
        filters: [BotLocaleFilter]? = nil,
        maxResults: Int? = nil,
        sortBy: BotLocaleSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotLocalesRequest, ListBotLocalesResponse> {
        let input = ListBotLocalesRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listBotLocalesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBotRecommendations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotRecommendationsPaginator(
        _ input: ListBotRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotRecommendationsRequest, ListBotRecommendationsResponse> {
        return .init(
            input: input,
            command: self.listBotRecommendations,
            inputKey: \ListBotRecommendationsRequest.nextToken,
            outputKey: \ListBotRecommendationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBotRecommendations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier of the bot that contains the bot recommendation list.
    ///   - botVersion: The version of the bot that contains the bot recommendation list.
    ///   - localeId: The identifier of the language and locale of the bot recommendation list.
    ///   - maxResults: The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotRecommendationsPaginator(
        botId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotRecommendationsRequest, ListBotRecommendationsResponse> {
        let input = ListBotRecommendationsRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults
        )
        return self.listBotRecommendationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBotResourceGenerations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotResourceGenerationsPaginator(
        _ input: ListBotResourceGenerationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotResourceGenerationsRequest, ListBotResourceGenerationsResponse> {
        return .init(
            input: input,
            command: self.listBotResourceGenerations,
            inputKey: \ListBotResourceGenerationsRequest.nextToken,
            outputKey: \ListBotResourceGenerationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBotResourceGenerations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier of the bot whose generation  requests you want to view.
    ///   - botVersion: The version of the bot whose generation  requests you want to view.
    ///   - localeId: The locale of the bot whose generation  requests you want to view.
    ///   - maxResults: The maximum number of results to return in the response.
    ///   - sortBy: An object containing information about the attribute and the  method by which to sort the results
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotResourceGenerationsPaginator(
        botId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        sortBy: GenerationSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotResourceGenerationsRequest, ListBotResourceGenerationsResponse> {
        let input = ListBotResourceGenerationsRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listBotResourceGenerationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBotVersionReplicas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotVersionReplicasPaginator(
        _ input: ListBotVersionReplicasRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotVersionReplicasRequest, ListBotVersionReplicasResponse> {
        return .init(
            input: input,
            command: self.listBotVersionReplicas,
            inputKey: \ListBotVersionReplicasRequest.nextToken,
            outputKey: \ListBotVersionReplicasResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBotVersionReplicas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The request for the unique ID in the list of replicated bots.
    ///   - maxResults: The maximum results given in the list of replicated bots.
    ///   - replicaRegion: The request for the region used in the list of replicated bots.
    ///   - sortBy: The requested sort category for the list of replicated bots.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotVersionReplicasPaginator(
        botId: String,
        maxResults: Int? = nil,
        replicaRegion: String,
        sortBy: BotVersionReplicaSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotVersionReplicasRequest, ListBotVersionReplicasResponse> {
        let input = ListBotVersionReplicasRequest(
            botId: botId, 
            maxResults: maxResults, 
            replicaRegion: replicaRegion, 
            sortBy: sortBy
        )
        return self.listBotVersionReplicasPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBotVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotVersionsPaginator(
        _ input: ListBotVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotVersionsRequest, ListBotVersionsResponse> {
        return .init(
            input: input,
            command: self.listBotVersions,
            inputKey: \ListBotVersionsRequest.nextToken,
            outputKey: \ListBotVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBotVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot to list versions for.
    ///   - maxResults: The maximum number of versions to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Specifies sorting parameters for the list of versions. You can specify that the list be sorted by version name in either ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotVersionsPaginator(
        botId: String,
        maxResults: Int? = nil,
        sortBy: BotVersionSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotVersionsRequest, ListBotVersionsResponse> {
        let input = ListBotVersionsRequest(
            botId: botId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listBotVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotsPaginator(
        _ input: ListBotsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBotsRequest, ListBotsResponse> {
        return .init(
            input: input,
            command: self.listBots,
            inputKey: \ListBotsRequest.nextToken,
            outputKey: \ListBotsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - maxResults: The maximum number of bots to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - sortBy: Specifies sorting parameters for the list of bots. You can specify that the list be sorted by bot name in ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBotsPaginator(
        filters: [BotFilter]? = nil,
        maxResults: Int? = nil,
        sortBy: BotSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBotsRequest, ListBotsResponse> {
        let input = ListBotsRequest(
            filters: filters, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listBotsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBuiltInIntents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBuiltInIntentsPaginator(
        _ input: ListBuiltInIntentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBuiltInIntentsRequest, ListBuiltInIntentsResponse> {
        return .init(
            input: input,
            command: self.listBuiltInIntents,
            inputKey: \ListBuiltInIntentsRequest.nextToken,
            outputKey: \ListBuiltInIntentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBuiltInIntents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - localeId: The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of built-in intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Specifies sorting parameters for the list of built-in intents. You can specify that the list be sorted by the built-in intent signature in either ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBuiltInIntentsPaginator(
        localeId: String,
        maxResults: Int? = nil,
        sortBy: BuiltInIntentSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBuiltInIntentsRequest, ListBuiltInIntentsResponse> {
        let input = ListBuiltInIntentsRequest(
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listBuiltInIntentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBuiltInSlotTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBuiltInSlotTypesPaginator(
        _ input: ListBuiltInSlotTypesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBuiltInSlotTypesRequest, ListBuiltInSlotTypesResponse> {
        return .init(
            input: input,
            command: self.listBuiltInSlotTypes,
            inputKey: \ListBuiltInSlotTypesRequest.nextToken,
            outputKey: \ListBuiltInSlotTypesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBuiltInSlotTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - localeId: The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of built-in slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Determines the sort order for the response from the ListBuiltInSlotTypes operation. You can choose to sort by the slot type signature in either ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBuiltInSlotTypesPaginator(
        localeId: String,
        maxResults: Int? = nil,
        sortBy: BuiltInSlotTypeSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBuiltInSlotTypesRequest, ListBuiltInSlotTypesResponse> {
        let input = ListBuiltInSlotTypesRequest(
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listBuiltInSlotTypesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCustomVocabularyItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomVocabularyItemsPaginator(
        _ input: ListCustomVocabularyItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCustomVocabularyItemsRequest, ListCustomVocabularyItemsResponse> {
        return .init(
            input: input,
            command: self.listCustomVocabularyItems,
            inputKey: \ListCustomVocabularyItemsRequest.nextToken,
            outputKey: \ListCustomVocabularyItemsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCustomVocabularyItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the version of the bot associated with this custom  vocabulary.
    ///   - botVersion: The bot version of the bot to the list custom vocabulary  request.
    ///   - localeId: The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see Supported  languages (https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
    ///   - maxResults: The maximum number of items returned by the list operation.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomVocabularyItemsPaginator(
        botId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCustomVocabularyItemsRequest, ListCustomVocabularyItemsResponse> {
        let input = ListCustomVocabularyItemsRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults
        )
        return self.listCustomVocabularyItemsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listExports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listExportsPaginator(
        _ input: ListExportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListExportsRequest, ListExportsResponse> {
        return .init(
            input: input,
            command: self.listExports,
            inputKey: \ListExportsRequest.nextToken,
            outputKey: \ListExportsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listExports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier that Amazon Lex assigned to the bot.
    ///   - botVersion: The version of the bot to list exports for.
    ///   - filters: Provides the specification of a filter used to limit the exports in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - localeId: Specifies the resources that should be exported. If you don't specify a resource type in the filters parameter, both bot locales and custom vocabularies are exported.
    ///   - maxResults: The maximum number of exports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Determines the field that the list of exports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listExportsPaginator(
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [ExportFilter]? = nil,
        localeId: String? = nil,
        maxResults: Int? = nil,
        sortBy: ExportSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListExportsRequest, ListExportsResponse> {
        let input = ListExportsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listExportsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportsPaginator(
        _ input: ListImportsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImportsRequest, ListImportsResponse> {
        return .init(
            input: input,
            command: self.listImports,
            inputKey: \ListImportsRequest.nextToken,
            outputKey: \ListImportsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImports(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier that Amazon Lex assigned to the bot.
    ///   - botVersion: The version of the bot to list imports for.
    ///   - filters: Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
    ///   - localeId: Specifies the locale that should be present in the list. If you don't specify a resource type in the filters parameter, the list contains both bot locales and custom vocabularies.
    ///   - maxResults: The maximum number of imports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Determines the field that the list of imports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImportsPaginator(
        botId: String? = nil,
        botVersion: String? = nil,
        filters: [ImportFilter]? = nil,
        localeId: String? = nil,
        maxResults: Int? = nil,
        sortBy: ImportSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImportsRequest, ListImportsResponse> {
        let input = ListImportsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listImportsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIntentMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIntentMetricsPaginator(
        _ input: ListIntentMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIntentMetricsRequest, ListIntentMetricsResponse> {
        return .init(
            input: input,
            command: self.listIntentMetrics,
            inputKey: \ListIntentMetricsRequest.nextToken,
            outputKey: \ListIntentMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIntentMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve intent metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see intent metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    IntentName  The name of the intent.    IntentEndState  The final state of the intent. The possible end states are detailed in Key definitions in the user guide.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the order by which to organize the results.
    ///   - startDateTime: The timestamp that marks the beginning of the range of time for which you want to see intent metrics.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIntentMetricsPaginator(
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsIntentFilter]? = nil,
        groupBy: [AnalyticsIntentGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsIntentMetric],
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIntentMetricsRequest, ListIntentMetricsResponse> {
        let input = ListIntentMetricsRequest(
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            startDateTime: startDateTime
        )
        return self.listIntentMetricsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIntentStageMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIntentStageMetricsPaginator(
        _ input: ListIntentStageMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIntentStageMetricsRequest, ListIntentStageMetricsResponse> {
        return .init(
            input: input,
            command: self.listIntentStageMetrics,
            inputKey: \ListIntentStageMetricsRequest.nextToken,
            outputKey: \ListIntentStageMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIntentStageMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve intent stage metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see intent stage metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    IntentStageName  The name of the intent stage.    SwitchedToIntent  The intent to which the conversation was switched (if any).
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see intent stage metrics.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIntentStageMetricsPaginator(
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsIntentStageFilter]? = nil,
        groupBy: [AnalyticsIntentStageGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsIntentStageMetric],
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIntentStageMetricsRequest, ListIntentStageMetricsResponse> {
        let input = ListIntentStageMetricsRequest(
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            startDateTime: startDateTime
        )
        return self.listIntentStageMetricsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIntents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIntentsPaginator(
        _ input: ListIntentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIntentsRequest, ListIntentsResponse> {
        return .init(
            input: input,
            command: self.listIntents,
            inputKey: \ListIntentsRequest.nextToken,
            outputKey: \ListIntentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIntents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier of the bot that contains the intent.
    ///   - botVersion: The version of the bot that contains the intent.
    ///   - filters: Provides the specification of a filter used to limit the intents in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    ///   - localeId: The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Determines the sort order for the response from the ListIntents operation. You can choose to sort by the intent name or last updated date in either ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIntentsPaginator(
        botId: String,
        botVersion: String,
        filters: [IntentFilter]? = nil,
        localeId: String,
        maxResults: Int? = nil,
        sortBy: IntentSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIntentsRequest, ListIntentsResponse> {
        let input = ListIntentsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listIntentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRecommendedIntents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRecommendedIntentsPaginator(
        _ input: ListRecommendedIntentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRecommendedIntentsRequest, ListRecommendedIntentsResponse> {
        return .init(
            input: input,
            command: self.listRecommendedIntents,
            inputKey: \ListRecommendedIntentsRequest.nextToken,
            outputKey: \ListRecommendedIntentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRecommendedIntents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier of the bot associated with the recommended intents.
    ///   - botRecommendationId: The identifier of the bot recommendation that contains the recommended intents.
    ///   - botVersion: The version of the bot that contains the recommended intents.
    ///   - localeId: The identifier of the language and locale of the recommended intents.
    ///   - maxResults: The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRecommendedIntentsPaginator(
        botId: String,
        botRecommendationId: String,
        botVersion: String,
        localeId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRecommendedIntentsRequest, ListRecommendedIntentsResponse> {
        let input = ListRecommendedIntentsRequest(
            botId: botId, 
            botRecommendationId: botRecommendationId, 
            botVersion: botVersion, 
            localeId: localeId, 
            maxResults: maxResults
        )
        return self.listRecommendedIntentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSessionAnalyticsData(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionAnalyticsDataPaginator(
        _ input: ListSessionAnalyticsDataRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionAnalyticsDataRequest, ListSessionAnalyticsDataResponse> {
        return .init(
            input: input,
            command: self.listSessionAnalyticsData,
            inputKey: \ListSessionAnalyticsDataRequest.nextToken,
            outputKey: \ListSessionAnalyticsDataResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSessionAnalyticsData(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier for the bot for which you want to retrieve session analytics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see session analytics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - sortBy: An object specifying the measure and method by which to sort the session analytics data.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see session analytics.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionAnalyticsDataPaginator(
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsSessionFilter]? = nil,
        maxResults: Int? = nil,
        sortBy: SessionDataSortBy? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSessionAnalyticsDataRequest, ListSessionAnalyticsDataResponse> {
        let input = ListSessionAnalyticsDataRequest(
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            maxResults: maxResults, 
            sortBy: sortBy, 
            startDateTime: startDateTime
        )
        return self.listSessionAnalyticsDataPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSessionMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionMetricsPaginator(
        _ input: ListSessionMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionMetricsRequest, ListSessionMetricsResponse> {
        return .init(
            input: input,
            command: self.listSessionMetrics,
            inputKey: \ListSessionMetricsRequest.nextToken,
            outputKey: \ListSessionMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSessionMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve session metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see session metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    ConversationEndState  The final state of the conversation. The possible end states are detailed in Key definitions in the user guide.    LocaleId  The unique identifier of the bot locale.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see session metrics.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionMetricsPaginator(
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsSessionFilter]? = nil,
        groupBy: [AnalyticsSessionGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsSessionMetric],
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSessionMetricsRequest, ListSessionMetricsResponse> {
        let input = ListSessionMetricsRequest(
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            startDateTime: startDateTime
        )
        return self.listSessionMetricsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSlotTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSlotTypesPaginator(
        _ input: ListSlotTypesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSlotTypesRequest, ListSlotTypesResponse> {
        return .init(
            input: input,
            command: self.listSlotTypes,
            inputKey: \ListSlotTypesRequest.nextToken,
            outputKey: \ListSlotTypesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSlotTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier of the bot that contains the slot types.
    ///   - botVersion: The version of the bot that contains the slot type.
    ///   - filters: Provides the specification of a filter used to limit the slot types in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    ///   - localeId: The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Determines the sort order for the response from the ListSlotTypes operation. You can choose to sort by the slot type name or last updated date in either ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSlotTypesPaginator(
        botId: String,
        botVersion: String,
        filters: [SlotTypeFilter]? = nil,
        localeId: String,
        maxResults: Int? = nil,
        sortBy: SlotTypeSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSlotTypesRequest, ListSlotTypesResponse> {
        let input = ListSlotTypesRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listSlotTypesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSlots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSlotsPaginator(
        _ input: ListSlotsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSlotsRequest, ListSlotsResponse> {
        return .init(
            input: input,
            command: self.listSlots,
            inputKey: \ListSlotsRequest.nextToken,
            outputKey: \ListSlotsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSlots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot that contains the slot.
    ///   - botVersion: The version of the bot that contains the slot.
    ///   - filters: Provides the specification of a filter used to limit the slots in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
    ///   - intentId: The unique identifier of the intent that contains the slot.
    ///   - localeId: The identifier of the language and locale of the slots to list. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - maxResults: The maximum number of slots to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
    ///   - sortBy: Determines the sort order for the response from the ListSlots operation. You can choose to sort by the slot name or last updated date in either ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSlotsPaginator(
        botId: String,
        botVersion: String,
        filters: [SlotFilter]? = nil,
        intentId: String,
        localeId: String,
        maxResults: Int? = nil,
        sortBy: SlotSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSlotsRequest, ListSlotsResponse> {
        let input = ListSlotsRequest(
            botId: botId, 
            botVersion: botVersion, 
            filters: filters, 
            intentId: intentId, 
            localeId: localeId, 
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listSlotsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTestExecutionResultItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestExecutionResultItemsPaginator(
        _ input: ListTestExecutionResultItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestExecutionResultItemsRequest, ListTestExecutionResultItemsResponse> {
        return .init(
            input: input,
            command: self.listTestExecutionResultItems,
            inputKey: \ListTestExecutionResultItemsRequest.nextToken,
            outputKey: \ListTestExecutionResultItemsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTestExecutionResultItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of test execution result items to return in each  page. If there are fewer results than the max page size, only the actual  number of results are returned.
    ///   - resultFilterBy: The filter for the list of results from the test set execution.
    ///   - testExecutionId: The unique identifier of the test execution to list the result items.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestExecutionResultItemsPaginator(
        maxResults: Int? = nil,
        resultFilterBy: TestExecutionResultFilterBy,
        testExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTestExecutionResultItemsRequest, ListTestExecutionResultItemsResponse> {
        let input = ListTestExecutionResultItemsRequest(
            maxResults: maxResults, 
            resultFilterBy: resultFilterBy, 
            testExecutionId: testExecutionId
        )
        return self.listTestExecutionResultItemsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTestExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestExecutionsPaginator(
        _ input: ListTestExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestExecutionsRequest, ListTestExecutionsResponse> {
        return .init(
            input: input,
            command: self.listTestExecutions,
            inputKey: \ListTestExecutionsRequest.nextToken,
            outputKey: \ListTestExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTestExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of test executions to return in each page. If there are  fewer results than the max page size, only the actual number of results are  returned.
    ///   - sortBy: The sort order of the test set executions.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestExecutionsPaginator(
        maxResults: Int? = nil,
        sortBy: TestExecutionSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTestExecutionsRequest, ListTestExecutionsResponse> {
        let input = ListTestExecutionsRequest(
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listTestExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTestSetRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestSetRecordsPaginator(
        _ input: ListTestSetRecordsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestSetRecordsRequest, ListTestSetRecordsResponse> {
        return .init(
            input: input,
            command: self.listTestSetRecords,
            inputKey: \ListTestSetRecordsRequest.nextToken,
            outputKey: \ListTestSetRecordsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTestSetRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of test set records to return in each page. If there are  fewer records than the max page size, only the actual number of records are  returned.
    ///   - testSetId: The identifier of the test set to list its test set records.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestSetRecordsPaginator(
        maxResults: Int? = nil,
        testSetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTestSetRecordsRequest, ListTestSetRecordsResponse> {
        let input = ListTestSetRecordsRequest(
            maxResults: maxResults, 
            testSetId: testSetId
        )
        return self.listTestSetRecordsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTestSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestSetsPaginator(
        _ input: ListTestSetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTestSetsRequest, ListTestSetsResponse> {
        return .init(
            input: input,
            command: self.listTestSets,
            inputKey: \ListTestSetsRequest.nextToken,
            outputKey: \ListTestSetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTestSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of test sets to return in each page. If there are fewer  results than the max page size, only the actual number of results are returned.
    ///   - sortBy: The sort order for the list of test sets.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTestSetsPaginator(
        maxResults: Int? = nil,
        sortBy: TestSetSortBy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTestSetsRequest, ListTestSetsResponse> {
        let input = ListTestSetsRequest(
            maxResults: maxResults, 
            sortBy: sortBy
        )
        return self.listTestSetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listUtteranceAnalyticsData(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listUtteranceAnalyticsDataPaginator(
        _ input: ListUtteranceAnalyticsDataRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListUtteranceAnalyticsDataRequest, ListUtteranceAnalyticsDataResponse> {
        return .init(
            input: input,
            command: self.listUtteranceAnalyticsData,
            inputKey: \ListUtteranceAnalyticsDataRequest.nextToken,
            outputKey: \ListUtteranceAnalyticsDataResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listUtteranceAnalyticsData(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier for the bot for which you want to retrieve utterance analytics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see utterance analytics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - sortBy: An object specifying the measure and method by which to sort the utterance analytics data.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see utterance analytics.
    ///   - logger: Logger used for logging
    @inlinable
    public func listUtteranceAnalyticsDataPaginator(
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsUtteranceFilter]? = nil,
        maxResults: Int? = nil,
        sortBy: UtteranceDataSortBy? = nil,
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListUtteranceAnalyticsDataRequest, ListUtteranceAnalyticsDataResponse> {
        let input = ListUtteranceAnalyticsDataRequest(
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            maxResults: maxResults, 
            sortBy: sortBy, 
            startDateTime: startDateTime
        )
        return self.listUtteranceAnalyticsDataPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listUtteranceMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listUtteranceMetricsPaginator(
        _ input: ListUtteranceMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListUtteranceMetricsRequest, ListUtteranceMetricsResponse> {
        return .init(
            input: input,
            command: self.listUtteranceMetrics,
            inputKey: \ListUtteranceMetricsRequest.nextToken,
            outputKey: \ListUtteranceMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listUtteranceMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - attributes: A list containing attributes related to the utterance that you want the response to return. The following attributes are possible:    LastUsedIntent  The last used intent at the time of the utterance.
    ///   - binBy: A list of objects, each of which contains specifications for organizing the results by time.
    ///   - botId: The identifier for the bot for which you want to retrieve utterance metrics.
    ///   - endDateTime: The date and time that marks the end of the range of time for which you want to see utterance metrics.
    ///   - filters: A list of objects, each of which describes a condition by which you want to filter the results.
    ///   - groupBy: A list of objects, each of which specifies how to group the results. You can group by the following criteria:    UtteranceText  The transcription of the utterance.    UtteranceState  The state of the utterance. The possible states are detailed in Key definitions in the user guide.
    ///   - maxResults: The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
    ///   - metrics: A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
    ///   - startDateTime: The date and time that marks the beginning of the range of time for which you want to see utterance metrics.
    ///   - logger: Logger used for logging
    @inlinable
    public func listUtteranceMetricsPaginator(
        attributes: [AnalyticsUtteranceAttribute]? = nil,
        binBy: [AnalyticsBinBySpecification]? = nil,
        botId: String,
        endDateTime: Date,
        filters: [AnalyticsUtteranceFilter]? = nil,
        groupBy: [AnalyticsUtteranceGroupBySpecification]? = nil,
        maxResults: Int? = nil,
        metrics: [AnalyticsUtteranceMetric],
        startDateTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListUtteranceMetricsRequest, ListUtteranceMetricsResponse> {
        let input = ListUtteranceMetricsRequest(
            attributes: attributes, 
            binBy: binBy, 
            botId: botId, 
            endDateTime: endDateTime, 
            filters: filters, 
            groupBy: groupBy, 
            maxResults: maxResults, 
            metrics: metrics, 
            startDateTime: startDateTime
        )
        return self.listUtteranceMetricsPaginator(input, logger: logger)
    }
}

extension LexModelsV2.ListAggregatedUtterancesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListAggregatedUtterancesRequest {
        return .init(
            aggregationDuration: self.aggregationDuration,
            botAliasId: self.botAliasId,
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotAliasReplicasRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotAliasReplicasRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            replicaRegion: self.replicaRegion
        )
    }
}

extension LexModelsV2.ListBotAliasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotAliasesRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListBotLocalesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotLocalesRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotRecommendationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotRecommendationsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListBotResourceGenerationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotResourceGenerationsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotVersionReplicasRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotVersionReplicasRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            replicaRegion: self.replicaRegion,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotVersionsRequest {
        return .init(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBotsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBotsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBuiltInIntentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBuiltInIntentsRequest {
        return .init(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListBuiltInSlotTypesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListBuiltInSlotTypesRequest {
        return .init(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListCustomVocabularyItemsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListCustomVocabularyItemsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListExportsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListExportsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListImportsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListImportsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListIntentMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListIntentMetricsRequest {
        return .init(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListIntentStageMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListIntentStageMetricsRequest {
        return .init(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListIntentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListIntentsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListRecommendedIntentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListRecommendedIntentsRequest {
        return .init(
            botId: self.botId,
            botRecommendationId: self.botRecommendationId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LexModelsV2.ListSessionAnalyticsDataRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSessionAnalyticsDataRequest {
        return .init(
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListSessionMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSessionMetricsRequest {
        return .init(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListSlotTypesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSlotTypesRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListSlotsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListSlotsRequest {
        return .init(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            intentId: self.intentId,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListTestExecutionResultItemsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestExecutionResultItemsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resultFilterBy: self.resultFilterBy,
            testExecutionId: self.testExecutionId
        )
    }
}

extension LexModelsV2.ListTestExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestExecutionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListTestSetRecordsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestSetRecordsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            testSetId: self.testSetId
        )
    }
}

extension LexModelsV2.ListTestSetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListTestSetsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )
    }
}

extension LexModelsV2.ListUtteranceAnalyticsDataRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListUtteranceAnalyticsDataRequest {
        return .init(
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            startDateTime: self.startDateTime
        )
    }
}

extension LexModelsV2.ListUtteranceMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LexModelsV2.ListUtteranceMetricsRequest {
        return .init(
            attributes: self.attributes,
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension LexModelsV2 {
    /// Waiter for operation ``describeBotAlias(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotAliasAvailable(
        _ input: DescribeBotAliasRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeBotAliasRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botAliasStatus", expected: "Available")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botAliasStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botAliasStatus", expected: "Deleting")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotAlias
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeBotAlias(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botAliasId: The identifier of the bot alias to describe.
    ///   - botId: The identifier of the bot associated with the bot alias to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotAliasAvailable(
        botAliasId: String,
        botId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeBotAliasRequest(
            botAliasId: botAliasId, 
            botId: botId
        )
        try await self.waitUntilBotAliasAvailable(input, logger: logger)
    }

    /// Waiter for operation ``describeBot(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotAvailable(
        _ input: DescribeBotRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeBotRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botStatus", expected: "Available")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Inactive")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBot
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeBot(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The unique identifier of the bot to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotAvailable(
        botId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeBotRequest(
            botId: botId
        )
        try await self.waitUntilBotAvailable(input, logger: logger)
    }

    /// Waiter for operation ``describeExport(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotExportCompleted(
        _ input: DescribeExportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeExportRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("exportStatus", expected: "Completed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("exportStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("exportStatus", expected: "Failed")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeExport
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeExport(_:logger:)``.
    ///
    /// - Parameters:
    ///   - exportId: The unique identifier of the export to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotExportCompleted(
        exportId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeExportRequest(
            exportId: exportId
        )
        try await self.waitUntilBotExportCompleted(input, logger: logger)
    }

    /// Waiter for operation ``describeImport(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotImportCompleted(
        _ input: DescribeImportRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeImportRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("importStatus", expected: "Completed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("importStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("importStatus", expected: "Failed")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeImport
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeImport(_:logger:)``.
    ///
    /// - Parameters:
    ///   - importId: The unique identifier of the import to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotImportCompleted(
        importId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeImportRequest(
            importId: importId
        )
        try await self.waitUntilBotImportCompleted(input, logger: logger)
    }

    /// Waiter for operation ``describeBotLocale(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotLocaleBuilt(
        _ input: DescribeBotLocaleRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeBotLocaleRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Built")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "NotBuilt")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotLocale
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeBotLocale(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot associated with the locale.
    ///   - botVersion: The version of the bot associated with the locale.
    ///   - localeId: The unique identifier of the locale to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotLocaleBuilt(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        try await self.waitUntilBotLocaleBuilt(input, logger: logger)
    }

    /// Waiter for operation ``describeBotLocale(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotLocaleCreated(
        _ input: DescribeBotLocaleRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeBotLocaleRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Built")),
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "ReadyExpressTesting")),
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "NotBuilt")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Failed")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotLocale
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeBotLocale(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot associated with the locale.
    ///   - botVersion: The version of the bot associated with the locale.
    ///   - localeId: The unique identifier of the locale to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotLocaleCreated(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        try await self.waitUntilBotLocaleCreated(input, logger: logger)
    }

    /// Waiter for operation ``describeBotLocale(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotLocaleExpressTestingAvailable(
        _ input: DescribeBotLocaleRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeBotLocaleRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Built")),
                .init(state: .success, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "ReadyExpressTesting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "Failed")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botLocaleStatus", expected: "NotBuilt")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotLocale
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeBotLocale(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot associated with the locale.
    ///   - botVersion: The version of the bot associated with the locale.
    ///   - localeId: The unique identifier of the locale to describe. The string must match one of the supported locales. For more information, see Supported languages.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotLocaleExpressTestingAvailable(
        botId: String,
        botVersion: String,
        localeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeBotLocaleRequest(
            botId: botId, 
            botVersion: botVersion, 
            localeId: localeId
        )
        try await self.waitUntilBotLocaleExpressTestingAvailable(input, logger: logger)
    }

    /// Waiter for operation ``describeBotVersion(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotVersionAvailable(
        _ input: DescribeBotVersionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeBotVersionRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("botStatus", expected: "Available")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Deleting")),
                .init(state: .failure, matcher: try! JMESPathMatcher("botStatus", expected: "Failed")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
            ],
            minDelayTime: .seconds(10),
            command: self.describeBotVersion
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeBotVersion(_:logger:)``.
    ///
    /// - Parameters:
    ///   - botId: The identifier of the bot containing the version to return metadata for.
    ///   - botVersion: The version of the bot to return metadata for.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilBotVersionAvailable(
        botId: String,
        botVersion: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeBotVersionRequest(
            botId: botId, 
            botVersion: botVersion
        )
        try await self.waitUntilBotVersionAvailable(input, logger: logger)
    }
}
