//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension LexModelsV2 {
    // MARK: Enums

    public enum AggregatedUtterancesFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case utterance = "Utterance"
        public var description: String { return self.rawValue }
    }

    public enum AggregatedUtterancesFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum AggregatedUtterancesSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hitCount = "HitCount"
        case missedCount = "MissedCount"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsBinByName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conversationStartTime = "ConversationStartTime"
        case utteranceTimestamp = "UtteranceTimestamp"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsCommonFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botAliasId = "BotAliasId"
        case botVersion = "BotVersion"
        case channel = "Channel"
        case localeId = "LocaleId"
        case modality = "Modality"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQ"
        case greaterThan = "GT"
        case lessThan = "LT"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsIntentField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intentEndState = "IntentEndState"
        case intentLevel = "IntentLevel"
        case intentName = "IntentName"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsIntentFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botAliasId = "BotAliasId"
        case botVersion = "BotVersion"
        case channel = "Channel"
        case intentEndState = "IntentEndState"
        case intentName = "IntentName"
        case localeId = "LocaleId"
        case modality = "Modality"
        case originatingRequestId = "OriginatingRequestId"
        case sessionId = "SessionId"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsIntentMetricName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case count = "Count"
        case dropped = "Dropped"
        case failure = "Failure"
        case success = "Success"
        case switched = "Switched"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsIntentStageField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intentStageName = "IntentStageName"
        case switchedToIntent = "SwitchedToIntent"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsIntentStageFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botAliasId = "BotAliasId"
        case botVersion = "BotVersion"
        case channel = "Channel"
        case intentName = "IntentName"
        case intentStageName = "IntentStageName"
        case localeId = "LocaleId"
        case modality = "Modality"
        case originatingRequestId = "OriginatingRequestId"
        case sessionId = "SessionId"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsIntentStageMetricName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case count = "Count"
        case dropped = "Dropped"
        case failed = "Failed"
        case retry = "Retry"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsInterval: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneDay = "OneDay"
        case oneHour = "OneHour"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsMetricStatistic: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "Avg"
        case max = "Max"
        case sum = "Sum"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dtmf = "DTMF"
        case multiMode = "MultiMode"
        case speech = "Speech"
        case text = "Text"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsNodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exit = "Exit"
        case inner = "Inner"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsSessionField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conversationEndState = "ConversationEndState"
        case localeId = "LocaleId"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsSessionFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botAliasId = "BotAliasId"
        case botVersion = "BotVersion"
        case channel = "Channel"
        case conversationEndState = "ConversationEndState"
        case duration = "Duration"
        case intentPath = "IntentPath"
        case localeId = "LocaleId"
        case modality = "Modality"
        case originatingRequestId = "OriginatingRequestId"
        case sessionId = "SessionId"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsSessionMetricName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case concurrency = "Concurrency"
        case count = "Count"
        case dropped = "Dropped"
        case duration = "Duration"
        case failure = "Failure"
        case success = "Success"
        case turnsPerConversation = "TurnsPerConversation"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsSessionSortByName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conversationStartTime = "ConversationStartTime"
        case duration = "Duration"
        case numberOfTurns = "NumberOfTurns"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsSortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsUtteranceAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastUsedIntent = "LastUsedIntent"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsUtteranceField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case utteranceState = "UtteranceState"
        case utteranceText = "UtteranceText"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsUtteranceFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botAliasId = "BotAliasId"
        case botVersion = "BotVersion"
        case channel = "Channel"
        case localeId = "LocaleId"
        case modality = "Modality"
        case originatingRequestId = "OriginatingRequestId"
        case sessionId = "SessionId"
        case utteranceState = "UtteranceState"
        case utteranceText = "UtteranceText"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsUtteranceMetricName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case count = "Count"
        case detected = "Detected"
        case missed = "Missed"
        case utteranceTimestamp = "UtteranceTimestamp"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsUtteranceSortByName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case utteranceTimestamp = "UtteranceTimestamp"
        public var description: String { return self.rawValue }
    }

    public enum AssociatedTranscriptFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intentId = "IntentId"
        case slotTypeId = "SlotTypeId"
        public var description: String { return self.rawValue }
    }

    public enum AudioRecognitionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case useSlotValuesAsCustomVocabulary = "UseSlotValuesAsCustomVocabulary"
        public var description: String { return self.rawValue }
    }

    public enum BedrockTraceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum BotAliasReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum BotAliasStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public enum BotFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botName = "BotName"
        case botType = "BotType"
        public var description: String { return self.rawValue }
    }

    public enum BotFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        case notEquals = "NE"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botLocaleName = "BotLocaleName"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botLocaleName = "BotLocaleName"
        public var description: String { return self.rawValue }
    }

    public enum BotLocaleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case building = "Building"
        case built = "Built"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case importing = "Importing"
        case notBuilt = "NotBuilt"
        case processing = "Processing"
        case readyExpressTesting = "ReadyExpressTesting"
        public var description: String { return self.rawValue }
    }

    public enum BotRecommendationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case deleted = "Deleted"
        case deleting = "Deleting"
        case downloading = "Downloading"
        case failed = "Failed"
        case processing = "Processing"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum BotReplicaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "Deleting"
        case enabled = "Enabled"
        case enabling = "Enabling"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public enum BotSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botName = "BotName"
        public var description: String { return self.rawValue }
    }

    public enum BotStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case importing = "Importing"
        case inactive = "Inactive"
        case updating = "Updating"
        case versioning = "Versioning"
        public var description: String { return self.rawValue }
    }

    public enum BotType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bot = "Bot"
        case botNetwork = "BotNetwork"
        public var description: String { return self.rawValue }
    }

    public enum BotVersionReplicaSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botVersion = "BotVersion"
        public var description: String { return self.rawValue }
    }

    public enum BotVersionReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public enum BotVersionSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case botVersion = "BotVersion"
        public var description: String { return self.rawValue }
    }

    public enum BuiltInIntentSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intentSignature = "IntentSignature"
        public var description: String { return self.rawValue }
    }

    public enum BuiltInSlotTypeSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case slotTypeSignature = "SlotTypeSignature"
        public var description: String { return self.rawValue }
    }

    public enum ConversationEndState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dropped = "Dropped"
        case failure = "Failure"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum ConversationLogsInputModeFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case speech = "Speech"
        case text = "Text"
        public var description: String { return self.rawValue }
    }

    public enum CustomVocabularyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "Creating"
        case deleting = "Deleting"
        case exporting = "Exporting"
        case importing = "Importing"
        case ready = "Ready"
        public var description: String { return self.rawValue }
    }

    public enum DialogActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closeIntent = "CloseIntent"
        case confirmIntent = "ConfirmIntent"
        case elicitIntent = "ElicitIntent"
        case elicitSlot = "ElicitSlot"
        case endConversation = "EndConversation"
        case evaluateConditional = "EvaluateConditional"
        case fulfillIntent = "FulfillIntent"
        case invokeDialogCodeHook = "InvokeDialogCodeHook"
        case startIntent = "StartIntent"
        public var description: String { return self.rawValue }
    }

    public enum Effect: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "Allow"
        case deny = "Deny"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case duplicateInput = "DUPLICATE_INPUT"
        case internalServerFailure = "INTERNAL_SERVER_FAILURE"
        case resourceAlreadyExists = "RESOURCE_ALREADY_EXISTS"
        case resourceDoesNotExist = "RESOURCE_DOES_NOT_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum ExportFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exportResourceType = "ExportResourceType"
        public var description: String { return self.rawValue }
    }

    public enum ExportFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum ExportSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        public var description: String { return self.rawValue }
    }

    public enum ExportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum GenerationSortByAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationStartTime = "creationStartTime"
        case lastUpdatedTime = "lastUpdatedTime"
        public var description: String { return self.rawValue }
    }

    public enum GenerationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "Complete"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum ImportExportFileFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case lexJson = "LexJson"
        case tsv = "TSV"
        public var description: String { return self.rawValue }
    }

    public enum ImportFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case importResourceType = "ImportResourceType"
        public var description: String { return self.rawValue }
    }

    public enum ImportFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum ImportResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bot = "Bot"
        case botLocale = "BotLocale"
        case customVocabulary = "CustomVocabulary"
        case testSet = "TestSet"
        public var description: String { return self.rawValue }
    }

    public enum ImportSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        public var description: String { return self.rawValue }
    }

    public enum ImportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum IntentFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intentName = "IntentName"
        public var description: String { return self.rawValue }
    }

    public enum IntentFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum IntentSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intentName = "IntentName"
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        public var description: String { return self.rawValue }
    }

    public enum IntentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case fulfilled = "Fulfilled"
        case fulfillmentInProgress = "FulfillmentInProgress"
        case inProgress = "InProgress"
        case readyForFulfillment = "ReadyForFulfillment"
        case waiting = "Waiting"
        public var description: String { return self.rawValue }
    }

    public enum MergeStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case append = "Append"
        case failOnConflict = "FailOnConflict"
        case overwrite = "Overwrite"
        public var description: String { return self.rawValue }
    }

    public enum MessageSelectionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ordered = "Ordered"
        case random = "Random"
        public var description: String { return self.rawValue }
    }

    public enum ObfuscationSettingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case defaultObfuscation = "DefaultObfuscation"
        case none = "None"
        public var description: String { return self.rawValue }
    }

    public enum PromptAttempt: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case initial = "Initial"
        case retry1 = "Retry1"
        case retry2 = "Retry2"
        case retry3 = "Retry3"
        case retry4 = "Retry4"
        case retry5 = "Retry5"
        public var description: String { return self.rawValue }
    }

    public enum SearchOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum SlotConstraint: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optional = "Optional"
        case required = "Required"
        public var description: String { return self.rawValue }
    }

    public enum SlotFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case slotName = "SlotName"
        public var description: String { return self.rawValue }
    }

    public enum SlotFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum SlotResolutionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "Default"
        case enhancedFallback = "EnhancedFallback"
        public var description: String { return self.rawValue }
    }

    public enum SlotShape: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case list = "List"
        case scalar = "Scalar"
        public var description: String { return self.rawValue }
    }

    public enum SlotSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case slotName = "SlotName"
        public var description: String { return self.rawValue }
    }

    public enum SlotTypeCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case composite = "Composite"
        case custom = "Custom"
        case extended = "Extended"
        case externalGrammar = "ExternalGrammar"
        public var description: String { return self.rawValue }
    }

    public enum SlotTypeFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalSourceType = "ExternalSourceType"
        case slotTypeName = "SlotTypeName"
        public var description: String { return self.rawValue }
    }

    public enum SlotTypeFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CO"
        case equals = "EQ"
        public var description: String { return self.rawValue }
    }

    public enum SlotTypeSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case slotTypeName = "SlotTypeName"
        public var description: String { return self.rawValue }
    }

    public enum SlotValueResolutionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case concatenation = "Concatenation"
        case originalValue = "OriginalValue"
        case topResolution = "TopResolution"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum TestExecutionApiMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nonStreaming = "NonStreaming"
        case streaming = "Streaming"
        public var description: String { return self.rawValue }
    }

    public enum TestExecutionModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audio = "Audio"
        case text = "Text"
        public var description: String { return self.rawValue }
    }

    public enum TestExecutionSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationDateTime = "CreationDateTime"
        case testSetName = "TestSetName"
        public var description: String { return self.rawValue }
    }

    public enum TestExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case pending = "Pending"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case waiting = "Waiting"
        public var description: String { return self.rawValue }
    }

    public enum TestResultMatchStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executionError = "ExecutionError"
        case matched = "Matched"
        case mismatched = "Mismatched"
        public var description: String { return self.rawValue }
    }

    public enum TestResultTypeFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conversationLevelTestResults = "ConversationLevelTestResults"
        case intentClassificationTestResults = "IntentClassificationTestResults"
        case overallTestResults = "OverallTestResults"
        case slotResolutionTestResults = "SlotResolutionTestResults"
        case utteranceLevelResults = "UtteranceLevelResults"
        public var description: String { return self.rawValue }
    }

    public enum TestSetDiscrepancyReportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum TestSetGenerationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case generating = "Generating"
        case pending = "Pending"
        case ready = "Ready"
        public var description: String { return self.rawValue }
    }

    public enum TestSetModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audio = "Audio"
        case text = "Text"
        public var description: String { return self.rawValue }
    }

    public enum TestSetSortAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lastUpdatedDateTime = "LastUpdatedDateTime"
        case testSetName = "TestSetName"
        public var description: String { return self.rawValue }
    }

    public enum TestSetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "Deleting"
        case importing = "Importing"
        case pendingAnnotation = "PendingAnnotation"
        case ready = "Ready"
        case validationError = "ValidationError"
        public var description: String { return self.rawValue }
    }

    public enum TimeDimension: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "Days"
        case hours = "Hours"
        case weeks = "Weeks"
        public var description: String { return self.rawValue }
    }

    public enum TranscriptFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lex = "Lex"
        public var description: String { return self.rawValue }
    }

    public enum UtteranceContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customPayload = "CustomPayload"
        case imageResponseCard = "ImageResponseCard"
        case plainText = "PlainText"
        case ssml = "SSML"
        public var description: String { return self.rawValue }
    }

    public enum VoiceEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case generative = "generative"
        case longForm = "long-form"
        case neural = "neural"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ActiveContext: AWSDecodableShape {
        /// The name of active context.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct AdvancedRecognitionSetting: AWSEncodableShape & AWSDecodableShape {
        /// Enables using the slot values as a custom vocabulary for recognizing user utterances.
        public let audioRecognitionStrategy: AudioRecognitionStrategy?

        @inlinable
        public init(audioRecognitionStrategy: AudioRecognitionStrategy? = nil) {
            self.audioRecognitionStrategy = audioRecognitionStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case audioRecognitionStrategy = "audioRecognitionStrategy"
        }
    }

    public struct AgentTurnResult: AWSDecodableShape {
        /// The actual agent prompt for the agent turn in a test set execution.
        public let actualAgentPrompt: String?
        /// The actual elicited slot for the agent turn in a test set execution.
        public let actualElicitedSlot: String?
        /// The actual intent for the agent turn in a test set execution.
        public let actualIntent: String?
        public let errorDetails: ExecutionErrorDetails?
        /// The expected agent prompt for the agent turn in a test set execution.
        public let expectedAgentPrompt: String

        @inlinable
        public init(actualAgentPrompt: String? = nil, actualElicitedSlot: String? = nil, actualIntent: String? = nil, errorDetails: ExecutionErrorDetails? = nil, expectedAgentPrompt: String) {
            self.actualAgentPrompt = actualAgentPrompt
            self.actualElicitedSlot = actualElicitedSlot
            self.actualIntent = actualIntent
            self.errorDetails = errorDetails
            self.expectedAgentPrompt = expectedAgentPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case actualAgentPrompt = "actualAgentPrompt"
            case actualElicitedSlot = "actualElicitedSlot"
            case actualIntent = "actualIntent"
            case errorDetails = "errorDetails"
            case expectedAgentPrompt = "expectedAgentPrompt"
        }
    }

    public struct AgentTurnSpecification: AWSDecodableShape {
        /// The agent prompt for the agent turn in a test set.
        public let agentPrompt: String

        @inlinable
        public init(agentPrompt: String) {
            self.agentPrompt = agentPrompt
        }

        private enum CodingKeys: String, CodingKey {
            case agentPrompt = "agentPrompt"
        }
    }

    public struct AggregatedUtterancesFilter: AWSEncodableShape {
        /// The name of the field to filter the utterance list.
        public let name: AggregatedUtterancesFilterName
        /// The operator to use for the filter. Specify EQ when the ListAggregatedUtterances operation should return only utterances that equal the specified value. Specify CO when the ListAggregatedUtterances operation should return utterances that contain the specified value.
        public let `operator`: AggregatedUtterancesFilterOperator
        /// The value to use for filtering the list of bots.
        public let values: [String]

        @inlinable
        public init(name: AggregatedUtterancesFilterName, operator: AggregatedUtterancesFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct AggregatedUtterancesSortBy: AWSEncodableShape {
        /// The utterance attribute to sort by.
        public let attribute: AggregatedUtterancesSortAttribute
        /// Specifies whether to sort the aggregated utterances in ascending or descending order.
        public let order: SortOrder

        @inlinable
        public init(attribute: AggregatedUtterancesSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct AggregatedUtterancesSummary: AWSDecodableShape {
        /// Aggregated utterance data may contain utterances from versions of your bot that have since been deleted. When the aggregated contains this kind of data, this field is set to true.
        public let containsDataFromDeletedResources: Bool?
        /// The number of times that the utterance was detected by Amazon Lex during the time period. When an utterance is detected, it activates an intent or a slot.
        public let hitCount: Int?
        /// The number of times that the utterance was missed by Amazon Lex An utterance is missed when it doesn't activate an intent or slot.
        public let missedCount: Int?
        /// The text of the utterance. If the utterance was used with the RecognizeUtterance operation, the text is the transcription of the audio utterance.
        public let utterance: String?
        /// The date and time that the utterance was first recorded in the time window for aggregation. An utterance may have been sent to Amazon Lex before that time, but only utterances within the time window are counted.
        public let utteranceFirstRecordedInAggregationDuration: Date?
        /// The last date and time that an utterance was recorded in the time window for aggregation. An utterance may be sent to Amazon Lex after that time, but only utterances within the time window are counted.
        public let utteranceLastRecordedInAggregationDuration: Date?

        @inlinable
        public init(containsDataFromDeletedResources: Bool? = nil, hitCount: Int? = nil, missedCount: Int? = nil, utterance: String? = nil, utteranceFirstRecordedInAggregationDuration: Date? = nil, utteranceLastRecordedInAggregationDuration: Date? = nil) {
            self.containsDataFromDeletedResources = containsDataFromDeletedResources
            self.hitCount = hitCount
            self.missedCount = missedCount
            self.utterance = utterance
            self.utteranceFirstRecordedInAggregationDuration = utteranceFirstRecordedInAggregationDuration
            self.utteranceLastRecordedInAggregationDuration = utteranceLastRecordedInAggregationDuration
        }

        private enum CodingKeys: String, CodingKey {
            case containsDataFromDeletedResources = "containsDataFromDeletedResources"
            case hitCount = "hitCount"
            case missedCount = "missedCount"
            case utterance = "utterance"
            case utteranceFirstRecordedInAggregationDuration = "utteranceFirstRecordedInAggregationDuration"
            case utteranceLastRecordedInAggregationDuration = "utteranceLastRecordedInAggregationDuration"
        }
    }

    public struct AllowedInputTypes: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether audio input is allowed.
        public let allowAudioInput: Bool
        /// Indicates whether DTMF input is allowed.
        public let allowDTMFInput: Bool

        @inlinable
        public init(allowAudioInput: Bool, allowDTMFInput: Bool) {
            self.allowAudioInput = allowAudioInput
            self.allowDTMFInput = allowDTMFInput
        }

        private enum CodingKeys: String, CodingKey {
            case allowAudioInput = "allowAudioInput"
            case allowDTMFInput = "allowDTMFInput"
        }
    }

    public struct AnalyticsBinBySpecification: AWSEncodableShape {
        /// Specifies the interval of time by which to bin the analytics data.
        public let interval: AnalyticsInterval
        /// Specifies the time metric by which to bin the analytics data.
        public let name: AnalyticsBinByName
        /// Specifies whether to bin the analytics data in ascending or descending order. If this field is left blank, the default order is by the key of the bin in descending order.
        public let order: AnalyticsSortOrder?

        @inlinable
        public init(interval: AnalyticsInterval, name: AnalyticsBinByName, order: AnalyticsSortOrder? = nil) {
            self.interval = interval
            self.name = name
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "interval"
            case name = "name"
            case order = "order"
        }
    }

    public struct AnalyticsBinKey: AWSDecodableShape {
        /// The criterion by which to bin the results.
        public let name: AnalyticsBinByName?
        /// The value of the criterion that defines the bin.
        public let value: Int64?

        @inlinable
        public init(name: AnalyticsBinByName? = nil, value: Int64? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct AnalyticsIntentFilter: AWSEncodableShape {
        /// The category by which to filter the intents. The descriptions for each option are as follows:    BotAlias – The name of the bot alias.    BotVersion – The version of the bot.    LocaleId – The locale of the bot.    Modality – The modality of the session with the bot (audio, DTMF, or text).    Channel – The channel that the bot is integrated with.    SessionId – The identifier of the session with the bot.    OriginatingRequestId – The identifier of the first request in a session.    IntentName – The name of the intent.    IntentEndState – The final state of the intent.
        public let name: AnalyticsIntentFilterName
        /// The operation by which to filter the category. The following operations are possible:    CO – Contains    EQ – Equals    GT – Greater than    LT – Less than   The operators that each filter supports are listed below:    BotAlias – EQ.    BotVersion – EQ.    LocaleId – EQ.    Modality – EQ.    Channel – EQ.    SessionId – EQ.    OriginatingRequestId – EQ.    IntentName – EQ, CO.    IntentEndState – EQ, CO.
        public let `operator`: AnalyticsFilterOperator
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        public let values: [String]

        @inlinable
        public init(name: AnalyticsIntentFilterName, operator: AnalyticsFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct AnalyticsIntentGroupByKey: AWSDecodableShape {
        /// A category by which the intent analytics were grouped.
        public let name: AnalyticsIntentField?
        /// A member of the category by which the intent analytics were grouped.
        public let value: String?

        @inlinable
        public init(name: AnalyticsIntentField? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct AnalyticsIntentGroupBySpecification: AWSEncodableShape {
        /// Specifies whether to group the intent stages by their name or their end state.
        public let name: AnalyticsIntentField

        @inlinable
        public init(name: AnalyticsIntentField) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct AnalyticsIntentMetric: AWSEncodableShape {
        /// The metric for which you want to get intent summary statistics.    Count – The number of times the intent was invoked.    Success – The number of times the intent succeeded.    Failure – The number of times the intent failed.    Switched – The number of times there was a switch to a different intent.    Dropped – The number of times the user dropped the intent.
        public let name: AnalyticsIntentMetricName
        /// Specifies whether to sort the results in ascending or descending order.
        public let order: AnalyticsSortOrder?
        /// The summary statistic to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of intents in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic

        @inlinable
        public init(name: AnalyticsIntentMetricName, order: AnalyticsSortOrder? = nil, statistic: AnalyticsMetricStatistic) {
            self.name = name
            self.order = order
            self.statistic = statistic
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
            case statistic = "statistic"
        }
    }

    public struct AnalyticsIntentMetricResult: AWSDecodableShape {
        /// The metric that you requested. See Key definitions for more details about these metrics.    Count – The number of times the intent was invoked.    Success – The number of times the intent succeeded.    Failure – The number of times the intent failed.    Switched – The number of times there was a switch to a different intent.    Dropped – The number of times the user dropped the intent.
        public let name: AnalyticsIntentMetricName?
        /// The statistic that you requested to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of intents in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public let value: Double?

        @inlinable
        public init(name: AnalyticsIntentMetricName? = nil, statistic: AnalyticsMetricStatistic? = nil, value: Double? = nil) {
            self.name = name
            self.statistic = statistic
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case statistic = "statistic"
            case value = "value"
        }
    }

    public struct AnalyticsIntentNodeSummary: AWSDecodableShape {
        /// The total number of sessions that follow the given path to the given intent.
        public let intentCount: Int?
        /// The number of intents up to and including the requested path.
        public let intentLevel: Int?
        /// The name of the intent at the end of the requested path.
        public let intentName: String?
        /// The path.
        public let intentPath: String?
        /// Specifies whether the node is the end of a path (Exit) or not (Inner).
        public let nodeType: AnalyticsNodeType?

        @inlinable
        public init(intentCount: Int? = nil, intentLevel: Int? = nil, intentName: String? = nil, intentPath: String? = nil, nodeType: AnalyticsNodeType? = nil) {
            self.intentCount = intentCount
            self.intentLevel = intentLevel
            self.intentName = intentName
            self.intentPath = intentPath
            self.nodeType = nodeType
        }

        private enum CodingKeys: String, CodingKey {
            case intentCount = "intentCount"
            case intentLevel = "intentLevel"
            case intentName = "intentName"
            case intentPath = "intentPath"
            case nodeType = "nodeType"
        }
    }

    public struct AnalyticsIntentResult: AWSDecodableShape {
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public let binKeys: [AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the groups.
        public let groupByKeys: [AnalyticsIntentGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public let metricsResults: [AnalyticsIntentMetricResult]?

        @inlinable
        public init(binKeys: [AnalyticsBinKey]? = nil, groupByKeys: [AnalyticsIntentGroupByKey]? = nil, metricsResults: [AnalyticsIntentMetricResult]? = nil) {
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }

        private enum CodingKeys: String, CodingKey {
            case binKeys = "binKeys"
            case groupByKeys = "groupByKeys"
            case metricsResults = "metricsResults"
        }
    }

    public struct AnalyticsIntentStageFilter: AWSEncodableShape {
        /// The category by which to filter the intent stages. The descriptions for each option are as follows:    BotAlias – The name of the bot alias.    BotVersion – The version of the bot.    LocaleId – The locale of the bot.    Modality – The modality of the session with the bot (audio, DTMF, or text).    Channel – The channel that the bot is integrated with.    SessionId – The identifier of the session with the bot.    OriginatingRequestId – The identifier of the first request in a session.    IntentName – The name of the intent.    IntentStageName – The stage in the intent.
        public let name: AnalyticsIntentStageFilterName
        /// The operation by which to filter the category. The following operations are possible:    CO – Contains    EQ – Equals    GT – Greater than    LT – Less than   The operators that each filter supports are listed below:    BotAlias – EQ.    BotVersion – EQ.    LocaleId – EQ.    Modality – EQ.    Channel – EQ.    SessionId – EQ.    OriginatingRequestId – EQ.    IntentName – EQ, CO.    IntentStageName – EQ, CO.
        public let `operator`: AnalyticsFilterOperator
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        public let values: [String]

        @inlinable
        public init(name: AnalyticsIntentStageFilterName, operator: AnalyticsFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct AnalyticsIntentStageGroupByKey: AWSDecodableShape {
        /// A category by which the intent stage analytics were grouped.
        public let name: AnalyticsIntentStageField?
        /// A member of the category by which the intent stage analytics were grouped.
        public let value: String?

        @inlinable
        public init(name: AnalyticsIntentStageField? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct AnalyticsIntentStageGroupBySpecification: AWSEncodableShape {
        /// Specifies whether to group the intent stages by their name or the intent to which the session was switched.
        public let name: AnalyticsIntentStageField

        @inlinable
        public init(name: AnalyticsIntentStageField) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct AnalyticsIntentStageMetric: AWSEncodableShape {
        /// The metric for which you want to get intent stage summary statistics. See Key definitions for more details about these metrics.    Count – The number of times the intent stage occurred.    Success – The number of times the intent stage succeeded.    Failure – The number of times the intent stage failed.    Dropped – The number of times the user dropped the intent stage.    Retry – The number of times the bot tried to elicit a response from the user at this stage.
        public let name: AnalyticsIntentStageMetricName
        /// Specifies whether to sort the results in ascending or descending order of the summary statistic (value in the response).
        public let order: AnalyticsSortOrder?
        /// The summary statistic to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of intent stages in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic

        @inlinable
        public init(name: AnalyticsIntentStageMetricName, order: AnalyticsSortOrder? = nil, statistic: AnalyticsMetricStatistic) {
            self.name = name
            self.order = order
            self.statistic = statistic
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
            case statistic = "statistic"
        }
    }

    public struct AnalyticsIntentStageMetricResult: AWSDecodableShape {
        /// The metric that you requested.    Count – The number of times the intent stage occurred.    Success – The number of times the intent stage succeeded.    Failure – The number of times the intent stage failed.    Dropped – The number of times the user dropped the intent stage.    Retry – The number of times the bot tried to elicit a response from the user at this stage.
        public let name: AnalyticsIntentStageMetricName?
        /// The summary statistic that you requested to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of intent stages in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public let value: Double?

        @inlinable
        public init(name: AnalyticsIntentStageMetricName? = nil, statistic: AnalyticsMetricStatistic? = nil, value: Double? = nil) {
            self.name = name
            self.statistic = statistic
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case statistic = "statistic"
            case value = "value"
        }
    }

    public struct AnalyticsIntentStageResult: AWSDecodableShape {
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public let binKeys: [AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the bins.
        public let groupByKeys: [AnalyticsIntentStageGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public let metricsResults: [AnalyticsIntentStageMetricResult]?

        @inlinable
        public init(binKeys: [AnalyticsBinKey]? = nil, groupByKeys: [AnalyticsIntentStageGroupByKey]? = nil, metricsResults: [AnalyticsIntentStageMetricResult]? = nil) {
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }

        private enum CodingKeys: String, CodingKey {
            case binKeys = "binKeys"
            case groupByKeys = "groupByKeys"
            case metricsResults = "metricsResults"
        }
    }

    public struct AnalyticsPathFilter: AWSEncodableShape {
        /// The category by which to filter the intent paths. The descriptions for each option are as follows:    BotAlias – The name of the bot alias.    BotVersion – The version of the bot.    LocaleId – The locale of the bot.    Modality – The modality of the session with the bot (audio, DTMF, or text).    Channel – The channel that the bot is integrated with.
        public let name: AnalyticsCommonFilterName
        /// The operation by which to filter the category. The following operations are possible:    CO – Contains    EQ – Equals    GT – Greater than    LT – Less than   The operators that each filter supports are listed below:    BotAlias – EQ.    BotVersion – EQ.    LocaleId – EQ.    Modality – EQ.    Channel – EQ.
        public let `operator`: AnalyticsFilterOperator
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        public let values: [String]

        @inlinable
        public init(name: AnalyticsCommonFilterName, operator: AnalyticsFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct AnalyticsSessionFilter: AWSEncodableShape {
        /// The category by which to filter the sessions. The descriptions for each option are as follows:    BotAlias – The name of the bot alias.    BotVersion – The version of the bot.    LocaleId – The locale of the bot.    Modality – The modality of the session with the bot (audio, DTMF, or text).    Channel – The channel that the bot is integrated with.    Duration – The duration of the session.    conversationEndState – The final state of the session.    SessionId – The identifier of the session with the bot.    OriginatingRequestId – The identifier of the first request in a session.    IntentPath – The order of intents taken in a session.
        public let name: AnalyticsSessionFilterName
        /// The operation by which to filter the category. The following operations are possible:    CO – Contains    EQ – Equals    GT – Greater than    LT – Less than   The operators that each filter supports are listed below:    BotAlias – EQ.    BotVersion – EQ.    LocaleId – EQ.    Modality – EQ.    Channel – EQ.    Duration – EQ, GT, LT.    conversationEndState – EQ, CO.    SessionId – EQ.    OriginatingRequestId – EQ.    IntentPath – EQ.
        public let `operator`: AnalyticsFilterOperator
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        public let values: [String]

        @inlinable
        public init(name: AnalyticsSessionFilterName, operator: AnalyticsFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct AnalyticsSessionGroupByKey: AWSDecodableShape {
        /// The category by which the session analytics were grouped.
        public let name: AnalyticsSessionField?
        /// A member of the category by which the session analytics were grouped.
        public let value: String?

        @inlinable
        public init(name: AnalyticsSessionField? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct AnalyticsSessionGroupBySpecification: AWSEncodableShape {
        /// Specifies whether to group the session by their end state or their locale.
        public let name: AnalyticsSessionField

        @inlinable
        public init(name: AnalyticsSessionField) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct AnalyticsSessionMetric: AWSEncodableShape {
        /// The metric for which you want to get session summary statistics.    Count – The number of sessions.    Success – The number of sessions that succeeded.    Failure – The number of sessions that failed.    Dropped – The number of sessions that the user dropped.    Duration – The duration of sessions.    TurnsPerSession – The number of turns in the sessions.    Concurrency – The number of sessions occurring in the same period of time.
        public let name: AnalyticsSessionMetricName
        /// Specifies whether to sort the results in ascending or descending order.
        public let order: AnalyticsSortOrder?
        /// The summary statistic to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of sessions in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic

        @inlinable
        public init(name: AnalyticsSessionMetricName, order: AnalyticsSortOrder? = nil, statistic: AnalyticsMetricStatistic) {
            self.name = name
            self.order = order
            self.statistic = statistic
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
            case statistic = "statistic"
        }
    }

    public struct AnalyticsSessionMetricResult: AWSDecodableShape {
        /// The metric that you requested.    Count – The number of sessions.    Success – The number of sessions that succeeded.    Failure – The number of sessions that failed.    Dropped – The number of sessions that the user dropped.    Duration – The duration of sessions.    TurnPersession – The number of turns in the sessions.    Concurrency – The number of sessions occurring in the same period of time.
        public let name: AnalyticsSessionMetricName?
        /// The summary statistic that you requested to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of sessions in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public let value: Double?

        @inlinable
        public init(name: AnalyticsSessionMetricName? = nil, statistic: AnalyticsMetricStatistic? = nil, value: Double? = nil) {
            self.name = name
            self.statistic = statistic
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case statistic = "statistic"
            case value = "value"
        }
    }

    public struct AnalyticsSessionResult: AWSDecodableShape {
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public let binKeys: [AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the bins.
        public let groupByKeys: [AnalyticsSessionGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public let metricsResults: [AnalyticsSessionMetricResult]?

        @inlinable
        public init(binKeys: [AnalyticsBinKey]? = nil, groupByKeys: [AnalyticsSessionGroupByKey]? = nil, metricsResults: [AnalyticsSessionMetricResult]? = nil) {
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }

        private enum CodingKeys: String, CodingKey {
            case binKeys = "binKeys"
            case groupByKeys = "groupByKeys"
            case metricsResults = "metricsResults"
        }
    }

    public struct AnalyticsUtteranceAttribute: AWSEncodableShape {
        /// An attribute to return. The only available attribute is the intent that the bot mapped the utterance to.
        public let name: AnalyticsUtteranceAttributeName

        @inlinable
        public init(name: AnalyticsUtteranceAttributeName) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct AnalyticsUtteranceAttributeResult: AWSDecodableShape {
        /// The intent that the bot mapped the utterance to.
        public let lastUsedIntent: String?

        @inlinable
        public init(lastUsedIntent: String? = nil) {
            self.lastUsedIntent = lastUsedIntent
        }

        private enum CodingKeys: String, CodingKey {
            case lastUsedIntent = "lastUsedIntent"
        }
    }

    public struct AnalyticsUtteranceFilter: AWSEncodableShape {
        /// The category by which to filter the utterances. The descriptions for each option are as follows:    BotAlias – The name of the bot alias.    BotVersion – The version of the bot.    LocaleId – The locale of the bot.    Modality – The modality of the session with the bot (audio, DTMF, or text).    Channel – The channel that the bot is integrated with.    SessionId – The identifier of the session with the bot.    OriginatingRequestId – The identifier of the first request in a session.    UtteranceState – The state of the utterance.    UtteranceText – The text in the utterance.
        public let name: AnalyticsUtteranceFilterName
        /// The operation by which to filter the category. The following operations are possible:    CO – Contains    EQ – Equals    GT – Greater than    LT – Less than   The operators that each filter supports are listed below:    BotAlias – EQ.    BotVersion – EQ.    LocaleId – EQ.    Modality – EQ.    Channel – EQ.    SessionId – EQ.    OriginatingRequestId – EQ.    UtteranceState – EQ.    UtteranceText – EQ, CO.
        public let `operator`: AnalyticsFilterOperator
        /// An array containing the values of the category by which to apply the operator to filter the results. You can provide multiple values if the operator is EQ or CO. If you provide multiple values, you filter for results that equal/contain any of the values. For example, if the name, operator, and values fields are Modality, EQ, and [Speech, Text], the operation filters for results where the modality was either Speech or Text.
        public let values: [String]

        @inlinable
        public init(name: AnalyticsUtteranceFilterName, operator: AnalyticsFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct AnalyticsUtteranceGroupByKey: AWSDecodableShape {
        /// The category by which the utterance analytics were grouped.
        public let name: AnalyticsUtteranceField?
        /// A member of the category by which the utterance analytics were grouped.
        public let value: String?

        @inlinable
        public init(name: AnalyticsUtteranceField? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct AnalyticsUtteranceGroupBySpecification: AWSEncodableShape {
        /// Specifies whether to group the utterances by their text or their state.
        public let name: AnalyticsUtteranceField

        @inlinable
        public init(name: AnalyticsUtteranceField) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct AnalyticsUtteranceMetric: AWSEncodableShape {
        /// The metric for which you want to get utterance summary statistics.    Count – The number of utterances.    Missed – The number of utterances that Amazon Lex failed to recognize.    Detected – The number of utterances that Amazon Lex managed to detect.    UtteranceTimestamp – The date and time of the utterance.
        public let name: AnalyticsUtteranceMetricName
        /// Specifies whether to sort the results in ascending or descending order.
        public let order: AnalyticsSortOrder?
        /// The summary statistic to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of utterances in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic

        @inlinable
        public init(name: AnalyticsUtteranceMetricName, order: AnalyticsSortOrder? = nil, statistic: AnalyticsMetricStatistic) {
            self.name = name
            self.order = order
            self.statistic = statistic
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
            case statistic = "statistic"
        }
    }

    public struct AnalyticsUtteranceMetricResult: AWSDecodableShape {
        /// The metric that you requested.    Count – The number of utterances.    Missed – The number of utterances that Amazon Lex failed to recognize.    Detected – The number of utterances that Amazon Lex managed to detect.    UtteranceTimestamp – The date and time of the utterance.
        public let name: AnalyticsUtteranceMetricName?
        /// The summary statistic that you requested to calculate.    Sum – The total count for the category you provide in name.    Average – The total count divided by the number of utterances in the category you provide in name.    Max – The highest count in the category you provide in name.
        public let statistic: AnalyticsMetricStatistic?
        /// The value of the summary statistic for the metric that you requested.
        public let value: Double?

        @inlinable
        public init(name: AnalyticsUtteranceMetricName? = nil, statistic: AnalyticsMetricStatistic? = nil, value: Double? = nil) {
            self.name = name
            self.statistic = statistic
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case statistic = "statistic"
            case value = "value"
        }
    }

    public struct AnalyticsUtteranceResult: AWSDecodableShape {
        /// A list of objects containing information about the last used intent at the time of an utterance.
        public let attributeResults: [AnalyticsUtteranceAttributeResult]?
        /// A list of objects containing the criteria you requested for binning results and the values of the bins.
        public let binKeys: [AnalyticsBinKey]?
        /// A list of objects containing the criteria you requested for grouping results and the values of the bins.
        public let groupByKeys: [AnalyticsUtteranceGroupByKey]?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public let metricsResults: [AnalyticsUtteranceMetricResult]?

        @inlinable
        public init(attributeResults: [AnalyticsUtteranceAttributeResult]? = nil, binKeys: [AnalyticsBinKey]? = nil, groupByKeys: [AnalyticsUtteranceGroupByKey]? = nil, metricsResults: [AnalyticsUtteranceMetricResult]? = nil) {
            self.attributeResults = attributeResults
            self.binKeys = binKeys
            self.groupByKeys = groupByKeys
            self.metricsResults = metricsResults
        }

        private enum CodingKeys: String, CodingKey {
            case attributeResults = "attributeResults"
            case binKeys = "binKeys"
            case groupByKeys = "groupByKeys"
            case metricsResults = "metricsResults"
        }
    }

    public struct AssociatedTranscript: AWSDecodableShape {
        /// The content of the transcript that meets the search filter criteria. For the JSON format of the transcript, see Output transcript format.
        public let transcript: String?

        @inlinable
        public init(transcript: String? = nil) {
            self.transcript = transcript
        }

        private enum CodingKeys: String, CodingKey {
            case transcript = "transcript"
        }
    }

    public struct AssociatedTranscriptFilter: AWSEncodableShape {
        /// The name of the field to use for filtering. The allowed names are IntentId and SlotTypeId.
        public let name: AssociatedTranscriptFilterName
        /// The values to use to filter the transcript.
        public let values: [String]

        @inlinable
        public init(name: AssociatedTranscriptFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct AudioAndDTMFInputSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the settings on audio input.
        public let audioSpecification: AudioSpecification?
        /// Specifies the settings on DTMF input.
        public let dtmfSpecification: DTMFSpecification?
        /// Time for which a bot waits before assuming that the customer isn't going to speak or press  a key. This timeout is shared between Audio and DTMF inputs.
        public let startTimeoutMs: Int

        @inlinable
        public init(audioSpecification: AudioSpecification? = nil, dtmfSpecification: DTMFSpecification? = nil, startTimeoutMs: Int) {
            self.audioSpecification = audioSpecification
            self.dtmfSpecification = dtmfSpecification
            self.startTimeoutMs = startTimeoutMs
        }

        public func validate(name: String) throws {
            try self.audioSpecification?.validate(name: "\(name).audioSpecification")
            try self.dtmfSpecification?.validate(name: "\(name).dtmfSpecification")
            try self.validate(self.startTimeoutMs, name: "startTimeoutMs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audioSpecification = "audioSpecification"
            case dtmfSpecification = "dtmfSpecification"
            case startTimeoutMs = "startTimeoutMs"
        }
    }

    public struct AudioLogDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket where the audio log files are stored. The IAM role specified in the roleArn parameter of the CreateBot operation must have permission to write to this bucket.
        public let s3Bucket: S3BucketLogDestination

        @inlinable
        public init(s3Bucket: S3BucketLogDestination) {
            self.s3Bucket = s3Bucket
        }

        public func validate(name: String) throws {
            try self.s3Bucket.validate(name: "\(name).s3Bucket")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
        }
    }

    public struct AudioLogSetting: AWSEncodableShape & AWSDecodableShape {
        public let destination: AudioLogDestination
        /// Determines whether audio logging in enabled for the bot.
        public let enabled: Bool
        /// The option to enable selective conversation log capture for audio.
        public let selectiveLoggingEnabled: Bool?

        @inlinable
        public init(destination: AudioLogDestination, enabled: Bool, selectiveLoggingEnabled: Bool? = nil) {
            self.destination = destination
            self.enabled = enabled
            self.selectiveLoggingEnabled = selectiveLoggingEnabled
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case enabled = "enabled"
            case selectiveLoggingEnabled = "selectiveLoggingEnabled"
        }
    }

    public struct AudioSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Time for which a bot waits after the customer stops speaking to assume the  utterance is finished.
        public let endTimeoutMs: Int
        /// Time for how long Amazon Lex waits before speech input is truncated and the speech  is returned to application.
        public let maxLengthMs: Int

        @inlinable
        public init(endTimeoutMs: Int, maxLengthMs: Int) {
            self.endTimeoutMs = endTimeoutMs
            self.maxLengthMs = maxLengthMs
        }

        public func validate(name: String) throws {
            try self.validate(self.endTimeoutMs, name: "endTimeoutMs", parent: name, min: 1)
            try self.validate(self.maxLengthMs, name: "maxLengthMs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeoutMs = "endTimeoutMs"
            case maxLengthMs = "maxLengthMs"
        }
    }

    public struct BatchCreateCustomVocabularyItemRequest: AWSEncodableShape {
        /// The identifier of the bot associated with this custom vocabulary.
        public let botId: String
        /// The identifier of the version of the bot associated with this  custom vocabulary.
        public let botVersion: String
        /// A list of new custom vocabulary items. Each entry must contain a phrase and can optionally contain a displayAs and/or a weight.
        public let customVocabularyItemList: [NewCustomVocabularyItem]
        /// The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see  Supported Languages .
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, customVocabularyItemList: [NewCustomVocabularyItem], localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.customVocabularyItemList = customVocabularyItemList
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encode(self.customVocabularyItemList, forKey: .customVocabularyItemList)
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.customVocabularyItemList.forEach {
                try $0.validate(name: "\(name).customVocabularyItemList[]")
            }
            try self.validate(self.customVocabularyItemList, name: "customVocabularyItemList", parent: name, max: 10)
            try self.validate(self.customVocabularyItemList, name: "customVocabularyItemList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customVocabularyItemList = "customVocabularyItemList"
        }
    }

    public struct BatchCreateCustomVocabularyItemResponse: AWSDecodableShape {
        /// The identifier of the bot associated with this custom vocabulary.
        public let botId: String?
        /// The identifier of the version of the bot associated with this  custom vocabulary.
        public let botVersion: String?
        /// A list of custom vocabulary items that failed to create during the operation. The reason for the error is contained within each error object.
        public let errors: [FailedCustomVocabularyItem]?
        /// The identifier of the language and locale where this custom vocabulary is used.  The string must match one of the supported locales.  For more information, see  Supported Languages .
        public let localeId: String?
        /// A list of custom vocabulary items that were  successfully created during the operation.
        public let resources: [CustomVocabularyItem]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, errors: [FailedCustomVocabularyItem]? = nil, localeId: String? = nil, resources: [CustomVocabularyItem]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.errors = errors
            self.localeId = localeId
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case errors = "errors"
            case localeId = "localeId"
            case resources = "resources"
        }
    }

    public struct BatchDeleteCustomVocabularyItemRequest: AWSEncodableShape {
        /// The identifier of the bot associated with this custom vocabulary.
        public let botId: String
        /// The identifier of the version of the bot associated with this custom  vocabulary.
        public let botVersion: String
        /// A list of custom vocabulary items requested to be deleted. Each entry must contain the unique custom vocabulary entry identifier.
        public let customVocabularyItemList: [CustomVocabularyEntryId]
        /// The identifier of the language and locale where this custom vocabulary is  used. The string must match one of the supported locales.  For more information, see  Supported Languages .
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, customVocabularyItemList: [CustomVocabularyEntryId], localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.customVocabularyItemList = customVocabularyItemList
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encode(self.customVocabularyItemList, forKey: .customVocabularyItemList)
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.customVocabularyItemList.forEach {
                try $0.validate(name: "\(name).customVocabularyItemList[]")
            }
            try self.validate(self.customVocabularyItemList, name: "customVocabularyItemList", parent: name, max: 10)
            try self.validate(self.customVocabularyItemList, name: "customVocabularyItemList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customVocabularyItemList = "customVocabularyItemList"
        }
    }

    public struct BatchDeleteCustomVocabularyItemResponse: AWSDecodableShape {
        /// The identifier of the bot associated with this custom vocabulary.
        public let botId: String?
        /// The identifier of the version of the bot associated with this custom  vocabulary.
        public let botVersion: String?
        /// A list of custom vocabulary items that failed to delete during the operation. The reason for the error is contained within each error object.
        public let errors: [FailedCustomVocabularyItem]?
        /// The identifier of the language and locale where this custom vocabulary is  used. The string must match one of the supported locales.  For more information, see Supported  languages (https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
        public let localeId: String?
        /// A list of custom vocabulary items that were  successfully deleted during the operation.
        public let resources: [CustomVocabularyItem]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, errors: [FailedCustomVocabularyItem]? = nil, localeId: String? = nil, resources: [CustomVocabularyItem]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.errors = errors
            self.localeId = localeId
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case errors = "errors"
            case localeId = "localeId"
            case resources = "resources"
        }
    }

    public struct BatchUpdateCustomVocabularyItemRequest: AWSEncodableShape {
        /// The identifier of the bot associated with this custom vocabulary
        public let botId: String
        /// The identifier of the version of the bot associated with this custom  vocabulary.
        public let botVersion: String
        /// A list of custom vocabulary items with updated fields. Each entry must contain a phrase and can optionally contain a displayAs and/or a weight.
        public let customVocabularyItemList: [CustomVocabularyItem]
        /// The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see  Supported Languages .
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, customVocabularyItemList: [CustomVocabularyItem], localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.customVocabularyItemList = customVocabularyItemList
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encode(self.customVocabularyItemList, forKey: .customVocabularyItemList)
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.customVocabularyItemList.forEach {
                try $0.validate(name: "\(name).customVocabularyItemList[]")
            }
            try self.validate(self.customVocabularyItemList, name: "customVocabularyItemList", parent: name, max: 10)
            try self.validate(self.customVocabularyItemList, name: "customVocabularyItemList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customVocabularyItemList = "customVocabularyItemList"
        }
    }

    public struct BatchUpdateCustomVocabularyItemResponse: AWSDecodableShape {
        /// The identifier of the bot associated with this custom vocabulary.
        public let botId: String?
        /// The identifier of the version of the bot associated with this custom  vocabulary.
        public let botVersion: String?
        /// A list of custom vocabulary items that failed to update during the operation. The reason for the error is contained within each error object.
        public let errors: [FailedCustomVocabularyItem]?
        /// The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see  Supported Languages .
        public let localeId: String?
        /// A list of custom vocabulary items that were  successfully updated during the operation.
        public let resources: [CustomVocabularyItem]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, errors: [FailedCustomVocabularyItem]? = nil, localeId: String? = nil, resources: [CustomVocabularyItem]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.errors = errors
            self.localeId = localeId
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case errors = "errors"
            case localeId = "localeId"
            case resources = "resources"
        }
    }

    public struct BedrockGuardrailConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The unique guardrail id for the Bedrock guardrail configuration.
        public let identifier: String
        /// The guardrail version for the Bedrock guardrail configuration.
        public let version: String

        @inlinable
        public init(identifier: String, version: String) {
            self.identifier = identifier
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 2048)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.version, name: "version", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case version = "version"
        }
    }

    public struct BedrockKnowledgeStoreConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The base ARN of the knowledge base used.
        public let bedrockKnowledgeBaseArn: String
        /// Specifies whether to return an exact response, or to return an answer generated by the model, using the fields you specify from the database.
        public let exactResponse: Bool?
        /// Contains the names of the fields used for an exact response to the user.
        public let exactResponseFields: BedrockKnowledgeStoreExactResponseFields?

        @inlinable
        public init(bedrockKnowledgeBaseArn: String, exactResponse: Bool? = nil, exactResponseFields: BedrockKnowledgeStoreExactResponseFields? = nil) {
            self.bedrockKnowledgeBaseArn = bedrockKnowledgeBaseArn
            self.exactResponse = exactResponse
            self.exactResponseFields = exactResponseFields
        }

        public func validate(name: String) throws {
            try self.validate(self.bedrockKnowledgeBaseArn, name: "bedrockKnowledgeBaseArn", parent: name, max: 200)
            try self.validate(self.bedrockKnowledgeBaseArn, name: "bedrockKnowledgeBaseArn", parent: name, min: 1)
            try self.validate(self.bedrockKnowledgeBaseArn, name: "bedrockKnowledgeBaseArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,40}:[0-9]{12}:knowledge-base\\/[A-Za-z0-9]{10}$|^[A-Za-z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockKnowledgeBaseArn = "bedrockKnowledgeBaseArn"
            case exactResponse = "exactResponse"
            case exactResponseFields = "exactResponseFields"
        }
    }

    public struct BedrockKnowledgeStoreExactResponseFields: AWSEncodableShape & AWSDecodableShape {
        /// The answer field used for an exact response from Bedrock Knowledge Store.
        public let answerField: String?

        @inlinable
        public init(answerField: String? = nil) {
            self.answerField = answerField
        }

        private enum CodingKeys: String, CodingKey {
            case answerField = "answerField"
        }
    }

    public struct BedrockModelSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The custom prompt used in the Bedrock model specification details.
        public let customPrompt: String?
        /// The guardrail configuration in the Bedrock model specification details.
        public let guardrail: BedrockGuardrailConfiguration?
        /// The ARN of the foundation model used in descriptive bot building.
        public let modelArn: String
        /// The Bedrock trace status in the Bedrock model specification details.
        public let traceStatus: BedrockTraceStatus?

        @inlinable
        public init(customPrompt: String? = nil, guardrail: BedrockGuardrailConfiguration? = nil, modelArn: String, traceStatus: BedrockTraceStatus? = nil) {
            self.customPrompt = customPrompt
            self.guardrail = guardrail
            self.modelArn = modelArn
            self.traceStatus = traceStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.customPrompt, name: "customPrompt", parent: name, max: 4000)
            try self.validate(self.customPrompt, name: "customPrompt", parent: name, min: 1)
            try self.guardrail?.validate(name: "\(name).guardrail")
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model\\/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case customPrompt = "customPrompt"
            case guardrail = "guardrail"
            case modelArn = "modelArn"
            case traceStatus = "traceStatus"
        }
    }

    public struct BotAliasHistoryEvent: AWSDecodableShape {
        /// The version of the bot that was used in the event.
        public let botVersion: String?
        /// The date and time that the event ended.
        public let endDate: Date?
        /// The date and time that the event started.
        public let startDate: Date?

        @inlinable
        public init(botVersion: String? = nil, endDate: Date? = nil, startDate: Date? = nil) {
            self.botVersion = botVersion
            self.endDate = endDate
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case botVersion = "botVersion"
            case endDate = "endDate"
            case startDate = "startDate"
        }
    }

    public struct BotAliasLocaleSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the Lambda function that should be used in the locale.
        public let codeHookSpecification: CodeHookSpecification?
        /// Determines whether the locale is enabled for the bot. If the value is false, the locale isn't available for use.
        public let enabled: Bool

        @inlinable
        public init(codeHookSpecification: CodeHookSpecification? = nil, enabled: Bool) {
            self.codeHookSpecification = codeHookSpecification
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.codeHookSpecification?.validate(name: "\(name).codeHookSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case codeHookSpecification = "codeHookSpecification"
            case enabled = "enabled"
        }
    }

    public struct BotAliasReplicaSummary: AWSDecodableShape {
        /// The bot alias ID for all the alias bot replications.
        public let botAliasId: String?
        /// The replication statuses for all the alias bot replications.
        public let botAliasReplicationStatus: BotAliasReplicationStatus?
        /// The bot version for all the alias bot replications.
        public let botVersion: String?
        /// The creation time and date for all the alias bot replications.
        public let creationDateTime: Date?
        /// The reasons for failure for the aliases bot replications.
        public let failureReasons: [String]?
        /// The last time and date updated for all the alias bot replications.
        public let lastUpdatedDateTime: Date?

        @inlinable
        public init(botAliasId: String? = nil, botAliasReplicationStatus: BotAliasReplicationStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, failureReasons: [String]? = nil, lastUpdatedDateTime: Date? = nil) {
            self.botAliasId = botAliasId
            self.botAliasReplicationStatus = botAliasReplicationStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
            self.lastUpdatedDateTime = lastUpdatedDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasReplicationStatus = "botAliasReplicationStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
        }
    }

    public struct BotAliasSummary: AWSDecodableShape {
        /// The unique identifier assigned to the bot alias. You can use this ID to get detailed information about the alias using the DescribeBotAlias operation.
        public let botAliasId: String?
        /// The name of the bot alias.
        public let botAliasName: String?
        /// The current state of the bot alias. If the status is Available, the alias is ready for use.
        public let botAliasStatus: BotAliasStatus?
        /// The version of the bot that the bot alias references.
        public let botVersion: String?
        /// A timestamp of the date and time that the bot alias was created.
        public let creationDateTime: Date?
        /// The description of the bot alias.
        public let description: String?
        /// A timestamp of the date and time that the bot alias was last updated.
        public let lastUpdatedDateTime: Date?

        @inlinable
        public init(botAliasId: String? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil) {
            self.botAliasId = botAliasId
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
        }
    }

    public struct BotAliasTestExecutionTarget: AWSEncodableShape & AWSDecodableShape {
        /// The bot alias Id of the bot alias used in the test set execution.
        public let botAliasId: String
        /// The bot Id of the bot alias used in the test set execution.
        public let botId: String
        /// The locale Id of the bot alias used in the test set execution.
        public let localeId: String

        @inlinable
        public init(botAliasId: String, botId: String, localeId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botId = "botId"
            case localeId = "localeId"
        }
    }

    public struct BotExportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the bot assigned by Amazon Lex.
        public let botId: String
        /// The version of the bot that was exported. This will be either DRAFT or the version number.
        public let botVersion: String

        @inlinable
        public init(botId: String, botVersion: String) {
            self.botId = botId
            self.botVersion = botVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
        }
    }

    public struct BotFilter: AWSEncodableShape {
        /// The name of the field to filter the list of bots.
        public let name: BotFilterName
        /// The operator to use for the filter. Specify EQ when the ListBots operation should return only aliases that equal the specified value. Specify CO when the ListBots operation should return aliases that contain the specified value.
        public let `operator`: BotFilterOperator
        /// The value to use for filtering the list of bots.
        public let values: [String]

        @inlinable
        public init(name: BotFilterName, operator: BotFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct BotImportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The name that Amazon Lex should use for the bot.
        public let botName: String
        /// A list of tags to add to the bot. You can only add tags when you import a bot. You can't use the UpdateBot operation to update tags. To update tags, use the TagResource operation.
        public let botTags: [String: String]?
        public let dataPrivacy: DataPrivacy
        /// Allows you to configure destinations where error logs will be published during the bot import process.
        public let errorLogSettings: ErrorLogSettings?
        /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot.  A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
        public let idleSessionTTLInSeconds: Int?
        /// The Amazon Resource Name (ARN) of the IAM role used to build and run the bot.
        public let roleArn: String
        /// A list of tags to add to the test alias for a bot. You can only add tags when you import a bot. You can't use the UpdateAlias operation to update tags. To update tags on the test alias, use the TagResource operation.
        public let testBotAliasTags: [String: String]?

        @inlinable
        public init(botName: String, botTags: [String: String]? = nil, dataPrivacy: DataPrivacy, errorLogSettings: ErrorLogSettings? = nil, idleSessionTTLInSeconds: Int? = nil, roleArn: String, testBotAliasTags: [String: String]? = nil) {
            self.botName = botName
            self.botTags = botTags
            self.dataPrivacy = dataPrivacy
            self.errorLogSettings = errorLogSettings
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
            self.testBotAliasTags = testBotAliasTags
        }

        public func validate(name: String) throws {
            try self.validate(self.botName, name: "botName", parent: name, max: 100)
            try self.validate(self.botName, name: "botName", parent: name, min: 1)
            try self.validate(self.botName, name: "botName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.botTags?.forEach {
                try validate($0.key, name: "botTags.key", parent: name, max: 128)
                try validate($0.key, name: "botTags.key", parent: name, min: 1)
                try validate($0.value, name: "botTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.botTags, name: "botTags", parent: name, max: 200)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 86400)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/.*$")
            try self.testBotAliasTags?.forEach {
                try validate($0.key, name: "testBotAliasTags.key", parent: name, max: 128)
                try validate($0.key, name: "testBotAliasTags.key", parent: name, min: 1)
                try validate($0.value, name: "testBotAliasTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.testBotAliasTags, name: "testBotAliasTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case botName = "botName"
            case botTags = "botTags"
            case dataPrivacy = "dataPrivacy"
            case errorLogSettings = "errorLogSettings"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
            case testBotAliasTags = "testBotAliasTags"
        }
    }

    public struct BotLocaleExportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the bot to create the locale for.
        public let botId: String
        /// The version of the bot to export.
        public let botVersion: String
        /// The identifier of the language and locale to export. The string must match one of the locales in the bot.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case localeId = "localeId"
        }
    }

    public struct BotLocaleFilter: AWSEncodableShape {
        /// The name of the field to filter the list of bots.
        public let name: BotLocaleFilterName
        /// The operator to use for the filter. Specify EQ when the ListBotLocales operation should return only aliases that equal the specified value. Specify CO when the ListBotLocales operation should return aliases that contain the specified value.
        public let `operator`: BotLocaleFilterOperator
        /// The value to use for filtering the list of bots.
        public let values: [String]

        @inlinable
        public init(name: BotLocaleFilterName, operator: BotLocaleFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct BotLocaleHistoryEvent: AWSDecodableShape {
        /// A description of the event that occurred.
        public let event: String
        /// A timestamp of the date and time that the event occurred.
        public let eventDate: Date

        @inlinable
        public init(event: String, eventDate: Date) {
            self.event = event
            self.eventDate = eventDate
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case eventDate = "eventDate"
        }
    }

    public struct BotLocaleImportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the bot to import the locale to.
        public let botId: String
        /// The version of the bot to import the locale to. This can only be the DRAFT version of the bot.
        public let botVersion: String
        /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see Supported languages.
        public let localeId: String
        /// Determines the threshold where Amazon Lex will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot.  For example, suppose a bot is configured with the confidence threshold of 0.80 and the AMAZON.FallbackIntent. Amazon Lex returns three alternative intents with the following confidence scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the PostText operation would be:    AMAZON.FallbackIntent     IntentA     IntentB     IntentC
        public let nluIntentConfidenceThreshold: Double?
        public let voiceSettings: VoiceSettings?

        @inlinable
        public init(botId: String, botVersion: String, localeId: String, nluIntentConfidenceThreshold: Double? = nil, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, max: 1.0)
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case localeId = "localeId"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct BotLocaleSortBy: AWSEncodableShape {
        /// The bot locale attribute to sort by.
        public let attribute: BotLocaleSortAttribute
        /// Specifies whether to sort the bot locales in ascending or descending order.
        public let order: SortOrder

        @inlinable
        public init(attribute: BotLocaleSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BotLocaleSummary: AWSDecodableShape {
        /// The current status of the bot locale. When the status is Built the locale is ready for use.
        public let botLocaleStatus: BotLocaleStatus?
        /// The description of the bot locale.
        public let description: String?
        /// A timestamp of the date and time that the bot locale was last built.
        public let lastBuildSubmittedDateTime: Date?
        /// A timestamp of the date and time that the bot locale was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale of the bot locale.
        public let localeId: String?
        /// The name of the bot locale.
        public let localeName: String?

        @inlinable
        public init(botLocaleStatus: BotLocaleStatus? = nil, description: String? = nil, lastBuildSubmittedDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, localeName: String? = nil) {
            self.botLocaleStatus = botLocaleStatus
            self.description = description
            self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.localeName = localeName
        }

        private enum CodingKeys: String, CodingKey {
            case botLocaleStatus = "botLocaleStatus"
            case description = "description"
            case lastBuildSubmittedDateTime = "lastBuildSubmittedDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case localeName = "localeName"
        }
    }

    public struct BotMember: AWSEncodableShape & AWSDecodableShape {
        /// The alias ID of a bot that is a member of this network of bots.
        public let botMemberAliasId: String
        /// The alias name of a bot that is a member of this network of bots.
        public let botMemberAliasName: String
        /// The unique ID of a bot that is a member of this network of bots.
        public let botMemberId: String
        /// The unique name of a bot that is a member of this network of bots.
        public let botMemberName: String
        /// The version of a bot that is a member of this network of bots.
        public let botMemberVersion: String

        @inlinable
        public init(botMemberAliasId: String, botMemberAliasName: String, botMemberId: String, botMemberName: String, botMemberVersion: String) {
            self.botMemberAliasId = botMemberAliasId
            self.botMemberAliasName = botMemberAliasName
            self.botMemberId = botMemberId
            self.botMemberName = botMemberName
            self.botMemberVersion = botMemberVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.botMemberAliasId, name: "botMemberAliasId", parent: name, max: 10)
            try self.validate(self.botMemberAliasId, name: "botMemberAliasId", parent: name, min: 10)
            try self.validate(self.botMemberAliasId, name: "botMemberAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botMemberAliasName, name: "botMemberAliasName", parent: name, max: 100)
            try self.validate(self.botMemberAliasName, name: "botMemberAliasName", parent: name, min: 1)
            try self.validate(self.botMemberAliasName, name: "botMemberAliasName", parent: name, pattern: "^(\\bAmazonLexTestAlias\\b|[0-9a-zA-Z][_-]?)+$")
            try self.validate(self.botMemberId, name: "botMemberId", parent: name, max: 10)
            try self.validate(self.botMemberId, name: "botMemberId", parent: name, min: 10)
            try self.validate(self.botMemberId, name: "botMemberId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botMemberName, name: "botMemberName", parent: name, max: 100)
            try self.validate(self.botMemberName, name: "botMemberName", parent: name, min: 1)
            try self.validate(self.botMemberName, name: "botMemberName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.botMemberVersion, name: "botMemberVersion", parent: name, max: 5)
            try self.validate(self.botMemberVersion, name: "botMemberVersion", parent: name, min: 1)
            try self.validate(self.botMemberVersion, name: "botMemberVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case botMemberAliasId = "botMemberAliasId"
            case botMemberAliasName = "botMemberAliasName"
            case botMemberId = "botMemberId"
            case botMemberName = "botMemberName"
            case botMemberVersion = "botMemberVersion"
        }
    }

    public struct BotRecommendationResultStatistics: AWSDecodableShape {
        /// Statistical information about about the intents associated with the bot recommendation results.
        public let intents: IntentStatistics?
        /// Statistical information about the slot types associated with the bot recommendation results.
        public let slotTypes: SlotTypeStatistics?

        @inlinable
        public init(intents: IntentStatistics? = nil, slotTypes: SlotTypeStatistics? = nil) {
            self.intents = intents
            self.slotTypes = slotTypes
        }

        private enum CodingKeys: String, CodingKey {
            case intents = "intents"
            case slotTypes = "slotTypes"
        }
    }

    public struct BotRecommendationResults: AWSDecodableShape {
        /// The presigned url link of the associated transcript.
        public let associatedTranscriptsUrl: String?
        /// The presigned URL link of the recommended bot definition.
        public let botLocaleExportUrl: String?
        /// The statistical summary of the bot recommendation results.
        public let statistics: BotRecommendationResultStatistics?

        @inlinable
        public init(associatedTranscriptsUrl: String? = nil, botLocaleExportUrl: String? = nil, statistics: BotRecommendationResultStatistics? = nil) {
            self.associatedTranscriptsUrl = associatedTranscriptsUrl
            self.botLocaleExportUrl = botLocaleExportUrl
            self.statistics = statistics
        }

        private enum CodingKeys: String, CodingKey {
            case associatedTranscriptsUrl = "associatedTranscriptsUrl"
            case botLocaleExportUrl = "botLocaleExportUrl"
            case statistics = "statistics"
        }
    }

    public struct BotRecommendationSummary: AWSDecodableShape {
        /// The unique identifier of the bot recommendation to be updated.
        public let botRecommendationId: String
        /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
        public let botRecommendationStatus: BotRecommendationStatus
        /// A timestamp of the date and time that the bot recommendation was created.
        public let creationDateTime: Date?
        /// A timestamp of the date and time that the bot recommendation was last updated.
        public let lastUpdatedDateTime: Date?

        @inlinable
        public init(botRecommendationId: String, botRecommendationStatus: BotRecommendationStatus, creationDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil) {
            self.botRecommendationId = botRecommendationId
            self.botRecommendationStatus = botRecommendationStatus
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case botRecommendationId = "botRecommendationId"
            case botRecommendationStatus = "botRecommendationStatus"
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
        }
    }

    public struct BotReplicaSummary: AWSDecodableShape {
        /// The operation status for the replicated bot applicable.
        public let botReplicaStatus: BotReplicaStatus?
        /// The creation time and date for the replicated bots.
        public let creationDateTime: Date?
        /// The reasons for the failure for the replicated bot.
        public let failureReasons: [String]?
        /// The replica region used in the replication statuses summary.
        public let replicaRegion: String?

        @inlinable
        public init(botReplicaStatus: BotReplicaStatus? = nil, creationDateTime: Date? = nil, failureReasons: [String]? = nil, replicaRegion: String? = nil) {
            self.botReplicaStatus = botReplicaStatus
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
            self.replicaRegion = replicaRegion
        }

        private enum CodingKeys: String, CodingKey {
            case botReplicaStatus = "botReplicaStatus"
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
            case replicaRegion = "replicaRegion"
        }
    }

    public struct BotSortBy: AWSEncodableShape {
        /// The attribute to use to sort the list of bots.
        public let attribute: BotSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        @inlinable
        public init(attribute: BotSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BotSummary: AWSDecodableShape {
        /// The unique identifier assigned to the bot. Use this ID to get detailed information about the bot with the DescribeBot operation.
        public let botId: String?
        /// The name of the bot.
        public let botName: String?
        /// The current status of the bot. When the status is Available the bot is ready for use.
        public let botStatus: BotStatus?
        /// The type of the bot.
        public let botType: BotType?
        /// The description of the bot.
        public let description: String?
        /// The date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The latest numerical version in use for the bot.
        public let latestBotVersion: String?

        @inlinable
        public init(botId: String? = nil, botName: String? = nil, botStatus: BotStatus? = nil, botType: BotType? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, latestBotVersion: String? = nil) {
            self.botId = botId
            self.botName = botName
            self.botStatus = botStatus
            self.botType = botType
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestBotVersion = latestBotVersion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botName = "botName"
            case botStatus = "botStatus"
            case botType = "botType"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestBotVersion = "latestBotVersion"
        }
    }

    public struct BotVersionLocaleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The version of a bot used for a bot locale.
        public let sourceBotVersion: String

        @inlinable
        public init(sourceBotVersion: String) {
            self.sourceBotVersion = sourceBotVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceBotVersion, name: "sourceBotVersion", parent: name, max: 5)
            try self.validate(self.sourceBotVersion, name: "sourceBotVersion", parent: name, min: 1)
            try self.validate(self.sourceBotVersion, name: "sourceBotVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceBotVersion = "sourceBotVersion"
        }
    }

    public struct BotVersionReplicaSortBy: AWSEncodableShape {
        /// The attribute of the sort category for the version replicated bots.
        public let attribute: BotVersionReplicaSortAttribute
        /// The order of the sort category for the version replicated bots.
        public let order: SortOrder

        @inlinable
        public init(attribute: BotVersionReplicaSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BotVersionReplicaSummary: AWSDecodableShape {
        /// The bot version for the summary information for all the version replication statuses.
        public let botVersion: String?
        /// The version replication status for all the replicated bots.
        public let botVersionReplicationStatus: BotVersionReplicationStatus?
        /// The creation date and time of the replication status for all the replicated bots.
        public let creationDateTime: Date?
        /// The reasons for replication failure for all the replicated bots.
        public let failureReasons: [String]?

        @inlinable
        public init(botVersion: String? = nil, botVersionReplicationStatus: BotVersionReplicationStatus? = nil, creationDateTime: Date? = nil, failureReasons: [String]? = nil) {
            self.botVersion = botVersion
            self.botVersionReplicationStatus = botVersionReplicationStatus
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
        }

        private enum CodingKeys: String, CodingKey {
            case botVersion = "botVersion"
            case botVersionReplicationStatus = "botVersionReplicationStatus"
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
        }
    }

    public struct BotVersionSortBy: AWSEncodableShape {
        /// The attribute to use to sort the list of versions.
        public let attribute: BotVersionSortAttribute
        /// The order to sort the list. You can specify ascending or descending order.
        public let order: SortOrder

        @inlinable
        public init(attribute: BotVersionSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BotVersionSummary: AWSDecodableShape {
        /// The name of the bot associated with the version.
        public let botName: String?
        /// The status of the bot. When the status is available, the version of the bot is ready for use.
        public let botStatus: BotStatus?
        /// The numeric version of the bot, or DRAFT to indicate that this is the version of the bot that can be updated..
        public let botVersion: String?
        /// A timestamp of the date and time that the version was created.
        public let creationDateTime: Date?
        /// The description of the version.
        public let description: String?

        @inlinable
        public init(botName: String? = nil, botStatus: BotStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil) {
            self.botName = botName
            self.botStatus = botStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case botName = "botName"
            case botStatus = "botStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
        }
    }

    public struct BuildBotLocaleRequest: AWSEncodableShape {
        /// The identifier of the bot to build. The identifier is returned in the response from the CreateBot operation.
        public let botId: String
        /// The version of the bot to build. This can only be the draft version of the bot.
        public let botVersion: String
        /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see Supported languages.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct BuildBotLocaleResponse: AWSDecodableShape {
        /// The identifier of the specified bot.
        public let botId: String?
        /// The bot's build status. When the status is ReadyExpressTesting you can test the bot using the utterances defined for the intents and slot types. When the status is Built, the bot is ready for use and can be tested using any utterance.
        public let botLocaleStatus: BotLocaleStatus?
        /// The version of the bot that was built. This is only the draft version of the bot.
        public let botVersion: String?
        /// A timestamp indicating the date and time that the bot was last built for this locale.
        public let lastBuildSubmittedDateTime: Date?
        /// The language and locale specified of where the bot can be used.
        public let localeId: String?

        @inlinable
        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, lastBuildSubmittedDateTime: Date? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case lastBuildSubmittedDateTime = "lastBuildSubmittedDateTime"
            case localeId = "localeId"
        }
    }

    public struct BuildtimeSettings: AWSEncodableShape & AWSDecodableShape {
        /// An object containing specifications for the descriptive bot building feature.
        public let descriptiveBotBuilder: DescriptiveBotBuilderSpecification?
        /// Contains specifications for the sample utterance generation feature.
        public let sampleUtteranceGeneration: SampleUtteranceGenerationSpecification?

        @inlinable
        public init(descriptiveBotBuilder: DescriptiveBotBuilderSpecification? = nil, sampleUtteranceGeneration: SampleUtteranceGenerationSpecification? = nil) {
            self.descriptiveBotBuilder = descriptiveBotBuilder
            self.sampleUtteranceGeneration = sampleUtteranceGeneration
        }

        public func validate(name: String) throws {
            try self.descriptiveBotBuilder?.validate(name: "\(name).descriptiveBotBuilder")
            try self.sampleUtteranceGeneration?.validate(name: "\(name).sampleUtteranceGeneration")
        }

        private enum CodingKeys: String, CodingKey {
            case descriptiveBotBuilder = "descriptiveBotBuilder"
            case sampleUtteranceGeneration = "sampleUtteranceGeneration"
        }
    }

    public struct BuiltInIntentSortBy: AWSEncodableShape {
        /// The attribute to use to sort the list of built-in intents.
        public let attribute: BuiltInIntentSortAttribute
        /// The order to sort the list. You can specify ascending or descending order.
        public let order: SortOrder

        @inlinable
        public init(attribute: BuiltInIntentSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BuiltInIntentSummary: AWSDecodableShape {
        /// The description of the intent.
        public let description: String?
        /// The signature of the built-in intent. Use this to specify the parent intent of a derived intent.
        public let intentSignature: String?

        @inlinable
        public init(description: String? = nil, intentSignature: String? = nil) {
            self.description = description
            self.intentSignature = intentSignature
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case intentSignature = "intentSignature"
        }
    }

    public struct BuiltInSlotTypeSortBy: AWSEncodableShape {
        /// The attribute to use to sort the list of built-in intents.
        public let attribute: BuiltInSlotTypeSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        @inlinable
        public init(attribute: BuiltInSlotTypeSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct BuiltInSlotTypeSummary: AWSDecodableShape {
        /// The description of the built-in slot type.
        public let description: String?
        /// The signature of the built-in slot type. Use this to specify the parent slot type of a derived slot type.
        public let slotTypeSignature: String?

        @inlinable
        public init(description: String? = nil, slotTypeSignature: String? = nil) {
            self.description = description
            self.slotTypeSignature = slotTypeSignature
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case slotTypeSignature = "slotTypeSignature"
        }
    }

    public struct Button: AWSEncodableShape & AWSDecodableShape {
        /// The text that appears on the button. Use this to tell the user what value is returned when they choose this button.
        public let text: String
        /// The value returned to Amazon Lex when the user chooses this button. This must be one of the slot values configured for the slot.
        public let value: String

        @inlinable
        public init(text: String, value: String) {
            self.text = text
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 50)
            try self.validate(self.text, name: "text", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 50)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
            case value = "value"
        }
    }

    public struct CloudWatchLogGroupLogDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the log group where text and metadata logs are delivered.
        public let cloudWatchLogGroupArn: String
        /// The prefix of the log stream name within the log group that you specified
        public let logPrefix: String

        @inlinable
        public init(cloudWatchLogGroupArn: String, logPrefix: String) {
            self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
            self.logPrefix = logPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupArn, name: "cloudWatchLogGroupArn", parent: name, max: 2048)
            try self.validate(self.cloudWatchLogGroupArn, name: "cloudWatchLogGroupArn", parent: name, min: 1)
            try self.validate(self.cloudWatchLogGroupArn, name: "cloudWatchLogGroupArn", parent: name, pattern: "^arn:[\\w\\-]+:logs:[\\w\\-]+:[\\d]{12}:log-group:[\\.\\-_/#A-Za-z0-9]{1,512}(?::\\*)?$")
            try self.validate(self.logPrefix, name: "logPrefix", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogGroupArn = "cloudWatchLogGroupArn"
            case logPrefix = "logPrefix"
        }
    }

    public struct CodeHookSpecification: AWSEncodableShape & AWSDecodableShape {
        public let lambdaCodeHook: LambdaCodeHook

        @inlinable
        public init(lambdaCodeHook: LambdaCodeHook) {
            self.lambdaCodeHook = lambdaCodeHook
        }

        public func validate(name: String) throws {
            try self.lambdaCodeHook.validate(name: "\(name).lambdaCodeHook")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaCodeHook = "lambdaCodeHook"
        }
    }

    public struct CompositeSlotTypeSetting: AWSEncodableShape & AWSDecodableShape {
        /// Subslots in the composite slot.
        public let subSlots: [SubSlotTypeComposition]?

        @inlinable
        public init(subSlots: [SubSlotTypeComposition]? = nil) {
            self.subSlots = subSlots
        }

        public func validate(name: String) throws {
            try self.subSlots?.forEach {
                try $0.validate(name: "\(name).subSlots[]")
            }
            try self.validate(self.subSlots, name: "subSlots", parent: name, max: 6)
        }

        private enum CodingKeys: String, CodingKey {
            case subSlots = "subSlots"
        }
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        /// The expression string that is evaluated.
        public let expressionString: String

        @inlinable
        public init(expressionString: String) {
            self.expressionString = expressionString
        }

        public func validate(name: String) throws {
            try self.validate(self.expressionString, name: "expressionString", parent: name, max: 1024)
            try self.validate(self.expressionString, name: "expressionString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expressionString = "expressionString"
        }
    }

    public struct ConditionalBranch: AWSEncodableShape & AWSDecodableShape {
        /// Contains the expression to evaluate. If the condition is true, the branch's actions are taken.
        public let condition: Condition
        /// The name of the branch.
        public let name: String
        /// The next step in the conversation.
        public let nextStep: DialogState
        public let response: ResponseSpecification?

        @inlinable
        public init(condition: Condition, name: String, nextStep: DialogState, response: ResponseSpecification? = nil) {
            self.condition = condition
            self.name = name
            self.nextStep = nextStep
            self.response = response
        }

        public func validate(name: String) throws {
            try self.condition.validate(name: "\(name).condition")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.nextStep.validate(name: "\(name).nextStep")
            try self.response?.validate(name: "\(name).response")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case name = "name"
            case nextStep = "nextStep"
            case response = "response"
        }
    }

    public struct ConditionalSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether a conditional branch is active. When active is false, the conditions are not evaluated.
        public let active: Bool
        /// A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
        public let conditionalBranches: [ConditionalBranch]
        /// The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
        public let defaultBranch: DefaultConditionalBranch

        @inlinable
        public init(active: Bool, conditionalBranches: [ConditionalBranch], defaultBranch: DefaultConditionalBranch) {
            self.active = active
            self.conditionalBranches = conditionalBranches
            self.defaultBranch = defaultBranch
        }

        public func validate(name: String) throws {
            try self.conditionalBranches.forEach {
                try $0.validate(name: "\(name).conditionalBranches[]")
            }
            try self.validate(self.conditionalBranches, name: "conditionalBranches", parent: name, max: 4)
            try self.validate(self.conditionalBranches, name: "conditionalBranches", parent: name, min: 1)
            try self.defaultBranch.validate(name: "\(name).defaultBranch")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case conditionalBranches = "conditionalBranches"
            case defaultBranch = "defaultBranch"
        }
    }

    public struct ConversationLevelIntentClassificationResultItem: AWSDecodableShape {
        /// The intent name used in the evaluation of intent level success or failure.
        public let intentName: String
        /// The number of times the specific intent is used in the evaluation of intent level success or failure.
        public let matchResult: TestResultMatchStatus

        @inlinable
        public init(intentName: String, matchResult: TestResultMatchStatus) {
            self.intentName = intentName
            self.matchResult = matchResult
        }

        private enum CodingKeys: String, CodingKey {
            case intentName = "intentName"
            case matchResult = "matchResult"
        }
    }

    public struct ConversationLevelResultDetail: AWSDecodableShape {
        /// The success or failure of the streaming of the conversation.
        public let endToEndResult: TestResultMatchStatus
        /// The speech transcription success or failure details of the conversation.
        public let speechTranscriptionResult: TestResultMatchStatus?

        @inlinable
        public init(endToEndResult: TestResultMatchStatus, speechTranscriptionResult: TestResultMatchStatus? = nil) {
            self.endToEndResult = endToEndResult
            self.speechTranscriptionResult = speechTranscriptionResult
        }

        private enum CodingKeys: String, CodingKey {
            case endToEndResult = "endToEndResult"
            case speechTranscriptionResult = "speechTranscriptionResult"
        }
    }

    public struct ConversationLevelSlotResolutionResultItem: AWSDecodableShape {
        /// The intents used in the slots list for the slot resolution details.
        public let intentName: String
        /// The number of matching slots used in the slots listings for the slot resolution evaluation.
        public let matchResult: TestResultMatchStatus
        /// The slot name in the slots list for the slot resolution details.
        public let slotName: String

        @inlinable
        public init(intentName: String, matchResult: TestResultMatchStatus, slotName: String) {
            self.intentName = intentName
            self.matchResult = matchResult
            self.slotName = slotName
        }

        private enum CodingKeys: String, CodingKey {
            case intentName = "intentName"
            case matchResult = "matchResult"
            case slotName = "slotName"
        }
    }

    public struct ConversationLevelTestResultItem: AWSDecodableShape {
        /// The conversation Id of the test result evaluation item.
        public let conversationId: String
        /// The end-to-end success or failure of the test result evaluation item.
        public let endToEndResult: TestResultMatchStatus
        /// The intent classification of the test result evaluation item.
        public let intentClassificationResults: [ConversationLevelIntentClassificationResultItem]
        /// The slot success or failure of the test result evaluation item.
        public let slotResolutionResults: [ConversationLevelSlotResolutionResultItem]
        /// The speech transcription success or failure of the test result evaluation item.
        public let speechTranscriptionResult: TestResultMatchStatus?

        @inlinable
        public init(conversationId: String, endToEndResult: TestResultMatchStatus, intentClassificationResults: [ConversationLevelIntentClassificationResultItem], slotResolutionResults: [ConversationLevelSlotResolutionResultItem], speechTranscriptionResult: TestResultMatchStatus? = nil) {
            self.conversationId = conversationId
            self.endToEndResult = endToEndResult
            self.intentClassificationResults = intentClassificationResults
            self.slotResolutionResults = slotResolutionResults
            self.speechTranscriptionResult = speechTranscriptionResult
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case endToEndResult = "endToEndResult"
            case intentClassificationResults = "intentClassificationResults"
            case slotResolutionResults = "slotResolutionResults"
            case speechTranscriptionResult = "speechTranscriptionResult"
        }
    }

    public struct ConversationLevelTestResults: AWSDecodableShape {
        /// The item list in the test set results data at the conversation level.
        public let items: [ConversationLevelTestResultItem]

        @inlinable
        public init(items: [ConversationLevelTestResultItem]) {
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
        }
    }

    public struct ConversationLevelTestResultsFilterBy: AWSEncodableShape {
        /// The selection of matched or mismatched end-to-end status to filter test set results data at the conversation level.
        public let endToEndResult: TestResultMatchStatus?

        @inlinable
        public init(endToEndResult: TestResultMatchStatus? = nil) {
            self.endToEndResult = endToEndResult
        }

        private enum CodingKeys: String, CodingKey {
            case endToEndResult = "endToEndResult"
        }
    }

    public struct ConversationLogSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 settings for logging audio to an S3 bucket.
        public let audioLogSettings: [AudioLogSetting]?
        /// The Amazon CloudWatch Logs settings for logging text and metadata.
        public let textLogSettings: [TextLogSetting]?

        @inlinable
        public init(audioLogSettings: [AudioLogSetting]? = nil, textLogSettings: [TextLogSetting]? = nil) {
            self.audioLogSettings = audioLogSettings
            self.textLogSettings = textLogSettings
        }

        public func validate(name: String) throws {
            try self.audioLogSettings?.forEach {
                try $0.validate(name: "\(name).audioLogSettings[]")
            }
            try self.validate(self.audioLogSettings, name: "audioLogSettings", parent: name, max: 1)
            try self.validate(self.audioLogSettings, name: "audioLogSettings", parent: name, min: 1)
            try self.textLogSettings?.forEach {
                try $0.validate(name: "\(name).textLogSettings[]")
            }
            try self.validate(self.textLogSettings, name: "textLogSettings", parent: name, max: 1)
            try self.validate(self.textLogSettings, name: "textLogSettings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audioLogSettings = "audioLogSettings"
            case textLogSettings = "textLogSettings"
        }
    }

    public struct ConversationLogsDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The bot alias Id from the conversation logs.
        public let botAliasId: String
        /// The bot Id from the conversation logs.
        public let botId: String
        /// The filter for the data source of the conversation log.
        public let filter: ConversationLogsDataSourceFilterBy
        /// The locale Id of the conversation log.
        public let localeId: String

        @inlinable
        public init(botAliasId: String, botId: String, filter: ConversationLogsDataSourceFilterBy, localeId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.filter = filter
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botId = "botId"
            case filter = "filter"
            case localeId = "localeId"
        }
    }

    public struct ConversationLogsDataSourceFilterBy: AWSEncodableShape & AWSDecodableShape {
        /// The end time for the conversation log.
        public let endTime: Date
        /// The selection to filter by input mode for the conversation logs.
        public let inputMode: ConversationLogsInputModeFilter
        /// The start time for the conversation log.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, inputMode: ConversationLogsInputModeFilter, startTime: Date) {
            self.endTime = endTime
            self.inputMode = inputMode
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case inputMode = "inputMode"
            case startTime = "startTime"
        }
    }

    public struct CreateBotAliasRequest: AWSEncodableShape {
        /// Maps configuration information to a specific locale. You can use this parameter to specify a specific Lambda function to run different functions in different locales.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The alias to create. The name must be unique for the bot.
        public let botAliasName: String
        /// The unique identifier of the bot that the alias applies to.
        public let botId: String
        /// The version of the bot that this alias points to. You can use the UpdateBotAlias operation to change the bot version associated with the alias.
        public let botVersion: String?
        /// Specifies whether Amazon Lex logs text and audio for a conversation with the bot. When you enable conversation logs, text logs store text input, transcripts of audio input, and associated metadata in Amazon CloudWatch Logs. Audio logs store audio input in Amazon S3.
        public let conversationLogSettings: ConversationLogSettings?
        /// A description of the alias. Use this description to help identify the alias.
        public let description: String?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?
        /// A list of tags to add to the bot alias. You can only add tags when you create an alias, you can't use the UpdateBotAlias operation to update the tags on a bot alias. To update tags, use the TagResource operation.
        public let tags: [String: String]?

        @inlinable
        public init(botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String, botId: String, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, description: String? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil, tags: [String: String]? = nil) {
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.description = description
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.botAliasLocaleSettings, forKey: .botAliasLocaleSettings)
            try container.encode(self.botAliasName, forKey: .botAliasName)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.botVersion, forKey: .botVersion)
            try container.encodeIfPresent(self.conversationLogSettings, forKey: .conversationLogSettings)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.sentimentAnalysisSettings, forKey: .sentimentAnalysisSettings)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.botAliasLocaleSettings?.forEach {
                try $0.value.validate(name: "\(name).botAliasLocaleSettings[\"\($0.key)\"]")
            }
            try self.validate(self.botAliasLocaleSettings, name: "botAliasLocaleSettings", parent: name, min: 1)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, max: 100)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, min: 1)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^[0-9]+$")
            try self.conversationLogSettings?.validate(name: "\(name).conversationLogSettings")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case description = "description"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
            case tags = "tags"
        }
    }

    public struct CreateBotAliasResponse: AWSDecodableShape {
        /// The unique identifier of the bot alias.
        public let botAliasId: String?
        /// Configuration information for a specific locale.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The name specified for the bot alias.
        public let botAliasName: String?
        /// The current status of the alias. The alias is first put into the Creating state. When the alias is ready to be used, it is put into the Available state. You can use the DescribeBotAlias operation to get the current state of an alias.
        public let botAliasStatus: BotAliasStatus?
        /// The unique identifier of the bot that this alias applies to.
        public let botId: String?
        /// The version of the bot associated with this alias.
        public let botVersion: String?
        /// The conversation log settings specified for the alias.
        public let conversationLogSettings: ConversationLogSettings?
        /// A Unix timestamp indicating the date and time that the bot alias was created.
        public let creationDateTime: Date?
        /// The description specified for the bot alias.
        public let description: String?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?
        /// A list of tags associated with the bot alias.
        public let tags: [String: String]?

        @inlinable
        public init(botAliasId: String? = nil, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, creationDateTime: Date? = nil, description: String? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil, tags: [String: String]? = nil) {
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.creationDateTime = creationDateTime
            self.description = description
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
            case tags = "tags"
        }
    }

    public struct CreateBotLocaleRequest: AWSEncodableShape {
        /// The identifier of the bot to create the locale for.
        public let botId: String
        /// The version of the bot to create the locale for. This can only be the draft version of the bot.
        public let botVersion: String
        /// A description of the bot locale. Use this to help identify the bot locale in lists.
        public let description: String?
        public let generativeAISettings: GenerativeAISettings?
        /// The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see Supported languages.
        public let localeId: String
        /// Determines the threshold where Amazon Lex will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot. For example, suppose a bot is configured with the confidence threshold of 0.80 and the AMAZON.FallbackIntent. Amazon Lex returns three alternative intents with the following confidence scores: IntentA (0.70), IntentB (0.60), IntentC (0.50). The response from the RecognizeText operation would be:   AMAZON.FallbackIntent   IntentA   IntentB   IntentC
        public let nluIntentConfidenceThreshold: Double
        /// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        @inlinable
        public init(botId: String, botVersion: String, description: String? = nil, generativeAISettings: GenerativeAISettings? = nil, localeId: String, nluIntentConfidenceThreshold: Double, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.generativeAISettings = generativeAISettings
            self.localeId = localeId
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.generativeAISettings, forKey: .generativeAISettings)
            try container.encode(self.localeId, forKey: .localeId)
            try container.encode(self.nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
            try container.encodeIfPresent(self.voiceSettings, forKey: .voiceSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.generativeAISettings?.validate(name: "\(name).generativeAISettings")
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, max: 1.0)
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case generativeAISettings = "generativeAISettings"
            case localeId = "localeId"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct CreateBotLocaleResponse: AWSDecodableShape {
        /// The specified bot identifier.
        public let botId: String?
        /// The status of the bot. When the status is Creating the bot locale is being configured. When the status is Building Amazon Lex is building the bot for testing and use. If the status of the bot is ReadyExpressTesting, you can test the bot using the exact utterances specified in the bots' intents. When the bot is ready for full testing or to run, the status is Built. If there was a problem with building the bot, the status is Failed. If the bot was saved but not built, the status is NotBuilt.
        public let botLocaleStatus: BotLocaleStatus?
        /// The specified bot version.
        public let botVersion: String?
        /// A timestamp specifying the date and time that the bot locale was created.
        public let creationDateTime: Date?
        /// The specified description of the bot locale.
        public let description: String?
        public let generativeAISettings: GenerativeAISettings?
        /// The specified locale identifier.
        public let localeId: String?
        /// The specified locale name.
        public let localeName: String?
        /// The specified confidence threshold for inserting the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents.
        public let nluIntentConfidenceThreshold: Double?
        /// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        @inlinable
        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, generativeAISettings: GenerativeAISettings? = nil, localeId: String? = nil, localeName: String? = nil, nluIntentConfidenceThreshold: Double? = nil, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.generativeAISettings = generativeAISettings
            self.localeId = localeId
            self.localeName = localeName
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case generativeAISettings = "generativeAISettings"
            case localeId = "localeId"
            case localeName = "localeName"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct CreateBotReplicaRequest: AWSEncodableShape {
        /// The request for the unique bot ID of the source bot to be replicated in the secondary region.
        public let botId: String
        /// The request for the secondary region that will be used in the replication of the source bot.
        public let replicaRegion: String

        @inlinable
        public init(botId: String, replicaRegion: String) {
            self.botId = botId
            self.replicaRegion = replicaRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.replicaRegion, forKey: .replicaRegion)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, max: 25)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case replicaRegion = "replicaRegion"
        }
    }

    public struct CreateBotReplicaResponse: AWSDecodableShape {
        /// The unique bot ID of the replicated bot generated.
        public let botId: String?
        /// The operational status of the replicated bot generated.
        public let botReplicaStatus: BotReplicaStatus?
        /// The creation date and time of the replicated bot generated.
        public let creationDateTime: Date?
        /// The region of the replicated bot generated.
        public let replicaRegion: String?
        /// The source region for the source bot used for the replicated bot generated.
        public let sourceRegion: String?

        @inlinable
        public init(botId: String? = nil, botReplicaStatus: BotReplicaStatus? = nil, creationDateTime: Date? = nil, replicaRegion: String? = nil, sourceRegion: String? = nil) {
            self.botId = botId
            self.botReplicaStatus = botReplicaStatus
            self.creationDateTime = creationDateTime
            self.replicaRegion = replicaRegion
            self.sourceRegion = sourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botReplicaStatus = "botReplicaStatus"
            case creationDateTime = "creationDateTime"
            case replicaRegion = "replicaRegion"
            case sourceRegion = "sourceRegion"
        }
    }

    public struct CreateBotRequest: AWSEncodableShape {
        /// The list of bot members in a network to be created.
        public let botMembers: [BotMember]?
        /// The name of the bot. The bot name must be unique in the account that creates the bot.
        public let botName: String
        /// A list of tags to add to the bot. You can only add tags when you create a bot. You can't use the UpdateBot operation to update tags. To update tags, use the TagResource operation.
        public let botTags: [String: String]?
        /// The type of a bot to create.
        public let botType: BotType?
        /// Provides information on additional privacy protections Amazon Lex should use with the bot's data.
        public let dataPrivacy: DataPrivacy
        /// A description of the bot. It appears in lists to help you identify a particular bot.
        public let description: String?
        /// Specifies the configuration for error logging during bot creation.
        public let errorLogSettings: ErrorLogSettings?
        /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot.  A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
        public let idleSessionTTLInSeconds: Int
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot.
        public let roleArn: String
        /// A list of tags to add to the test alias for a bot. You can only add tags when you create a bot. You can't use the UpdateAlias operation to update tags. To update tags on the test alias, use the TagResource operation.
        public let testBotAliasTags: [String: String]?

        @inlinable
        public init(botMembers: [BotMember]? = nil, botName: String, botTags: [String: String]? = nil, botType: BotType? = nil, dataPrivacy: DataPrivacy, description: String? = nil, errorLogSettings: ErrorLogSettings? = nil, idleSessionTTLInSeconds: Int, roleArn: String, testBotAliasTags: [String: String]? = nil) {
            self.botMembers = botMembers
            self.botName = botName
            self.botTags = botTags
            self.botType = botType
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.errorLogSettings = errorLogSettings
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
            self.testBotAliasTags = testBotAliasTags
        }

        public func validate(name: String) throws {
            try self.botMembers?.forEach {
                try $0.validate(name: "\(name).botMembers[]")
            }
            try self.validate(self.botMembers, name: "botMembers", parent: name, max: 10)
            try self.validate(self.botName, name: "botName", parent: name, max: 100)
            try self.validate(self.botName, name: "botName", parent: name, min: 1)
            try self.validate(self.botName, name: "botName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.botTags?.forEach {
                try validate($0.key, name: "botTags.key", parent: name, max: 128)
                try validate($0.key, name: "botTags.key", parent: name, min: 1)
                try validate($0.value, name: "botTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.botTags, name: "botTags", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 86400)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/.*$")
            try self.testBotAliasTags?.forEach {
                try validate($0.key, name: "testBotAliasTags.key", parent: name, max: 128)
                try validate($0.key, name: "testBotAliasTags.key", parent: name, min: 1)
                try validate($0.value, name: "testBotAliasTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.testBotAliasTags, name: "testBotAliasTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case botMembers = "botMembers"
            case botName = "botName"
            case botTags = "botTags"
            case botType = "botType"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case errorLogSettings = "errorLogSettings"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
            case testBotAliasTags = "testBotAliasTags"
        }
    }

    public struct CreateBotResponse: AWSDecodableShape {
        /// A unique identifier for a particular bot. You use this to identify the bot when you call other Amazon Lex API operations.
        public let botId: String?
        /// The list of bots in a network that was created.
        public let botMembers: [BotMember]?
        /// The name specified for the bot.
        public let botName: String?
        /// Shows the current status of the bot. The bot is first in the Creating status. Once the bot is read for use, it changes to the Available status. After the bot is created, you can use the DRAFT version of the bot.
        public let botStatus: BotStatus?
        /// A list of tags associated with the bot.
        public let botTags: [String: String]?
        /// The type of a bot that was created.
        public let botType: BotType?
        /// A timestamp indicating the date and time that the bot was created.
        public let creationDateTime: Date?
        /// The data privacy settings specified for the bot.
        public let dataPrivacy: DataPrivacy?
        /// The description specified for the bot.
        public let description: String?
        /// Specifies configuration settings for delivering error logs to Cloudwatch Logs in an Amazon Lex bot response.
        public let errorLogSettings: ErrorLogSettings?
        /// The session idle time specified for the bot.
        public let idleSessionTTLInSeconds: Int?
        /// The IAM role specified for the bot.
        public let roleArn: String?
        /// A list of tags associated with the test alias for the bot.
        public let testBotAliasTags: [String: String]?

        @inlinable
        public init(botId: String? = nil, botMembers: [BotMember]? = nil, botName: String? = nil, botStatus: BotStatus? = nil, botTags: [String: String]? = nil, botType: BotType? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, errorLogSettings: ErrorLogSettings? = nil, idleSessionTTLInSeconds: Int? = nil, roleArn: String? = nil, testBotAliasTags: [String: String]? = nil) {
            self.botId = botId
            self.botMembers = botMembers
            self.botName = botName
            self.botStatus = botStatus
            self.botTags = botTags
            self.botType = botType
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.errorLogSettings = errorLogSettings
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
            self.testBotAliasTags = testBotAliasTags
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botMembers = "botMembers"
            case botName = "botName"
            case botStatus = "botStatus"
            case botTags = "botTags"
            case botType = "botType"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case errorLogSettings = "errorLogSettings"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
            case testBotAliasTags = "testBotAliasTags"
        }
    }

    public struct CreateBotVersionRequest: AWSEncodableShape {
        /// The identifier of the bot to create the version for.
        public let botId: String
        /// Specifies the locales that Amazon Lex adds to this version. You can choose the Draft version or any other previously published version for each locale. When you specify a source version, the locale data is copied from the source version to the new version.
        public let botVersionLocaleSpecification: [String: BotVersionLocaleDetails]
        /// A description of the version. Use the description to help identify the version in lists.
        public let description: String?

        @inlinable
        public init(botId: String, botVersionLocaleSpecification: [String: BotVersionLocaleDetails], description: String? = nil) {
            self.botId = botId
            self.botVersionLocaleSpecification = botVersionLocaleSpecification
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.botVersionLocaleSpecification, forKey: .botVersionLocaleSpecification)
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.botVersionLocaleSpecification.forEach {
                try $0.value.validate(name: "\(name).botVersionLocaleSpecification[\"\($0.key)\"]")
            }
            try self.validate(self.botVersionLocaleSpecification, name: "botVersionLocaleSpecification", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case botVersionLocaleSpecification = "botVersionLocaleSpecification"
            case description = "description"
        }
    }

    public struct CreateBotVersionResponse: AWSDecodableShape {
        /// The bot identifier specified in the request.
        public let botId: String?
        /// When you send a request to create or update a bot, Amazon Lex sets the status response element to Creating. After Amazon Lex builds the bot, it sets status to Available. If Amazon Lex can't build the bot, it sets status to Failed.
        public let botStatus: BotStatus?
        /// The version number assigned to the version.
        public let botVersion: String?
        /// The source versions used for each locale in the new version.
        public let botVersionLocaleSpecification: [String: BotVersionLocaleDetails]?
        /// A timestamp of the date and time that the version was created.
        public let creationDateTime: Date?
        /// The description of the version specified in the request.
        public let description: String?

        @inlinable
        public init(botId: String? = nil, botStatus: BotStatus? = nil, botVersion: String? = nil, botVersionLocaleSpecification: [String: BotVersionLocaleDetails]? = nil, creationDateTime: Date? = nil, description: String? = nil) {
            self.botId = botId
            self.botStatus = botStatus
            self.botVersion = botVersion
            self.botVersionLocaleSpecification = botVersionLocaleSpecification
            self.creationDateTime = creationDateTime
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botStatus = "botStatus"
            case botVersion = "botVersion"
            case botVersionLocaleSpecification = "botVersionLocaleSpecification"
            case creationDateTime = "creationDateTime"
            case description = "description"
        }
    }

    public struct CreateExportRequest: AWSEncodableShape {
        /// The file format of the bot or bot locale definition files.
        public let fileFormat: ImportExportFileFormat
        /// An password to use to encrypt the exported archive. Using a password is optional, but you should encrypt the archive to protect the data in transit between Amazon Lex and your local computer.
        public let filePassword: String?
        /// Specifies the type of resource to export, either a bot or a bot locale. You can only specify one type of resource to export.
        public let resourceSpecification: ExportResourceSpecification

        @inlinable
        public init(fileFormat: ImportExportFileFormat, filePassword: String? = nil, resourceSpecification: ExportResourceSpecification) {
            self.fileFormat = fileFormat
            self.filePassword = filePassword
            self.resourceSpecification = resourceSpecification
        }

        public func validate(name: String) throws {
            try self.validate(self.filePassword, name: "filePassword", parent: name, max: 1024)
            try self.validate(self.filePassword, name: "filePassword", parent: name, min: 1)
            try self.resourceSpecification.validate(name: "\(name).resourceSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat = "fileFormat"
            case filePassword = "filePassword"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct CreateExportResponse: AWSDecodableShape {
        /// The date and time that the request to export a bot was created.
        public let creationDateTime: Date?
        /// An identifier for a specific request to create an export.
        public let exportId: String?
        /// The status of the export. When the status is Completed, you can use the DescribeExport operation to get the pre-signed S3 URL link to your exported bot or bot locale.
        public let exportStatus: ExportStatus?
        /// The file format used for the bot or bot locale definition files.
        public let fileFormat: ImportExportFileFormat?
        /// A description of the type of resource that was exported, either a bot or a bot locale.
        public let resourceSpecification: ExportResourceSpecification?

        @inlinable
        public init(creationDateTime: Date? = nil, exportId: String? = nil, exportStatus: ExportStatus? = nil, fileFormat: ImportExportFileFormat? = nil, resourceSpecification: ExportResourceSpecification? = nil) {
            self.creationDateTime = creationDateTime
            self.exportId = exportId
            self.exportStatus = exportStatus
            self.fileFormat = fileFormat
            self.resourceSpecification = resourceSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case exportId = "exportId"
            case exportStatus = "exportStatus"
            case fileFormat = "fileFormat"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct CreateIntentRequest: AWSEncodableShape {
        /// The identifier of the bot associated with this intent.
        public let botId: String
        /// The version of the bot associated with this intent.
        public let botVersion: String
        /// A description of the intent. Use the description to help identify the intent in lists.
        public let description: String?
        /// Specifies that Amazon Lex invokes the alias Lambda function for each user input. You can invoke this Lambda function to personalize user interaction. For example, suppose that your bot determines that the user's name is John. You Lambda function might retrieve John's information from a backend database and prepopulate some of the values. For example, if you find that John is gluten intolerant, you might set the corresponding intent slot, glutenIntolerant to true. You might find John's phone number and set the corresponding session attribute.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// Specifies that Amazon Lex invokes the alias Lambda function when the intent is ready for fulfillment. You can invoke this function to complete the bot's transaction with the user. For example, in a pizza ordering bot, the Lambda function can look up the closest pizza restaurant to the customer's location and then place an order on the customer's behalf.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// Configuration settings for the response that is sent to the user at the beginning of a conversation, before eliciting slot values.
        public let initialResponseSetting: InitialResponseSetting?
        /// A list of contexts that must be active for this intent to be considered by Amazon Lex. When an intent has an input context list, Amazon Lex only considers using the intent in an interaction with the user when the specified contexts are included in the active context list for the session. If the contexts are not active, then Amazon Lex will not use the intent. A context can be automatically activated using the outputContexts property or it can be set at runtime. For example, if there are two intents with different input contexts that respond to the same utterances, only the intent with the active context will respond. An intent may have up to 5 input contexts. If an intent has multiple input contexts, all of the contexts must be active to consider the intent.
        public let inputContexts: [InputContext]?
        /// Sets the response that Amazon Lex sends to the user when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// Provides prompts that Amazon Lex sends to the user to confirm the completion of an intent. If the user answers "no," the settings contain a statement that is sent to the user to end the intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The name of the intent. Intent names must be unique in the locale that contains the intent and cannot match the name of any built-in intent.
        public let intentName: String
        /// Configuration information required to use the AMAZON.KendraSearchIntent intent to connect to an Amazon Kendra index. The AMAZON.KendraSearchIntent intent is called when Amazon Lex can't determine another intent to invoke.
        public let kendraConfiguration: KendraConfiguration?
        /// The identifier of the language and locale where this intent is used. All of the bots, slot types, and slots used by the intent must have the same locale. For more information, see Supported languages.
        public let localeId: String
        /// A lists of contexts that the intent activates when it is fulfilled. You can use an output context to indicate the intents that Amazon Lex should consider for the next turn of the conversation with a customer.  When you use the outputContextsList property, all of the contexts specified in the list are activated when the intent is fulfilled. You can set up to 10 output contexts. You can also set the number of conversation turns that the context should be active, or the length of time that the context should be active.
        public let outputContexts: [OutputContext]?
        /// A unique identifier for the built-in intent to base this intent on.
        public let parentIntentSignature: String?
        /// Qinconnect intent configuration details for the create intent request.
        public let qInConnectIntentConfiguration: QInConnectIntentConfiguration?
        /// Specifies the configuration of the built-in Amazon.QnAIntent. The AMAZON.QnAIntent intent is called when Amazon Lex can't determine another intent to invoke. If you specify this field, you can't specify the kendraConfiguration field.
        public let qnAIntentConfiguration: QnAIntentConfiguration?
        /// An array of strings that a user might say to signal the intent. For example, "I want a pizza", or "I want a {PizzaSize} pizza".  In an utterance, slot names are enclosed in curly braces ("{", "}") to indicate where they should be displayed in the utterance shown to the user..
        public let sampleUtterances: [SampleUtterance]?

        @inlinable
        public init(botId: String, botVersion: String, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, initialResponseSetting: InitialResponseSetting? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentName: String, kendraConfiguration: KendraConfiguration? = nil, localeId: String, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, qInConnectIntentConfiguration: QInConnectIntentConfiguration? = nil, qnAIntentConfiguration: QnAIntentConfiguration? = nil, sampleUtterances: [SampleUtterance]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.initialResponseSetting = initialResponseSetting
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.qInConnectIntentConfiguration = qInConnectIntentConfiguration
            self.qnAIntentConfiguration = qnAIntentConfiguration
            self.sampleUtterances = sampleUtterances
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dialogCodeHook, forKey: .dialogCodeHook)
            try container.encodeIfPresent(self.fulfillmentCodeHook, forKey: .fulfillmentCodeHook)
            try container.encodeIfPresent(self.initialResponseSetting, forKey: .initialResponseSetting)
            try container.encodeIfPresent(self.inputContexts, forKey: .inputContexts)
            try container.encodeIfPresent(self.intentClosingSetting, forKey: .intentClosingSetting)
            try container.encodeIfPresent(self.intentConfirmationSetting, forKey: .intentConfirmationSetting)
            try container.encode(self.intentName, forKey: .intentName)
            try container.encodeIfPresent(self.kendraConfiguration, forKey: .kendraConfiguration)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.outputContexts, forKey: .outputContexts)
            try container.encodeIfPresent(self.parentIntentSignature, forKey: .parentIntentSignature)
            try container.encodeIfPresent(self.qInConnectIntentConfiguration, forKey: .qInConnectIntentConfiguration)
            try container.encodeIfPresent(self.qnAIntentConfiguration, forKey: .qnAIntentConfiguration)
            try container.encodeIfPresent(self.sampleUtterances, forKey: .sampleUtterances)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.fulfillmentCodeHook?.validate(name: "\(name).fulfillmentCodeHook")
            try self.initialResponseSetting?.validate(name: "\(name).initialResponseSetting")
            try self.inputContexts?.forEach {
                try $0.validate(name: "\(name).inputContexts[]")
            }
            try self.validate(self.inputContexts, name: "inputContexts", parent: name, max: 5)
            try self.intentClosingSetting?.validate(name: "\(name).intentClosingSetting")
            try self.intentConfirmationSetting?.validate(name: "\(name).intentConfirmationSetting")
            try self.validate(self.intentName, name: "intentName", parent: name, max: 100)
            try self.validate(self.intentName, name: "intentName", parent: name, min: 1)
            try self.validate(self.intentName, name: "intentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.kendraConfiguration?.validate(name: "\(name).kendraConfiguration")
            try self.outputContexts?.forEach {
                try $0.validate(name: "\(name).outputContexts[]")
            }
            try self.validate(self.outputContexts, name: "outputContexts", parent: name, max: 10)
            try self.qInConnectIntentConfiguration?.validate(name: "\(name).qInConnectIntentConfiguration")
            try self.qnAIntentConfiguration?.validate(name: "\(name).qnAIntentConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case initialResponseSetting = "initialResponseSetting"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case qInConnectIntentConfiguration = "qInConnectIntentConfiguration"
            case qnAIntentConfiguration = "qnAIntentConfiguration"
            case sampleUtterances = "sampleUtterances"
        }
    }

    public struct CreateIntentResponse: AWSDecodableShape {
        /// The identifier of the bot associated with the intent.
        public let botId: String?
        /// The version of the bot associated with the intent.
        public let botVersion: String?
        /// A timestamp of the date and time that the intent was created.
        public let creationDateTime: Date?
        /// The description specified for the intent.
        public let description: String?
        /// The dialog Lambda function specified for the intent.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The fulfillment Lambda function specified for the intent.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// Configuration settings for the response that is sent to the user at the beginning of a conversation, before eliciting slot values.
        public let initialResponseSetting: InitialResponseSetting?
        /// The list of input contexts specified for the intent.
        public let inputContexts: [InputContext]?
        /// The closing setting specified for the intent.
        public let intentClosingSetting: IntentClosingSetting?
        /// The confirmation setting specified for the intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// A unique identifier for the intent.
        public let intentId: String?
        /// The name specified for the intent.
        public let intentName: String?
        /// Configuration for searching a Amazon Kendra index specified for the intent.
        public let kendraConfiguration: KendraConfiguration?
        /// The locale that the intent is specified to use.
        public let localeId: String?
        /// The list of output contexts specified for the intent.
        public let outputContexts: [OutputContext]?
        /// The signature of the parent intent specified for the intent.
        public let parentIntentSignature: String?
        /// Qinconnect intent configuration details for the create intent response.
        public let qInConnectIntentConfiguration: QInConnectIntentConfiguration?
        /// Details about the the configuration of the built-in Amazon.QnAIntent.
        public let qnAIntentConfiguration: QnAIntentConfiguration?
        /// The sample utterances specified for the intent.
        public let sampleUtterances: [SampleUtterance]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, initialResponseSetting: InitialResponseSetting? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String? = nil, intentName: String? = nil, kendraConfiguration: KendraConfiguration? = nil, localeId: String? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, qInConnectIntentConfiguration: QInConnectIntentConfiguration? = nil, qnAIntentConfiguration: QnAIntentConfiguration? = nil, sampleUtterances: [SampleUtterance]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.initialResponseSetting = initialResponseSetting
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.qInConnectIntentConfiguration = qInConnectIntentConfiguration
            self.qnAIntentConfiguration = qnAIntentConfiguration
            self.sampleUtterances = sampleUtterances
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case initialResponseSetting = "initialResponseSetting"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentId = "intentId"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case localeId = "localeId"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case qInConnectIntentConfiguration = "qInConnectIntentConfiguration"
            case qnAIntentConfiguration = "qnAIntentConfiguration"
            case sampleUtterances = "sampleUtterances"
        }
    }

    public struct CreateResourcePolicyRequest: AWSEncodableShape {
        /// A resource policy to add to the resource. The policy is a JSON structure that contains one or more statements that define the policy. The policy must follow the IAM syntax. For more information about the contents of a JSON policy document, see  IAM JSON policy reference .  If the policy isn't valid, Amazon Lex returns a validation exception.
        public let policy: String
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String

        @inlinable
        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policy, forKey: .policy)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, min: 2)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct CreateResourcePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy was attached to.
        public let resourceArn: String?
        /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
        public let revisionId: String?

        @inlinable
        public init(resourceArn: String? = nil, revisionId: String? = nil) {
            self.resourceArn = resourceArn
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case revisionId = "revisionId"
        }
    }

    public struct CreateResourcePolicyStatementRequest: AWSEncodableShape {
        /// The Amazon Lex action that this policy either allows or denies. The action must apply to the resource type of the specified ARN. For more information, see  Actions, resources, and condition keys for Amazon Lex V2.
        public let action: [String]
        /// Specifies a condition when the policy is in effect. If the principal of the policy is a service principal, you must provide two condition blocks, one with a SourceAccount global condition key and one with a SourceArn global condition key. For more information, see IAM JSON policy elements: Condition .
        public let condition: [String: [String: String]]?
        /// Determines whether the statement allows or denies access to the resource.
        public let effect: Effect
        /// The identifier of the revision of the policy to edit. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex overwrites the contents of the policy with the new values.
        public let expectedRevisionId: String?
        /// An IAM principal, such as an IAM user, IAM role,  or Amazon Web Services services that is allowed or denied access to a resource. For more information, see Amazon Web Services JSON policy elements: Principal.
        public let principal: [Principal]
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String
        /// The name of the statement. The ID is the same as the Sid IAM property. The statement name must be unique within the policy. For more information, see IAM JSON policy elements: Sid.
        public let statementId: String

        @inlinable
        public init(action: [String], condition: [String: [String: String]]? = nil, effect: Effect, expectedRevisionId: String? = nil, principal: [Principal], resourceArn: String, statementId: String) {
            self.action = action
            self.condition = condition
            self.effect = effect
            self.expectedRevisionId = expectedRevisionId
            self.principal = principal
            self.resourceArn = resourceArn
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.condition, forKey: .condition)
            try container.encode(self.effect, forKey: .effect)
            request.encodeQuery(self.expectedRevisionId, key: "expectedRevisionId")
            try container.encode(self.principal, forKey: .principal)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.statementId, forKey: .statementId)
        }

        public func validate(name: String) throws {
            try self.action.forEach {
                try validate($0, name: "action[]", parent: name, max: 50)
                try validate($0, name: "action[]", parent: name, min: 5)
                try validate($0, name: "action[]", parent: name, pattern: "^lex:[a-zA-Z*]+$")
            }
            try self.condition?.forEach {
                try validate($0.key, name: "condition.key", parent: name, min: 1)
                try validate($0.value, name: "condition[\"\($0.key)\"]", parent: name, max: 10)
            }
            try self.validate(self.condition, name: "condition", parent: name, max: 10)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, max: 5)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, min: 1)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, pattern: "^[0-9]+$")
            try self.principal.forEach {
                try $0.validate(name: "\(name).principal[]")
            }
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case condition = "condition"
            case effect = "effect"
            case principal = "principal"
            case statementId = "statementId"
        }
    }

    public struct CreateResourcePolicyStatementResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String?
        /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
        public let revisionId: String?

        @inlinable
        public init(resourceArn: String? = nil, revisionId: String? = nil) {
            self.resourceArn = resourceArn
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case revisionId = "revisionId"
        }
    }

    public struct CreateSlotRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the slot.
        public let botId: String
        /// The version of the bot associated with the slot.
        public let botVersion: String
        /// A description of the slot. Use this to help identify the slot in lists.
        public let description: String?
        /// The identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale that the slot will be used in. The string must match one of the supported locales. All of the bots, intents, slot types used by the slot must have the same locale. For more information, see Supported languages.
        public let localeId: String
        /// Indicates whether the slot returns multiple values in one response. Multi-value slots are only available in the en-US locale.  If you set this value to true in any other locale, Amazon Lex throws a ValidationException.  If the multipleValuesSetting is not set, the default value is false.
        public let multipleValuesSetting: MultipleValuesSetting?
        /// Determines how slot values are used in Amazon CloudWatch logs. If the value of the obfuscationSetting parameter is DefaultObfuscation, slot values are obfuscated in the log output. If the value is None, the actual value is present in the log output. The default is to obfuscate values in the CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The name of the slot. Slot names must be unique within the bot that contains the slot.
        public let slotName: String
        /// The unique identifier for the slot type associated with this slot. The slot type determines the values that can be entered into the slot.
        public let slotTypeId: String?
        /// Specifications for the constituent sub slots and the   expression for the composite slot.
        public let subSlotSetting: SubSlotSetting?
        /// Specifies prompts that Amazon Lex sends to the user to elicit a response that provides the value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting

        @inlinable
        public init(botId: String, botVersion: String, description: String? = nil, intentId: String, localeId: String, multipleValuesSetting: MultipleValuesSetting? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotName: String, slotTypeId: String? = nil, subSlotSetting: SubSlotSetting? = nil, valueElicitationSetting: SlotValueElicitationSetting) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.intentId = intentId
            self.localeId = localeId
            self.multipleValuesSetting = multipleValuesSetting
            self.obfuscationSetting = obfuscationSetting
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.subSlotSetting = subSlotSetting
            self.valueElicitationSetting = valueElicitationSetting
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.intentId, key: "intentId")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.multipleValuesSetting, forKey: .multipleValuesSetting)
            try container.encodeIfPresent(self.obfuscationSetting, forKey: .obfuscationSetting)
            try container.encode(self.slotName, forKey: .slotName)
            try container.encodeIfPresent(self.slotTypeId, forKey: .slotTypeId)
            try container.encodeIfPresent(self.subSlotSetting, forKey: .subSlotSetting)
            try container.encode(self.valueElicitationSetting, forKey: .valueElicitationSetting)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotName, name: "slotName", parent: name, max: 100)
            try self.validate(self.slotName, name: "slotName", parent: name, min: 1)
            try self.validate(self.slotName, name: "slotName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 25)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 1)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^((AMAZON\\.)[a-zA-Z_]+?|[0-9a-zA-Z]+)$")
            try self.subSlotSetting?.validate(name: "\(name).subSlotSetting")
            try self.valueElicitationSetting.validate(name: "\(name).valueElicitationSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case multipleValuesSetting = "multipleValuesSetting"
            case obfuscationSetting = "obfuscationSetting"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case subSlotSetting = "subSlotSetting"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct CreateSlotResponse: AWSDecodableShape {
        /// The unique identifier of the bot associated with the slot.
        public let botId: String?
        /// The version of the bot associated with the slot.
        public let botVersion: String?
        /// The timestamp of the date and time that the slot was created.
        public let creationDateTime: Date?
        /// The description associated with the slot.
        public let description: String?
        /// The unique identifier of the intent associated with the slot.
        public let intentId: String?
        /// The language and local specified for the slot.
        public let localeId: String?
        /// Indicates whether the slot returns multiple values in one response.
        public let multipleValuesSetting: MultipleValuesSetting?
        /// Indicates whether the slot is configured to obfuscate values in Amazon CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier associated with the slot. Use this to identify the slot when you update or delete it.
        public let slotId: String?
        /// The name specified for the slot.
        public let slotName: String?
        /// The unique identifier of the slot type associated with this slot.
        public let slotTypeId: String?
        /// Specifications for the constituent sub slots and the   expression for the composite slot.
        public let subSlotSetting: SubSlotSetting?
        /// The value elicitation settings specified for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, intentId: String? = nil, localeId: String? = nil, multipleValuesSetting: MultipleValuesSetting? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, subSlotSetting: SubSlotSetting? = nil, valueElicitationSetting: SlotValueElicitationSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.intentId = intentId
            self.localeId = localeId
            self.multipleValuesSetting = multipleValuesSetting
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.subSlotSetting = subSlotSetting
            self.valueElicitationSetting = valueElicitationSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case intentId = "intentId"
            case localeId = "localeId"
            case multipleValuesSetting = "multipleValuesSetting"
            case obfuscationSetting = "obfuscationSetting"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case subSlotSetting = "subSlotSetting"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct CreateSlotTypeRequest: AWSEncodableShape {
        /// The identifier of the bot associated with this slot type.
        public let botId: String
        /// The identifier of the bot version associated with this slot type.
        public let botVersion: String
        /// Specifications for a composite slot type.
        public let compositeSlotTypeSetting: CompositeSlotTypeSetting?
        /// A description of the slot type. Use the description to help identify the slot type in lists.
        public let description: String?
        /// Sets the type of external information used to create the slot type.
        public let externalSourceSetting: ExternalSourceSetting?
        /// The identifier of the language and locale that the slot type will be used in. The string must match one of the supported locales. All of the bots, intents, and slots used by the slot type must have the same locale. For more information, see Supported languages.
        public let localeId: String
        /// The built-in slot type used as a parent of this slot type. When you define a parent slot type, the new slot type has the configuration of the parent slot type. Only AMAZON.AlphaNumeric is supported.
        public let parentSlotTypeSignature: String?
        /// The name for the slot. A slot type name must be unique within the intent.
        public let slotTypeName: String
        /// A list of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for a slot.
        public let slotTypeValues: [SlotTypeValue]?
        /// Determines the strategy that Amazon Lex uses to select a value from the list of possible values. The field can be set to one of the following values:    ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to the slot value.    TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list. If there is no resolution list, return null.   If you don't specify the valueSelectionSetting parameter, the default is ORIGINAL_VALUE.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        @inlinable
        public init(botId: String, botVersion: String, compositeSlotTypeSetting: CompositeSlotTypeSetting? = nil, description: String? = nil, externalSourceSetting: ExternalSourceSetting? = nil, localeId: String, parentSlotTypeSignature: String? = nil, slotTypeName: String, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.compositeSlotTypeSetting = compositeSlotTypeSetting
            self.description = description
            self.externalSourceSetting = externalSourceSetting
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.compositeSlotTypeSetting, forKey: .compositeSlotTypeSetting)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.externalSourceSetting, forKey: .externalSourceSetting)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
            try container.encode(self.slotTypeName, forKey: .slotTypeName)
            try container.encodeIfPresent(self.slotTypeValues, forKey: .slotTypeValues)
            try container.encodeIfPresent(self.valueSelectionSetting, forKey: .valueSelectionSetting)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.compositeSlotTypeSetting?.validate(name: "\(name).compositeSlotTypeSetting")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.externalSourceSetting?.validate(name: "\(name).externalSourceSetting")
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, max: 100)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, min: 1)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.slotTypeValues?.forEach {
                try $0.validate(name: "\(name).slotTypeValues[]")
            }
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, max: 10000)
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, min: 1)
            try self.valueSelectionSetting?.validate(name: "\(name).valueSelectionSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case compositeSlotTypeSetting = "compositeSlotTypeSetting"
            case description = "description"
            case externalSourceSetting = "externalSourceSetting"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct CreateSlotTypeResponse: AWSDecodableShape {
        /// The identifier for the bot associated with the slot type.
        public let botId: String?
        /// The version of the bot associated with the slot type.
        public let botVersion: String?
        /// Specifications for a composite slot type.
        public let compositeSlotTypeSetting: CompositeSlotTypeSetting?
        /// A timestamp of the date and time that the slot type was created.
        public let creationDateTime: Date?
        /// The description specified for the slot type.
        public let description: String?
        /// The type of external information used to create the slot type.
        public let externalSourceSetting: ExternalSourceSetting?
        /// The specified language and local specified for the slot type.
        public let localeId: String?
        /// The signature of the base slot type specified for the slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier assigned to the slot type. Use this to identify the slot type in the UpdateSlotType and DeleteSlotType operations.
        public let slotTypeId: String?
        /// The name specified for the slot type.
        public let slotTypeName: String?
        /// The list of values that the slot type can assume.
        public let slotTypeValues: [SlotTypeValue]?
        /// The strategy that Amazon Lex uses to select a value from the list of possible values.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, compositeSlotTypeSetting: CompositeSlotTypeSetting? = nil, creationDateTime: Date? = nil, description: String? = nil, externalSourceSetting: ExternalSourceSetting? = nil, localeId: String? = nil, parentSlotTypeSignature: String? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.compositeSlotTypeSetting = compositeSlotTypeSetting
            self.creationDateTime = creationDateTime
            self.description = description
            self.externalSourceSetting = externalSourceSetting
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case compositeSlotTypeSetting = "compositeSlotTypeSetting"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case externalSourceSetting = "externalSourceSetting"
            case localeId = "localeId"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct CreateTestSetDiscrepancyReportRequest: AWSEncodableShape {
        /// The target bot for the test set discrepancy report.
        public let target: TestSetDiscrepancyReportResourceTarget
        /// The test set Id for the test set discrepancy report.
        public let testSetId: String

        @inlinable
        public init(target: TestSetDiscrepancyReportResourceTarget, testSetId: String) {
            self.target = target
            self.testSetId = testSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.target, forKey: .target)
            request.encodePath(self.testSetId, key: "testSetId")
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
            try self.validate(self.testSetId, name: "testSetId", parent: name, max: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, min: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case target = "target"
        }
    }

    public struct CreateTestSetDiscrepancyReportResponse: AWSDecodableShape {
        /// The creation date and time for the test set discrepancy report.
        public let creationDateTime: Date?
        /// The target bot for the test set discrepancy report.
        public let target: TestSetDiscrepancyReportResourceTarget?
        /// The unique identifier of the test set discrepancy report to describe.
        public let testSetDiscrepancyReportId: String?
        /// The test set Id for the test set discrepancy report.
        public let testSetId: String?

        @inlinable
        public init(creationDateTime: Date? = nil, target: TestSetDiscrepancyReportResourceTarget? = nil, testSetDiscrepancyReportId: String? = nil, testSetId: String? = nil) {
            self.creationDateTime = creationDateTime
            self.target = target
            self.testSetDiscrepancyReportId = testSetDiscrepancyReportId
            self.testSetId = testSetId
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case target = "target"
            case testSetDiscrepancyReportId = "testSetDiscrepancyReportId"
            case testSetId = "testSetId"
        }
    }

    public struct CreateUploadUrlRequest: AWSEncodableShape {
        public init() {}
    }

    public struct CreateUploadUrlResponse: AWSDecodableShape {
        /// An identifier for a unique import job. Use it when you call the StartImport operation.
        public let importId: String?
        /// A pre-signed S3 write URL. Upload the zip archive file that contains the definition of your bot or bot locale.
        public let uploadUrl: String?

        @inlinable
        public init(importId: String? = nil, uploadUrl: String? = nil) {
            self.importId = importId
            self.uploadUrl = uploadUrl
        }

        private enum CodingKeys: String, CodingKey {
            case importId = "importId"
            case uploadUrl = "uploadUrl"
        }
    }

    public struct CustomPayload: AWSEncodableShape & AWSDecodableShape {
        /// The string that is sent to your application.
        public let value: String

        @inlinable
        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct CustomVocabularyEntryId: AWSEncodableShape {
        /// The unique item identifier for the custom vocabulary items.
        public let itemId: String

        @inlinable
        public init(itemId: String) {
            self.itemId = itemId
        }

        public func validate(name: String) throws {
            try self.validate(self.itemId, name: "itemId", parent: name, max: 32)
            try self.validate(self.itemId, name: "itemId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case itemId = "itemId"
        }
    }

    public struct CustomVocabularyExportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the bot that contains the custom vocabulary to export.
        public let botId: String
        /// The version of the bot that contains the custom vocabulary to export.
        public let botVersion: String
        /// The locale of the bot that contains the custom vocabulary to export.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case localeId = "localeId"
        }
    }

    public struct CustomVocabularyImportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the bot to import the custom vocabulary to.
        public let botId: String
        /// The version of the bot to import the custom vocabulary to.
        public let botVersion: String
        /// The identifier of the local to import the custom vocabulary to. The value must be en_GB.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case localeId = "localeId"
        }
    }

    public struct CustomVocabularyItem: AWSEncodableShape & AWSDecodableShape {
        /// The DisplayAs value for the custom vocabulary item  from the custom vocabulary list.
        public let displayAs: String?
        /// The unique item identifer for the custom vocabulary item  from the custom vocabulary list.
        public let itemId: String
        /// The unique phrase for the custom vocabulary item  from the custom vocabulary list.
        public let phrase: String
        /// The weight assigned for the custom vocabulary item  from the custom vocabulary list.
        public let weight: Int?

        @inlinable
        public init(displayAs: String? = nil, itemId: String, phrase: String, weight: Int? = nil) {
            self.displayAs = displayAs
            self.itemId = itemId
            self.phrase = phrase
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.displayAs, name: "displayAs", parent: name, max: 100)
            try self.validate(self.displayAs, name: "displayAs", parent: name, min: 1)
            try self.validate(self.itemId, name: "itemId", parent: name, max: 32)
            try self.validate(self.itemId, name: "itemId", parent: name, min: 1)
            try self.validate(self.phrase, name: "phrase", parent: name, max: 100)
            try self.validate(self.phrase, name: "phrase", parent: name, min: 1)
            try self.validate(self.weight, name: "weight", parent: name, max: 3)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case displayAs = "displayAs"
            case itemId = "itemId"
            case phrase = "phrase"
            case weight = "weight"
        }
    }

    public struct DTMFSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The DTMF character that clears the accumulated DTMF digits and immediately ends  the input.
        public let deletionCharacter: String
        /// The DTMF character that immediately ends input. If the user does not press this  character, the input ends after the end timeout.
        public let endCharacter: String
        /// How long the bot should wait after the last DTMF character input before assuming  that the input has concluded.
        public let endTimeoutMs: Int
        /// The maximum number of DTMF digits allowed in an utterance.
        public let maxLength: Int

        @inlinable
        public init(deletionCharacter: String, endCharacter: String, endTimeoutMs: Int, maxLength: Int) {
            self.deletionCharacter = deletionCharacter
            self.endCharacter = endCharacter
            self.endTimeoutMs = endTimeoutMs
            self.maxLength = maxLength
        }

        public func validate(name: String) throws {
            try self.validate(self.deletionCharacter, name: "deletionCharacter", parent: name, pattern: "^[A-D0-9#*]{1}$")
            try self.validate(self.endCharacter, name: "endCharacter", parent: name, pattern: "^[A-D0-9#*]{1}$")
            try self.validate(self.endTimeoutMs, name: "endTimeoutMs", parent: name, min: 1)
            try self.validate(self.maxLength, name: "maxLength", parent: name, max: 1024)
            try self.validate(self.maxLength, name: "maxLength", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deletionCharacter = "deletionCharacter"
            case endCharacter = "endCharacter"
            case endTimeoutMs = "endTimeoutMs"
            case maxLength = "maxLength"
        }
    }

    public struct DataPrivacy: AWSEncodableShape & AWSDecodableShape {
        /// For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying true or false in the childDirected field. By specifying true in the childDirected field, you confirm that your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. By specifying false in the childDirected field, you confirm that your use of Amazon Lex is not related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. You may not specify a default value for the childDirected field that does not accurately reflect whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. If your use of Amazon Lex relates to a website, program, or other application that is directed in whole or in part, to children under age 13, you must obtain any required verifiable parental consent under COPPA. For information regarding the use of Amazon Lex in connection with websites, programs, or other applications that are directed or targeted, in whole or in part, to children under age 13, see the Amazon Lex FAQ.
        public let childDirected: Bool

        @inlinable
        public init(childDirected: Bool) {
            self.childDirected = childDirected
        }

        private enum CodingKeys: String, CodingKey {
            case childDirected = "childDirected"
        }
    }

    public struct DataSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains details about the configuration of the Amazon Bedrock knowledge base used for the AMAZON.QnAIntent. To set up a knowledge base, follow the steps at Building a knowledge base.
        public let bedrockKnowledgeStoreConfiguration: BedrockKnowledgeStoreConfiguration?
        /// Contains details about the configuration of the Amazon Kendra index used for the AMAZON.QnAIntent. To create a Amazon Kendra index, follow the steps at Creating an index.
        public let kendraConfiguration: QnAKendraConfiguration?
        /// Contains details about the configuration of the Amazon OpenSearch Service database used for the AMAZON.QnAIntent. To create a domain, follow the steps at Creating and managing Amazon OpenSearch Service domains.
        public let opensearchConfiguration: OpensearchConfiguration?

        @inlinable
        public init(bedrockKnowledgeStoreConfiguration: BedrockKnowledgeStoreConfiguration? = nil, kendraConfiguration: QnAKendraConfiguration? = nil, opensearchConfiguration: OpensearchConfiguration? = nil) {
            self.bedrockKnowledgeStoreConfiguration = bedrockKnowledgeStoreConfiguration
            self.kendraConfiguration = kendraConfiguration
            self.opensearchConfiguration = opensearchConfiguration
        }

        public func validate(name: String) throws {
            try self.bedrockKnowledgeStoreConfiguration?.validate(name: "\(name).bedrockKnowledgeStoreConfiguration")
            try self.kendraConfiguration?.validate(name: "\(name).kendraConfiguration")
            try self.opensearchConfiguration?.validate(name: "\(name).opensearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockKnowledgeStoreConfiguration = "bedrockKnowledgeStoreConfiguration"
            case kendraConfiguration = "kendraConfiguration"
            case opensearchConfiguration = "opensearchConfiguration"
        }
    }

    public struct DateRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// A timestamp indicating the end date for the date range filter.
        public let endDateTime: Date
        /// A timestamp indicating the start date for the date range filter.
        public let startDateTime: Date

        @inlinable
        public init(endDateTime: Date, startDateTime: Date) {
            self.endDateTime = endDateTime
            self.startDateTime = startDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case endDateTime = "endDateTime"
            case startDateTime = "startDateTime"
        }
    }

    public struct DefaultConditionalBranch: AWSEncodableShape & AWSDecodableShape {
        /// The next step in the conversation.
        public let nextStep: DialogState?
        public let response: ResponseSpecification?

        @inlinable
        public init(nextStep: DialogState? = nil, response: ResponseSpecification? = nil) {
            self.nextStep = nextStep
            self.response = response
        }

        public func validate(name: String) throws {
            try self.nextStep?.validate(name: "\(name).nextStep")
            try self.response?.validate(name: "\(name).response")
        }

        private enum CodingKeys: String, CodingKey {
            case nextStep = "nextStep"
            case response = "response"
        }
    }

    public struct DeleteBotAliasRequest: AWSEncodableShape {
        /// The unique identifier of the bot alias to delete.
        public let botAliasId: String
        /// The unique identifier of the bot associated with the alias to delete.
        public let botId: String
        /// By default, Amazon Lex checks if any other resource, such as a bot network,  is using the bot alias before it is deleted and throws a  ResourceInUseException exception if the alias is  being used by another resource. Set this parameter to true to skip this check and remove the alias even if it is being used by  another resource.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(botAliasId: String, botId: String, skipResourceInUseCheck: Bool? = nil) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotAliasResponse: AWSDecodableShape {
        /// The unique identifier of the bot alias to delete.
        public let botAliasId: String?
        /// The current status of the alias. The status is Deleting while the alias is in the process of being deleted. Once the alias is deleted, it will no longer appear in the list of aliases returned by the ListBotAliases operation.
        public let botAliasStatus: BotAliasStatus?
        /// The unique identifier of the bot that contains the alias to delete.
        public let botId: String?

        @inlinable
        public init(botAliasId: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil) {
            self.botAliasId = botAliasId
            self.botAliasStatus = botAliasStatus
            self.botId = botId
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
        }
    }

    public struct DeleteBotLocaleRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the locale.
        public let botId: String
        /// The version of the bot that contains the locale.
        public let botVersion: String
        /// The identifier of the language and locale that will be deleted. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotLocaleResponse: AWSDecodableShape {
        /// The identifier of the bot that contained the deleted locale.
        public let botId: String?
        /// The status of deleting the bot locale. The locale first enters the Deleting status. Once the locale is deleted it no longer appears in the list of locales for the bot.
        public let botLocaleStatus: BotLocaleStatus?
        /// The version of the bot that contained the deleted locale.
        public let botVersion: String?
        /// The language and locale of the deleted locale.
        public let localeId: String?

        @inlinable
        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case localeId = "localeId"
        }
    }

    public struct DeleteBotReplicaRequest: AWSEncodableShape {
        /// The unique ID of the replicated bot to be deleted from the secondary region
        public let botId: String
        /// The secondary region of the replicated bot that will be deleted.
        public let replicaRegion: String

        @inlinable
        public init(botId: String, replicaRegion: String) {
            self.botId = botId
            self.replicaRegion = replicaRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.replicaRegion, key: "replicaRegion")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, max: 25)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, min: 2)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotReplicaResponse: AWSDecodableShape {
        /// The unique bot ID of the replicated bot generated.
        public let botId: String?
        /// The operational status of the replicated bot generated.
        public let botReplicaStatus: BotReplicaStatus?
        /// The region of the replicated bot generated.
        public let replicaRegion: String?

        @inlinable
        public init(botId: String? = nil, botReplicaStatus: BotReplicaStatus? = nil, replicaRegion: String? = nil) {
            self.botId = botId
            self.botReplicaStatus = botReplicaStatus
            self.replicaRegion = replicaRegion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botReplicaStatus = "botReplicaStatus"
            case replicaRegion = "replicaRegion"
        }
    }

    public struct DeleteBotRequest: AWSEncodableShape {
        /// The identifier of the bot to delete.
        public let botId: String
        /// By default, Amazon Lex checks if any other resource, such as an alias or  bot network, is using the bot version before it is deleted and throws a  ResourceInUseException exception if the bot is  being used by another resource. Set this parameter to true to skip this check and remove the bot even if it is being used by  another resource.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(botId: String, skipResourceInUseCheck: Bool? = nil) {
            self.botId = botId
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotResponse: AWSDecodableShape {
        /// The unique identifier of the bot that Amazon Lex is deleting.
        public let botId: String?
        /// The current status of the bot. The status is Deleting while the bot and its associated resources are being deleted.
        public let botStatus: BotStatus?

        @inlinable
        public init(botId: String? = nil, botStatus: BotStatus? = nil) {
            self.botId = botId
            self.botStatus = botStatus
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botStatus = "botStatus"
        }
    }

    public struct DeleteBotVersionRequest: AWSEncodableShape {
        /// The identifier of the bot that contains the version.
        public let botId: String
        /// The version of the bot to delete.
        public let botVersion: String
        /// By default, Amazon Lex checks if any other resource, such as an alias or bot network,  is using the bot version before it is deleted and throws a  ResourceInUseException exception if the version is  being used by another resource. Set this parameter to true to skip this check and remove the version even if it is being used by  another resource.
        public let skipResourceInUseCheck: Bool?

        @inlinable
        public init(botId: String, botVersion: String, skipResourceInUseCheck: Bool? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.skipResourceInUseCheck = skipResourceInUseCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBotVersionResponse: AWSDecodableShape {
        /// The identifier of the bot that is being deleted.
        public let botId: String?
        /// The current status of the bot.
        public let botStatus: BotStatus?
        /// The version of the bot that is being deleted.
        public let botVersion: String?

        @inlinable
        public init(botId: String? = nil, botStatus: BotStatus? = nil, botVersion: String? = nil) {
            self.botId = botId
            self.botStatus = botStatus
            self.botVersion = botVersion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botStatus = "botStatus"
            case botVersion = "botVersion"
        }
    }

    public struct DeleteCustomVocabularyRequest: AWSEncodableShape {
        /// The unique identifier of the bot to remove the custom vocabulary from.
        public let botId: String
        /// The version of the bot to remove the custom vocabulary from.
        public let botVersion: String
        /// The locale identifier for the locale that contains the custom vocabulary to remove.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomVocabularyResponse: AWSDecodableShape {
        /// The identifier of the bot that the custom vocabulary was removed from.
        public let botId: String?
        /// The version of the bot that the custom vocabulary was removed from.
        public let botVersion: String?
        /// The status of removing the custom vocabulary.
        public let customVocabularyStatus: CustomVocabularyStatus?
        /// The locale identifier for the locale that the custom vocabulary was removed from.
        public let localeId: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, customVocabularyStatus: CustomVocabularyStatus? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.customVocabularyStatus = customVocabularyStatus
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case customVocabularyStatus = "customVocabularyStatus"
            case localeId = "localeId"
        }
    }

    public struct DeleteExportRequest: AWSEncodableShape {
        /// The unique identifier of the export to delete.
        public let exportId: String

        @inlinable
        public init(exportId: String) {
            self.exportId = exportId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.exportId, key: "exportId")
        }

        public func validate(name: String) throws {
            try self.validate(self.exportId, name: "exportId", parent: name, max: 10)
            try self.validate(self.exportId, name: "exportId", parent: name, min: 10)
            try self.validate(self.exportId, name: "exportId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteExportResponse: AWSDecodableShape {
        /// The unique identifier of the deleted export.
        public let exportId: String?
        /// The current status of the deletion. When the deletion is complete, the export will no longer be returned by the ListExports operation and calls to the  DescribeExport operation with the export identifier will fail.
        public let exportStatus: ExportStatus?

        @inlinable
        public init(exportId: String? = nil, exportStatus: ExportStatus? = nil) {
            self.exportId = exportId
            self.exportStatus = exportStatus
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "exportId"
            case exportStatus = "exportStatus"
        }
    }

    public struct DeleteImportRequest: AWSEncodableShape {
        /// The unique identifier of the import to delete.
        public let importId: String

        @inlinable
        public init(importId: String) {
            self.importId = importId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importId, key: "importId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importId, name: "importId", parent: name, max: 10)
            try self.validate(self.importId, name: "importId", parent: name, min: 10)
            try self.validate(self.importId, name: "importId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImportResponse: AWSDecodableShape {
        /// The unique identifier of the deleted import.
        public let importId: String?
        /// The current status of the deletion. When the deletion is complete, the import will no longer be returned by the ListImports operation and calls to the DescribeImport operation with the import identifier will fail.
        public let importStatus: ImportStatus?

        @inlinable
        public init(importId: String? = nil, importStatus: ImportStatus? = nil) {
            self.importId = importId
            self.importStatus = importStatus
        }

        private enum CodingKeys: String, CodingKey {
            case importId = "importId"
            case importStatus = "importStatus"
        }
    }

    public struct DeleteIntentRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the intent.
        public let botId: String
        /// The version of the bot associated with the intent.
        public let botVersion: String
        /// The unique identifier of the intent to delete.
        public let intentId: String
        /// The identifier of the language and locale where the bot will be deleted. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, intentId: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.intentId, key: "intentId")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The identifier of the revision to edit. If this ID doesn't match the current revision number, Amazon Lex returns an exception If you don't specify a revision ID, Amazon Lex will delete the current policy.
        public let expectedRevisionId: String?
        /// The Amazon Resource Name (ARN) of the bot or bot alias that has the resource policy attached.
        public let resourceArn: String

        @inlinable
        public init(expectedRevisionId: String? = nil, resourceArn: String) {
            self.expectedRevisionId = expectedRevisionId
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.expectedRevisionId, key: "expectedRevisionId")
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, max: 5)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, min: 1)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy was deleted from.
        public let resourceArn: String?
        /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
        public let revisionId: String?

        @inlinable
        public init(resourceArn: String? = nil, revisionId: String? = nil) {
            self.resourceArn = resourceArn
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case revisionId = "revisionId"
        }
    }

    public struct DeleteResourcePolicyStatementRequest: AWSEncodableShape {
        /// The identifier of the revision of the policy to delete the statement from. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex removes the current contents of the statement.
        public let expectedRevisionId: String?
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String
        /// The name of the statement (SID) to delete from the policy.
        public let statementId: String

        @inlinable
        public init(expectedRevisionId: String? = nil, resourceArn: String, statementId: String) {
            self.expectedRevisionId = expectedRevisionId
            self.resourceArn = resourceArn
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.expectedRevisionId, key: "expectedRevisionId")
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodePath(self.statementId, key: "statementId")
        }

        public func validate(name: String) throws {
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, max: 5)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, min: 1)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyStatementResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy statement was removed from.
        public let resourceArn: String?
        /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
        public let revisionId: String?

        @inlinable
        public init(resourceArn: String? = nil, revisionId: String? = nil) {
            self.resourceArn = resourceArn
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case revisionId = "revisionId"
        }
    }

    public struct DeleteSlotRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the slot to delete.
        public let botId: String
        /// The version of the bot associated with the slot to delete.
        public let botVersion: String
        /// The identifier of the intent associated with the slot.
        public let intentId: String
        /// The identifier of the language and locale that the slot will be deleted from. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The identifier of the slot to delete.
        public let slotId: String

        @inlinable
        public init(botId: String, botVersion: String, intentId: String, localeId: String, slotId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
            self.slotId = slotId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.intentId, key: "intentId")
            request.encodePath(self.localeId, key: "localeId")
            request.encodePath(self.slotId, key: "slotId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSlotTypeRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the slot type.
        public let botId: String
        /// The version of the bot associated with the slot type.
        public let botVersion: String
        /// The identifier of the language and locale that the slot type will be deleted from. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// By default, the DeleteSlotType operations throws a ResourceInUseException exception if you try to delete a slot type used by a slot. Set the skipResourceInUseCheck parameter to true to skip this check and remove the slot type even if a slot uses it.
        public let skipResourceInUseCheck: Bool?
        /// The identifier of the slot type to delete.
        public let slotTypeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String, skipResourceInUseCheck: Bool? = nil, slotTypeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.skipResourceInUseCheck = skipResourceInUseCheck
            self.slotTypeId = slotTypeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
            request.encodeQuery(self.skipResourceInUseCheck, key: "skipResourceInUseCheck")
            request.encodePath(self.slotTypeId, key: "slotTypeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTestSetRequest: AWSEncodableShape {
        /// The test set Id of the test set to be deleted.
        public let testSetId: String

        @inlinable
        public init(testSetId: String) {
            self.testSetId = testSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testSetId, key: "testSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testSetId, name: "testSetId", parent: name, max: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, min: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUtterancesRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the utterances.
        public let botId: String
        /// The identifier of the language and locale where the utterances were collected. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String?
        /// The unique identifier of the session with the user. The ID is returned in the response from the RecognizeText and RecognizeUtterance operations.
        public let sessionId: String?

        @inlinable
        public init(botId: String, localeId: String? = nil, sessionId: String? = nil) {
            self.botId = botId
            self.localeId = localeId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodeQuery(self.localeId, key: "localeId")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 2)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z._:-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUtterancesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeBotAliasRequest: AWSEncodableShape {
        /// The identifier of the bot alias to describe.
        public let botAliasId: String
        /// The identifier of the bot associated with the bot alias to describe.
        public let botId: String

        @inlinable
        public init(botAliasId: String, botId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botAliasId, key: "botAliasId")
            request.encodePath(self.botId, key: "botId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotAliasResponse: AWSDecodableShape {
        /// A list of events that affect a bot alias. For example, an event is recorded when the version that the alias points to changes.
        public let botAliasHistoryEvents: [BotAliasHistoryEvent]?
        /// The identifier of the bot alias.
        public let botAliasId: String?
        /// The locale settings that are unique to the alias.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The name of the bot alias.
        public let botAliasName: String?
        /// The current status of the alias. When the alias is Available, the alias is ready for use with your bot.
        public let botAliasStatus: BotAliasStatus?
        /// The identifier of the bot associated with the bot alias.
        public let botId: String?
        /// The version of the bot associated with the bot alias.
        public let botVersion: String?
        /// Specifics of how Amazon Lex logs text and audio conversations with the bot associated with the alias.
        public let conversationLogSettings: ConversationLogSettings?
        /// A timestamp of the date and time that the alias was created.
        public let creationDateTime: Date?
        /// The description of the bot alias.
        public let description: String?
        /// A timestamp of the date and time that the alias was last updated.
        public let lastUpdatedDateTime: Date?
        /// A list of the networks to which the bot alias you described belongs.
        public let parentBotNetworks: [ParentBotNetwork]?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?

        @inlinable
        public init(botAliasHistoryEvents: [BotAliasHistoryEvent]? = nil, botAliasId: String? = nil, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, parentBotNetworks: [ParentBotNetwork]? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil) {
            self.botAliasHistoryEvents = botAliasHistoryEvents
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.parentBotNetworks = parentBotNetworks
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasHistoryEvents = "botAliasHistoryEvents"
            case botAliasId = "botAliasId"
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case parentBotNetworks = "parentBotNetworks"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
        }
    }

    public struct DescribeBotLocaleRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the locale.
        public let botId: String
        /// The version of the bot associated with the locale.
        public let botVersion: String
        /// The unique identifier of the locale to describe. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotLocaleResponse: AWSDecodableShape {
        /// The identifier of the bot associated with the locale.
        public let botId: String?
        /// History of changes, such as when a locale is used in an alias, that have taken place for the locale.
        public let botLocaleHistoryEvents: [BotLocaleHistoryEvent]?
        /// The status of the bot. If the status is Failed, the reasons for the failure are listed in the failureReasons field.
        public let botLocaleStatus: BotLocaleStatus?
        /// The version of the bot associated with the locale.
        public let botVersion: String?
        /// The date and time that the locale was created.
        public let creationDateTime: Date?
        /// The description of the locale.
        public let description: String?
        /// if botLocaleStatus is Failed, Amazon Lex explains why it failed to build the bot.
        public let failureReasons: [String]?
        /// Contains settings for Amazon Bedrock's generative AI features for your bot locale.
        public let generativeAISettings: GenerativeAISettings?
        /// The number of intents defined for the locale.
        public let intentsCount: Int?
        /// The date and time that the locale was last submitted for building.
        public let lastBuildSubmittedDateTime: Date?
        /// The date and time that the locale was last updated.
        public let lastUpdatedDateTime: Date?
        /// The unique identifier of the described locale.
        public let localeId: String?
        /// The name of the locale.
        public let localeName: String?
        /// The confidence threshold where Amazon Lex inserts the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
        public let nluIntentConfidenceThreshold: Double?
        /// Recommended actions to take to resolve an error in the failureReasons field.
        public let recommendedActions: [String]?
        /// The number of slot types defined for the locale.
        public let slotTypesCount: Int?
        /// The Amazon Polly voice Amazon Lex uses for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        @inlinable
        public init(botId: String? = nil, botLocaleHistoryEvents: [BotLocaleHistoryEvent]? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, failureReasons: [String]? = nil, generativeAISettings: GenerativeAISettings? = nil, intentsCount: Int? = nil, lastBuildSubmittedDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, localeName: String? = nil, nluIntentConfidenceThreshold: Double? = nil, recommendedActions: [String]? = nil, slotTypesCount: Int? = nil, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botLocaleHistoryEvents = botLocaleHistoryEvents
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.failureReasons = failureReasons
            self.generativeAISettings = generativeAISettings
            self.intentsCount = intentsCount
            self.lastBuildSubmittedDateTime = lastBuildSubmittedDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.localeName = localeName
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.recommendedActions = recommendedActions
            self.slotTypesCount = slotTypesCount
            self.voiceSettings = voiceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleHistoryEvents = "botLocaleHistoryEvents"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case failureReasons = "failureReasons"
            case generativeAISettings = "generativeAISettings"
            case intentsCount = "intentsCount"
            case lastBuildSubmittedDateTime = "lastBuildSubmittedDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case localeName = "localeName"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case recommendedActions = "recommendedActions"
            case slotTypesCount = "slotTypesCount"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct DescribeBotRecommendationRequest: AWSEncodableShape {
        /// The unique identifier of the bot associated with the bot recommendation.
        public let botId: String
        /// The identifier of the bot recommendation to describe.
        public let botRecommendationId: String
        /// The version of the bot associated with the bot recommendation.
        public let botVersion: String
        /// The identifier of the language and locale of the bot recommendation to describe. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String

        @inlinable
        public init(botId: String, botRecommendationId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botRecommendationId, key: "botRecommendationId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, max: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, min: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotRecommendationResponse: AWSDecodableShape {
        /// The identifier of the bot associated with the bot recommendation.
        public let botId: String?
        /// The identifier of the bot recommendation being described.
        public let botRecommendationId: String?
        /// The object representing the URL of the bot definition, the URL of the associated transcript and a statistical summary of the bot recommendation results.
        public let botRecommendationResults: BotRecommendationResults?
        /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
        public let botRecommendationStatus: BotRecommendationStatus?
        /// The version of the bot associated with the bot recommendation.
        public let botVersion: String?
        /// The date and time that the bot recommendation was created.
        public let creationDateTime: Date?
        /// The object representing the passwords that were used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
        public let encryptionSetting: EncryptionSetting?
        /// If botRecommendationStatus is Failed, Amazon Lex explains why.
        public let failureReasons: [String]?
        /// The date and time that the bot recommendation was last updated.
        public let lastUpdatedDateTime: Date?
        /// The identifier of the language and locale of the bot recommendation to describe.
        public let localeId: String?
        /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
        public let transcriptSourceSetting: TranscriptSourceSetting?

        @inlinable
        public init(botId: String? = nil, botRecommendationId: String? = nil, botRecommendationResults: BotRecommendationResults? = nil, botRecommendationStatus: BotRecommendationStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, encryptionSetting: EncryptionSetting? = nil, failureReasons: [String]? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, transcriptSourceSetting: TranscriptSourceSetting? = nil) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botRecommendationResults = botRecommendationResults
            self.botRecommendationStatus = botRecommendationStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.encryptionSetting = encryptionSetting
            self.failureReasons = failureReasons
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.transcriptSourceSetting = transcriptSourceSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botRecommendationId = "botRecommendationId"
            case botRecommendationResults = "botRecommendationResults"
            case botRecommendationStatus = "botRecommendationStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case encryptionSetting = "encryptionSetting"
            case failureReasons = "failureReasons"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case transcriptSourceSetting = "transcriptSourceSetting"
        }
    }

    public struct DescribeBotReplicaRequest: AWSEncodableShape {
        /// The request for the unique bot ID of the replicated bot being monitored.
        public let botId: String
        /// The request for the region of the replicated bot being monitored.
        public let replicaRegion: String

        @inlinable
        public init(botId: String, replicaRegion: String) {
            self.botId = botId
            self.replicaRegion = replicaRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.replicaRegion, key: "replicaRegion")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, max: 25)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, min: 2)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotReplicaResponse: AWSDecodableShape {
        /// The unique bot ID of the replicated bot being monitored.
        public let botId: String?
        /// The operational status of the replicated bot being monitored.
        public let botReplicaStatus: BotReplicaStatus?
        /// The creation date and time of the replicated bot being monitored.
        public let creationDateTime: Date?
        /// The failure reasons the bot being monitored failed to replicate.
        public let failureReasons: [String]?
        /// The region of the replicated bot being monitored.
        public let replicaRegion: String?
        /// The source region of the replicated bot being monitored.
        public let sourceRegion: String?

        @inlinable
        public init(botId: String? = nil, botReplicaStatus: BotReplicaStatus? = nil, creationDateTime: Date? = nil, failureReasons: [String]? = nil, replicaRegion: String? = nil, sourceRegion: String? = nil) {
            self.botId = botId
            self.botReplicaStatus = botReplicaStatus
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
            self.replicaRegion = replicaRegion
            self.sourceRegion = sourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botReplicaStatus = "botReplicaStatus"
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
            case replicaRegion = "replicaRegion"
            case sourceRegion = "sourceRegion"
        }
    }

    public struct DescribeBotRequest: AWSEncodableShape {
        /// The unique identifier of the bot to describe.
        public let botId: String

        @inlinable
        public init(botId: String) {
            self.botId = botId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotResourceGenerationRequest: AWSEncodableShape {
        /// The unique identifier of the bot for which to return the generation details.
        public let botId: String
        /// The version of the bot for which to return the generation details.
        public let botVersion: String
        /// The unique identifier of the generation request for which to  return the generation details.
        public let generationId: String
        /// The locale of the bot for which to return the generation details.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, generationId: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.generationId = generationId
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.generationId, key: "generationId")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.generationId, name: "generationId", parent: name, max: 10)
            try self.validate(self.generationId, name: "generationId", parent: name, min: 10)
            try self.validate(self.generationId, name: "generationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotResourceGenerationResponse: AWSDecodableShape {
        /// The unique identifier of the bot for which the generation request was  made.
        public let botId: String?
        /// The version of the bot for which the generation request was made.
        public let botVersion: String?
        /// The date and time at which the item was generated.
        public let creationDateTime: Date?
        /// A list of reasons why the generation of bot resources through natural language description failed.
        public let failureReasons: [String]?
        /// The Amazon S3 location of the generated bot locale configuration.
        public let generatedBotLocaleUrl: String?
        /// The generation ID for which to return the generation details.
        public let generationId: String?
        /// The prompt used in the generation request.
        public let generationInputPrompt: String?
        /// The status of the generation request.
        public let generationStatus: GenerationStatus?
        /// The date and time at which the generated item was updated.
        public let lastUpdatedDateTime: Date?
        /// The locale of the bot for which the generation request was made.
        public let localeId: String?
        /// The ARN of the model used to generate the bot resources.
        public let modelArn: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, failureReasons: [String]? = nil, generatedBotLocaleUrl: String? = nil, generationId: String? = nil, generationInputPrompt: String? = nil, generationStatus: GenerationStatus? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, modelArn: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
            self.generatedBotLocaleUrl = generatedBotLocaleUrl
            self.generationId = generationId
            self.generationInputPrompt = generationInputPrompt
            self.generationStatus = generationStatus
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.modelArn = modelArn
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
            case generatedBotLocaleUrl = "generatedBotLocaleUrl"
            case generationId = "generationId"
            case generationInputPrompt = "generationInputPrompt"
            case generationStatus = "generationStatus"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case modelArn = "modelArn"
        }
    }

    public struct DescribeBotResponse: AWSDecodableShape {
        /// The unique identifier of the bot.
        public let botId: String?
        /// The list of bots in the network that was described.
        public let botMembers: [BotMember]?
        /// The name of the bot.
        public let botName: String?
        /// The current status of the bot. When the status is Available the bot is ready to be used in conversations with users.
        public let botStatus: BotStatus?
        /// The type of the bot that was described.
        public let botType: BotType?
        /// A timestamp of the date and time that the bot was created.
        public let creationDateTime: Date?
        /// Settings for managing data privacy of the bot and its conversations with users.
        public let dataPrivacy: DataPrivacy?
        /// The description of the bot.
        public let description: String?
        /// Contains the configuration for error logging that specifies where and how bot errors are recorded, including destinations like CloudWatch Logs.
        public let errorLogSettings: ErrorLogSettings?
        /// If the botStatus is Failed, this contains a list of reasons that the bot couldn't be built.
        public let failureReasons: [String]?
        /// The maximum time in seconds that Amazon Lex retains the data gathered in a conversation.
        public let idleSessionTTLInSeconds: Int?
        /// A timestamp of the date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot.
        public let roleArn: String?

        @inlinable
        public init(botId: String? = nil, botMembers: [BotMember]? = nil, botName: String? = nil, botStatus: BotStatus? = nil, botType: BotType? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, errorLogSettings: ErrorLogSettings? = nil, failureReasons: [String]? = nil, idleSessionTTLInSeconds: Int? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil) {
            self.botId = botId
            self.botMembers = botMembers
            self.botName = botName
            self.botStatus = botStatus
            self.botType = botType
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.errorLogSettings = errorLogSettings
            self.failureReasons = failureReasons
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botMembers = "botMembers"
            case botName = "botName"
            case botStatus = "botStatus"
            case botType = "botType"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case errorLogSettings = "errorLogSettings"
            case failureReasons = "failureReasons"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
        }
    }

    public struct DescribeBotVersionRequest: AWSEncodableShape {
        /// The identifier of the bot containing the version to return metadata for.
        public let botId: String
        /// The version of the bot to return metadata for.
        public let botVersion: String

        @inlinable
        public init(botId: String, botVersion: String) {
            self.botId = botId
            self.botVersion = botVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeBotVersionResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the version.
        public let botId: String?
        /// The members of bot network in the version that was described.
        public let botMembers: [BotMember]?
        /// The name of the bot that contains the version.
        public let botName: String?
        /// The current status of the bot. When the status is Available, the bot version is ready for use.
        public let botStatus: BotStatus?
        /// The type of the bot in the version that was described.
        public let botType: BotType?
        /// The version of the bot that was described.
        public let botVersion: String?
        /// A timestamp of the date and time that the bot version was created.
        public let creationDateTime: Date?
        /// Data privacy settings for the bot version.
        public let dataPrivacy: DataPrivacy?
        /// The description specified for the bot.
        public let description: String?
        /// If the botStatus is Failed, this contains a list of reasons that the version couldn't be built.
        public let failureReasons: [String]?
        /// The number of seconds that a session with the bot remains active before it is discarded by Amazon Lex.
        public let idleSessionTTLInSeconds: Int?
        /// A list of the networks to which the bot version you described belongs.
        public let parentBotNetworks: [ParentBotNetwork]?
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the bot version.
        public let roleArn: String?

        @inlinable
        public init(botId: String? = nil, botMembers: [BotMember]? = nil, botName: String? = nil, botStatus: BotStatus? = nil, botType: BotType? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, failureReasons: [String]? = nil, idleSessionTTLInSeconds: Int? = nil, parentBotNetworks: [ParentBotNetwork]? = nil, roleArn: String? = nil) {
            self.botId = botId
            self.botMembers = botMembers
            self.botName = botName
            self.botStatus = botStatus
            self.botType = botType
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.failureReasons = failureReasons
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.parentBotNetworks = parentBotNetworks
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botMembers = "botMembers"
            case botName = "botName"
            case botStatus = "botStatus"
            case botType = "botType"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case failureReasons = "failureReasons"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case parentBotNetworks = "parentBotNetworks"
            case roleArn = "roleArn"
        }
    }

    public struct DescribeCustomVocabularyMetadataRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the custom vocabulary.
        public let botId: String
        /// The bot version of the bot to return metadata for.
        public let botVersion: String
        /// The locale to return the custom vocabulary information for. The locale must be en_GB.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeCustomVocabularyMetadataResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the custom vocabulary.
        public let botId: String?
        /// The version of the bot that contains the custom vocabulary to describe.
        public let botVersion: String?
        /// The date and time that the custom vocabulary was created.
        public let creationDateTime: Date?
        /// The status of the custom vocabulary. If the status is  Ready the custom vocabulary is ready to use.
        public let customVocabularyStatus: CustomVocabularyStatus?
        /// The date and time that the custom vocabulary was last updated.
        public let lastUpdatedDateTime: Date?
        /// The locale that contains the custom vocabulary to describe.
        public let localeId: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, customVocabularyStatus: CustomVocabularyStatus? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.customVocabularyStatus = customVocabularyStatus
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case customVocabularyStatus = "customVocabularyStatus"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
        }
    }

    public struct DescribeExportRequest: AWSEncodableShape {
        /// The unique identifier of the export to describe.
        public let exportId: String

        @inlinable
        public init(exportId: String) {
            self.exportId = exportId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.exportId, key: "exportId")
        }

        public func validate(name: String) throws {
            try self.validate(self.exportId, name: "exportId", parent: name, max: 10)
            try self.validate(self.exportId, name: "exportId", parent: name, min: 10)
            try self.validate(self.exportId, name: "exportId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeExportResponse: AWSDecodableShape {
        /// The date and time that the export was created.
        public let creationDateTime: Date?
        /// A pre-signed S3 URL that points to the bot or bot locale archive. The URL is only available for 5 minutes after calling the DescribeExport operation.
        public let downloadUrl: String?
        /// The unique identifier of the described export.
        public let exportId: String?
        /// The status of the export. When the status is Complete the export archive file is available for download.
        public let exportStatus: ExportStatus?
        /// If the exportStatus is failed, contains one or more reasons why the export could not be completed.
        public let failureReasons: [String]?
        /// The file format used in the files that describe the resource.
        public let fileFormat: ImportExportFileFormat?
        /// The last date and time that the export was updated.
        public let lastUpdatedDateTime: Date?
        /// The bot, bot ID, and optional locale ID of the exported bot or bot locale.
        public let resourceSpecification: ExportResourceSpecification?

        @inlinable
        public init(creationDateTime: Date? = nil, downloadUrl: String? = nil, exportId: String? = nil, exportStatus: ExportStatus? = nil, failureReasons: [String]? = nil, fileFormat: ImportExportFileFormat? = nil, lastUpdatedDateTime: Date? = nil, resourceSpecification: ExportResourceSpecification? = nil) {
            self.creationDateTime = creationDateTime
            self.downloadUrl = downloadUrl
            self.exportId = exportId
            self.exportStatus = exportStatus
            self.failureReasons = failureReasons
            self.fileFormat = fileFormat
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.resourceSpecification = resourceSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case downloadUrl = "downloadUrl"
            case exportId = "exportId"
            case exportStatus = "exportStatus"
            case failureReasons = "failureReasons"
            case fileFormat = "fileFormat"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct DescribeImportRequest: AWSEncodableShape {
        /// The unique identifier of the import to describe.
        public let importId: String

        @inlinable
        public init(importId: String) {
            self.importId = importId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importId, key: "importId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importId, name: "importId", parent: name, max: 10)
            try self.validate(self.importId, name: "importId", parent: name, min: 10)
            try self.validate(self.importId, name: "importId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeImportResponse: AWSDecodableShape {
        /// The date and time that the import was created.
        public let creationDateTime: Date?
        /// If the importStatus field is Failed, this provides one or more reasons for the failure.
        public let failureReasons: [String]?
        /// The unique identifier that Amazon Lex assigned to the resource created by the import.
        public let importedResourceId: String?
        /// The name of the imported resource.
        public let importedResourceName: String?
        /// The unique identifier of the described import.
        public let importId: String?
        /// The status of the import process. When the status is Completed the resource is imported and ready for use.
        public let importStatus: ImportStatus?
        /// The date and time that the import was last updated.
        public let lastUpdatedDateTime: Date?
        /// The strategy used when there was a name conflict between the imported resource and an existing resource. When the merge strategy is FailOnConflict existing resources are not overwritten and the import fails.
        public let mergeStrategy: MergeStrategy?
        /// The specifications of the imported bot, bot locale, or custom vocabulary.
        public let resourceSpecification: ImportResourceSpecification?

        @inlinable
        public init(creationDateTime: Date? = nil, failureReasons: [String]? = nil, importedResourceId: String? = nil, importedResourceName: String? = nil, importId: String? = nil, importStatus: ImportStatus? = nil, lastUpdatedDateTime: Date? = nil, mergeStrategy: MergeStrategy? = nil, resourceSpecification: ImportResourceSpecification? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
            self.importedResourceId = importedResourceId
            self.importedResourceName = importedResourceName
            self.importId = importId
            self.importStatus = importStatus
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.mergeStrategy = mergeStrategy
            self.resourceSpecification = resourceSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
            case importedResourceId = "importedResourceId"
            case importedResourceName = "importedResourceName"
            case importId = "importId"
            case importStatus = "importStatus"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case mergeStrategy = "mergeStrategy"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct DescribeIntentRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the intent.
        public let botId: String
        /// The version of the bot associated with the intent.
        public let botVersion: String
        /// The identifier of the intent to describe.
        public let intentId: String
        /// The identifier of the language and locale of the intent to describe. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, intentId: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.intentId, key: "intentId")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIntentResponse: AWSDecodableShape {
        /// The identifier of the bot associated with the intent.
        public let botId: String?
        /// The version of the bot associated with the intent.
        public let botVersion: String?
        /// A timestamp of the date and time that the intent was created.
        public let creationDateTime: Date?
        /// The description of the intent.
        public let description: String?
        /// The Lambda function called during each turn of a conversation with the intent.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The Lambda function called when the intent is complete and ready for fulfillment.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
        public let initialResponseSetting: InitialResponseSetting?
        /// A list of contexts that must be active for the intent to be considered for sending to the user.
        public let inputContexts: [InputContext]?
        /// The response that Amazon Lex sends to when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// Prompts that Amazon Lex sends to the user to confirm completion of an intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The unique identifier assigned to the intent when it was created.
        public let intentId: String?
        /// The name specified for the intent.
        public let intentName: String?
        /// Configuration information required to use the AMAZON.KendraSearchIntent intent.
        public let kendraConfiguration: KendraConfiguration?
        /// A timestamp of the date and time that the intent was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale specified for the intent.
        public let localeId: String?
        /// A list of contexts that are activated when the intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// The identifier of the built-in intent that this intent is derived from, if any.
        public let parentIntentSignature: String?
        /// Qinconnect intent configuration details for the describe intent response.
        public let qInConnectIntentConfiguration: QInConnectIntentConfiguration?
        /// Details about the configuration of the built-in Amazon.QnAIntent.
        public let qnAIntentConfiguration: QnAIntentConfiguration?
        /// User utterances that trigger this intent.
        public let sampleUtterances: [SampleUtterance]?
        /// The list that determines the priority that slots should be elicited from the user.
        public let slotPriorities: [SlotPriority]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, initialResponseSetting: InitialResponseSetting? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String? = nil, intentName: String? = nil, kendraConfiguration: KendraConfiguration? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, qInConnectIntentConfiguration: QInConnectIntentConfiguration? = nil, qnAIntentConfiguration: QnAIntentConfiguration? = nil, sampleUtterances: [SampleUtterance]? = nil, slotPriorities: [SlotPriority]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.initialResponseSetting = initialResponseSetting
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.qInConnectIntentConfiguration = qInConnectIntentConfiguration
            self.qnAIntentConfiguration = qnAIntentConfiguration
            self.sampleUtterances = sampleUtterances
            self.slotPriorities = slotPriorities
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case initialResponseSetting = "initialResponseSetting"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentId = "intentId"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case qInConnectIntentConfiguration = "qInConnectIntentConfiguration"
            case qnAIntentConfiguration = "qnAIntentConfiguration"
            case sampleUtterances = "sampleUtterances"
            case slotPriorities = "slotPriorities"
        }
    }

    public struct DescribeResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeResourcePolicyResponse: AWSDecodableShape {
        /// The JSON structure that contains the resource policy. For more information about the contents of a JSON policy document, see  IAM JSON policy reference .
        public let policy: String?
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String?
        /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
        public let revisionId: String?

        @inlinable
        public init(policy: String? = nil, resourceArn: String? = nil, revisionId: String? = nil) {
            self.policy = policy
            self.resourceArn = resourceArn
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case resourceArn = "resourceArn"
            case revisionId = "revisionId"
        }
    }

    public struct DescribeSlotRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the slot.
        public let botId: String
        /// The version of the bot associated with the slot.
        public let botVersion: String
        /// The identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale of the slot to describe. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The unique identifier for the slot.
        public let slotId: String

        @inlinable
        public init(botId: String, botVersion: String, intentId: String, localeId: String, slotId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
            self.slotId = slotId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.intentId, key: "intentId")
            request.encodePath(self.localeId, key: "localeId")
            request.encodePath(self.slotId, key: "slotId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSlotResponse: AWSDecodableShape {
        /// The identifier of the bot associated with the slot.
        public let botId: String?
        /// The version of the bot associated with the slot.
        public let botVersion: String?
        /// A timestamp of the date and time that the slot was created.
        public let creationDateTime: Date?
        /// The description specified for the slot.
        public let description: String?
        /// The identifier of the intent associated with the slot.
        public let intentId: String?
        /// A timestamp of the date and time that the slot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale specified for the slot.
        public let localeId: String?
        /// Indicates whether the slot accepts multiple values in a single utterance. If the multipleValuesSetting is not set, the default value is false.
        public let multipleValuesSetting: MultipleValuesSetting?
        /// Whether slot values are shown in Amazon CloudWatch logs. If the value is None, the actual value of the slot is shown in logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier generated for the slot.
        public let slotId: String?
        /// The name specified for the slot.
        public let slotName: String?
        /// The identifier of the slot type that determines the values entered into the slot.
        public let slotTypeId: String?
        /// Specifications for the constituent sub slots and the   expression for the composite slot.
        public let subSlotSetting: SubSlotSetting?
        /// Prompts that Amazon Lex uses to elicit a value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, intentId: String? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, multipleValuesSetting: MultipleValuesSetting? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, subSlotSetting: SubSlotSetting? = nil, valueElicitationSetting: SlotValueElicitationSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.intentId = intentId
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.multipleValuesSetting = multipleValuesSetting
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.subSlotSetting = subSlotSetting
            self.valueElicitationSetting = valueElicitationSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case intentId = "intentId"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case multipleValuesSetting = "multipleValuesSetting"
            case obfuscationSetting = "obfuscationSetting"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case subSlotSetting = "subSlotSetting"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct DescribeSlotTypeRequest: AWSEncodableShape {
        /// The identifier of the bot associated with the slot type.
        public let botId: String
        /// The version of the bot associated with the slot type.
        public let botVersion: String
        /// The identifier of the language and locale of the slot type to describe. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The identifier of the slot type.
        public let slotTypeId: String

        @inlinable
        public init(botId: String, botVersion: String, localeId: String, slotTypeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.slotTypeId = slotTypeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
            request.encodePath(self.slotTypeId, key: "slotTypeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSlotTypeResponse: AWSDecodableShape {
        /// The identifier of the bot associated with the slot type.
        public let botId: String?
        /// The version of the bot associated with the slot type.
        public let botVersion: String?
        /// Specifications for a composite slot type.
        public let compositeSlotTypeSetting: CompositeSlotTypeSetting?
        /// A timestamp of the date and time that the slot type was created.
        public let creationDateTime: Date?
        /// The description specified for the slot type.
        public let description: String?
        public let externalSourceSetting: ExternalSourceSetting?
        /// A timestamp of the date and time that the slot type was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale specified for the slot type.
        public let localeId: String?
        /// The built in slot type used as a parent to this slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier for the slot type.
        public let slotTypeId: String?
        /// The name specified for the slot type.
        public let slotTypeName: String?
        /// The values that the slot type can take. Includes any synonyms for the slot type values.
        public let slotTypeValues: [SlotTypeValue]?
        /// The strategy that Amazon Lex uses to choose a value from a list of possible values.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, compositeSlotTypeSetting: CompositeSlotTypeSetting? = nil, creationDateTime: Date? = nil, description: String? = nil, externalSourceSetting: ExternalSourceSetting? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, parentSlotTypeSignature: String? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.compositeSlotTypeSetting = compositeSlotTypeSetting
            self.creationDateTime = creationDateTime
            self.description = description
            self.externalSourceSetting = externalSourceSetting
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case compositeSlotTypeSetting = "compositeSlotTypeSetting"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case externalSourceSetting = "externalSourceSetting"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct DescribeTestExecutionRequest: AWSEncodableShape {
        /// The execution Id of the test set execution.
        public let testExecutionId: String

        @inlinable
        public init(testExecutionId: String) {
            self.testExecutionId = testExecutionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testExecutionId, key: "testExecutionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, max: 10)
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, min: 10)
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTestExecutionResponse: AWSDecodableShape {
        /// Indicates whether we use streaming or non-streaming APIs are used for  the test set execution. For streaming, StartConversation  Amazon Lex Runtime API is used. Whereas for non-streaming, RecognizeUtterance  and RecognizeText Amazon Lex Runtime API is used.
        public let apiMode: TestExecutionApiMode?
        /// The execution creation date and time for the test set execution.
        public let creationDateTime: Date?
        /// Reasons for the failure of the test set execution.
        public let failureReasons: [String]?
        /// The date and time of the last update for the execution.
        public let lastUpdatedDateTime: Date?
        /// The target bot for the test set execution details.
        public let target: TestExecutionTarget?
        /// The execution Id for the test set execution.
        public let testExecutionId: String?
        /// Indicates whether test set is audio or text.
        public let testExecutionModality: TestExecutionModality?
        /// The test execution status for the test execution.
        public let testExecutionStatus: TestExecutionStatus?
        /// The test set Id for the test set execution.
        public let testSetId: String?
        /// The test set name of the test set execution.
        public let testSetName: String?

        @inlinable
        public init(apiMode: TestExecutionApiMode? = nil, creationDateTime: Date? = nil, failureReasons: [String]? = nil, lastUpdatedDateTime: Date? = nil, target: TestExecutionTarget? = nil, testExecutionId: String? = nil, testExecutionModality: TestExecutionModality? = nil, testExecutionStatus: TestExecutionStatus? = nil, testSetId: String? = nil, testSetName: String? = nil) {
            self.apiMode = apiMode
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.target = target
            self.testExecutionId = testExecutionId
            self.testExecutionModality = testExecutionModality
            self.testExecutionStatus = testExecutionStatus
            self.testSetId = testSetId
            self.testSetName = testSetName
        }

        private enum CodingKeys: String, CodingKey {
            case apiMode = "apiMode"
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case target = "target"
            case testExecutionId = "testExecutionId"
            case testExecutionModality = "testExecutionModality"
            case testExecutionStatus = "testExecutionStatus"
            case testSetId = "testSetId"
            case testSetName = "testSetName"
        }
    }

    public struct DescribeTestSetDiscrepancyReportRequest: AWSEncodableShape {
        /// The unique identifier of the test set discrepancy report.
        public let testSetDiscrepancyReportId: String

        @inlinable
        public init(testSetDiscrepancyReportId: String) {
            self.testSetDiscrepancyReportId = testSetDiscrepancyReportId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testSetDiscrepancyReportId, key: "testSetDiscrepancyReportId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testSetDiscrepancyReportId, name: "testSetDiscrepancyReportId", parent: name, max: 10)
            try self.validate(self.testSetDiscrepancyReportId, name: "testSetDiscrepancyReportId", parent: name, min: 10)
            try self.validate(self.testSetDiscrepancyReportId, name: "testSetDiscrepancyReportId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTestSetDiscrepancyReportResponse: AWSDecodableShape {
        /// The time and date of creation for the test set discrepancy report.
        public let creationDateTime: Date?
        /// The failure report for the test set discrepancy report generation action.
        public let failureReasons: [String]?
        /// The date and time of the last update for the test set discrepancy report.
        public let lastUpdatedDataTime: Date?
        /// The target bot location for the test set discrepancy report.
        public let target: TestSetDiscrepancyReportResourceTarget?
        /// Pre-signed Amazon S3 URL to download the test set discrepancy report.
        public let testSetDiscrepancyRawOutputUrl: String?
        /// The unique identifier of the test set discrepancy report to describe.
        public let testSetDiscrepancyReportId: String?
        /// The status for the test set discrepancy report.
        public let testSetDiscrepancyReportStatus: TestSetDiscrepancyReportStatus?
        /// The top 200 error results from the test set discrepancy report.
        public let testSetDiscrepancyTopErrors: TestSetDiscrepancyErrors?
        /// The test set Id for the test set discrepancy report.
        public let testSetId: String?

        @inlinable
        public init(creationDateTime: Date? = nil, failureReasons: [String]? = nil, lastUpdatedDataTime: Date? = nil, target: TestSetDiscrepancyReportResourceTarget? = nil, testSetDiscrepancyRawOutputUrl: String? = nil, testSetDiscrepancyReportId: String? = nil, testSetDiscrepancyReportStatus: TestSetDiscrepancyReportStatus? = nil, testSetDiscrepancyTopErrors: TestSetDiscrepancyErrors? = nil, testSetId: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReasons = failureReasons
            self.lastUpdatedDataTime = lastUpdatedDataTime
            self.target = target
            self.testSetDiscrepancyRawOutputUrl = testSetDiscrepancyRawOutputUrl
            self.testSetDiscrepancyReportId = testSetDiscrepancyReportId
            self.testSetDiscrepancyReportStatus = testSetDiscrepancyReportStatus
            self.testSetDiscrepancyTopErrors = testSetDiscrepancyTopErrors
            self.testSetId = testSetId
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReasons = "failureReasons"
            case lastUpdatedDataTime = "lastUpdatedDataTime"
            case target = "target"
            case testSetDiscrepancyRawOutputUrl = "testSetDiscrepancyRawOutputUrl"
            case testSetDiscrepancyReportId = "testSetDiscrepancyReportId"
            case testSetDiscrepancyReportStatus = "testSetDiscrepancyReportStatus"
            case testSetDiscrepancyTopErrors = "testSetDiscrepancyTopErrors"
            case testSetId = "testSetId"
        }
    }

    public struct DescribeTestSetGenerationRequest: AWSEncodableShape {
        /// The unique identifier of the test set generation.
        public let testSetGenerationId: String

        @inlinable
        public init(testSetGenerationId: String) {
            self.testSetGenerationId = testSetGenerationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testSetGenerationId, key: "testSetGenerationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testSetGenerationId, name: "testSetGenerationId", parent: name, max: 10)
            try self.validate(self.testSetGenerationId, name: "testSetGenerationId", parent: name, min: 10)
            try self.validate(self.testSetGenerationId, name: "testSetGenerationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTestSetGenerationResponse: AWSDecodableShape {
        /// The creation date and time for the test set generation.
        public let creationDateTime: Date?
        /// The test set description for the test set generation.
        public let description: String?
        /// The reasons the test set generation failed.
        public let failureReasons: [String]?
        /// The data source of the test set used for the test set generation.
        public let generationDataSource: TestSetGenerationDataSource?
        /// The date and time of the last update for the test set generation.
        public let lastUpdatedDateTime: Date?
        ///  The roleARN of the test set used for the test set generation.
        public let roleArn: String?
        /// The Amazon S3 storage location for the test set generation.
        public let storageLocation: TestSetStorageLocation?
        /// The unique identifier of the test set generation.
        public let testSetGenerationId: String?
        /// The status for the test set generation.
        public let testSetGenerationStatus: TestSetGenerationStatus?
        /// The unique identifier for the test set created for the generated test set.
        public let testSetId: String?
        /// The test set name for the generated test set.
        public let testSetName: String?

        @inlinable
        public init(creationDateTime: Date? = nil, description: String? = nil, failureReasons: [String]? = nil, generationDataSource: TestSetGenerationDataSource? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil, storageLocation: TestSetStorageLocation? = nil, testSetGenerationId: String? = nil, testSetGenerationStatus: TestSetGenerationStatus? = nil, testSetId: String? = nil, testSetName: String? = nil) {
            self.creationDateTime = creationDateTime
            self.description = description
            self.failureReasons = failureReasons
            self.generationDataSource = generationDataSource
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.storageLocation = storageLocation
            self.testSetGenerationId = testSetGenerationId
            self.testSetGenerationStatus = testSetGenerationStatus
            self.testSetId = testSetId
            self.testSetName = testSetName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case description = "description"
            case failureReasons = "failureReasons"
            case generationDataSource = "generationDataSource"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
            case storageLocation = "storageLocation"
            case testSetGenerationId = "testSetGenerationId"
            case testSetGenerationStatus = "testSetGenerationStatus"
            case testSetId = "testSetId"
            case testSetName = "testSetName"
        }
    }

    public struct DescribeTestSetRequest: AWSEncodableShape {
        /// The test set Id for the test set request.
        public let testSetId: String

        @inlinable
        public init(testSetId: String) {
            self.testSetId = testSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testSetId, key: "testSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testSetId, name: "testSetId", parent: name, max: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, min: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTestSetResponse: AWSDecodableShape {
        /// The creation date and time for the test set data.
        public let creationDateTime: Date?
        /// The description of the test set.
        public let description: String?
        /// The date and time for the last update of the test set data.
        public let lastUpdatedDateTime: Date?
        /// Indicates whether the test set is audio or text data.
        public let modality: TestSetModality?
        /// The total number of agent and user turn in the test set.
        public let numTurns: Int?
        /// The roleARN used for any operation in the test set to access  resources in the Amazon Web Services account.
        public let roleArn: String?
        /// The status of the test set.
        public let status: TestSetStatus?
        /// The Amazon S3 storage location for the test set data.
        public let storageLocation: TestSetStorageLocation?
        /// The test set Id for the test set response.
        public let testSetId: String?
        /// The test set name of the test set.
        public let testSetName: String?

        @inlinable
        public init(creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, modality: TestSetModality? = nil, numTurns: Int? = nil, roleArn: String? = nil, status: TestSetStatus? = nil, storageLocation: TestSetStorageLocation? = nil, testSetId: String? = nil, testSetName: String? = nil) {
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.modality = modality
            self.numTurns = numTurns
            self.roleArn = roleArn
            self.status = status
            self.storageLocation = storageLocation
            self.testSetId = testSetId
            self.testSetName = testSetName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case modality = "modality"
            case numTurns = "numTurns"
            case roleArn = "roleArn"
            case status = "status"
            case storageLocation = "storageLocation"
            case testSetId = "testSetId"
            case testSetName = "testSetName"
        }
    }

    public struct DescriptiveBotBuilderSpecification: AWSEncodableShape & AWSDecodableShape {
        /// An object containing information about the Amazon Bedrock model used to interpret the prompt used in descriptive bot building.
        public let bedrockModelSpecification: BedrockModelSpecification?
        /// Specifies whether the descriptive bot building feature is activated or not.
        public let enabled: Bool

        @inlinable
        public init(bedrockModelSpecification: BedrockModelSpecification? = nil, enabled: Bool) {
            self.bedrockModelSpecification = bedrockModelSpecification
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.bedrockModelSpecification?.validate(name: "\(name).bedrockModelSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockModelSpecification = "bedrockModelSpecification"
            case enabled = "enabled"
        }
    }

    public struct DialogAction: AWSEncodableShape & AWSDecodableShape {
        /// If the dialog action is ElicitSlot, defines the slot to elicit from the user.
        public let slotToElicit: String?
        /// When true the next message for the intent is not used.
        public let suppressNextMessage: Bool?
        /// The action that the bot should execute.
        public let type: DialogActionType

        @inlinable
        public init(slotToElicit: String? = nil, suppressNextMessage: Bool? = nil, type: DialogActionType) {
            self.slotToElicit = slotToElicit
            self.suppressNextMessage = suppressNextMessage
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.slotToElicit, name: "slotToElicit", parent: name, max: 100)
            try self.validate(self.slotToElicit, name: "slotToElicit", parent: name, min: 1)
            try self.validate(self.slotToElicit, name: "slotToElicit", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case slotToElicit = "slotToElicit"
            case suppressNextMessage = "suppressNextMessage"
            case type = "type"
        }
    }

    public struct DialogCodeHookInvocationSetting: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether a dialog code hook is used when the intent is activated.
        public let active: Bool
        /// Indicates whether a Lambda function should be invoked for the dialog.
        public let enableCodeHookInvocation: Bool
        /// A label that indicates the dialog step from which the dialog code hook is happening.
        public let invocationLabel: String?
        /// Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
        public let postCodeHookSpecification: PostDialogCodeHookInvocationSpecification

        @inlinable
        public init(active: Bool, enableCodeHookInvocation: Bool, invocationLabel: String? = nil, postCodeHookSpecification: PostDialogCodeHookInvocationSpecification) {
            self.active = active
            self.enableCodeHookInvocation = enableCodeHookInvocation
            self.invocationLabel = invocationLabel
            self.postCodeHookSpecification = postCodeHookSpecification
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationLabel, name: "invocationLabel", parent: name, max: 100)
            try self.validate(self.invocationLabel, name: "invocationLabel", parent: name, min: 1)
            try self.validate(self.invocationLabel, name: "invocationLabel", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.postCodeHookSpecification.validate(name: "\(name).postCodeHookSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case enableCodeHookInvocation = "enableCodeHookInvocation"
            case invocationLabel = "invocationLabel"
            case postCodeHookSpecification = "postCodeHookSpecification"
        }
    }

    public struct DialogCodeHookSettings: AWSEncodableShape & AWSDecodableShape {
        /// Enables the dialog code hook so that it processes user requests.
        public let enabled: Bool

        @inlinable
        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct DialogState: AWSEncodableShape & AWSDecodableShape {
        public let dialogAction: DialogAction?
        public let intent: IntentOverride?
        /// Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
        public let sessionAttributes: [String: String]?

        @inlinable
        public init(dialogAction: DialogAction? = nil, intent: IntentOverride? = nil, sessionAttributes: [String: String]? = nil) {
            self.dialogAction = dialogAction
            self.intent = intent
            self.sessionAttributes = sessionAttributes
        }

        public func validate(name: String) throws {
            try self.dialogAction?.validate(name: "\(name).dialogAction")
            try self.intent?.validate(name: "\(name).intent")
            try self.sessionAttributes?.forEach {
                try validate($0.key, name: "sessionAttributes.key", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dialogAction = "dialogAction"
            case intent = "intent"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct ElicitationCodeHookInvocationSetting: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether a Lambda function should be invoked for the dialog.
        public let enableCodeHookInvocation: Bool
        /// A label that indicates the dialog step from which the dialog code hook is happening.
        public let invocationLabel: String?

        @inlinable
        public init(enableCodeHookInvocation: Bool, invocationLabel: String? = nil) {
            self.enableCodeHookInvocation = enableCodeHookInvocation
            self.invocationLabel = invocationLabel
        }

        public func validate(name: String) throws {
            try self.validate(self.invocationLabel, name: "invocationLabel", parent: name, max: 100)
            try self.validate(self.invocationLabel, name: "invocationLabel", parent: name, min: 1)
            try self.validate(self.invocationLabel, name: "invocationLabel", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case enableCodeHookInvocation = "enableCodeHookInvocation"
            case invocationLabel = "invocationLabel"
        }
    }

    public struct EncryptionSetting: AWSEncodableShape & AWSDecodableShape {
        /// The password used to encrypt the associated transcript file.
        public let associatedTranscriptsPassword: String?
        /// The password used to encrypt the recommended bot recommendation file.
        public let botLocaleExportPassword: String?
        /// The KMS key ARN used to encrypt the metadata associated with the bot recommendation.
        public let kmsKeyArn: String?

        @inlinable
        public init(associatedTranscriptsPassword: String? = nil, botLocaleExportPassword: String? = nil, kmsKeyArn: String? = nil) {
            self.associatedTranscriptsPassword = associatedTranscriptsPassword
            self.botLocaleExportPassword = botLocaleExportPassword
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.associatedTranscriptsPassword, name: "associatedTranscriptsPassword", parent: name, max: 1024)
            try self.validate(self.botLocaleExportPassword, name: "botLocaleExportPassword", parent: name, max: 1024)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:[\\w\\-]+:kms:[\\w\\-]+:[\\d]{12}:(?:key\\/[\\w\\-]+|alias\\/[a-zA-Z0-9:\\/_\\-]{1,256})$")
        }

        private enum CodingKeys: String, CodingKey {
            case associatedTranscriptsPassword = "associatedTranscriptsPassword"
            case botLocaleExportPassword = "botLocaleExportPassword"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct ErrorLogSettings: AWSEncodableShape & AWSDecodableShape {
        /// Settings parameters for the error logs, when it is enabled.
        public let enabled: Bool

        @inlinable
        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct ExactResponseFields: AWSEncodableShape & AWSDecodableShape {
        /// The name of the field that contains the answer to the query made to the OpenSearch Service database.
        public let answerField: String
        /// The name of the field that contains the query made to the OpenSearch Service database.
        public let questionField: String

        @inlinable
        public init(answerField: String, questionField: String) {
            self.answerField = answerField
            self.questionField = questionField
        }

        private enum CodingKeys: String, CodingKey {
            case answerField = "answerField"
            case questionField = "questionField"
        }
    }

    public struct ExecutionErrorDetails: AWSDecodableShape {
        /// The error code for the error.
        public let errorCode: String
        /// The message describing the error.
        public let errorMessage: String

        @inlinable
        public init(errorCode: String, errorMessage: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct ExportFilter: AWSEncodableShape {
        /// The name of the field to use for filtering.
        public let name: ExportFilterName
        /// The operator to use for the filter. Specify EQ when the ListExports operation should return only resource types that equal the specified value. Specify CO when the ListExports operation should return resource types that contain the specified value.
        public let `operator`: ExportFilterOperator
        /// The values to use to filter the response. The values must be Bot, BotLocale, or CustomVocabulary.
        public let values: [String]

        @inlinable
        public init(name: ExportFilterName, operator: ExportFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct ExportResourceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Parameters for exporting a bot.
        public let botExportSpecification: BotExportSpecification?
        /// Parameters for exporting a bot locale.
        public let botLocaleExportSpecification: BotLocaleExportSpecification?
        /// The parameters required to export a custom vocabulary.
        public let customVocabularyExportSpecification: CustomVocabularyExportSpecification?
        /// Specifications for the test set that is exported as a resource.
        public let testSetExportSpecification: TestSetExportSpecification?

        @inlinable
        public init(botExportSpecification: BotExportSpecification? = nil, botLocaleExportSpecification: BotLocaleExportSpecification? = nil, customVocabularyExportSpecification: CustomVocabularyExportSpecification? = nil, testSetExportSpecification: TestSetExportSpecification? = nil) {
            self.botExportSpecification = botExportSpecification
            self.botLocaleExportSpecification = botLocaleExportSpecification
            self.customVocabularyExportSpecification = customVocabularyExportSpecification
            self.testSetExportSpecification = testSetExportSpecification
        }

        public func validate(name: String) throws {
            try self.botExportSpecification?.validate(name: "\(name).botExportSpecification")
            try self.botLocaleExportSpecification?.validate(name: "\(name).botLocaleExportSpecification")
            try self.customVocabularyExportSpecification?.validate(name: "\(name).customVocabularyExportSpecification")
            try self.testSetExportSpecification?.validate(name: "\(name).testSetExportSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case botExportSpecification = "botExportSpecification"
            case botLocaleExportSpecification = "botLocaleExportSpecification"
            case customVocabularyExportSpecification = "customVocabularyExportSpecification"
            case testSetExportSpecification = "testSetExportSpecification"
        }
    }

    public struct ExportSortBy: AWSEncodableShape {
        /// The export field to use for sorting.
        public let attribute: ExportSortAttribute
        /// The order to sort the list.
        public let order: SortOrder

        @inlinable
        public init(attribute: ExportSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct ExportSummary: AWSDecodableShape {
        /// The date and time that the export was created.
        public let creationDateTime: Date?
        /// The unique identifier that Amazon Lex assigned to the export.
        public let exportId: String?
        /// The status of the export. When the status is Completed the export is ready to download.
        public let exportStatus: ExportStatus?
        /// The file format used in the export files.
        public let fileFormat: ImportExportFileFormat?
        /// The date and time that the export was last updated.
        public let lastUpdatedDateTime: Date?
        /// Information about the bot or bot locale that was exported.
        public let resourceSpecification: ExportResourceSpecification?

        @inlinable
        public init(creationDateTime: Date? = nil, exportId: String? = nil, exportStatus: ExportStatus? = nil, fileFormat: ImportExportFileFormat? = nil, lastUpdatedDateTime: Date? = nil, resourceSpecification: ExportResourceSpecification? = nil) {
            self.creationDateTime = creationDateTime
            self.exportId = exportId
            self.exportStatus = exportStatus
            self.fileFormat = fileFormat
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.resourceSpecification = resourceSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case exportId = "exportId"
            case exportStatus = "exportStatus"
            case fileFormat = "fileFormat"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct ExternalSourceSetting: AWSEncodableShape & AWSDecodableShape {
        /// Settings required for a slot type based on a grammar that you provide.
        public let grammarSlotTypeSetting: GrammarSlotTypeSetting?

        @inlinable
        public init(grammarSlotTypeSetting: GrammarSlotTypeSetting? = nil) {
            self.grammarSlotTypeSetting = grammarSlotTypeSetting
        }

        public func validate(name: String) throws {
            try self.grammarSlotTypeSetting?.validate(name: "\(name).grammarSlotTypeSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case grammarSlotTypeSetting = "grammarSlotTypeSetting"
        }
    }

    public struct FailedCustomVocabularyItem: AWSDecodableShape {
        /// The unique error code for the failed custom vocabulary item  from the custom vocabulary list.
        public let errorCode: ErrorCode?
        /// The error message for the failed custom vocabulary item  from the custom vocabulary list.
        public let errorMessage: String?
        /// The unique item identifer for the failed custom vocabulary item  from the custom vocabulary list.
        public let itemId: String?

        @inlinable
        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, itemId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.itemId = itemId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case itemId = "itemId"
        }
    }

    public struct FulfillmentCodeHookSettings: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether the fulfillment code hook is used. When active is false, the code hook doesn't run.
        public let active: Bool?
        /// Indicates whether a Lambda function should be invoked to fulfill a specific intent.
        public let enabled: Bool
        /// Provides settings for update messages sent to the user for long-running Lambda fulfillment functions. Fulfillment updates can be used only with streaming conversations.
        public let fulfillmentUpdatesSpecification: FulfillmentUpdatesSpecification?
        /// Provides settings for messages sent to the user for after the Lambda fulfillment function completes. Post-fulfillment messages can be sent for both streaming and non-streaming conversations.
        public let postFulfillmentStatusSpecification: PostFulfillmentStatusSpecification?

        @inlinable
        public init(active: Bool? = nil, enabled: Bool, fulfillmentUpdatesSpecification: FulfillmentUpdatesSpecification? = nil, postFulfillmentStatusSpecification: PostFulfillmentStatusSpecification? = nil) {
            self.active = active
            self.enabled = enabled
            self.fulfillmentUpdatesSpecification = fulfillmentUpdatesSpecification
            self.postFulfillmentStatusSpecification = postFulfillmentStatusSpecification
        }

        public func validate(name: String) throws {
            try self.fulfillmentUpdatesSpecification?.validate(name: "\(name).fulfillmentUpdatesSpecification")
            try self.postFulfillmentStatusSpecification?.validate(name: "\(name).postFulfillmentStatusSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case enabled = "enabled"
            case fulfillmentUpdatesSpecification = "fulfillmentUpdatesSpecification"
            case postFulfillmentStatusSpecification = "postFulfillmentStatusSpecification"
        }
    }

    public struct FulfillmentStartResponseSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether the user can interrupt the start message while it is playing.
        public let allowInterrupt: Bool?
        /// The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
        public let delayInSeconds: Int
        /// 1 - 5 message groups that contain start messages. Amazon Lex chooses one of the messages to play to the user.
        public let messageGroups: [MessageGroup]

        @inlinable
        public init(allowInterrupt: Bool? = nil, delayInSeconds: Int, messageGroups: [MessageGroup]) {
            self.allowInterrupt = allowInterrupt
            self.delayInSeconds = delayInSeconds
            self.messageGroups = messageGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.delayInSeconds, name: "delayInSeconds", parent: name, max: 900)
            try self.validate(self.delayInSeconds, name: "delayInSeconds", parent: name, min: 1)
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case delayInSeconds = "delayInSeconds"
            case messageGroups = "messageGroups"
        }
    }

    public struct FulfillmentUpdateResponseSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether the user can interrupt an update message while it is playing.
        public let allowInterrupt: Bool?
        /// The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
        public let frequencyInSeconds: Int
        /// 1 - 5 message groups that contain update messages. Amazon Lex chooses one of the messages to play to the user.
        public let messageGroups: [MessageGroup]

        @inlinable
        public init(allowInterrupt: Bool? = nil, frequencyInSeconds: Int, messageGroups: [MessageGroup]) {
            self.allowInterrupt = allowInterrupt
            self.frequencyInSeconds = frequencyInSeconds
            self.messageGroups = messageGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.frequencyInSeconds, name: "frequencyInSeconds", parent: name, max: 900)
            try self.validate(self.frequencyInSeconds, name: "frequencyInSeconds", parent: name, min: 1)
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case frequencyInSeconds = "frequencyInSeconds"
            case messageGroups = "messageGroups"
        }
    }

    public struct FulfillmentUpdatesSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent. If the active field is set to true, the startResponse, updateResponse, and timeoutInSeconds fields are required.
        public let active: Bool
        /// Provides configuration information for the message sent to users when the fulfillment Lambda functions starts running.
        public let startResponse: FulfillmentStartResponseSpecification?
        /// The length of time that the fulfillment Lambda function should run before it times out.
        public let timeoutInSeconds: Int?
        /// Provides configuration information for messages sent periodically to the user while the fulfillment Lambda function is running.
        public let updateResponse: FulfillmentUpdateResponseSpecification?

        @inlinable
        public init(active: Bool, startResponse: FulfillmentStartResponseSpecification? = nil, timeoutInSeconds: Int? = nil, updateResponse: FulfillmentUpdateResponseSpecification? = nil) {
            self.active = active
            self.startResponse = startResponse
            self.timeoutInSeconds = timeoutInSeconds
            self.updateResponse = updateResponse
        }

        public func validate(name: String) throws {
            try self.startResponse?.validate(name: "\(name).startResponse")
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, max: 900)
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, min: 1)
            try self.updateResponse?.validate(name: "\(name).updateResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case startResponse = "startResponse"
            case timeoutInSeconds = "timeoutInSeconds"
            case updateResponse = "updateResponse"
        }
    }

    public struct GenerateBotElementRequest: AWSEncodableShape {
        /// The bot unique Id for the bot request to generate utterances.
        public let botId: String
        /// The bot version for the bot request to generate utterances.
        public let botVersion: String
        /// The intent unique Id for the bot request to generate utterances.
        public let intentId: String
        /// The unique locale Id for the bot request to generate utterances.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, intentId: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encode(self.intentId, forKey: .intentId)
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case intentId = "intentId"
        }
    }

    public struct GenerateBotElementResponse: AWSDecodableShape {
        /// The unique bot Id for the bot which received the response.
        public let botId: String?
        /// The unique bot version for the bot which received the response.
        public let botVersion: String?
        /// The unique intent Id for the bot which received the response.
        public let intentId: String?
        /// The unique locale Id for the bot which received the response.
        public let localeId: String?
        /// The sample utterances for the bot which received the response.
        public let sampleUtterances: [SampleUtterance]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, intentId: String? = nil, localeId: String? = nil, sampleUtterances: [SampleUtterance]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
            self.sampleUtterances = sampleUtterances
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case intentId = "intentId"
            case localeId = "localeId"
            case sampleUtterances = "sampleUtterances"
        }
    }

    public struct GenerationSortBy: AWSEncodableShape {
        /// The attribute by which to sort the generation request information. You can sort by the following attributes.    creationStartTime – The time at which the generation request was created.    lastUpdatedTime – The time at which the generation request was last updated.
        public let attribute: GenerationSortByAttribute
        /// The order by which to sort the generation request information.
        public let order: SortOrder

        @inlinable
        public init(attribute: GenerationSortByAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct GenerationSummary: AWSDecodableShape {
        /// The date and time at which the generation request was made.
        public let creationDateTime: Date?
        /// The unique identifier of the generation request.
        public let generationId: String?
        /// The status of the generation request.
        public let generationStatus: GenerationStatus?
        /// The date and time at which the generation request was last updated.
        public let lastUpdatedDateTime: Date?

        @inlinable
        public init(creationDateTime: Date? = nil, generationId: String? = nil, generationStatus: GenerationStatus? = nil, lastUpdatedDateTime: Date? = nil) {
            self.creationDateTime = creationDateTime
            self.generationId = generationId
            self.generationStatus = generationStatus
            self.lastUpdatedDateTime = lastUpdatedDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case generationId = "generationId"
            case generationStatus = "generationStatus"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
        }
    }

    public struct GenerativeAISettings: AWSEncodableShape & AWSDecodableShape {
        public let buildtimeSettings: BuildtimeSettings?
        public let runtimeSettings: RuntimeSettings?

        @inlinable
        public init(buildtimeSettings: BuildtimeSettings? = nil, runtimeSettings: RuntimeSettings? = nil) {
            self.buildtimeSettings = buildtimeSettings
            self.runtimeSettings = runtimeSettings
        }

        public func validate(name: String) throws {
            try self.buildtimeSettings?.validate(name: "\(name).buildtimeSettings")
            try self.runtimeSettings?.validate(name: "\(name).runtimeSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case buildtimeSettings = "buildtimeSettings"
            case runtimeSettings = "runtimeSettings"
        }
    }

    public struct GetTestExecutionArtifactsUrlRequest: AWSEncodableShape {
        /// The unique identifier of the completed test execution.
        public let testExecutionId: String

        @inlinable
        public init(testExecutionId: String) {
            self.testExecutionId = testExecutionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testExecutionId, key: "testExecutionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, max: 10)
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, min: 10)
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTestExecutionArtifactsUrlResponse: AWSDecodableShape {
        /// The pre-signed Amazon S3 URL to download completed test execution.
        public let downloadArtifactsUrl: String?
        /// The unique identifier of the completed test execution.
        public let testExecutionId: String?

        @inlinable
        public init(downloadArtifactsUrl: String? = nil, testExecutionId: String? = nil) {
            self.downloadArtifactsUrl = downloadArtifactsUrl
            self.testExecutionId = testExecutionId
        }

        private enum CodingKeys: String, CodingKey {
            case downloadArtifactsUrl = "downloadArtifactsUrl"
            case testExecutionId = "testExecutionId"
        }
    }

    public struct GrammarSlotTypeSetting: AWSEncodableShape & AWSDecodableShape {
        /// The source of the grammar used to create the slot type.
        public let source: GrammarSlotTypeSource?

        @inlinable
        public init(source: GrammarSlotTypeSource? = nil) {
            self.source = source
        }

        public func validate(name: String) throws {
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
        }
    }

    public struct GrammarSlotTypeSource: AWSEncodableShape & AWSDecodableShape {
        /// The KMS key required to decrypt the contents of the grammar, if any.
        public let kmsKeyArn: String?
        /// The name of the Amazon S3 bucket that contains the grammar source.
        public let s3BucketName: String
        /// The path to the grammar in the Amazon S3 bucket.
        public let s3ObjectKey: String

        @inlinable
        public init(kmsKeyArn: String? = nil, s3BucketName: String, s3ObjectKey: String) {
            self.kmsKeyArn = kmsKeyArn
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:[\\w\\-]+:kms:[\\w\\-]+:[\\d]{12}:(?:key\\/[\\w\\-]+|alias\\/[a-zA-Z0-9:\\/_\\-]{1,256})$")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, max: 1024)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, min: 1)
            try self.validate(self.s3ObjectKey, name: "s3ObjectKey", parent: name, pattern: "^[\\.\\-\\!\\*\\_\\'\\(\\)a-zA-Z0-9][\\.\\-\\!\\*\\_\\'\\(\\)\\/a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case s3BucketName = "s3BucketName"
            case s3ObjectKey = "s3ObjectKey"
        }
    }

    public struct ImageResponseCard: AWSEncodableShape & AWSDecodableShape {
        /// A list of buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button.
        public let buttons: [Button]?
        /// The URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
        public let imageUrl: String?
        /// The subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
        public let subtitle: String?
        /// The title to display on the response card. The format of the title is determined by the platform displaying the response card.
        public let title: String

        @inlinable
        public init(buttons: [Button]? = nil, imageUrl: String? = nil, subtitle: String? = nil, title: String) {
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subtitle = subtitle
            self.title = title
        }

        public func validate(name: String) throws {
            try self.buttons?.forEach {
                try $0.validate(name: "\(name).buttons[]")
            }
            try self.validate(self.buttons, name: "buttons", parent: name, max: 5)
            try self.validate(self.imageUrl, name: "imageUrl", parent: name, max: 250)
            try self.validate(self.imageUrl, name: "imageUrl", parent: name, min: 1)
            try self.validate(self.subtitle, name: "subtitle", parent: name, max: 250)
            try self.validate(self.subtitle, name: "subtitle", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 250)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case buttons = "buttons"
            case imageUrl = "imageUrl"
            case subtitle = "subtitle"
            case title = "title"
        }
    }

    public struct ImportFilter: AWSEncodableShape {
        /// The name of the field to use for filtering.
        public let name: ImportFilterName
        /// The operator to use for the filter. Specify EQ when the ListImports operation should return only resource types that equal the specified value. Specify CO when the ListImports operation should return resource types that contain the specified value.
        public let `operator`: ImportFilterOperator
        /// The values to use to filter the response. The values must be Bot, BotLocale, or CustomVocabulary.
        public let values: [String]

        @inlinable
        public init(name: ImportFilterName, operator: ImportFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct ImportResourceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Parameters for importing a bot.
        public let botImportSpecification: BotImportSpecification?
        /// Parameters for importing a bot locale.
        public let botLocaleImportSpecification: BotLocaleImportSpecification?
        public let customVocabularyImportSpecification: CustomVocabularyImportSpecification?
        /// Specifications for the test set that is imported.
        public let testSetImportResourceSpecification: TestSetImportResourceSpecification?

        @inlinable
        public init(botImportSpecification: BotImportSpecification? = nil, botLocaleImportSpecification: BotLocaleImportSpecification? = nil, customVocabularyImportSpecification: CustomVocabularyImportSpecification? = nil, testSetImportResourceSpecification: TestSetImportResourceSpecification? = nil) {
            self.botImportSpecification = botImportSpecification
            self.botLocaleImportSpecification = botLocaleImportSpecification
            self.customVocabularyImportSpecification = customVocabularyImportSpecification
            self.testSetImportResourceSpecification = testSetImportResourceSpecification
        }

        public func validate(name: String) throws {
            try self.botImportSpecification?.validate(name: "\(name).botImportSpecification")
            try self.botLocaleImportSpecification?.validate(name: "\(name).botLocaleImportSpecification")
            try self.customVocabularyImportSpecification?.validate(name: "\(name).customVocabularyImportSpecification")
            try self.testSetImportResourceSpecification?.validate(name: "\(name).testSetImportResourceSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case botImportSpecification = "botImportSpecification"
            case botLocaleImportSpecification = "botLocaleImportSpecification"
            case customVocabularyImportSpecification = "customVocabularyImportSpecification"
            case testSetImportResourceSpecification = "testSetImportResourceSpecification"
        }
    }

    public struct ImportSortBy: AWSEncodableShape {
        /// The export field to use for sorting.
        public let attribute: ImportSortAttribute
        /// The order to sort the list.
        public let order: SortOrder

        @inlinable
        public init(attribute: ImportSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct ImportSummary: AWSDecodableShape {
        /// The date and time that the import was created.
        public let creationDateTime: Date?
        /// The unique identifier that Amazon Lex assigned to the imported resource.
        public let importedResourceId: String?
        /// The name that you gave the imported resource.
        public let importedResourceName: String?
        /// The type of resource that was imported.
        public let importedResourceType: ImportResourceType?
        /// The unique identifier that Amazon Lex assigned to the import.
        public let importId: String?
        /// The status of the resource. When the status is Completed the resource is ready to build.
        public let importStatus: ImportStatus?
        /// The date and time that the import was last updated.
        public let lastUpdatedDateTime: Date?
        /// The strategy used to merge existing bot or bot locale definitions with the imported definition.
        public let mergeStrategy: MergeStrategy?

        @inlinable
        public init(creationDateTime: Date? = nil, importedResourceId: String? = nil, importedResourceName: String? = nil, importedResourceType: ImportResourceType? = nil, importId: String? = nil, importStatus: ImportStatus? = nil, lastUpdatedDateTime: Date? = nil, mergeStrategy: MergeStrategy? = nil) {
            self.creationDateTime = creationDateTime
            self.importedResourceId = importedResourceId
            self.importedResourceName = importedResourceName
            self.importedResourceType = importedResourceType
            self.importId = importId
            self.importStatus = importStatus
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.mergeStrategy = mergeStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case importedResourceId = "importedResourceId"
            case importedResourceName = "importedResourceName"
            case importedResourceType = "importedResourceType"
            case importId = "importId"
            case importStatus = "importStatus"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case mergeStrategy = "mergeStrategy"
        }
    }

    public struct InitialResponseSetting: AWSEncodableShape & AWSDecodableShape {
        public let codeHook: DialogCodeHookInvocationSetting?
        public let conditional: ConditionalSpecification?
        public let initialResponse: ResponseSpecification?
        /// The next step in the conversation.
        public let nextStep: DialogState?

        @inlinable
        public init(codeHook: DialogCodeHookInvocationSetting? = nil, conditional: ConditionalSpecification? = nil, initialResponse: ResponseSpecification? = nil, nextStep: DialogState? = nil) {
            self.codeHook = codeHook
            self.conditional = conditional
            self.initialResponse = initialResponse
            self.nextStep = nextStep
        }

        public func validate(name: String) throws {
            try self.codeHook?.validate(name: "\(name).codeHook")
            try self.conditional?.validate(name: "\(name).conditional")
            try self.initialResponse?.validate(name: "\(name).initialResponse")
            try self.nextStep?.validate(name: "\(name).nextStep")
        }

        private enum CodingKeys: String, CodingKey {
            case codeHook = "codeHook"
            case conditional = "conditional"
            case initialResponse = "initialResponse"
            case nextStep = "nextStep"
        }
    }

    public struct InputContext: AWSEncodableShape & AWSDecodableShape {
        /// The name of the context.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct InputSessionStateSpecification: AWSDecodableShape {
        /// Active contexts for the session state.
        public let activeContexts: [ActiveContext]?
        /// Runtime hints for the session state.
        public let runtimeHints: RuntimeHints?
        /// Session attributes for the session state.
        public let sessionAttributes: [String: String]?

        @inlinable
        public init(activeContexts: [ActiveContext]? = nil, runtimeHints: RuntimeHints? = nil, sessionAttributes: [String: String]? = nil) {
            self.activeContexts = activeContexts
            self.runtimeHints = runtimeHints
            self.sessionAttributes = sessionAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case activeContexts = "activeContexts"
            case runtimeHints = "runtimeHints"
            case sessionAttributes = "sessionAttributes"
        }
    }

    public struct IntentClassificationTestResultItem: AWSDecodableShape {
        /// The name of the intent.
        public let intentName: String
        /// Indicates whether the conversation involves multiple turns or not.
        public let multiTurnConversation: Bool
        /// The result of the intent classification test.
        public let resultCounts: IntentClassificationTestResultItemCounts

        @inlinable
        public init(intentName: String, multiTurnConversation: Bool, resultCounts: IntentClassificationTestResultItemCounts) {
            self.intentName = intentName
            self.multiTurnConversation = multiTurnConversation
            self.resultCounts = resultCounts
        }

        private enum CodingKeys: String, CodingKey {
            case intentName = "intentName"
            case multiTurnConversation = "multiTurnConversation"
            case resultCounts = "resultCounts"
        }
    }

    public struct IntentClassificationTestResultItemCounts: AWSDecodableShape {
        /// The number of matched and mismatched results for intent recognition for the intent.
        public let intentMatchResultCounts: [TestResultMatchStatus: Int]
        /// The number of matched, mismatched, and execution error results for speech transcription for the intent.
        public let speechTranscriptionResultCounts: [TestResultMatchStatus: Int]?
        /// The total number of results in the intent classification test.
        public let totalResultCount: Int

        @inlinable
        public init(intentMatchResultCounts: [TestResultMatchStatus: Int], speechTranscriptionResultCounts: [TestResultMatchStatus: Int]? = nil, totalResultCount: Int) {
            self.intentMatchResultCounts = intentMatchResultCounts
            self.speechTranscriptionResultCounts = speechTranscriptionResultCounts
            self.totalResultCount = totalResultCount
        }

        private enum CodingKeys: String, CodingKey {
            case intentMatchResultCounts = "intentMatchResultCounts"
            case speechTranscriptionResultCounts = "speechTranscriptionResultCounts"
            case totalResultCount = "totalResultCount"
        }
    }

    public struct IntentClassificationTestResults: AWSDecodableShape {
        /// A list of the results for the intent classification test.
        public let items: [IntentClassificationTestResultItem]

        @inlinable
        public init(items: [IntentClassificationTestResultItem]) {
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
        }
    }

    public struct IntentClosingSetting: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the active field isn't specified, the default is true.
        public let active: Bool?
        /// The response that Amazon Lex sends to the user when the intent is complete.
        public let closingResponse: ResponseSpecification?
        /// A list of conditional branches associated with the intent's closing response. These branches are executed when the nextStep attribute is set to EvalutateConditional.
        public let conditional: ConditionalSpecification?
        /// Specifies the next step that the bot executes after playing the intent's closing response.
        public let nextStep: DialogState?

        @inlinable
        public init(active: Bool? = nil, closingResponse: ResponseSpecification? = nil, conditional: ConditionalSpecification? = nil, nextStep: DialogState? = nil) {
            self.active = active
            self.closingResponse = closingResponse
            self.conditional = conditional
            self.nextStep = nextStep
        }

        public func validate(name: String) throws {
            try self.closingResponse?.validate(name: "\(name).closingResponse")
            try self.conditional?.validate(name: "\(name).conditional")
            try self.nextStep?.validate(name: "\(name).nextStep")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case closingResponse = "closingResponse"
            case conditional = "conditional"
            case nextStep = "nextStep"
        }
    }

    public struct IntentConfirmationSetting: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the active field isn't specified, the default is true.
        public let active: Bool?
        /// The DialogCodeHookInvocationSetting object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is InvokeDialogCodeHook.
        public let codeHook: DialogCodeHookInvocationSetting?
        /// A list of conditional branches to evaluate after the intent is closed.
        public let confirmationConditional: ConditionalSpecification?
        /// Specifies the next step that the bot executes when the customer confirms the intent.
        public let confirmationNextStep: DialogState?
        public let confirmationResponse: ResponseSpecification?
        /// A list of conditional branches to evaluate after the intent is declined.
        public let declinationConditional: ConditionalSpecification?
        /// Specifies the next step that the bot executes when the customer declines the intent.
        public let declinationNextStep: DialogState?
        /// When the user answers "no" to the question defined in promptSpecification, Amazon Lex responds with this response to acknowledge that the intent was canceled.
        public let declinationResponse: ResponseSpecification?
        /// The DialogCodeHookInvocationSetting used when the code hook is invoked during confirmation prompt retries.
        public let elicitationCodeHook: ElicitationCodeHookInvocationSetting?
        public let failureConditional: ConditionalSpecification?
        /// The next step to take in the conversation if the confirmation step fails.
        public let failureNextStep: DialogState?
        public let failureResponse: ResponseSpecification?
        /// Prompts the user to confirm the intent. This question should have a yes or no answer. Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the OrderPizza intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information.
        public let promptSpecification: PromptSpecification

        @inlinable
        public init(active: Bool? = nil, codeHook: DialogCodeHookInvocationSetting? = nil, confirmationConditional: ConditionalSpecification? = nil, confirmationNextStep: DialogState? = nil, confirmationResponse: ResponseSpecification? = nil, declinationConditional: ConditionalSpecification? = nil, declinationNextStep: DialogState? = nil, declinationResponse: ResponseSpecification? = nil, elicitationCodeHook: ElicitationCodeHookInvocationSetting? = nil, failureConditional: ConditionalSpecification? = nil, failureNextStep: DialogState? = nil, failureResponse: ResponseSpecification? = nil, promptSpecification: PromptSpecification) {
            self.active = active
            self.codeHook = codeHook
            self.confirmationConditional = confirmationConditional
            self.confirmationNextStep = confirmationNextStep
            self.confirmationResponse = confirmationResponse
            self.declinationConditional = declinationConditional
            self.declinationNextStep = declinationNextStep
            self.declinationResponse = declinationResponse
            self.elicitationCodeHook = elicitationCodeHook
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
            self.promptSpecification = promptSpecification
        }

        public func validate(name: String) throws {
            try self.codeHook?.validate(name: "\(name).codeHook")
            try self.confirmationConditional?.validate(name: "\(name).confirmationConditional")
            try self.confirmationNextStep?.validate(name: "\(name).confirmationNextStep")
            try self.confirmationResponse?.validate(name: "\(name).confirmationResponse")
            try self.declinationConditional?.validate(name: "\(name).declinationConditional")
            try self.declinationNextStep?.validate(name: "\(name).declinationNextStep")
            try self.declinationResponse?.validate(name: "\(name).declinationResponse")
            try self.elicitationCodeHook?.validate(name: "\(name).elicitationCodeHook")
            try self.failureConditional?.validate(name: "\(name).failureConditional")
            try self.failureNextStep?.validate(name: "\(name).failureNextStep")
            try self.failureResponse?.validate(name: "\(name).failureResponse")
            try self.promptSpecification.validate(name: "\(name).promptSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case codeHook = "codeHook"
            case confirmationConditional = "confirmationConditional"
            case confirmationNextStep = "confirmationNextStep"
            case confirmationResponse = "confirmationResponse"
            case declinationConditional = "declinationConditional"
            case declinationNextStep = "declinationNextStep"
            case declinationResponse = "declinationResponse"
            case elicitationCodeHook = "elicitationCodeHook"
            case failureConditional = "failureConditional"
            case failureNextStep = "failureNextStep"
            case failureResponse = "failureResponse"
            case promptSpecification = "promptSpecification"
        }
    }

    public struct IntentFilter: AWSEncodableShape {
        /// The name of the field to use for the filter.
        public let name: IntentFilterName
        /// The operator to use for the filter. Specify EQ when the ListIntents operation should return only aliases that equal the specified value. Specify CO when the ListIntents operation should return aliases that contain the specified value.
        public let `operator`: IntentFilterOperator
        /// The value to use for the filter.
        public let values: [String]

        @inlinable
        public init(name: IntentFilterName, operator: IntentFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct IntentLevelSlotResolutionTestResultItem: AWSDecodableShape {
        /// The name of the intent that was recognized.
        public let intentName: String
        /// Indicates whether the conversation involves multiple turns or not.
        public let multiTurnConversation: Bool
        /// The results for the slot resolution in the test execution result.
        public let slotResolutionResults: [SlotResolutionTestResultItem]

        @inlinable
        public init(intentName: String, multiTurnConversation: Bool, slotResolutionResults: [SlotResolutionTestResultItem]) {
            self.intentName = intentName
            self.multiTurnConversation = multiTurnConversation
            self.slotResolutionResults = slotResolutionResults
        }

        private enum CodingKeys: String, CodingKey {
            case intentName = "intentName"
            case multiTurnConversation = "multiTurnConversation"
            case slotResolutionResults = "slotResolutionResults"
        }
    }

    public struct IntentLevelSlotResolutionTestResults: AWSDecodableShape {
        /// Indicates the items for the slot level resolution for the intents.
        public let items: [IntentLevelSlotResolutionTestResultItem]

        @inlinable
        public init(items: [IntentLevelSlotResolutionTestResultItem]) {
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
        }
    }

    public struct IntentOverride: AWSEncodableShape & AWSDecodableShape {
        /// The name of the intent. Only required when you're switching intents.
        public let name: String?
        /// A map of all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden.
        public let slots: [String: SlotValueOverride]?

        @inlinable
        public init(name: String? = nil, slots: [String: SlotValueOverride]? = nil) {
            self.name = name
            self.slots = slots
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.slots?.forEach {
                try validate($0.key, name: "slots.key", parent: name, max: 100)
                try validate($0.key, name: "slots.key", parent: name, min: 1)
                try validate($0.key, name: "slots.key", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
                try $0.value.validate(name: "\(name).slots[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case slots = "slots"
        }
    }

    public struct IntentSortBy: AWSEncodableShape {
        /// The attribute to use to sort the list of intents.
        public let attribute: IntentSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        @inlinable
        public init(attribute: IntentSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct IntentStatistics: AWSDecodableShape {
        /// The number of recommended intents associated with the bot recommendation.
        public let discoveredIntentCount: Int?

        @inlinable
        public init(discoveredIntentCount: Int? = nil) {
            self.discoveredIntentCount = discoveredIntentCount
        }

        private enum CodingKeys: String, CodingKey {
            case discoveredIntentCount = "discoveredIntentCount"
        }
    }

    public struct IntentSummary: AWSDecodableShape {
        /// The description of the intent.
        public let description: String?
        /// The input contexts that must be active for this intent to be considered for recognition.
        public let inputContexts: [InputContext]?
        /// The unique identifier assigned to the intent. Use this ID to get detailed information about the intent with the DescribeIntent operation.
        public let intentId: String?
        /// The name of the intent.
        public let intentName: String?
        /// The timestamp of the date and time that the intent was last updated.
        public let lastUpdatedDateTime: Date?
        /// The output contexts that are activated when this intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// If this intent is derived from a built-in intent, the name of the parent intent.
        public let parentIntentSignature: String?

        @inlinable
        public init(description: String? = nil, inputContexts: [InputContext]? = nil, intentId: String? = nil, intentName: String? = nil, lastUpdatedDateTime: Date? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil) {
            self.description = description
            self.inputContexts = inputContexts
            self.intentId = intentId
            self.intentName = intentName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputContexts = "inputContexts"
            case intentId = "intentId"
            case intentName = "intentName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
        }
    }

    public struct InvokedIntentSample: AWSDecodableShape {
        /// The name of an intent that was invoked.
        public let intentName: String?

        @inlinable
        public init(intentName: String? = nil) {
            self.intentName = intentName
        }

        private enum CodingKeys: String, CodingKey {
            case intentName = "intentName"
        }
    }

    public struct KendraConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the AMAZON.KendraSearchIntent intent to search. The index must be in the same account and Region as the Amazon Lex bot.
        public let kendraIndex: String
        /// A query filter that Amazon Lex sends to Amazon Kendra to filter the response from a query. The filter is in the format defined by Amazon Kendra. For more information, see Filtering queries.
        public let queryFilterString: String?
        /// Determines whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
        public let queryFilterStringEnabled: Bool?

        @inlinable
        public init(kendraIndex: String, queryFilterString: String? = nil, queryFilterStringEnabled: Bool? = nil) {
            self.kendraIndex = kendraIndex
            self.queryFilterString = queryFilterString
            self.queryFilterStringEnabled = queryFilterStringEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, max: 2048)
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, min: 32)
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, pattern: "^arn:aws:kendra:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:index\\/[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.queryFilterString, name: "queryFilterString", parent: name, max: 5000)
            try self.validate(self.queryFilterString, name: "queryFilterString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kendraIndex = "kendraIndex"
            case queryFilterString = "queryFilterString"
            case queryFilterStringEnabled = "queryFilterStringEnabled"
        }
    }

    public struct LambdaCodeHook: AWSEncodableShape & AWSDecodableShape {
        /// The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        public let codeHookInterfaceVersion: String
        /// The Amazon Resource Name (ARN) of the Lambda function.
        public let lambdaARN: String

        @inlinable
        public init(codeHookInterfaceVersion: String, lambdaARN: String) {
            self.codeHookInterfaceVersion = codeHookInterfaceVersion
            self.lambdaARN = lambdaARN
        }

        public func validate(name: String) throws {
            try self.validate(self.codeHookInterfaceVersion, name: "codeHookInterfaceVersion", parent: name, max: 5)
            try self.validate(self.codeHookInterfaceVersion, name: "codeHookInterfaceVersion", parent: name, min: 1)
            try self.validate(self.lambdaARN, name: "lambdaARN", parent: name, max: 2048)
            try self.validate(self.lambdaARN, name: "lambdaARN", parent: name, min: 20)
            try self.validate(self.lambdaARN, name: "lambdaARN", parent: name, pattern: "^arn:aws:lambda:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:function:[a-zA-Z0-9-_]+(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?(:[a-zA-Z0-9-_]+)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case codeHookInterfaceVersion = "codeHookInterfaceVersion"
            case lambdaARN = "lambdaARN"
        }
    }

    public struct LexTranscriptFilter: AWSEncodableShape & AWSDecodableShape {
        /// The object that contains a date range filter that will be applied to the transcript. Specify this object if you want Amazon Lex to only read the files that are within the date range.
        public let dateRangeFilter: DateRangeFilter?

        @inlinable
        public init(dateRangeFilter: DateRangeFilter? = nil) {
            self.dateRangeFilter = dateRangeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case dateRangeFilter = "dateRangeFilter"
        }
    }

    public struct ListAggregatedUtterancesRequest: AWSEncodableShape {
        /// The time window for aggregating the utterance information. You can specify a time between one hour and two weeks.
        public let aggregationDuration: UtteranceAggregationDuration
        /// The identifier of the bot alias associated with this request. If you specify the bot alias, you can't specify the bot version.
        public let botAliasId: String?
        /// The unique identifier of the bot associated with this request.
        public let botId: String
        /// The identifier of the bot version associated with this request. If you specify the bot version, you can't specify the bot alias.
        public let botVersion: String?
        /// Provides the specification of a filter used to limit the utterances in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
        public let filters: [AggregatedUtterancesFilter]?
        /// The identifier of the language and locale where the utterances were collected. For more information, see Supported languages.
        public let localeId: String
        /// The maximum number of utterances to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned. If you don't specify the maxResults parameter, 1,000 results are returned.
        public let maxResults: Int?
        /// If the response from the ListAggregatedUtterances operation contains more results that specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of utterances. You can sort by the hit count, the missed count, or the number of distinct sessions the utterance appeared in.
        public let sortBy: AggregatedUtterancesSortBy?

        @inlinable
        public init(aggregationDuration: UtteranceAggregationDuration, botAliasId: String? = nil, botId: String, botVersion: String? = nil, filters: [AggregatedUtterancesFilter]? = nil, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: AggregatedUtterancesSortBy? = nil) {
            self.aggregationDuration = aggregationDuration
            self.botAliasId = botAliasId
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.aggregationDuration, forKey: .aggregationDuration)
            try container.encodeIfPresent(self.botAliasId, forKey: .botAliasId)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.botVersion, forKey: .botVersion)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encode(self.localeId, forKey: .localeId)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.aggregationDuration.validate(name: "\(name).aggregationDuration")
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationDuration = "aggregationDuration"
            case botAliasId = "botAliasId"
            case botVersion = "botVersion"
            case filters = "filters"
            case localeId = "localeId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListAggregatedUtterancesResponse: AWSDecodableShape {
        /// Summaries of the aggregated utterance data. Each response contains information about the number of times that the utterance was seen during the time period, whether it was detected or missed, and when it was seen during the time period.
        public let aggregatedUtterancesSummaries: [AggregatedUtterancesSummary]?
        /// The time period used to aggregate the utterance data.
        public let aggregationDuration: UtteranceAggregationDuration?
        /// The last date and time that the aggregated data was collected. The time period depends on the length of the aggregation window.    Hours - for 1 hour time window, every half hour; otherwise every hour.    Days - every 6 hours    Weeks - for a one week time window, every 12 hours; otherwise, every day
        public let aggregationLastRefreshedDateTime: Date?
        /// The date and time that the aggregation window ends. Only data collected between the start time and the end time are returned in the results.
        public let aggregationWindowEndTime: Date?
        /// The date and time that the aggregation window begins. Only data collected after this time is returned in the results.
        public let aggregationWindowStartTime: Date?
        /// The identifier of the bot alias that contains the utterances. If you specified the bot version, the bot alias ID isn't returned.
        public let botAliasId: String?
        /// The identifier of the bot that contains the utterances.
        public let botId: String?
        /// The identifier of the bot version that contains the utterances. If you specified the bot alias, the bot version isn't returned.
        public let botVersion: String?
        /// The identifier of the language and locale that the utterances are in.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListAggregatedUtterances operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListAggregatedUtterances operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(aggregatedUtterancesSummaries: [AggregatedUtterancesSummary]? = nil, aggregationDuration: UtteranceAggregationDuration? = nil, aggregationLastRefreshedDateTime: Date? = nil, aggregationWindowEndTime: Date? = nil, aggregationWindowStartTime: Date? = nil, botAliasId: String? = nil, botId: String? = nil, botVersion: String? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.aggregatedUtterancesSummaries = aggregatedUtterancesSummaries
            self.aggregationDuration = aggregationDuration
            self.aggregationLastRefreshedDateTime = aggregationLastRefreshedDateTime
            self.aggregationWindowEndTime = aggregationWindowEndTime
            self.aggregationWindowStartTime = aggregationWindowStartTime
            self.botAliasId = botAliasId
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedUtterancesSummaries = "aggregatedUtterancesSummaries"
            case aggregationDuration = "aggregationDuration"
            case aggregationLastRefreshedDateTime = "aggregationLastRefreshedDateTime"
            case aggregationWindowEndTime = "aggregationWindowEndTime"
            case aggregationWindowStartTime = "aggregationWindowStartTime"
            case botAliasId = "botAliasId"
            case botId = "botId"
            case botVersion = "botVersion"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotAliasReplicasRequest: AWSEncodableShape {
        /// The request for the unique bot ID of the replicated bot created from the source bot alias.
        public let botId: String
        /// The request for maximum results to list the replicated bots created from the source bot alias.
        public let maxResults: Int?
        /// The request for the next token for the replicated bot created from the source bot alias.
        public let nextToken: String?
        /// The request for the secondary region of the replicated bot created from the source bot alias.
        public let replicaRegion: String

        @inlinable
        public init(botId: String, maxResults: Int? = nil, nextToken: String? = nil, replicaRegion: String) {
            self.botId = botId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicaRegion = replicaRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.replicaRegion, key: "replicaRegion")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, max: 25)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotAliasReplicasResponse: AWSDecodableShape {
        /// The summary information of the replicated bot created from the source bot alias.
        public let botAliasReplicaSummaries: [BotAliasReplicaSummary]?
        /// The unique bot ID of the replicated bot created from the source bot alias.
        public let botId: String?
        /// The next token for the replicated bots created from the source bot alias.
        public let nextToken: String?
        /// The secondary region of the replicated bot created from the source bot alias.
        public let replicaRegion: String?
        /// The source region of the replicated bot created from the source bot alias.
        public let sourceRegion: String?

        @inlinable
        public init(botAliasReplicaSummaries: [BotAliasReplicaSummary]? = nil, botId: String? = nil, nextToken: String? = nil, replicaRegion: String? = nil, sourceRegion: String? = nil) {
            self.botAliasReplicaSummaries = botAliasReplicaSummaries
            self.botId = botId
            self.nextToken = nextToken
            self.replicaRegion = replicaRegion
            self.sourceRegion = sourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasReplicaSummaries = "botAliasReplicaSummaries"
            case botId = "botId"
            case nextToken = "nextToken"
            case replicaRegion = "replicaRegion"
            case sourceRegion = "sourceRegion"
        }
    }

    public struct ListBotAliasesRequest: AWSEncodableShape {
        /// The identifier of the bot to list aliases for.
        public let botId: String
        /// The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBotAliases operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotAliasesResponse: AWSDecodableShape {
        /// Summary information for the bot aliases that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more aliases available, the nextToken field contains a token to get the next page of results.
        public let botAliasSummaries: [BotAliasSummary]?
        /// The identifier of the bot associated with the aliases.
        public let botId: String?
        /// A token that indicates whether there are more results to return in a response to the ListBotAliases operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botAliasSummaries: [BotAliasSummary]? = nil, botId: String? = nil, nextToken: String? = nil) {
            self.botAliasSummaries = botAliasSummaries
            self.botId = botId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasSummaries = "botAliasSummaries"
            case botId = "botId"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotLocalesRequest: AWSEncodableShape {
        /// The identifier of the bot to list locales for.
        public let botId: String
        /// The version of the bot to list locales for.
        public let botVersion: String
        /// Provides the specification for a filter used to limit the response to only those locales that match the filter specification. You can only specify one filter and one value to filter on.
        public let filters: [BotLocaleFilter]?
        /// The maximum number of aliases to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBotLocales operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token as the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of locales. You can sort by locale name in ascending or descending order.
        public let sortBy: BotLocaleSortBy?

        @inlinable
        public init(botId: String, botVersion: String, filters: [BotLocaleFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BotLocaleSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotLocalesResponse: AWSDecodableShape {
        /// The identifier of the bot to list locales for.
        public let botId: String?
        /// Summary information for the locales that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more locales available, the nextToken field contains a token to get the next page of results.
        public let botLocaleSummaries: [BotLocaleSummary]?
        /// The version of the bot.
        public let botVersion: String?
        /// A token that indicates whether there are more results to return in a response to the ListBotLocales operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotLocales operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botLocaleSummaries: [BotLocaleSummary]? = nil, botVersion: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botLocaleSummaries = botLocaleSummaries
            self.botVersion = botVersion
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleSummaries = "botLocaleSummaries"
            case botVersion = "botVersion"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotRecommendationsRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the bot recommendation list.
        public let botId: String
        /// The version of the bot that contains the bot recommendation list.
        public let botVersion: String
        /// The identifier of the language and locale of the bot recommendation list.
        public let localeId: String
        /// The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBotRecommendation operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String, botVersion: String, localeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotRecommendationsResponse: AWSDecodableShape {
        /// The unique identifier of the bot that contains the bot recommendation list.
        public let botId: String?
        /// Summary information for the bot recommendations that meet the filter specified in this request. The length of the list is specified in the maxResults parameter of the request. If there are more bot recommendations available, the nextToken field contains a token to get the next page of results.
        public let botRecommendationSummaries: [BotRecommendationSummary]?
        /// The version of the bot that contains the bot recommendation list.
        public let botVersion: String?
        /// The identifier of the language and locale of the bot recommendation list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListBotRecommendations operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotRecommendations operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botRecommendationSummaries: [BotRecommendationSummary]? = nil, botVersion: String? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botRecommendationSummaries = botRecommendationSummaries
            self.botVersion = botVersion
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botRecommendationSummaries = "botRecommendationSummaries"
            case botVersion = "botVersion"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotReplicasRequest: AWSEncodableShape {
        /// The request for the unique bot IDs in the list of replicated bots.
        public let botId: String

        @inlinable
        public init(botId: String) {
            self.botId = botId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBotReplicasResponse: AWSDecodableShape {
        /// the unique bot IDs in the list of replicated bots.
        public let botId: String?
        /// The summary details for the replicated bots.
        public let botReplicaSummaries: [BotReplicaSummary]?
        /// The source region of the source bots in the list of replicated bots.
        public let sourceRegion: String?

        @inlinable
        public init(botId: String? = nil, botReplicaSummaries: [BotReplicaSummary]? = nil, sourceRegion: String? = nil) {
            self.botId = botId
            self.botReplicaSummaries = botReplicaSummaries
            self.sourceRegion = sourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botReplicaSummaries = "botReplicaSummaries"
            case sourceRegion = "sourceRegion"
        }
    }

    public struct ListBotResourceGenerationsRequest: AWSEncodableShape {
        /// The unique identifier of the bot whose generation  requests you want to view.
        public let botId: String
        /// The version of the bot whose generation  requests you want to view.
        public let botVersion: String
        /// The locale of the bot whose generation  requests you want to view.
        public let localeId: String
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// If the total number of results is greater than the number  specified in the maxResults, the response returns a token  in the nextToken field. Use this token when making a request to  return the next batch of results.
        public let nextToken: String?
        /// An object containing information about the attribute and the  method by which to sort the results
        public let sortBy: GenerationSortBy?

        @inlinable
        public init(botId: String, botVersion: String, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: GenerationSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotResourceGenerationsResponse: AWSDecodableShape {
        /// The unique identifier of the bot for which the generation requests were made.
        public let botId: String?
        /// The version of the bot for which the generation requests were made.
        public let botVersion: String?
        /// A list of objects, each containing information about a generation request for the bot locale.
        public let generationSummaries: [GenerationSummary]?
        /// The locale of the bot for which the generation requests were made.
        public let localeId: String?
        /// If the total number of results is greater than the number  specified in the maxResults, the response returns a token  in the nextToken field. Use this token when making a request to  return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, generationSummaries: [GenerationSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.generationSummaries = generationSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case generationSummaries = "generationSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotVersionReplicasRequest: AWSEncodableShape {
        /// The request for the unique ID in the list of replicated bots.
        public let botId: String
        /// The maximum results given in the list of replicated bots.
        public let maxResults: Int?
        /// The next token given in the list of replicated bots.
        public let nextToken: String?
        /// The request for the region used in the list of replicated bots.
        public let replicaRegion: String
        /// The requested sort category for the list of replicated bots.
        public let sortBy: BotVersionReplicaSortBy?

        @inlinable
        public init(botId: String, maxResults: Int? = nil, nextToken: String? = nil, replicaRegion: String, sortBy: BotVersionReplicaSortBy? = nil) {
            self.botId = botId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicaRegion = replicaRegion
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.replicaRegion, key: "replicaRegion")
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, max: 25)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotVersionReplicasResponse: AWSDecodableShape {
        /// The unique ID of the bots in the list of replicated bots.
        public let botId: String?
        /// The information summary used for the replicated bots in the list of replicated bots.
        public let botVersionReplicaSummaries: [BotVersionReplicaSummary]?
        /// The next token used for the replicated bots in the list of replicated bots.
        public let nextToken: String?
        /// The region used for the replicated bots in the list of replicated bots.
        public let replicaRegion: String?
        /// The source region used for the bots in the list of replicated bots.
        public let sourceRegion: String?

        @inlinable
        public init(botId: String? = nil, botVersionReplicaSummaries: [BotVersionReplicaSummary]? = nil, nextToken: String? = nil, replicaRegion: String? = nil, sourceRegion: String? = nil) {
            self.botId = botId
            self.botVersionReplicaSummaries = botVersionReplicaSummaries
            self.nextToken = nextToken
            self.replicaRegion = replicaRegion
            self.sourceRegion = sourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersionReplicaSummaries = "botVersionReplicaSummaries"
            case nextToken = "nextToken"
            case replicaRegion = "replicaRegion"
            case sourceRegion = "sourceRegion"
        }
    }

    public struct ListBotVersionsRequest: AWSEncodableShape {
        /// The identifier of the bot to list versions for.
        public let botId: String
        /// The maximum number of versions to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response to the ListBotVersion operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of versions. You can specify that the list be sorted by version name in either ascending or descending order.
        public let sortBy: BotVersionSortBy?

        @inlinable
        public init(botId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BotVersionSortBy? = nil) {
            self.botId = botId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotVersionsResponse: AWSDecodableShape {
        /// The identifier of the bot to list versions for.
        public let botId: String?
        /// Summary information for the bot versions that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more versions available, the nextToken field contains a token to get the next page of results.
        public let botVersionSummaries: [BotVersionSummary]?
        /// A token that indicates whether there are more results to return in a response to the ListBotVersions operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botVersionSummaries: [BotVersionSummary]? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersionSummaries = botVersionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersionSummaries = "botVersionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBotsRequest: AWSEncodableShape {
        /// Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
        public let filters: [BotFilter]?
        /// The maximum number of bots to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBots operation contains more results than specified in the maxResults parameter, a token is returned in the response.  Use the returned token in the nextToken parameter of a ListBots request to return the next page of results. For a complete set of results, call the ListBots operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of bots. You can specify that the list be sorted by bot name in ascending or descending order.
        public let sortBy: BotSortBy?

        @inlinable
        public init(filters: [BotFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BotSortBy? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 2)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBotsResponse: AWSDecodableShape {
        /// Summary information for the bots that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more bots available, the nextToken field contains a token to the next page of results.
        public let botSummaries: [BotSummary]?
        /// A token that indicates whether there are more results to return in a response to the ListBots operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBots operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botSummaries: [BotSummary]? = nil, nextToken: String? = nil) {
            self.botSummaries = botSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botSummaries = "botSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBuiltInIntentsRequest: AWSEncodableShape {
        /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The maximum number of built-in intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBuiltInIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Specifies sorting parameters for the list of built-in intents. You can specify that the list be sorted by the built-in intent signature in either ascending or descending order.
        public let sortBy: BuiltInIntentSortBy?

        @inlinable
        public init(localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BuiltInIntentSortBy? = nil) {
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBuiltInIntentsResponse: AWSDecodableShape {
        /// Summary information for the built-in intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
        public let builtInIntentSummaries: [BuiltInIntentSummary]?
        /// The language and locale of the intents in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListBuiltInIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListBotAliases operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(builtInIntentSummaries: [BuiltInIntentSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.builtInIntentSummaries = builtInIntentSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case builtInIntentSummaries = "builtInIntentSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListBuiltInSlotTypesRequest: AWSEncodableShape {
        /// The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The maximum number of built-in slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListBuiltInSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListBuiltInSlotTypes operation. You can choose to sort by the slot type signature in either ascending or descending order.
        public let sortBy: BuiltInSlotTypeSortBy?

        @inlinable
        public init(localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: BuiltInSlotTypeSortBy? = nil) {
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListBuiltInSlotTypesResponse: AWSDecodableShape {
        /// Summary information for the built-in slot types that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slot types available, the nextToken field contains a token to get the next page of results.
        public let builtInSlotTypeSummaries: [BuiltInSlotTypeSummary]?
        /// The language and locale of the slot types in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListBuiltInSlotTypes operation. If the nextToken field is present, you send the contents as the nextToken parameter of a LIstBuiltInSlotTypes operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(builtInSlotTypeSummaries: [BuiltInSlotTypeSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.builtInSlotTypeSummaries = builtInSlotTypeSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case builtInSlotTypeSummaries = "builtInSlotTypeSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListCustomVocabularyItemsRequest: AWSEncodableShape {
        /// The identifier of the version of the bot associated with this custom  vocabulary.
        public let botId: String
        /// The bot version of the bot to the list custom vocabulary  request.
        public let botVersion: String
        /// The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see Supported  languages (https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html).
        public let localeId: String
        /// The maximum number of items returned by the list operation.
        public let maxResults: Int?
        /// The nextToken identifier to the list custom vocabulary  request.
        public let nextToken: String?

        @inlinable
        public init(botId: String, botVersion: String, localeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCustomVocabularyItemsResponse: AWSDecodableShape {
        /// The identifier of the bot associated with this custom vocabulary.
        public let botId: String?
        /// The identifier of the version of the bot associated with this custom  vocabulary.
        public let botVersion: String?
        /// The custom vocabulary items from the list custom vocabulary  response.
        public let customVocabularyItems: [CustomVocabularyItem]?
        /// The identifier of the language and locale where this custom vocabulary  is used. The string must match one of the supported locales. For more  information, see  Supported Languages .
        public let localeId: String?
        /// The nextToken identifier to the list custom vocabulary  response.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, customVocabularyItems: [CustomVocabularyItem]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.customVocabularyItems = customVocabularyItems
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case customVocabularyItems = "customVocabularyItems"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListExportsRequest: AWSEncodableShape {
        /// The unique identifier that Amazon Lex assigned to the bot.
        public let botId: String?
        /// The version of the bot to list exports for.
        public let botVersion: String?
        /// Provides the specification of a filter used to limit the exports in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
        public let filters: [ExportFilter]?
        /// Specifies the resources that should be exported. If you don't specify a resource type in the filters parameter, both bot locales and custom vocabularies are exported.
        public let localeId: String?
        /// The maximum number of exports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListExports operation contains more results that specified in the maxResults parameter, a token is returned in the response.  Use the returned token in the nextToken parameter of a ListExports request to return the next page of results. For a complete set of results, call the ListExports operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// Determines the field that the list of exports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
        public let sortBy: ExportSortBy?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, filters: [ExportFilter]? = nil, localeId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: ExportSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case filters = "filters"
            case localeId = "localeId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListExportsResponse: AWSDecodableShape {
        /// The unique identifier assigned to the bot by Amazon Lex.
        public let botId: String?
        /// The version of the bot that was exported.
        public let botVersion: String?
        /// Summary information for the exports that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter. If there are more exports available, the nextToken field contains a token to get the next page of results.
        public let exportSummaries: [ExportSummary]?
        /// The locale specified in the request.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListExports operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListExports operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, exportSummaries: [ExportSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.exportSummaries = exportSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case exportSummaries = "exportSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportsRequest: AWSEncodableShape {
        /// The unique identifier that Amazon Lex assigned to the bot.
        public let botId: String?
        /// The version of the bot to list imports for.
        public let botVersion: String?
        /// Provides the specification of a filter used to limit the bots in the response to only those that match the filter specification. You can only specify one filter and one string to filter on.
        public let filters: [ImportFilter]?
        /// Specifies the locale that should be present in the list. If you don't specify a resource type in the filters parameter, the list contains both bot locales and custom vocabularies.
        public let localeId: String?
        /// The maximum number of imports to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListImports operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListImports request to return the next page of results. For a complete set of results, call the ListImports operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// Determines the field that the list of imports is sorted by. You can sort by the LastUpdatedDateTime field in ascending or descending order.
        public let sortBy: ImportSortBy?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, filters: [ImportFilter]? = nil, localeId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: ImportSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case filters = "filters"
            case localeId = "localeId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListImportsResponse: AWSDecodableShape {
        /// The unique identifier assigned by Amazon Lex to the bot.
        public let botId: String?
        /// The version of the bot that was imported. It will always be DRAFT.
        public let botVersion: String?
        /// Summary information for the imports that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter. If there are more imports available, the nextToken field contains a token to get the next page of results.
        public let importSummaries: [ImportSummary]?
        /// The locale specified in the request.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListImports operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListImports operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, importSummaries: [ImportSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.importSummaries = importSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case importSummaries = "importSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListIntentMetricsRequest: AWSEncodableShape {
        /// A list of objects, each of which contains specifications for organizing the results by time.
        public let binBy: [AnalyticsBinBySpecification]?
        /// The identifier for the bot for which you want to retrieve intent metrics.
        public let botId: String
        /// The date and time that marks the end of the range of time for which you want to see intent metrics.
        public let endDateTime: Date
        /// A list of objects, each of which describes a condition by which you want to filter the results.
        public let filters: [AnalyticsIntentFilter]?
        /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:    IntentName – The name of the intent.    IntentEndState – The final state of the intent. The possible end states are detailed in Key definitions in the user guide.
        public let groupBy: [AnalyticsIntentGroupBySpecification]?
        /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the order by which to organize the results.
        public let metrics: [AnalyticsIntentMetric]
        /// If the response from the ListIntentMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentMetrics request to return the next page of results. For a complete set of results, call the ListIntentMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The timestamp that marks the beginning of the range of time for which you want to see intent metrics.
        public let startDateTime: Date

        @inlinable
        public init(binBy: [AnalyticsBinBySpecification]? = nil, botId: String, endDateTime: Date, filters: [AnalyticsIntentFilter]? = nil, groupBy: [AnalyticsIntentGroupBySpecification]? = nil, maxResults: Int? = nil, metrics: [AnalyticsIntentMetric], nextToken: String? = nil, startDateTime: Date) {
            self.binBy = binBy
            self.botId = botId
            self.endDateTime = endDateTime
            self.filters = filters
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextToken = nextToken
            self.startDateTime = startDateTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.binBy, forKey: .binBy)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.groupBy, forKey: .groupBy)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encode(self.metrics, forKey: .metrics)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.startDateTime, forKey: .startDateTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.binBy, name: "binBy", parent: name, max: 1)
            try self.validate(self.binBy, name: "binBy", parent: name, min: 1)
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 9)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 3)
            try self.validate(self.groupBy, name: "groupBy", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metrics, name: "metrics", parent: name, max: 5)
            try self.validate(self.metrics, name: "metrics", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case binBy = "binBy"
            case endDateTime = "endDateTime"
            case filters = "filters"
            case groupBy = "groupBy"
            case maxResults = "maxResults"
            case metrics = "metrics"
            case nextToken = "nextToken"
            case startDateTime = "startDateTime"
        }
    }

    public struct ListIntentMetricsResponse: AWSDecodableShape {
        /// The identifier for the bot for which you retrieved intent metrics.
        public let botId: String?
        /// If the response from the ListIntentMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentMetrics request to return the next page of results. For a complete set of results, call the ListIntentMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The results for the intent metrics.
        public let results: [AnalyticsIntentResult]?

        @inlinable
        public init(botId: String? = nil, nextToken: String? = nil, results: [AnalyticsIntentResult]? = nil) {
            self.botId = botId
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct ListIntentPathsRequest: AWSEncodableShape {
        /// The identifier for the bot for which you want to retrieve intent path metrics.
        public let botId: String
        /// The date and time that marks the end of the range of time for which you want to see intent path metrics.
        public let endDateTime: Date
        /// A list of objects, each describes a condition by which you want to filter the results.
        public let filters: [AnalyticsPathFilter]?
        /// The intent path for which you want to retrieve metrics. Use a forward slash to separate intents in the path. For example:   /BookCar   /BookCar/BookHotel   /BookHotel/BookCar
        public let intentPath: String
        /// The date and time that marks the beginning of the range of time for which you want to see intent path metrics.
        public let startDateTime: Date

        @inlinable
        public init(botId: String, endDateTime: Date, filters: [AnalyticsPathFilter]? = nil, intentPath: String, startDateTime: Date) {
            self.botId = botId
            self.endDateTime = endDateTime
            self.filters = filters
            self.intentPath = intentPath
            self.startDateTime = startDateTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encode(self.intentPath, forKey: .intentPath)
            try container.encode(self.startDateTime, forKey: .startDateTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 5)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.intentPath, name: "intentPath", parent: name, max: 1024)
            try self.validate(self.intentPath, name: "intentPath", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endDateTime = "endDateTime"
            case filters = "filters"
            case intentPath = "intentPath"
            case startDateTime = "startDateTime"
        }
    }

    public struct ListIntentPathsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains information about a node in the intent path for which you requested metrics.
        public let nodeSummaries: [AnalyticsIntentNodeSummary]?

        @inlinable
        public init(nodeSummaries: [AnalyticsIntentNodeSummary]? = nil) {
            self.nodeSummaries = nodeSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nodeSummaries = "nodeSummaries"
        }
    }

    public struct ListIntentStageMetricsRequest: AWSEncodableShape {
        /// A list of objects, each of which contains specifications for organizing the results by time.
        public let binBy: [AnalyticsBinBySpecification]?
        /// The identifier for the bot for which you want to retrieve intent stage metrics.
        public let botId: String
        /// The date and time that marks the end of the range of time for which you want to see intent stage metrics.
        public let endDateTime: Date
        /// A list of objects, each of which describes a condition by which you want to filter the results.
        public let filters: [AnalyticsIntentStageFilter]?
        /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:    IntentStageName – The name of the intent stage.    SwitchedToIntent – The intent to which the conversation was switched (if any).
        public let groupBy: [AnalyticsIntentStageGroupBySpecification]?
        /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public let metrics: [AnalyticsIntentStageMetric]
        /// If the response from the ListIntentStageMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentStageMetrics request to return the next page of results. For a complete set of results, call the ListIntentStageMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The date and time that marks the beginning of the range of time for which you want to see intent stage metrics.
        public let startDateTime: Date

        @inlinable
        public init(binBy: [AnalyticsBinBySpecification]? = nil, botId: String, endDateTime: Date, filters: [AnalyticsIntentStageFilter]? = nil, groupBy: [AnalyticsIntentStageGroupBySpecification]? = nil, maxResults: Int? = nil, metrics: [AnalyticsIntentStageMetric], nextToken: String? = nil, startDateTime: Date) {
            self.binBy = binBy
            self.botId = botId
            self.endDateTime = endDateTime
            self.filters = filters
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextToken = nextToken
            self.startDateTime = startDateTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.binBy, forKey: .binBy)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.groupBy, forKey: .groupBy)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encode(self.metrics, forKey: .metrics)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.startDateTime, forKey: .startDateTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.binBy, name: "binBy", parent: name, max: 1)
            try self.validate(self.binBy, name: "binBy", parent: name, min: 1)
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 9)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 2)
            try self.validate(self.groupBy, name: "groupBy", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metrics, name: "metrics", parent: name, max: 5)
            try self.validate(self.metrics, name: "metrics", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case binBy = "binBy"
            case endDateTime = "endDateTime"
            case filters = "filters"
            case groupBy = "groupBy"
            case maxResults = "maxResults"
            case metrics = "metrics"
            case nextToken = "nextToken"
            case startDateTime = "startDateTime"
        }
    }

    public struct ListIntentStageMetricsResponse: AWSDecodableShape {
        /// The identifier for the bot for which you retrieved intent stage metrics.
        public let botId: String?
        /// If the response from the ListIntentStageMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntentStageMetrics request to return the next page of results. For a complete set of results, call the ListIntentStageMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The results for the intent stage metrics.
        public let results: [AnalyticsIntentStageResult]?

        @inlinable
        public init(botId: String? = nil, nextToken: String? = nil, results: [AnalyticsIntentStageResult]? = nil) {
            self.botId = botId
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct ListIntentsRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the intent.
        public let botId: String
        /// The version of the bot that contains the intent.
        public let botVersion: String
        /// Provides the specification of a filter used to limit the intents in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
        public let filters: [IntentFilter]?
        /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The maximum number of intents to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListIntents request to return the next page of results. For a complete set of results, call the ListIntents operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListIntents operation. You can choose to sort by the intent name or last updated date in either ascending or descending order.
        public let sortBy: IntentSortBy?

        @inlinable
        public init(botId: String, botVersion: String, filters: [IntentFilter]? = nil, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: IntentSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListIntentsResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the intent.
        public let botId: String?
        /// The version of the bot that contains the intent.
        public let botVersion: String?
        /// Summary information for the intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
        public let intentSummaries: [IntentSummary]?
        /// The language and locale of the intents in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListIntents operation request to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, intentSummaries: [IntentSummary]? = nil, localeId: String? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentSummaries = intentSummaries
            self.localeId = localeId
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case intentSummaries = "intentSummaries"
            case localeId = "localeId"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendedIntentsRequest: AWSEncodableShape {
        /// The unique identifier of the bot associated with the recommended intents.
        public let botId: String
        /// The identifier of the bot recommendation that contains the recommended intents.
        public let botRecommendationId: String
        /// The version of the bot that contains the recommended intents.
        public let botVersion: String
        /// The identifier of the language and locale of the recommended intents.
        public let localeId: String
        /// The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListRecommendedIntents operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?

        @inlinable
        public init(botId: String, botRecommendationId: String, botVersion: String, localeId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botVersion = botVersion
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botRecommendationId, key: "botRecommendationId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, max: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, min: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecommendedIntentsResponse: AWSDecodableShape {
        /// The unique identifier of the bot associated with the recommended intent.
        public let botId: String?
        /// The identifier of the bot recommendation that contains the recommended intent.
        public let botRecommendationId: String?
        /// The version of the bot that contains the intent.
        public let botVersion: String?
        /// The identifier of the language and locale of the intents to list. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListRecommendedIntents operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListRecommendedIntents operation request to get the next page of results.
        public let nextToken: String?
        /// Summary information for the intents that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more intents available, the nextToken field contains a token to get the next page of results.
        public let summaryList: [RecommendedIntentSummary]?

        @inlinable
        public init(botId: String? = nil, botRecommendationId: String? = nil, botVersion: String? = nil, localeId: String? = nil, nextToken: String? = nil, summaryList: [RecommendedIntentSummary]? = nil) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botVersion = botVersion
            self.localeId = localeId
            self.nextToken = nextToken
            self.summaryList = summaryList
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botRecommendationId = "botRecommendationId"
            case botVersion = "botVersion"
            case localeId = "localeId"
            case nextToken = "nextToken"
            case summaryList = "summaryList"
        }
    }

    public struct ListSessionAnalyticsDataRequest: AWSEncodableShape {
        /// The identifier for the bot for which you want to retrieve session analytics.
        public let botId: String
        /// The date and time that marks the end of the range of time for which you want to see session analytics.
        public let endDateTime: Date
        /// A list of objects, each of which describes a condition by which you want to filter the results.
        public let filters: [AnalyticsSessionFilter]?
        /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListSessionAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionAnalyticsData request to return the next page of results. For a complete set of results, call the ListSessionAnalyticsData operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// An object specifying the measure and method by which to sort the session analytics data.
        public let sortBy: SessionDataSortBy?
        /// The date and time that marks the beginning of the range of time for which you want to see session analytics.
        public let startDateTime: Date

        @inlinable
        public init(botId: String, endDateTime: Date, filters: [AnalyticsSessionFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SessionDataSortBy? = nil, startDateTime: Date) {
            self.botId = botId
            self.endDateTime = endDateTime
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.startDateTime = startDateTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
            try container.encode(self.startDateTime, forKey: .startDateTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endDateTime = "endDateTime"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
            case startDateTime = "startDateTime"
        }
    }

    public struct ListSessionAnalyticsDataResponse: AWSDecodableShape {
        /// The unique identifier of the bot that the sessions belong to.
        public let botId: String?
        /// If the response from the ListSessionAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionAnalyticsData request to return the next page of results. For a complete set of results, call the ListSessionAnalyticsData operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// A list of objects, each of which contains information about a session with the bot.
        public let sessions: [SessionSpecification]?

        @inlinable
        public init(botId: String? = nil, nextToken: String? = nil, sessions: [SessionSpecification]? = nil) {
            self.botId = botId
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case nextToken = "nextToken"
            case sessions = "sessions"
        }
    }

    public struct ListSessionMetricsRequest: AWSEncodableShape {
        /// A list of objects, each of which contains specifications for organizing the results by time.
        public let binBy: [AnalyticsBinBySpecification]?
        /// The identifier for the bot for which you want to retrieve session metrics.
        public let botId: String
        /// The date and time that marks the end of the range of time for which you want to see session metrics.
        public let endDateTime: Date
        /// A list of objects, each of which describes a condition by which you want to filter the results.
        public let filters: [AnalyticsSessionFilter]?
        /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:    ConversationEndState – The final state of the conversation. The possible end states are detailed in Key definitions in the user guide.    LocaleId – The unique identifier of the bot locale.
        public let groupBy: [AnalyticsSessionGroupBySpecification]?
        /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public let metrics: [AnalyticsSessionMetric]
        /// If the response from the ListSessionMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionMetrics request to return the next page of results. For a complete set of results, call the ListSessionMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The date and time that marks the beginning of the range of time for which you want to see session metrics.
        public let startDateTime: Date

        @inlinable
        public init(binBy: [AnalyticsBinBySpecification]? = nil, botId: String, endDateTime: Date, filters: [AnalyticsSessionFilter]? = nil, groupBy: [AnalyticsSessionGroupBySpecification]? = nil, maxResults: Int? = nil, metrics: [AnalyticsSessionMetric], nextToken: String? = nil, startDateTime: Date) {
            self.binBy = binBy
            self.botId = botId
            self.endDateTime = endDateTime
            self.filters = filters
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextToken = nextToken
            self.startDateTime = startDateTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.binBy, forKey: .binBy)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.groupBy, forKey: .groupBy)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encode(self.metrics, forKey: .metrics)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.startDateTime, forKey: .startDateTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.binBy, name: "binBy", parent: name, max: 1)
            try self.validate(self.binBy, name: "binBy", parent: name, min: 1)
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 2)
            try self.validate(self.groupBy, name: "groupBy", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metrics, name: "metrics", parent: name, max: 7)
            try self.validate(self.metrics, name: "metrics", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case binBy = "binBy"
            case endDateTime = "endDateTime"
            case filters = "filters"
            case groupBy = "groupBy"
            case maxResults = "maxResults"
            case metrics = "metrics"
            case nextToken = "nextToken"
            case startDateTime = "startDateTime"
        }
    }

    public struct ListSessionMetricsResponse: AWSDecodableShape {
        /// The identifier for the bot for which you retrieved session metrics.
        public let botId: String?
        /// If the response from the ListSessionMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListSessionMetrics request to return the next page of results. For a complete set of results, call the ListSessionMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The results for the session metrics.
        public let results: [AnalyticsSessionResult]?

        @inlinable
        public init(botId: String? = nil, nextToken: String? = nil, results: [AnalyticsSessionResult]? = nil) {
            self.botId = botId
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct ListSlotTypesRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the slot types.
        public let botId: String
        /// The version of the bot that contains the slot type.
        public let botVersion: String
        /// Provides the specification of a filter used to limit the slot types in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
        public let filters: [SlotTypeFilter]?
        /// The identifier of the language and locale of the slot types to list. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The maximum number of slot types to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListSlotTypes operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListSlotTypes operation. You can choose to sort by the slot type name or last updated date in either ascending or descending order.
        public let sortBy: SlotTypeSortBy?

        @inlinable
        public init(botId: String, botVersion: String, filters: [SlotTypeFilter]? = nil, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SlotTypeSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListSlotTypesResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the slot types.
        public let botId: String?
        /// The version of the bot that contains the slot types.
        public let botVersion: String?
        /// The language and local of the slot types in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListSlotTypes operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListSlotTypes operation request to get the next page of results.
        public let nextToken: String?
        /// Summary information for the slot types that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slot types available, the nextToken field contains a token to get the next page of results.
        public let slotTypeSummaries: [SlotTypeSummary]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, localeId: String? = nil, nextToken: String? = nil, slotTypeSummaries: [SlotTypeSummary]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.localeId = localeId
            self.nextToken = nextToken
            self.slotTypeSummaries = slotTypeSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case localeId = "localeId"
            case nextToken = "nextToken"
            case slotTypeSummaries = "slotTypeSummaries"
        }
    }

    public struct ListSlotsRequest: AWSEncodableShape {
        /// The identifier of the bot that contains the slot.
        public let botId: String
        /// The version of the bot that contains the slot.
        public let botVersion: String
        /// Provides the specification of a filter used to limit the slots in the response to only those that match the filter specification. You can only specify one filter and only one string to filter on.
        public let filters: [SlotFilter]?
        /// The unique identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale of the slots to list. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The maximum number of slots to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListSlots operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// Determines the sort order for the response from the ListSlots operation. You can choose to sort by the slot name or last updated date in either ascending or descending order.
        public let sortBy: SlotSortBy?

        @inlinable
        public init(botId: String, botVersion: String, filters: [SlotFilter]? = nil, intentId: String, localeId: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SlotSortBy? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.filters = filters
            self.intentId = intentId
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            request.encodePath(self.intentId, key: "intentId")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListSlotsResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the slots.
        public let botId: String?
        /// The version of the bot that contains the slots.
        public let botVersion: String?
        /// The identifier of the intent that contains the slots.
        public let intentId: String?
        /// The language and locale of the slots in the list.
        public let localeId: String?
        /// A token that indicates whether there are more results to return in a response to the ListSlots operation. If the nextToken field is present, you send the contents as the nextToken parameter of a ListSlots operation request to get the next page of results.
        public let nextToken: String?
        /// Summary information for the slots that meet the filter criteria specified in the request. The length of the list is specified in the maxResults parameter of the request. If there are more slots available, the nextToken field contains a token to get the next page of results.
        public let slotSummaries: [SlotSummary]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, intentId: String? = nil, localeId: String? = nil, nextToken: String? = nil, slotSummaries: [SlotSummary]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.intentId = intentId
            self.localeId = localeId
            self.nextToken = nextToken
            self.slotSummaries = slotSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case intentId = "intentId"
            case localeId = "localeId"
            case nextToken = "nextToken"
            case slotSummaries = "slotSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to get a list of tags for.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with a resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTestExecutionResultItemsRequest: AWSEncodableShape {
        /// The maximum number of test execution result items to return in each  page. If there are fewer results than the max page size, only the actual  number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListTestExecutionResultItems operation  contains more results than specified in the maxResults parameter,  a token is returned in the response. Use that token in the nextToken  parameter to return the next page of results.
        public let nextToken: String?
        /// The filter for the list of results from the test set execution.
        public let resultFilterBy: TestExecutionResultFilterBy
        /// The unique identifier of the test execution to list the result items.
        public let testExecutionId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resultFilterBy: TestExecutionResultFilterBy, testExecutionId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resultFilterBy = resultFilterBy
            self.testExecutionId = testExecutionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.resultFilterBy, forKey: .resultFilterBy)
            request.encodePath(self.testExecutionId, key: "testExecutionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, max: 10)
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, min: 10)
            try self.validate(self.testExecutionId, name: "testExecutionId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resultFilterBy = "resultFilterBy"
        }
    }

    public struct ListTestExecutionResultItemsResponse: AWSDecodableShape {
        /// A token that indicates whether there are more results to return in a response to the ListTestExecutionResultItems operation. If the  nextToken field is present, you send the contents as the  nextToken parameter of a ListTestExecutionResultItems  operation request to get the next page of results.
        public let nextToken: String?
        /// The list of results from the test execution.
        public let testExecutionResults: TestExecutionResultItems?

        @inlinable
        public init(nextToken: String? = nil, testExecutionResults: TestExecutionResultItems? = nil) {
            self.nextToken = nextToken
            self.testExecutionResults = testExecutionResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testExecutionResults = "testExecutionResults"
        }
    }

    public struct ListTestExecutionsRequest: AWSEncodableShape {
        /// The maximum number of test executions to return in each page. If there are  fewer results than the max page size, only the actual number of results are  returned.
        public let maxResults: Int?
        /// If the response from the ListTestExecutions operation contains more results  than specified in the maxResults parameter, a token is returned in the response.  Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// The sort order of the test set executions.
        public let sortBy: TestExecutionSortBy?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sortBy: TestExecutionSortBy? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListTestExecutionsResponse: AWSDecodableShape {
        /// A token that indicates whether there are more results to return in a response to  the ListTestExecutions operation. If the nextToken field is present, you send the  contents as the nextToken parameter of a ListTestExecutions operation request to  get the next page of results.
        public let nextToken: String?
        /// The list of test executions.
        public let testExecutions: [TestExecutionSummary]?

        @inlinable
        public init(nextToken: String? = nil, testExecutions: [TestExecutionSummary]? = nil) {
            self.nextToken = nextToken
            self.testExecutions = testExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testExecutions = "testExecutions"
        }
    }

    public struct ListTestSetRecordsRequest: AWSEncodableShape {
        /// The maximum number of test set records to return in each page. If there are  fewer records than the max page size, only the actual number of records are  returned.
        public let maxResults: Int?
        /// If the response from the ListTestSetRecords operation contains more results  than specified in the maxResults parameter, a token is returned in the response.  Use that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// The identifier of the test set to list its test set records.
        public let testSetId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, testSetId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.testSetId = testSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.testSetId, key: "testSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.testSetId, name: "testSetId", parent: name, max: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, min: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListTestSetRecordsResponse: AWSDecodableShape {
        /// A token that indicates whether there are more records to return in a response to the ListTestSetRecords operation. If the nextToken field is present, you  send the contents as the nextToken parameter of a ListTestSetRecords operation  request to get the next page of records.
        public let nextToken: String?
        /// The list of records from the test set.
        public let testSetRecords: [TestSetTurnRecord]?

        @inlinable
        public init(nextToken: String? = nil, testSetRecords: [TestSetTurnRecord]? = nil) {
            self.nextToken = nextToken
            self.testSetRecords = testSetRecords
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testSetRecords = "testSetRecords"
        }
    }

    public struct ListTestSetsRequest: AWSEncodableShape {
        /// The maximum number of test sets to return in each page. If there are fewer  results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListTestSets operation contains more results than  specified in the maxResults parameter, a token is returned in the response. Use  that token in the nextToken parameter to return the next page of results.
        public let nextToken: String?
        /// The sort order for the list of test sets.
        public let sortBy: TestSetSortBy?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sortBy: TestSetSortBy? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
        }
    }

    public struct ListTestSetsResponse: AWSDecodableShape {
        /// A token that indicates whether there are more results to return in a response  to the ListTestSets operation. If the nextToken field is present, you send the  contents as the nextToken parameter of a ListTestSets operation request to get  the next page of results.
        public let nextToken: String?
        /// The selected test sets in a list of test sets.
        public let testSets: [TestSetSummary]?

        @inlinable
        public init(nextToken: String? = nil, testSets: [TestSetSummary]? = nil) {
            self.nextToken = nextToken
            self.testSets = testSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testSets = "testSets"
        }
    }

    public struct ListUtteranceAnalyticsDataRequest: AWSEncodableShape {
        /// The identifier for the bot for which you want to retrieve utterance analytics.
        public let botId: String
        /// The date and time that marks the end of the range of time for which you want to see utterance analytics.
        public let endDateTime: Date
        /// A list of objects, each of which describes a condition by which you want to filter the results.
        public let filters: [AnalyticsUtteranceFilter]?
        /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the ListUtteranceAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceAnalyticsData request to return the next page of results. For a complete set of results, call the ListUtteranceAnalyticsData operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// An object specifying the measure and method by which to sort the utterance analytics data.
        public let sortBy: UtteranceDataSortBy?
        /// The date and time that marks the beginning of the range of time for which you want to see utterance analytics.
        public let startDateTime: Date

        @inlinable
        public init(botId: String, endDateTime: Date, filters: [AnalyticsUtteranceFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: UtteranceDataSortBy? = nil, startDateTime: Date) {
            self.botId = botId
            self.endDateTime = endDateTime
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.startDateTime = startDateTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortBy, forKey: .sortBy)
            try container.encode(self.startDateTime, forKey: .startDateTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 9)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endDateTime = "endDateTime"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
            case startDateTime = "startDateTime"
        }
    }

    public struct ListUtteranceAnalyticsDataResponse: AWSDecodableShape {
        /// The unique identifier of the bot that the utterances belong to.
        public let botId: String?
        /// If the response from the ListUtteranceAnalyticsData operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceAnalyticsData request to return the next page of results. For a complete set of results, call the ListUtteranceAnalyticsData operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// A list of objects, each of which contains information about an utterance in a user session with your bot.
        public let utterances: [UtteranceSpecification]?

        @inlinable
        public init(botId: String? = nil, nextToken: String? = nil, utterances: [UtteranceSpecification]? = nil) {
            self.botId = botId
            self.nextToken = nextToken
            self.utterances = utterances
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case nextToken = "nextToken"
            case utterances = "utterances"
        }
    }

    public struct ListUtteranceMetricsRequest: AWSEncodableShape {
        /// A list containing attributes related to the utterance that you want the response to return. The following attributes are possible:    LastUsedIntent – The last used intent at the time of the utterance.
        public let attributes: [AnalyticsUtteranceAttribute]?
        /// A list of objects, each of which contains specifications for organizing the results by time.
        public let binBy: [AnalyticsBinBySpecification]?
        /// The identifier for the bot for which you want to retrieve utterance metrics.
        public let botId: String
        /// The date and time that marks the end of the range of time for which you want to see utterance metrics.
        public let endDateTime: Date
        /// A list of objects, each of which describes a condition by which you want to filter the results.
        public let filters: [AnalyticsUtteranceFilter]?
        /// A list of objects, each of which specifies how to group the results. You can group by the following criteria:    UtteranceText – The transcription of the utterance.    UtteranceState – The state of the utterance. The possible states are detailed in Key definitions in the user guide.
        public let groupBy: [AnalyticsUtteranceGroupBySpecification]?
        /// The maximum number of results to return in each page of results. If there are fewer results than the maximum page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// A list of objects, each of which contains a metric you want to list, the statistic for the metric you want to return, and the method by which to organize the results.
        public let metrics: [AnalyticsUtteranceMetric]
        /// If the response from the ListUtteranceMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceMetrics request to return the next page of results. For a complete set of results, call the ListUtteranceMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The date and time that marks the beginning of the range of time for which you want to see utterance metrics.
        public let startDateTime: Date

        @inlinable
        public init(attributes: [AnalyticsUtteranceAttribute]? = nil, binBy: [AnalyticsBinBySpecification]? = nil, botId: String, endDateTime: Date, filters: [AnalyticsUtteranceFilter]? = nil, groupBy: [AnalyticsUtteranceGroupBySpecification]? = nil, maxResults: Int? = nil, metrics: [AnalyticsUtteranceMetric], nextToken: String? = nil, startDateTime: Date) {
            self.attributes = attributes
            self.binBy = binBy
            self.botId = botId
            self.endDateTime = endDateTime
            self.filters = filters
            self.groupBy = groupBy
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextToken = nextToken
            self.startDateTime = startDateTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encodeIfPresent(self.binBy, forKey: .binBy)
            request.encodePath(self.botId, key: "botId")
            try container.encode(self.endDateTime, forKey: .endDateTime)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.groupBy, forKey: .groupBy)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encode(self.metrics, forKey: .metrics)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.startDateTime, forKey: .startDateTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.attributes, name: "attributes", parent: name, max: 1)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 1)
            try self.validate(self.binBy, name: "binBy", parent: name, max: 1)
            try self.validate(self.binBy, name: "binBy", parent: name, min: 1)
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 9)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 2)
            try self.validate(self.groupBy, name: "groupBy", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metrics, name: "metrics", parent: name, max: 4)
            try self.validate(self.metrics, name: "metrics", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case binBy = "binBy"
            case endDateTime = "endDateTime"
            case filters = "filters"
            case groupBy = "groupBy"
            case maxResults = "maxResults"
            case metrics = "metrics"
            case nextToken = "nextToken"
            case startDateTime = "startDateTime"
        }
    }

    public struct ListUtteranceMetricsResponse: AWSDecodableShape {
        /// The identifier for the bot for which you retrieved utterance metrics.
        public let botId: String?
        /// If the response from the ListUtteranceMetrics operation contains more results than specified in the maxResults parameter, a token is returned in the response. Use the returned token in the nextToken parameter of a ListUtteranceMetrics request to return the next page of results. For a complete set of results, call the ListUtteranceMetrics operation until the nextToken returned in the response is null.
        public let nextToken: String?
        /// The results for the utterance metrics.
        public let results: [AnalyticsUtteranceResult]?

        @inlinable
        public init(botId: String? = nil, nextToken: String? = nil, results: [AnalyticsUtteranceResult]? = nil) {
            self.botId = botId
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct Message: AWSEncodableShape & AWSDecodableShape {
        /// A message in a custom format defined by the client application.
        public let customPayload: CustomPayload?
        /// A message that defines a response card that the client application can show to the user.
        public let imageResponseCard: ImageResponseCard?
        /// A message in plain text format.
        public let plainTextMessage: PlainTextMessage?
        /// A message in Speech Synthesis Markup Language (SSML).
        public let ssmlMessage: SSMLMessage?

        @inlinable
        public init(customPayload: CustomPayload? = nil, imageResponseCard: ImageResponseCard? = nil, plainTextMessage: PlainTextMessage? = nil, ssmlMessage: SSMLMessage? = nil) {
            self.customPayload = customPayload
            self.imageResponseCard = imageResponseCard
            self.plainTextMessage = plainTextMessage
            self.ssmlMessage = ssmlMessage
        }

        public func validate(name: String) throws {
            try self.customPayload?.validate(name: "\(name).customPayload")
            try self.imageResponseCard?.validate(name: "\(name).imageResponseCard")
            try self.plainTextMessage?.validate(name: "\(name).plainTextMessage")
            try self.ssmlMessage?.validate(name: "\(name).ssmlMessage")
        }

        private enum CodingKeys: String, CodingKey {
            case customPayload = "customPayload"
            case imageResponseCard = "imageResponseCard"
            case plainTextMessage = "plainTextMessage"
            case ssmlMessage = "ssmlMessage"
        }
    }

    public struct MessageGroup: AWSEncodableShape & AWSDecodableShape {
        /// The primary message that Amazon Lex should send to the user.
        public let message: Message
        /// Message variations to send to the user. When variations are defined, Amazon Lex chooses the primary message or one of the variations to send to the user.
        public let variations: [Message]?

        @inlinable
        public init(message: Message, variations: [Message]? = nil) {
            self.message = message
            self.variations = variations
        }

        public func validate(name: String) throws {
            try self.message.validate(name: "\(name).message")
            try self.variations?.forEach {
                try $0.validate(name: "\(name).variations[]")
            }
            try self.validate(self.variations, name: "variations", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case variations = "variations"
        }
    }

    public struct MultipleValuesSetting: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether a slot can return multiple values. When true, the slot may return more than one value in a response. When false, the slot returns only a single value. Multi-value slots are only available in the en-US locale. If you set this value to true in any other locale, Amazon Lex throws a ValidationException. If the allowMutlipleValues is not set, the default value is false.
        public let allowMultipleValues: Bool?

        @inlinable
        public init(allowMultipleValues: Bool? = nil) {
            self.allowMultipleValues = allowMultipleValues
        }

        private enum CodingKeys: String, CodingKey {
            case allowMultipleValues = "allowMultipleValues"
        }
    }

    public struct NewCustomVocabularyItem: AWSEncodableShape {
        /// The display as value assigned to the new custom vocabulary item from the custom  vocabulary list.
        public let displayAs: String?
        /// The unique phrase for the new custom vocabulary item from the custom  vocabulary list.
        public let phrase: String
        /// The weight assigned to the new custom vocabulary item from the custom  vocabulary list.
        public let weight: Int?

        @inlinable
        public init(displayAs: String? = nil, phrase: String, weight: Int? = nil) {
            self.displayAs = displayAs
            self.phrase = phrase
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.displayAs, name: "displayAs", parent: name, max: 100)
            try self.validate(self.displayAs, name: "displayAs", parent: name, min: 1)
            try self.validate(self.phrase, name: "phrase", parent: name, max: 100)
            try self.validate(self.phrase, name: "phrase", parent: name, min: 1)
            try self.validate(self.weight, name: "weight", parent: name, max: 3)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case displayAs = "displayAs"
            case phrase = "phrase"
            case weight = "weight"
        }
    }

    public struct ObfuscationSetting: AWSEncodableShape & AWSDecodableShape {
        /// Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        public let obfuscationSettingType: ObfuscationSettingType

        @inlinable
        public init(obfuscationSettingType: ObfuscationSettingType) {
            self.obfuscationSettingType = obfuscationSettingType
        }

        private enum CodingKeys: String, CodingKey {
            case obfuscationSettingType = "obfuscationSettingType"
        }
    }

    public struct OpensearchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the Amazon OpenSearch Service domain.
        public let domainEndpoint: String
        /// Specifies whether to return an exact response or to return an answer generated by the model using the fields you specify from the database.
        public let exactResponse: Bool?
        /// Contains the names of the fields used for an exact response to the user.
        public let exactResponseFields: ExactResponseFields?
        /// Contains a list of fields from the Amazon OpenSearch Service that the model can use to generate the answer to the query.
        public let includeFields: [String]?
        /// The name of the Amazon OpenSearch Service index.
        public let indexName: String

        @inlinable
        public init(domainEndpoint: String, exactResponse: Bool? = nil, exactResponseFields: ExactResponseFields? = nil, includeFields: [String]? = nil, indexName: String) {
            self.domainEndpoint = domainEndpoint
            self.exactResponse = exactResponse
            self.exactResponseFields = exactResponseFields
            self.includeFields = includeFields
            self.indexName = indexName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainEndpoint, name: "domainEndpoint", parent: name, pattern: "^(http|https):\\/\\/+[^\\s]+[\\w]$")
            try self.validate(self.includeFields, name: "includeFields", parent: name, max: 5)
            try self.validate(self.includeFields, name: "includeFields", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, max: 255)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^(?![_-])[a-z0-9][a-z0-9_\\-]{0,254}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainEndpoint = "domainEndpoint"
            case exactResponse = "exactResponse"
            case exactResponseFields = "exactResponseFields"
            case includeFields = "includeFields"
            case indexName = "indexName"
        }
    }

    public struct OutputContext: AWSEncodableShape & AWSDecodableShape {
        /// The name of the output context.
        public let name: String
        /// The amount of time, in seconds, that the output context should remain active. The time is figured from the first time the context is sent to the user.
        public let timeToLiveInSeconds: Int
        /// The number of conversation turns that the output context should remain active. The number of turns is counted from the first time that the context is sent to the user.
        public let turnsToLive: Int

        @inlinable
        public init(name: String, timeToLiveInSeconds: Int, turnsToLive: Int) {
            self.name = name
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, max: 86400)
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, min: 5)
            try self.validate(self.turnsToLive, name: "turnsToLive", parent: name, max: 20)
            try self.validate(self.turnsToLive, name: "turnsToLive", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case timeToLiveInSeconds = "timeToLiveInSeconds"
            case turnsToLive = "turnsToLive"
        }
    }

    public struct OverallTestResultItem: AWSDecodableShape {
        /// The number of results that succeeded.
        public let endToEndResultCounts: [TestResultMatchStatus: Int]
        /// Indicates whether the conversation contains multiple turns or not.
        public let multiTurnConversation: Bool
        /// The number of speech transcription results in the overall test.
        public let speechTranscriptionResultCounts: [TestResultMatchStatus: Int]?
        /// The total number of overall results in the result of the test execution.
        public let totalResultCount: Int

        @inlinable
        public init(endToEndResultCounts: [TestResultMatchStatus: Int], multiTurnConversation: Bool, speechTranscriptionResultCounts: [TestResultMatchStatus: Int]? = nil, totalResultCount: Int) {
            self.endToEndResultCounts = endToEndResultCounts
            self.multiTurnConversation = multiTurnConversation
            self.speechTranscriptionResultCounts = speechTranscriptionResultCounts
            self.totalResultCount = totalResultCount
        }

        private enum CodingKeys: String, CodingKey {
            case endToEndResultCounts = "endToEndResultCounts"
            case multiTurnConversation = "multiTurnConversation"
            case speechTranscriptionResultCounts = "speechTranscriptionResultCounts"
            case totalResultCount = "totalResultCount"
        }
    }

    public struct OverallTestResults: AWSDecodableShape {
        /// A list of the overall test results.
        public let items: [OverallTestResultItem]

        @inlinable
        public init(items: [OverallTestResultItem]) {
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
        }
    }

    public struct ParentBotNetwork: AWSDecodableShape {
        /// The identifier of the network of bots assigned by Amazon Lex.
        public let botId: String
        /// The version of the network of bots.
        public let botVersion: String

        @inlinable
        public init(botId: String, botVersion: String) {
            self.botId = botId
            self.botVersion = botVersion
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
        }
    }

    public struct PathFormat: AWSEncodableShape & AWSDecodableShape {
        /// A list of Amazon S3 prefixes that points to sub-folders in the Amazon S3 bucket. Specify this list if you only want Lex to read the files under this set of sub-folders.
        public let objectPrefixes: [String]?

        @inlinable
        public init(objectPrefixes: [String]? = nil) {
            self.objectPrefixes = objectPrefixes
        }

        public func validate(name: String) throws {
            try self.objectPrefixes?.forEach {
                try validate($0, name: "objectPrefixes[]", parent: name, min: 1)
                try validate($0, name: "objectPrefixes[]", parent: name, pattern: "^[\\/]?+[a-zA-Z0-9!_.*'()-]+(\\/[a-zA-Z0-9!_.*'()-]+)*$")
            }
            try self.validate(self.objectPrefixes, name: "objectPrefixes", parent: name, max: 2)
            try self.validate(self.objectPrefixes, name: "objectPrefixes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case objectPrefixes = "objectPrefixes"
        }
    }

    public struct PlainTextMessage: AWSEncodableShape & AWSDecodableShape {
        /// The message to send to the user.
        public let value: String

        @inlinable
        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct PostDialogCodeHookInvocationSpecification: AWSEncodableShape & AWSDecodableShape {
        /// A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public let failureConditional: ConditionalSpecification?
        /// Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public let failureNextStep: DialogState?
        public let failureResponse: ResponseSpecification?
        /// A list of conditional branches to evaluate after the dialog code hook finishes successfully.
        public let successConditional: ConditionalSpecification?
        /// Specifics the next step the bot runs after the dialog code hook finishes successfully.
        public let successNextStep: DialogState?
        public let successResponse: ResponseSpecification?
        /// A list of conditional branches to evaluate if the code hook times out.
        public let timeoutConditional: ConditionalSpecification?
        /// Specifies the next step that the bot runs when the code hook times out.
        public let timeoutNextStep: DialogState?
        public let timeoutResponse: ResponseSpecification?

        @inlinable
        public init(failureConditional: ConditionalSpecification? = nil, failureNextStep: DialogState? = nil, failureResponse: ResponseSpecification? = nil, successConditional: ConditionalSpecification? = nil, successNextStep: DialogState? = nil, successResponse: ResponseSpecification? = nil, timeoutConditional: ConditionalSpecification? = nil, timeoutNextStep: DialogState? = nil, timeoutResponse: ResponseSpecification? = nil) {
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
            self.successConditional = successConditional
            self.successNextStep = successNextStep
            self.successResponse = successResponse
            self.timeoutConditional = timeoutConditional
            self.timeoutNextStep = timeoutNextStep
            self.timeoutResponse = timeoutResponse
        }

        public func validate(name: String) throws {
            try self.failureConditional?.validate(name: "\(name).failureConditional")
            try self.failureNextStep?.validate(name: "\(name).failureNextStep")
            try self.failureResponse?.validate(name: "\(name).failureResponse")
            try self.successConditional?.validate(name: "\(name).successConditional")
            try self.successNextStep?.validate(name: "\(name).successNextStep")
            try self.successResponse?.validate(name: "\(name).successResponse")
            try self.timeoutConditional?.validate(name: "\(name).timeoutConditional")
            try self.timeoutNextStep?.validate(name: "\(name).timeoutNextStep")
            try self.timeoutResponse?.validate(name: "\(name).timeoutResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case failureConditional = "failureConditional"
            case failureNextStep = "failureNextStep"
            case failureResponse = "failureResponse"
            case successConditional = "successConditional"
            case successNextStep = "successNextStep"
            case successResponse = "successResponse"
            case timeoutConditional = "timeoutConditional"
            case timeoutNextStep = "timeoutNextStep"
            case timeoutResponse = "timeoutResponse"
        }
    }

    public struct PostFulfillmentStatusSpecification: AWSEncodableShape & AWSDecodableShape {
        /// A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public let failureConditional: ConditionalSpecification?
        /// Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        public let failureNextStep: DialogState?
        public let failureResponse: ResponseSpecification?
        /// A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
        public let successConditional: ConditionalSpecification?
        /// Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
        public let successNextStep: DialogState?
        public let successResponse: ResponseSpecification?
        /// A list of conditional branches to evaluate if the fulfillment code hook times out.
        public let timeoutConditional: ConditionalSpecification?
        /// Specifies the next step that the bot runs when the fulfillment code hook times out.
        public let timeoutNextStep: DialogState?
        public let timeoutResponse: ResponseSpecification?

        @inlinable
        public init(failureConditional: ConditionalSpecification? = nil, failureNextStep: DialogState? = nil, failureResponse: ResponseSpecification? = nil, successConditional: ConditionalSpecification? = nil, successNextStep: DialogState? = nil, successResponse: ResponseSpecification? = nil, timeoutConditional: ConditionalSpecification? = nil, timeoutNextStep: DialogState? = nil, timeoutResponse: ResponseSpecification? = nil) {
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
            self.successConditional = successConditional
            self.successNextStep = successNextStep
            self.successResponse = successResponse
            self.timeoutConditional = timeoutConditional
            self.timeoutNextStep = timeoutNextStep
            self.timeoutResponse = timeoutResponse
        }

        public func validate(name: String) throws {
            try self.failureConditional?.validate(name: "\(name).failureConditional")
            try self.failureNextStep?.validate(name: "\(name).failureNextStep")
            try self.failureResponse?.validate(name: "\(name).failureResponse")
            try self.successConditional?.validate(name: "\(name).successConditional")
            try self.successNextStep?.validate(name: "\(name).successNextStep")
            try self.successResponse?.validate(name: "\(name).successResponse")
            try self.timeoutConditional?.validate(name: "\(name).timeoutConditional")
            try self.timeoutNextStep?.validate(name: "\(name).timeoutNextStep")
            try self.timeoutResponse?.validate(name: "\(name).timeoutResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case failureConditional = "failureConditional"
            case failureNextStep = "failureNextStep"
            case failureResponse = "failureResponse"
            case successConditional = "successConditional"
            case successNextStep = "successNextStep"
            case successResponse = "successResponse"
            case timeoutConditional = "timeoutConditional"
            case timeoutNextStep = "timeoutNextStep"
            case timeoutResponse = "timeoutResponse"
        }
    }

    public struct Principal: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the principal.
        public let arn: String?
        /// The name of the Amazon Web Services service that should allowed or denied access to an Amazon Lex action.
        public let service: String?

        @inlinable
        public init(arn: String? = nil, service: String? = nil) {
            self.arn = arn
            self.service = service
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1024)
            try self.validate(self.arn, name: "arn", parent: name, min: 30)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:(root|(user|role)/.*)$")
            try self.validate(self.service, name: "service", parent: name, max: 1024)
            try self.validate(self.service, name: "service", parent: name, min: 15)
            try self.validate(self.service, name: "service", parent: name, pattern: "^[0-9a-zA-Z_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case service = "service"
        }
    }

    public struct PromptAttemptSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the allowed input types of the prompt attempt.
        public let allowedInputTypes: AllowedInputTypes
        /// Indicates whether the user can interrupt a speech prompt attempt from the bot.
        public let allowInterrupt: Bool?
        /// Specifies the settings on audio and DTMF input.
        public let audioAndDTMFInputSpecification: AudioAndDTMFInputSpecification?
        /// Specifies the settings on text input.
        public let textInputSpecification: TextInputSpecification?

        @inlinable
        public init(allowedInputTypes: AllowedInputTypes, allowInterrupt: Bool? = nil, audioAndDTMFInputSpecification: AudioAndDTMFInputSpecification? = nil, textInputSpecification: TextInputSpecification? = nil) {
            self.allowedInputTypes = allowedInputTypes
            self.allowInterrupt = allowInterrupt
            self.audioAndDTMFInputSpecification = audioAndDTMFInputSpecification
            self.textInputSpecification = textInputSpecification
        }

        public func validate(name: String) throws {
            try self.audioAndDTMFInputSpecification?.validate(name: "\(name).audioAndDTMFInputSpecification")
            try self.textInputSpecification?.validate(name: "\(name).textInputSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedInputTypes = "allowedInputTypes"
            case allowInterrupt = "allowInterrupt"
            case audioAndDTMFInputSpecification = "audioAndDTMFInputSpecification"
            case textInputSpecification = "textInputSpecification"
        }
    }

    public struct PromptSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the user can interrupt a speech prompt from the bot.
        public let allowInterrupt: Bool?
        /// The maximum number of times the bot tries to elicit a response from the user using this prompt.
        public let maxRetries: Int
        /// A collection of messages that Amazon Lex can send to the user. Amazon Lex chooses the actual message to send at runtime.
        public let messageGroups: [MessageGroup]
        /// Indicates how a message is selected from a message group among retries.
        public let messageSelectionStrategy: MessageSelectionStrategy?
        /// Specifies the advanced settings on each attempt of the prompt.
        public let promptAttemptsSpecification: [PromptAttempt: PromptAttemptSpecification]?

        @inlinable
        public init(allowInterrupt: Bool? = nil, maxRetries: Int, messageGroups: [MessageGroup], messageSelectionStrategy: MessageSelectionStrategy? = nil, promptAttemptsSpecification: [PromptAttempt: PromptAttemptSpecification]? = nil) {
            self.allowInterrupt = allowInterrupt
            self.maxRetries = maxRetries
            self.messageGroups = messageGroups
            self.messageSelectionStrategy = messageSelectionStrategy
            self.promptAttemptsSpecification = promptAttemptsSpecification
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, max: 5)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
            try self.promptAttemptsSpecification?.forEach {
                try $0.value.validate(name: "\(name).promptAttemptsSpecification[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case maxRetries = "maxRetries"
            case messageGroups = "messageGroups"
            case messageSelectionStrategy = "messageSelectionStrategy"
            case promptAttemptsSpecification = "promptAttemptsSpecification"
        }
    }

    public struct QInConnectAssistantConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The assistant Arn details of the Qinconnect assistant configuration.
        public let assistantArn: String

        @inlinable
        public init(assistantArn: String) {
            self.assistantArn = assistantArn
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantArn, name: "assistantArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}){0,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
        }
    }

    public struct QInConnectIntentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Qinconnect assistant configuration details of the Qinconnect intent.
        public let qInConnectAssistantConfiguration: QInConnectAssistantConfiguration?

        @inlinable
        public init(qInConnectAssistantConfiguration: QInConnectAssistantConfiguration? = nil) {
            self.qInConnectAssistantConfiguration = qInConnectAssistantConfiguration
        }

        public func validate(name: String) throws {
            try self.qInConnectAssistantConfiguration?.validate(name: "\(name).qInConnectAssistantConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case qInConnectAssistantConfiguration = "qInConnectAssistantConfiguration"
        }
    }

    public struct QnAIntentConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let bedrockModelConfiguration: BedrockModelSpecification?
        /// Contains details about the configuration of the data source used for the AMAZON.QnAIntent.
        public let dataSourceConfiguration: DataSourceConfiguration?

        @inlinable
        public init(bedrockModelConfiguration: BedrockModelSpecification? = nil, dataSourceConfiguration: DataSourceConfiguration? = nil) {
            self.bedrockModelConfiguration = bedrockModelConfiguration
            self.dataSourceConfiguration = dataSourceConfiguration
        }

        public func validate(name: String) throws {
            try self.bedrockModelConfiguration?.validate(name: "\(name).bedrockModelConfiguration")
            try self.dataSourceConfiguration?.validate(name: "\(name).dataSourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockModelConfiguration = "bedrockModelConfiguration"
            case dataSourceConfiguration = "dataSourceConfiguration"
        }
    }

    public struct QnAKendraConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to return an exact response from the Amazon Kendra index or to let the Amazon Bedrock model you select generate a response based on the results. To use this feature, you must first add FAQ questions to your index by following the steps at Adding frequently asked questions (FAQs) to an index.
        public let exactResponse: Bool?
        /// The ARN of the Amazon Kendra index to use.
        public let kendraIndex: String
        /// Contains the Amazon Kendra filter string to use if enabled. For more information on the Amazon Kendra search filter JSON format, see Using document attributes to filter search results.
        public let queryFilterString: String?
        /// Specifies whether to enable an Amazon Kendra filter string or not.
        public let queryFilterStringEnabled: Bool?

        @inlinable
        public init(exactResponse: Bool? = nil, kendraIndex: String, queryFilterString: String? = nil, queryFilterStringEnabled: Bool? = nil) {
            self.exactResponse = exactResponse
            self.kendraIndex = kendraIndex
            self.queryFilterString = queryFilterString
            self.queryFilterStringEnabled = queryFilterStringEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, max: 2048)
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, min: 32)
            try self.validate(self.kendraIndex, name: "kendraIndex", parent: name, pattern: "^arn:aws:kendra:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:index\\/[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.queryFilterString, name: "queryFilterString", parent: name, max: 5000)
            try self.validate(self.queryFilterString, name: "queryFilterString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exactResponse = "exactResponse"
            case kendraIndex = "kendraIndex"
            case queryFilterString = "queryFilterString"
            case queryFilterStringEnabled = "queryFilterStringEnabled"
        }
    }

    public struct RecommendedIntentSummary: AWSDecodableShape {
        /// The unique identifier of a recommended intent associated with the bot recommendation.
        public let intentId: String?
        /// The name of a recommended intent associated with the bot recommendation.
        public let intentName: String?
        /// The count of sample utterances of a recommended intent that is associated with a bot recommendation.
        public let sampleUtterancesCount: Int?

        @inlinable
        public init(intentId: String? = nil, intentName: String? = nil, sampleUtterancesCount: Int? = nil) {
            self.intentId = intentId
            self.intentName = intentName
            self.sampleUtterancesCount = sampleUtterancesCount
        }

        private enum CodingKeys: String, CodingKey {
            case intentId = "intentId"
            case intentName = "intentName"
            case sampleUtterancesCount = "sampleUtterancesCount"
        }
    }

    public struct RelativeAggregationDuration: AWSEncodableShape & AWSDecodableShape {
        /// The type of time period that the timeValue field represents.
        public let timeDimension: TimeDimension
        /// The period of the time window to gather statistics for. The valid value depends on the setting of the timeDimension field.    Hours - 1/3/6/12/24    Days - 3    Weeks - 1/2
        public let timeValue: Int

        @inlinable
        public init(timeDimension: TimeDimension, timeValue: Int) {
            self.timeDimension = timeDimension
            self.timeValue = timeValue
        }

        public func validate(name: String) throws {
            try self.validate(self.timeValue, name: "timeValue", parent: name, max: 24)
            try self.validate(self.timeValue, name: "timeValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case timeDimension = "timeDimension"
            case timeValue = "timeValue"
        }
    }

    public struct ResponseSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the user can interrupt a speech response from Amazon Lex.
        public let allowInterrupt: Bool?
        /// A collection of responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime.
        public let messageGroups: [MessageGroup]

        @inlinable
        public init(allowInterrupt: Bool? = nil, messageGroups: [MessageGroup]) {
            self.allowInterrupt = allowInterrupt
            self.messageGroups = messageGroups
        }

        public func validate(name: String) throws {
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case messageGroups = "messageGroups"
        }
    }

    public struct RuntimeHintDetails: AWSDecodableShape {
        /// One or more strings that Amazon Lex should look for in the input to the bot. Each phrase is given preference when deciding on slot values.
        public let runtimeHintValues: [RuntimeHintValue]?
        /// A map of constituent sub slot names inside a composite slot in the intent and the phrases  that should be added for each sub slot. Inside each composite slot hints, this structure provides  a mechanism to add granular sub slot phrases. Only sub slot hints are supported for composite slots.  The intent name, composite slot name and the constituent sub slot names must exist.
        public let subSlotHints: [String: RuntimeHintDetails]?

        @inlinable
        public init(runtimeHintValues: [RuntimeHintValue]? = nil, subSlotHints: [String: RuntimeHintDetails]? = nil) {
            self.runtimeHintValues = runtimeHintValues
            self.subSlotHints = subSlotHints
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeHintValues = "runtimeHintValues"
            case subSlotHints = "subSlotHints"
        }
    }

    public struct RuntimeHintValue: AWSDecodableShape {
        /// The phrase that Amazon Lex should look for in the user's input to the bot.
        public let phrase: String

        @inlinable
        public init(phrase: String) {
            self.phrase = phrase
        }

        private enum CodingKeys: String, CodingKey {
            case phrase = "phrase"
        }
    }

    public struct RuntimeHints: AWSDecodableShape {
        /// A list of the slots in the intent that should have runtime hints added, and the phrases that should be added for each slot. The first level of the slotHints map is the name of the intent. The second level is the name of the slot within the intent. For more information, see Using hints to improve accuracy. The intent name and slot name must exist.
        public let slotHints: [String: [String: RuntimeHintDetails]]?

        @inlinable
        public init(slotHints: [String: [String: RuntimeHintDetails]]? = nil) {
            self.slotHints = slotHints
        }

        private enum CodingKeys: String, CodingKey {
            case slotHints = "slotHints"
        }
    }

    public struct RuntimeSettings: AWSEncodableShape & AWSDecodableShape {
        /// An object containing specifications for the assisted slot resolution feature.
        public let slotResolutionImprovement: SlotResolutionImprovementSpecification?

        @inlinable
        public init(slotResolutionImprovement: SlotResolutionImprovementSpecification? = nil) {
            self.slotResolutionImprovement = slotResolutionImprovement
        }

        public func validate(name: String) throws {
            try self.slotResolutionImprovement?.validate(name: "\(name).slotResolutionImprovement")
        }

        private enum CodingKeys: String, CodingKey {
            case slotResolutionImprovement = "slotResolutionImprovement"
        }
    }

    public struct S3BucketLogDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        public let kmsKeyArn: String?
        /// The S3 prefix to assign to audio log files.
        public let logPrefix: String
        /// The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        public let s3BucketArn: String

        @inlinable
        public init(kmsKeyArn: String? = nil, logPrefix: String, s3BucketArn: String) {
            self.kmsKeyArn = kmsKeyArn
            self.logPrefix = logPrefix
            self.s3BucketArn = s3BucketArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:[\\w\\-]+:kms:[\\w\\-]+:[\\d]{12}:(?:key\\/[\\w\\-]+|alias\\/[a-zA-Z0-9:\\/_\\-]{1,256})$")
            try self.validate(self.logPrefix, name: "logPrefix", parent: name, max: 1024)
            try self.validate(self.s3BucketArn, name: "s3BucketArn", parent: name, max: 2048)
            try self.validate(self.s3BucketArn, name: "s3BucketArn", parent: name, min: 1)
            try self.validate(self.s3BucketArn, name: "s3BucketArn", parent: name, pattern: "^arn:[\\w\\-]+:s3:::[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case logPrefix = "logPrefix"
            case s3BucketArn = "s3BucketArn"
        }
    }

    public struct S3BucketTranscriptSource: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the KMS key that customer use to encrypt their Amazon S3 bucket. Only use this field if your bucket is encrypted using a customer managed KMS key.
        public let kmsKeyArn: String?
        /// The object that contains a path format that will be applied when Amazon Lex reads the transcript file in the bucket you provide. Specify this object if you only want Lex to read a subset of files in your Amazon S3 bucket.
        public let pathFormat: PathFormat?
        /// The name of the bucket containing the transcript and the associated metadata.
        public let s3BucketName: String
        /// The object that contains the filter which will be applied when Amazon Lex reads through the Amazon S3 bucket. Specify this object if you want Amazon Lex to read only a subset of the Amazon S3 bucket based on the filter you provide.
        public let transcriptFilter: TranscriptFilter?
        /// The format of the transcript content. Currently, Genie only supports the Amazon Lex transcript format.
        public let transcriptFormat: TranscriptFormat

        @inlinable
        public init(kmsKeyArn: String? = nil, pathFormat: PathFormat? = nil, s3BucketName: String, transcriptFilter: TranscriptFilter? = nil, transcriptFormat: TranscriptFormat) {
            self.kmsKeyArn = kmsKeyArn
            self.pathFormat = pathFormat
            self.s3BucketName = s3BucketName
            self.transcriptFilter = transcriptFilter
            self.transcriptFormat = transcriptFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:[\\w\\-]+:kms:[\\w\\-]+:[\\d]{12}:(?:key\\/[\\w\\-]+|alias\\/[a-zA-Z0-9:\\/_\\-]{1,256})$")
            try self.pathFormat?.validate(name: "\(name).pathFormat")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case pathFormat = "pathFormat"
            case s3BucketName = "s3BucketName"
            case transcriptFilter = "transcriptFilter"
            case transcriptFormat = "transcriptFormat"
        }
    }

    public struct SSMLMessage: AWSEncodableShape & AWSDecodableShape {
        /// The SSML text that defines the prompt.
        public let value: String

        @inlinable
        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct SampleUtterance: AWSEncodableShape & AWSDecodableShape {
        /// The sample utterance that Amazon Lex uses to build its machine-learning model to recognize intents.
        public let utterance: String

        @inlinable
        public init(utterance: String) {
            self.utterance = utterance
        }

        private enum CodingKeys: String, CodingKey {
            case utterance = "utterance"
        }
    }

    public struct SampleUtteranceGenerationSpecification: AWSEncodableShape & AWSDecodableShape {
        public let bedrockModelSpecification: BedrockModelSpecification?
        /// Specifies whether to enable sample utterance generation or not.
        public let enabled: Bool

        @inlinable
        public init(bedrockModelSpecification: BedrockModelSpecification? = nil, enabled: Bool) {
            self.bedrockModelSpecification = bedrockModelSpecification
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.bedrockModelSpecification?.validate(name: "\(name).bedrockModelSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockModelSpecification = "bedrockModelSpecification"
            case enabled = "enabled"
        }
    }

    public struct SampleValue: AWSEncodableShape & AWSDecodableShape {
        /// The value that can be used for a slot type.
        public let value: String

        @inlinable
        public init(value: String) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 140)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct SearchAssociatedTranscriptsRequest: AWSEncodableShape {
        /// The unique identifier of the bot associated with the transcripts that you are searching.
        public let botId: String
        /// The unique identifier of the bot recommendation associated with the transcripts to search.
        public let botRecommendationId: String
        /// The version of the bot containing the transcripts that you are searching.
        public let botVersion: String
        /// A list of filter objects.
        public let filters: [AssociatedTranscriptFilter]
        /// The identifier of the language and locale of the transcripts to search. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String
        /// The maximum number of bot recommendations to return in each page of results. If there are fewer results than the max page size, only the actual number of results are returned.
        public let maxResults: Int?
        /// If the response from the SearchAssociatedTranscriptsRequest operation contains more results than specified in the maxResults parameter, an index is returned in the response. Use that index in the nextIndex parameter to return the next page of results.
        public let nextIndex: Int?
        /// How SearchResults are ordered. Valid values are Ascending or Descending. The default is Descending.
        public let searchOrder: SearchOrder?

        @inlinable
        public init(botId: String, botRecommendationId: String, botVersion: String, filters: [AssociatedTranscriptFilter], localeId: String, maxResults: Int? = nil, nextIndex: Int? = nil, searchOrder: SearchOrder? = nil) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botVersion = botVersion
            self.filters = filters
            self.localeId = localeId
            self.maxResults = maxResults
            self.nextIndex = nextIndex
            self.searchOrder = searchOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botRecommendationId, key: "botRecommendationId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encode(self.filters, forKey: .filters)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextIndex, forKey: .nextIndex)
            try container.encodeIfPresent(self.searchOrder, forKey: .searchOrder)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, max: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, min: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextIndex, name: "nextIndex", parent: name, max: 10000000)
            try self.validate(self.nextIndex, name: "nextIndex", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextIndex = "nextIndex"
            case searchOrder = "searchOrder"
        }
    }

    public struct SearchAssociatedTranscriptsResponse: AWSDecodableShape {
        /// The object that contains the associated transcript that meet the criteria you specified.
        public let associatedTranscripts: [AssociatedTranscript]?
        /// The unique identifier of the bot associated with the transcripts that you are searching.
        public let botId: String?
        ///  The unique identifier of the bot recommendation associated with the transcripts to search.
        public let botRecommendationId: String?
        /// The version of the bot containing the transcripts that you are searching.
        public let botVersion: String?
        /// The identifier of the language and locale of the transcripts to search. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String?
        /// A index that indicates whether there are more results to return in a response to the SearchAssociatedTranscripts operation. If the nextIndex field is present, you send the contents as the nextIndex parameter of a SearchAssociatedTranscriptsRequest operation to get the next page of results.
        public let nextIndex: Int?
        /// The total number of transcripts returned by the search.
        public let totalResults: Int?

        @inlinable
        public init(associatedTranscripts: [AssociatedTranscript]? = nil, botId: String? = nil, botRecommendationId: String? = nil, botVersion: String? = nil, localeId: String? = nil, nextIndex: Int? = nil, totalResults: Int? = nil) {
            self.associatedTranscripts = associatedTranscripts
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botVersion = botVersion
            self.localeId = localeId
            self.nextIndex = nextIndex
            self.totalResults = totalResults
        }

        private enum CodingKeys: String, CodingKey {
            case associatedTranscripts = "associatedTranscripts"
            case botId = "botId"
            case botRecommendationId = "botRecommendationId"
            case botVersion = "botVersion"
            case localeId = "localeId"
            case nextIndex = "nextIndex"
            case totalResults = "totalResults"
        }
    }

    public struct SentimentAnalysisSettings: AWSEncodableShape & AWSDecodableShape {
        /// Sets whether Amazon Lex uses Amazon Comprehend to detect the sentiment of user utterances.
        public let detectSentiment: Bool

        @inlinable
        public init(detectSentiment: Bool) {
            self.detectSentiment = detectSentiment
        }

        private enum CodingKeys: String, CodingKey {
            case detectSentiment = "detectSentiment"
        }
    }

    public struct SessionDataSortBy: AWSEncodableShape {
        /// The measure by which to sort the session analytics data.    conversationStartTime – The date and time when the conversation began. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.    numberOfTurns – The number of turns that the session took.    conversationDurationSeconds – The duration of the conversation in seconds.
        public let name: AnalyticsSessionSortByName
        /// Specifies whether to sort the results in ascending or descending order.
        public let order: AnalyticsSortOrder

        @inlinable
        public init(name: AnalyticsSessionSortByName, order: AnalyticsSortOrder) {
            self.name = name
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
        }
    }

    public struct SessionSpecification: AWSDecodableShape {
        /// The identifier of the alias of the bot that the session was held with.
        public let botAliasId: String?
        /// The version of the bot that the session was held with.
        public let botVersion: String?
        /// The channel that is integrated with the bot that the session was held with.
        public let channel: String?
        /// The duration of the conversation in seconds. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public let conversationDurationSeconds: Int64?
        /// The final state of the conversation. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public let conversationEndState: ConversationEndState?
        /// The date and time when the conversation ended. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public let conversationEndTime: Date?
        /// The date and time when the conversation began. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public let conversationStartTime: Date?
        /// A list of objects containing the name of an intent that was invoked.
        public let invokedIntentSamples: [InvokedIntentSample]?
        /// The locale of the bot that the session was held with.
        public let localeId: String?
        /// The mode of the session. The possible values are as follows:    Speech – The session was spoken.    Text – The session was written.    DTMF – The session used a touch-tone keypad (Dual Tone Multi-Frequency).    MultiMode – The session used multiple modes.
        public let mode: AnalyticsModality?
        /// The number of turns that the session took.
        public let numberOfTurns: Int64?
        /// The identifier of the first request in a session.
        public let originatingRequestId: String?
        /// The identifier of the session.
        public let sessionId: String?

        @inlinable
        public init(botAliasId: String? = nil, botVersion: String? = nil, channel: String? = nil, conversationDurationSeconds: Int64? = nil, conversationEndState: ConversationEndState? = nil, conversationEndTime: Date? = nil, conversationStartTime: Date? = nil, invokedIntentSamples: [InvokedIntentSample]? = nil, localeId: String? = nil, mode: AnalyticsModality? = nil, numberOfTurns: Int64? = nil, originatingRequestId: String? = nil, sessionId: String? = nil) {
            self.botAliasId = botAliasId
            self.botVersion = botVersion
            self.channel = channel
            self.conversationDurationSeconds = conversationDurationSeconds
            self.conversationEndState = conversationEndState
            self.conversationEndTime = conversationEndTime
            self.conversationStartTime = conversationStartTime
            self.invokedIntentSamples = invokedIntentSamples
            self.localeId = localeId
            self.mode = mode
            self.numberOfTurns = numberOfTurns
            self.originatingRequestId = originatingRequestId
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botVersion = "botVersion"
            case channel = "channel"
            case conversationDurationSeconds = "conversationDurationSeconds"
            case conversationEndState = "conversationEndState"
            case conversationEndTime = "conversationEndTime"
            case conversationStartTime = "conversationStartTime"
            case invokedIntentSamples = "invokedIntentSamples"
            case localeId = "localeId"
            case mode = "mode"
            case numberOfTurns = "numberOfTurns"
            case originatingRequestId = "originatingRequestId"
            case sessionId = "sessionId"
        }
    }

    public struct SlotCaptureSetting: AWSEncodableShape & AWSDecodableShape {
        /// A list of conditional branches to evaluate after the slot value is captured.
        public let captureConditional: ConditionalSpecification?
        /// Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
        public let captureNextStep: DialogState?
        public let captureResponse: ResponseSpecification?
        /// Code hook called after Amazon Lex successfully captures a slot value.
        public let codeHook: DialogCodeHookInvocationSetting?
        /// Code hook called when Amazon Lex doesn't capture a slot value.
        public let elicitationCodeHook: ElicitationCodeHookInvocationSetting?
        /// A list of conditional branches to evaluate when the slot value isn't captured.
        public let failureConditional: ConditionalSpecification?
        /// Specifies the next step that the bot runs when the slot value code is not recognized.
        public let failureNextStep: DialogState?
        public let failureResponse: ResponseSpecification?

        @inlinable
        public init(captureConditional: ConditionalSpecification? = nil, captureNextStep: DialogState? = nil, captureResponse: ResponseSpecification? = nil, codeHook: DialogCodeHookInvocationSetting? = nil, elicitationCodeHook: ElicitationCodeHookInvocationSetting? = nil, failureConditional: ConditionalSpecification? = nil, failureNextStep: DialogState? = nil, failureResponse: ResponseSpecification? = nil) {
            self.captureConditional = captureConditional
            self.captureNextStep = captureNextStep
            self.captureResponse = captureResponse
            self.codeHook = codeHook
            self.elicitationCodeHook = elicitationCodeHook
            self.failureConditional = failureConditional
            self.failureNextStep = failureNextStep
            self.failureResponse = failureResponse
        }

        public func validate(name: String) throws {
            try self.captureConditional?.validate(name: "\(name).captureConditional")
            try self.captureNextStep?.validate(name: "\(name).captureNextStep")
            try self.captureResponse?.validate(name: "\(name).captureResponse")
            try self.codeHook?.validate(name: "\(name).codeHook")
            try self.elicitationCodeHook?.validate(name: "\(name).elicitationCodeHook")
            try self.failureConditional?.validate(name: "\(name).failureConditional")
            try self.failureNextStep?.validate(name: "\(name).failureNextStep")
            try self.failureResponse?.validate(name: "\(name).failureResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case captureConditional = "captureConditional"
            case captureNextStep = "captureNextStep"
            case captureResponse = "captureResponse"
            case codeHook = "codeHook"
            case elicitationCodeHook = "elicitationCodeHook"
            case failureConditional = "failureConditional"
            case failureNextStep = "failureNextStep"
            case failureResponse = "failureResponse"
        }
    }

    public struct SlotDefaultValue: AWSEncodableShape & AWSDecodableShape {
        /// The default value to use when a user doesn't provide a value for a slot.
        public let defaultValue: String

        @inlinable
        public init(defaultValue: String) {
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 202)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
        }
    }

    public struct SlotDefaultValueSpecification: AWSEncodableShape & AWSDecodableShape {
        /// A list of default values. Amazon Lex chooses the default value to use in the order that they are presented in the list.
        public let defaultValueList: [SlotDefaultValue]

        @inlinable
        public init(defaultValueList: [SlotDefaultValue]) {
            self.defaultValueList = defaultValueList
        }

        public func validate(name: String) throws {
            try self.defaultValueList.forEach {
                try $0.validate(name: "\(name).defaultValueList[]")
            }
            try self.validate(self.defaultValueList, name: "defaultValueList", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValueList = "defaultValueList"
        }
    }

    public struct SlotFilter: AWSEncodableShape {
        /// The name of the field to use for filtering.
        public let name: SlotFilterName
        /// The operator to use for the filter. Specify EQ when the ListSlots operation should return only aliases that equal the specified value. Specify CO when the ListSlots operation should return aliases that contain the specified value.
        public let `operator`: SlotFilterOperator
        /// The value to use to filter the response.
        public let values: [String]

        @inlinable
        public init(name: SlotFilterName, operator: SlotFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SlotPriority: AWSEncodableShape & AWSDecodableShape {
        /// The priority that Amazon Lex should apply to the slot.
        public let priority: Int
        /// The unique identifier of the slot.
        public let slotId: String

        @inlinable
        public init(priority: Int, slotId: String) {
            self.priority = priority
            self.slotId = slotId
        }

        public func validate(name: String) throws {
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "priority"
            case slotId = "slotId"
        }
    }

    public struct SlotResolutionImprovementSpecification: AWSEncodableShape & AWSDecodableShape {
        /// An object containing information about the Amazon Bedrock model used to assist slot resolution.
        public let bedrockModelSpecification: BedrockModelSpecification?
        /// Specifies whether assisted slot resolution is turned on or off.
        public let enabled: Bool

        @inlinable
        public init(bedrockModelSpecification: BedrockModelSpecification? = nil, enabled: Bool) {
            self.bedrockModelSpecification = bedrockModelSpecification
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.bedrockModelSpecification?.validate(name: "\(name).bedrockModelSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockModelSpecification = "bedrockModelSpecification"
            case enabled = "enabled"
        }
    }

    public struct SlotResolutionSetting: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether assisted slot resolution is turned on for the slot or not. If the value is EnhancedFallback, assisted slot resolution is activated when Amazon Lex defaults to the AMAZON.FallbackIntent. If the value is Default, assisted slot resolution is turned off.
        public let slotResolutionStrategy: SlotResolutionStrategy

        @inlinable
        public init(slotResolutionStrategy: SlotResolutionStrategy) {
            self.slotResolutionStrategy = slotResolutionStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case slotResolutionStrategy = "slotResolutionStrategy"
        }
    }

    public struct SlotResolutionTestResultItem: AWSDecodableShape {
        /// A result for slot resolution in the results of a test execution.
        public let resultCounts: SlotResolutionTestResultItemCounts
        /// The name of the slot.
        public let slotName: String

        @inlinable
        public init(resultCounts: SlotResolutionTestResultItemCounts, slotName: String) {
            self.resultCounts = resultCounts
            self.slotName = slotName
        }

        private enum CodingKeys: String, CodingKey {
            case resultCounts = "resultCounts"
            case slotName = "slotName"
        }
    }

    public struct SlotResolutionTestResultItemCounts: AWSDecodableShape {
        /// The number of matched and mismatched results for slot resolution for the slot.
        public let slotMatchResultCounts: [TestResultMatchStatus: Int]
        /// The number of matched, mismatched and execution error results for speech transcription for the slot.
        public let speechTranscriptionResultCounts: [TestResultMatchStatus: Int]?
        /// The total number of results.
        public let totalResultCount: Int

        @inlinable
        public init(slotMatchResultCounts: [TestResultMatchStatus: Int], speechTranscriptionResultCounts: [TestResultMatchStatus: Int]? = nil, totalResultCount: Int) {
            self.slotMatchResultCounts = slotMatchResultCounts
            self.speechTranscriptionResultCounts = speechTranscriptionResultCounts
            self.totalResultCount = totalResultCount
        }

        private enum CodingKeys: String, CodingKey {
            case slotMatchResultCounts = "slotMatchResultCounts"
            case speechTranscriptionResultCounts = "speechTranscriptionResultCounts"
            case totalResultCount = "totalResultCount"
        }
    }

    public struct SlotSortBy: AWSEncodableShape {
        /// The attribute to use to sort the list.
        public let attribute: SlotSortAttribute
        /// The order to sort the list. You can choose ascending or descending.
        public let order: SortOrder

        @inlinable
        public init(attribute: SlotSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct SlotSummary: AWSDecodableShape {
        /// The description of the slot.
        public let description: String?
        /// The timestamp of the last date and time that the slot was updated.
        public let lastUpdatedDateTime: Date?
        /// Whether the slot is required or optional. An intent is complete when all required slots are filled.
        public let slotConstraint: SlotConstraint?
        /// The unique identifier of the slot.
        public let slotId: String?
        /// The name given to the slot.
        public let slotName: String?
        /// The unique identifier for the slot type that defines the values for the slot.
        public let slotTypeId: String?
        /// Prompts that are sent to the user to elicit a value for the slot.
        public let valueElicitationPromptSpecification: PromptSpecification?

        @inlinable
        public init(description: String? = nil, lastUpdatedDateTime: Date? = nil, slotConstraint: SlotConstraint? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, valueElicitationPromptSpecification: PromptSpecification? = nil) {
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.slotConstraint = slotConstraint
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.valueElicitationPromptSpecification = valueElicitationPromptSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case slotConstraint = "slotConstraint"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case valueElicitationPromptSpecification = "valueElicitationPromptSpecification"
        }
    }

    public struct SlotTypeFilter: AWSEncodableShape {
        /// The name of the field to use for filtering.
        public let name: SlotTypeFilterName
        /// The operator to use for the filter. Specify EQ when the ListSlotTypes operation should return only aliases that equal the specified value. Specify CO when the ListSlotTypes operation should return aliases that contain the specified value.
        public let `operator`: SlotTypeFilterOperator
        /// The value to use to filter the response.
        public let values: [String]

        @inlinable
        public init(name: SlotTypeFilterName, operator: SlotTypeFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z_()\\s-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SlotTypeSortBy: AWSEncodableShape {
        /// The attribute to use to sort the list of slot types.
        public let attribute: SlotTypeSortAttribute
        /// The order to sort the list. You can say ascending or descending.
        public let order: SortOrder

        @inlinable
        public init(attribute: SlotTypeSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct SlotTypeStatistics: AWSDecodableShape {
        /// The number of recommended slot types associated with the bot recommendation.
        public let discoveredSlotTypeCount: Int?

        @inlinable
        public init(discoveredSlotTypeCount: Int? = nil) {
            self.discoveredSlotTypeCount = discoveredSlotTypeCount
        }

        private enum CodingKeys: String, CodingKey {
            case discoveredSlotTypeCount = "discoveredSlotTypeCount"
        }
    }

    public struct SlotTypeSummary: AWSDecodableShape {
        /// The description of the slot type.
        public let description: String?
        /// A timestamp of the date and time that the slot type was last updated.
        public let lastUpdatedDateTime: Date?
        /// If the slot type is derived from a built-on slot type, the name of the parent slot type.
        public let parentSlotTypeSignature: String?
        /// Indicates the type of the slot type.    Custom - A slot type that you created using custom values. For more information, see Creating custom slot types.    Extended - A slot type created by extending the AMAZON.AlphaNumeric built-in slot type. For more information, see  AMAZON.AlphaNumeric .    ExternalGrammar - A slot type using a custom GRXML grammar to define values. For more information, see Using a custom grammar slot type.
        public let slotTypeCategory: SlotTypeCategory?
        /// The unique identifier assigned to the slot type.
        public let slotTypeId: String?
        /// The name of the slot type.
        public let slotTypeName: String?

        @inlinable
        public init(description: String? = nil, lastUpdatedDateTime: Date? = nil, parentSlotTypeSignature: String? = nil, slotTypeCategory: SlotTypeCategory? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil) {
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeCategory = slotTypeCategory
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeCategory = "slotTypeCategory"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
        }
    }

    public struct SlotTypeValue: AWSEncodableShape & AWSDecodableShape {
        /// The value of the slot type entry.
        public let sampleValue: SampleValue?
        /// Additional values related to the slot type entry.
        public let synonyms: [SampleValue]?

        @inlinable
        public init(sampleValue: SampleValue? = nil, synonyms: [SampleValue]? = nil) {
            self.sampleValue = sampleValue
            self.synonyms = synonyms
        }

        public func validate(name: String) throws {
            try self.sampleValue?.validate(name: "\(name).sampleValue")
            try self.synonyms?.forEach {
                try $0.validate(name: "\(name).synonyms[]")
            }
            try self.validate(self.synonyms, name: "synonyms", parent: name, max: 10000)
            try self.validate(self.synonyms, name: "synonyms", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sampleValue = "sampleValue"
            case synonyms = "synonyms"
        }
    }

    public struct SlotValue: AWSEncodableShape & AWSDecodableShape {
        /// The value that Amazon Lex determines for the slot. The actual value depends on the setting of the value selection strategy for the bot. You can choose to use the value entered by the user, or you can have Amazon Lex choose the first value in the resolvedValues list.
        public let interpretedValue: String?

        @inlinable
        public init(interpretedValue: String? = nil) {
            self.interpretedValue = interpretedValue
        }

        public func validate(name: String) throws {
            try self.validate(self.interpretedValue, name: "interpretedValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case interpretedValue = "interpretedValue"
        }
    }

    public struct SlotValueElicitationSetting: AWSEncodableShape & AWSDecodableShape {
        /// A list of default values for a slot. Default values are used when Amazon Lex hasn't determined a value for a slot. You can specify default values from context variables, session attributes, and defined values.
        public let defaultValueSpecification: SlotDefaultValueSpecification?
        /// The prompt that Amazon Lex uses to elicit the slot value from the user.
        public let promptSpecification: PromptSpecification?
        /// If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances.
        public let sampleUtterances: [SampleUtterance]?
        /// Specifies the settings that Amazon Lex uses when a slot value is successfully entered by a user.
        public let slotCaptureSetting: SlotCaptureSetting?
        /// Specifies whether the slot is required or optional.
        public let slotConstraint: SlotConstraint
        /// An object containing information about whether assisted slot resolution is turned on for the slot or not.
        public let slotResolutionSetting: SlotResolutionSetting?
        public let waitAndContinueSpecification: WaitAndContinueSpecification?

        @inlinable
        public init(defaultValueSpecification: SlotDefaultValueSpecification? = nil, promptSpecification: PromptSpecification? = nil, sampleUtterances: [SampleUtterance]? = nil, slotCaptureSetting: SlotCaptureSetting? = nil, slotConstraint: SlotConstraint, slotResolutionSetting: SlotResolutionSetting? = nil, waitAndContinueSpecification: WaitAndContinueSpecification? = nil) {
            self.defaultValueSpecification = defaultValueSpecification
            self.promptSpecification = promptSpecification
            self.sampleUtterances = sampleUtterances
            self.slotCaptureSetting = slotCaptureSetting
            self.slotConstraint = slotConstraint
            self.slotResolutionSetting = slotResolutionSetting
            self.waitAndContinueSpecification = waitAndContinueSpecification
        }

        public func validate(name: String) throws {
            try self.defaultValueSpecification?.validate(name: "\(name).defaultValueSpecification")
            try self.promptSpecification?.validate(name: "\(name).promptSpecification")
            try self.slotCaptureSetting?.validate(name: "\(name).slotCaptureSetting")
            try self.waitAndContinueSpecification?.validate(name: "\(name).waitAndContinueSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValueSpecification = "defaultValueSpecification"
            case promptSpecification = "promptSpecification"
            case sampleUtterances = "sampleUtterances"
            case slotCaptureSetting = "slotCaptureSetting"
            case slotConstraint = "slotConstraint"
            case slotResolutionSetting = "slotResolutionSetting"
            case waitAndContinueSpecification = "waitAndContinueSpecification"
        }
    }

    public struct SlotValueOverride: AWSEncodableShape & AWSDecodableShape {
        /// When the shape value is List, it indicates that the values field contains a list of slot values. When the value is Scalar, it indicates that the value field contains a single value.
        public let shape: SlotShape?
        /// The current value of the slot.
        public let value: SlotValue?
        /// A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        public let values: [SlotValueOverride]?

        @inlinable
        public init(shape: SlotShape? = nil, value: SlotValue? = nil, values: [SlotValueOverride]? = nil) {
            self.shape = shape
            self.value = value
            self.values = values
        }

        public func validate(name: String) throws {
            try self.value?.validate(name: "\(name).value")
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case shape = "shape"
            case value = "value"
            case values = "values"
        }
    }

    public struct SlotValueRegexFilter: AWSEncodableShape & AWSDecodableShape {
        /// A regular expression used to validate the value of a slot. Use a standard regular expression. Amazon Lex supports the following characters in the regular expression:    A-Z, a-z   0-9   Unicode characters ("\⁠u")   Represent Unicode characters with four digits, for example "\⁠u0041" or "\⁠u005A".  The following regular expression operators are not supported:    Infinite repeaters: *, +, or {x,} with no upper bound.   Wild card (.)
        public let pattern: String

        @inlinable
        public init(pattern: String) {
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.pattern, name: "pattern", parent: name, max: 300)
            try self.validate(self.pattern, name: "pattern", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pattern = "pattern"
        }
    }

    public struct SlotValueSelectionSetting: AWSEncodableShape & AWSDecodableShape {
        /// Provides settings that enable advanced recognition settings for slot values. You can use this to enable using slot values as a custom vocabulary for recognizing user utterances.
        public let advancedRecognitionSetting: AdvancedRecognitionSetting?
        /// A regular expression used to validate the value of a slot.
        public let regexFilter: SlotValueRegexFilter?
        /// Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:    ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to the slot value.    TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.   If you don't specify the valueSelectionStrategy, the  default is ORIGINAL_VALUE.
        public let resolutionStrategy: SlotValueResolutionStrategy

        @inlinable
        public init(advancedRecognitionSetting: AdvancedRecognitionSetting? = nil, regexFilter: SlotValueRegexFilter? = nil, resolutionStrategy: SlotValueResolutionStrategy) {
            self.advancedRecognitionSetting = advancedRecognitionSetting
            self.regexFilter = regexFilter
            self.resolutionStrategy = resolutionStrategy
        }

        public func validate(name: String) throws {
            try self.regexFilter?.validate(name: "\(name).regexFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case advancedRecognitionSetting = "advancedRecognitionSetting"
            case regexFilter = "regexFilter"
            case resolutionStrategy = "resolutionStrategy"
        }
    }

    public struct Specifications: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier assigned to the slot type.
        public let slotTypeId: String
        /// Specifies the elicitation setting details for constituent sub slots of a composite slot.
        public let valueElicitationSetting: SubSlotValueElicitationSetting

        @inlinable
        public init(slotTypeId: String, valueElicitationSetting: SubSlotValueElicitationSetting) {
            self.slotTypeId = slotTypeId
            self.valueElicitationSetting = valueElicitationSetting
        }

        public func validate(name: String) throws {
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 25)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 1)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^((AMAZON\\.)[a-zA-Z_]+?|[0-9a-zA-Z]+)$")
            try self.valueElicitationSetting.validate(name: "\(name).valueElicitationSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case slotTypeId = "slotTypeId"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct StartBotRecommendationRequest: AWSEncodableShape {
        /// The unique identifier of the bot containing the bot recommendation.
        public let botId: String
        /// The version of the bot containing the bot recommendation.
        public let botVersion: String
        /// The object representing the passwords that will be used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
        public let encryptionSetting: EncryptionSetting?
        /// The identifier of the language and locale of the bot recommendation to start. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String
        /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
        public let transcriptSourceSetting: TranscriptSourceSetting

        @inlinable
        public init(botId: String, botVersion: String, encryptionSetting: EncryptionSetting? = nil, localeId: String, transcriptSourceSetting: TranscriptSourceSetting) {
            self.botId = botId
            self.botVersion = botVersion
            self.encryptionSetting = encryptionSetting
            self.localeId = localeId
            self.transcriptSourceSetting = transcriptSourceSetting
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.encryptionSetting, forKey: .encryptionSetting)
            request.encodePath(self.localeId, key: "localeId")
            try container.encode(self.transcriptSourceSetting, forKey: .transcriptSourceSetting)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.encryptionSetting?.validate(name: "\(name).encryptionSetting")
            try self.transcriptSourceSetting.validate(name: "\(name).transcriptSourceSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionSetting = "encryptionSetting"
            case transcriptSourceSetting = "transcriptSourceSetting"
        }
    }

    public struct StartBotRecommendationResponse: AWSDecodableShape {
        /// The unique identifier of the bot containing the bot recommendation.
        public let botId: String?
        /// The identifier of the bot recommendation that you have created.
        public let botRecommendationId: String?
        /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
        public let botRecommendationStatus: BotRecommendationStatus?
        /// The version of the bot containing the bot recommendation.
        public let botVersion: String?
        /// A timestamp of the date and time that the bot recommendation was created.
        public let creationDateTime: Date?
        /// The object representing the passwords that were used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
        public let encryptionSetting: EncryptionSetting?
        /// The identifier of the language and locale of the bot recommendation to start. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String?
        /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
        public let transcriptSourceSetting: TranscriptSourceSetting?

        @inlinable
        public init(botId: String? = nil, botRecommendationId: String? = nil, botRecommendationStatus: BotRecommendationStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, encryptionSetting: EncryptionSetting? = nil, localeId: String? = nil, transcriptSourceSetting: TranscriptSourceSetting? = nil) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botRecommendationStatus = botRecommendationStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.encryptionSetting = encryptionSetting
            self.localeId = localeId
            self.transcriptSourceSetting = transcriptSourceSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botRecommendationId = "botRecommendationId"
            case botRecommendationStatus = "botRecommendationStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case encryptionSetting = "encryptionSetting"
            case localeId = "localeId"
            case transcriptSourceSetting = "transcriptSourceSetting"
        }
    }

    public struct StartBotResourceGenerationRequest: AWSEncodableShape {
        /// The unique identifier of the bot for which to generate intents and slot types.
        public let botId: String
        /// The version of the bot for which to generate intents and slot types.
        public let botVersion: String
        /// The prompt to generate intents and slot types for the bot locale. Your description should be both detailed and precise to help generate appropriate and sufficient intents for your bot. Include a list of actions to improve the intent creation process.
        public let generationInputPrompt: String
        /// The locale of the bot for which to generate intents and slot types.
        public let localeId: String

        @inlinable
        public init(botId: String, botVersion: String, generationInputPrompt: String, localeId: String) {
            self.botId = botId
            self.botVersion = botVersion
            self.generationInputPrompt = generationInputPrompt
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encode(self.generationInputPrompt, forKey: .generationInputPrompt)
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.validate(self.generationInputPrompt, name: "generationInputPrompt", parent: name, max: 2000)
            try self.validate(self.generationInputPrompt, name: "generationInputPrompt", parent: name, min: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case generationInputPrompt = "generationInputPrompt"
        }
    }

    public struct StartBotResourceGenerationResponse: AWSDecodableShape {
        /// The unique identifier of the bot for which the generation request was made.
        public let botId: String?
        /// The version of the bot for which the generation request was made.
        public let botVersion: String?
        /// The date and time at which the generation request was made.
        public let creationDateTime: Date?
        /// The unique identifier of the generation request.
        public let generationId: String?
        /// The prompt that was used generate intents and slot types for the bot locale.
        public let generationInputPrompt: String?
        /// The status of the generation request.
        public let generationStatus: GenerationStatus?
        /// The locale of the bot for which the generation request was made.
        public let localeId: String?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, generationId: String? = nil, generationInputPrompt: String? = nil, generationStatus: GenerationStatus? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.generationId = generationId
            self.generationInputPrompt = generationInputPrompt
            self.generationStatus = generationStatus
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case generationId = "generationId"
            case generationInputPrompt = "generationInputPrompt"
            case generationStatus = "generationStatus"
            case localeId = "localeId"
        }
    }

    public struct StartImportRequest: AWSEncodableShape {
        /// The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex.
        public let filePassword: String?
        /// The unique identifier for the import. It is included in the response from the CreateUploadUrl operation.
        public let importId: String
        /// The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is FailOnConflict existing resources are not overwritten and the import fails.
        public let mergeStrategy: MergeStrategy
        /// Parameters for creating the bot, bot locale or custom vocabulary.
        public let resourceSpecification: ImportResourceSpecification

        @inlinable
        public init(filePassword: String? = nil, importId: String, mergeStrategy: MergeStrategy, resourceSpecification: ImportResourceSpecification) {
            self.filePassword = filePassword
            self.importId = importId
            self.mergeStrategy = mergeStrategy
            self.resourceSpecification = resourceSpecification
        }

        public func validate(name: String) throws {
            try self.validate(self.filePassword, name: "filePassword", parent: name, max: 1024)
            try self.validate(self.filePassword, name: "filePassword", parent: name, min: 1)
            try self.validate(self.importId, name: "importId", parent: name, max: 10)
            try self.validate(self.importId, name: "importId", parent: name, min: 10)
            try self.validate(self.importId, name: "importId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.resourceSpecification.validate(name: "\(name).resourceSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case filePassword = "filePassword"
            case importId = "importId"
            case mergeStrategy = "mergeStrategy"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct StartImportResponse: AWSDecodableShape {
        /// The date and time that the import request was created.
        public let creationDateTime: Date?
        /// A unique identifier for the import.
        public let importId: String?
        /// The current status of the import. When the status is Complete the bot, bot alias, or custom vocabulary is ready to use.
        public let importStatus: ImportStatus?
        /// The strategy used when there was a name conflict between the imported resource and an existing resource. When the merge strategy is FailOnConflict existing resources are not overwritten and the import fails.
        public let mergeStrategy: MergeStrategy?
        /// The parameters used when importing the resource.
        public let resourceSpecification: ImportResourceSpecification?

        @inlinable
        public init(creationDateTime: Date? = nil, importId: String? = nil, importStatus: ImportStatus? = nil, mergeStrategy: MergeStrategy? = nil, resourceSpecification: ImportResourceSpecification? = nil) {
            self.creationDateTime = creationDateTime
            self.importId = importId
            self.importStatus = importStatus
            self.mergeStrategy = mergeStrategy
            self.resourceSpecification = resourceSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case importId = "importId"
            case importStatus = "importStatus"
            case mergeStrategy = "mergeStrategy"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct StartTestExecutionRequest: AWSEncodableShape {
        /// Indicates whether we use streaming or non-streaming APIs for the test set  execution. For streaming, StartConversation Runtime API is used. Whereas, for  non-streaming, RecognizeUtterance and RecognizeText Amazon Lex  Runtime API are used.
        public let apiMode: TestExecutionApiMode
        /// The target bot for the test set execution.
        public let target: TestExecutionTarget
        /// Indicates whether audio or text is used.
        public let testExecutionModality: TestExecutionModality?
        /// The test set Id for the test set execution.
        public let testSetId: String

        @inlinable
        public init(apiMode: TestExecutionApiMode, target: TestExecutionTarget, testExecutionModality: TestExecutionModality? = nil, testSetId: String) {
            self.apiMode = apiMode
            self.target = target
            self.testExecutionModality = testExecutionModality
            self.testSetId = testSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.apiMode, forKey: .apiMode)
            try container.encode(self.target, forKey: .target)
            try container.encodeIfPresent(self.testExecutionModality, forKey: .testExecutionModality)
            request.encodePath(self.testSetId, key: "testSetId")
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
            try self.validate(self.testSetId, name: "testSetId", parent: name, max: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, min: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case apiMode = "apiMode"
            case target = "target"
            case testExecutionModality = "testExecutionModality"
        }
    }

    public struct StartTestExecutionResponse: AWSDecodableShape {
        /// Indicates whether we use streaming or non-streaming APIs for the test set  execution. For streaming, StartConversation Amazon Lex Runtime API is used. Whereas  for non-streaming, RecognizeUtterance and RecognizeText Amazon Lex Runtime API are used.
        public let apiMode: TestExecutionApiMode?
        /// The creation date and time for the test set execution.
        public let creationDateTime: Date?
        /// The target bot for the test set execution.
        public let target: TestExecutionTarget?
        /// The unique identifier of the test set execution.
        public let testExecutionId: String?
        /// Indicates whether audio or text is used.
        public let testExecutionModality: TestExecutionModality?
        /// The test set Id for the test set execution.
        public let testSetId: String?

        @inlinable
        public init(apiMode: TestExecutionApiMode? = nil, creationDateTime: Date? = nil, target: TestExecutionTarget? = nil, testExecutionId: String? = nil, testExecutionModality: TestExecutionModality? = nil, testSetId: String? = nil) {
            self.apiMode = apiMode
            self.creationDateTime = creationDateTime
            self.target = target
            self.testExecutionId = testExecutionId
            self.testExecutionModality = testExecutionModality
            self.testSetId = testSetId
        }

        private enum CodingKeys: String, CodingKey {
            case apiMode = "apiMode"
            case creationDateTime = "creationDateTime"
            case target = "target"
            case testExecutionId = "testExecutionId"
            case testExecutionModality = "testExecutionModality"
            case testSetId = "testSetId"
        }
    }

    public struct StartTestSetGenerationRequest: AWSEncodableShape {
        /// The test set description for the test set generation request.
        public let description: String?
        /// The data source for the test set generation.
        public let generationDataSource: TestSetGenerationDataSource
        /// The roleARN used for any operation in the test set to access  resources in the Amazon Web Services account.
        public let roleArn: String
        /// The Amazon S3 storage location for the test set generation.
        public let storageLocation: TestSetStorageLocation
        /// The test set name for the test set generation request.
        public let testSetName: String
        /// A list of tags to add to the test set. You can only add tags when you import/generate a new test set. You can't use the UpdateTestSet operation to update tags. To update tags, use the TagResource operation.
        public let testSetTags: [String: String]?

        @inlinable
        public init(description: String? = nil, generationDataSource: TestSetGenerationDataSource, roleArn: String, storageLocation: TestSetStorageLocation, testSetName: String, testSetTags: [String: String]? = nil) {
            self.description = description
            self.generationDataSource = generationDataSource
            self.roleArn = roleArn
            self.storageLocation = storageLocation
            self.testSetName = testSetName
            self.testSetTags = testSetTags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.generationDataSource.validate(name: "\(name).generationDataSource")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/.*$")
            try self.storageLocation.validate(name: "\(name).storageLocation")
            try self.validate(self.testSetName, name: "testSetName", parent: name, max: 100)
            try self.validate(self.testSetName, name: "testSetName", parent: name, min: 1)
            try self.validate(self.testSetName, name: "testSetName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.testSetTags?.forEach {
                try validate($0.key, name: "testSetTags.key", parent: name, max: 128)
                try validate($0.key, name: "testSetTags.key", parent: name, min: 1)
                try validate($0.value, name: "testSetTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.testSetTags, name: "testSetTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case generationDataSource = "generationDataSource"
            case roleArn = "roleArn"
            case storageLocation = "storageLocation"
            case testSetName = "testSetName"
            case testSetTags = "testSetTags"
        }
    }

    public struct StartTestSetGenerationResponse: AWSDecodableShape {
        ///  The creation date and time for the test set generation.
        public let creationDateTime: Date?
        /// The description used for the test set generation.
        public let description: String?
        ///  The data source for the test set generation.
        public let generationDataSource: TestSetGenerationDataSource?
        /// The roleARN used for any operation in the test set to access resources  in the Amazon Web Services account.
        public let roleArn: String?
        /// The Amazon S3 storage location for the test set generation.
        public let storageLocation: TestSetStorageLocation?
        /// The unique identifier of the test set generation to describe.
        public let testSetGenerationId: String?
        ///  The status for the test set generation.
        public let testSetGenerationStatus: TestSetGenerationStatus?
        /// The test set name used for the test set generation.
        public let testSetName: String?
        /// A list of tags that was used for the test set that is being generated.
        public let testSetTags: [String: String]?

        @inlinable
        public init(creationDateTime: Date? = nil, description: String? = nil, generationDataSource: TestSetGenerationDataSource? = nil, roleArn: String? = nil, storageLocation: TestSetStorageLocation? = nil, testSetGenerationId: String? = nil, testSetGenerationStatus: TestSetGenerationStatus? = nil, testSetName: String? = nil, testSetTags: [String: String]? = nil) {
            self.creationDateTime = creationDateTime
            self.description = description
            self.generationDataSource = generationDataSource
            self.roleArn = roleArn
            self.storageLocation = storageLocation
            self.testSetGenerationId = testSetGenerationId
            self.testSetGenerationStatus = testSetGenerationStatus
            self.testSetName = testSetName
            self.testSetTags = testSetTags
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case description = "description"
            case generationDataSource = "generationDataSource"
            case roleArn = "roleArn"
            case storageLocation = "storageLocation"
            case testSetGenerationId = "testSetGenerationId"
            case testSetGenerationStatus = "testSetGenerationStatus"
            case testSetName = "testSetName"
            case testSetTags = "testSetTags"
        }
    }

    public struct StillWaitingResponseSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Indicates that the user can interrupt the response by speaking while the message is being played.
        public let allowInterrupt: Bool?
        /// How often a message should be sent to the user. Minimum of 1 second, maximum of 5 minutes.
        public let frequencyInSeconds: Int
        /// One or more message groups, each containing one or more messages, that define the prompts that Amazon Lex sends to the user.
        public let messageGroups: [MessageGroup]
        /// If Amazon Lex waits longer than this length of time for a response, it will stop sending messages.
        public let timeoutInSeconds: Int

        @inlinable
        public init(allowInterrupt: Bool? = nil, frequencyInSeconds: Int, messageGroups: [MessageGroup], timeoutInSeconds: Int) {
            self.allowInterrupt = allowInterrupt
            self.frequencyInSeconds = frequencyInSeconds
            self.messageGroups = messageGroups
            self.timeoutInSeconds = timeoutInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.frequencyInSeconds, name: "frequencyInSeconds", parent: name, max: 300)
            try self.validate(self.frequencyInSeconds, name: "frequencyInSeconds", parent: name, min: 1)
            try self.messageGroups.forEach {
                try $0.validate(name: "\(name).messageGroups[]")
            }
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, max: 5)
            try self.validate(self.messageGroups, name: "messageGroups", parent: name, min: 1)
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, max: 900)
            try self.validate(self.timeoutInSeconds, name: "timeoutInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowInterrupt = "allowInterrupt"
            case frequencyInSeconds = "frequencyInSeconds"
            case messageGroups = "messageGroups"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct StopBotRecommendationRequest: AWSEncodableShape {
        /// The unique identifier of the bot containing the bot recommendation to be stopped.
        public let botId: String
        /// The unique identifier of the bot recommendation to be stopped.
        public let botRecommendationId: String
        /// The version of the bot containing the bot recommendation.
        public let botVersion: String
        /// The identifier of the language and locale of the bot recommendation to stop. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String

        @inlinable
        public init(botId: String, botRecommendationId: String, botVersion: String, localeId: String) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botVersion = botVersion
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botRecommendationId, key: "botRecommendationId")
            request.encodePath(self.botVersion, key: "botVersion")
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, max: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, min: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopBotRecommendationResponse: AWSDecodableShape {
        /// The unique identifier of the bot containing the bot recommendation that  is being stopped.
        public let botId: String?
        /// The unique identifier of the bot recommendation that is being stopped.
        public let botRecommendationId: String?
        /// The status of the bot recommendation. If the status is Failed,  then the reasons for the failure are listed in the failureReasons field.
        public let botRecommendationStatus: BotRecommendationStatus?
        /// The version of the bot containing the recommendation that is being  stopped.
        public let botVersion: String?
        /// The identifier of the language and locale of the bot response to stop. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String?

        @inlinable
        public init(botId: String? = nil, botRecommendationId: String? = nil, botRecommendationStatus: BotRecommendationStatus? = nil, botVersion: String? = nil, localeId: String? = nil) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botRecommendationStatus = botRecommendationStatus
            self.botVersion = botVersion
            self.localeId = localeId
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botRecommendationId = "botRecommendationId"
            case botRecommendationStatus = "botRecommendationStatus"
            case botVersion = "botVersion"
            case localeId = "localeId"
        }
    }

    public struct SubSlotSetting: AWSEncodableShape & AWSDecodableShape {
        /// The expression text for defining the constituent sub slots in the composite slot using logical AND and OR operators.
        public let expression: String?
        /// Specifications for the constituent sub slots of a composite slot.
        public let slotSpecifications: [String: Specifications]?

        @inlinable
        public init(expression: String? = nil, slotSpecifications: [String: Specifications]? = nil) {
            self.expression = expression
            self.slotSpecifications = slotSpecifications
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 640)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[0-9A-Za-z_\\-\\s\\(\\)]+$")
            try self.slotSpecifications?.forEach {
                try validate($0.key, name: "slotSpecifications.key", parent: name, max: 100)
                try validate($0.key, name: "slotSpecifications.key", parent: name, min: 1)
                try validate($0.key, name: "slotSpecifications.key", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
                try $0.value.validate(name: "\(name).slotSpecifications[\"\($0.key)\"]")
            }
            try self.validate(self.slotSpecifications, name: "slotSpecifications", parent: name, max: 6)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case slotSpecifications = "slotSpecifications"
        }
    }

    public struct SubSlotTypeComposition: AWSEncodableShape & AWSDecodableShape {
        /// Name of a constituent sub slot inside a composite slot.
        public let name: String
        /// The unique identifier assigned to a slot type.  This refers to either a built-in slot type or the unique slotTypeId of a custom slot type.
        public let slotTypeId: String

        @inlinable
        public init(name: String, slotTypeId: String) {
            self.name = name
            self.slotTypeId = slotTypeId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 25)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 1)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^((AMAZON\\.)[a-zA-Z_]+?|[0-9a-zA-Z]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case slotTypeId = "slotTypeId"
        }
    }

    public struct SubSlotValueElicitationSetting: AWSEncodableShape & AWSDecodableShape {
        public let defaultValueSpecification: SlotDefaultValueSpecification?
        public let promptSpecification: PromptSpecification
        /// If you know a specific pattern that users might respond to an Amazon Lex request for a sub slot value,  you can provide those utterances to improve accuracy. This is optional. In most cases Amazon Lex is capable  of understanding user utterances. This is similar to SampleUtterances for slots.
        public let sampleUtterances: [SampleUtterance]?
        public let waitAndContinueSpecification: WaitAndContinueSpecification?

        @inlinable
        public init(defaultValueSpecification: SlotDefaultValueSpecification? = nil, promptSpecification: PromptSpecification, sampleUtterances: [SampleUtterance]? = nil, waitAndContinueSpecification: WaitAndContinueSpecification? = nil) {
            self.defaultValueSpecification = defaultValueSpecification
            self.promptSpecification = promptSpecification
            self.sampleUtterances = sampleUtterances
            self.waitAndContinueSpecification = waitAndContinueSpecification
        }

        public func validate(name: String) throws {
            try self.defaultValueSpecification?.validate(name: "\(name).defaultValueSpecification")
            try self.promptSpecification.validate(name: "\(name).promptSpecification")
            try self.waitAndContinueSpecification?.validate(name: "\(name).waitAndContinueSpecification")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValueSpecification = "defaultValueSpecification"
            case promptSpecification = "promptSpecification"
            case sampleUtterances = "sampleUtterances"
            case waitAndContinueSpecification = "waitAndContinueSpecification"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the bot, bot alias, or bot channel to tag.
        public let resourceARN: String
        /// A list of tag keys to add to the resource. If a tag key already exists, the existing value is replaced with the new value.
        public let tags: [String: String]

        @inlinable
        public init(resourceARN: String, tags: [String: String]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TestExecutionResultFilterBy: AWSEncodableShape {
        /// Contains information about the method for filtering Conversation level test results.
        public let conversationLevelTestResultsFilterBy: ConversationLevelTestResultsFilterBy?
        /// Specifies which results to filter. See Test result details">Test results details  for details about different types of results.
        public let resultTypeFilter: TestResultTypeFilter

        @inlinable
        public init(conversationLevelTestResultsFilterBy: ConversationLevelTestResultsFilterBy? = nil, resultTypeFilter: TestResultTypeFilter) {
            self.conversationLevelTestResultsFilterBy = conversationLevelTestResultsFilterBy
            self.resultTypeFilter = resultTypeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case conversationLevelTestResultsFilterBy = "conversationLevelTestResultsFilterBy"
            case resultTypeFilter = "resultTypeFilter"
        }
    }

    public struct TestExecutionResultItems: AWSDecodableShape {
        /// Results related to conversations in the test set, including metrics about success and failure of conversations and intent and slot failures.
        public let conversationLevelTestResults: ConversationLevelTestResults?
        /// Intent recognition results aggregated by intent name. The aggregated results contain success and failure rates of intent recognition, speech transcriptions, and end-to-end conversations.
        public let intentClassificationTestResults: IntentClassificationTestResults?
        /// Slot resolution results aggregated by intent and slot name. The aggregated results contain success and failure rates of slot resolution, speech transcriptions, and end-to-end conversations
        public let intentLevelSlotResolutionTestResults: IntentLevelSlotResolutionTestResults?
        /// Overall results for the test execution, including the breakdown of conversations and  single-input utterances.
        public let overallTestResults: OverallTestResults?
        /// Results related to utterances in the test set.
        public let utteranceLevelTestResults: UtteranceLevelTestResults?

        @inlinable
        public init(conversationLevelTestResults: ConversationLevelTestResults? = nil, intentClassificationTestResults: IntentClassificationTestResults? = nil, intentLevelSlotResolutionTestResults: IntentLevelSlotResolutionTestResults? = nil, overallTestResults: OverallTestResults? = nil, utteranceLevelTestResults: UtteranceLevelTestResults? = nil) {
            self.conversationLevelTestResults = conversationLevelTestResults
            self.intentClassificationTestResults = intentClassificationTestResults
            self.intentLevelSlotResolutionTestResults = intentLevelSlotResolutionTestResults
            self.overallTestResults = overallTestResults
            self.utteranceLevelTestResults = utteranceLevelTestResults
        }

        private enum CodingKeys: String, CodingKey {
            case conversationLevelTestResults = "conversationLevelTestResults"
            case intentClassificationTestResults = "intentClassificationTestResults"
            case intentLevelSlotResolutionTestResults = "intentLevelSlotResolutionTestResults"
            case overallTestResults = "overallTestResults"
            case utteranceLevelTestResults = "utteranceLevelTestResults"
        }
    }

    public struct TestExecutionSortBy: AWSEncodableShape {
        /// Specifies whether to sort the test set executions by the date and time at which the test sets were created.
        public let attribute: TestExecutionSortAttribute
        /// Specifies whether to sort in ascending or descending order.
        public let order: SortOrder

        @inlinable
        public init(attribute: TestExecutionSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct TestExecutionSummary: AWSDecodableShape {
        /// Specifies whether the API mode for the test execution is streaming  or non-streaming.
        public let apiMode: TestExecutionApiMode?
        /// The date and time at which the test execution was created.
        public let creationDateTime: Date?
        /// The date and time at which the test execution was last updated.
        public let lastUpdatedDateTime: Date?
        /// Contains information about the bot used for the test execution..
        public let target: TestExecutionTarget?
        /// The unique identifier of the test execution.
        public let testExecutionId: String?
        /// Specifies whether the data used for the test execution is written or spoken.
        public let testExecutionModality: TestExecutionModality?
        /// The current status of the test execution.
        public let testExecutionStatus: TestExecutionStatus?
        /// The unique identifier of the test set used in the test execution.
        public let testSetId: String?
        /// The name of the test set used in the test execution.
        public let testSetName: String?

        @inlinable
        public init(apiMode: TestExecutionApiMode? = nil, creationDateTime: Date? = nil, lastUpdatedDateTime: Date? = nil, target: TestExecutionTarget? = nil, testExecutionId: String? = nil, testExecutionModality: TestExecutionModality? = nil, testExecutionStatus: TestExecutionStatus? = nil, testSetId: String? = nil, testSetName: String? = nil) {
            self.apiMode = apiMode
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.target = target
            self.testExecutionId = testExecutionId
            self.testExecutionModality = testExecutionModality
            self.testExecutionStatus = testExecutionStatus
            self.testSetId = testSetId
            self.testSetName = testSetName
        }

        private enum CodingKeys: String, CodingKey {
            case apiMode = "apiMode"
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case target = "target"
            case testExecutionId = "testExecutionId"
            case testExecutionModality = "testExecutionModality"
            case testExecutionStatus = "testExecutionStatus"
            case testSetId = "testSetId"
            case testSetName = "testSetName"
        }
    }

    public struct TestExecutionTarget: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about the bot alias used for the test execution.
        public let botAliasTarget: BotAliasTestExecutionTarget?

        @inlinable
        public init(botAliasTarget: BotAliasTestExecutionTarget? = nil) {
            self.botAliasTarget = botAliasTarget
        }

        public func validate(name: String) throws {
            try self.botAliasTarget?.validate(name: "\(name).botAliasTarget")
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasTarget = "botAliasTarget"
        }
    }

    public struct TestSetDiscrepancyErrors: AWSDecodableShape {
        /// Contains information about discrepancies found for intents between the test set and the bot.
        public let intentDiscrepancies: [TestSetIntentDiscrepancyItem]
        /// Contains information about discrepancies found for slots between the test set and the bot.
        public let slotDiscrepancies: [TestSetSlotDiscrepancyItem]

        @inlinable
        public init(intentDiscrepancies: [TestSetIntentDiscrepancyItem], slotDiscrepancies: [TestSetSlotDiscrepancyItem]) {
            self.intentDiscrepancies = intentDiscrepancies
            self.slotDiscrepancies = slotDiscrepancies
        }

        private enum CodingKeys: String, CodingKey {
            case intentDiscrepancies = "intentDiscrepancies"
            case slotDiscrepancies = "slotDiscrepancies"
        }
    }

    public struct TestSetDiscrepancyReportBotAliasTarget: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the bot associated with the bot alias.
        public let botAliasId: String
        /// The unique identifier for the bot alias.
        public let botId: String
        /// The unique identifier of the locale associated with the bot alias.
        public let localeId: String

        @inlinable
        public init(botAliasId: String, botId: String, localeId: String) {
            self.botAliasId = botAliasId
            self.botId = botId
            self.localeId = localeId
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botId = "botId"
            case localeId = "localeId"
        }
    }

    public struct TestSetDiscrepancyReportResourceTarget: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about the bot alias used as the resource for the test set discrepancy report.
        public let botAliasTarget: TestSetDiscrepancyReportBotAliasTarget?

        @inlinable
        public init(botAliasTarget: TestSetDiscrepancyReportBotAliasTarget? = nil) {
            self.botAliasTarget = botAliasTarget
        }

        public func validate(name: String) throws {
            try self.botAliasTarget?.validate(name: "\(name).botAliasTarget")
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasTarget = "botAliasTarget"
        }
    }

    public struct TestSetExportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the test set.
        public let testSetId: String

        @inlinable
        public init(testSetId: String) {
            self.testSetId = testSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.testSetId, name: "testSetId", parent: name, max: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, min: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case testSetId = "testSetId"
        }
    }

    public struct TestSetGenerationDataSource: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about the bot from which the conversation logs are sourced.
        public let conversationLogsDataSource: ConversationLogsDataSource?

        @inlinable
        public init(conversationLogsDataSource: ConversationLogsDataSource? = nil) {
            self.conversationLogsDataSource = conversationLogsDataSource
        }

        public func validate(name: String) throws {
            try self.conversationLogsDataSource?.validate(name: "\(name).conversationLogsDataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case conversationLogsDataSource = "conversationLogsDataSource"
        }
    }

    public struct TestSetImportInputLocation: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket.
        public let s3BucketName: String
        /// The path inside the Amazon S3 bucket pointing to the test-set CSV file.
        public let s3Path: String

        @inlinable
        public init(s3BucketName: String, s3Path: String) {
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.s3Path, name: "s3Path", parent: name, max: 1024)
            try self.validate(self.s3Path, name: "s3Path", parent: name, min: 1)
            try self.validate(self.s3Path, name: "s3Path", parent: name, pattern: "^[\\.\\-\\!\\*\\_\\'\\(\\)a-zA-Z0-9][\\.\\-\\!\\*\\_\\'\\(\\)\\/a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "s3BucketName"
            case s3Path = "s3Path"
        }
    }

    public struct TestSetImportResourceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The description of the test set.
        public let description: String?
        /// Contains information about the input location from where test-set should be imported.
        public let importInputLocation: TestSetImportInputLocation
        /// Specifies whether the test-set being imported contains written or spoken data.
        public let modality: TestSetModality
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the test set.
        public let roleArn: String
        /// Contains information about the location that Amazon Lex uses to store the test-set.
        public let storageLocation: TestSetStorageLocation
        /// The name of the test set.
        public let testSetName: String
        /// A list of tags to add to the test set. You can only add tags when you import/generate a new test set. You can't use the UpdateTestSet operation to update tags. To update tags, use the TagResource operation.
        public let testSetTags: [String: String]?

        @inlinable
        public init(description: String? = nil, importInputLocation: TestSetImportInputLocation, modality: TestSetModality, roleArn: String, storageLocation: TestSetStorageLocation, testSetName: String, testSetTags: [String: String]? = nil) {
            self.description = description
            self.importInputLocation = importInputLocation
            self.modality = modality
            self.roleArn = roleArn
            self.storageLocation = storageLocation
            self.testSetName = testSetName
            self.testSetTags = testSetTags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.importInputLocation.validate(name: "\(name).importInputLocation")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/.*$")
            try self.storageLocation.validate(name: "\(name).storageLocation")
            try self.validate(self.testSetName, name: "testSetName", parent: name, max: 100)
            try self.validate(self.testSetName, name: "testSetName", parent: name, min: 1)
            try self.validate(self.testSetName, name: "testSetName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.testSetTags?.forEach {
                try validate($0.key, name: "testSetTags.key", parent: name, max: 128)
                try validate($0.key, name: "testSetTags.key", parent: name, min: 1)
                try validate($0.value, name: "testSetTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.testSetTags, name: "testSetTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case importInputLocation = "importInputLocation"
            case modality = "modality"
            case roleArn = "roleArn"
            case storageLocation = "storageLocation"
            case testSetName = "testSetName"
            case testSetTags = "testSetTags"
        }
    }

    public struct TestSetIntentDiscrepancyItem: AWSDecodableShape {
        /// The error message for a discrepancy for an intent between the test set and the bot.
        public let errorMessage: String
        /// The name of the intent in the discrepancy report.
        public let intentName: String

        @inlinable
        public init(errorMessage: String, intentName: String) {
            self.errorMessage = errorMessage
            self.intentName = intentName
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case intentName = "intentName"
        }
    }

    public struct TestSetSlotDiscrepancyItem: AWSDecodableShape {
        /// The error message for a discrepancy for an intent between the test set and the bot.
        public let errorMessage: String
        /// The name of the intent associated with the slot in the discrepancy report.
        public let intentName: String
        /// The name of the slot in the discrepancy report.
        public let slotName: String

        @inlinable
        public init(errorMessage: String, intentName: String, slotName: String) {
            self.errorMessage = errorMessage
            self.intentName = intentName
            self.slotName = slotName
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case intentName = "intentName"
            case slotName = "slotName"
        }
    }

    public struct TestSetSortBy: AWSEncodableShape {
        /// Specifies whether to sort the test sets by name or by the time they were last updated.
        public let attribute: TestSetSortAttribute
        /// Specifies whether to sort in ascending or descending order.
        public let order: SortOrder

        @inlinable
        public init(attribute: TestSetSortAttribute, order: SortOrder) {
            self.attribute = attribute
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct TestSetStorageLocation: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services Key Management Service (KMS) key for encrypting the test set.
        public let kmsKeyArn: String?
        /// The name of the Amazon S3 bucket in which the test set is stored.
        public let s3BucketName: String
        /// The path inside the Amazon S3 bucket where the test set is stored.
        public let s3Path: String

        @inlinable
        public init(kmsKeyArn: String? = nil, s3BucketName: String, s3Path: String) {
            self.kmsKeyArn = kmsKeyArn
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:[\\w\\-]+:kms:[\\w\\-]+:[\\d]{12}:(?:key\\/[\\w\\-]+|alias\\/[a-zA-Z0-9:\\/_\\-]{1,256})$")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.s3Path, name: "s3Path", parent: name, max: 1024)
            try self.validate(self.s3Path, name: "s3Path", parent: name, min: 1)
            try self.validate(self.s3Path, name: "s3Path", parent: name, pattern: "^[\\.\\-\\!\\*\\_\\'\\(\\)a-zA-Z0-9][\\.\\-\\!\\*\\_\\'\\(\\)\\/a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case s3BucketName = "s3BucketName"
            case s3Path = "s3Path"
        }
    }

    public struct TestSetSummary: AWSDecodableShape {
        /// The date and time at which the test set was created.
        public let creationDateTime: Date?
        /// The description of the test set.
        public let description: String?
        /// The date and time at which the test set was last updated.
        public let lastUpdatedDateTime: Date?
        /// Specifies whether the test set contains written or spoken data.
        public let modality: TestSetModality?
        /// The number of turns in the test set.
        public let numTurns: Int?
        /// The Amazon Resource Name (ARN) of an IAM role that has permission to access the test set.
        public let roleArn: String?
        /// The status of the test set.
        public let status: TestSetStatus?
        /// Contains information about the location at which the test set is stored.
        public let storageLocation: TestSetStorageLocation?
        /// The unique identifier of the test set.
        public let testSetId: String?
        /// The name of the test set.
        public let testSetName: String?

        @inlinable
        public init(creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, modality: TestSetModality? = nil, numTurns: Int? = nil, roleArn: String? = nil, status: TestSetStatus? = nil, storageLocation: TestSetStorageLocation? = nil, testSetId: String? = nil, testSetName: String? = nil) {
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.modality = modality
            self.numTurns = numTurns
            self.roleArn = roleArn
            self.status = status
            self.storageLocation = storageLocation
            self.testSetId = testSetId
            self.testSetName = testSetName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case modality = "modality"
            case numTurns = "numTurns"
            case roleArn = "roleArn"
            case status = "status"
            case storageLocation = "storageLocation"
            case testSetId = "testSetId"
            case testSetName = "testSetName"
        }
    }

    public struct TestSetTurnRecord: AWSDecodableShape {
        /// The unique identifier for the conversation associated with the turn.
        public let conversationId: String?
        /// The record number associated with the turn.
        public let recordNumber: Int64
        /// The number of turns that has elapsed up to that turn.
        public let turnNumber: Int?
        /// Contains information about the agent or user turn depending upon type of turn.
        public let turnSpecification: TurnSpecification

        @inlinable
        public init(conversationId: String? = nil, recordNumber: Int64, turnNumber: Int? = nil, turnSpecification: TurnSpecification) {
            self.conversationId = conversationId
            self.recordNumber = recordNumber
            self.turnNumber = turnNumber
            self.turnSpecification = turnSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case recordNumber = "recordNumber"
            case turnNumber = "turnNumber"
            case turnSpecification = "turnSpecification"
        }
    }

    public struct TestSetTurnResult: AWSDecodableShape {
        /// Contains information about the agent messages in the turn.
        public let agent: AgentTurnResult?
        /// Contains information about the user messages in the turn.
        public let user: UserTurnResult?

        @inlinable
        public init(agent: AgentTurnResult? = nil, user: UserTurnResult? = nil) {
            self.agent = agent
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "agent"
            case user = "user"
        }
    }

    public struct TextInputSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Time for which a bot waits before re-prompting a customer for text input.
        public let startTimeoutMs: Int

        @inlinable
        public init(startTimeoutMs: Int) {
            self.startTimeoutMs = startTimeoutMs
        }

        public func validate(name: String) throws {
            try self.validate(self.startTimeoutMs, name: "startTimeoutMs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case startTimeoutMs = "startTimeoutMs"
        }
    }

    public struct TextLogDestination: AWSEncodableShape & AWSDecodableShape {
        /// Defines the Amazon CloudWatch Logs log group where text and metadata logs are delivered.
        public let cloudWatch: CloudWatchLogGroupLogDestination

        @inlinable
        public init(cloudWatch: CloudWatchLogGroupLogDestination) {
            self.cloudWatch = cloudWatch
        }

        public func validate(name: String) throws {
            try self.cloudWatch.validate(name: "\(name).cloudWatch")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatch = "cloudWatch"
        }
    }

    public struct TextLogSetting: AWSEncodableShape & AWSDecodableShape {
        public let destination: TextLogDestination
        /// Determines whether conversation logs should be stored for an alias.
        public let enabled: Bool
        /// The option to enable selective conversation log capture for text.
        public let selectiveLoggingEnabled: Bool?

        @inlinable
        public init(destination: TextLogDestination, enabled: Bool, selectiveLoggingEnabled: Bool? = nil) {
            self.destination = destination
            self.enabled = enabled
            self.selectiveLoggingEnabled = selectiveLoggingEnabled
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case enabled = "enabled"
            case selectiveLoggingEnabled = "selectiveLoggingEnabled"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String?
        /// The number of seconds after which the user can invoke the API again.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String? = nil, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TranscriptFilter: AWSEncodableShape & AWSDecodableShape {
        /// The object representing the filter that Amazon Lex will use to select the appropriate transcript when the transcript format is the Amazon Lex format.
        public let lexTranscriptFilter: LexTranscriptFilter?

        @inlinable
        public init(lexTranscriptFilter: LexTranscriptFilter? = nil) {
            self.lexTranscriptFilter = lexTranscriptFilter
        }

        private enum CodingKeys: String, CodingKey {
            case lexTranscriptFilter = "lexTranscriptFilter"
        }
    }

    public struct TranscriptSourceSetting: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the setting of the Amazon S3 bucket where the transcript is stored.
        public let s3BucketTranscriptSource: S3BucketTranscriptSource?

        @inlinable
        public init(s3BucketTranscriptSource: S3BucketTranscriptSource? = nil) {
            self.s3BucketTranscriptSource = s3BucketTranscriptSource
        }

        public func validate(name: String) throws {
            try self.s3BucketTranscriptSource?.validate(name: "\(name).s3BucketTranscriptSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketTranscriptSource = "s3BucketTranscriptSource"
        }
    }

    public struct TurnSpecification: AWSDecodableShape {
        /// Contains information about the agent messages in the turn.
        public let agentTurn: AgentTurnSpecification?
        /// Contains information about the user messages in the turn.
        public let userTurn: UserTurnSpecification?

        @inlinable
        public init(agentTurn: AgentTurnSpecification? = nil, userTurn: UserTurnSpecification? = nil) {
            self.agentTurn = agentTurn
            self.userTurn = userTurn
        }

        private enum CodingKeys: String, CodingKey {
            case agentTurn = "agentTurn"
            case userTurn = "userTurn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove the tags from.
        public let resourceARN: String
        /// A list of tag keys to remove from the resource. If a tag key does not exist on the resource, it is ignored.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBotAliasRequest: AWSEncodableShape {
        /// The unique identifier of the bot alias.
        public let botAliasId: String
        /// The new Lambda functions to use in each locale for the bot alias.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The new name to assign to the bot alias.
        public let botAliasName: String
        /// The identifier of the bot with the updated alias.
        public let botId: String
        /// The new bot version to assign to the bot alias.
        public let botVersion: String?
        /// The new settings for storing conversation logs in Amazon CloudWatch Logs and Amazon S3 buckets.
        public let conversationLogSettings: ConversationLogSettings?
        /// The new description to assign to the bot alias.
        public let description: String?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?

        @inlinable
        public init(botAliasId: String, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String, botId: String, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, description: String? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil) {
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.description = description
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botAliasId, key: "botAliasId")
            try container.encodeIfPresent(self.botAliasLocaleSettings, forKey: .botAliasLocaleSettings)
            try container.encode(self.botAliasName, forKey: .botAliasName)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.botVersion, forKey: .botVersion)
            try container.encodeIfPresent(self.conversationLogSettings, forKey: .conversationLogSettings)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.sentimentAnalysisSettings, forKey: .sentimentAnalysisSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, max: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, min: 10)
            try self.validate(self.botAliasId, name: "botAliasId", parent: name, pattern: "^(\\bTSTALIASID\\b|[0-9a-zA-Z]+)$")
            try self.botAliasLocaleSettings?.forEach {
                try $0.value.validate(name: "\(name).botAliasLocaleSettings[\"\($0.key)\"]")
            }
            try self.validate(self.botAliasLocaleSettings, name: "botAliasLocaleSettings", parent: name, min: 1)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, max: 100)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, min: 1)
            try self.validate(self.botAliasName, name: "botAliasName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 1)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^(DRAFT|[0-9]+)$")
            try self.conversationLogSettings?.validate(name: "\(name).conversationLogSettings")
            try self.validate(self.description, name: "description", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case description = "description"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
        }
    }

    public struct UpdateBotAliasResponse: AWSDecodableShape {
        /// The identifier of the updated bot alias.
        public let botAliasId: String?
        /// The updated Lambda functions to use in each locale for the bot alias.
        public let botAliasLocaleSettings: [String: BotAliasLocaleSettings]?
        /// The updated name of the bot alias.
        public let botAliasName: String?
        /// The current status of the bot alias. When the status is Available the alias is ready for use.
        public let botAliasStatus: BotAliasStatus?
        /// The identifier of the bot with the updated alias.
        public let botId: String?
        /// The updated version of the bot that the alias points to.
        public let botVersion: String?
        /// The updated settings for storing conversation logs in Amazon CloudWatch Logs and Amazon S3 buckets.
        public let conversationLogSettings: ConversationLogSettings?
        /// A timestamp of the date and time that the bot was created.
        public let creationDateTime: Date?
        /// The updated description of the bot alias.
        public let description: String?
        /// A timestamp of the date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        public let sentimentAnalysisSettings: SentimentAnalysisSettings?

        @inlinable
        public init(botAliasId: String? = nil, botAliasLocaleSettings: [String: BotAliasLocaleSettings]? = nil, botAliasName: String? = nil, botAliasStatus: BotAliasStatus? = nil, botId: String? = nil, botVersion: String? = nil, conversationLogSettings: ConversationLogSettings? = nil, creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, sentimentAnalysisSettings: SentimentAnalysisSettings? = nil) {
            self.botAliasId = botAliasId
            self.botAliasLocaleSettings = botAliasLocaleSettings
            self.botAliasName = botAliasName
            self.botAliasStatus = botAliasStatus
            self.botId = botId
            self.botVersion = botVersion
            self.conversationLogSettings = conversationLogSettings
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.sentimentAnalysisSettings = sentimentAnalysisSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botAliasId = "botAliasId"
            case botAliasLocaleSettings = "botAliasLocaleSettings"
            case botAliasName = "botAliasName"
            case botAliasStatus = "botAliasStatus"
            case botId = "botId"
            case botVersion = "botVersion"
            case conversationLogSettings = "conversationLogSettings"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case sentimentAnalysisSettings = "sentimentAnalysisSettings"
        }
    }

    public struct UpdateBotLocaleRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the locale.
        public let botId: String
        /// The version of the bot that contains the locale to be updated. The version can only be the DRAFT version.
        public let botVersion: String
        /// The new description of the locale.
        public let description: String?
        /// Contains settings for generative AI features powered by Amazon Bedrock for your bot locale. Use this object to turn generative AI features on and off. Pricing  may differ if you turn a feature on. For more information, see LINK.
        public let generativeAISettings: GenerativeAISettings?
        /// The identifier of the language and locale to update. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The new confidence threshold where Amazon Lex inserts the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
        public let nluIntentConfidenceThreshold: Double
        /// The new Amazon Polly voice Amazon Lex should use for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        @inlinable
        public init(botId: String, botVersion: String, description: String? = nil, generativeAISettings: GenerativeAISettings? = nil, localeId: String, nluIntentConfidenceThreshold: Double, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.generativeAISettings = generativeAISettings
            self.localeId = localeId
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.voiceSettings = voiceSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.generativeAISettings, forKey: .generativeAISettings)
            request.encodePath(self.localeId, key: "localeId")
            try container.encode(self.nluIntentConfidenceThreshold, forKey: .nluIntentConfidenceThreshold)
            try container.encodeIfPresent(self.voiceSettings, forKey: .voiceSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.generativeAISettings?.validate(name: "\(name).generativeAISettings")
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, max: 1.0)
            try self.validate(self.nluIntentConfidenceThreshold, name: "nluIntentConfidenceThreshold", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case generativeAISettings = "generativeAISettings"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct UpdateBotLocaleResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the updated locale.
        public let botId: String?
        /// The current status of the locale. When the bot status is Built the locale is ready for use.
        public let botLocaleStatus: BotLocaleStatus?
        /// The version of the bot that contains the updated locale.
        public let botVersion: String?
        /// A timestamp of the date and time that the locale was created.
        public let creationDateTime: Date?
        /// The updated description of the locale.
        public let description: String?
        /// If the botLocaleStatus is Failed, the failureReasons field lists the errors that occurred while building the bot.
        public let failureReasons: [String]?
        /// Contains settings for generative AI features powered by Amazon Bedrock for your bot locale.
        public let generativeAISettings: GenerativeAISettings?
        /// A timestamp of the date and time that the locale was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale of the updated bot locale.
        public let localeId: String?
        /// The updated locale name for the locale.
        public let localeName: String?
        /// The updated confidence threshold for inserting the AMAZON.FallbackIntent and AMAZON.KendraSearchIntent intents in the list of possible intents for an utterance.
        public let nluIntentConfidenceThreshold: Double?
        /// Recommended actions to take to resolve an error in the failureReasons field.
        public let recommendedActions: [String]?
        /// The updated Amazon Polly voice to use for voice interaction with the user.
        public let voiceSettings: VoiceSettings?

        @inlinable
        public init(botId: String? = nil, botLocaleStatus: BotLocaleStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, failureReasons: [String]? = nil, generativeAISettings: GenerativeAISettings? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, localeName: String? = nil, nluIntentConfidenceThreshold: Double? = nil, recommendedActions: [String]? = nil, voiceSettings: VoiceSettings? = nil) {
            self.botId = botId
            self.botLocaleStatus = botLocaleStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.failureReasons = failureReasons
            self.generativeAISettings = generativeAISettings
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.localeName = localeName
            self.nluIntentConfidenceThreshold = nluIntentConfidenceThreshold
            self.recommendedActions = recommendedActions
            self.voiceSettings = voiceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botLocaleStatus = "botLocaleStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case failureReasons = "failureReasons"
            case generativeAISettings = "generativeAISettings"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case localeName = "localeName"
            case nluIntentConfidenceThreshold = "nluIntentConfidenceThreshold"
            case recommendedActions = "recommendedActions"
            case voiceSettings = "voiceSettings"
        }
    }

    public struct UpdateBotRecommendationRequest: AWSEncodableShape {
        /// The unique identifier of the bot containing the bot recommendation to be updated.
        public let botId: String
        /// The unique identifier of the bot recommendation to be updated.
        public let botRecommendationId: String
        /// The version of the bot containing the bot recommendation to be updated.
        public let botVersion: String
        /// The object representing the passwords that will be used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
        public let encryptionSetting: EncryptionSetting
        /// The identifier of the language and locale of the bot recommendation to update. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String

        @inlinable
        public init(botId: String, botRecommendationId: String, botVersion: String, encryptionSetting: EncryptionSetting, localeId: String) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botVersion = botVersion
            self.encryptionSetting = encryptionSetting
            self.localeId = localeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botRecommendationId, key: "botRecommendationId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encode(self.encryptionSetting, forKey: .encryptionSetting)
            request.encodePath(self.localeId, key: "localeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, max: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, min: 10)
            try self.validate(self.botRecommendationId, name: "botRecommendationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.encryptionSetting.validate(name: "\(name).encryptionSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionSetting = "encryptionSetting"
        }
    }

    public struct UpdateBotRecommendationResponse: AWSDecodableShape {
        /// The unique identifier of the bot containing the bot recommendation that has been updated.
        public let botId: String?
        /// The unique identifier of the bot recommendation to be updated.
        public let botRecommendationId: String?
        /// The status of the bot recommendation. If the status is Failed, then the reasons for the failure are listed in the failureReasons field.
        public let botRecommendationStatus: BotRecommendationStatus?
        /// The version of the bot containing the bot recommendation that has been updated.
        public let botVersion: String?
        /// A timestamp of the date and time that the bot recommendation was created.
        public let creationDateTime: Date?
        /// The object representing the passwords that were used to encrypt the data related to the bot recommendation results, as well as the KMS key ARN used to encrypt the associated metadata.
        public let encryptionSetting: EncryptionSetting?
        /// A timestamp of the date and time that the bot recommendation was last updated.
        public let lastUpdatedDateTime: Date?
        /// The identifier of the language and locale of the bot recommendation to update. The string must match one of the supported locales. For more information, see Supported languages
        public let localeId: String?
        /// The object representing the Amazon S3 bucket containing the transcript, as well as the associated metadata.
        public let transcriptSourceSetting: TranscriptSourceSetting?

        @inlinable
        public init(botId: String? = nil, botRecommendationId: String? = nil, botRecommendationStatus: BotRecommendationStatus? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, encryptionSetting: EncryptionSetting? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, transcriptSourceSetting: TranscriptSourceSetting? = nil) {
            self.botId = botId
            self.botRecommendationId = botRecommendationId
            self.botRecommendationStatus = botRecommendationStatus
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.encryptionSetting = encryptionSetting
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.transcriptSourceSetting = transcriptSourceSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botRecommendationId = "botRecommendationId"
            case botRecommendationStatus = "botRecommendationStatus"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case encryptionSetting = "encryptionSetting"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case transcriptSourceSetting = "transcriptSourceSetting"
        }
    }

    public struct UpdateBotRequest: AWSEncodableShape {
        /// The unique identifier of the bot to update. This identifier is returned by the CreateBot operation.
        public let botId: String
        /// The list of bot members in the network associated  with the update action.
        public let botMembers: [BotMember]?
        /// The new name of the bot. The name must be unique in the account that creates the bot.
        public let botName: String
        /// The type of the bot to be updated.
        public let botType: BotType?
        /// Provides information on additional privacy protections Amazon Lex should use with the bot's data.
        public let dataPrivacy: DataPrivacy
        /// A description of the bot.
        public let description: String?
        /// Allows you to modify how Amazon Lex logs errors during bot interactions, including destinations for error logs and the types of errors to be captured.
        public let errorLogSettings: ErrorLogSettings?
        /// The time, in seconds, that Amazon Lex should keep information about a user's conversation with the bot. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Lex deletes any data provided before the timeout. You can specify between 60 (1 minute) and 86,400 (24 hours) seconds.
        public let idleSessionTTLInSeconds: Int
        /// The Amazon Resource Name (ARN) of an IAM role that has permissions to access the bot.
        public let roleArn: String

        @inlinable
        public init(botId: String, botMembers: [BotMember]? = nil, botName: String, botType: BotType? = nil, dataPrivacy: DataPrivacy, description: String? = nil, errorLogSettings: ErrorLogSettings? = nil, idleSessionTTLInSeconds: Int, roleArn: String) {
            self.botId = botId
            self.botMembers = botMembers
            self.botName = botName
            self.botType = botType
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.errorLogSettings = errorLogSettings
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            try container.encodeIfPresent(self.botMembers, forKey: .botMembers)
            try container.encode(self.botName, forKey: .botName)
            try container.encodeIfPresent(self.botType, forKey: .botType)
            try container.encode(self.dataPrivacy, forKey: .dataPrivacy)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.errorLogSettings, forKey: .errorLogSettings)
            try container.encode(self.idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.botMembers?.forEach {
                try $0.validate(name: "\(name).botMembers[]")
            }
            try self.validate(self.botMembers, name: "botMembers", parent: name, max: 10)
            try self.validate(self.botName, name: "botName", parent: name, max: 100)
            try self.validate(self.botName, name: "botName", parent: name, min: 1)
            try self.validate(self.botName, name: "botName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, max: 86400)
            try self.validate(self.idleSessionTTLInSeconds, name: "idleSessionTTLInSeconds", parent: name, min: 60)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case botMembers = "botMembers"
            case botName = "botName"
            case botType = "botType"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case errorLogSettings = "errorLogSettings"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateBotResponse: AWSDecodableShape {
        /// The unique identifier of the bot that was updated.
        public let botId: String?
        /// The list of bot members in the network that was updated.
        public let botMembers: [BotMember]?
        /// The name of the bot after the update.
        public let botName: String?
        /// Shows the current status of the bot. The bot is first in the Creating status. Once the bot is read for use, it changes to the Available status. After the bot is created, you can use the DRAFT version of the bot.
        public let botStatus: BotStatus?
        /// The type of the bot that was updated.
        public let botType: BotType?
        /// A timestamp of the date and time that the bot was created.
        public let creationDateTime: Date?
        /// The data privacy settings for the bot after the update.
        public let dataPrivacy: DataPrivacy?
        /// The description of the bot after the update.
        public let description: String?
        /// Settings for managing error logs within the response of an update bot operation.
        public let errorLogSettings: ErrorLogSettings?
        /// The session timeout, in seconds, for the bot after the update.
        public let idleSessionTTLInSeconds: Int?
        /// A timestamp of the date and time that the bot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The Amazon Resource Name (ARN) of the IAM role used by the bot after the update.
        public let roleArn: String?

        @inlinable
        public init(botId: String? = nil, botMembers: [BotMember]? = nil, botName: String? = nil, botStatus: BotStatus? = nil, botType: BotType? = nil, creationDateTime: Date? = nil, dataPrivacy: DataPrivacy? = nil, description: String? = nil, errorLogSettings: ErrorLogSettings? = nil, idleSessionTTLInSeconds: Int? = nil, lastUpdatedDateTime: Date? = nil, roleArn: String? = nil) {
            self.botId = botId
            self.botMembers = botMembers
            self.botName = botName
            self.botStatus = botStatus
            self.botType = botType
            self.creationDateTime = creationDateTime
            self.dataPrivacy = dataPrivacy
            self.description = description
            self.errorLogSettings = errorLogSettings
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botMembers = "botMembers"
            case botName = "botName"
            case botStatus = "botStatus"
            case botType = "botType"
            case creationDateTime = "creationDateTime"
            case dataPrivacy = "dataPrivacy"
            case description = "description"
            case errorLogSettings = "errorLogSettings"
            case idleSessionTTLInSeconds = "idleSessionTTLInSeconds"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateExportRequest: AWSEncodableShape {
        /// The unique identifier Amazon Lex assigned to the export.
        public let exportId: String
        /// The new password to use to encrypt the export zip archive.
        public let filePassword: String?

        @inlinable
        public init(exportId: String, filePassword: String? = nil) {
            self.exportId = exportId
            self.filePassword = filePassword
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.exportId, key: "exportId")
            try container.encodeIfPresent(self.filePassword, forKey: .filePassword)
        }

        public func validate(name: String) throws {
            try self.validate(self.exportId, name: "exportId", parent: name, max: 10)
            try self.validate(self.exportId, name: "exportId", parent: name, min: 10)
            try self.validate(self.exportId, name: "exportId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.filePassword, name: "filePassword", parent: name, max: 1024)
            try self.validate(self.filePassword, name: "filePassword", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filePassword = "filePassword"
        }
    }

    public struct UpdateExportResponse: AWSDecodableShape {
        /// The date and time that the export was created.
        public let creationDateTime: Date?
        /// The unique identifier Amazon Lex assigned to the export.
        public let exportId: String?
        /// The status of the export. When the status is Completed the export archive is available for download.
        public let exportStatus: ExportStatus?
        /// The file format used for the files that define the resource. The TSV format is required to export a custom vocabulary only; otherwise use LexJson format.
        public let fileFormat: ImportExportFileFormat?
        /// The date and time that the export was last updated.
        public let lastUpdatedDateTime: Date?
        /// A description of the type of resource that was exported, either a bot or a bot locale.
        public let resourceSpecification: ExportResourceSpecification?

        @inlinable
        public init(creationDateTime: Date? = nil, exportId: String? = nil, exportStatus: ExportStatus? = nil, fileFormat: ImportExportFileFormat? = nil, lastUpdatedDateTime: Date? = nil, resourceSpecification: ExportResourceSpecification? = nil) {
            self.creationDateTime = creationDateTime
            self.exportId = exportId
            self.exportStatus = exportStatus
            self.fileFormat = fileFormat
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.resourceSpecification = resourceSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case exportId = "exportId"
            case exportStatus = "exportStatus"
            case fileFormat = "fileFormat"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case resourceSpecification = "resourceSpecification"
        }
    }

    public struct UpdateIntentRequest: AWSEncodableShape {
        /// The identifier of the bot that contains the intent.
        public let botId: String
        /// The version of the bot that contains the intent. Must be DRAFT.
        public let botVersion: String
        /// The new description of the intent.
        public let description: String?
        /// The new Lambda function to use between each turn of the conversation with the bot.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The new Lambda function to call when all of the intents required slots are provided and the intent is ready for fulfillment.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// Configuration settings for a response sent to the user before Amazon Lex starts eliciting slots.
        public let initialResponseSetting: InitialResponseSetting?
        /// A new list of contexts that must be active in order for Amazon Lex to consider the intent.
        public let inputContexts: [InputContext]?
        /// The new response that Amazon Lex sends the user when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// New prompts that Amazon Lex sends to the user to confirm the completion of an intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The unique identifier of the intent to update.
        public let intentId: String
        /// The new name for the intent.
        public let intentName: String
        /// New configuration settings for connecting to an Amazon Kendra index.
        public let kendraConfiguration: KendraConfiguration?
        /// The identifier of the language and locale where this intent is used. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// A new list of contexts that Amazon Lex activates when the intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// The signature of the new built-in intent to use as the parent of this intent.
        public let parentIntentSignature: String?
        /// Qinconnect intent configuration details for the update intent request.
        public let qInConnectIntentConfiguration: QInConnectIntentConfiguration?
        /// Specifies the configuration of the built-in Amazon.QnAIntent. The AMAZON.QnAIntent intent is called when Amazon Lex can't determine another intent to invoke. If you specify this field, you can't specify the kendraConfiguration field.
        public let qnAIntentConfiguration: QnAIntentConfiguration?
        /// New utterances used to invoke the intent.
        public let sampleUtterances: [SampleUtterance]?
        /// A new list of slots and their priorities that are contained by the intent.
        public let slotPriorities: [SlotPriority]?

        @inlinable
        public init(botId: String, botVersion: String, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, initialResponseSetting: InitialResponseSetting? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String, intentName: String, kendraConfiguration: KendraConfiguration? = nil, localeId: String, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, qInConnectIntentConfiguration: QInConnectIntentConfiguration? = nil, qnAIntentConfiguration: QnAIntentConfiguration? = nil, sampleUtterances: [SampleUtterance]? = nil, slotPriorities: [SlotPriority]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.initialResponseSetting = initialResponseSetting
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.qInConnectIntentConfiguration = qInConnectIntentConfiguration
            self.qnAIntentConfiguration = qnAIntentConfiguration
            self.sampleUtterances = sampleUtterances
            self.slotPriorities = slotPriorities
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.dialogCodeHook, forKey: .dialogCodeHook)
            try container.encodeIfPresent(self.fulfillmentCodeHook, forKey: .fulfillmentCodeHook)
            try container.encodeIfPresent(self.initialResponseSetting, forKey: .initialResponseSetting)
            try container.encodeIfPresent(self.inputContexts, forKey: .inputContexts)
            try container.encodeIfPresent(self.intentClosingSetting, forKey: .intentClosingSetting)
            try container.encodeIfPresent(self.intentConfirmationSetting, forKey: .intentConfirmationSetting)
            request.encodePath(self.intentId, key: "intentId")
            try container.encode(self.intentName, forKey: .intentName)
            try container.encodeIfPresent(self.kendraConfiguration, forKey: .kendraConfiguration)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.outputContexts, forKey: .outputContexts)
            try container.encodeIfPresent(self.parentIntentSignature, forKey: .parentIntentSignature)
            try container.encodeIfPresent(self.qInConnectIntentConfiguration, forKey: .qInConnectIntentConfiguration)
            try container.encodeIfPresent(self.qnAIntentConfiguration, forKey: .qnAIntentConfiguration)
            try container.encodeIfPresent(self.sampleUtterances, forKey: .sampleUtterances)
            try container.encodeIfPresent(self.slotPriorities, forKey: .slotPriorities)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.fulfillmentCodeHook?.validate(name: "\(name).fulfillmentCodeHook")
            try self.initialResponseSetting?.validate(name: "\(name).initialResponseSetting")
            try self.inputContexts?.forEach {
                try $0.validate(name: "\(name).inputContexts[]")
            }
            try self.validate(self.inputContexts, name: "inputContexts", parent: name, max: 5)
            try self.intentClosingSetting?.validate(name: "\(name).intentClosingSetting")
            try self.intentConfirmationSetting?.validate(name: "\(name).intentConfirmationSetting")
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.intentName, name: "intentName", parent: name, max: 100)
            try self.validate(self.intentName, name: "intentName", parent: name, min: 1)
            try self.validate(self.intentName, name: "intentName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.kendraConfiguration?.validate(name: "\(name).kendraConfiguration")
            try self.outputContexts?.forEach {
                try $0.validate(name: "\(name).outputContexts[]")
            }
            try self.validate(self.outputContexts, name: "outputContexts", parent: name, max: 10)
            try self.qInConnectIntentConfiguration?.validate(name: "\(name).qInConnectIntentConfiguration")
            try self.qnAIntentConfiguration?.validate(name: "\(name).qnAIntentConfiguration")
            try self.slotPriorities?.forEach {
                try $0.validate(name: "\(name).slotPriorities[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case initialResponseSetting = "initialResponseSetting"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case qInConnectIntentConfiguration = "qInConnectIntentConfiguration"
            case qnAIntentConfiguration = "qnAIntentConfiguration"
            case sampleUtterances = "sampleUtterances"
            case slotPriorities = "slotPriorities"
        }
    }

    public struct UpdateIntentResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the intent.
        public let botId: String?
        /// The version of the bot that contains the intent. Will always be DRAFT.
        public let botVersion: String?
        /// A timestamp of when the intent was created.
        public let creationDateTime: Date?
        /// The updated description of the intent.
        public let description: String?
        /// The updated Lambda function called during each turn of the conversation with the user.
        public let dialogCodeHook: DialogCodeHookSettings?
        /// The updated Lambda function called when the intent is ready for fulfillment.
        public let fulfillmentCodeHook: FulfillmentCodeHookSettings?
        /// Configuration settings for a response sent to the user before Amazon Lex starts eliciting slots.
        public let initialResponseSetting: InitialResponseSetting?
        /// The updated list of contexts that must be active for the intent to be considered by Amazon Lex.
        public let inputContexts: [InputContext]?
        /// The updated response that Amazon Lex sends the user when the intent is closed.
        public let intentClosingSetting: IntentClosingSetting?
        /// The updated prompts that Amazon Lex sends to the user to confirm the completion of an intent.
        public let intentConfirmationSetting: IntentConfirmationSetting?
        /// The identifier of the intent that was updated.
        public let intentId: String?
        /// The updated name of the intent.
        public let intentName: String?
        /// The updated configuration for connecting to an Amazon Kendra index with the AMAZON.KendraSearchIntent intent.
        public let kendraConfiguration: KendraConfiguration?
        /// A timestamp of the last time that the intent was modified.
        public let lastUpdatedDateTime: Date?
        /// The updated language and locale of the intent.
        public let localeId: String?
        /// The updated list of contexts that Amazon Lex activates when the intent is fulfilled.
        public let outputContexts: [OutputContext]?
        /// The updated built-in intent that is the parent of this intent.
        public let parentIntentSignature: String?
        /// Qinconnect intent configuration details for the update intent response.
        public let qInConnectIntentConfiguration: QInConnectIntentConfiguration?
        /// Details about the configuration of the built-in Amazon.QnAIntent.
        public let qnAIntentConfiguration: QnAIntentConfiguration?
        /// The updated list of sample utterances for the intent.
        public let sampleUtterances: [SampleUtterance]?
        /// The updated list of slots and their priorities that are elicited from the user for the intent.
        public let slotPriorities: [SlotPriority]?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, dialogCodeHook: DialogCodeHookSettings? = nil, fulfillmentCodeHook: FulfillmentCodeHookSettings? = nil, initialResponseSetting: InitialResponseSetting? = nil, inputContexts: [InputContext]? = nil, intentClosingSetting: IntentClosingSetting? = nil, intentConfirmationSetting: IntentConfirmationSetting? = nil, intentId: String? = nil, intentName: String? = nil, kendraConfiguration: KendraConfiguration? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, outputContexts: [OutputContext]? = nil, parentIntentSignature: String? = nil, qInConnectIntentConfiguration: QInConnectIntentConfiguration? = nil, qnAIntentConfiguration: QnAIntentConfiguration? = nil, sampleUtterances: [SampleUtterance]? = nil, slotPriorities: [SlotPriority]? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.dialogCodeHook = dialogCodeHook
            self.fulfillmentCodeHook = fulfillmentCodeHook
            self.initialResponseSetting = initialResponseSetting
            self.inputContexts = inputContexts
            self.intentClosingSetting = intentClosingSetting
            self.intentConfirmationSetting = intentConfirmationSetting
            self.intentId = intentId
            self.intentName = intentName
            self.kendraConfiguration = kendraConfiguration
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.outputContexts = outputContexts
            self.parentIntentSignature = parentIntentSignature
            self.qInConnectIntentConfiguration = qInConnectIntentConfiguration
            self.qnAIntentConfiguration = qnAIntentConfiguration
            self.sampleUtterances = sampleUtterances
            self.slotPriorities = slotPriorities
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case dialogCodeHook = "dialogCodeHook"
            case fulfillmentCodeHook = "fulfillmentCodeHook"
            case initialResponseSetting = "initialResponseSetting"
            case inputContexts = "inputContexts"
            case intentClosingSetting = "intentClosingSetting"
            case intentConfirmationSetting = "intentConfirmationSetting"
            case intentId = "intentId"
            case intentName = "intentName"
            case kendraConfiguration = "kendraConfiguration"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case outputContexts = "outputContexts"
            case parentIntentSignature = "parentIntentSignature"
            case qInConnectIntentConfiguration = "qInConnectIntentConfiguration"
            case qnAIntentConfiguration = "qnAIntentConfiguration"
            case sampleUtterances = "sampleUtterances"
            case slotPriorities = "slotPriorities"
        }
    }

    public struct UpdateResourcePolicyRequest: AWSEncodableShape {
        /// The identifier of the revision of the policy to update. If this revision ID doesn't match the current revision ID, Amazon Lex throws an exception. If you don't specify a revision, Amazon Lex overwrites the contents of the policy with the new values.
        public let expectedRevisionId: String?
        /// A resource policy to add to the resource. The policy is a JSON structure that contains one or more statements that define the policy. The policy must follow the IAM syntax. For more information about the contents of a JSON policy document, see  IAM JSON policy reference .  If the policy isn't valid, Amazon Lex returns a validation exception.
        public let policy: String
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String

        @inlinable
        public init(expectedRevisionId: String? = nil, policy: String, resourceArn: String) {
            self.expectedRevisionId = expectedRevisionId
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.expectedRevisionId, key: "expectedRevisionId")
            try container.encode(self.policy, forKey: .policy)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, max: 5)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, min: 1)
            try self.validate(self.expectedRevisionId, name: "expectedRevisionId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, min: 2)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct UpdateResourcePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the bot or bot alias that the resource policy is attached to.
        public let resourceArn: String?
        /// The current revision of the resource policy. Use the revision ID to make sure that you are updating the most current version of a resource policy when you add a policy statement to a resource, delete a resource, or update a resource.
        public let revisionId: String?

        @inlinable
        public init(resourceArn: String? = nil, revisionId: String? = nil) {
            self.resourceArn = resourceArn
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case revisionId = "revisionId"
        }
    }

    public struct UpdateSlotRequest: AWSEncodableShape {
        /// The unique identifier of the bot that contains the slot.
        public let botId: String
        /// The version of the bot that contains the slot. Must always be DRAFT.
        public let botVersion: String
        /// The new description for the slot.
        public let description: String?
        /// The identifier of the intent that contains the slot.
        public let intentId: String
        /// The identifier of the language and locale that contains the slot. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// Determines whether the slot accepts multiple values in one response. Multiple value slots are only available in the en-US locale. If you set this value to true in any other locale, Amazon Lex throws a ValidationException. If the multipleValuesSetting is not set, the default value is false.
        public let multipleValuesSetting: MultipleValuesSetting?
        /// New settings that determine how slot values are formatted in Amazon CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier for the slot to update.
        public let slotId: String
        /// The new name for the slot.
        public let slotName: String
        /// The unique identifier of the new slot type to associate with this slot.
        public let slotTypeId: String?
        /// Specifications for the constituent sub slots and the   expression for the composite slot.
        public let subSlotSetting: SubSlotSetting?
        /// A new set of prompts that Amazon Lex sends to the user to elicit a response the provides a value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting

        @inlinable
        public init(botId: String, botVersion: String, description: String? = nil, intentId: String, localeId: String, multipleValuesSetting: MultipleValuesSetting? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotId: String, slotName: String, slotTypeId: String? = nil, subSlotSetting: SubSlotSetting? = nil, valueElicitationSetting: SlotValueElicitationSetting) {
            self.botId = botId
            self.botVersion = botVersion
            self.description = description
            self.intentId = intentId
            self.localeId = localeId
            self.multipleValuesSetting = multipleValuesSetting
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.subSlotSetting = subSlotSetting
            self.valueElicitationSetting = valueElicitationSetting
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.intentId, key: "intentId")
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.multipleValuesSetting, forKey: .multipleValuesSetting)
            try container.encodeIfPresent(self.obfuscationSetting, forKey: .obfuscationSetting)
            request.encodePath(self.slotId, key: "slotId")
            try container.encode(self.slotName, forKey: .slotName)
            try container.encodeIfPresent(self.slotTypeId, forKey: .slotTypeId)
            try container.encodeIfPresent(self.subSlotSetting, forKey: .subSlotSetting)
            try container.encode(self.valueElicitationSetting, forKey: .valueElicitationSetting)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.intentId, name: "intentId", parent: name, max: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, min: 10)
            try self.validate(self.intentId, name: "intentId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotId, name: "slotId", parent: name, max: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, min: 10)
            try self.validate(self.slotId, name: "slotId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotName, name: "slotName", parent: name, max: 100)
            try self.validate(self.slotName, name: "slotName", parent: name, min: 1)
            try self.validate(self.slotName, name: "slotName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 25)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 1)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^((AMAZON\\.)[a-zA-Z_]+?|[0-9a-zA-Z]+)$")
            try self.subSlotSetting?.validate(name: "\(name).subSlotSetting")
            try self.valueElicitationSetting.validate(name: "\(name).valueElicitationSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case multipleValuesSetting = "multipleValuesSetting"
            case obfuscationSetting = "obfuscationSetting"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case subSlotSetting = "subSlotSetting"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct UpdateSlotResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the slot.
        public let botId: String?
        /// The version of the bot that contains the slot. Will always be DRAFT.
        public let botVersion: String?
        /// The timestamp of the date and time that the slot was created.
        public let creationDateTime: Date?
        /// The updated description of the bot.
        public let description: String?
        /// The intent that contains the slot.
        public let intentId: String?
        /// The timestamp of the date and time that the slot was last updated.
        public let lastUpdatedDateTime: Date?
        /// The locale that contains the slot.
        public let localeId: String?
        /// Indicates whether the slot accepts multiple values in one response.
        public let multipleValuesSetting: MultipleValuesSetting?
        /// The updated setting that determines whether the slot value is obfuscated in the Amazon CloudWatch logs.
        public let obfuscationSetting: ObfuscationSetting?
        /// The unique identifier of the slot that was updated.
        public let slotId: String?
        /// The updated name of the slot.
        public let slotName: String?
        /// The updated identifier of the slot type that provides values for the slot.
        public let slotTypeId: String?
        /// Specifications for the constituent sub slots and the   expression for the composite slot.
        public let subSlotSetting: SubSlotSetting?
        /// The updated prompts that Amazon Lex sends to the user to elicit a response that provides a value for the slot.
        public let valueElicitationSetting: SlotValueElicitationSetting?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, creationDateTime: Date? = nil, description: String? = nil, intentId: String? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, multipleValuesSetting: MultipleValuesSetting? = nil, obfuscationSetting: ObfuscationSetting? = nil, slotId: String? = nil, slotName: String? = nil, slotTypeId: String? = nil, subSlotSetting: SubSlotSetting? = nil, valueElicitationSetting: SlotValueElicitationSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.creationDateTime = creationDateTime
            self.description = description
            self.intentId = intentId
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.multipleValuesSetting = multipleValuesSetting
            self.obfuscationSetting = obfuscationSetting
            self.slotId = slotId
            self.slotName = slotName
            self.slotTypeId = slotTypeId
            self.subSlotSetting = subSlotSetting
            self.valueElicitationSetting = valueElicitationSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case intentId = "intentId"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case multipleValuesSetting = "multipleValuesSetting"
            case obfuscationSetting = "obfuscationSetting"
            case slotId = "slotId"
            case slotName = "slotName"
            case slotTypeId = "slotTypeId"
            case subSlotSetting = "subSlotSetting"
            case valueElicitationSetting = "valueElicitationSetting"
        }
    }

    public struct UpdateSlotTypeRequest: AWSEncodableShape {
        /// The identifier of the bot that contains the slot type.
        public let botId: String
        /// The version of the bot that contains the slot type. Must be DRAFT.
        public let botVersion: String
        /// Specifications for a composite slot type.
        public let compositeSlotTypeSetting: CompositeSlotTypeSetting?
        /// The new description of the slot type.
        public let description: String?
        public let externalSourceSetting: ExternalSourceSetting?
        /// The identifier of the language and locale that contains the slot type. The string must match one of the supported locales. For more information, see Supported languages.
        public let localeId: String
        /// The new built-in slot type that should be used as the parent of this slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier of the slot type to update.
        public let slotTypeId: String
        /// The new name of the slot type.
        public let slotTypeName: String
        /// A new list of values and their optional synonyms that define the values that the slot type can take.
        public let slotTypeValues: [SlotTypeValue]?
        /// The strategy that Amazon Lex should use when deciding on a value from the list of slot type values.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        @inlinable
        public init(botId: String, botVersion: String, compositeSlotTypeSetting: CompositeSlotTypeSetting? = nil, description: String? = nil, externalSourceSetting: ExternalSourceSetting? = nil, localeId: String, parentSlotTypeSignature: String? = nil, slotTypeId: String, slotTypeName: String, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.compositeSlotTypeSetting = compositeSlotTypeSetting
            self.description = description
            self.externalSourceSetting = externalSourceSetting
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.botId, key: "botId")
            request.encodePath(self.botVersion, key: "botVersion")
            try container.encodeIfPresent(self.compositeSlotTypeSetting, forKey: .compositeSlotTypeSetting)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.externalSourceSetting, forKey: .externalSourceSetting)
            request.encodePath(self.localeId, key: "localeId")
            try container.encodeIfPresent(self.parentSlotTypeSignature, forKey: .parentSlotTypeSignature)
            request.encodePath(self.slotTypeId, key: "slotTypeId")
            try container.encode(self.slotTypeName, forKey: .slotTypeName)
            try container.encodeIfPresent(self.slotTypeValues, forKey: .slotTypeValues)
            try container.encodeIfPresent(self.valueSelectionSetting, forKey: .valueSelectionSetting)
        }

        public func validate(name: String) throws {
            try self.validate(self.botId, name: "botId", parent: name, max: 10)
            try self.validate(self.botId, name: "botId", parent: name, min: 10)
            try self.validate(self.botId, name: "botId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.botVersion, name: "botVersion", parent: name, max: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, min: 5)
            try self.validate(self.botVersion, name: "botVersion", parent: name, pattern: "^DRAFT$")
            try self.compositeSlotTypeSetting?.validate(name: "\(name).compositeSlotTypeSetting")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.externalSourceSetting?.validate(name: "\(name).externalSourceSetting")
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, max: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, min: 10)
            try self.validate(self.slotTypeId, name: "slotTypeId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, max: 100)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, min: 1)
            try self.validate(self.slotTypeName, name: "slotTypeName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
            try self.slotTypeValues?.forEach {
                try $0.validate(name: "\(name).slotTypeValues[]")
            }
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, max: 10000)
            try self.validate(self.slotTypeValues, name: "slotTypeValues", parent: name, min: 1)
            try self.valueSelectionSetting?.validate(name: "\(name).valueSelectionSetting")
        }

        private enum CodingKeys: String, CodingKey {
            case compositeSlotTypeSetting = "compositeSlotTypeSetting"
            case description = "description"
            case externalSourceSetting = "externalSourceSetting"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct UpdateSlotTypeResponse: AWSDecodableShape {
        /// The identifier of the bot that contains the slot type.
        public let botId: String?
        /// The version of the bot that contains the slot type. This is always DRAFT.
        public let botVersion: String?
        /// Specifications for a composite slot type.
        public let compositeSlotTypeSetting: CompositeSlotTypeSetting?
        /// The timestamp of the date and time that the slot type was created.
        public let creationDateTime: Date?
        /// The updated description of the slot type.
        public let description: String?
        public let externalSourceSetting: ExternalSourceSetting?
        /// A timestamp of the date and time that the slot type was last updated.
        public let lastUpdatedDateTime: Date?
        /// The language and locale of the updated slot type.
        public let localeId: String?
        /// The updated signature of the built-in slot type that is the parent of this slot type.
        public let parentSlotTypeSignature: String?
        /// The unique identifier of the updated slot type.
        public let slotTypeId: String?
        /// The updated name of the slot type.
        public let slotTypeName: String?
        /// The updated values that the slot type provides.
        public let slotTypeValues: [SlotTypeValue]?
        /// The updated strategy that Amazon Lex uses to determine which value to select from the slot type.
        public let valueSelectionSetting: SlotValueSelectionSetting?

        @inlinable
        public init(botId: String? = nil, botVersion: String? = nil, compositeSlotTypeSetting: CompositeSlotTypeSetting? = nil, creationDateTime: Date? = nil, description: String? = nil, externalSourceSetting: ExternalSourceSetting? = nil, lastUpdatedDateTime: Date? = nil, localeId: String? = nil, parentSlotTypeSignature: String? = nil, slotTypeId: String? = nil, slotTypeName: String? = nil, slotTypeValues: [SlotTypeValue]? = nil, valueSelectionSetting: SlotValueSelectionSetting? = nil) {
            self.botId = botId
            self.botVersion = botVersion
            self.compositeSlotTypeSetting = compositeSlotTypeSetting
            self.creationDateTime = creationDateTime
            self.description = description
            self.externalSourceSetting = externalSourceSetting
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.localeId = localeId
            self.parentSlotTypeSignature = parentSlotTypeSignature
            self.slotTypeId = slotTypeId
            self.slotTypeName = slotTypeName
            self.slotTypeValues = slotTypeValues
            self.valueSelectionSetting = valueSelectionSetting
        }

        private enum CodingKeys: String, CodingKey {
            case botId = "botId"
            case botVersion = "botVersion"
            case compositeSlotTypeSetting = "compositeSlotTypeSetting"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case externalSourceSetting = "externalSourceSetting"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case localeId = "localeId"
            case parentSlotTypeSignature = "parentSlotTypeSignature"
            case slotTypeId = "slotTypeId"
            case slotTypeName = "slotTypeName"
            case slotTypeValues = "slotTypeValues"
            case valueSelectionSetting = "valueSelectionSetting"
        }
    }

    public struct UpdateTestSetRequest: AWSEncodableShape {
        /// The new test set description.
        public let description: String?
        /// The test set Id for which update test operation to be performed.
        public let testSetId: String
        /// The new test set name.
        public let testSetName: String

        @inlinable
        public init(description: String? = nil, testSetId: String, testSetName: String) {
            self.description = description
            self.testSetId = testSetId
            self.testSetName = testSetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.testSetId, key: "testSetId")
            try container.encode(self.testSetName, forKey: .testSetName)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.testSetId, name: "testSetId", parent: name, max: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, min: 10)
            try self.validate(self.testSetId, name: "testSetId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.testSetName, name: "testSetName", parent: name, max: 100)
            try self.validate(self.testSetName, name: "testSetName", parent: name, min: 1)
            try self.validate(self.testSetName, name: "testSetName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case testSetName = "testSetName"
        }
    }

    public struct UpdateTestSetResponse: AWSDecodableShape {
        /// The creation date and time for the updated test set.
        public let creationDateTime: Date?
        /// The test set description for the updated test set.
        public let description: String?
        ///  The date and time of the last update for the updated test set.
        public let lastUpdatedDateTime: Date?
        /// Indicates whether audio or text is used for the updated test set.
        public let modality: TestSetModality?
        /// The number of conversation turns from the updated test set.
        public let numTurns: Int?
        /// The roleARN used for any operation in the test set to access  resources in the Amazon Web Services account.
        public let roleArn: String?
        /// The status for the updated test set.
        public let status: TestSetStatus?
        /// The Amazon S3 storage location for the updated test set.
        public let storageLocation: TestSetStorageLocation?
        /// The test set Id for which update test operation to be performed.
        public let testSetId: String?
        /// The test set name for the updated test set.
        public let testSetName: String?

        @inlinable
        public init(creationDateTime: Date? = nil, description: String? = nil, lastUpdatedDateTime: Date? = nil, modality: TestSetModality? = nil, numTurns: Int? = nil, roleArn: String? = nil, status: TestSetStatus? = nil, storageLocation: TestSetStorageLocation? = nil, testSetId: String? = nil, testSetName: String? = nil) {
            self.creationDateTime = creationDateTime
            self.description = description
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.modality = modality
            self.numTurns = numTurns
            self.roleArn = roleArn
            self.status = status
            self.storageLocation = storageLocation
            self.testSetId = testSetId
            self.testSetName = testSetName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case description = "description"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case modality = "modality"
            case numTurns = "numTurns"
            case roleArn = "roleArn"
            case status = "status"
            case storageLocation = "storageLocation"
            case testSetId = "testSetId"
            case testSetName = "testSetName"
        }
    }

    public struct UserTurnInputSpecification: AWSDecodableShape {
        /// Request attributes of the user turn.
        public let requestAttributes: [String: String]?
        /// Contains information about the session state in the input.
        public let sessionState: InputSessionStateSpecification?
        /// The utterance input in the user turn.
        public let utteranceInput: UtteranceInputSpecification

        @inlinable
        public init(requestAttributes: [String: String]? = nil, sessionState: InputSessionStateSpecification? = nil, utteranceInput: UtteranceInputSpecification) {
            self.requestAttributes = requestAttributes
            self.sessionState = sessionState
            self.utteranceInput = utteranceInput
        }

        private enum CodingKeys: String, CodingKey {
            case requestAttributes = "requestAttributes"
            case sessionState = "sessionState"
            case utteranceInput = "utteranceInput"
        }
    }

    public struct UserTurnIntentOutput: AWSDecodableShape {
        /// The name of the intent.
        public let name: String
        /// The slots associated with the intent.
        public let slots: [String: UserTurnSlotOutput]?

        @inlinable
        public init(name: String, slots: [String: UserTurnSlotOutput]? = nil) {
            self.name = name
            self.slots = slots
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case slots = "slots"
        }
    }

    public struct UserTurnOutputSpecification: AWSDecodableShape {
        /// The contexts that are active in the turn.
        public let activeContexts: [ActiveContext]?
        /// Contains information about the intent.
        public let intent: UserTurnIntentOutput
        /// The transcript that is output for the user turn by the test execution.
        public let transcript: String?

        @inlinable
        public init(activeContexts: [ActiveContext]? = nil, intent: UserTurnIntentOutput, transcript: String? = nil) {
            self.activeContexts = activeContexts
            self.intent = intent
            self.transcript = transcript
        }

        private enum CodingKeys: String, CodingKey {
            case activeContexts = "activeContexts"
            case intent = "intent"
            case transcript = "transcript"
        }
    }

    public struct UserTurnResult: AWSDecodableShape {
        /// Contains information about the actual output for the user turn.
        public let actualOutput: UserTurnOutputSpecification?
        /// Contains information about the results related to the conversation associated with the user turn.
        public let conversationLevelResult: ConversationLevelResultDetail?
        /// Specifies whether the expected and actual outputs match or not, or if there is an error in execution.
        public let endToEndResult: TestResultMatchStatus?
        public let errorDetails: ExecutionErrorDetails?
        /// Contains information about the expected output for the user turn.
        public let expectedOutput: UserTurnOutputSpecification
        /// Contains information about the user messages in the turn in the input.
        public let input: UserTurnInputSpecification
        /// Specifies whether the expected and actual intents match or not.
        public let intentMatchResult: TestResultMatchStatus?
        /// Specifies whether the expected and actual slots match or not.
        public let slotMatchResult: TestResultMatchStatus?
        /// Specifies whether the expected and actual speech transcriptions match or not, or if there is an error in execution.
        public let speechTranscriptionResult: TestResultMatchStatus?

        @inlinable
        public init(actualOutput: UserTurnOutputSpecification? = nil, conversationLevelResult: ConversationLevelResultDetail? = nil, endToEndResult: TestResultMatchStatus? = nil, errorDetails: ExecutionErrorDetails? = nil, expectedOutput: UserTurnOutputSpecification, input: UserTurnInputSpecification, intentMatchResult: TestResultMatchStatus? = nil, slotMatchResult: TestResultMatchStatus? = nil, speechTranscriptionResult: TestResultMatchStatus? = nil) {
            self.actualOutput = actualOutput
            self.conversationLevelResult = conversationLevelResult
            self.endToEndResult = endToEndResult
            self.errorDetails = errorDetails
            self.expectedOutput = expectedOutput
            self.input = input
            self.intentMatchResult = intentMatchResult
            self.slotMatchResult = slotMatchResult
            self.speechTranscriptionResult = speechTranscriptionResult
        }

        private enum CodingKeys: String, CodingKey {
            case actualOutput = "actualOutput"
            case conversationLevelResult = "conversationLevelResult"
            case endToEndResult = "endToEndResult"
            case errorDetails = "errorDetails"
            case expectedOutput = "expectedOutput"
            case input = "input"
            case intentMatchResult = "intentMatchResult"
            case slotMatchResult = "slotMatchResult"
            case speechTranscriptionResult = "speechTranscriptionResult"
        }
    }

    public struct UserTurnSlotOutput: AWSDecodableShape {
        /// A list of items mapping the name of the subslots to information about those subslots.
        public let subSlots: [String: UserTurnSlotOutput]?
        /// The value output by the slot recognition.
        public let value: String?
        /// Values that are output by the slot recognition.
        public let values: [UserTurnSlotOutput]?

        @inlinable
        public init(subSlots: [String: UserTurnSlotOutput]? = nil, value: String? = nil, values: [UserTurnSlotOutput]? = nil) {
            self.subSlots = subSlots
            self.value = value
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case subSlots = "subSlots"
            case value = "value"
            case values = "values"
        }
    }

    public struct UserTurnSpecification: AWSDecodableShape {
        /// Contains results about the expected output for the user turn.
        public let expected: UserTurnOutputSpecification
        /// Contains information about the user messages in the turn in the input.
        public let input: UserTurnInputSpecification

        @inlinable
        public init(expected: UserTurnOutputSpecification, input: UserTurnInputSpecification) {
            self.expected = expected
            self.input = input
        }

        private enum CodingKeys: String, CodingKey {
            case expected = "expected"
            case input = "input"
        }
    }

    public struct UtteranceAggregationDuration: AWSEncodableShape & AWSDecodableShape {
        /// The desired time window for aggregating utterances.
        public let relativeAggregationDuration: RelativeAggregationDuration

        @inlinable
        public init(relativeAggregationDuration: RelativeAggregationDuration) {
            self.relativeAggregationDuration = relativeAggregationDuration
        }

        public func validate(name: String) throws {
            try self.relativeAggregationDuration.validate(name: "\(name).relativeAggregationDuration")
        }

        private enum CodingKeys: String, CodingKey {
            case relativeAggregationDuration = "relativeAggregationDuration"
        }
    }

    public struct UtteranceAudioInputSpecification: AWSDecodableShape {
        /// Amazon S3 file pointing to the audio.
        public let audioFileS3Location: String

        @inlinable
        public init(audioFileS3Location: String) {
            self.audioFileS3Location = audioFileS3Location
        }

        private enum CodingKeys: String, CodingKey {
            case audioFileS3Location = "audioFileS3Location"
        }
    }

    public struct UtteranceBotResponse: AWSDecodableShape {
        /// The text of the response to the utterance from the bot.
        public let content: String?
        /// The type of the response. The following values are possible:    PlainText – A plain text string.    CustomPayload – A response string that you can customize to include data or metadata for your application.    SSML – A string that includes Speech Synthesis Markup Language to customize the audio response.    ImageResponseCard – An image with buttons that the customer can select. See ImageResponseCard for more information.
        public let contentType: UtteranceContentType?
        public let imageResponseCard: ImageResponseCard?

        @inlinable
        public init(content: String? = nil, contentType: UtteranceContentType? = nil, imageResponseCard: ImageResponseCard? = nil) {
            self.content = content
            self.contentType = contentType
            self.imageResponseCard = imageResponseCard
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case contentType = "contentType"
            case imageResponseCard = "imageResponseCard"
        }
    }

    public struct UtteranceDataSortBy: AWSEncodableShape {
        /// The measure by which to sort the utterance analytics data.    Count – The number of utterances.    UtteranceTimestamp – The date and time of the utterance.
        public let name: AnalyticsUtteranceSortByName
        /// Specifies whether to sort the results in ascending or descending order.
        public let order: AnalyticsSortOrder

        @inlinable
        public init(name: AnalyticsUtteranceSortByName, order: AnalyticsSortOrder) {
            self.name = name
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
        }
    }

    public struct UtteranceInputSpecification: AWSDecodableShape {
        /// Contains information about the audio input for an utterance.
        public let audioInput: UtteranceAudioInputSpecification?
        /// A text input transcription of the utterance. It is only applicable for test-sets containing text data.
        public let textInput: String?

        @inlinable
        public init(audioInput: UtteranceAudioInputSpecification? = nil, textInput: String? = nil) {
            self.audioInput = audioInput
            self.textInput = textInput
        }

        private enum CodingKeys: String, CodingKey {
            case audioInput = "audioInput"
            case textInput = "textInput"
        }
    }

    public struct UtteranceLevelTestResultItem: AWSDecodableShape {
        /// The unique identifier for the conversation associated with the result.
        public let conversationId: String?
        /// The record number of the result.
        public let recordNumber: Int64
        /// Contains information about the turn associated with the result.
        public let turnResult: TestSetTurnResult

        @inlinable
        public init(conversationId: String? = nil, recordNumber: Int64, turnResult: TestSetTurnResult) {
            self.conversationId = conversationId
            self.recordNumber = recordNumber
            self.turnResult = turnResult
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case recordNumber = "recordNumber"
            case turnResult = "turnResult"
        }
    }

    public struct UtteranceLevelTestResults: AWSDecodableShape {
        /// Contains information about an utterance in the results of the test set execution.
        public let items: [UtteranceLevelTestResultItem]

        @inlinable
        public init(items: [UtteranceLevelTestResultItem]) {
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
        }
    }

    public struct UtteranceSpecification: AWSDecodableShape {
        /// The name of the intent that the utterance is associated to.
        public let associatedIntentName: String?
        /// The name of the slot that the utterance is associated to.
        public let associatedSlotName: String?
        /// The duration in milliseconds of the audio associated with the utterance.
        public let audioVoiceDurationMillis: Int64?
        /// The identifier of the alias of the bot that the utterance was made to.
        public let botAliasId: String?
        /// The identifier for the audio of the bot response.
        public let botResponseAudioVoiceId: String?
        /// A list of objects containing information about the bot response to the utterance.
        public let botResponses: [UtteranceBotResponse]?
        /// The version of the bot that the utterance was made to.
        public let botVersion: String?
        /// The channel that is integrated with the bot that the utterance was made to.
        public let channel: String?
        /// The date and time when the conversation in which the utterance took place ended. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public let conversationEndTime: Date?
        /// The date and time when the conversation in which the utterance took place began. A conversation is defined as a unique combination of a sessionId and an originatingRequestId.
        public let conversationStartTime: Date?
        /// The type of dialog action that the utterance is associated to. See the type field in DialogAction for more information.
        public let dialogActionType: String?
        /// The input type of the utterance. The possible values are as follows:   PCM format: audio data must be in little-endian byte order.    audio/l16; rate=16000; channels=1     audio/x-l16; sample-rate=16000; channel-count=1     audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false      Opus format    audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4      Text format    text/plain; charset=utf-8
        public let inputType: String?
        /// The state of the intent that the utterance is associated to.
        public let intentState: IntentState?
        /// The locale of the bot that the utterance was made to.
        public let localeId: String?
        /// The mode of the session. The possible values are as follows:    Speech – The session consisted of spoken dialogue.    Text – The session consisted of written dialogue.    DTMF – The session consisted of touch-tone keypad (Dual Tone Multi-Frequency) key presses.    MultiMode – The session consisted of multiple modes.
        public let mode: AnalyticsModality?
        /// The output type of the utterance. The possible values are as follows:    audio/mpeg     audio/ogg     audio/pcm (16 KHz)     audio/ (defaults to mpeg)    text/plain; charset=utf-8
        public let outputType: String?
        /// The identifier of the session that the utterance was made in.
        public let sessionId: String?
        /// The slots that have been filled in the session by the time of the utterance.
        public let slotsFilledInSession: String?
        /// The text of the utterance.
        public let utterance: String?
        /// The identifier of the request associated with the utterance.
        public let utteranceRequestId: String?
        /// The date and time when the utterance took place.
        public let utteranceTimestamp: Date?
        /// Specifies whether the bot understood the utterance or not.
        public let utteranceUnderstood: Bool?

        @inlinable
        public init(associatedIntentName: String? = nil, associatedSlotName: String? = nil, audioVoiceDurationMillis: Int64? = nil, botAliasId: String? = nil, botResponseAudioVoiceId: String? = nil, botResponses: [UtteranceBotResponse]? = nil, botVersion: String? = nil, channel: String? = nil, conversationEndTime: Date? = nil, conversationStartTime: Date? = nil, dialogActionType: String? = nil, inputType: String? = nil, intentState: IntentState? = nil, localeId: String? = nil, mode: AnalyticsModality? = nil, outputType: String? = nil, sessionId: String? = nil, slotsFilledInSession: String? = nil, utterance: String? = nil, utteranceRequestId: String? = nil, utteranceTimestamp: Date? = nil, utteranceUnderstood: Bool? = nil) {
            self.associatedIntentName = associatedIntentName
            self.associatedSlotName = associatedSlotName
            self.audioVoiceDurationMillis = audioVoiceDurationMillis
            self.botAliasId = botAliasId
            self.botResponseAudioVoiceId = botResponseAudioVoiceId
            self.botResponses = botResponses
            self.botVersion = botVersion
            self.channel = channel
            self.conversationEndTime = conversationEndTime
            self.conversationStartTime = conversationStartTime
            self.dialogActionType = dialogActionType
            self.inputType = inputType
            self.intentState = intentState
            self.localeId = localeId
            self.mode = mode
            self.outputType = outputType
            self.sessionId = sessionId
            self.slotsFilledInSession = slotsFilledInSession
            self.utterance = utterance
            self.utteranceRequestId = utteranceRequestId
            self.utteranceTimestamp = utteranceTimestamp
            self.utteranceUnderstood = utteranceUnderstood
        }

        private enum CodingKeys: String, CodingKey {
            case associatedIntentName = "associatedIntentName"
            case associatedSlotName = "associatedSlotName"
            case audioVoiceDurationMillis = "audioVoiceDurationMillis"
            case botAliasId = "botAliasId"
            case botResponseAudioVoiceId = "botResponseAudioVoiceId"
            case botResponses = "botResponses"
            case botVersion = "botVersion"
            case channel = "channel"
            case conversationEndTime = "conversationEndTime"
            case conversationStartTime = "conversationStartTime"
            case dialogActionType = "dialogActionType"
            case inputType = "inputType"
            case intentState = "intentState"
            case localeId = "localeId"
            case mode = "mode"
            case outputType = "outputType"
            case sessionId = "sessionId"
            case slotsFilledInSession = "slotsFilledInSession"
            case utterance = "utterance"
            case utteranceRequestId = "utteranceRequestId"
            case utteranceTimestamp = "utteranceTimestamp"
            case utteranceUnderstood = "utteranceUnderstood"
        }
    }

    public struct VoiceSettings: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the  engine parameter of the SynthesizeSpeech operation in the Amazon Polly developer guide. If you do not specify a value, the default is standard.
        public let engine: VoiceEngine?
        /// The identifier of the Amazon Polly voice to use.
        public let voiceId: String

        @inlinable
        public init(engine: VoiceEngine? = nil, voiceId: String) {
            self.engine = engine
            self.voiceId = voiceId
        }

        private enum CodingKeys: String, CodingKey {
            case engine = "engine"
            case voiceId = "voiceId"
        }
    }

    public struct WaitAndContinueSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the bot will wait for a user to respond. When this field is false, wait and continue responses for a slot aren't used. If the active field isn't specified, the default is true.
        public let active: Bool?
        /// The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        public let continueResponse: ResponseSpecification
        /// A response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        public let stillWaitingResponse: StillWaitingResponseSpecification?
        /// The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        public let waitingResponse: ResponseSpecification

        @inlinable
        public init(active: Bool? = nil, continueResponse: ResponseSpecification, stillWaitingResponse: StillWaitingResponseSpecification? = nil, waitingResponse: ResponseSpecification) {
            self.active = active
            self.continueResponse = continueResponse
            self.stillWaitingResponse = stillWaitingResponse
            self.waitingResponse = waitingResponse
        }

        public func validate(name: String) throws {
            try self.continueResponse.validate(name: "\(name).continueResponse")
            try self.stillWaitingResponse?.validate(name: "\(name).stillWaitingResponse")
            try self.waitingResponse.validate(name: "\(name).waitingResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case continueResponse = "continueResponse"
            case stillWaitingResponse = "stillWaitingResponse"
            case waitingResponse = "waitingResponse"
        }
    }
}

// MARK: - Errors

/// Error enum for LexModelsV2
public struct LexModelsV2ErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case preconditionFailedException = "PreconditionFailedException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize LexModelsV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The action that you tried to perform couldn't be completed because the resource is in a conflicting state. For example, deleting a bot that is in the CREATING state. Try your request again.
    public static var conflictException: Self { .init(.conflictException) }
    /// The service encountered an unexpected condition. Try your request again.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Your request couldn't be completed because one or more request fields aren't valid. Check the fields in your request and try again.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// You asked to describe a resource that doesn't exist. Check the resource that you are requesting and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have reached a quota for your bot.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Your request rate is too high. Reduce the frequency of requests.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One of the input parameters in your request isn't valid. Check the parameters and try your request again.
    public static var validationException: Self { .init(.validationException) }
}

extension LexModelsV2ErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ThrottlingException": LexModelsV2.ThrottlingException.self
    ]
}

extension LexModelsV2ErrorType: Equatable {
    public static func == (lhs: LexModelsV2ErrorType, rhs: LexModelsV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LexModelsV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
