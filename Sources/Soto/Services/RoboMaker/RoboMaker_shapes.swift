//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension RoboMaker {
    // MARK: Enums

    public enum Architecture: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arm64 = "ARM64"
        case armhf = "ARMHF"
        case x8664 = "X86_64"
        public var description: String { return self.rawValue }
    }

    public enum ComputeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cpu = "CPU"
        case gpuAndCpu = "GPU_AND_CPU"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archive = "Archive"
        case file = "File"
        case prefix = "Prefix"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentJobErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badLambdaAssociated = "BadLambdaAssociated"
        case badPermissionError = "BadPermissionError"
        case deploymentFleetDoesNotExist = "DeploymentFleetDoesNotExist"
        case downloadConditionFailed = "DownloadConditionFailed"
        case environmentSetupError = "EnvironmentSetupError"
        case etagMismatch = "EtagMismatch"
        case extractingBundleFailure = "ExtractingBundleFailure"
        case failureThresholdBreached = "FailureThresholdBreached"
        case fleetDeploymentTimeout = "FleetDeploymentTimeout"
        case greengrassDeploymentFailed = "GreengrassDeploymentFailed"
        case greengrassGroupVersionDoesNotExist = "GreengrassGroupVersionDoesNotExist"
        case internalServerError = "InternalServerError"
        case invalidGreengrassGroup = "InvalidGreengrassGroup"
        case lambdaDeleted = "LambdaDeleted"
        case missingRobotApplicationArchitecture = "MissingRobotApplicationArchitecture"
        case missingRobotArchitecture = "MissingRobotArchitecture"
        case missingRobotDeploymentResource = "MissingRobotDeploymentResource"
        case postLaunchFileFailure = "PostLaunchFileFailure"
        case preLaunchFileFailure = "PreLaunchFileFailure"
        case resourceNotFound = "ResourceNotFound"
        case robotAgentConnectionTimeout = "RobotAgentConnectionTimeout"
        case robotApplicationDoesNotExist = "RobotApplicationDoesNotExist"
        case robotDeploymentAborted = "RobotDeploymentAborted"
        case robotDeploymentNoResponse = "RobotDeploymentNoResponse"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "Canceled"
        case failed = "Failed"
        case inProgress = "InProgress"
        case pending = "Pending"
        case preparing = "Preparing"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum ExitBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fail = "FAIL"
        case restart = "RESTART"
        public var description: String { return self.rawValue }
    }

    public enum FailureBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `continue` = "Continue"
        case fail = "Fail"
        public var description: String { return self.rawValue }
    }

    public enum RenderingEngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ogre = "OGRE"
        public var description: String { return self.rawValue }
    }

    public enum RobotDeploymentStep: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case downloadingExtractingStep = "DownloadingExtracting"
        case executingDownloadCondition = "ExecutingDownloadCondition"
        case finishedStep = "Finished"
        case launchingStep = "Launching"
        case postLaunchStep = "ExecutingPostLaunch"
        case preLaunchStep = "ExecutingPreLaunch"
        case validatingStep = "Validating"
        public var description: String { return self.rawValue }
    }

    public enum RobotSoftwareSuiteType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case general = "General"
        case ros = "ROS"
        case ros2 = "ROS2"
        public var description: String { return self.rawValue }
    }

    public enum RobotSoftwareSuiteVersionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dashing = "Dashing"
        case foxy = "Foxy"
        case kinetic = "Kinetic"
        case melodic = "Melodic"
        public var description: String { return self.rawValue }
    }

    public enum RobotStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case deploying = "Deploying"
        case failed = "Failed"
        case inSync = "InSync"
        case noResponse = "NoResponse"
        case pendingNewDeployment = "PendingNewDeployment"
        case registered = "Registered"
        public var description: String { return self.rawValue }
    }

    public enum SimulationJobBatchErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalServiceError = "InternalServiceError"
        public var description: String { return self.rawValue }
    }

    public enum SimulationJobBatchStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "Canceled"
        case canceling = "Canceling"
        case completed = "Completed"
        case completing = "Completing"
        case failed = "Failed"
        case inProgress = "InProgress"
        case pending = "Pending"
        case timedOut = "TimedOut"
        case timingOut = "TimingOut"
        public var description: String { return self.rawValue }
    }

    public enum SimulationJobErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case badPermissionsCloudwatchLogs = "BadPermissionsCloudwatchLogs"
        case badPermissionsRobotApplication = "BadPermissionsRobotApplication"
        case badPermissionsS3Object = "BadPermissionsS3Object"
        case badPermissionsS3Output = "BadPermissionsS3Output"
        case badPermissionsSimulationApplication = "BadPermissionsSimulationApplication"
        case badPermissionsUserCredentials = "BadPermissionsUserCredentials"
        case batchCanceled = "BatchCanceled"
        case batchTimedOut = "BatchTimedOut"
        case eniLimitExceeded = "ENILimitExceeded"
        case internalServiceError = "InternalServiceError"
        case invalidBundleRobotApplication = "InvalidBundleRobotApplication"
        case invalidBundleSimulationApplication = "InvalidBundleSimulationApplication"
        case invalidInput = "InvalidInput"
        case invalidS3Resource = "InvalidS3Resource"
        case limitExceeded = "LimitExceeded"
        case mismatchedEtag = "MismatchedEtag"
        case requestThrottled = "RequestThrottled"
        case resourceNotFound = "ResourceNotFound"
        case robotApplicationCrash = "RobotApplicationCrash"
        case robotApplicationHealthCheckFailure = "RobotApplicationHealthCheckFailure"
        case robotApplicationVersionMismatchedEtag = "RobotApplicationVersionMismatchedEtag"
        case simulationApplicationCrash = "SimulationApplicationCrash"
        case simulationApplicationHealthCheckFailure = "SimulationApplicationHealthCheckFailure"
        case simulationApplicationVersionMismatchedEtag = "SimulationApplicationVersionMismatchedEtag"
        case subnetIpLimitExceeded = "SubnetIpLimitExceeded"
        case throttlingError = "ThrottlingError"
        case uploadContentMismatchError = "UploadContentMismatchError"
        case wrongRegionRobotApplication = "WrongRegionRobotApplication"
        case wrongRegionS3Bucket = "WrongRegionS3Bucket"
        case wrongRegionS3Output = "WrongRegionS3Output"
        case wrongRegionSimulationApplication = "WrongRegionSimulationApplication"
        public var description: String { return self.rawValue }
    }

    public enum SimulationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "Canceled"
        case completed = "Completed"
        case failed = "Failed"
        case pending = "Pending"
        case preparing = "Preparing"
        case restarting = "Restarting"
        case running = "Running"
        case runningFailed = "RunningFailed"
        case terminated = "Terminated"
        case terminating = "Terminating"
        public var description: String { return self.rawValue }
    }

    public enum SimulationSoftwareSuiteType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gazebo = "Gazebo"
        case rosbagPlay = "RosbagPlay"
        case simulationRuntime = "SimulationRuntime"
        public var description: String { return self.rawValue }
    }

    public enum UploadBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case uploadOnTerminate = "UPLOAD_ON_TERMINATE"
        case uploadRollingAutoRemove = "UPLOAD_ROLLING_AUTO_REMOVE"
        public var description: String { return self.rawValue }
    }

    public enum WorldExportJobErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "AccessDenied"
        case internalServiceError = "InternalServiceError"
        case invalidInput = "InvalidInput"
        case limitExceeded = "LimitExceeded"
        case requestThrottled = "RequestThrottled"
        case resourceNotFound = "ResourceNotFound"
        public var description: String { return self.rawValue }
    }

    public enum WorldExportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "Canceled"
        case canceling = "Canceling"
        case completed = "Completed"
        case failed = "Failed"
        case pending = "Pending"
        case running = "Running"
        public var description: String { return self.rawValue }
    }

    public enum WorldGenerationJobErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allWorldGenerationFailed = "AllWorldGenerationFailed"
        case internalServiceError = "InternalServiceError"
        case invalidInput = "InvalidInput"
        case limitExceeded = "LimitExceeded"
        case requestThrottled = "RequestThrottled"
        case resourceNotFound = "ResourceNotFound"
        public var description: String { return self.rawValue }
    }

    public enum WorldGenerationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "Canceled"
        case canceling = "Canceling"
        case completed = "Completed"
        case failed = "Failed"
        case partialFailed = "PartialFailed"
        case pending = "Pending"
        case running = "Running"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchDeleteWorldsRequest: AWSEncodableShape {
        /// A list of Amazon Resource Names (arns) that correspond to worlds to delete.
        public let worlds: [String]

        public init(worlds: [String]) {
            self.worlds = worlds
        }

        public func validate(name: String) throws {
            try self.worlds.forEach {
                try validate($0, name: "worlds[]", parent: name, max: 1224)
                try validate($0, name: "worlds[]", parent: name, min: 1)
                try validate($0, name: "worlds[]", parent: name, pattern: "^arn:")
            }
            try self.validate(self.worlds, name: "worlds", parent: name, max: 100)
            try self.validate(self.worlds, name: "worlds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case worlds = "worlds"
        }
    }

    public struct BatchDeleteWorldsResponse: AWSDecodableShape {
        /// A list of unprocessed worlds associated with the call. These worlds were not deleted.
        public let unprocessedWorlds: [String]?

        public init(unprocessedWorlds: [String]? = nil) {
            self.unprocessedWorlds = unprocessedWorlds
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedWorlds = "unprocessedWorlds"
        }
    }

    public struct BatchDescribeSimulationJobRequest: AWSEncodableShape {
        /// A list of Amazon Resource Names (ARNs) of simulation jobs to describe.
        public let jobs: [String]

        public init(jobs: [String]) {
            self.jobs = jobs
        }

        public func validate(name: String) throws {
            try self.jobs.forEach {
                try validate($0, name: "jobs[]", parent: name, max: 1224)
                try validate($0, name: "jobs[]", parent: name, min: 1)
                try validate($0, name: "jobs[]", parent: name, pattern: "^arn:")
            }
            try self.validate(self.jobs, name: "jobs", parent: name, max: 100)
            try self.validate(self.jobs, name: "jobs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
        }
    }

    public struct BatchDescribeSimulationJobResponse: AWSDecodableShape {
        /// A list of simulation jobs.
        public let jobs: [SimulationJob]?
        /// A list of unprocessed simulation job Amazon Resource Names (ARNs).
        public let unprocessedJobs: [String]?

        public init(jobs: [SimulationJob]? = nil, unprocessedJobs: [String]? = nil) {
            self.jobs = jobs
            self.unprocessedJobs = unprocessedJobs
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case unprocessedJobs = "unprocessedJobs"
        }
    }

    public struct BatchPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The number of active simulation jobs create as part of the batch that can be in an active state at the same time.  Active states include: Pending,Preparing, Running, Restarting, RunningFailed and Terminating. All other states are terminal states.
        public let maxConcurrency: Int?
        /// The amount of time, in seconds, to wait for the batch to complete.   If a batch times out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), they will be moved to the failed list and the batch status will be Failed. If the pending requests were failing for any other reason, the failed pending requests will be moved to the failed list and the batch status will be TimedOut.
        public let timeoutInSeconds: Int64?

        public init(maxConcurrency: Int? = nil, timeoutInSeconds: Int64? = nil) {
            self.maxConcurrency = maxConcurrency
            self.timeoutInSeconds = timeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case maxConcurrency = "maxConcurrency"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct CancelDeploymentJobRequest: AWSEncodableShape {
        /// The deployment job ARN to cancel.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct CancelDeploymentJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelSimulationJobBatchRequest: AWSEncodableShape {
        /// The id of the batch to cancel.
        public let batch: String

        public init(batch: String) {
            self.batch = batch
        }

        public func validate(name: String) throws {
            try self.validate(self.batch, name: "batch", parent: name, max: 1224)
            try self.validate(self.batch, name: "batch", parent: name, min: 1)
            try self.validate(self.batch, name: "batch", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case batch = "batch"
        }
    }

    public struct CancelSimulationJobBatchResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelSimulationJobRequest: AWSEncodableShape {
        /// The simulation job ARN to cancel.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct CancelSimulationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelWorldExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world export job to cancel.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct CancelWorldExportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelWorldGenerationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world generator job to cancel.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct CancelWorldGenerationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Compute: AWSEncodableShape & AWSDecodableShape {
        /// Compute type information for the simulation job.
        public let computeType: ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public let gpuUnitLimit: Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public let simulationUnitLimit: Int?

        public init(computeType: ComputeType? = nil, gpuUnitLimit: Int? = nil, simulationUnitLimit: Int? = nil) {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.gpuUnitLimit, name: "gpuUnitLimit", parent: name, max: 1)
            try self.validate(self.gpuUnitLimit, name: "gpuUnitLimit", parent: name, min: 0)
            try self.validate(self.simulationUnitLimit, name: "simulationUnitLimit", parent: name, max: 15)
            try self.validate(self.simulationUnitLimit, name: "simulationUnitLimit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case computeType = "computeType"
            case gpuUnitLimit = "gpuUnitLimit"
            case simulationUnitLimit = "simulationUnitLimit"
        }
    }

    public struct ComputeResponse: AWSDecodableShape {
        /// Compute type response information for the simulation job.
        public let computeType: ComputeType?
        /// Compute GPU unit limit for the simulation job. It is the same as the number of GPUs allocated to the SimulationJob.
        public let gpuUnitLimit: Int?
        /// The simulation unit limit. Your simulation is allocated CPU and memory proportional to the supplied simulation unit limit. A simulation unit is 1 vcpu and 2GB of memory. You are only billed for the SU utilization you consume up to the maximum value provided. The default is 15.
        public let simulationUnitLimit: Int?

        public init(computeType: ComputeType? = nil, gpuUnitLimit: Int? = nil, simulationUnitLimit: Int? = nil) {
            self.computeType = computeType
            self.gpuUnitLimit = gpuUnitLimit
            self.simulationUnitLimit = simulationUnitLimit
        }

        private enum CodingKeys: String, CodingKey {
            case computeType = "computeType"
            case gpuUnitLimit = "gpuUnitLimit"
            case simulationUnitLimit = "simulationUnitLimit"
        }
    }

    public struct CreateDeploymentJobRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String
        /// The deployment application configuration.
        public let deploymentApplicationConfigs: [DeploymentApplicationConfig]
        /// The requested deployment configuration.
        public let deploymentConfig: DeploymentConfig?
        /// The Amazon Resource Name (ARN) of the fleet to deploy.
        public let fleet: String
        /// A map that contains tag keys and tag values that are attached to the deployment job.
        public let tags: [String: String]?

        public init(clientRequestToken: String = CreateDeploymentJobRequest.idempotencyToken(), deploymentApplicationConfigs: [DeploymentApplicationConfig], deploymentConfig: DeploymentConfig? = nil, fleet: String, tags: [String: String]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.fleet = fleet
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9_\\-=]*$")
            try self.deploymentApplicationConfigs.forEach {
                try $0.validate(name: "\(name).deploymentApplicationConfigs[]")
            }
            try self.validate(self.deploymentApplicationConfigs, name: "deploymentApplicationConfigs", parent: name, max: 1)
            try self.validate(self.deploymentApplicationConfigs, name: "deploymentApplicationConfigs", parent: name, min: 1)
            try self.deploymentConfig?.validate(name: "\(name).deploymentConfig")
            try self.validate(self.fleet, name: "fleet", parent: name, max: 1224)
            try self.validate(self.fleet, name: "fleet", parent: name, min: 1)
            try self.validate(self.fleet, name: "fleet", parent: name, pattern: "^arn:")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case deploymentApplicationConfigs = "deploymentApplicationConfigs"
            case deploymentConfig = "deploymentConfig"
            case fleet = "fleet"
            case tags = "tags"
        }
    }

    public struct CreateDeploymentJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public let createdAt: Date?
        /// The deployment application configuration.
        public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
        /// The deployment configuration.
        public let deploymentConfig: DeploymentConfig?
        /// The failure code of the simulation job if it failed:  BadPermissionError  AWS Greengrass requires a service-level role permission to access other services. The role must include the  AWSGreengrassResourceAccessRolePolicy managed policy.   ExtractingBundleFailure  The robot application could not be extracted from the bundle.  FailureThresholdBreached  The percentage of robots that could not be updated exceeded the percentage set for the deployment.  GreengrassDeploymentFailed  The robot application could not be deployed to the robot.  GreengrassGroupVersionDoesNotExist  The AWS Greengrass group or version associated with a robot is missing.  InternalServerError  An internal error has occurred. Retry your request, but if the problem persists, contact us with details.  MissingRobotApplicationArchitecture  The robot application does not have a source that matches the architecture of the robot.  MissingRobotDeploymentResource  One or more of the resources specified for the robot application are missing. For example, does the robot application have the correct launch package and launch file?  PostLaunchFileFailure  The post-launch script failed.  PreLaunchFileFailure  The pre-launch script failed.  ResourceNotFound  One or more deployment resources are missing. For example, do robot application source bundles still exist?   RobotDeploymentNoResponse  There is no response from the robot. It might not be powered on or connected to the internet.
        public let failureCode: DeploymentJobErrorCode?
        /// The failure reason of the deployment job if it failed.
        public let failureReason: String?
        /// The target fleet for the deployment job.
        public let fleet: String?
        /// The status of the deployment job.
        public let status: DeploymentStatus?
        /// The list of all tags added to the deployment job.
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: Date? = nil, deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil, deploymentConfig: DeploymentConfig? = nil, failureCode: DeploymentJobErrorCode? = nil, failureReason: String? = nil, fleet: String? = nil, status: DeploymentStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentApplicationConfigs = "deploymentApplicationConfigs"
            case deploymentConfig = "deploymentConfig"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case fleet = "fleet"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateFleetRequest: AWSEncodableShape {
        /// The name of the fleet.
        public let name: String
        /// A map that contains tag keys and tag values that are attached to the fleet.
        public let tags: [String: String]?

        public init(name: String, tags: [String: String]? = nil) {
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateFleetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public let createdAt: Date?
        /// The name of the fleet.
        public let name: String?
        /// The list of all tags added to the fleet.
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: Date? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateRobotApplicationRequest: AWSEncodableShape {
        /// The object that contains that URI of the Docker image that you use for your robot application.
        public let environment: Environment?
        /// The name of the robot application.
        public let name: String
        /// The robot software suite (ROS distribuition) used by the robot application.
        public let robotSoftwareSuite: RobotSoftwareSuite
        /// The sources of the robot application.
        public let sources: [SourceConfig]?
        /// A map that contains tag keys and tag values that are attached to the robot application.
        public let tags: [String: String]?

        public init(environment: Environment? = nil, name: String, robotSoftwareSuite: RobotSoftwareSuite, sources: [SourceConfig]? = nil, tags: [String: String]? = nil) {
            self.environment = environment
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.sources = sources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.environment?.validate(name: "\(name).environment")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.sources?.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
            case name = "name"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case sources = "sources"
            case tags = "tags"
        }
    }

    public struct CreateRobotApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the robot application.
        public let arn: String?
        /// An object that contains the Docker image URI used to a create your robot application.
        public let environment: Environment?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the robot application.
        public let name: String?
        /// The revision id of the robot application.
        public let revisionId: String?
        /// The robot software suite (ROS distribution) used by the robot application.
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The sources of the robot application.
        public let sources: [Source]?
        /// The list of all tags added to the robot application.
        public let tags: [String: String]?
        /// The version of the robot application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, sources: [Source]? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.sources = sources
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case sources = "sources"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct CreateRobotApplicationVersionRequest: AWSEncodableShape {
        /// The application information for the robot application.
        public let application: String
        /// The current revision id for the robot application. If you provide a value and it matches the latest revision ID, a new version will be created.
        public let currentRevisionId: String?
        /// A SHA256 identifier for the Docker image that you use for your robot application.
        public let imageDigest: String?
        /// The Amazon S3 identifier for the zip file bundle that you use for your robot application.
        public let s3Etags: [String]?

        public init(application: String, currentRevisionId: String? = nil, imageDigest: String? = nil, s3Etags: [String]? = nil) {
            self.application = application
            self.currentRevisionId = currentRevisionId
            self.imageDigest = imageDigest
            self.s3Etags = s3Etags
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, max: 40)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, min: 1)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, max: 72)
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, pattern: "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case currentRevisionId = "currentRevisionId"
            case imageDigest = "imageDigest"
            case s3Etags = "s3Etags"
        }
    }

    public struct CreateRobotApplicationVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the robot application.
        public let arn: String?
        /// The object that contains the Docker image URI used to create your robot application.
        public let environment: Environment?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the robot application.
        public let name: String?
        /// The revision id of the robot application.
        public let revisionId: String?
        /// The robot software suite (ROS distribution) used by the robot application.
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The sources of the robot application.
        public let sources: [Source]?
        /// The version of the robot application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, sources: [Source]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.sources = sources
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case sources = "sources"
            case version = "version"
        }
    }

    public struct CreateRobotRequest: AWSEncodableShape {
        /// The target architecture of the robot.
        public let architecture: Architecture
        /// The Greengrass group id.
        public let greengrassGroupId: String
        /// The name for the robot.
        public let name: String
        /// A map that contains tag keys and tag values that are attached to the robot.
        public let tags: [String: String]?

        public init(architecture: Architecture, greengrassGroupId: String, name: String, tags: [String: String]? = nil) {
            self.architecture = architecture
            self.greengrassGroupId = greengrassGroupId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.greengrassGroupId, name: "greengrassGroupId", parent: name, max: 1224)
            try self.validate(self.greengrassGroupId, name: "greengrassGroupId", parent: name, min: 1)
            try self.validate(self.greengrassGroupId, name: "greengrassGroupId", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case greengrassGroupId = "greengrassGroupId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateRobotResponse: AWSDecodableShape {
        /// The target architecture of the robot.
        public let architecture: Architecture?
        /// The Amazon Resource Name (ARN) of the robot.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the robot was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the Greengrass group associated with the robot.
        public let greengrassGroupId: String?
        /// The name of the robot.
        public let name: String?
        /// The list of all tags added to the robot.
        public let tags: [String: String]?

        public init(architecture: Architecture? = nil, arn: String? = nil, createdAt: Date? = nil, greengrassGroupId: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.greengrassGroupId = greengrassGroupId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case arn = "arn"
            case createdAt = "createdAt"
            case greengrassGroupId = "greengrassGroupId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateSimulationApplicationRequest: AWSEncodableShape {
        /// The object that contains the Docker image URI used to create your simulation application.
        public let environment: Environment?
        /// The name of the simulation application.
        public let name: String
        /// The rendering engine for the simulation application.
        public let renderingEngine: RenderingEngine?
        /// The robot software suite (ROS distribution) used by the simulation application.
        public let robotSoftwareSuite: RobotSoftwareSuite
        /// The simulation software suite used by the simulation application.
        public let simulationSoftwareSuite: SimulationSoftwareSuite
        /// The sources of the simulation application.
        public let sources: [SourceConfig]?
        /// A map that contains tag keys and tag values that are attached to the simulation application.
        public let tags: [String: String]?

        public init(environment: Environment? = nil, name: String, renderingEngine: RenderingEngine? = nil, robotSoftwareSuite: RobotSoftwareSuite, simulationSoftwareSuite: SimulationSoftwareSuite, sources: [SourceConfig]? = nil, tags: [String: String]? = nil) {
            self.environment = environment
            self.name = name
            self.renderingEngine = renderingEngine
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.sources = sources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.environment?.validate(name: "\(name).environment")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.renderingEngine?.validate(name: "\(name).renderingEngine")
            try self.simulationSoftwareSuite.validate(name: "\(name).simulationSoftwareSuite")
            try self.sources?.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case environment = "environment"
            case name = "name"
            case renderingEngine = "renderingEngine"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case simulationSoftwareSuite = "simulationSoftwareSuite"
            case sources = "sources"
            case tags = "tags"
        }
    }

    public struct CreateSimulationApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the simulation application.
        public let arn: String?
        /// The object that contains the Docker image URI that you used to create your simulation application.
        public let environment: Environment?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the simulation application.
        public let name: String?
        /// The rendering engine for the simulation application.
        public let renderingEngine: RenderingEngine?
        /// The revision id of the simulation application.
        public let revisionId: String?
        /// Information about the robot software suite (ROS distribution).
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The simulation software suite used by the simulation application.
        public let simulationSoftwareSuite: SimulationSoftwareSuite?
        /// The sources of the simulation application.
        public let sources: [Source]?
        /// The list of all tags added to the simulation application.
        public let tags: [String: String]?
        /// The version of the simulation application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, renderingEngine: RenderingEngine? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, simulationSoftwareSuite: SimulationSoftwareSuite? = nil, sources: [Source]? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.renderingEngine = renderingEngine
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.sources = sources
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case renderingEngine = "renderingEngine"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case simulationSoftwareSuite = "simulationSoftwareSuite"
            case sources = "sources"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct CreateSimulationApplicationVersionRequest: AWSEncodableShape {
        /// The application information for the simulation application.
        public let application: String
        /// The current revision id for the simulation application. If you provide a value and it matches the latest revision ID, a new version will be created.
        public let currentRevisionId: String?
        /// The SHA256 digest used to identify the Docker image URI used to created the simulation application.
        public let imageDigest: String?
        /// The Amazon S3 eTag identifier for the zip file bundle that you use to create the simulation application.
        public let s3Etags: [String]?

        public init(application: String, currentRevisionId: String? = nil, imageDigest: String? = nil, s3Etags: [String]? = nil) {
            self.application = application
            self.currentRevisionId = currentRevisionId
            self.imageDigest = imageDigest
            self.s3Etags = s3Etags
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, max: 40)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, min: 1)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, max: 72)
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, pattern: "^[Ss][Hh][Aa]256:[0-9a-fA-F]{64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case currentRevisionId = "currentRevisionId"
            case imageDigest = "imageDigest"
            case s3Etags = "s3Etags"
        }
    }

    public struct CreateSimulationApplicationVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the simulation application.
        public let arn: String?
        /// The object that contains the Docker image URI used to create the simulation application.
        public let environment: Environment?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the simulation application.
        public let name: String?
        /// The rendering engine for the simulation application.
        public let renderingEngine: RenderingEngine?
        /// The revision ID of the simulation application.
        public let revisionId: String?
        /// Information about the robot software suite (ROS distribution).
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The simulation software suite used by the simulation application.
        public let simulationSoftwareSuite: SimulationSoftwareSuite?
        /// The sources of the simulation application.
        public let sources: [Source]?
        /// The version of the simulation application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, renderingEngine: RenderingEngine? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, simulationSoftwareSuite: SimulationSoftwareSuite? = nil, sources: [Source]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.renderingEngine = renderingEngine
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.sources = sources
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case renderingEngine = "renderingEngine"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case simulationSoftwareSuite = "simulationSoftwareSuite"
            case sources = "sources"
            case version = "version"
        }
    }

    public struct CreateSimulationJobRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// Compute information for the simulation job.
        public let compute: Compute?
        /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name.   There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
        public let dataSources: [DataSourceConfig]?
        /// The failure behavior the simulation job.  Continue  Leaves the instance running for its maximum timeout duration after a 4XX error code.  Fail  Stop the simulation job and terminate the instance.
        public let failureBehavior: FailureBehavior?
        /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public let iamRole: String
        /// The logging configuration.
        public let loggingConfig: LoggingConfig?
        /// The maximum simulation job duration in seconds (up to 14 days or 1,209,600 seconds. When maxJobDurationInSeconds is reached, the simulation job will status will transition to Completed.
        public let maxJobDurationInSeconds: Int64
        /// Location for output files generated by the simulation job.
        public let outputLocation: OutputLocation?
        /// The robot application to use in the simulation job.
        public let robotApplications: [RobotApplicationConfig]?
        /// The simulation application to use in the simulation job.
        public let simulationApplications: [SimulationApplicationConfig]?
        /// A map that contains tag keys and tag values that are attached to the simulation job.
        public let tags: [String: String]?
        /// If your simulation job accesses resources in a VPC, you provide this parameter identifying the list of security group IDs and subnet IDs. These must belong to the same VPC. You must provide at least one security group and one subnet ID.
        public let vpcConfig: VPCConfig?

        public init(clientRequestToken: String? = CreateSimulationJobRequest.idempotencyToken(), compute: Compute? = nil, dataSources: [DataSourceConfig]? = nil, failureBehavior: FailureBehavior? = nil, iamRole: String, loggingConfig: LoggingConfig? = nil, maxJobDurationInSeconds: Int64 = 0, outputLocation: OutputLocation? = nil, robotApplications: [RobotApplicationConfig]? = nil, simulationApplications: [SimulationApplicationConfig]? = nil, tags: [String: String]? = nil, vpcConfig: VPCConfig? = nil) {
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.iamRole = iamRole
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9_\\-=]*$")
            try self.compute?.validate(name: "\(name).compute")
            try self.dataSources?.forEach {
                try $0.validate(name: "\(name).dataSources[]")
            }
            try self.validate(self.dataSources, name: "dataSources", parent: name, max: 6)
            try self.validate(self.dataSources, name: "dataSources", parent: name, min: 1)
            try self.validate(self.iamRole, name: "iamRole", parent: name, max: 255)
            try self.validate(self.iamRole, name: "iamRole", parent: name, min: 1)
            try self.validate(self.iamRole, name: "iamRole", parent: name, pattern: "^arn:aws:iam::\\w+:role/")
            try self.outputLocation?.validate(name: "\(name).outputLocation")
            try self.robotApplications?.forEach {
                try $0.validate(name: "\(name).robotApplications[]")
            }
            try self.validate(self.robotApplications, name: "robotApplications", parent: name, max: 1)
            try self.validate(self.robotApplications, name: "robotApplications", parent: name, min: 1)
            try self.simulationApplications?.forEach {
                try $0.validate(name: "\(name).simulationApplications[]")
            }
            try self.validate(self.simulationApplications, name: "simulationApplications", parent: name, max: 1)
            try self.validate(self.simulationApplications, name: "simulationApplications", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case compute = "compute"
            case dataSources = "dataSources"
            case failureBehavior = "failureBehavior"
            case iamRole = "iamRole"
            case loggingConfig = "loggingConfig"
            case maxJobDurationInSeconds = "maxJobDurationInSeconds"
            case outputLocation = "outputLocation"
            case robotApplications = "robotApplications"
            case simulationApplications = "simulationApplications"
            case tags = "tags"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CreateSimulationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// Compute information for the simulation job.
        public let compute: ComputeResponse?
        /// The data sources for the simulation job.
        public let dataSources: [DataSource]?
        /// the failure behavior for the simulation job.
        public let failureBehavior: FailureBehavior?
        /// The failure code of the simulation job if it failed:  InternalServiceError  Internal service error.  RobotApplicationCrash  Robot application exited abnormally.  SimulationApplicationCrash  Simulation application exited abnormally.  BadPermissionsRobotApplication  Robot application bundle could not be downloaded.  BadPermissionsSimulationApplication  Simulation application bundle could not be downloaded.  BadPermissionsS3Output  Unable to publish outputs to customer-provided S3 bucket.  BadPermissionsCloudwatchLogs  Unable to publish logs to customer-provided CloudWatch Logs resource.  SubnetIpLimitExceeded  Subnet IP limit exceeded.  ENILimitExceeded  ENI limit exceeded.  BadPermissionsUserCredentials  Unable to use the Role provided.  InvalidBundleRobotApplication  Robot bundle cannot be extracted (invalid format, bundling error, or other issue).  InvalidBundleSimulationApplication  Simulation bundle cannot be extracted (invalid format, bundling error, or other issue).  RobotApplicationVersionMismatchedEtag  Etag for RobotApplication does not match value during version creation.  SimulationApplicationVersionMismatchedEtag  Etag for SimulationApplication does not match value during version creation.
        public let failureCode: SimulationJobErrorCode?
        /// The IAM role that allows the simulation job to call the AWS APIs that are specified in its associated policies on your behalf.
        public let iamRole: String?
        /// The time, in milliseconds since the epoch, when the simulation job was last started.
        public let lastStartedAt: Date?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public let lastUpdatedAt: Date?
        /// The logging configuration.
        public let loggingConfig: LoggingConfig?
        /// The maximum simulation job duration in seconds.
        public let maxJobDurationInSeconds: Int64?
        /// Simulation job output files location.
        public let outputLocation: OutputLocation?
        /// The robot application used by the simulation job.
        public let robotApplications: [RobotApplicationConfig]?
        /// The simulation application used by the simulation job.
        public let simulationApplications: [SimulationApplicationConfig]?
        /// The simulation job execution duration in milliseconds.
        public let simulationTimeMillis: Int64?
        /// The status of the simulation job.
        public let status: SimulationJobStatus?
        /// The list of all tags added to the simulation job.
        public let tags: [String: String]?
        /// Information about the vpc configuration.
        public let vpcConfig: VPCConfigResponse?

        public init(arn: String? = nil, clientRequestToken: String? = nil, compute: ComputeResponse? = nil, dataSources: [DataSource]? = nil, failureBehavior: FailureBehavior? = nil, failureCode: SimulationJobErrorCode? = nil, iamRole: String? = nil, lastStartedAt: Date? = nil, lastUpdatedAt: Date? = nil, loggingConfig: LoggingConfig? = nil, maxJobDurationInSeconds: Int64? = nil, outputLocation: OutputLocation? = nil, robotApplications: [RobotApplicationConfig]? = nil, simulationApplications: [SimulationApplicationConfig]? = nil, simulationTimeMillis: Int64? = nil, status: SimulationJobStatus? = nil, tags: [String: String]? = nil, vpcConfig: VPCConfigResponse? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.failureCode = failureCode
            self.iamRole = iamRole
            self.lastStartedAt = lastStartedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.simulationTimeMillis = simulationTimeMillis
            self.status = status
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case compute = "compute"
            case dataSources = "dataSources"
            case failureBehavior = "failureBehavior"
            case failureCode = "failureCode"
            case iamRole = "iamRole"
            case lastStartedAt = "lastStartedAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case loggingConfig = "loggingConfig"
            case maxJobDurationInSeconds = "maxJobDurationInSeconds"
            case outputLocation = "outputLocation"
            case robotApplications = "robotApplications"
            case simulationApplications = "simulationApplications"
            case simulationTimeMillis = "simulationTimeMillis"
            case status = "status"
            case tags = "tags"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CreateWorldExportJobRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
        public let iamRole: String
        public let outputLocation: OutputLocation
        /// A map that contains tag keys and tag values that are attached to the world export job.
        public let tags: [String: String]?
        /// A list of Amazon Resource Names (arns) that correspond to worlds to export.
        public let worlds: [String]

        public init(clientRequestToken: String? = CreateWorldExportJobRequest.idempotencyToken(), iamRole: String, outputLocation: OutputLocation, tags: [String: String]? = nil, worlds: [String]) {
            self.clientRequestToken = clientRequestToken
            self.iamRole = iamRole
            self.outputLocation = outputLocation
            self.tags = tags
            self.worlds = worlds
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9_\\-=]*$")
            try self.validate(self.iamRole, name: "iamRole", parent: name, max: 255)
            try self.validate(self.iamRole, name: "iamRole", parent: name, min: 1)
            try self.validate(self.iamRole, name: "iamRole", parent: name, pattern: "^arn:aws:iam::\\w+:role/")
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.worlds.forEach {
                try validate($0, name: "worlds[]", parent: name, max: 1224)
                try validate($0, name: "worlds[]", parent: name, min: 1)
                try validate($0, name: "worlds[]", parent: name, pattern: "^arn:")
            }
            try self.validate(self.worlds, name: "worlds", parent: name, max: 100)
            try self.validate(self.worlds, name: "worlds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case iamRole = "iamRole"
            case outputLocation = "outputLocation"
            case tags = "tags"
            case worlds = "worlds"
        }
    }

    public struct CreateWorldExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world export job.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the world export job was created.
        public let createdAt: Date?
        /// The failure code of the world export job if it failed:  InternalServiceError  Internal service error.  LimitExceeded  The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.   ResourceNotFound  The specified resource could not be found.   RequestThrottled  The request was throttled.  InvalidInput  An input parameter in the request is not valid.  AllWorldGenerationFailed  All of the worlds in the world generation job failed. This can happen if your worldCount is greater than 50 or less than 1.    For more information about troubleshooting WorldForge, see Troubleshooting Simulation WorldForge.
        public let failureCode: WorldExportJobErrorCode?
        /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
        public let iamRole: String?
        public let outputLocation: OutputLocation?
        /// The status of the world export job.  Pending  The world export job request is pending.  Running  The world export job is running.   Completed  The world export job completed.   Failed  The world export job failed. See failureCode for more information.   Canceled  The world export job was cancelled.  Canceling  The world export job is being cancelled.
        public let status: WorldExportJobStatus?
        /// A map that contains tag keys and tag values that are attached to the world export job.
        public let tags: [String: String]?

        public init(arn: String? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, failureCode: WorldExportJobErrorCode? = nil, iamRole: String? = nil, outputLocation: OutputLocation? = nil, status: WorldExportJobStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.failureCode = failureCode
            self.iamRole = iamRole
            self.outputLocation = outputLocation
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case failureCode = "failureCode"
            case iamRole = "iamRole"
            case outputLocation = "outputLocation"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateWorldGenerationJobRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// A map that contains tag keys and tag values that are attached to the world generator job.
        public let tags: [String: String]?
        /// The Amazon Resource Name (arn) of the world template describing the worlds you want to create.
        public let template: String
        /// Information about the world count.
        public let worldCount: WorldCount
        /// A map that contains tag keys and tag values that are attached to the generated worlds.
        public let worldTags: [String: String]?

        public init(clientRequestToken: String? = CreateWorldGenerationJobRequest.idempotencyToken(), tags: [String: String]? = nil, template: String, worldCount: WorldCount, worldTags: [String: String]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.tags = tags
            self.template = template
            self.worldCount = worldCount
            self.worldTags = worldTags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9_\\-=]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.template, name: "template", parent: name, max: 1224)
            try self.validate(self.template, name: "template", parent: name, min: 1)
            try self.validate(self.template, name: "template", parent: name, pattern: "^arn:")
            try self.worldTags?.forEach {
                try validate($0.key, name: "worldTags.key", parent: name, max: 128)
                try validate($0.key, name: "worldTags.key", parent: name, min: 1)
                try validate($0.key, name: "worldTags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "worldTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "worldTags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.worldTags, name: "worldTags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case tags = "tags"
            case template = "template"
            case worldCount = "worldCount"
            case worldTags = "worldTags"
        }
    }

    public struct CreateWorldGenerationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world generator job.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the world generator job was created.
        public let createdAt: Date?
        /// The failure code of the world generator job if it failed:  InternalServiceError  Internal service error.  LimitExceeded  The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.   ResourceNotFound  The specified resource could not be found.   RequestThrottled  The request was throttled.  InvalidInput  An input parameter in the request is not valid.
        public let failureCode: WorldGenerationJobErrorCode?
        /// The status of the world generator job.  Pending  The world generator job request is pending.  Running  The world generator job is running.   Completed  The world generator job completed.   Failed  The world generator job failed. See failureCode for more information.   PartialFailed  Some worlds did not generate.  Canceled  The world generator job was cancelled.  Canceling  The world generator job is being cancelled.
        public let status: WorldGenerationJobStatus?
        /// A map that contains tag keys and tag values that are attached to the world generator job.
        public let tags: [String: String]?
        /// The Amazon Resource Name (arn) of the world template.
        public let template: String?
        /// Information about the world count.
        public let worldCount: WorldCount?
        /// A map that contains tag keys and tag values that are attached to the generated worlds.
        public let worldTags: [String: String]?

        public init(arn: String? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, failureCode: WorldGenerationJobErrorCode? = nil, status: WorldGenerationJobStatus? = nil, tags: [String: String]? = nil, template: String? = nil, worldCount: WorldCount? = nil, worldTags: [String: String]? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.failureCode = failureCode
            self.status = status
            self.tags = tags
            self.template = template
            self.worldCount = worldCount
            self.worldTags = worldTags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case failureCode = "failureCode"
            case status = "status"
            case tags = "tags"
            case template = "template"
            case worldCount = "worldCount"
            case worldTags = "worldTags"
        }
    }

    public struct CreateWorldTemplateRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The name of the world template.
        public let name: String?
        /// A map that contains tag keys and tag values that are attached to the world template.
        public let tags: [String: String]?
        /// The world template body.
        public let templateBody: String?
        /// The location of the world template.
        public let templateLocation: TemplateLocation?

        public init(clientRequestToken: String? = nil, name: String? = nil, tags: [String: String]? = nil, templateBody: String? = nil, templateLocation: TemplateLocation? = nil) {
            self.clientRequestToken = clientRequestToken
            self.name = name
            self.tags = tags
            self.templateBody = templateBody
            self.templateLocation = templateLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9_\\-=]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.templateBody, name: "templateBody", parent: name, max: 262144)
            try self.validate(self.templateBody, name: "templateBody", parent: name, min: 1)
            try self.validate(self.templateBody, name: "templateBody", parent: name, pattern: "^[\\S\\s]+$")
            try self.templateLocation?.validate(name: "\(name).templateLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case name = "name"
            case tags = "tags"
            case templateBody = "templateBody"
            case templateLocation = "templateLocation"
        }
    }

    public struct CreateWorldTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world template.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the world template was created.
        public let createdAt: Date?
        /// The name of the world template.
        public let name: String?
        /// A map that contains tag keys and tag values that are attached to the world template.
        public let tags: [String: String]?

        public init(arn: String? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public let destination: String?
        /// The name of the data source.
        public let name: String?
        /// The S3 bucket where the data files are located.
        public let s3Bucket: String?
        /// The list of S3 keys identifying the data source files.
        public let s3Keys: [S3KeyOutput]?
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public let type: DataSourceType?

        public init(destination: String? = nil, name: String? = nil, s3Bucket: String? = nil, s3Keys: [S3KeyOutput]? = nil, type: DataSourceType? = nil) {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case name = "name"
            case s3Bucket = "s3Bucket"
            case s3Keys = "s3Keys"
            case type = "type"
        }
    }

    public struct DataSourceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The location where your files are mounted in the container image. If you've specified the type of the data source as an Archive, you must provide an Amazon S3 object key to your archive. The object key must point to either a .zip or .tar.gz file. If you've specified the type of the data source as a Prefix, you provide the Amazon S3 prefix that points to the files that you are using for your data source. If you've specified the type of the data source as a File, you provide the Amazon S3 path to the file that you're using as your data source.
        public let destination: String?
        /// The name of the data source.
        public let name: String
        /// The S3 bucket where the data files are located.
        public let s3Bucket: String
        /// The list of S3 keys identifying the data source files.
        public let s3Keys: [String]
        /// The data type for the data source that you're using for your container image or simulation job. You can use this field to specify whether your data source is an Archive, an Amazon S3 prefix, or a file. If you don't specify a field, the default value is File.
        public let type: DataSourceType?

        public init(destination: String? = nil, name: String, s3Bucket: String, s3Keys: [String], type: DataSourceType? = nil) {
            self.destination = destination
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-z0-9][a-z0-9.\\-]*[a-z0-9]$")
            try self.s3Keys.forEach {
                try validate($0, name: "s3Keys[]", parent: name, max: 1024)
                try validate($0, name: "s3Keys[]", parent: name, pattern: ".*")
            }
            try self.validate(self.s3Keys, name: "s3Keys", parent: name, max: 100)
            try self.validate(self.s3Keys, name: "s3Keys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case name = "name"
            case s3Bucket = "s3Bucket"
            case s3Keys = "s3Keys"
            case type = "type"
        }
    }

    public struct DeleteFleetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String

        public init(fleet: String) {
            self.fleet = fleet
        }

        public func validate(name: String) throws {
            try self.validate(self.fleet, name: "fleet", parent: name, max: 1224)
            try self.validate(self.fleet, name: "fleet", parent: name, min: 1)
            try self.validate(self.fleet, name: "fleet", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "fleet"
        }
    }

    public struct DeleteFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRobotApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the the robot application.
        public let application: String
        /// The version of the robot application to delete.
        public let applicationVersion: String?

        public init(application: String, applicationVersion: String? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, max: 255)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, pattern: "^(\\$LATEST)|[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case applicationVersion = "applicationVersion"
        }
    }

    public struct DeleteRobotApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRobotRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the robot.
        public let robot: String

        public init(robot: String) {
            self.robot = robot
        }

        public func validate(name: String) throws {
            try self.validate(self.robot, name: "robot", parent: name, max: 1224)
            try self.validate(self.robot, name: "robot", parent: name, min: 1)
            try self.validate(self.robot, name: "robot", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case robot = "robot"
        }
    }

    public struct DeleteRobotResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSimulationApplicationRequest: AWSEncodableShape {
        /// The application information for the simulation application to delete.
        public let application: String
        /// The version of the simulation application to delete.
        public let applicationVersion: String?

        public init(application: String, applicationVersion: String? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, max: 255)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, pattern: "^(\\$LATEST)|[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case applicationVersion = "applicationVersion"
        }
    }

    public struct DeleteSimulationApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorldTemplateRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world template you want to delete.
        public let template: String

        public init(template: String) {
            self.template = template
        }

        public func validate(name: String) throws {
            try self.validate(self.template, name: "template", parent: name, max: 1224)
            try self.validate(self.template, name: "template", parent: name, min: 1)
            try self.validate(self.template, name: "template", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case template = "template"
        }
    }

    public struct DeleteWorldTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeploymentApplicationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the robot application.
        public let application: String
        /// The version of the application.
        public let applicationVersion: String
        /// The launch configuration.
        public let launchConfig: DeploymentLaunchConfig

        public init(application: String, applicationVersion: String, launchConfig: DeploymentLaunchConfig) {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, max: 255)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, pattern: "^[0-9]*$")
            try self.launchConfig.validate(name: "\(name).launchConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case applicationVersion = "applicationVersion"
            case launchConfig = "launchConfig"
        }
    }

    public struct DeploymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// The percentage of robots receiving the deployment at the same time.
        public let concurrentDeploymentPercentage: Int?
        /// The download condition file.
        public let downloadConditionFile: S3Object?
        /// The percentage of deployments that need to fail before stopping deployment.
        public let failureThresholdPercentage: Int?
        /// The amount of time, in seconds, to wait for deployment to a single robot to complete. Choose a time between 1 minute and 7 days. The default is 5 hours.
        public let robotDeploymentTimeoutInSeconds: Int64?

        public init(concurrentDeploymentPercentage: Int? = nil, downloadConditionFile: S3Object? = nil, failureThresholdPercentage: Int? = nil, robotDeploymentTimeoutInSeconds: Int64? = nil) {
            self.concurrentDeploymentPercentage = concurrentDeploymentPercentage
            self.downloadConditionFile = downloadConditionFile
            self.failureThresholdPercentage = failureThresholdPercentage
            self.robotDeploymentTimeoutInSeconds = robotDeploymentTimeoutInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.concurrentDeploymentPercentage, name: "concurrentDeploymentPercentage", parent: name, max: 100)
            try self.validate(self.concurrentDeploymentPercentage, name: "concurrentDeploymentPercentage", parent: name, min: 1)
            try self.downloadConditionFile?.validate(name: "\(name).downloadConditionFile")
            try self.validate(self.failureThresholdPercentage, name: "failureThresholdPercentage", parent: name, max: 100)
            try self.validate(self.failureThresholdPercentage, name: "failureThresholdPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case concurrentDeploymentPercentage = "concurrentDeploymentPercentage"
            case downloadConditionFile = "downloadConditionFile"
            case failureThresholdPercentage = "failureThresholdPercentage"
            case robotDeploymentTimeoutInSeconds = "robotDeploymentTimeoutInSeconds"
        }
    }

    public struct DeploymentJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the deployment job was created.
        public let createdAt: Date?
        /// The deployment application configuration.
        public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
        /// The deployment configuration.
        public let deploymentConfig: DeploymentConfig?
        /// The deployment job failure code.
        public let failureCode: DeploymentJobErrorCode?
        /// A short description of the reason why the deployment job failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String?
        /// The status of the deployment job.
        public let status: DeploymentStatus?

        public init(arn: String? = nil, createdAt: Date? = nil, deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil, deploymentConfig: DeploymentConfig? = nil, failureCode: DeploymentJobErrorCode? = nil, failureReason: String? = nil, fleet: String? = nil, status: DeploymentStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentApplicationConfigs = "deploymentApplicationConfigs"
            case deploymentConfig = "deploymentConfig"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case fleet = "fleet"
            case status = "status"
        }
    }

    public struct DeploymentLaunchConfig: AWSEncodableShape & AWSDecodableShape {
        /// An array of key/value pairs specifying environment variables for the robot application
        public let environmentVariables: [String: String]?
        /// The launch file name.
        public let launchFile: String
        /// The package name.
        public let packageName: String
        /// The deployment post-launch file. This file will be executed after the launch file.
        public let postLaunchFile: String?
        /// The deployment pre-launch file. This file will be executed prior to the launch file.
        public let preLaunchFile: String?

        public init(environmentVariables: [String: String]? = nil, launchFile: String, packageName: String, postLaunchFile: String? = nil, preLaunchFile: String? = nil) {
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.postLaunchFile = postLaunchFile
            self.preLaunchFile = preLaunchFile
        }

        public func validate(name: String) throws {
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 1024)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^[A-Z_][A-Z0-9_]*$")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 20)
            try self.validate(self.launchFile, name: "launchFile", parent: name, max: 1024)
            try self.validate(self.launchFile, name: "launchFile", parent: name, min: 1)
            try self.validate(self.launchFile, name: "launchFile", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.validate(self.packageName, name: "packageName", parent: name, max: 1024)
            try self.validate(self.packageName, name: "packageName", parent: name, min: 1)
            try self.validate(self.packageName, name: "packageName", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.validate(self.postLaunchFile, name: "postLaunchFile", parent: name, max: 1024)
            try self.validate(self.postLaunchFile, name: "postLaunchFile", parent: name, min: 1)
            try self.validate(self.postLaunchFile, name: "postLaunchFile", parent: name, pattern: ".*")
            try self.validate(self.preLaunchFile, name: "preLaunchFile", parent: name, max: 1024)
            try self.validate(self.preLaunchFile, name: "preLaunchFile", parent: name, min: 1)
            try self.validate(self.preLaunchFile, name: "preLaunchFile", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentVariables = "environmentVariables"
            case launchFile = "launchFile"
            case packageName = "packageName"
            case postLaunchFile = "postLaunchFile"
            case preLaunchFile = "preLaunchFile"
        }
    }

    public struct DeregisterRobotRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String
        /// The Amazon Resource Name (ARN) of the robot.
        public let robot: String

        public init(fleet: String, robot: String) {
            self.fleet = fleet
            self.robot = robot
        }

        public func validate(name: String) throws {
            try self.validate(self.fleet, name: "fleet", parent: name, max: 1224)
            try self.validate(self.fleet, name: "fleet", parent: name, min: 1)
            try self.validate(self.fleet, name: "fleet", parent: name, pattern: "^arn:")
            try self.validate(self.robot, name: "robot", parent: name, max: 1224)
            try self.validate(self.robot, name: "robot", parent: name, min: 1)
            try self.validate(self.robot, name: "robot", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "fleet"
            case robot = "robot"
        }
    }

    public struct DeregisterRobotResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String?
        /// The Amazon Resource Name (ARN) of the robot.
        public let robot: String?

        public init(fleet: String? = nil, robot: String? = nil) {
            self.fleet = fleet
            self.robot = robot
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "fleet"
            case robot = "robot"
        }
    }

    public struct DescribeDeploymentJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct DescribeDeploymentJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deployment job.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the deployment job was created.
        public let createdAt: Date?
        /// The deployment application configuration.
        public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
        /// The deployment configuration.
        public let deploymentConfig: DeploymentConfig?
        /// The deployment job failure code.
        public let failureCode: DeploymentJobErrorCode?
        /// A short description of the reason why the deployment job failed.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String?
        /// A list of robot deployment summaries.
        public let robotDeploymentSummary: [RobotDeployment]?
        /// The status of the deployment job.
        public let status: DeploymentStatus?
        /// The list of all tags added to the specified deployment job.
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: Date? = nil, deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil, deploymentConfig: DeploymentConfig? = nil, failureCode: DeploymentJobErrorCode? = nil, failureReason: String? = nil, fleet: String? = nil, robotDeploymentSummary: [RobotDeployment]? = nil, status: DeploymentStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.robotDeploymentSummary = robotDeploymentSummary
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentApplicationConfigs = "deploymentApplicationConfigs"
            case deploymentConfig = "deploymentConfig"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case fleet = "fleet"
            case robotDeploymentSummary = "robotDeploymentSummary"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct DescribeFleetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String

        public init(fleet: String) {
            self.fleet = fleet
        }

        public func validate(name: String) throws {
            try self.validate(self.fleet, name: "fleet", parent: name, max: 1224)
            try self.validate(self.fleet, name: "fleet", parent: name, min: 1)
            try self.validate(self.fleet, name: "fleet", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "fleet"
        }
    }

    public struct DescribeFleetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public let lastDeploymentJob: String?
        /// The status of the last deployment.
        public let lastDeploymentStatus: DeploymentStatus?
        /// The time of the last deployment.
        public let lastDeploymentTime: Date?
        /// The name of the fleet.
        public let name: String?
        /// A list of robots.
        public let robots: [Robot]?
        /// The list of all tags added to the specified fleet.
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: Date? = nil, lastDeploymentJob: String? = nil, lastDeploymentStatus: DeploymentStatus? = nil, lastDeploymentTime: Date? = nil, name: String? = nil, robots: [Robot]? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentStatus = lastDeploymentStatus
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
            self.robots = robots
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastDeploymentJob = "lastDeploymentJob"
            case lastDeploymentStatus = "lastDeploymentStatus"
            case lastDeploymentTime = "lastDeploymentTime"
            case name = "name"
            case robots = "robots"
            case tags = "tags"
        }
    }

    public struct DescribeRobotApplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the robot application.
        public let application: String
        /// The version of the robot application to describe.
        public let applicationVersion: String?

        public init(application: String, applicationVersion: String? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, max: 255)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, pattern: "^(\\$LATEST)|[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case applicationVersion = "applicationVersion"
        }
    }

    public struct DescribeRobotApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the robot application.
        public let arn: String?
        /// The object that contains the Docker image URI used to create the robot application.
        public let environment: Environment?
        /// A SHA256 identifier for the Docker image that you use for your robot application.
        public let imageDigest: String?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the robot application.
        public let name: String?
        /// The revision id of the robot application.
        public let revisionId: String?
        /// The robot software suite (ROS distribution) used by the robot application.
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The sources of the robot application.
        public let sources: [Source]?
        /// The list of all tags added to the specified robot application.
        public let tags: [String: String]?
        /// The version of the robot application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, imageDigest: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, sources: [Source]? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.imageDigest = imageDigest
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.sources = sources
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case imageDigest = "imageDigest"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case sources = "sources"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct DescribeRobotRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the robot to be described.
        public let robot: String

        public init(robot: String) {
            self.robot = robot
        }

        public func validate(name: String) throws {
            try self.validate(self.robot, name: "robot", parent: name, max: 1224)
            try self.validate(self.robot, name: "robot", parent: name, min: 1)
            try self.validate(self.robot, name: "robot", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case robot = "robot"
        }
    }

    public struct DescribeRobotResponse: AWSDecodableShape {
        /// The target architecture of the robot application.
        public let architecture: Architecture?
        /// The Amazon Resource Name (ARN) of the robot.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the robot was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleetArn: String?
        /// The Greengrass group id.
        public let greengrassGroupId: String?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public let lastDeploymentJob: String?
        /// The time of the last deployment job.
        public let lastDeploymentTime: Date?
        /// The name of the robot.
        public let name: String?
        /// The status of the fleet.
        public let status: RobotStatus?
        /// The list of all tags added to the specified robot.
        public let tags: [String: String]?

        public init(architecture: Architecture? = nil, arn: String? = nil, createdAt: Date? = nil, fleetArn: String? = nil, greengrassGroupId: String? = nil, lastDeploymentJob: String? = nil, lastDeploymentTime: Date? = nil, name: String? = nil, status: RobotStatus? = nil, tags: [String: String]? = nil) {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.fleetArn = fleetArn
            self.greengrassGroupId = greengrassGroupId
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case arn = "arn"
            case createdAt = "createdAt"
            case fleetArn = "fleetArn"
            case greengrassGroupId = "greengrassGroupId"
            case lastDeploymentJob = "lastDeploymentJob"
            case lastDeploymentTime = "lastDeploymentTime"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct DescribeSimulationApplicationRequest: AWSEncodableShape {
        /// The application information for the simulation application.
        public let application: String
        /// The version of the simulation application to describe.
        public let applicationVersion: String?

        public init(application: String, applicationVersion: String? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, max: 255)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, pattern: "^(\\$LATEST)|[0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case applicationVersion = "applicationVersion"
        }
    }

    public struct DescribeSimulationApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the robot simulation application.
        public let arn: String?
        /// The object that contains the Docker image URI used to create the simulation application.
        public let environment: Environment?
        /// A SHA256 identifier for the Docker image that you use for your simulation application.
        public let imageDigest: String?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the simulation application.
        public let name: String?
        /// The rendering engine for the simulation application.
        public let renderingEngine: RenderingEngine?
        /// The revision id of the simulation application.
        public let revisionId: String?
        /// Information about the robot software suite (ROS distribution).
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The simulation software suite used by the simulation application.
        public let simulationSoftwareSuite: SimulationSoftwareSuite?
        /// The sources of the simulation application.
        public let sources: [Source]?
        /// The list of all tags added to the specified simulation application.
        public let tags: [String: String]?
        /// The version of the simulation application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, imageDigest: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, renderingEngine: RenderingEngine? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, simulationSoftwareSuite: SimulationSoftwareSuite? = nil, sources: [Source]? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.imageDigest = imageDigest
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.renderingEngine = renderingEngine
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.sources = sources
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case imageDigest = "imageDigest"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case renderingEngine = "renderingEngine"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case simulationSoftwareSuite = "simulationSoftwareSuite"
            case sources = "sources"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct DescribeSimulationJobBatchRequest: AWSEncodableShape {
        /// The id of the batch to describe.
        public let batch: String

        public init(batch: String) {
            self.batch = batch
        }

        public func validate(name: String) throws {
            try self.validate(self.batch, name: "batch", parent: name, max: 1224)
            try self.validate(self.batch, name: "batch", parent: name, min: 1)
            try self.validate(self.batch, name: "batch", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case batch = "batch"
        }
    }

    public struct DescribeSimulationJobBatchResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch.
        public let arn: String?
        /// The batch policy.
        public let batchPolicy: BatchPolicy?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was created.
        public let createdAt: Date?
        /// A list of created simulation job summaries.
        public let createdRequests: [SimulationJobSummary]?
        /// A list of failed create simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
        public let failedRequests: [FailedCreateSimulationJobRequest]?
        /// The failure code of the simulation job batch.
        public let failureCode: SimulationJobBatchErrorCode?
        /// The reason the simulation job batch failed.
        public let failureReason: String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
        public let lastUpdatedAt: Date?
        /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
        public let pendingRequests: [SimulationJobRequest]?
        /// The status of the batch.  Pending  The simulation job batch request is pending.  InProgress  The simulation job batch is in progress.   Failed  The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information.  Completed  The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed).   Canceled  The simulation batch job was cancelled.  Canceling  The simulation batch job is being cancelled.  Completing  The simulation batch job is completing.  TimingOut  The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut.   TimedOut  The simulation batch job timed out.
        public let status: SimulationJobBatchStatus?
        /// A map that contains tag keys and tag values that are attached to the simulation job batch.
        public let tags: [String: String]?

        public init(arn: String? = nil, batchPolicy: BatchPolicy? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, createdRequests: [SimulationJobSummary]? = nil, failedRequests: [FailedCreateSimulationJobRequest]? = nil, failureCode: SimulationJobBatchErrorCode? = nil, failureReason: String? = nil, lastUpdatedAt: Date? = nil, pendingRequests: [SimulationJobRequest]? = nil, status: SimulationJobBatchStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.batchPolicy = batchPolicy
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.createdRequests = createdRequests
            self.failedRequests = failedRequests
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.lastUpdatedAt = lastUpdatedAt
            self.pendingRequests = pendingRequests
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case batchPolicy = "batchPolicy"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case createdRequests = "createdRequests"
            case failedRequests = "failedRequests"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case lastUpdatedAt = "lastUpdatedAt"
            case pendingRequests = "pendingRequests"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct DescribeSimulationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the simulation job to be described.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct DescribeSimulationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// Compute information for the simulation job.
        public let compute: ComputeResponse?
        /// The data sources for the simulation job.
        public let dataSources: [DataSource]?
        /// The failure behavior for the simulation job.
        public let failureBehavior: FailureBehavior?
        /// The failure code of the simulation job if it failed:  InternalServiceError  Internal service error.  RobotApplicationCrash  Robot application exited abnormally.  SimulationApplicationCrash  Simulation application exited abnormally.  BadPermissionsRobotApplication  Robot application bundle could not be downloaded.  BadPermissionsSimulationApplication  Simulation application bundle could not be downloaded.  BadPermissionsS3Output  Unable to publish outputs to customer-provided S3 bucket.  BadPermissionsCloudwatchLogs  Unable to publish logs to customer-provided CloudWatch Logs resource.  SubnetIpLimitExceeded  Subnet IP limit exceeded.  ENILimitExceeded  ENI limit exceeded.  BadPermissionsUserCredentials  Unable to use the Role provided.  InvalidBundleRobotApplication  Robot bundle cannot be extracted (invalid format, bundling error, or other issue).  InvalidBundleSimulationApplication  Simulation bundle cannot be extracted (invalid format, bundling error, or other issue).  RobotApplicationVersionMismatchedEtag  Etag for RobotApplication does not match value during version creation.  SimulationApplicationVersionMismatchedEtag  Etag for SimulationApplication does not match value during version creation.
        public let failureCode: SimulationJobErrorCode?
        /// Details about why the simulation job failed. For more information about troubleshooting, see Troubleshooting.
        public let failureReason: String?
        /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf.
        public let iamRole: String?
        /// The time, in milliseconds since the epoch, when the simulation job was last started.
        public let lastStartedAt: Date?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public let lastUpdatedAt: Date?
        /// The logging configuration.
        public let loggingConfig: LoggingConfig?
        /// The maximum job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        public let maxJobDurationInSeconds: Int64?
        /// The name of the simulation job.
        public let name: String?
        /// The network interface information for the simulation job.
        public let networkInterface: NetworkInterface?
        /// Location for output files generated by the simulation job.
        public let outputLocation: OutputLocation?
        /// A list of robot applications.
        public let robotApplications: [RobotApplicationConfig]?
        /// A list of simulation applications.
        public let simulationApplications: [SimulationApplicationConfig]?
        /// The simulation job execution duration in milliseconds.
        public let simulationTimeMillis: Int64?
        /// The status of the simulation job.
        public let status: SimulationJobStatus?
        /// The list of all tags added to the specified simulation job.
        public let tags: [String: String]?
        /// The VPC configuration.
        public let vpcConfig: VPCConfigResponse?

        public init(arn: String? = nil, clientRequestToken: String? = nil, compute: ComputeResponse? = nil, dataSources: [DataSource]? = nil, failureBehavior: FailureBehavior? = nil, failureCode: SimulationJobErrorCode? = nil, failureReason: String? = nil, iamRole: String? = nil, lastStartedAt: Date? = nil, lastUpdatedAt: Date? = nil, loggingConfig: LoggingConfig? = nil, maxJobDurationInSeconds: Int64? = nil, name: String? = nil, networkInterface: NetworkInterface? = nil, outputLocation: OutputLocation? = nil, robotApplications: [RobotApplicationConfig]? = nil, simulationApplications: [SimulationApplicationConfig]? = nil, simulationTimeMillis: Int64? = nil, status: SimulationJobStatus? = nil, tags: [String: String]? = nil, vpcConfig: VPCConfigResponse? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.iamRole = iamRole
            self.lastStartedAt = lastStartedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.name = name
            self.networkInterface = networkInterface
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.simulationTimeMillis = simulationTimeMillis
            self.status = status
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case compute = "compute"
            case dataSources = "dataSources"
            case failureBehavior = "failureBehavior"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case iamRole = "iamRole"
            case lastStartedAt = "lastStartedAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case loggingConfig = "loggingConfig"
            case maxJobDurationInSeconds = "maxJobDurationInSeconds"
            case name = "name"
            case networkInterface = "networkInterface"
            case outputLocation = "outputLocation"
            case robotApplications = "robotApplications"
            case simulationApplications = "simulationApplications"
            case simulationTimeMillis = "simulationTimeMillis"
            case status = "status"
            case tags = "tags"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct DescribeWorldExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world export job to describe.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct DescribeWorldExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world export job.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the world export job was created.
        public let createdAt: Date?
        /// The failure code of the world export job if it failed:  InternalServiceError  Internal service error.  LimitExceeded  The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.   ResourceNotFound  The specified resource could not be found.   RequestThrottled  The request was throttled.  InvalidInput  An input parameter in the request is not valid.
        public let failureCode: WorldExportJobErrorCode?
        /// The reason why the world export job failed.
        public let failureReason: String?
        /// The IAM role that the world export process uses to access the Amazon S3 bucket and put the export.
        public let iamRole: String?
        public let outputLocation: OutputLocation?
        /// The status of the world export job.  Pending  The world export job request is pending.  Running  The world export job is running.   Completed  The world export job completed.   Failed  The world export job failed. See failureCode and failureReason for more information.   Canceled  The world export job was cancelled.  Canceling  The world export job is being cancelled.
        public let status: WorldExportJobStatus?
        /// A map that contains tag keys and tag values that are attached to the world export job.
        public let tags: [String: String]?
        /// A list of Amazon Resource Names (arns) that correspond to worlds to be exported.
        public let worlds: [String]?

        public init(arn: String? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, failureCode: WorldExportJobErrorCode? = nil, failureReason: String? = nil, iamRole: String? = nil, outputLocation: OutputLocation? = nil, status: WorldExportJobStatus? = nil, tags: [String: String]? = nil, worlds: [String]? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.iamRole = iamRole
            self.outputLocation = outputLocation
            self.status = status
            self.tags = tags
            self.worlds = worlds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case iamRole = "iamRole"
            case outputLocation = "outputLocation"
            case status = "status"
            case tags = "tags"
            case worlds = "worlds"
        }
    }

    public struct DescribeWorldGenerationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world generation job to describe.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct DescribeWorldGenerationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world generation job.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the world generation job was created.
        public let createdAt: Date?
        /// The failure code of the world generation job if it failed:  InternalServiceError  Internal service error.  LimitExceeded  The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.   ResourceNotFound  The specified resource could not be found.   RequestThrottled  The request was throttled.  InvalidInput  An input parameter in the request is not valid.
        public let failureCode: WorldGenerationJobErrorCode?
        /// The reason why the world generation job failed.
        public let failureReason: String?
        /// Summary information about finished worlds.
        public let finishedWorldsSummary: FinishedWorldsSummary?
        /// The status of the world generation job:  Pending  The world generation job request is pending.  Running  The world generation job is running.   Completed  The world generation job completed.   Failed  The world generation job failed. See failureCode for more information.   PartialFailed  Some worlds did not generate.  Canceled  The world generation job was cancelled.  Canceling  The world generation job is being cancelled.
        public let status: WorldGenerationJobStatus?
        /// A map that contains tag keys and tag values that are attached to the world generation job.
        public let tags: [String: String]?
        /// The Amazon Resource Name (arn) of the world template.
        public let template: String?
        /// Information about the world count.
        public let worldCount: WorldCount?
        /// A map that contains tag keys and tag values that are attached to the generated worlds.
        public let worldTags: [String: String]?

        public init(arn: String? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, failureCode: WorldGenerationJobErrorCode? = nil, failureReason: String? = nil, finishedWorldsSummary: FinishedWorldsSummary? = nil, status: WorldGenerationJobStatus? = nil, tags: [String: String]? = nil, template: String? = nil, worldCount: WorldCount? = nil, worldTags: [String: String]? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.finishedWorldsSummary = finishedWorldsSummary
            self.status = status
            self.tags = tags
            self.template = template
            self.worldCount = worldCount
            self.worldTags = worldTags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case finishedWorldsSummary = "finishedWorldsSummary"
            case status = "status"
            case tags = "tags"
            case template = "template"
            case worldCount = "worldCount"
            case worldTags = "worldTags"
        }
    }

    public struct DescribeWorldRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world you want to describe.
        public let world: String

        public init(world: String) {
            self.world = world
        }

        public func validate(name: String) throws {
            try self.validate(self.world, name: "world", parent: name, max: 1224)
            try self.validate(self.world, name: "world", parent: name, min: 1)
            try self.validate(self.world, name: "world", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case world = "world"
        }
    }

    public struct DescribeWorldResponse: AWSDecodableShape {
        /// The Amazon Resource Name (arn) of the world.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the world was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (arn) of the world generation job that generated the world.
        public let generationJob: String?
        /// A map that contains tag keys and tag values that are attached to the world.
        public let tags: [String: String]?
        /// The world template.
        public let template: String?
        /// Returns the JSON formatted string that describes the contents of your world.
        public let worldDescriptionBody: String?

        public init(arn: String? = nil, createdAt: Date? = nil, generationJob: String? = nil, tags: [String: String]? = nil, template: String? = nil, worldDescriptionBody: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.generationJob = generationJob
            self.tags = tags
            self.template = template
            self.worldDescriptionBody = worldDescriptionBody
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case generationJob = "generationJob"
            case tags = "tags"
            case template = "template"
            case worldDescriptionBody = "worldDescriptionBody"
        }
    }

    public struct DescribeWorldTemplateRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world template you want to describe.
        public let template: String

        public init(template: String) {
            self.template = template
        }

        public func validate(name: String) throws {
            try self.validate(self.template, name: "template", parent: name, max: 1224)
            try self.validate(self.template, name: "template", parent: name, min: 1)
            try self.validate(self.template, name: "template", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case template = "template"
        }
    }

    public struct DescribeWorldTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world template.
        public let arn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the world template was created.
        public let createdAt: Date?
        /// The time, in milliseconds since the epoch, when the world template was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the world template.
        public let name: String?
        /// A map that contains tag keys and tag values that are attached to the world template.
        public let tags: [String: String]?
        /// The version of the world template that you're using.
        public let version: String?

        public init(arn: String? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, tags: [String: String]? = nil, version: String? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct Environment: AWSEncodableShape & AWSDecodableShape {
        /// The Docker image URI for either your robot or simulation applications.
        public let uri: String?

        public init(uri: String? = nil) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct FailedCreateSimulationJobRequest: AWSDecodableShape {
        /// The time, in milliseconds since the epoch, when the simulation job batch failed.
        public let failedAt: Date?
        /// The failure code.
        public let failureCode: SimulationJobErrorCode?
        /// The failure reason of the simulation job request.
        public let failureReason: String?
        /// The simulation job request.
        public let request: SimulationJobRequest?

        public init(failedAt: Date? = nil, failureCode: SimulationJobErrorCode? = nil, failureReason: String? = nil, request: SimulationJobRequest? = nil) {
            self.failedAt = failedAt
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.request = request
        }

        private enum CodingKeys: String, CodingKey {
            case failedAt = "failedAt"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case request = "request"
        }
    }

    public struct FailureSummary: AWSDecodableShape {
        /// The worlds that failed.
        public let failures: [WorldFailure]?
        /// The total number of failures.
        public let totalFailureCount: Int?

        public init(failures: [WorldFailure]? = nil, totalFailureCount: Int? = nil) {
            self.failures = failures
            self.totalFailureCount = totalFailureCount
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "failures"
            case totalFailureCount = "totalFailureCount"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter.
        public let name: String?
        /// A list of values.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct FinishedWorldsSummary: AWSDecodableShape {
        /// Information about worlds that failed.
        public let failureSummary: FailureSummary?
        /// The total number of finished worlds.
        public let finishedCount: Int?
        /// A list of worlds that succeeded.
        public let succeededWorlds: [String]?

        public init(failureSummary: FailureSummary? = nil, finishedCount: Int? = nil, succeededWorlds: [String]? = nil) {
            self.failureSummary = failureSummary
            self.finishedCount = finishedCount
            self.succeededWorlds = succeededWorlds
        }

        private enum CodingKeys: String, CodingKey {
            case failureSummary = "failureSummary"
            case finishedCount = "finishedCount"
            case succeededWorlds = "succeededWorlds"
        }
    }

    public struct Fleet: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public let lastDeploymentJob: String?
        /// The status of the last fleet deployment.
        public let lastDeploymentStatus: DeploymentStatus?
        /// The time of the last deployment.
        public let lastDeploymentTime: Date?
        /// The name of the fleet.
        public let name: String?

        public init(arn: String? = nil, createdAt: Date? = nil, lastDeploymentJob: String? = nil, lastDeploymentStatus: DeploymentStatus? = nil, lastDeploymentTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentStatus = lastDeploymentStatus
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastDeploymentJob = "lastDeploymentJob"
            case lastDeploymentStatus = "lastDeploymentStatus"
            case lastDeploymentTime = "lastDeploymentTime"
            case name = "name"
        }
    }

    public struct GetWorldTemplateBodyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (arn) of the world generator job.
        public let generationJob: String?
        /// The Amazon Resource Name (arn) of the world template.
        public let template: String?

        public init(generationJob: String? = nil, template: String? = nil) {
            self.generationJob = generationJob
            self.template = template
        }

        public func validate(name: String) throws {
            try self.validate(self.generationJob, name: "generationJob", parent: name, max: 1224)
            try self.validate(self.generationJob, name: "generationJob", parent: name, min: 1)
            try self.validate(self.generationJob, name: "generationJob", parent: name, pattern: "^arn:")
            try self.validate(self.template, name: "template", parent: name, max: 1224)
            try self.validate(self.template, name: "template", parent: name, min: 1)
            try self.validate(self.template, name: "template", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case generationJob = "generationJob"
            case template = "template"
        }
    }

    public struct GetWorldTemplateBodyResponse: AWSDecodableShape {
        /// The world template body.
        public let templateBody: String?

        public init(templateBody: String? = nil) {
            self.templateBody = templateBody
        }

        private enum CodingKeys: String, CodingKey {
            case templateBody = "templateBody"
        }
    }

    public struct LaunchConfig: AWSEncodableShape & AWSDecodableShape {
        /// If you've specified General as the value for your RobotSoftwareSuite, you can use this field to specify a list of commands for your container image. If you've specified SimulationRuntime as the value for your SimulationSoftwareSuite, you can use this field to specify a list of commands for your container image.
        public let command: [String]?
        /// The environment variables for the application launch.
        public let environmentVariables: [String: String]?
        /// The launch file name.
        public let launchFile: String?
        /// The package name.
        public let packageName: String?
        /// The port forwarding configuration.
        public let portForwardingConfig: PortForwardingConfig?
        /// Boolean indicating whether a streaming session will be configured for the application. If True, AWS RoboMaker will configure a connection so you can interact with your application as it is running in the simulation. You must configure and launch the component. It must have a graphical user interface.
        public let streamUI: Bool?

        public init(command: [String]? = nil, environmentVariables: [String: String]? = nil, launchFile: String? = nil, packageName: String? = nil, portForwardingConfig: PortForwardingConfig? = nil, streamUI: Bool? = nil) {
            self.command = command
            self.environmentVariables = environmentVariables
            self.launchFile = launchFile
            self.packageName = packageName
            self.portForwardingConfig = portForwardingConfig
            self.streamUI = streamUI
        }

        public func validate(name: String) throws {
            try self.command?.forEach {
                try validate($0, name: "command[]", parent: name, max: 255)
                try validate($0, name: "command[]", parent: name, min: 1)
                try validate($0, name: "command[]", parent: name, pattern: "^.+$")
            }
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 1024)
                try validate($0.key, name: "environmentVariables.key", parent: name, min: 1)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^[A-Z_][A-Z0-9_]*$")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.validate(self.environmentVariables, name: "environmentVariables", parent: name, max: 20)
            try self.validate(self.launchFile, name: "launchFile", parent: name, max: 1024)
            try self.validate(self.launchFile, name: "launchFile", parent: name, min: 1)
            try self.validate(self.launchFile, name: "launchFile", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.validate(self.packageName, name: "packageName", parent: name, max: 1024)
            try self.validate(self.packageName, name: "packageName", parent: name, min: 1)
            try self.validate(self.packageName, name: "packageName", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.portForwardingConfig?.validate(name: "\(name).portForwardingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case command = "command"
            case environmentVariables = "environmentVariables"
            case launchFile = "launchFile"
            case packageName = "packageName"
            case portForwardingConfig = "portForwardingConfig"
            case streamUI = "streamUI"
        }
    }

    public struct ListDeploymentJobsRequest: AWSEncodableShape {
        /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status InProgress or the status Pending.
        public let filters: [Filter]?
        /// When this parameter is used, ListDeploymentJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListDeploymentJobs request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListDeploymentJobs returns up to 200 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentJobsResponse: AWSDecodableShape {
        /// A list of deployment jobs that meet the criteria of the request.
        public let deploymentJobs: [DeploymentJob]?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListDeploymentJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(deploymentJobs: [DeploymentJob]? = nil, nextToken: String? = nil) {
            self.deploymentJobs = deploymentJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentJobs = "deploymentJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListFleetsRequest: AWSEncodableShape {
        /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
        public let filters: [Filter]?
        /// When this parameter is used, ListFleets only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListFleets request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListFleets returns up to 200 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.   This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFleetsResponse: AWSDecodableShape {
        /// A list of fleet details meeting the request criteria.
        public let fleetDetails: [Fleet]?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListFleets again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(fleetDetails: [Fleet]? = nil, nextToken: String? = nil) {
            self.fleetDetails = fleetDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleetDetails = "fleetDetails"
            case nextToken = "nextToken"
        }
    }

    public struct ListRobotApplicationsRequest: AWSEncodableShape {
        /// Optional filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
        public let filters: [Filter]?
        /// When this parameter is used, ListRobotApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobotApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListRobotApplications returns up to 100 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// The version qualifier of the robot application.
        public let versionQualifier: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, versionQualifier: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.versionQualifier = versionQualifier
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
            try self.validate(self.versionQualifier, name: "versionQualifier", parent: name, max: 255)
            try self.validate(self.versionQualifier, name: "versionQualifier", parent: name, min: 1)
            try self.validate(self.versionQualifier, name: "versionQualifier", parent: name, pattern: "^ALL$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case versionQualifier = "versionQualifier"
        }
    }

    public struct ListRobotApplicationsResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobotApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// A list of robot application summaries that meet the criteria of the request.
        public let robotApplicationSummaries: [RobotApplicationSummary]?

        public init(nextToken: String? = nil, robotApplicationSummaries: [RobotApplicationSummary]? = nil) {
            self.nextToken = nextToken
            self.robotApplicationSummaries = robotApplicationSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case robotApplicationSummaries = "robotApplicationSummaries"
        }
    }

    public struct ListRobotsRequest: AWSEncodableShape {
        /// Optional filters to limit results. The filter names status and fleetName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Registered or the status Available.
        public let filters: [Filter]?
        /// When this parameter is used, ListRobots only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListRobots request with the returned nextToken value. This value can be between 1 and 200. If this parameter is not used, then ListRobots returns up to 200 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRobotsResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListRobots again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// A list of robots that meet the criteria of the request.
        public let robots: [Robot]?

        public init(nextToken: String? = nil, robots: [Robot]? = nil) {
            self.nextToken = nextToken
            self.robots = robots
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case robots = "robots"
        }
    }

    public struct ListSimulationApplicationsRequest: AWSEncodableShape {
        /// Optional list of filters to limit results. The filter name name is supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters.
        public let filters: [Filter]?
        /// When this parameter is used, ListSimulationApplications only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationApplications request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListSimulationApplications returns up to 100 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// The version qualifier of the simulation application.
        public let versionQualifier: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, versionQualifier: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.versionQualifier = versionQualifier
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
            try self.validate(self.versionQualifier, name: "versionQualifier", parent: name, max: 255)
            try self.validate(self.versionQualifier, name: "versionQualifier", parent: name, min: 1)
            try self.validate(self.versionQualifier, name: "versionQualifier", parent: name, pattern: "^ALL$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case versionQualifier = "versionQualifier"
        }
    }

    public struct ListSimulationApplicationsResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationApplications again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// A list of simulation application summaries that meet the criteria of the request.
        public let simulationApplicationSummaries: [SimulationApplicationSummary]?

        public init(nextToken: String? = nil, simulationApplicationSummaries: [SimulationApplicationSummary]? = nil) {
            self.nextToken = nextToken
            self.simulationApplicationSummaries = simulationApplicationSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case simulationApplicationSummaries = "simulationApplicationSummaries"
        }
    }

    public struct ListSimulationJobBatchesRequest: AWSEncodableShape {
        /// Optional filters to limit results.
        public let filters: [Filter]?
        /// When this parameter is used, ListSimulationJobBatches only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobBatches request with the returned nextToken value.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSimulationJobBatchesResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobBatches again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// A list of simulation job batch summaries.
        public let simulationJobBatchSummaries: [SimulationJobBatchSummary]?

        public init(nextToken: String? = nil, simulationJobBatchSummaries: [SimulationJobBatchSummary]? = nil) {
            self.nextToken = nextToken
            self.simulationJobBatchSummaries = simulationJobBatchSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case simulationJobBatchSummaries = "simulationJobBatchSummaries"
        }
    }

    public struct ListSimulationJobsRequest: AWSEncodableShape {
        /// Optional filters to limit results. The filter names status and simulationApplicationName and robotApplicationName are supported. When filtering, you must use the complete value of the filtered item. You can use up to three filters, but they must be for the same named item. For example, if you are looking for items with the status Preparing or the status Running.
        public let filters: [Filter]?
        /// When this parameter is used, ListSimulationJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListSimulationJobs request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then ListSimulationJobs returns up to 1000 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSimulationJobsResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListSimulationJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// A list of simulation job summaries that meet the criteria of the request.
        public let simulationJobSummaries: [SimulationJobSummary]

        public init(nextToken: String? = nil, simulationJobSummaries: [SimulationJobSummary]) {
            self.nextToken = nextToken
            self.simulationJobSummaries = simulationJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case simulationJobSummaries = "simulationJobSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The AWS RoboMaker Amazon Resource Name (ARN) with tags to be listed.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of all tags added to the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorldExportJobsRequest: AWSEncodableShape {
        /// Optional filters to limit results. You can use generationJobId and templateId.
        public let filters: [Filter]?
        /// When this parameter is used, ListWorldExportJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldExportJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldExportJobs returns up to 100 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobs again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorldExportJobsResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldExportJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// Summary information for world export jobs.
        public let worldExportJobSummaries: [WorldExportJobSummary]

        public init(nextToken: String? = nil, worldExportJobSummaries: [WorldExportJobSummary]) {
            self.nextToken = nextToken
            self.worldExportJobSummaries = worldExportJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case worldExportJobSummaries = "worldExportJobSummaries"
        }
    }

    public struct ListWorldGenerationJobsRequest: AWSEncodableShape {
        /// Optional filters to limit results. You can use status and templateId.
        public let filters: [Filter]?
        /// When this parameter is used, ListWorldGeneratorJobs only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldGeneratorJobs request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldGeneratorJobs returns up to 100 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGenerationJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorldGenerationJobsResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldGeneratorJobsRequest again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// Summary information for world generator jobs.
        public let worldGenerationJobSummaries: [WorldGenerationJobSummary]

        public init(nextToken: String? = nil, worldGenerationJobSummaries: [WorldGenerationJobSummary]) {
            self.nextToken = nextToken
            self.worldGenerationJobSummaries = worldGenerationJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case worldGenerationJobSummaries = "worldGenerationJobSummaries"
        }
    }

    public struct ListWorldTemplatesRequest: AWSEncodableShape {
        /// When this parameter is used, ListWorldTemplates only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorldTemplates request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorldTemplates returns up to 100 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorldTemplatesResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorldTemplates again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// Summary information for templates.
        public let templateSummaries: [TemplateSummary]?

        public init(nextToken: String? = nil, templateSummaries: [TemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.templateSummaries = templateSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case templateSummaries = "templateSummaries"
        }
    }

    public struct ListWorldsRequest: AWSEncodableShape {
        /// Optional filters to limit results. You can use status.
        public let filters: [Filter]?
        /// When this parameter is used, ListWorlds only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListWorlds request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListWorlds returns up to 100 results and a nextToken value if applicable.
        public let maxResults: Int?
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9_.\\-\\/+=]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorldsResponse: AWSDecodableShape {
        /// If the previous paginated request did not return all of the remaining results, the response object's nextToken parameter value is set to a token. To retrieve the next set of results, call ListWorlds again and assign that token to the request object's nextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
        public let nextToken: String?
        /// Summary information for worlds.
        public let worldSummaries: [WorldSummary]?

        public init(nextToken: String? = nil, worldSummaries: [WorldSummary]? = nil) {
            self.nextToken = nextToken
            self.worldSummaries = worldSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case worldSummaries = "worldSummaries"
        }
    }

    public struct LoggingConfig: AWSEncodableShape & AWSDecodableShape {
        /// A boolean indicating whether to record all ROS topics.  This API is no longer supported and will throw an error if used.
        public let recordAllRosTopics: Bool?

        public init() {
            self.recordAllRosTopics = nil
        }

        @available(*, deprecated, message: "Members recordAllRosTopics have been deprecated")
        public init(recordAllRosTopics: Bool? = nil) {
            self.recordAllRosTopics = recordAllRosTopics
        }

        private enum CodingKeys: String, CodingKey {
            case recordAllRosTopics = "recordAllRosTopics"
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The IPv4 address of the network interface within the subnet.
        public let privateIpAddress: String?
        /// The IPv4 public address of the network interface.
        public let publicIpAddress: String?

        public init(networkInterfaceId: String? = nil, privateIpAddress: String? = nil, publicIpAddress: String? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }

        private enum CodingKeys: String, CodingKey {
            case networkInterfaceId = "networkInterfaceId"
            case privateIpAddress = "privateIpAddress"
            case publicIpAddress = "publicIpAddress"
        }
    }

    public struct OutputLocation: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket for output.
        public let s3Bucket: String?
        /// The S3 folder in the s3Bucket where output files will be placed.
        public let s3Prefix: String?

        public init(s3Bucket: String? = nil, s3Prefix: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-z0-9][a-z0-9.\\-]*[a-z0-9]$")
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, max: 1024)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, min: 1)
            try self.validate(self.s3Prefix, name: "s3Prefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3Prefix = "s3Prefix"
        }
    }

    public struct PortForwardingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The port mappings for the configuration.
        public let portMappings: [PortMapping]?

        public init(portMappings: [PortMapping]? = nil) {
            self.portMappings = portMappings
        }

        public func validate(name: String) throws {
            try self.portMappings?.forEach {
                try $0.validate(name: "\(name).portMappings[]")
            }
            try self.validate(self.portMappings, name: "portMappings", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case portMappings = "portMappings"
        }
    }

    public struct PortMapping: AWSEncodableShape & AWSDecodableShape {
        /// The port number on the application.
        public let applicationPort: Int
        /// A Boolean indicating whether to enable this port mapping on public IP.
        public let enableOnPublicIp: Bool?
        /// The port number on the simulation job instance to use as a remote connection point.
        public let jobPort: Int

        public init(applicationPort: Int, enableOnPublicIp: Bool? = nil, jobPort: Int) {
            self.applicationPort = applicationPort
            self.enableOnPublicIp = enableOnPublicIp
            self.jobPort = jobPort
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationPort, name: "applicationPort", parent: name, max: 65535)
            try self.validate(self.applicationPort, name: "applicationPort", parent: name, min: 1024)
            try self.validate(self.jobPort, name: "jobPort", parent: name, max: 65535)
            try self.validate(self.jobPort, name: "jobPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationPort = "applicationPort"
            case enableOnPublicIp = "enableOnPublicIp"
            case jobPort = "jobPort"
        }
    }

    public struct ProgressDetail: AWSDecodableShape {
        /// The current progress status.  Validating  Validating the deployment.  DownloadingExtracting  Downloading and extracting the bundle on the robot.  ExecutingPreLaunch  Executing pre-launch script(s) if provided.  Launching  Launching the robot application.  ExecutingPostLaunch  Executing post-launch script(s) if provided.  Finished  Deployment is complete.
        public let currentProgress: RobotDeploymentStep?
        /// Estimated amount of time in seconds remaining in the step. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public let estimatedTimeRemainingSeconds: Int?
        /// Precentage of the step that is done. This currently only applies to the Downloading/Extracting step of the deployment. It is empty for other steps.
        public let percentDone: Float?
        /// The Amazon Resource Name (ARN) of the deployment job.
        public let targetResource: String?

        public init(currentProgress: RobotDeploymentStep? = nil, estimatedTimeRemainingSeconds: Int? = nil, percentDone: Float? = nil, targetResource: String? = nil) {
            self.currentProgress = currentProgress
            self.estimatedTimeRemainingSeconds = estimatedTimeRemainingSeconds
            self.percentDone = percentDone
            self.targetResource = targetResource
        }

        private enum CodingKeys: String, CodingKey {
            case currentProgress = "currentProgress"
            case estimatedTimeRemainingSeconds = "estimatedTimeRemainingSeconds"
            case percentDone = "percentDone"
            case targetResource = "targetResource"
        }
    }

    public struct RegisterRobotRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String
        /// The Amazon Resource Name (ARN) of the robot.
        public let robot: String

        public init(fleet: String, robot: String) {
            self.fleet = fleet
            self.robot = robot
        }

        public func validate(name: String) throws {
            try self.validate(self.fleet, name: "fleet", parent: name, max: 1224)
            try self.validate(self.fleet, name: "fleet", parent: name, min: 1)
            try self.validate(self.fleet, name: "fleet", parent: name, pattern: "^arn:")
            try self.validate(self.robot, name: "robot", parent: name, max: 1224)
            try self.validate(self.robot, name: "robot", parent: name, min: 1)
            try self.validate(self.robot, name: "robot", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "fleet"
            case robot = "robot"
        }
    }

    public struct RegisterRobotResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the fleet that the robot will join.
        public let fleet: String?
        /// Information about the robot registration.
        public let robot: String?

        public init(fleet: String? = nil, robot: String? = nil) {
            self.fleet = fleet
            self.robot = robot
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "fleet"
            case robot = "robot"
        }
    }

    public struct RenderingEngine: AWSEncodableShape & AWSDecodableShape {
        /// The name of the rendering engine.
        public let name: RenderingEngineType?
        /// The version of the rendering engine.
        public let version: String?

        public init(name: RenderingEngineType? = nil, version: String? = nil) {
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.version, name: "version", parent: name, max: 4)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^1.x$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case version = "version"
        }
    }

    public struct RestartSimulationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public let job: String

        public init(job: String) {
            self.job = job
        }

        public func validate(name: String) throws {
            try self.validate(self.job, name: "job", parent: name, max: 1224)
            try self.validate(self.job, name: "job", parent: name, min: 1)
            try self.validate(self.job, name: "job", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct RestartSimulationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Robot: AWSDecodableShape {
        /// The architecture of the robot.
        public let architecture: Architecture?
        /// The Amazon Resource Name (ARN) of the robot.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the robot was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleetArn: String?
        /// The Greengrass group associated with the robot.
        public let greenGrassGroupId: String?
        /// The Amazon Resource Name (ARN) of the last deployment job.
        public let lastDeploymentJob: String?
        /// The time of the last deployment.
        public let lastDeploymentTime: Date?
        /// The name of the robot.
        public let name: String?
        /// The status of the robot.
        public let status: RobotStatus?

        public init(architecture: Architecture? = nil, arn: String? = nil, createdAt: Date? = nil, fleetArn: String? = nil, greenGrassGroupId: String? = nil, lastDeploymentJob: String? = nil, lastDeploymentTime: Date? = nil, name: String? = nil, status: RobotStatus? = nil) {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.fleetArn = fleetArn
            self.greenGrassGroupId = greenGrassGroupId
            self.lastDeploymentJob = lastDeploymentJob
            self.lastDeploymentTime = lastDeploymentTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case arn = "arn"
            case createdAt = "createdAt"
            case fleetArn = "fleetArn"
            case greenGrassGroupId = "greenGrassGroupId"
            case lastDeploymentJob = "lastDeploymentJob"
            case lastDeploymentTime = "lastDeploymentTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct RobotApplicationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The application information for the robot application.
        public let application: String
        /// The version of the robot application.
        public let applicationVersion: String?
        /// The launch configuration for the robot application.
        public let launchConfig: LaunchConfig
        /// Information about tools configured for the robot application.
        public let tools: [Tool]?
        /// The upload configurations for the robot application.
        public let uploadConfigurations: [UploadConfiguration]?
        /// A Boolean indicating whether to use default robot application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False.  This API is no longer supported and will throw an error if used.
        public let useDefaultTools: Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation.  This API is no longer supported and will throw an error if used.
        public let useDefaultUploadConfigurations: Bool?

        public init(application: String, applicationVersion: String? = nil, launchConfig: LaunchConfig, tools: [Tool]? = nil, uploadConfigurations: [UploadConfiguration]? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = nil
            self.useDefaultUploadConfigurations = nil
        }

        @available(*, deprecated, message: "Members useDefaultTools, useDefaultUploadConfigurations have been deprecated")
        public init(application: String, applicationVersion: String? = nil, launchConfig: LaunchConfig, tools: [Tool]? = nil, uploadConfigurations: [UploadConfiguration]? = nil, useDefaultTools: Bool? = nil, useDefaultUploadConfigurations: Bool? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, max: 255)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, pattern: "^(\\$LATEST)|[0-9]*$")
            try self.launchConfig.validate(name: "\(name).launchConfig")
            try self.tools?.forEach {
                try $0.validate(name: "\(name).tools[]")
            }
            try self.validate(self.tools, name: "tools", parent: name, max: 10)
            try self.uploadConfigurations?.forEach {
                try $0.validate(name: "\(name).uploadConfigurations[]")
            }
            try self.validate(self.uploadConfigurations, name: "uploadConfigurations", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case applicationVersion = "applicationVersion"
            case launchConfig = "launchConfig"
            case tools = "tools"
            case uploadConfigurations = "uploadConfigurations"
            case useDefaultTools = "useDefaultTools"
            case useDefaultUploadConfigurations = "useDefaultUploadConfigurations"
        }
    }

    public struct RobotApplicationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the robot.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the robot application.
        public let name: String?
        /// Information about a robot software suite (ROS distribution).
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The version of the robot application.
        public let version: String?

        public init(arn: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, version: String? = nil) {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case version = "version"
        }
    }

    public struct RobotDeployment: AWSDecodableShape {
        /// The robot deployment Amazon Resource Name (ARN).
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the deployment finished.
        public let deploymentFinishTime: Date?
        /// The time, in milliseconds since the epoch, when the deployment was started.
        public let deploymentStartTime: Date?
        /// The robot deployment failure code.
        public let failureCode: DeploymentJobErrorCode?
        /// A short description of the reason why the robot deployment failed.
        public let failureReason: String?
        /// Information about how the deployment is progressing.
        public let progressDetail: ProgressDetail?
        /// The status of the robot deployment.
        public let status: RobotStatus?

        public init(arn: String? = nil, deploymentFinishTime: Date? = nil, deploymentStartTime: Date? = nil, failureCode: DeploymentJobErrorCode? = nil, failureReason: String? = nil, progressDetail: ProgressDetail? = nil, status: RobotStatus? = nil) {
            self.arn = arn
            self.deploymentFinishTime = deploymentFinishTime
            self.deploymentStartTime = deploymentStartTime
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.progressDetail = progressDetail
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case deploymentFinishTime = "deploymentFinishTime"
            case deploymentStartTime = "deploymentStartTime"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case progressDetail = "progressDetail"
            case status = "status"
        }
    }

    public struct RobotSoftwareSuite: AWSEncodableShape & AWSDecodableShape {
        /// The name of the robot software suite (ROS distribution).
        public let name: RobotSoftwareSuiteType?
        /// The version of the robot software suite (ROS distribution).
        public let version: RobotSoftwareSuiteVersionType?

        public init(name: RobotSoftwareSuiteType? = nil, version: RobotSoftwareSuiteVersionType? = nil) {
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case version = "version"
        }
    }

    public struct S3KeyOutput: AWSDecodableShape {
        /// The etag for the object.
        public let etag: String?
        /// The S3 key.
        public let s3Key: String?

        public init(etag: String? = nil, s3Key: String? = nil) {
            self.etag = etag
            self.s3Key = s3Key
        }

        private enum CodingKeys: String, CodingKey {
            case etag = "etag"
            case s3Key = "s3Key"
        }
    }

    public struct S3Object: AWSEncodableShape & AWSDecodableShape {
        /// The bucket containing the object.
        public let bucket: String
        /// The etag of the object.
        public let etag: String?
        /// The key of the object.
        public let key: String

        public init(bucket: String, etag: String? = nil, key: String) {
            self.bucket = bucket
            self.etag = etag
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[a-z0-9][a-z0-9.\\-]*[a-z0-9]$")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case etag = "etag"
            case key = "key"
        }
    }

    public struct SimulationApplicationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The application information for the simulation application.
        public let application: String
        /// The version of the simulation application.
        public let applicationVersion: String?
        /// The launch configuration for the simulation application.
        public let launchConfig: LaunchConfig
        /// Information about tools configured for the simulation application.
        public let tools: [Tool]?
        /// Information about upload configurations for the simulation application.
        public let uploadConfigurations: [UploadConfiguration]?
        /// A Boolean indicating whether to use default simulation application tools. The default tools are rviz, rqt, terminal and rosbag record. The default is False.  This API is no longer supported and will throw an error if used.
        public let useDefaultTools: Bool?
        /// A Boolean indicating whether to use default upload configurations. By default, .ros and .gazebo files are uploaded when the application terminates and all ROS topics will be recorded. If you set this value, you must specify an outputLocation.  This API is no longer supported and will throw an error if used.
        public let useDefaultUploadConfigurations: Bool?
        /// A list of world configurations.
        public let worldConfigs: [WorldConfig]?

        public init(application: String, applicationVersion: String? = nil, launchConfig: LaunchConfig, tools: [Tool]? = nil, uploadConfigurations: [UploadConfiguration]? = nil, worldConfigs: [WorldConfig]? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = nil
            self.useDefaultUploadConfigurations = nil
            self.worldConfigs = worldConfigs
        }

        @available(*, deprecated, message: "Members useDefaultTools, useDefaultUploadConfigurations have been deprecated")
        public init(application: String, applicationVersion: String? = nil, launchConfig: LaunchConfig, tools: [Tool]? = nil, uploadConfigurations: [UploadConfiguration]? = nil, useDefaultTools: Bool? = nil, useDefaultUploadConfigurations: Bool? = nil, worldConfigs: [WorldConfig]? = nil) {
            self.application = application
            self.applicationVersion = applicationVersion
            self.launchConfig = launchConfig
            self.tools = tools
            self.uploadConfigurations = uploadConfigurations
            self.useDefaultTools = useDefaultTools
            self.useDefaultUploadConfigurations = useDefaultUploadConfigurations
            self.worldConfigs = worldConfigs
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, max: 255)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, pattern: "^(\\$LATEST)|[0-9]*$")
            try self.launchConfig.validate(name: "\(name).launchConfig")
            try self.tools?.forEach {
                try $0.validate(name: "\(name).tools[]")
            }
            try self.validate(self.tools, name: "tools", parent: name, max: 10)
            try self.uploadConfigurations?.forEach {
                try $0.validate(name: "\(name).uploadConfigurations[]")
            }
            try self.validate(self.uploadConfigurations, name: "uploadConfigurations", parent: name, max: 10)
            try self.worldConfigs?.forEach {
                try $0.validate(name: "\(name).worldConfigs[]")
            }
            try self.validate(self.worldConfigs, name: "worldConfigs", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case applicationVersion = "applicationVersion"
            case launchConfig = "launchConfig"
            case tools = "tools"
            case uploadConfigurations = "uploadConfigurations"
            case useDefaultTools = "useDefaultTools"
            case useDefaultUploadConfigurations = "useDefaultUploadConfigurations"
            case worldConfigs = "worldConfigs"
        }
    }

    public struct SimulationApplicationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the simulation application.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the simulation application.
        public let name: String?
        /// Information about a robot software suite (ROS distribution).
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// Information about a simulation software suite.
        public let simulationSoftwareSuite: SimulationSoftwareSuite?
        /// The version of the simulation application.
        public let version: String?

        public init(arn: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, simulationSoftwareSuite: SimulationSoftwareSuite? = nil, version: String? = nil) {
            self.arn = arn
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case simulationSoftwareSuite = "simulationSoftwareSuite"
            case version = "version"
        }
    }

    public struct SimulationJob: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public let arn: String?
        /// A unique identifier for this SimulationJob request.
        public let clientRequestToken: String?
        /// Compute information for the simulation job
        public let compute: ComputeResponse?
        /// The data sources for the simulation job.
        public let dataSources: [DataSource]?
        /// The failure behavior the simulation job.  Continue  Leaves the host running for its maximum timeout duration after a 4XX error code.  Fail  Stop the simulation job and terminate the instance.
        public let failureBehavior: FailureBehavior?
        /// The failure code of the simulation job if it failed.
        public let failureCode: SimulationJobErrorCode?
        /// The reason why the simulation job failed.
        public let failureReason: String?
        /// The IAM role that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public let iamRole: String?
        /// The time, in milliseconds since the epoch, when the simulation job was last started.
        public let lastStartedAt: Date?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public let lastUpdatedAt: Date?
        /// The logging configuration.
        public let loggingConfig: LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        public let maxJobDurationInSeconds: Int64?
        /// The name of the simulation job.
        public let name: String?
        /// Information about a network interface.
        public let networkInterface: NetworkInterface?
        /// Location for output files generated by the simulation job.
        public let outputLocation: OutputLocation?
        /// A list of robot applications.
        public let robotApplications: [RobotApplicationConfig]?
        /// A list of simulation applications.
        public let simulationApplications: [SimulationApplicationConfig]?
        /// The simulation job execution duration in milliseconds.
        public let simulationTimeMillis: Int64?
        /// Status of the simulation job.
        public let status: SimulationJobStatus?
        /// A map that contains tag keys and tag values that are attached to the simulation job.
        public let tags: [String: String]?
        /// VPC configuration information.
        public let vpcConfig: VPCConfigResponse?

        public init(arn: String? = nil, clientRequestToken: String? = nil, compute: ComputeResponse? = nil, dataSources: [DataSource]? = nil, failureBehavior: FailureBehavior? = nil, failureCode: SimulationJobErrorCode? = nil, failureReason: String? = nil, iamRole: String? = nil, lastStartedAt: Date? = nil, lastUpdatedAt: Date? = nil, loggingConfig: LoggingConfig? = nil, maxJobDurationInSeconds: Int64? = nil, name: String? = nil, networkInterface: NetworkInterface? = nil, outputLocation: OutputLocation? = nil, robotApplications: [RobotApplicationConfig]? = nil, simulationApplications: [SimulationApplicationConfig]? = nil, simulationTimeMillis: Int64? = nil, status: SimulationJobStatus? = nil, tags: [String: String]? = nil, vpcConfig: VPCConfigResponse? = nil) {
            self.arn = arn
            self.clientRequestToken = clientRequestToken
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.iamRole = iamRole
            self.lastStartedAt = lastStartedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.name = name
            self.networkInterface = networkInterface
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.simulationTimeMillis = simulationTimeMillis
            self.status = status
            self.tags = tags
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientRequestToken = "clientRequestToken"
            case compute = "compute"
            case dataSources = "dataSources"
            case failureBehavior = "failureBehavior"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case iamRole = "iamRole"
            case lastStartedAt = "lastStartedAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case loggingConfig = "loggingConfig"
            case maxJobDurationInSeconds = "maxJobDurationInSeconds"
            case name = "name"
            case networkInterface = "networkInterface"
            case outputLocation = "outputLocation"
            case robotApplications = "robotApplications"
            case simulationApplications = "simulationApplications"
            case simulationTimeMillis = "simulationTimeMillis"
            case status = "status"
            case tags = "tags"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct SimulationJobBatchSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was created.
        public let createdAt: Date?
        /// The number of created simulation job requests.
        public let createdRequestCount: Int?
        /// The number of failed simulation job requests.
        public let failedRequestCount: Int?
        /// The time, in milliseconds since the epoch, when the simulation job batch was last updated.
        public let lastUpdatedAt: Date?
        /// The number of pending simulation job requests.
        public let pendingRequestCount: Int?
        /// The status of the simulation job batch.  Pending  The simulation job batch request is pending.  InProgress  The simulation job batch is in progress.   Failed  The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information.  Completed  The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed).   Canceled  The simulation batch job was cancelled.  Canceling  The simulation batch job is being cancelled.  Completing  The simulation batch job is completing.  TimingOut  The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut.   TimedOut  The simulation batch job timed out.
        public let status: SimulationJobBatchStatus?

        public init(arn: String? = nil, createdAt: Date? = nil, createdRequestCount: Int? = nil, failedRequestCount: Int? = nil, lastUpdatedAt: Date? = nil, pendingRequestCount: Int? = nil, status: SimulationJobBatchStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdRequestCount = createdRequestCount
            self.failedRequestCount = failedRequestCount
            self.lastUpdatedAt = lastUpdatedAt
            self.pendingRequestCount = pendingRequestCount
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdRequestCount = "createdRequestCount"
            case failedRequestCount = "failedRequestCount"
            case lastUpdatedAt = "lastUpdatedAt"
            case pendingRequestCount = "pendingRequestCount"
            case status = "status"
        }
    }

    public struct SimulationJobRequest: AWSEncodableShape & AWSDecodableShape {
        /// Compute information for the simulation job
        public let compute: Compute?
        /// Specify data sources to mount read-only files from S3 into your simulation. These files are available under /opt/robomaker/datasources/data_source_name.   There is a limit of 100 files and a combined size of 25GB for all DataSourceConfig objects.
        public let dataSources: [DataSourceConfig]?
        /// The failure behavior the simulation job.  Continue  Leaves the host running for its maximum timeout duration after a 4XX error code.  Fail  Stop the simulation job and terminate the instance.
        public let failureBehavior: FailureBehavior?
        /// The IAM role name that allows the simulation instance to call the AWS APIs that are specified in its associated policies on your behalf. This is how credentials are passed in to your simulation job.
        public let iamRole: String?
        public let loggingConfig: LoggingConfig?
        /// The maximum simulation job duration in seconds. The value must be 8 days (691,200 seconds) or less.
        public let maxJobDurationInSeconds: Int64
        public let outputLocation: OutputLocation?
        /// The robot applications to use in the simulation job.
        public let robotApplications: [RobotApplicationConfig]?
        /// The simulation applications to use in the simulation job.
        public let simulationApplications: [SimulationApplicationConfig]?
        /// A map that contains tag keys and tag values that are attached to the simulation job request.
        public let tags: [String: String]?
        /// A Boolean indicating whether to use default applications in the simulation job. Default applications include Gazebo, rqt, rviz and terminal access.
        public let useDefaultApplications: Bool?
        public let vpcConfig: VPCConfig?

        public init(compute: Compute? = nil, dataSources: [DataSourceConfig]? = nil, failureBehavior: FailureBehavior? = nil, iamRole: String? = nil, loggingConfig: LoggingConfig? = nil, maxJobDurationInSeconds: Int64, outputLocation: OutputLocation? = nil, robotApplications: [RobotApplicationConfig]? = nil, simulationApplications: [SimulationApplicationConfig]? = nil, tags: [String: String]? = nil, useDefaultApplications: Bool? = nil, vpcConfig: VPCConfig? = nil) {
            self.compute = compute
            self.dataSources = dataSources
            self.failureBehavior = failureBehavior
            self.iamRole = iamRole
            self.loggingConfig = loggingConfig
            self.maxJobDurationInSeconds = maxJobDurationInSeconds
            self.outputLocation = outputLocation
            self.robotApplications = robotApplications
            self.simulationApplications = simulationApplications
            self.tags = tags
            self.useDefaultApplications = useDefaultApplications
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.compute?.validate(name: "\(name).compute")
            try self.dataSources?.forEach {
                try $0.validate(name: "\(name).dataSources[]")
            }
            try self.validate(self.dataSources, name: "dataSources", parent: name, max: 6)
            try self.validate(self.dataSources, name: "dataSources", parent: name, min: 1)
            try self.validate(self.iamRole, name: "iamRole", parent: name, max: 255)
            try self.validate(self.iamRole, name: "iamRole", parent: name, min: 1)
            try self.validate(self.iamRole, name: "iamRole", parent: name, pattern: "^arn:aws:iam::\\w+:role/")
            try self.outputLocation?.validate(name: "\(name).outputLocation")
            try self.robotApplications?.forEach {
                try $0.validate(name: "\(name).robotApplications[]")
            }
            try self.validate(self.robotApplications, name: "robotApplications", parent: name, max: 1)
            try self.validate(self.robotApplications, name: "robotApplications", parent: name, min: 1)
            try self.simulationApplications?.forEach {
                try $0.validate(name: "\(name).simulationApplications[]")
            }
            try self.validate(self.simulationApplications, name: "simulationApplications", parent: name, max: 1)
            try self.validate(self.simulationApplications, name: "simulationApplications", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case compute = "compute"
            case dataSources = "dataSources"
            case failureBehavior = "failureBehavior"
            case iamRole = "iamRole"
            case loggingConfig = "loggingConfig"
            case maxJobDurationInSeconds = "maxJobDurationInSeconds"
            case outputLocation = "outputLocation"
            case robotApplications = "robotApplications"
            case simulationApplications = "simulationApplications"
            case tags = "tags"
            case useDefaultApplications = "useDefaultApplications"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct SimulationJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the simulation job.
        public let arn: String?
        /// The compute type for the simulation job summary.
        public let computeType: ComputeType?
        /// The names of the data sources.
        public let dataSourceNames: [String]?
        /// The time, in milliseconds since the epoch, when the simulation job was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the simulation job.
        public let name: String?
        /// A list of simulation job robot application names.
        public let robotApplicationNames: [String]?
        /// A list of simulation job simulation application names.
        public let simulationApplicationNames: [String]?
        /// The status of the simulation job.
        public let status: SimulationJobStatus?

        public init(arn: String? = nil, computeType: ComputeType? = nil, dataSourceNames: [String]? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, robotApplicationNames: [String]? = nil, simulationApplicationNames: [String]? = nil, status: SimulationJobStatus? = nil) {
            self.arn = arn
            self.computeType = computeType
            self.dataSourceNames = dataSourceNames
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.robotApplicationNames = robotApplicationNames
            self.simulationApplicationNames = simulationApplicationNames
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case computeType = "computeType"
            case dataSourceNames = "dataSourceNames"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case robotApplicationNames = "robotApplicationNames"
            case simulationApplicationNames = "simulationApplicationNames"
            case status = "status"
        }
    }

    public struct SimulationSoftwareSuite: AWSEncodableShape & AWSDecodableShape {
        /// The name of the simulation software suite.
        public let name: SimulationSoftwareSuiteType?
        /// The version of the simulation software suite.
        public let version: String?

        public init(name: SimulationSoftwareSuiteType? = nil, version: String? = nil) {
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.version, name: "version", parent: name, max: 1024)
            try self.validate(self.version, name: "version", parent: name, pattern: "^7|9|11|Kinetic|Melodic|Dashing|Foxy$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case version = "version"
        }
    }

    public struct Source: AWSDecodableShape {
        /// The taget processor architecture for the application.
        public let architecture: Architecture?
        /// A hash of the object specified by s3Bucket and s3Key.
        public let etag: String?
        /// The s3 bucket name.
        public let s3Bucket: String?
        /// The s3 object key.
        public let s3Key: String?

        public init(architecture: Architecture? = nil, etag: String? = nil, s3Bucket: String? = nil, s3Key: String? = nil) {
            self.architecture = architecture
            self.etag = etag
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case etag = "etag"
            case s3Bucket = "s3Bucket"
            case s3Key = "s3Key"
        }
    }

    public struct SourceConfig: AWSEncodableShape {
        /// The target processor architecture for the application.
        public let architecture: Architecture?
        /// The Amazon S3 bucket name.
        public let s3Bucket: String?
        /// The s3 object key.
        public let s3Key: String?

        public init(architecture: Architecture? = nil, s3Bucket: String? = nil, s3Key: String? = nil) {
            self.architecture = architecture
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-z0-9][a-z0-9.\\-]*[a-z0-9]$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "architecture"
            case s3Bucket = "s3Bucket"
            case s3Key = "s3Key"
        }
    }

    public struct StartSimulationJobBatchRequest: AWSEncodableShape {
        /// The batch policy.
        public let batchPolicy: BatchPolicy?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// A list of simulation job requests to create in the batch.
        public let createSimulationJobRequests: [SimulationJobRequest]
        /// A map that contains tag keys and tag values that are attached to the deployment job batch.
        public let tags: [String: String]?

        public init(batchPolicy: BatchPolicy? = nil, clientRequestToken: String? = StartSimulationJobBatchRequest.idempotencyToken(), createSimulationJobRequests: [SimulationJobRequest], tags: [String: String]? = nil) {
            self.batchPolicy = batchPolicy
            self.clientRequestToken = clientRequestToken
            self.createSimulationJobRequests = createSimulationJobRequests
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9_\\-=]*$")
            try self.createSimulationJobRequests.forEach {
                try $0.validate(name: "\(name).createSimulationJobRequests[]")
            }
            try self.validate(self.createSimulationJobRequests, name: "createSimulationJobRequests", parent: name, max: 1000)
            try self.validate(self.createSimulationJobRequests, name: "createSimulationJobRequests", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case batchPolicy = "batchPolicy"
            case clientRequestToken = "clientRequestToken"
            case createSimulationJobRequests = "createSimulationJobRequests"
            case tags = "tags"
        }
    }

    public struct StartSimulationJobBatchResponse: AWSDecodableShape {
        /// The Amazon Resource Name (arn) of the batch.
        public let arn: String?
        /// The batch policy.
        public let batchPolicy: BatchPolicy?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String?
        /// The time, in milliseconds since the epoch, when the simulation job batch was created.
        public let createdAt: Date?
        /// A list of created simulation job request summaries.
        public let createdRequests: [SimulationJobSummary]?
        /// A list of failed simulation job requests. The request failed to be created into a simulation job. Failed requests do not have a simulation job ID.
        public let failedRequests: [FailedCreateSimulationJobRequest]?
        /// The failure code if the simulation job batch failed.
        public let failureCode: SimulationJobBatchErrorCode?
        /// The reason the simulation job batch failed.
        public let failureReason: String?
        /// A list of pending simulation job requests. These requests have not yet been created into simulation jobs.
        public let pendingRequests: [SimulationJobRequest]?
        /// The status of the simulation job batch.  Pending  The simulation job batch request is pending.  InProgress  The simulation job batch is in progress.   Failed  The simulation job batch failed. One or more simulation job requests could not be completed due to an internal failure (like InternalServiceError). See failureCode and failureReason for more information.  Completed  The simulation batch job completed. A batch is complete when (1) there are no pending simulation job requests in the batch and none of the failed simulation job requests are due to InternalServiceError and (2) when all created simulation jobs have reached a terminal state (for example, Completed or Failed).   Canceled  The simulation batch job was cancelled.  Canceling  The simulation batch job is being cancelled.  Completing  The simulation batch job is completing.  TimingOut  The simulation job batch is timing out. If a batch timing out, and there are pending requests that were failing due to an internal failure (like InternalServiceError), the batch status will be Failed. If there are no such failing request, the batch status will be TimedOut.   TimedOut  The simulation batch job timed out.
        public let status: SimulationJobBatchStatus?
        /// A map that contains tag keys and tag values that are attached to the deployment job batch.
        public let tags: [String: String]?

        public init(arn: String? = nil, batchPolicy: BatchPolicy? = nil, clientRequestToken: String? = nil, createdAt: Date? = nil, createdRequests: [SimulationJobSummary]? = nil, failedRequests: [FailedCreateSimulationJobRequest]? = nil, failureCode: SimulationJobBatchErrorCode? = nil, failureReason: String? = nil, pendingRequests: [SimulationJobRequest]? = nil, status: SimulationJobBatchStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.batchPolicy = batchPolicy
            self.clientRequestToken = clientRequestToken
            self.createdAt = createdAt
            self.createdRequests = createdRequests
            self.failedRequests = failedRequests
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.pendingRequests = pendingRequests
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case batchPolicy = "batchPolicy"
            case clientRequestToken = "clientRequestToken"
            case createdAt = "createdAt"
            case createdRequests = "createdRequests"
            case failedRequests = "failedRequests"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case pendingRequests = "pendingRequests"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct SyncDeploymentJobRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientRequestToken: String
        /// The target fleet for the synchronization.
        public let fleet: String

        public init(clientRequestToken: String = SyncDeploymentJobRequest.idempotencyToken(), fleet: String) {
            self.clientRequestToken = clientRequestToken
            self.fleet = fleet
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9_\\-=]*$")
            try self.validate(self.fleet, name: "fleet", parent: name, max: 1224)
            try self.validate(self.fleet, name: "fleet", parent: name, min: 1)
            try self.validate(self.fleet, name: "fleet", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case fleet = "fleet"
        }
    }

    public struct SyncDeploymentJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the synchronization request.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the fleet was created.
        public let createdAt: Date?
        /// Information about the deployment application configurations.
        public let deploymentApplicationConfigs: [DeploymentApplicationConfig]?
        /// Information about the deployment configuration.
        public let deploymentConfig: DeploymentConfig?
        /// The failure code if the job fails:  InternalServiceError  Internal service error.  RobotApplicationCrash  Robot application exited abnormally.  SimulationApplicationCrash  Simulation application exited abnormally.  BadPermissionsRobotApplication  Robot application bundle could not be downloaded.  BadPermissionsSimulationApplication  Simulation application bundle could not be downloaded.  BadPermissionsS3Output  Unable to publish outputs to customer-provided S3 bucket.  BadPermissionsCloudwatchLogs  Unable to publish logs to customer-provided CloudWatch Logs resource.  SubnetIpLimitExceeded  Subnet IP limit exceeded.  ENILimitExceeded  ENI limit exceeded.  BadPermissionsUserCredentials  Unable to use the Role provided.  InvalidBundleRobotApplication  Robot bundle cannot be extracted (invalid format, bundling error, or other issue).  InvalidBundleSimulationApplication  Simulation bundle cannot be extracted (invalid format, bundling error, or other issue).  RobotApplicationVersionMismatchedEtag  Etag for RobotApplication does not match value during version creation.  SimulationApplicationVersionMismatchedEtag  Etag for SimulationApplication does not match value during version creation.
        public let failureCode: DeploymentJobErrorCode?
        /// The failure reason if the job fails.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the fleet.
        public let fleet: String?
        /// The status of the synchronization job.
        public let status: DeploymentStatus?

        public init(arn: String? = nil, createdAt: Date? = nil, deploymentApplicationConfigs: [DeploymentApplicationConfig]? = nil, deploymentConfig: DeploymentConfig? = nil, failureCode: DeploymentJobErrorCode? = nil, failureReason: String? = nil, fleet: String? = nil, status: DeploymentStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deploymentApplicationConfigs = deploymentApplicationConfigs
            self.deploymentConfig = deploymentConfig
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.fleet = fleet
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case deploymentApplicationConfigs = "deploymentApplicationConfigs"
            case deploymentConfig = "deploymentConfig"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case fleet = "fleet"
            case status = "status"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are tagging.
        public let resourceArn: String
        /// A map that contains tag keys and tag values that are attached to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TemplateLocation: AWSEncodableShape {
        /// The Amazon S3 bucket name.
        public let s3Bucket: String
        /// The list of S3 keys identifying the data source files.
        public let s3Key: String

        public init(s3Bucket: String, s3Key: String) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, min: 3)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "^[a-z0-9][a-z0-9.\\-]*[a-z0-9]$")
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3Key = "s3Key"
        }
    }

    public struct TemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the template.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the template was created.
        public let createdAt: Date?
        /// The time, in milliseconds since the epoch, when the template was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the template.
        public let name: String?
        /// The version of the template that you're using.
        public let version: String?

        public init(arn: String? = nil, createdAt: Date? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, version: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case version = "version"
        }
    }

    public struct Tool: AWSEncodableShape & AWSDecodableShape {
        /// Command-line arguments for the tool. It must include the tool executable name.
        public let command: String
        /// Exit behavior determines what happens when your tool quits running. RESTART will cause your tool to be restarted. FAIL will cause your job to exit. The default is RESTART.
        public let exitBehavior: ExitBehavior?
        /// The name of the tool.
        public let name: String
        /// Boolean indicating whether logs will be recorded in CloudWatch for the tool. The default is False.
        public let streamOutputToCloudWatch: Bool?
        /// Boolean indicating whether a streaming session will be configured for the tool. If True, AWS RoboMaker will configure a connection so you can interact with the tool as it is running in the simulation. It must have a graphical user interface. The default is False.
        public let streamUI: Bool?

        public init(command: String, exitBehavior: ExitBehavior? = nil, name: String, streamOutputToCloudWatch: Bool? = nil, streamUI: Bool? = nil) {
            self.command = command
            self.exitBehavior = exitBehavior
            self.name = name
            self.streamOutputToCloudWatch = streamOutputToCloudWatch
            self.streamUI = streamUI
        }

        public func validate(name: String) throws {
            try self.validate(self.command, name: "command", parent: name, max: 1024)
            try self.validate(self.command, name: "command", parent: name, min: 1)
            try self.validate(self.command, name: "command", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case command = "command"
            case exitBehavior = "exitBehavior"
            case name = "name"
            case streamOutputToCloudWatch = "streamOutputToCloudWatch"
            case streamUI = "streamUI"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the AWS RoboMaker resource you are removing tags.
        public let resourceArn: String
        /// A map that contains tag keys and tag values that will be unattached from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9 _.\\-\\/+=:]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRobotApplicationRequest: AWSEncodableShape {
        /// The application information for the robot application.
        public let application: String
        /// The revision id for the robot application.
        public let currentRevisionId: String?
        /// The object that contains the Docker image URI for your robot application.
        public let environment: Environment?
        /// The robot software suite (ROS distribution) used by the robot application.
        public let robotSoftwareSuite: RobotSoftwareSuite
        /// The sources of the robot application.
        public let sources: [SourceConfig]?

        public init(application: String, currentRevisionId: String? = nil, environment: Environment? = nil, robotSoftwareSuite: RobotSoftwareSuite, sources: [SourceConfig]? = nil) {
            self.application = application
            self.currentRevisionId = currentRevisionId
            self.environment = environment
            self.robotSoftwareSuite = robotSoftwareSuite
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, max: 40)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, min: 1)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.environment?.validate(name: "\(name).environment")
            try self.sources?.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case currentRevisionId = "currentRevisionId"
            case environment = "environment"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case sources = "sources"
        }
    }

    public struct UpdateRobotApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated robot application.
        public let arn: String?
        /// The object that contains the Docker image URI for your robot application.
        public let environment: Environment?
        /// The time, in milliseconds since the epoch, when the robot application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the robot application.
        public let name: String?
        /// The revision id of the robot application.
        public let revisionId: String?
        /// The robot software suite (ROS distribution) used by the robot application.
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The sources of the robot application.
        public let sources: [Source]?
        /// The version of the robot application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, sources: [Source]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.sources = sources
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case sources = "sources"
            case version = "version"
        }
    }

    public struct UpdateSimulationApplicationRequest: AWSEncodableShape {
        /// The application information for the simulation application.
        public let application: String
        /// The revision id for the robot application.
        public let currentRevisionId: String?
        /// The object that contains the Docker image URI for your simulation application.
        public let environment: Environment?
        /// The rendering engine for the simulation application.
        public let renderingEngine: RenderingEngine?
        /// Information about the robot software suite (ROS distribution).
        public let robotSoftwareSuite: RobotSoftwareSuite
        /// The simulation software suite used by the simulation application.
        public let simulationSoftwareSuite: SimulationSoftwareSuite
        /// The sources of the simulation application.
        public let sources: [SourceConfig]?

        public init(application: String, currentRevisionId: String? = nil, environment: Environment? = nil, renderingEngine: RenderingEngine? = nil, robotSoftwareSuite: RobotSoftwareSuite, simulationSoftwareSuite: SimulationSoftwareSuite, sources: [SourceConfig]? = nil) {
            self.application = application
            self.currentRevisionId = currentRevisionId
            self.environment = environment
            self.renderingEngine = renderingEngine
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.validate(self.application, name: "application", parent: name, max: 1224)
            try self.validate(self.application, name: "application", parent: name, min: 1)
            try self.validate(self.application, name: "application", parent: name, pattern: "^arn:")
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, max: 40)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, min: 1)
            try self.validate(self.currentRevisionId, name: "currentRevisionId", parent: name, pattern: "^[a-zA-Z0-9_.\\-]*$")
            try self.environment?.validate(name: "\(name).environment")
            try self.renderingEngine?.validate(name: "\(name).renderingEngine")
            try self.simulationSoftwareSuite.validate(name: "\(name).simulationSoftwareSuite")
            try self.sources?.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case application = "application"
            case currentRevisionId = "currentRevisionId"
            case environment = "environment"
            case renderingEngine = "renderingEngine"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case simulationSoftwareSuite = "simulationSoftwareSuite"
            case sources = "sources"
        }
    }

    public struct UpdateSimulationApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated simulation application.
        public let arn: String?
        /// The object that contains the Docker image URI used for your simulation application.
        public let environment: Environment?
        /// The time, in milliseconds since the epoch, when the simulation application was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the simulation application.
        public let name: String?
        /// The rendering engine for the simulation application.
        public let renderingEngine: RenderingEngine?
        /// The revision id of the simulation application.
        public let revisionId: String?
        /// Information about the robot software suite (ROS distribution).
        public let robotSoftwareSuite: RobotSoftwareSuite?
        /// The simulation software suite used by the simulation application.
        public let simulationSoftwareSuite: SimulationSoftwareSuite?
        /// The sources of the simulation application.
        public let sources: [Source]?
        /// The version of the robot application.
        public let version: String?

        public init(arn: String? = nil, environment: Environment? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, renderingEngine: RenderingEngine? = nil, revisionId: String? = nil, robotSoftwareSuite: RobotSoftwareSuite? = nil, simulationSoftwareSuite: SimulationSoftwareSuite? = nil, sources: [Source]? = nil, version: String? = nil) {
            self.arn = arn
            self.environment = environment
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.renderingEngine = renderingEngine
            self.revisionId = revisionId
            self.robotSoftwareSuite = robotSoftwareSuite
            self.simulationSoftwareSuite = simulationSoftwareSuite
            self.sources = sources
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case environment = "environment"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case renderingEngine = "renderingEngine"
            case revisionId = "revisionId"
            case robotSoftwareSuite = "robotSoftwareSuite"
            case simulationSoftwareSuite = "simulationSoftwareSuite"
            case sources = "sources"
            case version = "version"
        }
    }

    public struct UpdateWorldTemplateRequest: AWSEncodableShape {
        /// The name of the template.
        public let name: String?
        /// The Amazon Resource Name (arn) of the world template to update.
        public let template: String
        /// The world template body.
        public let templateBody: String?
        /// The location of the world template.
        public let templateLocation: TemplateLocation?

        public init(name: String? = nil, template: String, templateBody: String? = nil, templateLocation: TemplateLocation? = nil) {
            self.name = name
            self.template = template
            self.templateBody = templateBody
            self.templateLocation = templateLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*")
            try self.validate(self.template, name: "template", parent: name, max: 1224)
            try self.validate(self.template, name: "template", parent: name, min: 1)
            try self.validate(self.template, name: "template", parent: name, pattern: "^arn:")
            try self.validate(self.templateBody, name: "templateBody", parent: name, max: 262144)
            try self.validate(self.templateBody, name: "templateBody", parent: name, min: 1)
            try self.validate(self.templateBody, name: "templateBody", parent: name, pattern: "^[\\S\\s]+$")
            try self.templateLocation?.validate(name: "\(name).templateLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case template = "template"
            case templateBody = "templateBody"
            case templateLocation = "templateLocation"
        }
    }

    public struct UpdateWorldTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (arn) of the world template.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the world template was created.
        public let createdAt: Date?
        /// The time, in milliseconds since the epoch, when the world template was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the world template.
        public let name: String?

        public init(arn: String? = nil, createdAt: Date? = nil, lastUpdatedAt: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
        }
    }

    public struct UploadConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A prefix that specifies where files will be uploaded in Amazon S3. It is appended to the simulation output location to determine the final path.  For example, if your simulation output location is s3://my-bucket and your upload configuration name is robot-test, your files will be uploaded to s3://my-bucket///robot-test.
        public let name: String
        ///  Specifies the path of the file(s) to upload. Standard Unix glob matching rules are accepted, with the addition of ** as a super asterisk. For example, specifying /var/log/**.log causes all .log files in the /var/log directory tree to be collected. For more examples, see Glob Library.
        public let path: String
        /// Specifies when to upload the files:  UPLOAD_ON_TERMINATE  Matching files are uploaded once the simulation enters the TERMINATING state. Matching files are not uploaded until all of your code (including tools) have stopped.  If there is a problem uploading a file, the upload is retried. If problems persist, no further upload attempts will be made.  UPLOAD_ROLLING_AUTO_REMOVE  Matching files are uploaded as they are created. They are deleted after they are uploaded. The specified path is checked every 5 seconds. A final check is made when all of your code (including tools) have stopped.
        public let uploadBehavior: UploadBehavior

        public init(name: String, path: String, uploadBehavior: UploadBehavior) {
            self.name = name
            self.path = path
            self.uploadBehavior = uploadBehavior
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-]*$")
            try self.validate(self.path, name: "path", parent: name, max: 1024)
            try self.validate(self.path, name: "path", parent: name, min: 1)
            try self.validate(self.path, name: "path", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case path = "path"
            case uploadBehavior = "uploadBehavior"
        }
    }

    public struct VPCConfig: AWSEncodableShape & AWSDecodableShape {
        /// A boolean indicating whether to assign a public IP address.
        public let assignPublicIp: Bool?
        /// A list of one or more security groups IDs in your VPC.
        public let securityGroups: [String]?
        /// A list of one or more subnet IDs in your VPC.
        public let subnets: [String]

        public init(assignPublicIp: Bool? = nil, securityGroups: [String]? = nil, subnets: [String]) {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, max: 255)
                try validate($0, name: "securityGroups[]", parent: name, min: 1)
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, max: 5)
            try self.validate(self.securityGroups, name: "securityGroups", parent: name, min: 1)
            try self.subnets.forEach {
                try validate($0, name: "subnets[]", parent: name, max: 255)
                try validate($0, name: "subnets[]", parent: name, min: 1)
                try validate($0, name: "subnets[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.subnets, name: "subnets", parent: name, max: 16)
            try self.validate(self.subnets, name: "subnets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assignPublicIp = "assignPublicIp"
            case securityGroups = "securityGroups"
            case subnets = "subnets"
        }
    }

    public struct VPCConfigResponse: AWSDecodableShape {
        /// A boolean indicating if a public IP was assigned.
        public let assignPublicIp: Bool?
        /// A list of security group IDs associated with the simulation job.
        public let securityGroups: [String]?
        /// A list of subnet IDs associated with the simulation job.
        public let subnets: [String]?
        /// The VPC ID associated with your simulation job.
        public let vpcId: String?

        public init(assignPublicIp: Bool? = nil, securityGroups: [String]? = nil, subnets: [String]? = nil, vpcId: String? = nil) {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case assignPublicIp = "assignPublicIp"
            case securityGroups = "securityGroups"
            case subnets = "subnets"
            case vpcId = "vpcId"
        }
    }

    public struct WorldConfig: AWSEncodableShape & AWSDecodableShape {
        /// The world generated by Simulation WorldForge.
        public let world: String?

        public init(world: String? = nil) {
            self.world = world
        }

        public func validate(name: String) throws {
            try self.validate(self.world, name: "world", parent: name, max: 1224)
            try self.validate(self.world, name: "world", parent: name, min: 1)
            try self.validate(self.world, name: "world", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case world = "world"
        }
    }

    public struct WorldCount: AWSEncodableShape & AWSDecodableShape {
        /// The number of unique floorplans.
        public let floorplanCount: Int?
        /// The number of unique interiors per floorplan.
        public let interiorCountPerFloorplan: Int?

        public init(floorplanCount: Int? = nil, interiorCountPerFloorplan: Int? = nil) {
            self.floorplanCount = floorplanCount
            self.interiorCountPerFloorplan = interiorCountPerFloorplan
        }

        private enum CodingKeys: String, CodingKey {
            case floorplanCount = "floorplanCount"
            case interiorCountPerFloorplan = "interiorCountPerFloorplan"
        }
    }

    public struct WorldExportJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world export job.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the world export job was created.
        public let createdAt: Date?
        public let outputLocation: OutputLocation?
        /// The status of the world export job.  Pending  The world export job request is pending.  Running  The world export job is running.   Completed  The world export job completed.   Failed  The world export job failed. See failureCode for more information.   Canceled  The world export job was cancelled.  Canceling  The world export job is being cancelled.
        public let status: WorldExportJobStatus?
        /// A list of worlds.
        public let worlds: [String]?

        public init(arn: String? = nil, createdAt: Date? = nil, outputLocation: OutputLocation? = nil, status: WorldExportJobStatus? = nil, worlds: [String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.outputLocation = outputLocation
            self.status = status
            self.worlds = worlds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case outputLocation = "outputLocation"
            case status = "status"
            case worlds = "worlds"
        }
    }

    public struct WorldFailure: AWSDecodableShape {
        /// The failure code of the world export job if it failed:  InternalServiceError  Internal service error.  LimitExceeded  The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.   ResourceNotFound  The specified resource could not be found.   RequestThrottled  The request was throttled.  InvalidInput  An input parameter in the request is not valid.
        public let failureCode: WorldGenerationJobErrorCode?
        /// The number of failed worlds.
        public let failureCount: Int?
        /// The sample reason why the world failed. World errors are aggregated. A sample is used as the sampleFailureReason.
        public let sampleFailureReason: String?

        public init(failureCode: WorldGenerationJobErrorCode? = nil, failureCount: Int? = nil, sampleFailureReason: String? = nil) {
            self.failureCode = failureCode
            self.failureCount = failureCount
            self.sampleFailureReason = sampleFailureReason
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureCount = "failureCount"
            case sampleFailureReason = "sampleFailureReason"
        }
    }

    public struct WorldGenerationJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world generator job.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the world generator job was created.
        public let createdAt: Date?
        /// The number of worlds that failed.
        public let failedWorldCount: Int?
        /// The status of the world generator job:  Pending  The world generator job request is pending.  Running  The world generator job is running.   Completed  The world generator job completed.   Failed  The world generator job failed. See failureCode for more information.   PartialFailed  Some worlds did not generate.  Canceled  The world generator job was cancelled.  Canceling  The world generator job is being cancelled.
        public let status: WorldGenerationJobStatus?
        /// The number of worlds that were generated.
        public let succeededWorldCount: Int?
        /// The Amazon Resource Name (arn) of the world template.
        public let template: String?
        /// Information about the world count.
        public let worldCount: WorldCount?

        public init(arn: String? = nil, createdAt: Date? = nil, failedWorldCount: Int? = nil, status: WorldGenerationJobStatus? = nil, succeededWorldCount: Int? = nil, template: String? = nil, worldCount: WorldCount? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.failedWorldCount = failedWorldCount
            self.status = status
            self.succeededWorldCount = succeededWorldCount
            self.template = template
            self.worldCount = worldCount
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case failedWorldCount = "failedWorldCount"
            case status = "status"
            case succeededWorldCount = "succeededWorldCount"
            case template = "template"
            case worldCount = "worldCount"
        }
    }

    public struct WorldSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the world.
        public let arn: String?
        /// The time, in milliseconds since the epoch, when the world was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (arn) of the world generation job.
        public let generationJob: String?
        /// The Amazon Resource Name (arn) of the world template.
        public let template: String?

        public init(arn: String? = nil, createdAt: Date? = nil, generationJob: String? = nil, template: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.generationJob = generationJob
            self.template = template
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case generationJob = "generationJob"
            case template = "template"
        }
    }
}

// MARK: - Errors

/// Error enum for RoboMaker
public struct RoboMakerErrorType: AWSErrorType {
    enum Code: String {
        case concurrentDeploymentException = "ConcurrentDeploymentException"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case internalServerException = "InternalServerException"
        case invalidParameterException = "InvalidParameterException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize RoboMaker
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The failure percentage threshold percentage was met.
    public static var concurrentDeploymentException: Self { .init(.concurrentDeploymentException) }
    /// The request uses the same client token as a previous, but non-identical request. Do not reuse a client token with different requests, unless the requests are identical.
    public static var idempotentParameterMismatchException: Self { .init(.idempotentParameterMismatchException) }
    /// AWS RoboMaker experienced a service issue. Try your call again.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A parameter specified in a request is not valid, is unsupported, or cannot be used. The returned message provides an explanation of the error value.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The requested resource exceeds the maximum number allowed, or the number of concurrent stream requests exceeds the maximum number allowed.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The specified resource already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request has failed due to a temporary failure of the server.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// AWS RoboMaker is temporarily unable to process the request. Try your call again.
    public static var throttlingException: Self { .init(.throttlingException) }
}

extension RoboMakerErrorType: Equatable {
    public static func == (lhs: RoboMakerErrorType, rhs: RoboMakerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RoboMakerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
