//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Braket {
    // MARK: Enums

    public enum AssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case reservationTimeWindowArn = "RESERVATION_TIME_WINDOW_ARN"
        public var description: String { return self.rawValue }
    }

    public enum CancellationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        public var description: String { return self.rawValue }
    }

    public enum CompressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case offline = "OFFLINE"
        case online = "ONLINE"
        case retired = "RETIRED"
        public var description: String { return self.rawValue }
    }

    public enum DeviceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case qpu = "QPU"
        case simulator = "SIMULATOR"
        public var description: String { return self.rawValue }
    }

    public enum HybridJobAdditionalAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queueInfo = "QueueInfo"
        public var description: String { return self.rawValue }
    }

    public enum InstanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mlC42Xlarge = "ml.c4.2xlarge"
        case mlC44Xlarge = "ml.c4.4xlarge"
        case mlC48Xlarge = "ml.c4.8xlarge"
        case mlC4Xlarge = "ml.c4.xlarge"
        case mlC518Xlarge = "ml.c5.18xlarge"
        case mlC52Xlarge = "ml.c5.2xlarge"
        case mlC54Xlarge = "ml.c5.4xlarge"
        case mlC59Xlarge = "ml.c5.9xlarge"
        case mlC5Xlarge = "ml.c5.xlarge"
        case mlC5N18Xlarge = "ml.c5n.18xlarge"
        case mlC5N2Xlarge = "ml.c5n.2xlarge"
        case mlC5N4Xlarge = "ml.c5n.4xlarge"
        case mlC5N9Xlarge = "ml.c5n.9xlarge"
        case mlC5NXlarge = "ml.c5n.xlarge"
        case mlG4Dn12Xlarge = "ml.g4dn.12xlarge"
        case mlG4Dn16Xlarge = "ml.g4dn.16xlarge"
        case mlG4Dn2Xlarge = "ml.g4dn.2xlarge"
        case mlG4Dn4Xlarge = "ml.g4dn.4xlarge"
        case mlG4Dn8Xlarge = "ml.g4dn.8xlarge"
        case mlG4DnXlarge = "ml.g4dn.xlarge"
        case mlM410Xlarge = "ml.m4.10xlarge"
        case mlM416Xlarge = "ml.m4.16xlarge"
        case mlM42Xlarge = "ml.m4.2xlarge"
        case mlM44Xlarge = "ml.m4.4xlarge"
        case mlM4Xlarge = "ml.m4.xlarge"
        case mlM512Xlarge = "ml.m5.12xlarge"
        case mlM524Xlarge = "ml.m5.24xlarge"
        case mlM52Xlarge = "ml.m5.2xlarge"
        case mlM54Xlarge = "ml.m5.4xlarge"
        case mlM5Large = "ml.m5.large"
        case mlM5Xlarge = "ml.m5.xlarge"
        case mlP216Xlarge = "ml.p2.16xlarge"
        case mlP28Xlarge = "ml.p2.8xlarge"
        case mlP2Xlarge = "ml.p2.xlarge"
        case mlP316Xlarge = "ml.p3.16xlarge"
        case mlP32Xlarge = "ml.p3.2xlarge"
        case mlP38Xlarge = "ml.p3.8xlarge"
        case mlP3Dn24Xlarge = "ml.p3dn.24xlarge"
        case mlP4D24Xlarge = "ml.p4d.24xlarge"
        public var description: String { return self.rawValue }
    }

    public enum JobEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case deprioritizedDueToInactivity = "DEPRIORITIZED_DUE_TO_INACTIVITY"
        case downloadingData = "DOWNLOADING_DATA"
        case failed = "FAILED"
        case maxRuntimeExceeded = "MAX_RUNTIME_EXCEEDED"
        case queuedForExecution = "QUEUED_FOR_EXECUTION"
        case running = "RUNNING"
        case startingInstance = "STARTING_INSTANCE"
        case uploadingResults = "UPLOADING_RESULTS"
        case waitingForPriority = "WAITING_FOR_PRIORITY"
        public var description: String { return self.rawValue }
    }

    public enum JobPrimaryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum QuantumTaskAdditionalAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queueInfo = "QueueInfo"
        public var description: String { return self.rawValue }
    }

    public enum QuantumTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum QueueName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jobsQueue = "JOBS_QUEUE"
        case quantumTasksQueue = "QUANTUM_TASKS_QUEUE"
        public var description: String { return self.rawValue }
    }

    public enum QueuePriority: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case normal = "Normal"
        case priority = "Priority"
        public var description: String { return self.rawValue }
    }

    public enum SearchJobsFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case equal = "EQUAL"
        case gt = "GT"
        case gte = "GTE"
        case lt = "LT"
        case lte = "LTE"
        public var description: String { return self.rawValue }
    }

    public enum SearchQuantumTasksFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        case equal = "EQUAL"
        case gt = "GT"
        case gte = "GTE"
        case lt = "LT"
        case lte = "LTE"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case programSetValidationFailed = "ProgramSetValidationFailed"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ActionMetadata: AWSDecodableShape {
        /// The type of action associated with the quantum task.
        public let actionType: String
        /// The number of executables in a program set. This is only available for a Program Set.
        public let executableCount: Int64?
        /// The number of programs in a program set. This is only available for a Program Set.
        public let programCount: Int64?

        @inlinable
        public init(actionType: String, executableCount: Int64? = nil, programCount: Int64? = nil) {
            self.actionType = actionType
            self.executableCount = executableCount
            self.programCount = programCount
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case executableCount = "executableCount"
            case programCount = "programCount"
        }
    }

    public struct AlgorithmSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The container image used to create an Amazon Braket hybrid job.
        public let containerImage: ContainerImage?
        /// Configures the paths to the Python scripts used for entry and training.
        public let scriptModeConfig: ScriptModeConfig?

        @inlinable
        public init(containerImage: ContainerImage? = nil, scriptModeConfig: ScriptModeConfig? = nil) {
            self.containerImage = containerImage
            self.scriptModeConfig = scriptModeConfig
        }

        public func validate(name: String) throws {
            try self.containerImage?.validate(name: "\(name).containerImage")
            try self.scriptModeConfig?.validate(name: "\(name).scriptModeConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case containerImage = "containerImage"
            case scriptModeConfig = "scriptModeConfig"
        }
    }

    public struct Association: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Braket resource arn.
        public let arn: String
        /// The association type for the specified Amazon Braket resource arn.
        public let type: AssociationType

        @inlinable
        public init(arn: String, type: AssociationType) {
            self.arn = arn
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z\\-]*:braket:[a-z0-9\\-]*:[0-9]{12}:.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case type = "type"
        }
    }

    public struct CancelJobRequest: AWSEncodableShape {
        /// The ARN of the Amazon Braket hybrid job to cancel.
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobArn, key: "jobArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobArn, name: "jobArn", parent: name, pattern: "^arn:aws[a-z\\-]*:braket:[a-z0-9\\-]+:[0-9]{12}:job/.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelJobResponse: AWSDecodableShape {
        /// The status of the hybrid job.
        public let cancellationStatus: CancellationStatus
        /// The ARN of the Amazon Braket job.
        public let jobArn: String

        @inlinable
        public init(cancellationStatus: CancellationStatus, jobArn: String) {
            self.cancellationStatus = cancellationStatus
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case cancellationStatus = "cancellationStatus"
            case jobArn = "jobArn"
        }
    }

    public struct CancelQuantumTaskRequest: AWSEncodableShape {
        /// The client token associated with the cancellation request.
        public let clientToken: String
        /// The ARN of the quantum task to cancel.
        public let quantumTaskArn: String

        @inlinable
        public init(clientToken: String = CancelQuantumTaskRequest.idempotencyToken(), quantumTaskArn: String) {
            self.clientToken = clientToken
            self.quantumTaskArn = quantumTaskArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodePath(self.quantumTaskArn, key: "quantumTaskArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.quantumTaskArn, name: "quantumTaskArn", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct CancelQuantumTaskResponse: AWSDecodableShape {
        /// The status of the quantum task.
        public let cancellationStatus: CancellationStatus
        /// The ARN of the quantum task.
        public let quantumTaskArn: String

        @inlinable
        public init(cancellationStatus: CancellationStatus, quantumTaskArn: String) {
            self.cancellationStatus = cancellationStatus
            self.quantumTaskArn = quantumTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case cancellationStatus = "cancellationStatus"
            case quantumTaskArn = "quantumTaskArn"
        }
    }

    public struct ContainerImage: AWSEncodableShape & AWSDecodableShape {
        /// The URI locating the container image.
        public let uri: String

        @inlinable
        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^\\d{10,14}\\.dkr\\.ecr.[a-z0-9-]+\\.amazonaws\\.com\\/.+(@sha256)?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        /// Definition of the Amazon Braket job to be created. Specifies the container image the job uses and information about the Python scripts used for entry and training.
        public let algorithmSpecification: AlgorithmSpecification
        /// The list of Amazon Braket resources associated with the hybrid job.
        public let associations: [Association]?
        /// Information about the output locations for hybrid job checkpoint data.
        public let checkpointConfig: JobCheckpointConfig?
        /// The client token associated with this request that guarantees that the request is idempotent.
        public let clientToken: String
        /// The quantum processing unit (QPU) or simulator used to create an Amazon Braket hybrid job.
        public let deviceConfig: DeviceConfig
        /// Algorithm-specific parameters used by an Amazon Braket hybrid job that influence the quality of the training job. The values are set with a map of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of the hyperparameter.  Do not include any security-sensitive information including account access IDs, secrets, or tokens in any hyperparameter fields. As part of the shared responsibility model, you are responsible for any potential exposure, unauthorized access, or compromise of your sensitive data if caused by security-sensitive information included in the request hyperparameter variable or plain text fields.
        public let hyperParameters: [String: String]?
        /// A list of parameters that specify the name and type of input data and where it is located.
        public let inputDataConfig: [InputFileConfig]?
        /// Configuration of the resource instances to use while running the hybrid job on Amazon Braket.
        public let instanceConfig: InstanceConfig
        /// The name of the Amazon Braket hybrid job.
        public let jobName: String
        /// The path to the S3 location where you want to store hybrid job artifacts and the encryption key used to store them.
        public let outputDataConfig: JobOutputDataConfig
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output results and hybrid job details to the users' s3 buckets.
        public let roleArn: String
        ///  The user-defined criteria that specifies when a hybrid job stops running.
        public let stoppingCondition: JobStoppingCondition?
        /// Tags to be added to the hybrid job you're creating.
        public let tags: [String: String]?

        @inlinable
        public init(algorithmSpecification: AlgorithmSpecification, associations: [Association]? = nil, checkpointConfig: JobCheckpointConfig? = nil, clientToken: String = CreateJobRequest.idempotencyToken(), deviceConfig: DeviceConfig, hyperParameters: [String: String]? = nil, inputDataConfig: [InputFileConfig]? = nil, instanceConfig: InstanceConfig, jobName: String, outputDataConfig: JobOutputDataConfig, roleArn: String, stoppingCondition: JobStoppingCondition? = nil, tags: [String: String]? = nil) {
            self.algorithmSpecification = algorithmSpecification
            self.associations = associations
            self.checkpointConfig = checkpointConfig
            self.clientToken = clientToken
            self.deviceConfig = deviceConfig
            self.hyperParameters = hyperParameters
            self.inputDataConfig = inputDataConfig
            self.instanceConfig = instanceConfig
            self.jobName = jobName
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.stoppingCondition = stoppingCondition
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.algorithmSpecification.validate(name: "\(name).algorithmSpecification")
            try self.associations?.forEach {
                try $0.validate(name: "\(name).associations[]")
            }
            try self.checkpointConfig?.validate(name: "\(name).checkpointConfig")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.deviceConfig.validate(name: "\(name).deviceConfig")
            try self.hyperParameters?.forEach {
                try validate($0.key, name: "hyperParameters.key", parent: name, max: 256)
                try validate($0.key, name: "hyperParameters.key", parent: name, min: 1)
            }
            try self.validate(self.hyperParameters, name: "hyperParameters", parent: name, max: 100)
            try self.inputDataConfig?.forEach {
                try $0.validate(name: "\(name).inputDataConfig[]")
            }
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSpecification = "algorithmSpecification"
            case associations = "associations"
            case checkpointConfig = "checkpointConfig"
            case clientToken = "clientToken"
            case deviceConfig = "deviceConfig"
            case hyperParameters = "hyperParameters"
            case inputDataConfig = "inputDataConfig"
            case instanceConfig = "instanceConfig"
            case jobName = "jobName"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
            case stoppingCondition = "stoppingCondition"
            case tags = "tags"
        }
    }

    public struct CreateJobResponse: AWSDecodableShape {
        /// The ARN of the Amazon Braket hybrid job created.
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
        }
    }

    public struct CreateQuantumTaskRequest: AWSEncodableShape {
        /// The action associated with the quantum task.
        public let action: String
        /// The list of Amazon Braket resources associated with the quantum task.
        public let associations: [Association]?
        /// The client token associated with the request.
        public let clientToken: String
        /// The ARN of the device to run the quantum task on.
        public let deviceArn: String
        /// The parameters for the device to run the quantum task on.
        public let deviceParameters: String?
        /// The token for an Amazon Braket hybrid job that associates it with the quantum task.
        public let jobToken: String?
        /// The S3 bucket to store quantum task result files in.
        public let outputS3Bucket: String
        /// The key prefix for the location in the S3 bucket to store quantum task results in.
        public let outputS3KeyPrefix: String
        /// The number of shots to use for the quantum task.
        public let shots: Int64
        /// Tags to be added to the quantum task you're creating.
        public let tags: [String: String]?

        @inlinable
        public init(action: String, associations: [Association]? = nil, clientToken: String = CreateQuantumTaskRequest.idempotencyToken(), deviceArn: String, deviceParameters: String? = nil, jobToken: String? = nil, outputS3Bucket: String, outputS3KeyPrefix: String, shots: Int64, tags: [String: String]? = nil) {
            self.action = action
            self.associations = associations
            self.clientToken = clientToken
            self.deviceArn = deviceArn
            self.deviceParameters = deviceParameters
            self.jobToken = jobToken
            self.outputS3Bucket = outputS3Bucket
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.shots = shots
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.associations?.forEach {
                try $0.validate(name: "\(name).associations[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, max: 256)
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, min: 1)
            try self.validate(self.jobToken, name: "jobToken", parent: name, max: 128)
            try self.validate(self.jobToken, name: "jobToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case associations = "associations"
            case clientToken = "clientToken"
            case deviceArn = "deviceArn"
            case deviceParameters = "deviceParameters"
            case jobToken = "jobToken"
            case outputS3Bucket = "outputS3Bucket"
            case outputS3KeyPrefix = "outputS3KeyPrefix"
            case shots = "shots"
            case tags = "tags"
        }
    }

    public struct CreateQuantumTaskResponse: AWSDecodableShape {
        /// The ARN of the quantum task created by the request.
        public let quantumTaskArn: String

        @inlinable
        public init(quantumTaskArn: String) {
            self.quantumTaskArn = quantumTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case quantumTaskArn = "quantumTaskArn"
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// Amazon S3 path of the input data used by the hybrid job.
        public let s3DataSource: S3DataSource

        @inlinable
        public init(s3DataSource: S3DataSource) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "s3DataSource"
        }
    }

    public struct DeviceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The primary device ARN used to create and run an Amazon Braket hybrid job.
        public let device: String

        @inlinable
        public init(device: String) {
            self.device = device
        }

        public func validate(name: String) throws {
            try self.validate(self.device, name: "device", parent: name, max: 256)
            try self.validate(self.device, name: "device", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case device = "device"
        }
    }

    public struct DeviceQueueInfo: AWSDecodableShape {
        /// The name of the queue.
        public let queue: QueueName
        /// Optional. Specifies the priority of the queue. Quantum tasks in a priority queue are processed before the quantum tasks in a normal queue.
        public let queuePriority: QueuePriority?
        /// The number of hybrid jobs or quantum tasks in the queue for a given device.
        public let queueSize: String

        @inlinable
        public init(queue: QueueName, queuePriority: QueuePriority? = nil, queueSize: String) {
            self.queue = queue
            self.queuePriority = queuePriority
            self.queueSize = queueSize
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
            case queuePriority = "queuePriority"
            case queueSize = "queueSize"
        }
    }

    public struct DeviceSummary: AWSDecodableShape {
        /// The ARN of the device.
        public let deviceArn: String
        /// The name of the device.
        public let deviceName: String
        /// The status of the device.
        public let deviceStatus: DeviceStatus
        /// The type of the device.
        public let deviceType: DeviceType
        /// The provider of the device.
        public let providerName: String

        @inlinable
        public init(deviceArn: String, deviceName: String, deviceStatus: DeviceStatus, deviceType: DeviceType, providerName: String) {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceStatus = deviceStatus
            self.deviceType = deviceType
            self.providerName = providerName
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "deviceArn"
            case deviceName = "deviceName"
            case deviceStatus = "deviceStatus"
            case deviceType = "deviceType"
            case providerName = "providerName"
        }
    }

    public struct GetDeviceRequest: AWSEncodableShape {
        /// The ARN of the device to retrieve.
        public let deviceArn: String

        @inlinable
        public init(deviceArn: String) {
            self.deviceArn = deviceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceArn, key: "deviceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, max: 256)
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeviceResponse: AWSDecodableShape {
        /// The ARN of the device.
        public let deviceArn: String
        /// Details about the capabilities of the device.
        public let deviceCapabilities: String
        /// The name of the device.
        public let deviceName: String
        /// The number of quantum tasks and hybrid jobs currently queued on the device.
        public let deviceQueueInfo: [DeviceQueueInfo]?
        /// The status of the device.
        public let deviceStatus: DeviceStatus
        /// The type of the device.
        public let deviceType: DeviceType
        /// The name of the partner company for the device.
        public let providerName: String

        @inlinable
        public init(deviceArn: String, deviceCapabilities: String, deviceName: String, deviceQueueInfo: [DeviceQueueInfo]? = nil, deviceStatus: DeviceStatus, deviceType: DeviceType, providerName: String) {
            self.deviceArn = deviceArn
            self.deviceCapabilities = deviceCapabilities
            self.deviceName = deviceName
            self.deviceQueueInfo = deviceQueueInfo
            self.deviceStatus = deviceStatus
            self.deviceType = deviceType
            self.providerName = providerName
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "deviceArn"
            case deviceCapabilities = "deviceCapabilities"
            case deviceName = "deviceName"
            case deviceQueueInfo = "deviceQueueInfo"
            case deviceStatus = "deviceStatus"
            case deviceType = "deviceType"
            case providerName = "providerName"
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        /// A list of attributes to return additional information for. Only the QueueInfo additional attribute name is currently supported.
        public let additionalAttributeNames: [HybridJobAdditionalAttributeName]?
        /// The ARN of the hybrid job to retrieve.
        public let jobArn: String

        @inlinable
        public init(additionalAttributeNames: [HybridJobAdditionalAttributeName]? = nil, jobArn: String) {
            self.additionalAttributeNames = additionalAttributeNames
            self.jobArn = jobArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.additionalAttributeNames, key: "additionalAttributeNames")
            request.encodePath(self.jobArn, key: "jobArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobArn, name: "jobArn", parent: name, pattern: "^arn:aws[a-z\\-]*:braket:[a-z0-9\\-]+:[0-9]{12}:job/.*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobResponse: AWSDecodableShape {
        /// Definition of the Amazon Braket hybrid job created. Provides information about the container image used, and the Python scripts used for training.
        public let algorithmSpecification: AlgorithmSpecification
        /// The list of Amazon Braket resources associated with the hybrid job.
        public let associations: [Association]?
        /// The billable time for which the Amazon Braket hybrid job used to complete.
        public let billableDuration: Int?
        /// Information about the output locations for hybrid job checkpoint data.
        public let checkpointConfig: JobCheckpointConfig?
        /// The time at which the Amazon Braket hybrid job was created.
        public let createdAt: Date
        /// The primary device used by the Amazon Braket hybrid job.
        public let deviceConfig: DeviceConfig?
        /// The time at which the Amazon Braket hybrid job ended.
        public let endedAt: Date?
        /// Details about the time and type of events occurred related to the Amazon Braket hybrid job.
        public let events: [JobEventDetails]?
        /// A description of the reason why an Amazon Braket hybrid job failed, if it failed.
        public let failureReason: String?
        /// Algorithm-specific parameters used by an Amazon Braket hybrid job that influence the quality of the traiing job. The values are set with a map of JSON key:value pairs, where the key is the name of the hyperparameter and the value is the value of th hyperparameter.
        public let hyperParameters: [String: String]?
        /// A list of parameters that specify the name and type of input data and where it is located.
        public let inputDataConfig: [InputFileConfig]?
        /// The resource instances to use while running the hybrid job on Amazon Braket.
        public let instanceConfig: InstanceConfig
        /// The ARN of the Amazon Braket hybrid job.
        public let jobArn: String
        /// The name of the Amazon Braket hybrid job.
        public let jobName: String
        /// The path to the S3 location where hybrid job artifacts are stored and the encryption key used to store them there.
        public let outputDataConfig: JobOutputDataConfig
        /// Queue information for the requested hybrid job. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetJob API request.
        public let queueInfo: HybridJobQueueInfo?
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can assume to perform tasks on behalf of a user. It can access user resources, run an Amazon Braket job container on behalf of user, and output results and other hybrid job details to the s3 buckets of a user.
        public let roleArn: String
        /// The time at which the Amazon Braket hybrid job was started.
        public let startedAt: Date?
        /// The status of the Amazon Braket hybrid job.
        public let status: JobPrimaryStatus
        /// The user-defined criteria that specifies when to stop a running hybrid job.
        public let stoppingCondition: JobStoppingCondition?
        /// The tags associated with this hybrid job.
        public let tags: [String: String]?

        @inlinable
        public init(algorithmSpecification: AlgorithmSpecification, associations: [Association]? = nil, billableDuration: Int? = nil, checkpointConfig: JobCheckpointConfig? = nil, createdAt: Date, deviceConfig: DeviceConfig? = nil, endedAt: Date? = nil, events: [JobEventDetails]? = nil, failureReason: String? = nil, hyperParameters: [String: String]? = nil, inputDataConfig: [InputFileConfig]? = nil, instanceConfig: InstanceConfig, jobArn: String, jobName: String, outputDataConfig: JobOutputDataConfig, queueInfo: HybridJobQueueInfo? = nil, roleArn: String, startedAt: Date? = nil, status: JobPrimaryStatus, stoppingCondition: JobStoppingCondition? = nil, tags: [String: String]? = nil) {
            self.algorithmSpecification = algorithmSpecification
            self.associations = associations
            self.billableDuration = billableDuration
            self.checkpointConfig = checkpointConfig
            self.createdAt = createdAt
            self.deviceConfig = deviceConfig
            self.endedAt = endedAt
            self.events = events
            self.failureReason = failureReason
            self.hyperParameters = hyperParameters
            self.inputDataConfig = inputDataConfig
            self.instanceConfig = instanceConfig
            self.jobArn = jobArn
            self.jobName = jobName
            self.outputDataConfig = outputDataConfig
            self.queueInfo = queueInfo
            self.roleArn = roleArn
            self.startedAt = startedAt
            self.status = status
            self.stoppingCondition = stoppingCondition
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmSpecification = "algorithmSpecification"
            case associations = "associations"
            case billableDuration = "billableDuration"
            case checkpointConfig = "checkpointConfig"
            case createdAt = "createdAt"
            case deviceConfig = "deviceConfig"
            case endedAt = "endedAt"
            case events = "events"
            case failureReason = "failureReason"
            case hyperParameters = "hyperParameters"
            case inputDataConfig = "inputDataConfig"
            case instanceConfig = "instanceConfig"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case outputDataConfig = "outputDataConfig"
            case queueInfo = "queueInfo"
            case roleArn = "roleArn"
            case startedAt = "startedAt"
            case status = "status"
            case stoppingCondition = "stoppingCondition"
            case tags = "tags"
        }
    }

    public struct GetQuantumTaskRequest: AWSEncodableShape {
        /// A list of attributes to return additional information for. Only the QueueInfo additional attribute name is currently supported.
        public let additionalAttributeNames: [QuantumTaskAdditionalAttributeName]?
        /// The ARN of the quantum task to retrieve.
        public let quantumTaskArn: String

        @inlinable
        public init(additionalAttributeNames: [QuantumTaskAdditionalAttributeName]? = nil, quantumTaskArn: String) {
            self.additionalAttributeNames = additionalAttributeNames
            self.quantumTaskArn = quantumTaskArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.additionalAttributeNames, key: "additionalAttributeNames")
            request.encodePath(self.quantumTaskArn, key: "quantumTaskArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.quantumTaskArn, name: "quantumTaskArn", parent: name, max: 256)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQuantumTaskResponse: AWSDecodableShape {
        /// Metadata about the action performed by the quantum task, including information about the type of action and program counts.
        public let actionMetadata: ActionMetadata?
        /// The list of Amazon Braket resources associated with the quantum task.
        public let associations: [Association]?
        /// The time at which the quantum task was created.
        public let createdAt: Date
        /// The ARN of the device the quantum task was run on.
        public let deviceArn: String
        /// The parameters for the device on which the quantum task ran.
        public let deviceParameters: String
        /// The time at which the quantum task ended.
        public let endedAt: Date?
        /// The reason that a quantum task failed.
        public let failureReason: String?
        /// The ARN of the Amazon Braket job associated with the quantum task.
        public let jobArn: String?
        /// The number of successful shots for the quantum task. This is available after a successfully completed quantum task.
        public let numSuccessfulShots: Int64?
        /// The S3 bucket where quantum task results are stored.
        public let outputS3Bucket: String
        /// The folder in the S3 bucket where quantum task results are stored.
        public let outputS3Directory: String
        /// The ARN of the quantum task.
        public let quantumTaskArn: String
        /// Queue information for the requested quantum task. Only returned if QueueInfo is specified in the additionalAttributeNames" field in the GetQuantumTask API request.
        public let queueInfo: QuantumTaskQueueInfo?
        /// The number of shots used in the quantum task.
        public let shots: Int64
        /// The status of the quantum task.
        public let status: QuantumTaskStatus
        /// The tags that belong to this quantum task.
        public let tags: [String: String]?

        @inlinable
        public init(actionMetadata: ActionMetadata? = nil, associations: [Association]? = nil, createdAt: Date, deviceArn: String, deviceParameters: String, endedAt: Date? = nil, failureReason: String? = nil, jobArn: String? = nil, numSuccessfulShots: Int64? = nil, outputS3Bucket: String, outputS3Directory: String, quantumTaskArn: String, queueInfo: QuantumTaskQueueInfo? = nil, shots: Int64, status: QuantumTaskStatus, tags: [String: String]? = nil) {
            self.actionMetadata = actionMetadata
            self.associations = associations
            self.createdAt = createdAt
            self.deviceArn = deviceArn
            self.deviceParameters = deviceParameters
            self.endedAt = endedAt
            self.failureReason = failureReason
            self.jobArn = jobArn
            self.numSuccessfulShots = numSuccessfulShots
            self.outputS3Bucket = outputS3Bucket
            self.outputS3Directory = outputS3Directory
            self.quantumTaskArn = quantumTaskArn
            self.queueInfo = queueInfo
            self.shots = shots
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case actionMetadata = "actionMetadata"
            case associations = "associations"
            case createdAt = "createdAt"
            case deviceArn = "deviceArn"
            case deviceParameters = "deviceParameters"
            case endedAt = "endedAt"
            case failureReason = "failureReason"
            case jobArn = "jobArn"
            case numSuccessfulShots = "numSuccessfulShots"
            case outputS3Bucket = "outputS3Bucket"
            case outputS3Directory = "outputS3Directory"
            case quantumTaskArn = "quantumTaskArn"
            case queueInfo = "queueInfo"
            case shots = "shots"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct HybridJobQueueInfo: AWSDecodableShape {
        /// Optional. Provides more information about the queue position. For example, if the hybrid job is complete and no longer in the queue, the message field contains that information.
        public let message: String?
        /// Current position of the hybrid job in the jobs queue.
        public let position: String
        /// The name of the queue.
        public let queue: QueueName

        @inlinable
        public init(message: String? = nil, position: String, queue: QueueName) {
            self.message = message
            self.position = position
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case position = "position"
            case queue = "queue"
        }
    }

    public struct InputFileConfig: AWSEncodableShape & AWSDecodableShape {
        /// A named input source that an Amazon Braket hybrid job can consume.
        public let channelName: String
        /// The MIME type of the data.
        public let contentType: String?
        /// The location of the input data.
        public let dataSource: DataSource

        @inlinable
        public init(channelName: String, contentType: String? = nil, dataSource: DataSource) {
            self.channelName = channelName
            self.contentType = contentType
            self.dataSource = dataSource
        }

        public func validate(name: String) throws {
            try self.validate(self.channelName, name: "channelName", parent: name, max: 64)
            try self.validate(self.channelName, name: "channelName", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.dataSource.validate(name: "\(name).dataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case channelName = "channelName"
            case contentType = "contentType"
            case dataSource = "dataSource"
        }
    }

    public struct InstanceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configures the number of resource instances to use while running an Amazon Braket hybrid job on Amazon Braket. The default value is 1.
        public let instanceCount: Int?
        /// Configures the type of resource instances to use while running an Amazon Braket hybrid job.
        public let instanceType: InstanceType
        /// The size of the storage volume, in GB, to provision.
        public let volumeSizeInGb: Int

        @inlinable
        public init(instanceCount: Int? = nil, instanceType: InstanceType, volumeSizeInGb: Int) {
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.volumeSizeInGb = volumeSizeInGb
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "instanceCount"
            case instanceType = "instanceType"
            case volumeSizeInGb = "volumeSizeInGb"
        }
    }

    public struct JobCheckpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// (Optional) The local directory where checkpoint data is stored. The default directory is /opt/braket/checkpoints/.
        public let localPath: String?
        /// Identifies the S3 path where you want Amazon Braket to store checkpoint data. For example, s3://bucket-name/key-name-prefix.
        public let s3Uri: String

        @inlinable
        public init(localPath: String? = nil, s3Uri: String) {
            self.localPath = localPath
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.localPath, name: "localPath", parent: name, max: 4096)
            try self.validate(self.localPath, name: "localPath", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case localPath = "localPath"
            case s3Uri = "s3Uri"
        }
    }

    public struct JobEventDetails: AWSDecodableShape {
        /// The type of event that occurred related to the Amazon Braket hybrid job.
        public let eventType: JobEventType?
        /// A message describing the event that occurred related to the Amazon Braket hybrid job.
        public let message: String?
        /// The time of the event that occurred related to the Amazon Braket hybrid job.
        public let timeOfEvent: Date?

        @inlinable
        public init(eventType: JobEventType? = nil, message: String? = nil, timeOfEvent: Date? = nil) {
            self.eventType = eventType
            self.message = message
            self.timeOfEvent = timeOfEvent
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "eventType"
            case message = "message"
            case timeOfEvent = "timeOfEvent"
        }
    }

    public struct JobOutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The AWS Key Management Service (AWS KMS) key that Amazon Braket uses to encrypt the hybrid job training artifacts at rest using Amazon S3 server-side encryption.
        public let kmsKeyId: String?
        /// Identifies the S3 path where you want Amazon Braket to store the hybrid job training artifacts. For example, s3://bucket-name/key-name-prefix.
        public let s3Path: String

        @inlinable
        public init(kmsKeyId: String? = nil, s3Path: String) {
            self.kmsKeyId = kmsKeyId
            self.s3Path = s3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.s3Path, name: "s3Path", parent: name, max: 1024)
            try self.validate(self.s3Path, name: "s3Path", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
            case s3Path = "s3Path"
        }
    }

    public struct JobStoppingCondition: AWSEncodableShape & AWSDecodableShape {
        /// The maximum length of time, in seconds, that an Amazon Braket hybrid job can run.
        public let maxRuntimeInSeconds: Int?

        @inlinable
        public init(maxRuntimeInSeconds: Int? = nil) {
            self.maxRuntimeInSeconds = maxRuntimeInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case maxRuntimeInSeconds = "maxRuntimeInSeconds"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The time at which the Amazon Braket hybrid job was created.
        public let createdAt: Date
        /// The primary device used by an Amazon Braket hybrid job.
        public let device: String
        /// The time at which the Amazon Braket hybrid job ended.
        public let endedAt: Date?
        /// The ARN of the Amazon Braket hybrid job.
        public let jobArn: String
        /// The name of the Amazon Braket hybrid job.
        public let jobName: String
        /// The time at which the Amazon Braket hybrid job was started.
        public let startedAt: Date?
        /// The status of the Amazon Braket hybrid job.
        public let status: JobPrimaryStatus
        /// Displays the key, value pairs of tags associated with this hybrid job.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, device: String, endedAt: Date? = nil, jobArn: String, jobName: String, startedAt: Date? = nil, status: JobPrimaryStatus, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.device = device
            self.endedAt = endedAt
            self.jobArn = jobArn
            self.jobName = jobName
            self.startedAt = startedAt
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case device = "device"
            case endedAt = "endedAt"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case startedAt = "startedAt"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// Specify the resourceArn for the resource whose tags to display.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Displays the key, value pairs of tags associated with this resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ProgramSetValidationFailure: AWSDecodableShape {
        /// A list of error messages describing the validation failures that occurred.
        public let errors: [String]?
        /// The index of the input within the program set that failed validation.
        public let inputsIndex: Int64?
        /// The index of the program within the program set that failed validation.
        public let programIndex: Int64

        @inlinable
        public init(errors: [String]? = nil, inputsIndex: Int64? = nil, programIndex: Int64) {
            self.errors = errors
            self.inputsIndex = inputsIndex
            self.programIndex = programIndex
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case inputsIndex = "inputsIndex"
            case programIndex = "programIndex"
        }
    }

    public struct QuantumTaskQueueInfo: AWSDecodableShape {
        /// Optional. Provides more information about the queue position. For example, if the quantum task is complete and no longer in the queue, the message field contains that information.
        public let message: String?
        /// Current position of the quantum task in the quantum tasks queue.
        public let position: String
        /// The name of the queue.
        public let queue: QueueName
        /// Optional. Specifies the priority of the queue. Quantum tasks in a priority queue are processed before the quantum tasks in a normal queue.
        public let queuePriority: QueuePriority?

        @inlinable
        public init(message: String? = nil, position: String, queue: QueueName, queuePriority: QueuePriority? = nil) {
            self.message = message
            self.position = position
            self.queue = queue
            self.queuePriority = queuePriority
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case position = "position"
            case queue = "queue"
            case queuePriority = "queuePriority"
        }
    }

    public struct QuantumTaskSummary: AWSDecodableShape {
        /// The time at which the quantum task was created.
        public let createdAt: Date
        /// The ARN of the device the quantum task ran on.
        public let deviceArn: String
        /// The time at which the quantum task finished.
        public let endedAt: Date?
        /// The S3 bucket where the quantum task result file is stored.
        public let outputS3Bucket: String
        /// The folder in the S3 bucket where the quantum task result file is stored.
        public let outputS3Directory: String
        /// The ARN of the quantum task.
        public let quantumTaskArn: String
        /// The shots used for the quantum task.
        public let shots: Int64
        /// The status of the quantum task.
        public let status: QuantumTaskStatus
        /// Displays the key, value pairs of tags associated with this quantum task.
        public let tags: [String: String]?

        @inlinable
        public init(createdAt: Date, deviceArn: String, endedAt: Date? = nil, outputS3Bucket: String, outputS3Directory: String, quantumTaskArn: String, shots: Int64, status: QuantumTaskStatus, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.deviceArn = deviceArn
            self.endedAt = endedAt
            self.outputS3Bucket = outputS3Bucket
            self.outputS3Directory = outputS3Directory
            self.quantumTaskArn = quantumTaskArn
            self.shots = shots
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case deviceArn = "deviceArn"
            case endedAt = "endedAt"
            case outputS3Bucket = "outputS3Bucket"
            case outputS3Directory = "outputS3Directory"
            case quantumTaskArn = "quantumTaskArn"
            case shots = "shots"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct S3DataSource: AWSEncodableShape & AWSDecodableShape {
        /// Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest that locates the S3 data source.
        public let s3Uri: String

        @inlinable
        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct ScriptModeConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of compression used to store the algorithm scripts in Amazon S3 storage.
        public let compressionType: CompressionType?
        /// The entry point in the algorithm scripts from where the execution begins in the hybrid job.
        public let entryPoint: String
        /// The URI that specifies the S3 path to the algorithm scripts used by an Amazon Braket hybrid job.
        public let s3Uri: String

        @inlinable
        public init(compressionType: CompressionType? = nil, entryPoint: String, s3Uri: String) {
            self.compressionType = compressionType
            self.entryPoint = entryPoint
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case compressionType = "compressionType"
            case entryPoint = "entryPoint"
            case s3Uri = "s3Uri"
        }
    }

    public struct SearchDevicesFilter: AWSEncodableShape {
        /// The name of the device parameter to filter based on. Only deviceArn filter name is currently supported.
        public let name: String
        /// The values used to filter devices based on the filter name.
        public let values: [String]

        @inlinable
        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct SearchDevicesRequest: AWSEncodableShape {
        /// Array of SearchDevicesFilter objects to use when searching for devices.
        public let filters: [SearchDevicesFilter]
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue search where the previous request ended.
        public let nextToken: String?

        @inlinable
        public init(filters: [SearchDevicesFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchDevicesResponse: AWSDecodableShape {
        /// An array of DeviceSummary objects for devices that match the specified filter values.
        public let devices: [DeviceSummary]
        /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue search where the previous request ended.
        public let nextToken: String?

        @inlinable
        public init(devices: [DeviceSummary], nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "devices"
            case nextToken = "nextToken"
        }
    }

    public struct SearchJobsFilter: AWSEncodableShape {
        /// The name of the hybrid job parameter to filter based on. Filter name can be either jobArn or createdAt.
        public let name: String
        /// An operator to use for the filter.
        public let `operator`: SearchJobsFilterOperator
        /// The values used to filter hybrid jobs based on the filter name and operator.
        public let values: [String]

        @inlinable
        public init(name: String, operator: SearchJobsFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SearchJobsRequest: AWSEncodableShape {
        /// Array of SearchJobsFilter objects to use when searching for hybrid jobs.
        public let filters: [SearchJobsFilter]
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue search where the previous request ended.
        public let nextToken: String?

        @inlinable
        public init(filters: [SearchJobsFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchJobsResponse: AWSDecodableShape {
        /// An array of JobSummary objects for devices that match the specified filter values.
        public let jobs: [JobSummary]
        /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue search where the previous request ended.
        public let nextToken: String?

        @inlinable
        public init(jobs: [JobSummary], nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct SearchQuantumTasksFilter: AWSEncodableShape {
        /// The name of the quantum task parameter to filter based on. Filter name can be either quantumTaskArn, deviceArn, jobArn, status or createdAt.
        public let name: String
        /// An operator to use for the filter.
        public let `operator`: SearchQuantumTasksFilterOperator
        /// The values used to filter quantum tasks based on the filter name and operator.
        public let values: [String]

        @inlinable
        public init(name: String, operator: SearchQuantumTasksFilterOperator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct SearchQuantumTasksRequest: AWSEncodableShape {
        /// Array of SearchQuantumTasksFilter objects to use when searching for quantum tasks.
        public let filters: [SearchQuantumTasksFilter]
        /// Maximum number of results to return in the response.
        public let maxResults: Int?
        /// A token used for pagination of results returned in the response. Use the token returned from the previous request to continue search where the previous request ended.
        public let nextToken: String?

        @inlinable
        public init(filters: [SearchQuantumTasksFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchQuantumTasksResponse: AWSDecodableShape {
        /// A token used for pagination of results, or null if there are no additional results. Use the token value in a subsequent request to continue search where the previous request ended.
        public let nextToken: String?
        /// An array of QuantumTaskSummary objects for quantum tasks that match the specified filters.
        public let quantumTasks: [QuantumTaskSummary]

        @inlinable
        public init(nextToken: String? = nil, quantumTasks: [QuantumTaskSummary]) {
            self.nextToken = nextToken
            self.quantumTasks = quantumTasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case quantumTasks = "quantumTasks"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Specify the resourceArn of the resource to which a tag will be added.
        public let resourceArn: String
        /// Specify the tags to add to the resource. Tags can be specified as a key-value map.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Specify the resourceArn for the resource from which to remove the tags.
        public let resourceArn: String
        /// Specify the keys for the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ValidationException: AWSErrorShape {
        public let message: String?
        /// The validation failures in the program set submitted in the request.
        public let programSetValidationFailures: [ProgramSetValidationFailure]?
        /// The reason for validation failure.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(message: String? = nil, programSetValidationFailures: [ProgramSetValidationFailure]? = nil, reason: ValidationExceptionReason? = nil) {
            self.message = message
            self.programSetValidationFailures = programSetValidationFailures
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case programSetValidationFailures = "programSetValidationFailures"
            case reason = "reason"
        }
    }
}

// MARK: - Errors

/// Error enum for Braket
public struct BraketErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case deviceOfflineException = "DeviceOfflineException"
        case deviceRetiredException = "DeviceRetiredException"
        case internalServiceException = "InternalServiceException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Braket
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// An error occurred due to a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// The specified device is currently offline.
    public static var deviceOfflineException: Self { .init(.deviceOfflineException) }
    /// The specified device has been retired.
    public static var deviceRetiredException: Self { .init(.deviceRetiredException) }
    /// The request failed because of an unknown error.
    public static var internalServiceException: Self { .init(.internalServiceException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request failed because a service quota is exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The API throttling rate limit is exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input request failed to satisfy constraints expected by Amazon Braket.
    public static var validationException: Self { .init(.validationException) }
}

extension BraketErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": Braket.ValidationException.self
    ]
}

extension BraketErrorType: Equatable {
    public static func == (lhs: BraketErrorType, rhs: BraketErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BraketErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
