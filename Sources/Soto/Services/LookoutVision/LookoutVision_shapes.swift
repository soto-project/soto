//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension LookoutVision {
    // MARK: Enums

    public enum DatasetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createComplete = "CREATE_COMPLETE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteComplete = "DELETE_COMPLETE"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateComplete = "UPDATE_COMPLETE"
        case updateFailedRollbackComplete = "UPDATE_FAILED_ROLLBACK_COMPLETE"
        case updateFailedRollbackInProgress = "UPDATE_FAILED_ROLLBACK_IN_PROGRESS"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ModelHostingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hosted = "HOSTED"
        case hostingFailed = "HOSTING_FAILED"
        case startingHosting = "STARTING_HOSTING"
        case stoppingHosting = "STOPPING_HOSTING"
        case systemUpdating = "SYSTEM_UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ModelPackagingJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ModelStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case hosted = "HOSTED"
        case hostingFailed = "HOSTING_FAILED"
        case startingHosting = "STARTING_HOSTING"
        case stoppingHosting = "STOPPING_HOSTING"
        case systemUpdating = "SYSTEM_UPDATING"
        case trained = "TRAINED"
        case training = "TRAINING"
        case trainingFailed = "TRAINING_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum TargetDevice: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jetsonXavier = "jetson_xavier"
        public var description: String { return self.rawValue }
    }

    public enum TargetPlatformAccelerator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nvidia = "NVIDIA"
        public var description: String { return self.rawValue }
    }

    public enum TargetPlatformArch: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arm64 = "ARM64"
        case x8664 = "X86_64"
        public var description: String { return self.rawValue }
    }

    public enum TargetPlatformOs: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Anomaly: AWSDecodableShape {
        /// The name of an anomaly type found in an image.   Name maps to an anomaly type in the training dataset, apart from the anomaly type background. The service automatically inserts the background anomaly type into the response from DetectAnomalies.
        public let name: String?
        /// Information about the pixel mask that covers an anomaly type.
        public let pixelAnomaly: PixelAnomaly?

        public init(name: String? = nil, pixelAnomaly: PixelAnomaly? = nil) {
            self.name = name
            self.pixelAnomaly = pixelAnomaly
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case pixelAnomaly = "PixelAnomaly"
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to CreateDataset completes only once.  You choose the value to pass. For example, An issue might prevent you from getting a response from CreateDataset. In this case, safely retry your call to CreateDataset by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple dataset creation requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to CreateDataset. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The location of the manifest file that Amazon Lookout for Vision uses to create the dataset. If you don't specify DatasetSource, an empty dataset is created and the operation  synchronously returns. Later, you can add JSON Lines by calling UpdateDatasetEntries.  If you specify a value for DataSource, the manifest at the S3 location is validated and used to create the dataset. The call to CreateDataset is asynchronous and might take a while to complete. To find out the current status, Check the value of Status returned in a call to DescribeDataset.
        public let datasetSource: DatasetSource?
        /// The type of the dataset. Specify train for a training dataset. Specify test for a test dataset.
        public let datasetType: String?
        /// The name of the project in which you want to create a dataset.
        public let projectName: String

        public init(clientToken: String? = CreateDatasetRequest.idempotencyToken(), datasetSource: DatasetSource? = nil, datasetType: String? = nil, projectName: String) {
            self.clientToken = clientToken
            self.datasetSource = datasetSource
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.datasetSource, forKey: .datasetSource)
            try container.encodeIfPresent(self.datasetType, forKey: .datasetType)
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.datasetSource?.validate(name: "\(name).datasetSource")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "^train|test$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetSource = "DatasetSource"
            case datasetType = "DatasetType"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// Information about the dataset.
        public let datasetMetadata: DatasetMetadata?

        public init(datasetMetadata: DatasetMetadata? = nil) {
            self.datasetMetadata = datasetMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case datasetMetadata = "DatasetMetadata"
        }
    }

    public struct CreateModelRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to CreateModel completes only once.  You choose the value to pass. For example, An issue might prevent you from getting a response from CreateModel. In this case, safely retry your call to CreateModel by using the same ClientToken parameter value.  If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from starting multiple training jobs. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to CreateModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// A description for the version of the model.
        public let description: String?
        /// The identifier for your AWS KMS key. The key is used to encrypt training and test images copied into the service for model training. Your  source images are unaffected. If this parameter is not specified, the copied images are encrypted by a key that AWS owns and manages.
        public let kmsKeyId: String?
        /// The location where Amazon Lookout for Vision saves the training results.
        public let outputConfig: OutputConfig?
        /// The name of the project in which you want to create a model version.
        public let projectName: String
        /// A set of tags (key-value pairs) that you want to attach to the model.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateModelRequest.idempotencyToken(), description: String? = nil, kmsKeyId: String? = nil, outputConfig: OutputConfig? = nil, projectName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.outputConfig = outputConfig
            self.projectName = projectName
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.kmsKeyId, forKey: .kmsKeyId)
            try container.encodeIfPresent(self.outputConfig, forKey: .outputConfig)
            request.encodePath(self.projectName, key: "ProjectName")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,2048}$")
            try self.outputConfig?.validate(name: "\(name).outputConfig")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case outputConfig = "OutputConfig"
            case tags = "Tags"
        }
    }

    public struct CreateModelResponse: AWSDecodableShape {
        /// The response from a call to CreateModel.
        public let modelMetadata: ModelMetadata?

        public init(modelMetadata: ModelMetadata? = nil) {
            self.modelMetadata = modelMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case modelMetadata = "ModelMetadata"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to CreateProject completes only once.  You choose the value to pass. For example, An issue might prevent you from  getting a response from CreateProject. In this case, safely retry your call to CreateProject by using the same ClientToken parameter value.  If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple project creation requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to CreateProject. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The name for the project.
        public let projectName: String?

        public init(clientToken: String? = CreateProjectRequest.idempotencyToken(), projectName: String? = nil) {
            self.clientToken = clientToken
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.projectName, forKey: .projectName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectName = "ProjectName"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// Information about the project.
        public let projectMetadata: ProjectMetadata?

        public init(projectMetadata: ProjectMetadata? = nil) {
            self.projectMetadata = projectMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case projectMetadata = "ProjectMetadata"
        }
    }

    public struct DatasetDescription: AWSDecodableShape {
        /// The Unix timestamp for the time and date that the dataset was created.
        public let creationTimestamp: Date?
        /// The type of the dataset. The value train represents a training dataset or single dataset project. The value test represents a test dataset.
        public let datasetType: String?
        /// Statistics about the images in a dataset.
        public let imageStats: DatasetImageStats?
        /// The Unix timestamp for the date and time that the dataset was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The name of the project that contains the dataset.
        public let projectName: String?
        /// The status of the dataset.
        public let status: DatasetStatus?
        /// The status message for the dataset.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, datasetType: String? = nil, imageStats: DatasetImageStats? = nil, lastUpdatedTimestamp: Date? = nil, projectName: String? = nil, status: DatasetStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.imageStats = imageStats
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case datasetType = "DatasetType"
            case imageStats = "ImageStats"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case projectName = "ProjectName"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DatasetGroundTruthManifest: AWSEncodableShape {
        /// The S3 bucket location for the manifest file.
        public let s3Object: InputS3Object?

        public init(s3Object: InputS3Object? = nil) {
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.s3Object?.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "S3Object"
        }
    }

    public struct DatasetImageStats: AWSDecodableShape {
        /// the total number of images labeled as an anomaly.
        public let anomaly: Int?
        /// The total number of labeled images.
        public let labeled: Int?
        /// The total number of images labeled as normal.
        public let normal: Int?
        /// The total number of images in the dataset.
        public let total: Int?

        public init(anomaly: Int? = nil, labeled: Int? = nil, normal: Int? = nil, total: Int? = nil) {
            self.anomaly = anomaly
            self.labeled = labeled
            self.normal = normal
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case anomaly = "Anomaly"
            case labeled = "Labeled"
            case normal = "Normal"
            case total = "Total"
        }
    }

    public struct DatasetMetadata: AWSDecodableShape {
        /// The Unix timestamp for the date and time that the dataset was created.
        public let creationTimestamp: Date?
        /// The type of the dataset.
        public let datasetType: String?
        /// The status for the dataset.
        public let status: DatasetStatus?
        /// The status message for the dataset.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, datasetType: String? = nil, status: DatasetStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case datasetType = "DatasetType"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DatasetSource: AWSEncodableShape {
        /// Location information for the manifest file.
        public let groundTruthManifest: DatasetGroundTruthManifest?

        public init(groundTruthManifest: DatasetGroundTruthManifest? = nil) {
            self.groundTruthManifest = groundTruthManifest
        }

        public func validate(name: String) throws {
            try self.groundTruthManifest?.validate(name: "\(name).groundTruthManifest")
        }

        private enum CodingKeys: String, CodingKey {
            case groundTruthManifest = "GroundTruthManifest"
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to DeleteDataset completes only once.  You choose the value to pass. For example, An issue might prevent you from getting a response from DeleteDataset. In this case, safely retry your call to DeleteDataset by using the same ClientToken parameter value.  If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple deletetion requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to DeleteDataset. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The type of the dataset to delete. Specify train to delete the training dataset. Specify test to delete the test dataset. To delete the dataset in a single dataset project,  specify train.
        public let datasetType: String
        /// The name of the project that contains the dataset that you want to delete.
        public let projectName: String

        public init(clientToken: String? = DeleteDatasetRequest.idempotencyToken(), datasetType: String, projectName: String) {
            self.clientToken = clientToken
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.datasetType, key: "DatasetType")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "^train|test$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatasetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to DeleteModel completes only once.  You choose the value to pass. For example, an issue might prevent you from getting a response from DeleteModel. In this case, safely retry your call to DeleteModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple model deletion requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to DeleteModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The version of the model that you want to delete.
        public let modelVersion: String
        /// The name of the project that contains the model that you want to delete.
        public let projectName: String

        public init(clientToken: String? = DeleteModelRequest.idempotencyToken(), modelVersion: String, projectName: String) {
            self.clientToken = clientToken
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.modelVersion, key: "ModelVersion")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "^([1-9][0-9]*)$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteModelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model that was deleted.
        public let modelArn: String?

        public init(modelArn: String? = nil) {
            self.modelArn = modelArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "ModelArn"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to DeleteProject completes only once.  You choose the value to pass. For example, An issue might prevent you from getting a response from DeleteProject. In this case, safely retry your call to DeleteProject by using the same ClientToken parameter value.  If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple project deletion requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to DeleteProject. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The name of the project to delete.
        public let projectName: String

        public init(clientToken: String? = DeleteProjectRequest.idempotencyToken(), projectName: String) {
            self.clientToken = clientToken
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the project that was deleted.
        public let projectArn: String?

        public init(projectArn: String? = nil) {
            self.projectArn = projectArn
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "ProjectArn"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        /// The type of the dataset to describe. Specify train to describe the  training dataset. Specify test to describe the test dataset. If you have a single dataset project, specify train
        public let datasetType: String
        /// The name of the project that contains the dataset that you want to describe.
        public let projectName: String

        public init(datasetType: String, projectName: String) {
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.datasetType, key: "DatasetType")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "^train|test$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// The description of the requested dataset.
        public let datasetDescription: DatasetDescription?

        public init(datasetDescription: DatasetDescription? = nil) {
            self.datasetDescription = datasetDescription
        }

        private enum CodingKeys: String, CodingKey {
            case datasetDescription = "DatasetDescription"
        }
    }

    public struct DescribeModelPackagingJobRequest: AWSEncodableShape {
        /// The job name for the model packaging job.
        public let jobName: String
        /// The name of the project that contains the model packaging job that you want to describe.
        public let projectName: String

        public init(jobName: String, projectName: String) {
            self.jobName = jobName
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobName, key: "JobName")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeModelPackagingJobResponse: AWSDecodableShape {
        /// The description of the model packaging job.
        public let modelPackagingDescription: ModelPackagingDescription?

        public init(modelPackagingDescription: ModelPackagingDescription? = nil) {
            self.modelPackagingDescription = modelPackagingDescription
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackagingDescription = "ModelPackagingDescription"
        }
    }

    public struct DescribeModelRequest: AWSEncodableShape {
        /// The version of the model that you want to describe.
        public let modelVersion: String
        /// The project that contains the version of a model that you want to describe.
        public let projectName: String

        public init(modelVersion: String, projectName: String) {
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelVersion, key: "ModelVersion")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "^([1-9][0-9]*|latest)$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeModelResponse: AWSDecodableShape {
        /// Contains the description of the model.
        public let modelDescription: ModelDescription?

        public init(modelDescription: ModelDescription? = nil) {
            self.modelDescription = modelDescription
        }

        private enum CodingKeys: String, CodingKey {
            case modelDescription = "ModelDescription"
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        /// The name of the project that you want to describe.
        public let projectName: String

        public init(projectName: String) {
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The description of the project.
        public let projectDescription: ProjectDescription?

        public init(projectDescription: ProjectDescription? = nil) {
            self.projectDescription = projectDescription
        }

        private enum CodingKeys: String, CodingKey {
            case projectDescription = "ProjectDescription"
        }
    }

    public struct DetectAnomaliesRequest: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming]
        /// The unencrypted image bytes that you want to analyze.
        public let body: AWSHTTPBody?
        /// The type of the image passed in Body. Valid values are image/png (PNG format images) and image/jpeg (JPG format images).
        public let contentType: String?
        /// The version of the model that you want to use.
        public let modelVersion: String
        /// The name of the project that contains the model version that you want to use.
        public let projectName: String

        public init(body: AWSHTTPBody? = nil, contentType: String? = nil, modelVersion: String, projectName: String) {
            self.body = body
            self.contentType = contentType
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            try container.encode(self.body)
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodePath(self.modelVersion, key: "ModelVersion")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, max: 255)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: ".*")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "^([1-9][0-9]*|latest)$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DetectAnomaliesResponse: AWSDecodableShape {
        /// The results of the DetectAnomalies operation.
        public let detectAnomalyResult: DetectAnomalyResult?

        public init(detectAnomalyResult: DetectAnomalyResult? = nil) {
            self.detectAnomalyResult = detectAnomalyResult
        }

        private enum CodingKeys: String, CodingKey {
            case detectAnomalyResult = "DetectAnomalyResult"
        }
    }

    public struct DetectAnomalyResult: AWSDecodableShape {
        /// If the model is an image segmentation model, Anomalies contains a list of anomaly types found in the image. There is one entry for each type of anomaly found (even if multiple instances of an anomaly type exist on the image). The first element in the list is always an anomaly type representing the image background ('background') and shouldn't be considered an anomaly. Amazon Lookout for Vision automatically add the background anomaly type to the response, and you don't need to declare a background anomaly type in your dataset. If the list has one entry ('background'), no anomalies were found on the image.  An image classification model doesn't return an Anomalies list.
        public let anomalies: [Anomaly]?
        /// If the model is an image segmentation model, AnomalyMask contains pixel masks that covers all anomaly types found on the image.  Each anomaly type has a different mask color. To map a color to an anomaly type, see the color field of the PixelAnomaly object. An image classification model doesn't return an Anomalies list.
        public let anomalyMask: AWSBase64Data?
        /// The confidence that Lookout for Vision has in the accuracy of the classification in IsAnomalous.
        public let confidence: Float?
        /// True if Amazon Lookout for Vision classifies the image as containing an anomaly, otherwise false.
        public let isAnomalous: Bool?
        /// The source of the image that was analyzed. direct means that the images was supplied from the local computer. No other values are supported.
        public let source: ImageSource?

        public init(anomalies: [Anomaly]? = nil, anomalyMask: AWSBase64Data? = nil, confidence: Float? = nil, isAnomalous: Bool? = nil, source: ImageSource? = nil) {
            self.anomalies = anomalies
            self.anomalyMask = anomalyMask
            self.confidence = confidence
            self.isAnomalous = isAnomalous
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case anomalies = "Anomalies"
            case anomalyMask = "AnomalyMask"
            case confidence = "Confidence"
            case isAnomalous = "IsAnomalous"
            case source = "Source"
        }
    }

    public struct GreengrassConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Additional compiler options for the Greengrass component. Currently,  only NVIDIA Graphics Processing Units (GPU) and CPU accelerators are supported.  If you specify TargetDevice, don't specify CompilerOptions. For more information, see  Compiler options in the  Amazon Lookout for Vision Developer Guide.
        public let compilerOptions: String?
        ///  A description for the AWS IoT Greengrass component.
        public let componentDescription: String?
        ///  A name for the AWS IoT Greengrass component.
        public let componentName: String?
        /// A Version for the AWS IoT Greengrass component. If you don't provide a value, a default value of  Model Version.0.0 is used.
        public let componentVersion: String?
        ///  An S3 location in which Lookout for Vision stores the component artifacts.
        public let s3OutputLocation: S3Location?
        ///  A set of tags (key-value pairs) that you want to attach to the AWS IoT Greengrass component.
        public let tags: [Tag]?
        /// The target device for the model. Currently the only supported value is jetson_xavier. If you specify TargetDevice, you can't specify TargetPlatform.
        public let targetDevice: TargetDevice?
        /// The target platform for the model. If you specify TargetPlatform, you can't specify TargetDevice.
        public let targetPlatform: TargetPlatform?

        public init(compilerOptions: String? = nil, componentDescription: String? = nil, componentName: String? = nil, componentVersion: String? = nil, s3OutputLocation: S3Location? = nil, tags: [Tag]? = nil, targetDevice: TargetDevice? = nil, targetPlatform: TargetPlatform? = nil) {
            self.compilerOptions = compilerOptions
            self.componentDescription = componentDescription
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.s3OutputLocation = s3OutputLocation
            self.tags = tags
            self.targetDevice = targetDevice
            self.targetPlatform = targetPlatform
        }

        public func validate(name: String) throws {
            try self.validate(self.compilerOptions, name: "compilerOptions", parent: name, max: 1024)
            try self.validate(self.compilerOptions, name: "compilerOptions", parent: name, min: 3)
            try self.validate(self.compilerOptions, name: "compilerOptions", parent: name, pattern: ".*")
            try self.validate(self.componentDescription, name: "componentDescription", parent: name, max: 256)
            try self.validate(self.componentDescription, name: "componentDescription", parent: name, min: 1)
            try self.validate(self.componentDescription, name: "componentDescription", parent: name, pattern: "^[a-zA-Z0-9-_. ()':,;?]+$")
            try self.validate(self.componentName, name: "componentName", parent: name, max: 128)
            try self.validate(self.componentName, name: "componentName", parent: name, min: 1)
            try self.validate(self.componentName, name: "componentName", parent: name, pattern: "^[a-zA-Z0-9-_.]+$")
            try self.validate(self.componentVersion, name: "componentVersion", parent: name, max: 64)
            try self.validate(self.componentVersion, name: "componentVersion", parent: name, min: 1)
            try self.validate(self.componentVersion, name: "componentVersion", parent: name, pattern: "^([0-9]{1,6})\\.([0-9]{1,6})\\.([0-9]{1,6})$")
            try self.s3OutputLocation?.validate(name: "\(name).s3OutputLocation")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case compilerOptions = "CompilerOptions"
            case componentDescription = "ComponentDescription"
            case componentName = "ComponentName"
            case componentVersion = "ComponentVersion"
            case s3OutputLocation = "S3OutputLocation"
            case tags = "Tags"
            case targetDevice = "TargetDevice"
            case targetPlatform = "TargetPlatform"
        }
    }

    public struct GreengrassOutputDetails: AWSDecodableShape {
        /// The name of the component.
        public let componentName: String?
        /// The version of the component.
        public let componentVersion: String?
        /// The Amazon Resource Name (ARN) of the component.
        public let componentVersionArn: String?

        public init(componentName: String? = nil, componentVersion: String? = nil, componentVersionArn: String? = nil) {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.componentVersionArn = componentVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "ComponentName"
            case componentVersion = "ComponentVersion"
            case componentVersionArn = "ComponentVersionArn"
        }
    }

    public struct ImageSource: AWSDecodableShape {
        /// The type of the image.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct InputS3Object: AWSEncodableShape {
        /// The Amazon S3 bucket that contains the manifest.
        public let bucket: String?
        /// The name and location of the manifest file withiin the bucket.
        public let key: String?
        /// The version ID of the bucket.
        public let versionId: String?

        public init(bucket: String? = nil, key: String? = nil, versionId: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*$")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([a-zA-Z0-9!_.*'()-][/a-zA-Z0-9!_.*'()-]*)?$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 1024)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
            case versionId = "VersionId"
        }
    }

    public struct ListDatasetEntriesRequest: AWSEncodableShape {
        /// Only includes entries after the specified date in the response. For example, 2020-06-23T00:00:00.
        public let afterCreationDate: Date?
        /// Specify normal to include only normal images. Specify anomaly to only include anomalous entries. If you don't specify a value, Amazon Lookout for Vision returns normal and anomalous images.
        public let anomalyClass: String?
        /// Only includes entries before the specified date in the response. For example, 2020-06-23T00:00:00.
        public let beforeCreationDate: Date?
        /// The type of the dataset that you want to list.  Specify train to list  the training dataset. Specify test to list the test dataset. If you have a single dataset project, specify train.
        public let datasetType: String
        /// Specify true to include labeled entries, otherwise specify false. If you don't specify a value, Lookout for Vision returns all entries.
        public let labeled: Bool?
        /// The maximum number of results to return per paginated call. The largest value you can specify is 100.  If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of dataset entries.
        public let nextToken: String?
        /// The name of the project that contains the dataset that you want to list.
        public let projectName: String
        /// Perform a "contains" search on the  values of the source-ref key within the dataset.  For example a value of "IMG_17"  returns all JSON Lines where the source-ref key value matches *IMG_17*.
        public let sourceRefContains: String?

        public init(afterCreationDate: Date? = nil, anomalyClass: String? = nil, beforeCreationDate: Date? = nil, datasetType: String, labeled: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectName: String, sourceRefContains: String? = nil) {
            self.afterCreationDate = afterCreationDate
            self.anomalyClass = anomalyClass
            self.beforeCreationDate = beforeCreationDate
            self.datasetType = datasetType
            self.labeled = labeled
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectName = projectName
            self.sourceRefContains = sourceRefContains
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.afterCreationDate, key: "createdAfter")
            request.encodeQuery(self.anomalyClass, key: "anomalyClass")
            request.encodeQuery(self.beforeCreationDate, key: "createdBefore")
            request.encodePath(self.datasetType, key: "DatasetType")
            request.encodeQuery(self.labeled, key: "labeled")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.projectName, key: "ProjectName")
            request.encodeQuery(self.sourceRefContains, key: "sourceRefContains")
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyClass, name: "anomalyClass", parent: name, max: 10)
            try self.validate(self.anomalyClass, name: "anomalyClass", parent: name, min: 1)
            try self.validate(self.anomalyClass, name: "anomalyClass", parent: name, pattern: "^(normal|anomaly)$")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "^train|test$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\=]{0,2048}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
            try self.validate(self.sourceRefContains, name: "sourceRefContains", parent: name, max: 2048)
            try self.validate(self.sourceRefContains, name: "sourceRefContains", parent: name, min: 1)
            try self.validate(self.sourceRefContains, name: "sourceRefContains", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatasetEntriesResponse: AWSDecodableShape {
        /// A list of the entries (JSON Lines) within the dataset.
        public let datasetEntries: [String]?
        /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set ofdataset entries.
        public let nextToken: String?

        public init(datasetEntries: [String]? = nil, nextToken: String? = nil) {
            self.datasetEntries = datasetEntries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetEntries = "DatasetEntries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelPackagingJobsRequest: AWSEncodableShape {
        /// The maximum number of results to return per paginated call. The largest value you can specify is 100.  If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more results to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination  token to retrieve the next set of results.
        public let nextToken: String?
        /// The name of the project for which you want to list the model packaging jobs.
        public let projectName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\=]{0,2048}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelPackagingJobsResponse: AWSDecodableShape {
        /// A list of the model packaging jobs created for the specified Amazon Lookout for Vision project.
        public let modelPackagingJobs: [ModelPackagingJobMetadata]?
        /// If the previous response was incomplete (because there is more results to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination  token to retrieve the next set of results.
        public let nextToken: String?

        public init(modelPackagingJobs: [ModelPackagingJobMetadata]? = nil, nextToken: String? = nil) {
            self.modelPackagingJobs = modelPackagingJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelPackagingJobs = "ModelPackagingJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelsRequest: AWSEncodableShape {
        /// The maximum number of results to return per paginated call. The largest value you can specify is 100.  If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of models.
        public let nextToken: String?
        /// The name of the project that contains the model versions that you want to list.
        public let projectName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\=]{0,2048}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelsResponse: AWSDecodableShape {
        /// A list of model versions in the specified project.
        public let models: [ModelMetadata]?
        /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of models.
        public let nextToken: String?

        public init(models: [ModelMetadata]? = nil, nextToken: String? = nil) {
            self.models = models
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case models = "Models"
            case nextToken = "NextToken"
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        /// The maximum number of results to return per paginated call. The largest value you can specify is 100.  If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of projects.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\=]{0,2048}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of projects.
        public let nextToken: String?
        /// A list of projects in your AWS account.
        public let projects: [ProjectMetadata]?

        public init(nextToken: String? = nil, projects: [ProjectMetadata]? = nil) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case projects = "Projects"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the model for which you want to list tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of tag keys and values attached to the specified model.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ModelDescription: AWSDecodableShape {
        /// The unix timestamp for the date and time that the model was created.
        public let creationTimestamp: Date?
        /// The description for the model.
        public let description: String?
        /// The unix timestamp for the date and time that the evaluation ended.
        public let evaluationEndTimestamp: Date?
        /// The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.
        public let evaluationManifest: OutputS3Object?
        /// The S3 location where Amazon Lookout for Vision saves the performance metrics.
        public let evaluationResult: OutputS3Object?
        /// The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.
        public let kmsKeyId: String?
        /// The maximum number of inference units Amazon Lookout for Vision uses to auto-scale the model. For more information, see StartModel.
        public let maxInferenceUnits: Int?
        /// The minimum number of inference units used by the model. For more information, see StartModel
        public let minInferenceUnits: Int?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String?
        /// The version of the model
        public let modelVersion: String?
        /// The S3 location where Amazon Lookout for Vision saves model training files.
        public let outputConfig: OutputConfig?
        /// Performance metrics for the model. Created during training.
        public let performance: ModelPerformance?
        /// The status of the model.
        public let status: ModelStatus?
        /// The status message for the model.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, description: String? = nil, evaluationEndTimestamp: Date? = nil, evaluationManifest: OutputS3Object? = nil, evaluationResult: OutputS3Object? = nil, kmsKeyId: String? = nil, maxInferenceUnits: Int? = nil, minInferenceUnits: Int? = nil, modelArn: String? = nil, modelVersion: String? = nil, outputConfig: OutputConfig? = nil, performance: ModelPerformance? = nil, status: ModelStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.evaluationEndTimestamp = evaluationEndTimestamp
            self.evaluationManifest = evaluationManifest
            self.evaluationResult = evaluationResult
            self.kmsKeyId = kmsKeyId
            self.maxInferenceUnits = maxInferenceUnits
            self.minInferenceUnits = minInferenceUnits
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.outputConfig = outputConfig
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case description = "Description"
            case evaluationEndTimestamp = "EvaluationEndTimestamp"
            case evaluationManifest = "EvaluationManifest"
            case evaluationResult = "EvaluationResult"
            case kmsKeyId = "KmsKeyId"
            case maxInferenceUnits = "MaxInferenceUnits"
            case minInferenceUnits = "MinInferenceUnits"
            case modelArn = "ModelArn"
            case modelVersion = "ModelVersion"
            case outputConfig = "OutputConfig"
            case performance = "Performance"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ModelMetadata: AWSDecodableShape {
        /// The unix timestamp for the date and time that the model was created.
        public let creationTimestamp: Date?
        /// The description for the model.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String?
        /// The version of the model.
        public let modelVersion: String?
        /// Performance metrics for the model. Not available until training has successfully completed.
        public let performance: ModelPerformance?
        /// The status of the model.
        public let status: ModelStatus?
        /// The status message for the model.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, description: String? = nil, modelArn: String? = nil, modelVersion: String? = nil, performance: ModelPerformance? = nil, status: ModelStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case description = "Description"
            case modelArn = "ModelArn"
            case modelVersion = "ModelVersion"
            case performance = "Performance"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ModelPackagingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration information for the AWS IoT Greengrass component in a model packaging job.
        public let greengrass: GreengrassConfiguration?

        public init(greengrass: GreengrassConfiguration? = nil) {
            self.greengrass = greengrass
        }

        public func validate(name: String) throws {
            try self.greengrass?.validate(name: "\(name).greengrass")
        }

        private enum CodingKeys: String, CodingKey {
            case greengrass = "Greengrass"
        }
    }

    public struct ModelPackagingDescription: AWSDecodableShape {
        ///  The Unix timestamp for the time and date that the model packaging job was created.
        public let creationTimestamp: Date?
        /// The name of the model packaging job.
        public let jobName: String?
        ///  The Unix timestamp for the time and date that the model packaging job was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The configuration information used in the model packaging job.
        public let modelPackagingConfiguration: ModelPackagingConfiguration?
        /// The description for the model packaging job.
        public let modelPackagingJobDescription: String?
        /// The AWS service used to package the job. Currently Lookout for Vision can package
        /// jobs with AWS IoT Greengrass.
        public let modelPackagingMethod: String?
        /// Information about the output of the model packaging job. For more information, see DescribeModelPackagingJob.
        public let modelPackagingOutputDetails: ModelPackagingOutputDetails?
        /// The version of the model used in the model packaging job.
        public let modelVersion: String?
        /// The name of the project that's associated with a model that's in the model package.
        public let projectName: String?
        /// The status of the model packaging job.
        public let status: ModelPackagingJobStatus?
        /// The status message for the model packaging job.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, jobName: String? = nil, lastUpdatedTimestamp: Date? = nil, modelPackagingConfiguration: ModelPackagingConfiguration? = nil, modelPackagingJobDescription: String? = nil, modelPackagingMethod: String? = nil, modelPackagingOutputDetails: ModelPackagingOutputDetails? = nil, modelVersion: String? = nil, projectName: String? = nil, status: ModelPackagingJobStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.jobName = jobName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.modelPackagingConfiguration = modelPackagingConfiguration
            self.modelPackagingJobDescription = modelPackagingJobDescription
            self.modelPackagingMethod = modelPackagingMethod
            self.modelPackagingOutputDetails = modelPackagingOutputDetails
            self.modelVersion = modelVersion
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case jobName = "JobName"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case modelPackagingConfiguration = "ModelPackagingConfiguration"
            case modelPackagingJobDescription = "ModelPackagingJobDescription"
            case modelPackagingMethod = "ModelPackagingMethod"
            case modelPackagingOutputDetails = "ModelPackagingOutputDetails"
            case modelVersion = "ModelVersion"
            case projectName = "ProjectName"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ModelPackagingJobMetadata: AWSDecodableShape {
        /// The Unix timestamp for the time and date that the model packaging job was created.
        public let creationTimestamp: Date?
        /// The name of the model packaging job.
        public let jobName: String?
        /// The Unix timestamp for the time and date that the model packaging job was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The description for the model packaging job.
        public let modelPackagingJobDescription: String?
        /// The AWS service used to package the job. Currently Lookout for Vision can package jobs with AWS IoT Greengrass.
        public let modelPackagingMethod: String?
        /// The version of the model that is in the model package.
        public let modelVersion: String?
        /// The project that contains the model that is in the model package.
        public let projectName: String?
        /// The status of the model packaging job.
        public let status: ModelPackagingJobStatus?
        /// The status message for the model packaging job.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, jobName: String? = nil, lastUpdatedTimestamp: Date? = nil, modelPackagingJobDescription: String? = nil, modelPackagingMethod: String? = nil, modelVersion: String? = nil, projectName: String? = nil, status: ModelPackagingJobStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.jobName = jobName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.modelPackagingJobDescription = modelPackagingJobDescription
            self.modelPackagingMethod = modelPackagingMethod
            self.modelVersion = modelVersion
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case jobName = "JobName"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case modelPackagingJobDescription = "ModelPackagingJobDescription"
            case modelPackagingMethod = "ModelPackagingMethod"
            case modelVersion = "ModelVersion"
            case projectName = "ProjectName"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ModelPackagingOutputDetails: AWSDecodableShape {
        /// Information about the AWS IoT Greengrass component in a model packaging job.
        public let greengrass: GreengrassOutputDetails?

        public init(greengrass: GreengrassOutputDetails? = nil) {
            self.greengrass = greengrass
        }

        private enum CodingKeys: String, CodingKey {
            case greengrass = "Greengrass"
        }
    }

    public struct ModelPerformance: AWSDecodableShape {
        /// The overall F1 score metric for the trained model.
        public let f1Score: Float?
        /// The overall precision metric value for the trained model.
        public let precision: Float?
        /// The overall recall metric value for the trained model.
        public let recall: Float?

        public init(f1Score: Float? = nil, precision: Float? = nil, recall: Float? = nil) {
            self.f1Score = f1Score
            self.precision = precision
            self.recall = recall
        }

        private enum CodingKeys: String, CodingKey {
            case f1Score = "F1Score"
            case precision = "Precision"
            case recall = "Recall"
        }
    }

    public struct OutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3 location for the output.
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "S3Location"
        }
    }

    public struct OutputS3Object: AWSDecodableShape {
        /// The bucket that contains the training output.
        public let bucket: String?
        /// The location of the training output in the bucket.
        public let key: String?

        public init(bucket: String? = nil, key: String? = nil) {
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct PixelAnomaly: AWSDecodableShape {
        /// A hex color value for the mask that covers an anomaly type. Each anomaly type has a different mask color. The color maps to the color of the anomaly type used in the training dataset.
        public let color: String?
        /// The percentage area of the image that the anomaly type covers.
        public let totalPercentageArea: Float?

        public init(color: String? = nil, totalPercentageArea: Float? = nil) {
            self.color = color
            self.totalPercentageArea = totalPercentageArea
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case totalPercentageArea = "TotalPercentageArea"
        }
    }

    public struct ProjectDescription: AWSDecodableShape {
        /// The unix timestamp for the date and time that the project was created.
        public let creationTimestamp: Date?
        /// A list of datasets in the project.
        public let datasets: [DatasetMetadata]?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String?
        /// The name of the project.
        public let projectName: String?

        public init(creationTimestamp: Date? = nil, datasets: [DatasetMetadata]? = nil, projectArn: String? = nil, projectName: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.datasets = datasets
            self.projectArn = projectArn
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case datasets = "Datasets"
            case projectArn = "ProjectArn"
            case projectName = "ProjectName"
        }
    }

    public struct ProjectMetadata: AWSDecodableShape {
        /// The unix timestamp for the date and time that the project was created.
        public let creationTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String?
        /// The name of the project.
        public let projectName: String?

        public init(creationTimestamp: Date? = nil, projectArn: String? = nil, projectName: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.projectArn = projectArn
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case projectArn = "ProjectArn"
            case projectName = "ProjectName"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket that contains the training or model packaging job output. If you are training a model, the bucket must in your AWS account. If you use an S3 bucket for a model packaging job, the S3 bucket must be in the same AWS Region and AWS account in which you use AWS IoT Greengrass.
        public let bucket: String?
        /// The path of the folder, within the S3 bucket, that contains the output.
        public let prefix: String?

        public init(bucket: String? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[0-9A-Za-z\\.\\-_]*$")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 1024)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^([a-zA-Z0-9!_.*'()-][/a-zA-Z0-9!_.*'()-]*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case prefix = "Prefix"
        }
    }

    public struct StartModelPackagingJobRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to StartModelPackagingJob completes only once.  You choose the value to pass. For example, An issue might prevent you from getting a response from StartModelPackagingJob. In this case, safely retry your call to StartModelPackagingJob by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple dataset creation requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to StartModelPackagingJob. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The configuration for the model packaging job.
        public let configuration: ModelPackagingConfiguration?
        /// A description for the model packaging job.
        public let description: String?
        /// A name for the model packaging job. If you don't supply a value, the service creates a job name for you.
        public let jobName: String?
        /// The version of the model within the project that you want to package.
        public let modelVersion: String?
        /// The name of the project which contains the version of the model that you want to package.
        public let projectName: String

        public init(clientToken: String? = StartModelPackagingJobRequest.idempotencyToken(), configuration: ModelPackagingConfiguration? = nil, description: String? = nil, jobName: String? = nil, modelVersion: String? = nil, projectName: String) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.jobName = jobName
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.jobName, forKey: .jobName)
            try container.encodeIfPresent(self.modelVersion, forKey: .modelVersion)
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9-_. ()':,;?]+$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 64)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "^([1-9][0-9]*|latest)$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case jobName = "JobName"
            case modelVersion = "ModelVersion"
        }
    }

    public struct StartModelPackagingJobResponse: AWSDecodableShape {
        /// The job name for the model packaging job. If you don't supply a job name in the JobName input parameter, the service creates a job name for you.
        public let jobName: String?

        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct StartModelRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to StartModel completes only once.  You choose the value to pass. For example, An issue might prevent  you from getting a response from StartModel. In this case, safely retry your call to StartModel by using the same ClientToken parameter value.  If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple start requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to StartModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The maximum number of inference units to use for auto-scaling the model. If you don't specify a value, Amazon Lookout for Vision doesn't auto-scale the model.
        public let maxInferenceUnits: Int?
        /// The minimum number of inference units to use. A single inference unit represents 1 hour of processing.  Use a higher number to increase the TPS throughput of your model. You are charged for the number of inference units that you use.
        public let minInferenceUnits: Int?
        /// The version of the model that you want to start.
        public let modelVersion: String
        /// The name of the project that contains the model that you want to start.
        public let projectName: String

        public init(clientToken: String? = StartModelRequest.idempotencyToken(), maxInferenceUnits: Int? = nil, minInferenceUnits: Int? = nil, modelVersion: String, projectName: String) {
            self.clientToken = clientToken
            self.maxInferenceUnits = maxInferenceUnits
            self.minInferenceUnits = minInferenceUnits
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            try container.encodeIfPresent(self.maxInferenceUnits, forKey: .maxInferenceUnits)
            try container.encodeIfPresent(self.minInferenceUnits, forKey: .minInferenceUnits)
            request.encodePath(self.modelVersion, key: "ModelVersion")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.maxInferenceUnits, name: "maxInferenceUnits", parent: name, min: 1)
            try self.validate(self.minInferenceUnits, name: "minInferenceUnits", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "^([1-9][0-9]*|latest)$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxInferenceUnits = "MaxInferenceUnits"
            case minInferenceUnits = "MinInferenceUnits"
        }
    }

    public struct StartModelResponse: AWSDecodableShape {
        /// The current running status of the model.
        public let status: ModelHostingStatus?

        public init(status: ModelHostingStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct StopModelRequest: AWSEncodableShape {
        /// ClientToken is an idempotency token that ensures a call to StopModel completes only once.  You choose the value to pass. For example, An issue  might prevent you from getting a response from StopModel. In this case, safely retry your call to StopModel by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple stop requests. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to StopModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The version of the model that you want to stop.
        public let modelVersion: String
        /// The name of the project that contains the model that you want to stop.
        public let projectName: String

        public init(clientToken: String? = StopModelRequest.idempotencyToken(), modelVersion: String, projectName: String) {
            self.clientToken = clientToken
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.modelVersion, key: "ModelVersion")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "^([1-9][0-9]*|latest)$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopModelResponse: AWSDecodableShape {
        /// The status of the model.
        public let status: ModelHostingStatus?

        public init(status: ModelHostingStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag that is attached to the specified model.
        public let key: String?
        /// The value of the tag that is attached to the specified model.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the model to assign the tags.
        public let resourceArn: String
        /// The key-value tags to assign to the model.
        public let tags: [Tag]?

        public init(resourceArn: String, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetPlatform: AWSEncodableShape & AWSDecodableShape {
        /// The target accelerator for the model. Currently, Amazon Lookout for Vision only supports NVIDIA (Nvidia graphics processing unit)  and CPU accelerators. If you specify NVIDIA as an accelerator, you must also specify the gpu-code, trt-ver, and cuda-ver compiler options. If you don't specify an accelerator, Lookout for Vision uses the CPU for compilation and we highly recommend that you use the GreengrassConfiguration$CompilerOptions field. For example, you can use the following compiler options for CPU:     mcpu: CPU micro-architecture. For example, {'mcpu': 'skylake-avx512'}     mattr: CPU flags. For example, {'mattr': ['+neon', '+vfpv4']}
        public let accelerator: TargetPlatformAccelerator?
        /// The target architecture for the model. The currently supported architectures are X86_64 (64-bit version of the x86 instruction set) and ARM_64 (ARMv8 64-bit CPU).
        public let arch: TargetPlatformArch?
        /// The target operating system for the model. Linux is the only operating system that is currently supported.
        public let os: TargetPlatformOs?

        public init(accelerator: TargetPlatformAccelerator? = nil, arch: TargetPlatformArch? = nil, os: TargetPlatformOs? = nil) {
            self.accelerator = accelerator
            self.arch = arch
            self.os = os
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
            case arch = "Arch"
            case os = "Os"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the model from which you want to remove tags.
        public let resourceArn: String
        /// A list of the keys of the tags that you want to remove.
        public let tagKeys: [String]?

        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys?.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatasetEntriesRequest: AWSEncodableShape {
        /// The entries to add to the dataset.
        public let changes: AWSBase64Data?
        /// ClientToken is an idempotency token that ensures a call to UpdateDatasetEntries completes only once.  You choose the value to pass. For example, An issue  might prevent you from getting a response from UpdateDatasetEntries. In this case, safely retry your call to UpdateDatasetEntries by using the same ClientToken parameter value. If you don't supply a value for ClientToken, the AWS SDK you are using inserts a value for you.  This prevents retries after a network error from making multiple updates with the same dataset entries. You'll need to provide your own value for other use cases.  An error occurs if the other input parameters are not the same as in the first request. Using a different   value for ClientToken is considered a new call to UpdateDatasetEntries. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The type of the dataset that you want to update. Specify train to update the training dataset. Specify test to update the test dataset. If you have a single dataset project, specify train.
        public let datasetType: String
        /// The name of the project that contains the dataset that you want to update.
        public let projectName: String

        public init(changes: AWSBase64Data? = nil, clientToken: String? = UpdateDatasetEntriesRequest.idempotencyToken(), datasetType: String, projectName: String) {
            self.changes = changes
            self.clientToken = clientToken
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.changes, forKey: .changes)
            request.encodeHeader(self.clientToken, key: "X-Amzn-Client-Token")
            request.encodePath(self.datasetType, key: "DatasetType")
            request.encodePath(self.projectName, key: "ProjectName")
        }

        public func validate(name: String) throws {
            try self.validate(self.changes, name: "changes", parent: name, max: 10485760)
            try self.validate(self.changes, name: "changes", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "^train|test$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_\\-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case changes = "Changes"
        }
    }

    public struct UpdateDatasetEntriesResponse: AWSDecodableShape {
        /// The status of the dataset update.
        public let status: DatasetStatus?

        public init(status: DatasetStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }
}

// MARK: - Errors

/// Error enum for LookoutVision
public struct LookoutVisionErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize LookoutVision
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You are not authorized to perform the action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The update or deletion of a resource caused an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Amazon Lookout for Vision experienced a service issue. Try your call again.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A service quota was exceeded the allowed limit. For more information, see Limits in Amazon Lookout for Vision in the Amazon Lookout for Vision Developer Guide.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Amazon Lookout for Vision is temporarily unable to process the request. Try your call again.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// An input validation error occured. For example, invalid characters in a project name, or if a pagination token is invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension LookoutVisionErrorType: Equatable {
    public static func == (lhs: LookoutVisionErrorType, rhs: LookoutVisionErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LookoutVisionErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
