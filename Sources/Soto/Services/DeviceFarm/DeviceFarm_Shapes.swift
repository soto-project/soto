//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension DeviceFarm {
    // MARK: Enums

    public enum ArtifactCategory: String, CustomStringConvertible, Codable {
        case file = "FILE"
        case log = "LOG"
        case screenshot = "SCREENSHOT"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactType: String, CustomStringConvertible, Codable {
        case appiumJavaOutput = "APPIUM_JAVA_OUTPUT"
        case appiumJavaXmlOutput = "APPIUM_JAVA_XML_OUTPUT"
        case appiumPythonOutput = "APPIUM_PYTHON_OUTPUT"
        case appiumPythonXmlOutput = "APPIUM_PYTHON_XML_OUTPUT"
        case appiumServerOutput = "APPIUM_SERVER_OUTPUT"
        case applicationCrashReport = "APPLICATION_CRASH_REPORT"
        case automationOutput = "AUTOMATION_OUTPUT"
        case calabashJavaXmlOutput = "CALABASH_JAVA_XML_OUTPUT"
        case calabashJsonOutput = "CALABASH_JSON_OUTPUT"
        case calabashPrettyOutput = "CALABASH_PRETTY_OUTPUT"
        case calabashStandardOutput = "CALABASH_STANDARD_OUTPUT"
        case customerArtifact = "CUSTOMER_ARTIFACT"
        case customerArtifactLog = "CUSTOMER_ARTIFACT_LOG"
        case deviceLog = "DEVICE_LOG"
        case exerciserMonkeyOutput = "EXERCISER_MONKEY_OUTPUT"
        case explorerEventLog = "EXPLORER_EVENT_LOG"
        case explorerSummaryLog = "EXPLORER_SUMMARY_LOG"
        case instrumentationOutput = "INSTRUMENTATION_OUTPUT"
        case messageLog = "MESSAGE_LOG"
        case resultLog = "RESULT_LOG"
        case screenshot = "SCREENSHOT"
        case serviceLog = "SERVICE_LOG"
        case testspecOutput = "TESTSPEC_OUTPUT"
        case unknown = "UNKNOWN"
        case video = "VIDEO"
        case videoLog = "VIDEO_LOG"
        case webkitLog = "WEBKIT_LOG"
        case xctestLog = "XCTEST_LOG"
        public var description: String { return self.rawValue }
    }

    public enum BillingMethod: String, CustomStringConvertible, Codable {
        case metered = "METERED"
        case unmetered = "UNMETERED"
        public var description: String { return self.rawValue }
    }

    public enum CurrencyCode: String, CustomStringConvertible, Codable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum DeviceAttribute: String, CustomStringConvertible, Codable {
        case appiumVersion = "APPIUM_VERSION"
        case arn = "ARN"
        case availability = "AVAILABILITY"
        case fleetType = "FLEET_TYPE"
        case formFactor = "FORM_FACTOR"
        case instanceArn = "INSTANCE_ARN"
        case instanceLabels = "INSTANCE_LABELS"
        case manufacturer = "MANUFACTURER"
        case model = "MODEL"
        case osVersion = "OS_VERSION"
        case platform = "PLATFORM"
        case remoteAccessEnabled = "REMOTE_ACCESS_ENABLED"
        case remoteDebugEnabled = "REMOTE_DEBUG_ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DeviceAvailability: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case busy = "BUSY"
        case highlyAvailable = "HIGHLY_AVAILABLE"
        case temporaryNotAvailable = "TEMPORARY_NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceFilterAttribute: String, CustomStringConvertible, Codable {
        case arn = "ARN"
        case availability = "AVAILABILITY"
        case fleetType = "FLEET_TYPE"
        case formFactor = "FORM_FACTOR"
        case instanceArn = "INSTANCE_ARN"
        case instanceLabels = "INSTANCE_LABELS"
        case manufacturer = "MANUFACTURER"
        case model = "MODEL"
        case osVersion = "OS_VERSION"
        case platform = "PLATFORM"
        case remoteAccessEnabled = "REMOTE_ACCESS_ENABLED"
        case remoteDebugEnabled = "REMOTE_DEBUG_ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DeviceFormFactor: String, CustomStringConvertible, Codable {
        case phone = "PHONE"
        case tablet = "TABLET"
        public var description: String { return self.rawValue }
    }

    public enum DevicePlatform: String, CustomStringConvertible, Codable {
        case android = "ANDROID"
        case ios = "IOS"
        public var description: String { return self.rawValue }
    }

    public enum DevicePoolType: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionResult: String, CustomStringConvertible, Codable {
        case errored = "ERRORED"
        case failed = "FAILED"
        case passed = "PASSED"
        case pending = "PENDING"
        case skipped = "SKIPPED"
        case stopped = "STOPPED"
        case warned = "WARNED"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionResultCode: String, CustomStringConvertible, Codable {
        case parsingFailed = "PARSING_FAILED"
        case vpcEndpointSetupFailed = "VPC_ENDPOINT_SETUP_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case pending = "PENDING"
        case pendingConcurrency = "PENDING_CONCURRENCY"
        case pendingDevice = "PENDING_DEVICE"
        case preparing = "PREPARING"
        case processing = "PROCESSING"
        case running = "RUNNING"
        case scheduling = "SCHEDULING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum InstanceStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case inUse = "IN_USE"
        case notAvailable = "NOT_AVAILABLE"
        case preparing = "PREPARING"
        public var description: String { return self.rawValue }
    }

    public enum InteractionMode: String, CustomStringConvertible, Codable {
        case interactive = "INTERACTIVE"
        case noVideo = "NO_VIDEO"
        case videoOnly = "VIDEO_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum NetworkProfileType: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public enum OfferingTransactionType: String, CustomStringConvertible, Codable {
        case purchase = "PURCHASE"
        case renew = "RENEW"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum OfferingType: String, CustomStringConvertible, Codable {
        case recurring = "RECURRING"
        public var description: String { return self.rawValue }
    }

    public enum RecurringChargeFrequency: String, CustomStringConvertible, Codable {
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public enum RuleOperator: String, CustomStringConvertible, Codable {
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEquals = "GREATER_THAN_OR_EQUALS"
        case `in` = "IN"
        case lessThan = "LESS_THAN"
        case lessThanOrEquals = "LESS_THAN_OR_EQUALS"
        case notIn = "NOT_IN"
        public var description: String { return self.rawValue }
    }

    public enum SampleType: String, CustomStringConvertible, Codable {
        case cpu = "CPU"
        case memory = "MEMORY"
        case nativeAvgDrawtime = "NATIVE_AVG_DRAWTIME"
        case nativeFps = "NATIVE_FPS"
        case nativeFrames = "NATIVE_FRAMES"
        case nativeMaxDrawtime = "NATIVE_MAX_DRAWTIME"
        case nativeMinDrawtime = "NATIVE_MIN_DRAWTIME"
        case openglAvgDrawtime = "OPENGL_AVG_DRAWTIME"
        case openglFps = "OPENGL_FPS"
        case openglFrames = "OPENGL_FRAMES"
        case openglMaxDrawtime = "OPENGL_MAX_DRAWTIME"
        case openglMinDrawtime = "OPENGL_MIN_DRAWTIME"
        case rx = "RX"
        case rxRate = "RX_RATE"
        case threads = "THREADS"
        case tx = "TX"
        case txRate = "TX_RATE"
        public var description: String { return self.rawValue }
    }

    public enum TestGridSessionArtifactCategory: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public enum TestGridSessionArtifactType: String, CustomStringConvertible, Codable {
        case seleniumLog = "SELENIUM_LOG"
        case unknown = "UNKNOWN"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public enum TestGridSessionStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case closed = "CLOSED"
        case errored = "ERRORED"
        public var description: String { return self.rawValue }
    }

    public enum TestType: String, CustomStringConvertible, Codable {
        case appiumJavaJunit = "APPIUM_JAVA_JUNIT"
        case appiumJavaTestng = "APPIUM_JAVA_TESTNG"
        case appiumNode = "APPIUM_NODE"
        case appiumPython = "APPIUM_PYTHON"
        case appiumRuby = "APPIUM_RUBY"
        case appiumWebJavaJunit = "APPIUM_WEB_JAVA_JUNIT"
        case appiumWebJavaTestng = "APPIUM_WEB_JAVA_TESTNG"
        case appiumWebNode = "APPIUM_WEB_NODE"
        case appiumWebPython = "APPIUM_WEB_PYTHON"
        case appiumWebRuby = "APPIUM_WEB_RUBY"
        case builtinExplorer = "BUILTIN_EXPLORER"
        case builtinFuzz = "BUILTIN_FUZZ"
        case calabash = "CALABASH"
        case instrumentation = "INSTRUMENTATION"
        case remoteAccessRecord = "REMOTE_ACCESS_RECORD"
        case remoteAccessReplay = "REMOTE_ACCESS_REPLAY"
        case uiautomation = "UIAUTOMATION"
        case uiautomator = "UIAUTOMATOR"
        case webPerformanceProfile = "WEB_PERFORMANCE_PROFILE"
        case xctest = "XCTEST"
        case xctestUi = "XCTEST_UI"
        public var description: String { return self.rawValue }
    }

    public enum UploadCategory: String, CustomStringConvertible, Codable {
        case curated = "CURATED"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public enum UploadStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case initialized = "INITIALIZED"
        case processing = "PROCESSING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum UploadType: String, CustomStringConvertible, Codable {
        case androidApp = "ANDROID_APP"
        case appiumJavaJunitTestPackage = "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
        case appiumJavaJunitTestSpec = "APPIUM_JAVA_JUNIT_TEST_SPEC"
        case appiumJavaTestngTestPackage = "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
        case appiumJavaTestngTestSpec = "APPIUM_JAVA_TESTNG_TEST_SPEC"
        case appiumNodeTestPackage = "APPIUM_NODE_TEST_PACKAGE"
        case appiumNodeTestSpec = "APPIUM_NODE_TEST_SPEC"
        case appiumPythonTestPackage = "APPIUM_PYTHON_TEST_PACKAGE"
        case appiumPythonTestSpec = "APPIUM_PYTHON_TEST_SPEC"
        case appiumRubyTestPackage = "APPIUM_RUBY_TEST_PACKAGE"
        case appiumRubyTestSpec = "APPIUM_RUBY_TEST_SPEC"
        case appiumWebJavaJunitTestPackage = "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
        case appiumWebJavaJunitTestSpec = "APPIUM_WEB_JAVA_JUNIT_TEST_SPEC"
        case appiumWebJavaTestngTestPackage = "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
        case appiumWebJavaTestngTestSpec = "APPIUM_WEB_JAVA_TESTNG_TEST_SPEC"
        case appiumWebNodeTestPackage = "APPIUM_WEB_NODE_TEST_PACKAGE"
        case appiumWebNodeTestSpec = "APPIUM_WEB_NODE_TEST_SPEC"
        case appiumWebPythonTestPackage = "APPIUM_WEB_PYTHON_TEST_PACKAGE"
        case appiumWebPythonTestSpec = "APPIUM_WEB_PYTHON_TEST_SPEC"
        case appiumWebRubyTestPackage = "APPIUM_WEB_RUBY_TEST_PACKAGE"
        case appiumWebRubyTestSpec = "APPIUM_WEB_RUBY_TEST_SPEC"
        case calabashTestPackage = "CALABASH_TEST_PACKAGE"
        case externalData = "EXTERNAL_DATA"
        case instrumentationTestPackage = "INSTRUMENTATION_TEST_PACKAGE"
        case instrumentationTestSpec = "INSTRUMENTATION_TEST_SPEC"
        case iosApp = "IOS_APP"
        case uiautomationTestPackage = "UIAUTOMATION_TEST_PACKAGE"
        case uiautomatorTestPackage = "UIAUTOMATOR_TEST_PACKAGE"
        case webApp = "WEB_APP"
        case xctestTestPackage = "XCTEST_TEST_PACKAGE"
        case xctestUiTestPackage = "XCTEST_UI_TEST_PACKAGE"
        case xctestUiTestSpec = "XCTEST_UI_TEST_SPEC"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountSettings: AWSDecodableShape {
        /// The AWS account number specified in the AccountSettings container.
        public let awsAccountNumber: String?
        /// The default number of minutes (at the account level) a test run executes before it times out. The default value is 150 minutes.
        public let defaultJobTimeoutMinutes: Int?
        /// The maximum number of minutes a test run executes before it times out.
        public let maxJobTimeoutMinutes: Int?
        /// The maximum number of device slots that the AWS account can purchase. Each maximum is expressed as an offering-id:number pair, where the offering-id represents one of the IDs returned by the ListOfferings command.
        public let maxSlots: [String: Int]?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?
        /// Information about an AWS account's usage of free trial device minutes.
        public let trialMinutes: TrialMinutes?
        /// Returns the unmetered devices you have purchased or want to purchase.
        public let unmeteredDevices: [DevicePlatform: Int]?
        /// Returns the unmetered remote access devices you have purchased or want to purchase.
        public let unmeteredRemoteAccessDevices: [DevicePlatform: Int]?

        public init(awsAccountNumber: String? = nil, defaultJobTimeoutMinutes: Int? = nil, maxJobTimeoutMinutes: Int? = nil, maxSlots: [String: Int]? = nil, skipAppResign: Bool? = nil, trialMinutes: TrialMinutes? = nil, unmeteredDevices: [DevicePlatform: Int]? = nil, unmeteredRemoteAccessDevices: [DevicePlatform: Int]? = nil) {
            self.awsAccountNumber = awsAccountNumber
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.maxSlots = maxSlots
            self.skipAppResign = skipAppResign
            self.trialMinutes = trialMinutes
            self.unmeteredDevices = unmeteredDevices
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountNumber
            case defaultJobTimeoutMinutes
            case maxJobTimeoutMinutes
            case maxSlots
            case skipAppResign
            case trialMinutes
            case unmeteredDevices
            case unmeteredRemoteAccessDevices
        }
    }

    public struct Artifact: AWSDecodableShape {
        /// The artifact's ARN.
        public let arn: String?
        /// The artifact's file extension.
        public let `extension`: String?
        /// The artifact's name.
        public let name: String?
        /// The artifact's type. Allowed values include the following:   UNKNOWN   SCREENSHOT   DEVICE_LOG   MESSAGE_LOG   VIDEO_LOG   RESULT_LOG   SERVICE_LOG   WEBKIT_LOG   INSTRUMENTATION_OUTPUT   EXERCISER_MONKEY_OUTPUT: the artifact (log) generated by an Android fuzz test.   CALABASH_JSON_OUTPUT   CALABASH_PRETTY_OUTPUT   CALABASH_STANDARD_OUTPUT   CALABASH_JAVA_XML_OUTPUT   AUTOMATION_OUTPUT   APPIUM_SERVER_OUTPUT   APPIUM_JAVA_OUTPUT   APPIUM_JAVA_XML_OUTPUT   APPIUM_PYTHON_OUTPUT   APPIUM_PYTHON_XML_OUTPUT   EXPLORER_EVENT_LOG   EXPLORER_SUMMARY_LOG   APPLICATION_CRASH_REPORT   XCTEST_LOG   VIDEO   CUSTOMER_ARTIFACT   CUSTOMER_ARTIFACT_LOG   TESTSPEC_OUTPUT
        public let type: ArtifactType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the artifact's file.
        public let url: String?

        public init(arn: String? = nil, extension: String? = nil, name: String? = nil, type: ArtifactType? = nil, url: String? = nil) {
            self.arn = arn
            self.`extension` = `extension`
            self.name = name
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case `extension`
            case name
            case type
            case url
        }
    }

    public struct CPU: AWSDecodableShape {
        /// The CPU's architecture (for example, x86 or ARM).
        public let architecture: String?
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2 GHz CPU is expressed as 1200000000.
        public let clock: Double?
        /// The CPU's frequency.
        public let frequency: String?

        public init(architecture: String? = nil, clock: Double? = nil, frequency: String? = nil) {
            self.architecture = architecture
            self.clock = clock
            self.frequency = frequency
        }

        private enum CodingKeys: String, CodingKey {
            case architecture
            case clock
            case frequency
        }
    }

    public struct Counters: AWSDecodableShape {
        /// The number of errored entities.
        public let errored: Int?
        /// The number of failed entities.
        public let failed: Int?
        /// The number of passed entities.
        public let passed: Int?
        /// The number of skipped entities.
        public let skipped: Int?
        /// The number of stopped entities.
        public let stopped: Int?
        /// The total number of entities.
        public let total: Int?
        /// The number of warned entities.
        public let warned: Int?

        public init(errored: Int? = nil, failed: Int? = nil, passed: Int? = nil, skipped: Int? = nil, stopped: Int? = nil, total: Int? = nil, warned: Int? = nil) {
            self.errored = errored
            self.failed = failed
            self.passed = passed
            self.skipped = skipped
            self.stopped = stopped
            self.total = total
            self.warned = warned
        }

        private enum CodingKeys: String, CodingKey {
            case errored
            case failed
            case passed
            case skipped
            case stopped
            case total
            case warned
        }
    }

    public struct CreateDevicePoolRequest: AWSEncodableShape {
        /// The device pool's description.
        public let description: String?
        /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests.
        public let maxDevices: Int?
        /// The device pool's name.
        public let name: String
        /// The ARN of the project for the device pool.
        public let projectArn: String
        /// The device pool's rules.
        public let rules: [Rule]

        public init(description: String? = nil, maxDevices: Int? = nil, name: String, projectArn: String, rules: [Rule]) {
            self.description = description
            self.maxDevices = maxDevices
            self.name = name
            self.projectArn = projectArn
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 16384)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case maxDevices
            case name
            case projectArn
            case rules
        }
    }

    public struct CreateDevicePoolResult: AWSDecodableShape {
        /// The newly created device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool
        }
    }

    public struct CreateInstanceProfileRequest: AWSEncodableShape {
        /// The description of your instance profile.
        public let description: String?
        /// An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run. The list of packages is considered only if you set packageCleanup to true.
        public let excludeAppPackagesFromCleanup: [String]?
        /// The name of your instance profile.
        public let name: String
        /// When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
        public let packageCleanup: Bool?
        /// When set to true, Device Farm reboots the instance after a test run. The default value is true.
        public let rebootAfterUse: Bool?

        public init(description: String? = nil, excludeAppPackagesFromCleanup: [String]? = nil, name: String, packageCleanup: Bool? = nil, rebootAfterUse: Bool? = nil) {
            self.description = description
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.packageCleanup = packageCleanup
            self.rebootAfterUse = rebootAfterUse
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 16384)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case excludeAppPackagesFromCleanup
            case name
            case packageCleanup
            case rebootAfterUse
        }
    }

    public struct CreateInstanceProfileResult: AWSDecodableShape {
        /// An object that contains information about your instance profile.
        public let instanceProfile: InstanceProfile?

        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile
        }
    }

    public struct CreateNetworkProfileRequest: AWSEncodableShape {
        /// The description of the network profile.
        public let description: String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int?
        /// The name for the new network profile.
        public let name: String
        /// The Amazon Resource Name (ARN) of the project for which you want to create a network profile.
        public let projectArn: String
        /// The type of network profile to create. Valid values are listed here.
        public let type: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int?

        public init(description: String? = nil, downlinkBandwidthBits: Int64? = nil, downlinkDelayMs: Int64? = nil, downlinkJitterMs: Int64? = nil, downlinkLossPercent: Int? = nil, name: String, projectArn: String, type: NetworkProfileType? = nil, uplinkBandwidthBits: Int64? = nil, uplinkDelayMs: Int64? = nil, uplinkJitterMs: Int64? = nil, uplinkLossPercent: Int? = nil) {
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.downlinkDelayMs = downlinkDelayMs
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkLossPercent = downlinkLossPercent
            self.name = name
            self.projectArn = projectArn
            self.type = type
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkJitterMs = uplinkJitterMs
            self.uplinkLossPercent = uplinkLossPercent
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 16384)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.downlinkLossPercent, name: "downlinkLossPercent", parent: name, max: 100)
            try self.validate(self.downlinkLossPercent, name: "downlinkLossPercent", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.uplinkLossPercent, name: "uplinkLossPercent", parent: name, max: 100)
            try self.validate(self.uplinkLossPercent, name: "uplinkLossPercent", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case downlinkBandwidthBits
            case downlinkDelayMs
            case downlinkJitterMs
            case downlinkLossPercent
            case name
            case projectArn
            case type
            case uplinkBandwidthBits
            case uplinkDelayMs
            case uplinkJitterMs
            case uplinkLossPercent
        }
    }

    public struct CreateNetworkProfileResult: AWSDecodableShape {
        /// The network profile that is returned by the create network profile request.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        /// Sets the execution timeout value (in minutes) for a project. All test runs in this project use the specified execution timeout value unless overridden when scheduling a run.
        public let defaultJobTimeoutMinutes: Int?
        /// The project's name.
        public let name: String

        public init(defaultJobTimeoutMinutes: Int? = nil, name: String) {
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultJobTimeoutMinutes
            case name
        }
    }

    public struct CreateProjectResult: AWSDecodableShape {
        /// The newly created project.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project
        }
    }

    public struct CreateRemoteAccessSessionConfiguration: AWSEncodableShape {
        /// The billing method for the remote access session.
        public let billingMethod: BillingMethod?
        /// An array of ARNs included in the VPC endpoint configuration.
        public let vpceConfigurationArns: [String]?

        public init(billingMethod: BillingMethod? = nil, vpceConfigurationArns: [String]? = nil) {
            self.billingMethod = billingMethod
            self.vpceConfigurationArns = vpceConfigurationArns
        }

        public func validate(name: String) throws {
            try self.vpceConfigurationArns?.forEach {
                try validate($0, name: "vpceConfigurationArns[]", parent: name, max: 1011)
                try validate($0, name: "vpceConfigurationArns[]", parent: name, min: 32)
                try validate($0, name: "vpceConfigurationArns[]", parent: name, pattern: "^arn:.+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case billingMethod
            case vpceConfigurationArns
        }
    }

    public struct CreateRemoteAccessSessionRequest: AWSEncodableShape {
        /// Unique identifier for the client. If you want access to multiple devices on the same client, you should pass the same clientId value in each call to CreateRemoteAccessSession. This identifier is required only if remoteDebugEnabled is set to true. Remote debugging is no longer supported.
        public let clientId: String?
        /// The configuration information for the remote access session request.
        public let configuration: CreateRemoteAccessSessionConfiguration?
        /// The ARN of the device for which you want to create a remote access session.
        public let deviceArn: String
        /// The Amazon Resource Name (ARN) of the device instance for which you want to create a remote access session.
        public let instanceArn: String?
        /// The interaction mode of the remote access session. Valid values are:   INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.   NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.   VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.
        public let interactionMode: InteractionMode?
        /// The name of the remote access session to create.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the project for which you want to create a remote access session.
        public let projectArn: String
        /// Set to true if you want to access devices remotely for debugging in your remote access session. Remote debugging is no longer supported.
        public let remoteDebugEnabled: Bool?
        /// The Amazon Resource Name (ARN) for the app to be recorded in the remote access session.
        public let remoteRecordAppArn: String?
        /// Set to true to enable remote recording for the remote access session.
        public let remoteRecordEnabled: Bool?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information on how Device Farm modifies your uploads during tests, see Do you modify my app?
        public let skipAppResign: Bool?
        /// Ignored. The public key of the ssh key pair you want to use for connecting to remote devices in your remote debugging session. This key is required only if remoteDebugEnabled is set to true. Remote debugging is no longer supported.
        public let sshPublicKey: String?

        public init(clientId: String? = nil, configuration: CreateRemoteAccessSessionConfiguration? = nil, deviceArn: String, instanceArn: String? = nil, interactionMode: InteractionMode? = nil, name: String? = nil, projectArn: String, remoteDebugEnabled: Bool? = nil, remoteRecordAppArn: String? = nil, remoteRecordEnabled: Bool? = nil, skipAppResign: Bool? = nil, sshPublicKey: String? = nil) {
            self.clientId = clientId
            self.configuration = configuration
            self.deviceArn = deviceArn
            self.instanceArn = instanceArn
            self.interactionMode = interactionMode
            self.name = name
            self.projectArn = projectArn
            self.remoteDebugEnabled = remoteDebugEnabled
            self.remoteRecordAppArn = remoteRecordAppArn
            self.remoteRecordEnabled = remoteRecordEnabled
            self.skipAppResign = skipAppResign
            self.sshPublicKey = sshPublicKey
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 64)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 0)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, max: 1011)
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, min: 32)
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, max: 1011)
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, min: 32)
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.remoteRecordAppArn, name: "remoteRecordAppArn", parent: name, max: 1011)
            try self.validate(self.remoteRecordAppArn, name: "remoteRecordAppArn", parent: name, min: 32)
            try self.validate(self.remoteRecordAppArn, name: "remoteRecordAppArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.sshPublicKey, name: "sshPublicKey", parent: name, max: 8192)
            try self.validate(self.sshPublicKey, name: "sshPublicKey", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId
            case configuration
            case deviceArn
            case instanceArn
            case interactionMode
            case name
            case projectArn
            case remoteDebugEnabled
            case remoteRecordAppArn
            case remoteRecordEnabled
            case skipAppResign
            case sshPublicKey
        }
    }

    public struct CreateRemoteAccessSessionResult: AWSDecodableShape {
        /// A container that describes the remote access session when the request to create a remote access session is sent.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession
        }
    }

    public struct CreateTestGridProjectRequest: AWSEncodableShape {
        /// Human-readable description of the project.
        public let description: String?
        /// Human-readable name of the Selenium testing project.
        public let name: String
        /// The VPC security groups and subnets that are attached to a project.
        public let vpcConfig: TestGridVpcConfig?

        public init(description: String? = nil, name: String, vpcConfig: TestGridVpcConfig? = nil) {
            self.description = description
            self.name = name
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*\\S.*")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case vpcConfig
        }
    }

    public struct CreateTestGridProjectResult: AWSDecodableShape {
        /// ARN of the Selenium testing project that was created.
        public let testGridProject: TestGridProject?

        public init(testGridProject: TestGridProject? = nil) {
            self.testGridProject = testGridProject
        }

        private enum CodingKeys: String, CodingKey {
            case testGridProject
        }
    }

    public struct CreateTestGridUrlRequest: AWSEncodableShape {
        /// Lifetime, in seconds, of the URL.
        public let expiresInSeconds: Int
        /// ARN (from CreateTestGridProject or ListTestGridProjects) to associate with the short-term URL.
        public let projectArn: String

        public init(expiresInSeconds: Int, projectArn: String) {
            self.expiresInSeconds = expiresInSeconds
            self.projectArn = projectArn
        }

        public func validate(name: String) throws {
            try self.validate(self.expiresInSeconds, name: "expiresInSeconds", parent: name, max: 86400)
            try self.validate(self.expiresInSeconds, name: "expiresInSeconds", parent: name, min: 60)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case expiresInSeconds
            case projectArn
        }
    }

    public struct CreateTestGridUrlResult: AWSDecodableShape {
        /// The number of seconds the URL from CreateTestGridUrlResult$url stays active.
        public let expires: Date?
        /// A signed URL, expiring in CreateTestGridUrlRequest$expiresInSeconds seconds, to be passed to a RemoteWebDriver.
        public let url: String?

        public init(expires: Date? = nil, url: String? = nil) {
            self.expires = expires
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case expires
            case url
        }
    }

    public struct CreateUploadRequest: AWSEncodableShape {
        /// The upload's content type (for example, application/octet-stream).
        public let contentType: String?
        /// The upload's file name. The name should not contain any forward slashes (/). If you are uploading an iOS app, the file name must end with the .ipa extension. If you are uploading an Android app, the file name must end with the .apk extension. For all others, the file name must end with the .zip file extension.
        public let name: String
        /// The ARN of the project for the upload.
        public let projectArn: String
        /// The upload's upload type. Must be one of the following values:   ANDROID_APP   IOS_APP   WEB_APP   EXTERNAL_DATA   APPIUM_JAVA_JUNIT_TEST_PACKAGE   APPIUM_JAVA_TESTNG_TEST_PACKAGE   APPIUM_PYTHON_TEST_PACKAGE   APPIUM_NODE_TEST_PACKAGE   APPIUM_RUBY_TEST_PACKAGE   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE   APPIUM_WEB_PYTHON_TEST_PACKAGE   APPIUM_WEB_NODE_TEST_PACKAGE   APPIUM_WEB_RUBY_TEST_PACKAGE   CALABASH_TEST_PACKAGE   INSTRUMENTATION_TEST_PACKAGE   UIAUTOMATION_TEST_PACKAGE   UIAUTOMATOR_TEST_PACKAGE   XCTEST_TEST_PACKAGE   XCTEST_UI_TEST_PACKAGE   APPIUM_JAVA_JUNIT_TEST_SPEC   APPIUM_JAVA_TESTNG_TEST_SPEC   APPIUM_PYTHON_TEST_SPEC   APPIUM_NODE_TEST_SPEC   APPIUM_RUBY_TEST_SPEC   APPIUM_WEB_JAVA_JUNIT_TEST_SPEC   APPIUM_WEB_JAVA_TESTNG_TEST_SPEC   APPIUM_WEB_PYTHON_TEST_SPEC   APPIUM_WEB_NODE_TEST_SPEC   APPIUM_WEB_RUBY_TEST_SPEC   INSTRUMENTATION_TEST_SPEC   XCTEST_UI_TEST_SPEC    If you call CreateUpload with WEB_APP specified, AWS Device Farm throws an ArgumentException error.
        public let type: UploadType

        public init(contentType: String? = nil, name: String, projectArn: String, type: UploadType) {
            self.contentType = contentType
            self.name = name
            self.projectArn = projectArn
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, max: 64)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case contentType
            case name
            case projectArn
            case type
        }
    }

    public struct CreateUploadResult: AWSDecodableShape {
        /// The newly created upload.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload
        }
    }

    public struct CreateVPCEConfigurationRequest: AWSEncodableShape {
        /// The DNS name of the service running in your VPC that you want Device Farm to test.
        public let serviceDnsName: String
        /// An optional description that provides details about your VPC endpoint configuration.
        public let vpceConfigurationDescription: String?
        /// The friendly name you give to your VPC endpoint configuration, to manage your configurations more easily.
        public let vpceConfigurationName: String
        /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
        public let vpceServiceName: String

        public init(serviceDnsName: String, vpceConfigurationDescription: String? = nil, vpceConfigurationName: String, vpceServiceName: String) {
            self.serviceDnsName = serviceDnsName
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.vpceConfigurationName = vpceConfigurationName
            self.vpceServiceName = vpceServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceDnsName, name: "serviceDnsName", parent: name, max: 2048)
            try self.validate(self.serviceDnsName, name: "serviceDnsName", parent: name, min: 0)
            try self.validate(self.vpceConfigurationDescription, name: "vpceConfigurationDescription", parent: name, max: 2048)
            try self.validate(self.vpceConfigurationDescription, name: "vpceConfigurationDescription", parent: name, min: 0)
            try self.validate(self.vpceConfigurationName, name: "vpceConfigurationName", parent: name, max: 1024)
            try self.validate(self.vpceConfigurationName, name: "vpceConfigurationName", parent: name, min: 0)
            try self.validate(self.vpceServiceName, name: "vpceServiceName", parent: name, max: 2048)
            try self.validate(self.vpceServiceName, name: "vpceServiceName", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case serviceDnsName
            case vpceConfigurationDescription
            case vpceConfigurationName
            case vpceServiceName
        }
    }

    public struct CreateVPCEConfigurationResult: AWSDecodableShape {
        /// An object that contains information about your VPC endpoint configuration.
        public let vpceConfiguration: VPCEConfiguration?

        public init(vpceConfiguration: VPCEConfiguration? = nil) {
            self.vpceConfiguration = vpceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfiguration
        }
    }

    public struct CustomerArtifactPaths: AWSEncodableShape & AWSDecodableShape {
        /// Comma-separated list of paths on the Android device where the artifacts generated by the customer's tests are pulled from.
        public let androidPaths: [String]?
        /// Comma-separated list of paths in the test execution environment where the artifacts generated by the customer's tests are pulled from.
        public let deviceHostPaths: [String]?
        /// Comma-separated list of paths on the iOS device where the artifacts generated by the customer's tests are pulled from.
        public let iosPaths: [String]?

        public init(androidPaths: [String]? = nil, deviceHostPaths: [String]? = nil, iosPaths: [String]? = nil) {
            self.androidPaths = androidPaths
            self.deviceHostPaths = deviceHostPaths
            self.iosPaths = iosPaths
        }

        private enum CodingKeys: String, CodingKey {
            case androidPaths
            case deviceHostPaths
            case iosPaths
        }
    }

    public struct DeleteDevicePoolRequest: AWSEncodableShape {
        /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteDevicePoolResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInstanceProfileRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the instance profile you are requesting to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteInstanceProfileResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNetworkProfileRequest: AWSEncodableShape {
        /// The ARN of the network profile to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteNetworkProfileResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        /// Represents the Amazon Resource Name (ARN) of the Device Farm project to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteProjectResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRemoteAccessSessionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the session for which you want to delete remote access.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteRemoteAccessSessionResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRunRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the run to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteRunResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTestGridProjectRequest: AWSEncodableShape {
        /// The ARN of the project to delete, from CreateTestGridProject or ListTestGridProjects.
        public let projectArn: String

        public init(projectArn: String) {
            self.projectArn = projectArn
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn
        }
    }

    public struct DeleteTestGridProjectResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUploadRequest: AWSEncodableShape {
        /// Represents the Amazon Resource Name (ARN) of the Device Farm upload to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteUploadResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVPCEConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to delete.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteVPCEConfigurationResult: AWSDecodableShape {
        public init() {}
    }

    public struct Device: AWSDecodableShape {
        /// The device's ARN.
        public let arn: String?
        /// Indicates how likely a device is available for a test run. Currently available in the ListDevices and GetDevice API methods.
        public let availability: DeviceAvailability?
        /// The device's carrier.
        public let carrier: String?
        /// Information about the device's CPU.
        public let cpu: CPU?
        /// The name of the fleet to which this device belongs.
        public let fleetName: String?
        /// The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.
        public let fleetType: String?
        /// The device's form factor. Allowed values include:   PHONE   TABLET
        public let formFactor: DeviceFormFactor?
        /// The device's heap size, expressed in bytes.
        public let heapSize: Int64?
        /// The device's image name.
        public let image: String?
        /// The instances that belong to this device.
        public let instances: [DeviceInstance]?
        /// The device's manufacturer name.
        public let manufacturer: String?
        /// The device's total memory size, expressed in bytes.
        public let memory: Int64?
        /// The device's model name.
        public let model: String?
        /// The device's model ID.
        public let modelId: String?
        /// The device's display name.
        public let name: String?
        /// The device's operating system type.
        public let os: String?
        /// The device's platform. Allowed values include:   ANDROID   IOS
        public let platform: DevicePlatform?
        /// The device's radio.
        public let radio: String?
        /// Specifies whether remote access has been enabled for the specified device.
        public let remoteAccessEnabled: Bool?
        /// This flag is set to true if remote debugging is enabled for the device. Remote debugging is no longer supported.
        public let remoteDebugEnabled: Bool?
        /// The resolution of the device.
        public let resolution: Resolution?

        public init(arn: String? = nil, availability: DeviceAvailability? = nil, carrier: String? = nil, cpu: CPU? = nil, fleetName: String? = nil, fleetType: String? = nil, formFactor: DeviceFormFactor? = nil, heapSize: Int64? = nil, image: String? = nil, instances: [DeviceInstance]? = nil, manufacturer: String? = nil, memory: Int64? = nil, model: String? = nil, modelId: String? = nil, name: String? = nil, os: String? = nil, platform: DevicePlatform? = nil, radio: String? = nil, remoteAccessEnabled: Bool? = nil, remoteDebugEnabled: Bool? = nil, resolution: Resolution? = nil) {
            self.arn = arn
            self.availability = availability
            self.carrier = carrier
            self.cpu = cpu
            self.fleetName = fleetName
            self.fleetType = fleetType
            self.formFactor = formFactor
            self.heapSize = heapSize
            self.image = image
            self.instances = instances
            self.manufacturer = manufacturer
            self.memory = memory
            self.model = model
            self.modelId = modelId
            self.name = name
            self.os = os
            self.platform = platform
            self.radio = radio
            self.remoteAccessEnabled = remoteAccessEnabled
            self.remoteDebugEnabled = remoteDebugEnabled
            self.resolution = resolution
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case availability
            case carrier
            case cpu
            case fleetName
            case fleetType
            case formFactor
            case heapSize
            case image
            case instances
            case manufacturer
            case memory
            case model
            case modelId
            case name
            case os
            case platform
            case radio
            case remoteAccessEnabled
            case remoteDebugEnabled
            case resolution
        }
    }

    public struct DeviceFilter: AWSEncodableShape & AWSDecodableShape {
        /// The aspect of a device such as platform or model used as the selection criteria in a device filter. The supported operators for each attribute are provided in the following list.  ARN  The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example). Supported operators: EQUALS, IN, NOT_IN   PLATFORM  The device platform. Valid values are ANDROID or IOS. Supported operators: EQUALS   OS_VERSION  The operating system version (for example, 10.3.2). Supported operators: EQUALS, GREATER_THAN, GREATER_THAN_OR_EQUALS, IN, LESS_THAN, LESS_THAN_OR_EQUALS, NOT_IN   MODEL  The device model (for example, iPad 5th Gen). Supported operators: CONTAINS, EQUALS, IN, NOT_IN   AVAILABILITY  The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE. Supported operators: EQUALS   FORM_FACTOR  The device form factor. Valid values are PHONE or TABLET. Supported operators: EQUALS   MANUFACTURER  The device manufacturer (for example, Apple). Supported operators: EQUALS, IN, NOT_IN   REMOTE_ACCESS_ENABLED  Whether the device is enabled for remote access. Valid values are TRUE or FALSE. Supported operators: EQUALS   REMOTE_DEBUG_ENABLED  Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Supported operators: EQUALS  Because remote debugging is no longer supported, this filter is ignored.  INSTANCE_ARN  The Amazon Resource Name (ARN) of the device instance. Supported operators: EQUALS, IN, NOT_IN   INSTANCE_LABELS  The label of the device instance. Supported operators: CONTAINS   FLEET_TYPE  The fleet type. Valid values are PUBLIC or PRIVATE. Supported operators: EQUALS
        public let attribute: DeviceFilterAttribute
        /// Specifies how Device Farm compares the filter's attribute to the value. See the attribute descriptions.
        public let `operator`: RuleOperator
        /// An array of one or more filter values used in a device filter.  Operator Values    The IN and NOT_IN operators can take a values array that has more than one element.   The other operators require an array with a single element.    Attribute Values    The PLATFORM attribute can be set to ANDROID or IOS.   The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.   The FORM_FACTOR attribute can be set to PHONE or TABLET.   The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        public let values: [String]

        public init(attribute: DeviceFilterAttribute, operator: RuleOperator, values: [String]) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case attribute
            case `operator`
            case values
        }
    }

    public struct DeviceInstance: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the device instance.
        public let arn: String?
        /// The ARN of the device.
        public let deviceArn: String?
        /// A object that contains information about the instance profile.
        public let instanceProfile: InstanceProfile?
        /// An array of strings that describe the device instance.
        public let labels: [String]?
        /// The status of the device instance. Valid values are listed here.
        public let status: InstanceStatus?
        /// Unique device identifier for the device instance.
        public let udid: String?

        public init(arn: String? = nil, deviceArn: String? = nil, instanceProfile: InstanceProfile? = nil, labels: [String]? = nil, status: InstanceStatus? = nil, udid: String? = nil) {
            self.arn = arn
            self.deviceArn = deviceArn
            self.instanceProfile = instanceProfile
            self.labels = labels
            self.status = status
            self.udid = udid
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case deviceArn
            case instanceProfile
            case labels
            case status
            case udid
        }
    }

    public struct DeviceMinutes: AWSDecodableShape {
        /// When specified, represents only the sum of metered minutes used by the resource to run tests.
        public let metered: Double?
        /// When specified, represents the total minutes used by the resource to run tests.
        public let total: Double?
        /// When specified, represents only the sum of unmetered minutes used by the resource to run tests.
        public let unmetered: Double?

        public init(metered: Double? = nil, total: Double? = nil, unmetered: Double? = nil) {
            self.metered = metered
            self.total = total
            self.unmetered = unmetered
        }

        private enum CodingKeys: String, CodingKey {
            case metered
            case total
            case unmetered
        }
    }

    public struct DevicePool: AWSDecodableShape {
        /// The device pool's ARN.
        public let arn: String?
        /// The device pool's description.
        public let description: String?
        /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests.
        public let maxDevices: Int?
        /// The device pool's name.
        public let name: String?
        /// Information about the device pool's rules.
        public let rules: [Rule]?
        /// The device pool's type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.
        public let type: DevicePoolType?

        public init(arn: String? = nil, description: String? = nil, maxDevices: Int? = nil, name: String? = nil, rules: [Rule]? = nil, type: DevicePoolType? = nil) {
            self.arn = arn
            self.description = description
            self.maxDevices = maxDevices
            self.name = name
            self.rules = rules
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case maxDevices
            case name
            case rules
            case type
        }
    }

    public struct DevicePoolCompatibilityResult: AWSDecodableShape {
        /// Whether the result was compatible with the device pool.
        public let compatible: Bool?
        /// The device (phone or tablet) to return information about.
        public let device: Device?
        /// Information about the compatibility.
        public let incompatibilityMessages: [IncompatibilityMessage]?

        public init(compatible: Bool? = nil, device: Device? = nil, incompatibilityMessages: [IncompatibilityMessage]? = nil) {
            self.compatible = compatible
            self.device = device
            self.incompatibilityMessages = incompatibilityMessages
        }

        private enum CodingKeys: String, CodingKey {
            case compatible
            case device
            case incompatibilityMessages
        }
    }

    public struct DeviceSelectionConfiguration: AWSEncodableShape {
        /// Used to dynamically select a set of devices for a test run. A filter is made up of an attribute, an operator, and one or more values.    Attribute  The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:   ARN: The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example).   PLATFORM: The device platform. Valid values are ANDROID or IOS.   OS_VERSION: The operating system version (for example, 10.3.2).   MODEL: The device model (for example, iPad 5th Gen).   AVAILABILITY: The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.   FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.   MANUFACTURER: The device manufacturer (for example, Apple).   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values are TRUE or FALSE.   REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Because remote debugging is no longer supported, this filter is ignored.   INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.   INSTANCE_LABELS: The label of the device instance.   FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.      Operator  The filter operator.   The EQUALS operator is available for every attribute except INSTANCE_LABELS.   The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.   The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.   The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.      Values  An array of one or more filter values.  Operator Values    The IN and NOT_IN operators can take a values array that has more than one element.   The other operators require an array with a single element.    Attribute Values    The PLATFORM attribute can be set to ANDROID or IOS.   The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.   The FORM_FACTOR attribute can be set to PHONE or TABLET.   The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        public let filters: [DeviceFilter]
        /// The maximum number of devices to be included in a test run.
        public let maxDevices: Int

        public init(filters: [DeviceFilter], maxDevices: Int) {
            self.filters = filters
            self.maxDevices = maxDevices
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxDevices
        }
    }

    public struct DeviceSelectionResult: AWSDecodableShape {
        /// The filters in a device selection result.
        public let filters: [DeviceFilter]?
        /// The number of devices that matched the device filter selection criteria.
        public let matchedDevicesCount: Int?
        /// The maximum number of devices to be selected by a device filter and included in a test run.
        public let maxDevices: Int?

        public init(filters: [DeviceFilter]? = nil, matchedDevicesCount: Int? = nil, maxDevices: Int? = nil) {
            self.filters = filters
            self.matchedDevicesCount = matchedDevicesCount
            self.maxDevices = maxDevices
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case matchedDevicesCount
            case maxDevices
        }
    }

    public struct ExecutionConfiguration: AWSEncodableShape {
        /// True if account cleanup is enabled at the beginning of the test. Otherwise, false.
        public let accountsCleanup: Bool?
        /// True if app package cleanup is enabled at the beginning of the test. Otherwise, false.
        public let appPackagesCleanup: Bool?
        /// The number of minutes a test run executes before it times out.
        public let jobTimeoutMinutes: Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?
        /// Set to true to enable video capture. Otherwise, set to false. The default is true.
        public let videoCapture: Bool?

        public init(accountsCleanup: Bool? = nil, appPackagesCleanup: Bool? = nil, jobTimeoutMinutes: Int? = nil, skipAppResign: Bool? = nil, videoCapture: Bool? = nil) {
            self.accountsCleanup = accountsCleanup
            self.appPackagesCleanup = appPackagesCleanup
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.skipAppResign = skipAppResign
            self.videoCapture = videoCapture
        }

        private enum CodingKeys: String, CodingKey {
            case accountsCleanup
            case appPackagesCleanup
            case jobTimeoutMinutes
            case skipAppResign
            case videoCapture
        }
    }

    public struct GetAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsResult: AWSDecodableShape {
        /// The account settings.
        public let accountSettings: AccountSettings?

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings
        }
    }

    public struct GetDeviceInstanceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the instance you're requesting information about.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetDeviceInstanceResult: AWSDecodableShape {
        /// An object that contains information about your device instance.
        public let deviceInstance: DeviceInstance?

        public init(deviceInstance: DeviceInstance? = nil) {
            self.deviceInstance = deviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case deviceInstance
        }
    }

    public struct GetDevicePoolCompatibilityRequest: AWSEncodableShape {
        /// The ARN of the app that is associated with the specified device pool.
        public let appArn: String?
        /// An object that contains information about the settings for a run.
        public let configuration: ScheduleRunConfiguration?
        /// The device pool's ARN.
        public let devicePoolArn: String
        /// Information about the uploaded test to be run against the device pool.
        public let test: ScheduleRunTest?
        /// The test type for the specified device pool. Allowed values include the following:   BUILTIN_FUZZ.   BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT.   APPIUM_JAVA_TESTNG.   APPIUM_PYTHON.   APPIUM_NODE.   APPIUM_RUBY.   APPIUM_WEB_JAVA_JUNIT.   APPIUM_WEB_JAVA_TESTNG.   APPIUM_WEB_PYTHON.   APPIUM_WEB_NODE.   APPIUM_WEB_RUBY.   CALABASH.   INSTRUMENTATION.   UIAUTOMATION.   UIAUTOMATOR.   XCTEST.   XCTEST_UI.
        public let testType: TestType?

        public init(appArn: String? = nil, configuration: ScheduleRunConfiguration? = nil, devicePoolArn: String, test: ScheduleRunTest? = nil, testType: TestType? = nil) {
            self.appArn = appArn
            self.configuration = configuration
            self.devicePoolArn = devicePoolArn
            self.test = test
            self.testType = testType
        }

        public func validate(name: String) throws {
            try self.validate(self.appArn, name: "appArn", parent: name, max: 1011)
            try self.validate(self.appArn, name: "appArn", parent: name, min: 32)
            try self.validate(self.appArn, name: "appArn", parent: name, pattern: "^arn:.+")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.devicePoolArn, name: "devicePoolArn", parent: name, max: 1011)
            try self.validate(self.devicePoolArn, name: "devicePoolArn", parent: name, min: 32)
            try self.validate(self.devicePoolArn, name: "devicePoolArn", parent: name, pattern: "^arn:.+")
            try self.test?.validate(name: "\(name).test")
        }

        private enum CodingKeys: String, CodingKey {
            case appArn
            case configuration
            case devicePoolArn
            case test
            case testType
        }
    }

    public struct GetDevicePoolCompatibilityResult: AWSDecodableShape {
        /// Information about compatible devices.
        public let compatibleDevices: [DevicePoolCompatibilityResult]?
        /// Information about incompatible devices.
        public let incompatibleDevices: [DevicePoolCompatibilityResult]?

        public init(compatibleDevices: [DevicePoolCompatibilityResult]? = nil, incompatibleDevices: [DevicePoolCompatibilityResult]? = nil) {
            self.compatibleDevices = compatibleDevices
            self.incompatibleDevices = incompatibleDevices
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleDevices
            case incompatibleDevices
        }
    }

    public struct GetDevicePoolRequest: AWSEncodableShape {
        /// The device pool's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetDevicePoolResult: AWSDecodableShape {
        /// An object that contains information about the requested device pool.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool
        }
    }

    public struct GetDeviceRequest: AWSEncodableShape {
        /// The device type's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetDeviceResult: AWSDecodableShape {
        /// An object that contains information about the requested device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device
        }
    }

    public struct GetInstanceProfileRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of an instance profile.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetInstanceProfileResult: AWSDecodableShape {
        /// An object that contains information about an instance profile.
        public let instanceProfile: InstanceProfile?

        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        /// The job's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetJobResult: AWSDecodableShape {
        /// An object that contains information about the requested job.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct GetNetworkProfileRequest: AWSEncodableShape {
        /// The ARN of the network profile to return information about.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetNetworkProfileResult: AWSDecodableShape {
        /// The network profile.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile
        }
    }

    public struct GetOfferingStatusRequest: AWSEncodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
        }
    }

    public struct GetOfferingStatusResult: AWSDecodableShape {
        /// When specified, gets the offering status for the current period.
        public let current: [String: OfferingStatus]?
        /// When specified, gets the offering status for the next period.
        public let nextPeriod: [String: OfferingStatus]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(current: [String: OfferingStatus]? = nil, nextPeriod: [String: OfferingStatus]? = nil, nextToken: String? = nil) {
            self.current = current
            self.nextPeriod = nextPeriod
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case current
            case nextPeriod
            case nextToken
        }
    }

    public struct GetProjectRequest: AWSEncodableShape {
        /// The project's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetProjectResult: AWSDecodableShape {
        /// The project to get information about.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project
        }
    }

    public struct GetRemoteAccessSessionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the remote access session about which you want to get session information.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetRemoteAccessSessionResult: AWSDecodableShape {
        /// A container that lists detailed information about the remote access session.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession
        }
    }

    public struct GetRunRequest: AWSEncodableShape {
        /// The run's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetRunResult: AWSDecodableShape {
        /// The run to get results from.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run
        }
    }

    public struct GetSuiteRequest: AWSEncodableShape {
        /// The suite's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetSuiteResult: AWSDecodableShape {
        /// A collection of one or more tests.
        public let suite: Suite?

        public init(suite: Suite? = nil) {
            self.suite = suite
        }

        private enum CodingKeys: String, CodingKey {
            case suite
        }
    }

    public struct GetTestGridProjectRequest: AWSEncodableShape {
        /// The ARN of the Selenium testing project, from either CreateTestGridProject or ListTestGridProjects.
        public let projectArn: String

        public init(projectArn: String) {
            self.projectArn = projectArn
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn
        }
    }

    public struct GetTestGridProjectResult: AWSDecodableShape {
        /// A TestGridProject.
        public let testGridProject: TestGridProject?

        public init(testGridProject: TestGridProject? = nil) {
            self.testGridProject = testGridProject
        }

        private enum CodingKeys: String, CodingKey {
            case testGridProject
        }
    }

    public struct GetTestGridSessionRequest: AWSEncodableShape {
        /// The ARN for the project that this session belongs to. See CreateTestGridProject and ListTestGridProjects.
        public let projectArn: String?
        /// An ARN that uniquely identifies a TestGridSession.
        public let sessionArn: String?
        /// An ID associated with this session.
        public let sessionId: String?

        public init(projectArn: String? = nil, sessionArn: String? = nil, sessionId: String? = nil) {
            self.projectArn = projectArn
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, max: 1011)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, min: 32)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 128)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn
            case sessionArn
            case sessionId
        }
    }

    public struct GetTestGridSessionResult: AWSDecodableShape {
        /// The TestGridSession that was requested.
        public let testGridSession: TestGridSession?

        public init(testGridSession: TestGridSession? = nil) {
            self.testGridSession = testGridSession
        }

        private enum CodingKeys: String, CodingKey {
            case testGridSession
        }
    }

    public struct GetTestRequest: AWSEncodableShape {
        /// The test's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetTestResult: AWSDecodableShape {
        /// A test condition that is evaluated.
        public let test: Test?

        public init(test: Test? = nil) {
            self.test = test
        }

        private enum CodingKeys: String, CodingKey {
            case test
        }
    }

    public struct GetUploadRequest: AWSEncodableShape {
        /// The upload's ARN.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetUploadResult: AWSDecodableShape {
        /// An app or a set of one or more tests to upload or that have been uploaded.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload
        }
    }

    public struct GetVPCEConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to describe.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct GetVPCEConfigurationResult: AWSDecodableShape {
        /// An object that contains information about your VPC endpoint configuration.
        public let vpceConfiguration: VPCEConfiguration?

        public init(vpceConfiguration: VPCEConfiguration? = nil) {
            self.vpceConfiguration = vpceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfiguration
        }
    }

    public struct IncompatibilityMessage: AWSDecodableShape {
        /// A message about the incompatibility.
        public let message: String?
        /// The type of incompatibility. Allowed values include:   ARN   FORM_FACTOR (for example, phone or tablet)   MANUFACTURER   PLATFORM (for example, Android or iOS)   REMOTE_ACCESS_ENABLED   APPIUM_VERSION
        public let type: DeviceAttribute?

        public init(message: String? = nil, type: DeviceAttribute? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message
            case type
        }
    }

    public struct InstallToRemoteAccessSessionRequest: AWSEncodableShape {
        /// The ARN of the app about which you are requesting information.
        public let appArn: String
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public let remoteAccessSessionArn: String

        public init(appArn: String, remoteAccessSessionArn: String) {
            self.appArn = appArn
            self.remoteAccessSessionArn = remoteAccessSessionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.appArn, name: "appArn", parent: name, max: 1011)
            try self.validate(self.appArn, name: "appArn", parent: name, min: 32)
            try self.validate(self.appArn, name: "appArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.remoteAccessSessionArn, name: "remoteAccessSessionArn", parent: name, max: 1011)
            try self.validate(self.remoteAccessSessionArn, name: "remoteAccessSessionArn", parent: name, min: 32)
            try self.validate(self.remoteAccessSessionArn, name: "remoteAccessSessionArn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case appArn
            case remoteAccessSessionArn
        }
    }

    public struct InstallToRemoteAccessSessionResult: AWSDecodableShape {
        /// An app to upload or that has been uploaded.
        public let appUpload: Upload?

        public init(appUpload: Upload? = nil) {
            self.appUpload = appUpload
        }

        private enum CodingKeys: String, CodingKey {
            case appUpload
        }
    }

    public struct InstanceProfile: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String?
        /// The description of the instance profile.
        public let description: String?
        /// An array of strings containing the list of app packages that should not be cleaned up from the device after a test run completes. The list of packages is considered only if you set packageCleanup to true.
        public let excludeAppPackagesFromCleanup: [String]?
        /// The name of the instance profile.
        public let name: String?
        /// When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
        public let packageCleanup: Bool?
        /// When set to true, Device Farm reboots the instance after a test run. The default value is true.
        public let rebootAfterUse: Bool?

        public init(arn: String? = nil, description: String? = nil, excludeAppPackagesFromCleanup: [String]? = nil, name: String? = nil, packageCleanup: Bool? = nil, rebootAfterUse: Bool? = nil) {
            self.arn = arn
            self.description = description
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.packageCleanup = packageCleanup
            self.rebootAfterUse = rebootAfterUse
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case excludeAppPackagesFromCleanup
            case name
            case packageCleanup
            case rebootAfterUse
        }
    }

    public struct Job: AWSDecodableShape {
        /// The job's ARN.
        public let arn: String?
        /// The job's result counters.
        public let counters: Counters?
        /// When the job was created.
        public let created: Date?
        /// The device (phone or tablet).
        public let device: Device?
        /// Represents the total (metered or unmetered) minutes used by the job.
        public let deviceMinutes: DeviceMinutes?
        /// The ARN of the instance.
        public let instanceArn: String?
        /// A message about the job's result.
        public let message: String?
        /// The job's name.
        public let name: String?
        /// The job's result. Allowed values include:   PENDING   PASSED   WARNED   FAILED   SKIPPED   ERRORED   STOPPED
        public let result: ExecutionResult?
        /// The job's start time.
        public let started: Date?
        /// The job's status. Allowed values include:   PENDING   PENDING_CONCURRENCY   PENDING_DEVICE   PROCESSING   SCHEDULING   PREPARING   RUNNING   COMPLETED   STOPPING
        public let status: ExecutionStatus?
        /// The job's stop time.
        public let stopped: Date?
        /// The job's type. Allowed values include the following:   BUILTIN_FUZZ   BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT   APPIUM_JAVA_TESTNG   APPIUM_PYTHON   APPIUM_NODE   APPIUM_RUBY   APPIUM_WEB_JAVA_JUNIT   APPIUM_WEB_JAVA_TESTNG   APPIUM_WEB_PYTHON   APPIUM_WEB_NODE   APPIUM_WEB_RUBY   CALABASH   INSTRUMENTATION   UIAUTOMATION   UIAUTOMATOR   XCTEST   XCTEST_UI
        public let type: TestType?
        /// This value is set to true if video capture is enabled. Otherwise, it is set to false.
        public let videoCapture: Bool?
        /// The endpoint for streaming device video.
        public let videoEndpoint: String?

        public init(arn: String? = nil, counters: Counters? = nil, created: Date? = nil, device: Device? = nil, deviceMinutes: DeviceMinutes? = nil, instanceArn: String? = nil, message: String? = nil, name: String? = nil, result: ExecutionResult? = nil, started: Date? = nil, status: ExecutionStatus? = nil, stopped: Date? = nil, type: TestType? = nil, videoCapture: Bool? = nil, videoEndpoint: String? = nil) {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.instanceArn = instanceArn
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
            self.videoCapture = videoCapture
            self.videoEndpoint = videoEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case counters
            case created
            case device
            case deviceMinutes
            case instanceArn
            case message
            case name
            case result
            case started
            case status
            case stopped
            case type
            case videoCapture
            case videoEndpoint
        }
    }

    public struct ListArtifactsRequest: AWSEncodableShape {
        /// The run, job, suite, or test ARN.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The artifacts' type. Allowed values include:   FILE   LOG   SCREENSHOT
        public let type: ArtifactCategory

        public init(arn: String, nextToken: String? = nil, type: ArtifactCategory) {
            self.arn = arn
            self.nextToken = nextToken
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
            case type
        }
    }

    public struct ListArtifactsResult: AWSDecodableShape {
        /// Information about the artifacts.
        public let artifacts: [Artifact]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(artifacts: [Artifact]? = nil, nextToken: String? = nil) {
            self.artifacts = artifacts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts
            case nextToken
        }
    }

    public struct ListDeviceInstancesRequest: AWSEncodableShape {
        /// An integer that specifies the maximum number of items you want to return in the API response.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListDeviceInstancesResult: AWSDecodableShape {
        /// An object that contains information about your device instances.
        public let deviceInstances: [DeviceInstance]?
        /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(deviceInstances: [DeviceInstance]? = nil, nextToken: String? = nil) {
            self.deviceInstances = deviceInstances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deviceInstances
            case nextToken
        }
    }

    public struct ListDevicePoolsRequest: AWSEncodableShape {
        /// The project ARN.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The device pools' type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.
        public let type: DevicePoolType?

        public init(arn: String, nextToken: String? = nil, type: DevicePoolType? = nil) {
            self.arn = arn
            self.nextToken = nextToken
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
            case type
        }
    }

    public struct ListDevicePoolsResult: AWSDecodableShape {
        /// Information about the device pools.
        public let devicePools: [DevicePool]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(devicePools: [DevicePool]? = nil, nextToken: String? = nil) {
            self.devicePools = devicePools
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devicePools
            case nextToken
        }
    }

    public struct ListDevicesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project.
        public let arn: String?
        /// Used to select a set of devices. A filter is made up of an attribute, an operator, and one or more values.   Attribute: The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:   ARN: The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example).   PLATFORM: The device platform. Valid values are ANDROID or IOS.   OS_VERSION: The operating system version (for example, 10.3.2).   MODEL: The device model (for example, iPad 5th Gen).   AVAILABILITY: The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.   FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.   MANUFACTURER: The device manufacturer (for example, Apple).   REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values are TRUE or FALSE.   REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Because remote debugging is no longer supported, this attribute is ignored.   INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.   INSTANCE_LABELS: The label of the device instance.   FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.     Operator: The filter operator.   The EQUALS operator is available for every attribute except INSTANCE_LABELS.   The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.   The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.   The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.     Values: An array of one or more filter values.   The IN and NOT_IN operators take a values array that has one or more elements.   The other operators require an array with a single element.   In a request, the AVAILABILITY attribute takes the following values: AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        public let filters: [DeviceFilter]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String? = nil, filters: [DeviceFilter]? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.filters = filters
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case filters
            case nextToken
        }
    }

    public struct ListDevicesResult: AWSDecodableShape {
        /// Information about the devices.
        public let devices: [Device]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(devices: [Device]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices
            case nextToken
        }
    }

    public struct ListInstanceProfilesRequest: AWSEncodableShape {
        /// An integer that specifies the maximum number of items you want to return in the API response.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListInstanceProfilesResult: AWSDecodableShape {
        /// An object that contains information about your instance profiles.
        public let instanceProfiles: [InstanceProfile]?
        /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(instanceProfiles: [InstanceProfile]? = nil, nextToken: String? = nil) {
            self.instanceProfiles = instanceProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfiles
            case nextToken
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        /// The run's Amazon Resource Name (ARN).
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListJobsResult: AWSDecodableShape {
        /// Information about the jobs.
        public let jobs: [Job]?
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs
            case nextToken
        }
    }

    public struct ListNetworkProfilesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project for which you want to list network profiles.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The type of network profile to return information about. Valid values are listed here.
        public let type: NetworkProfileType?

        public init(arn: String, nextToken: String? = nil, type: NetworkProfileType? = nil) {
            self.arn = arn
            self.nextToken = nextToken
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
            case type
        }
    }

    public struct ListNetworkProfilesResult: AWSDecodableShape {
        /// A list of the available network profiles.
        public let networkProfiles: [NetworkProfile]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(networkProfiles: [NetworkProfile]? = nil, nextToken: String? = nil) {
            self.networkProfiles = networkProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfiles
            case nextToken
        }
    }

    public struct ListOfferingPromotionsRequest: AWSEncodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
        }
    }

    public struct ListOfferingPromotionsResult: AWSDecodableShape {
        /// An identifier to be used in the next call to this operation, to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the offering promotions.
        public let offeringPromotions: [OfferingPromotion]?

        public init(nextToken: String? = nil, offeringPromotions: [OfferingPromotion]? = nil) {
            self.nextToken = nextToken
            self.offeringPromotions = offeringPromotions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case offeringPromotions
        }
    }

    public struct ListOfferingTransactionsRequest: AWSEncodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
        }
    }

    public struct ListOfferingTransactionsResult: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The audit log of subscriptions you have purchased and modified through AWS Device Farm.
        public let offeringTransactions: [OfferingTransaction]?

        public init(nextToken: String? = nil, offeringTransactions: [OfferingTransaction]? = nil) {
            self.nextToken = nextToken
            self.offeringTransactions = offeringTransactions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case offeringTransactions
        }
    }

    public struct ListOfferingsRequest: AWSEncodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
        }
    }

    public struct ListOfferingsResult: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A value that represents the list offering results.
        public let offerings: [Offering]?

        public init(nextToken: String? = nil, offerings: [Offering]? = nil) {
            self.nextToken = nextToken
            self.offerings = offerings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case offerings
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm returns a list of all projects for the AWS account. You can also specify a project ARN.
        public let arn: String?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListProjectsResult: AWSDecodableShape {
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the projects.
        public let projects: [Project]?

        public init(nextToken: String? = nil, projects: [Project]? = nil) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case projects
        }
    }

    public struct ListRemoteAccessSessionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project about which you are requesting information.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListRemoteAccessSessionsResult: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// A container that represents the metadata from the service about each remote access session you are requesting.
        public let remoteAccessSessions: [RemoteAccessSession]?

        public init(nextToken: String? = nil, remoteAccessSessions: [RemoteAccessSession]? = nil) {
            self.nextToken = nextToken
            self.remoteAccessSessions = remoteAccessSessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case remoteAccessSessions
        }
    }

    public struct ListRunsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project for which you want to list runs.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListRunsResult: AWSDecodableShape {
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the runs.
        public let runs: [Run]?

        public init(nextToken: String? = nil, runs: [Run]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case runs
        }
    }

    public struct ListSamplesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the job used to list samples.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListSamplesResult: AWSDecodableShape {
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the samples.
        public let samples: [Sample]?

        public init(nextToken: String? = nil, samples: [Sample]? = nil) {
            self.nextToken = nextToken
            self.samples = samples
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case samples
        }
    }

    public struct ListSuitesRequest: AWSEncodableShape {
        /// The job's Amazon Resource Name (ARN).
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListSuitesResult: AWSDecodableShape {
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the suites.
        public let suites: [Suite]?

        public init(nextToken: String? = nil, suites: [Suite]? = nil) {
            self.nextToken = nextToken
            self.suites = suites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case suites
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource or resources for which to list tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 32)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws:devicefarm:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTestGridProjectsRequest: AWSEncodableShape {
        /// Return no more than this number of results.
        public let maxResult: Int?
        /// From a response, used to continue a paginated listing.
        public let nextToken: String?

        public init(maxResult: Int? = nil, nextToken: String? = nil) {
            self.maxResult = maxResult
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResult, name: "maxResult", parent: name, max: 1000)
            try self.validate(self.maxResult, name: "maxResult", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResult
            case nextToken
        }
    }

    public struct ListTestGridProjectsResult: AWSDecodableShape {
        /// Used for pagination. Pass into ListTestGridProjects to get more results in a paginated request.
        public let nextToken: String?
        /// The list of TestGridProjects, based on a ListTestGridProjectsRequest.
        public let testGridProjects: [TestGridProject]?

        public init(nextToken: String? = nil, testGridProjects: [TestGridProject]? = nil) {
            self.nextToken = nextToken
            self.testGridProjects = testGridProjects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case testGridProjects
        }
    }

    public struct ListTestGridSessionActionsRequest: AWSEncodableShape {
        /// The maximum number of sessions to return per response.
        public let maxResult: Int?
        /// Pagination token.
        public let nextToken: String?
        /// The ARN of the session to retrieve.
        public let sessionArn: String

        public init(maxResult: Int? = nil, nextToken: String? = nil, sessionArn: String) {
            self.maxResult = maxResult
            self.nextToken = nextToken
            self.sessionArn = sessionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResult, name: "maxResult", parent: name, max: 1000)
            try self.validate(self.maxResult, name: "maxResult", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, max: 1011)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, min: 32)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResult
            case nextToken
            case sessionArn
        }
    }

    public struct ListTestGridSessionActionsResult: AWSDecodableShape {
        /// The action taken by the session.
        public let actions: [TestGridSessionAction]?
        /// Pagination token.
        public let nextToken: String?

        public init(actions: [TestGridSessionAction]? = nil, nextToken: String? = nil) {
            self.actions = actions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case nextToken
        }
    }

    public struct ListTestGridSessionArtifactsRequest: AWSEncodableShape {
        /// The maximum number of results to be returned by a request.
        public let maxResult: Int?
        /// Pagination token.
        public let nextToken: String?
        /// The ARN of a TestGridSession.
        public let sessionArn: String
        /// Limit results to a specified type of artifact.
        public let type: TestGridSessionArtifactCategory?

        public init(maxResult: Int? = nil, nextToken: String? = nil, sessionArn: String, type: TestGridSessionArtifactCategory? = nil) {
            self.maxResult = maxResult
            self.nextToken = nextToken
            self.sessionArn = sessionArn
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResult, name: "maxResult", parent: name, max: 1000)
            try self.validate(self.maxResult, name: "maxResult", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, max: 1011)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, min: 32)
            try self.validate(self.sessionArn, name: "sessionArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResult
            case nextToken
            case sessionArn
            case type
        }
    }

    public struct ListTestGridSessionArtifactsResult: AWSDecodableShape {
        /// A list of test grid session artifacts for a TestGridSession.
        public let artifacts: [TestGridSessionArtifact]?
        /// Pagination token.
        public let nextToken: String?

        public init(artifacts: [TestGridSessionArtifact]? = nil, nextToken: String? = nil) {
            self.artifacts = artifacts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts
            case nextToken
        }
    }

    public struct ListTestGridSessionsRequest: AWSEncodableShape {
        /// Return only sessions created after this time.
        public let creationTimeAfter: Date?
        /// Return only sessions created before this time.
        public let creationTimeBefore: Date?
        /// Return only sessions that ended after this time.
        public let endTimeAfter: Date?
        /// Return only sessions that ended before this time.
        public let endTimeBefore: Date?
        /// Return only this many results at a time.
        public let maxResult: Int?
        /// Pagination token.
        public let nextToken: String?
        /// ARN of a TestGridProject.
        public let projectArn: String
        /// Return only sessions in this state.
        public let status: TestGridSessionStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, endTimeAfter: Date? = nil, endTimeBefore: Date? = nil, maxResult: Int? = nil, nextToken: String? = nil, projectArn: String, status: TestGridSessionStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.endTimeAfter = endTimeAfter
            self.endTimeBefore = endTimeBefore
            self.maxResult = maxResult
            self.nextToken = nextToken
            self.projectArn = projectArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResult, name: "maxResult", parent: name, max: 1000)
            try self.validate(self.maxResult, name: "maxResult", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimeAfter
            case creationTimeBefore
            case endTimeAfter
            case endTimeBefore
            case maxResult
            case nextToken
            case projectArn
            case status
        }
    }

    public struct ListTestGridSessionsResult: AWSDecodableShape {
        /// Pagination token.
        public let nextToken: String?
        /// The sessions that match the criteria in a ListTestGridSessionsRequest.
        public let testGridSessions: [TestGridSession]?

        public init(nextToken: String? = nil, testGridSessions: [TestGridSession]? = nil) {
            self.nextToken = nextToken
            self.testGridSessions = testGridSessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case testGridSessions
        }
    }

    public struct ListTestsRequest: AWSEncodableShape {
        /// The test suite's Amazon Resource Name (ARN).
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListTestsResult: AWSDecodableShape {
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the tests.
        public let tests: [Test]?

        public init(nextToken: String? = nil, tests: [Test]? = nil) {
            self.nextToken = nextToken
            self.tests = tests
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case tests
        }
    }

    public struct ListUniqueProblemsRequest: AWSEncodableShape {
        /// The unique problems' ARNs.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(arn: String, nextToken: String? = nil) {
            self.arn = arn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
        }
    }

    public struct ListUniqueProblemsResult: AWSDecodableShape {
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the unique problems. Allowed values include:   PENDING   PASSED   WARNED   FAILED   SKIPPED   ERRORED   STOPPED
        public let uniqueProblems: [ExecutionResult: [UniqueProblem]]?

        public init(nextToken: String? = nil, uniqueProblems: [ExecutionResult: [UniqueProblem]]? = nil) {
            self.nextToken = nextToken
            self.uniqueProblems = uniqueProblems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case uniqueProblems
        }
    }

    public struct ListUploadsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project for which you want to list uploads.
        public let arn: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The type of upload. Must be one of the following values:   ANDROID_APP   IOS_APP   WEB_APP   EXTERNAL_DATA   APPIUM_JAVA_JUNIT_TEST_PACKAGE   APPIUM_JAVA_TESTNG_TEST_PACKAGE   APPIUM_PYTHON_TEST_PACKAGE   APPIUM_NODE_TEST_PACKAGE   APPIUM_RUBY_TEST_PACKAGE   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE   APPIUM_WEB_PYTHON_TEST_PACKAGE   APPIUM_WEB_NODE_TEST_PACKAGE   APPIUM_WEB_RUBY_TEST_PACKAGE   CALABASH_TEST_PACKAGE   INSTRUMENTATION_TEST_PACKAGE   UIAUTOMATION_TEST_PACKAGE   UIAUTOMATOR_TEST_PACKAGE   XCTEST_TEST_PACKAGE   XCTEST_UI_TEST_PACKAGE   APPIUM_JAVA_JUNIT_TEST_SPEC   APPIUM_JAVA_TESTNG_TEST_SPEC   APPIUM_PYTHON_TEST_SPEC   APPIUM_NODE_TEST_SPEC    APPIUM_RUBY_TEST_SPEC   APPIUM_WEB_JAVA_JUNIT_TEST_SPEC   APPIUM_WEB_JAVA_TESTNG_TEST_SPEC   APPIUM_WEB_PYTHON_TEST_SPEC   APPIUM_WEB_NODE_TEST_SPEC   APPIUM_WEB_RUBY_TEST_SPEC   INSTRUMENTATION_TEST_SPEC   XCTEST_UI_TEST_SPEC
        public let type: UploadType?

        public init(arn: String, nextToken: String? = nil, type: UploadType? = nil) {
            self.arn = arn
            self.nextToken = nextToken
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case nextToken
            case type
        }
    }

    public struct ListUploadsResult: AWSDecodableShape {
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// Information about the uploads.
        public let uploads: [Upload]?

        public init(nextToken: String? = nil, uploads: [Upload]? = nil) {
            self.nextToken = nextToken
            self.uploads = uploads
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case uploads
        }
    }

    public struct ListVPCEConfigurationsRequest: AWSEncodableShape {
        /// An integer that specifies the maximum number of items you want to return in the API response.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListVPCEConfigurationsResult: AWSDecodableShape {
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// An array of VPCEConfiguration objects that contain information about your VPC endpoint configuration.
        public let vpceConfigurations: [VPCEConfiguration]?

        public init(nextToken: String? = nil, vpceConfigurations: [VPCEConfiguration]? = nil) {
            self.nextToken = nextToken
            self.vpceConfigurations = vpceConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case vpceConfigurations
        }
    }

    public struct Location: AWSEncodableShape & AWSDecodableShape {
        /// The latitude.
        public let latitude: Double
        /// The longitude.
        public let longitude: Double

        public init(latitude: Double, longitude: Double) {
            self.latitude = latitude
            self.longitude = longitude
        }

        private enum CodingKeys: String, CodingKey {
            case latitude
            case longitude
        }
    }

    public struct MonetaryAmount: AWSDecodableShape {
        /// The numerical amount of an offering or transaction.
        public let amount: Double?
        /// The currency code of a monetary amount. For example, USD means U.S. dollars.
        public let currencyCode: CurrencyCode?

        public init(amount: Double? = nil, currencyCode: CurrencyCode? = nil) {
            self.amount = amount
            self.currencyCode = currencyCode
        }

        private enum CodingKeys: String, CodingKey {
            case amount
            case currencyCode
        }
    }

    public struct NetworkProfile: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the network profile.
        public let arn: String?
        /// The description of the network profile.
        public let description: String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int?
        /// The name of the network profile.
        public let name: String?
        /// The type of network profile. Valid values are listed here.
        public let type: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int?

        public init(arn: String? = nil, description: String? = nil, downlinkBandwidthBits: Int64? = nil, downlinkDelayMs: Int64? = nil, downlinkJitterMs: Int64? = nil, downlinkLossPercent: Int? = nil, name: String? = nil, type: NetworkProfileType? = nil, uplinkBandwidthBits: Int64? = nil, uplinkDelayMs: Int64? = nil, uplinkJitterMs: Int64? = nil, uplinkLossPercent: Int? = nil) {
            self.arn = arn
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.downlinkDelayMs = downlinkDelayMs
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkLossPercent = downlinkLossPercent
            self.name = name
            self.type = type
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkJitterMs = uplinkJitterMs
            self.uplinkLossPercent = uplinkLossPercent
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case downlinkBandwidthBits
            case downlinkDelayMs
            case downlinkJitterMs
            case downlinkLossPercent
            case name
            case type
            case uplinkBandwidthBits
            case uplinkDelayMs
            case uplinkJitterMs
            case uplinkLossPercent
        }
    }

    public struct Offering: AWSDecodableShape {
        /// A string that describes the offering.
        public let description: String?
        /// The ID that corresponds to a device offering.
        public let id: String?
        /// The platform of the device (for example, ANDROID or IOS).
        public let platform: DevicePlatform?
        /// Specifies whether there are recurring charges for the offering.
        public let recurringCharges: [RecurringCharge]?
        /// The type of offering (for example, RECURRING) for a device.
        public let type: OfferingType?

        public init(description: String? = nil, id: String? = nil, platform: DevicePlatform? = nil, recurringCharges: [RecurringCharge]? = nil, type: OfferingType? = nil) {
            self.description = description
            self.id = id
            self.platform = platform
            self.recurringCharges = recurringCharges
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case id
            case platform
            case recurringCharges
            case type
        }
    }

    public struct OfferingPromotion: AWSDecodableShape {
        /// A string that describes the offering promotion.
        public let description: String?
        /// The ID of the offering promotion.
        public let id: String?

        public init(description: String? = nil, id: String? = nil) {
            self.description = description
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case id
        }
    }

    public struct OfferingStatus: AWSDecodableShape {
        /// The date on which the offering is effective.
        public let effectiveOn: Date?
        /// Represents the metadata of an offering status.
        public let offering: Offering?
        /// The number of available devices in the offering.
        public let quantity: Int?
        /// The type specified for the offering status.
        public let type: OfferingTransactionType?

        public init(effectiveOn: Date? = nil, offering: Offering? = nil, quantity: Int? = nil, type: OfferingTransactionType? = nil) {
            self.effectiveOn = effectiveOn
            self.offering = offering
            self.quantity = quantity
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveOn
            case offering
            case quantity
            case type
        }
    }

    public struct OfferingTransaction: AWSDecodableShape {
        /// The cost of an offering transaction.
        public let cost: MonetaryAmount?
        /// The date on which an offering transaction was created.
        public let createdOn: Date?
        /// The ID that corresponds to a device offering promotion.
        public let offeringPromotionId: String?
        /// The status of an offering transaction.
        public let offeringStatus: OfferingStatus?
        /// The transaction ID of the offering transaction.
        public let transactionId: String?

        public init(cost: MonetaryAmount? = nil, createdOn: Date? = nil, offeringPromotionId: String? = nil, offeringStatus: OfferingStatus? = nil, transactionId: String? = nil) {
            self.cost = cost
            self.createdOn = createdOn
            self.offeringPromotionId = offeringPromotionId
            self.offeringStatus = offeringStatus
            self.transactionId = transactionId
        }

        private enum CodingKeys: String, CodingKey {
            case cost
            case createdOn
            case offeringPromotionId
            case offeringStatus
            case transactionId
        }
    }

    public struct Problem: AWSDecodableShape {
        /// Information about the associated device.
        public let device: Device?
        /// Information about the associated job.
        public let job: ProblemDetail?
        /// A message about the problem's result.
        public let message: String?
        /// The problem's result. Allowed values include:   PENDING   PASSED   WARNED   FAILED   SKIPPED   ERRORED   STOPPED
        public let result: ExecutionResult?
        /// Information about the associated run.
        public let run: ProblemDetail?
        /// Information about the associated suite.
        public let suite: ProblemDetail?
        /// Information about the associated test.
        public let test: ProblemDetail?

        public init(device: Device? = nil, job: ProblemDetail? = nil, message: String? = nil, result: ExecutionResult? = nil, run: ProblemDetail? = nil, suite: ProblemDetail? = nil, test: ProblemDetail? = nil) {
            self.device = device
            self.job = job
            self.message = message
            self.result = result
            self.run = run
            self.suite = suite
            self.test = test
        }

        private enum CodingKeys: String, CodingKey {
            case device
            case job
            case message
            case result
            case run
            case suite
            case test
        }
    }

    public struct ProblemDetail: AWSDecodableShape {
        /// The problem detail's ARN.
        public let arn: String?
        /// The problem detail's name.
        public let name: String?

        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case name
        }
    }

    public struct Project: AWSDecodableShape {
        /// The project's ARN.
        public let arn: String?
        /// When the project was created.
        public let created: Date?
        /// The default number of minutes (at the project level) a test run executes before it times out. The default value is 150 minutes.
        public let defaultJobTimeoutMinutes: Int?
        /// The project's name.
        public let name: String?

        public init(arn: String? = nil, created: Date? = nil, defaultJobTimeoutMinutes: Int? = nil, name: String? = nil) {
            self.arn = arn
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case created
            case defaultJobTimeoutMinutes
            case name
        }
    }

    public struct PurchaseOfferingRequest: AWSEncodableShape {
        /// The ID of the offering.
        public let offeringId: String
        /// The ID of the offering promotion to be applied to the purchase.
        public let offeringPromotionId: String?
        /// The number of device slots to purchase in an offering request.
        public let quantity: Int

        public init(offeringId: String, offeringPromotionId: String? = nil, quantity: Int) {
            self.offeringId = offeringId
            self.offeringPromotionId = offeringPromotionId
            self.quantity = quantity
        }

        public func validate(name: String) throws {
            try self.validate(self.offeringId, name: "offeringId", parent: name, min: 32)
            try self.validate(self.offeringPromotionId, name: "offeringPromotionId", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case offeringId
            case offeringPromotionId
            case quantity
        }
    }

    public struct PurchaseOfferingResult: AWSDecodableShape {
        /// Represents the offering transaction for the purchase result.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        private enum CodingKeys: String, CodingKey {
            case offeringTransaction
        }
    }

    public struct Radios: AWSEncodableShape & AWSDecodableShape {
        /// True if Bluetooth is enabled at the beginning of the test. Otherwise, false.
        public let bluetooth: Bool?
        /// True if GPS is enabled at the beginning of the test. Otherwise, false.
        public let gps: Bool?
        /// True if NFC is enabled at the beginning of the test. Otherwise, false.
        public let nfc: Bool?
        /// True if Wi-Fi is enabled at the beginning of the test. Otherwise, false.
        public let wifi: Bool?

        public init(bluetooth: Bool? = nil, gps: Bool? = nil, nfc: Bool? = nil, wifi: Bool? = nil) {
            self.bluetooth = bluetooth
            self.gps = gps
            self.nfc = nfc
            self.wifi = wifi
        }

        private enum CodingKeys: String, CodingKey {
            case bluetooth
            case gps
            case nfc
            case wifi
        }
    }

    public struct RecurringCharge: AWSDecodableShape {
        /// The cost of the recurring charge.
        public let cost: MonetaryAmount?
        /// The frequency in which charges recur.
        public let frequency: RecurringChargeFrequency?

        public init(cost: MonetaryAmount? = nil, frequency: RecurringChargeFrequency? = nil) {
            self.cost = cost
            self.frequency = frequency
        }

        private enum CodingKeys: String, CodingKey {
            case cost
            case frequency
        }
    }

    public struct RemoteAccessSession: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the remote access session.
        public let arn: String?
        /// The billing method of the remote access session. Possible values include METERED or UNMETERED. For more information about metered devices, see AWS Device Farm terminology.
        public let billingMethod: BillingMethod?
        /// Unique identifier of your client for the remote access session. Only returned if remote debugging is enabled for the remote access session. Remote debugging is no longer supported.
        public let clientId: String?
        /// The date and time the remote access session was created.
        public let created: Date?
        /// The device (phone or tablet) used in the remote access session.
        public let device: Device?
        /// The number of minutes a device is used in a remote access session (including setup and teardown minutes).
        public let deviceMinutes: DeviceMinutes?
        /// Unique device identifier for the remote device. Only returned if remote debugging is enabled for the remote access session. Remote debugging is no longer supported.
        public let deviceUdid: String?
        /// The endpoint for the remote access sesssion.
        public let endpoint: String?
        /// IP address of the EC2 host where you need to connect to remotely debug devices. Only returned if remote debugging is enabled for the remote access session. Remote debugging is no longer supported.
        public let hostAddress: String?
        /// The ARN of the instance.
        public let instanceArn: String?
        /// The interaction mode of the remote access session. Valid values are:   INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.   NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.   VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.
        public let interactionMode: InteractionMode?
        /// A message about the remote access session.
        public let message: String?
        /// The name of the remote access session.
        public let name: String?
        /// This flag is set to true if remote debugging is enabled for the remote access session. Remote debugging is no longer supported.
        public let remoteDebugEnabled: Bool?
        /// The ARN for the app to be recorded in the remote access session.
        public let remoteRecordAppArn: String?
        /// This flag is set to true if remote recording is enabled for the remote access session.
        public let remoteRecordEnabled: Bool?
        /// The result of the remote access session. Can be any of the following:   PENDING.   PASSED.   WARNED.   FAILED.   SKIPPED.   ERRORED.   STOPPED.
        public let result: ExecutionResult?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?
        /// The date and time the remote access session was started.
        public let started: Date?
        /// The status of the remote access session. Can be any of the following:   PENDING.   PENDING_CONCURRENCY.   PENDING_DEVICE.   PROCESSING.   SCHEDULING.   PREPARING.   RUNNING.   COMPLETED.   STOPPING.
        public let status: ExecutionStatus?
        /// The date and time the remote access session was stopped.
        public let stopped: Date?

        public init(arn: String? = nil, billingMethod: BillingMethod? = nil, clientId: String? = nil, created: Date? = nil, device: Device? = nil, deviceMinutes: DeviceMinutes? = nil, deviceUdid: String? = nil, endpoint: String? = nil, hostAddress: String? = nil, instanceArn: String? = nil, interactionMode: InteractionMode? = nil, message: String? = nil, name: String? = nil, remoteDebugEnabled: Bool? = nil, remoteRecordAppArn: String? = nil, remoteRecordEnabled: Bool? = nil, result: ExecutionResult? = nil, skipAppResign: Bool? = nil, started: Date? = nil, status: ExecutionStatus? = nil, stopped: Date? = nil) {
            self.arn = arn
            self.billingMethod = billingMethod
            self.clientId = clientId
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.deviceUdid = deviceUdid
            self.endpoint = endpoint
            self.hostAddress = hostAddress
            self.instanceArn = instanceArn
            self.interactionMode = interactionMode
            self.message = message
            self.name = name
            self.remoteDebugEnabled = remoteDebugEnabled
            self.remoteRecordAppArn = remoteRecordAppArn
            self.remoteRecordEnabled = remoteRecordEnabled
            self.result = result
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case billingMethod
            case clientId
            case created
            case device
            case deviceMinutes
            case deviceUdid
            case endpoint
            case hostAddress
            case instanceArn
            case interactionMode
            case message
            case name
            case remoteDebugEnabled
            case remoteRecordAppArn
            case remoteRecordEnabled
            case result
            case skipAppResign
            case started
            case status
            case stopped
        }
    }

    public struct RenewOfferingRequest: AWSEncodableShape {
        /// The ID of a request to renew an offering.
        public let offeringId: String
        /// The quantity requested in an offering renewal.
        public let quantity: Int

        public init(offeringId: String, quantity: Int) {
            self.offeringId = offeringId
            self.quantity = quantity
        }

        public func validate(name: String) throws {
            try self.validate(self.offeringId, name: "offeringId", parent: name, min: 32)
        }

        private enum CodingKeys: String, CodingKey {
            case offeringId
            case quantity
        }
    }

    public struct RenewOfferingResult: AWSDecodableShape {
        /// Represents the status of the offering transaction for the renewal.
        public let offeringTransaction: OfferingTransaction?

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        private enum CodingKeys: String, CodingKey {
            case offeringTransaction
        }
    }

    public struct Resolution: AWSDecodableShape {
        /// The screen resolution's height, expressed in pixels.
        public let height: Int?
        /// The screen resolution's width, expressed in pixels.
        public let width: Int?

        public init(height: Int? = nil, width: Int? = nil) {
            self.height = height
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case height
            case width
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// The rule's stringified attribute. For example, specify the value as "\"abc\"". The supported operators for each attribute are provided in the following list.  APPIUM_VERSION  The Appium version for the test. Supported operators: CONTAINS   ARN  The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example. Supported operators: EQUALS, IN, NOT_IN   AVAILABILITY  The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE. Supported operators: EQUALS   FLEET_TYPE  The fleet type. Valid values are PUBLIC or PRIVATE. Supported operators: EQUALS   FORM_FACTOR  The device form factor. Valid values are PHONE or TABLET. Supported operators: EQUALS, IN, NOT_IN   INSTANCE_ARN  The Amazon Resource Name (ARN) of the device instance. Supported operators: IN, NOT_IN   INSTANCE_LABELS  The label of the device instance. Supported operators: CONTAINS   MANUFACTURER  The device manufacturer (for example, Apple). Supported operators: EQUALS, IN, NOT_IN   MODEL  The device model, such as Apple iPad Air 2 or Google Pixel. Supported operators: CONTAINS, EQUALS, IN, NOT_IN   OS_VERSION  The operating system version (for example, 10.3.2). Supported operators: EQUALS, GREATER_THAN, GREATER_THAN_OR_EQUALS, IN, LESS_THAN, LESS_THAN_OR_EQUALS, NOT_IN   PLATFORM  The device platform. Valid values are ANDROID or IOS. Supported operators: EQUALS, IN, NOT_IN   REMOTE_ACCESS_ENABLED  Whether the device is enabled for remote access. Valid values are TRUE or FALSE. Supported operators: EQUALS   REMOTE_DEBUG_ENABLED  Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Supported operators: EQUALS  Because remote debugging is no longer supported, this filter is ignored.
        public let attribute: DeviceAttribute?
        /// Specifies how Device Farm compares the rule's attribute to the value. For the operators that are supported by each attribute, see the attribute descriptions.
        public let `operator`: RuleOperator?
        /// The rule's value.
        public let value: String?

        public init(attribute: DeviceAttribute? = nil, operator: RuleOperator? = nil, value: String? = nil) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attribute
            case `operator`
            case value
        }
    }

    public struct Run: AWSDecodableShape {
        /// An app to upload or that has been uploaded.
        public let appUpload: String?
        /// The run's ARN.
        public let arn: String?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.  If you have unmetered device slots, you must set this to unmetered to use them. Otherwise, the run is counted toward metered device minutes.
        public let billingMethod: BillingMethod?
        /// The total number of completed jobs.
        public let completedJobs: Int?
        /// The run's result counters.
        public let counters: Counters?
        /// When the run was created.
        public let created: Date?
        /// Output CustomerArtifactPaths object for the test run.
        public let customerArtifactPaths: CustomerArtifactPaths?
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public let deviceMinutes: DeviceMinutes?
        /// The ARN of the device pool for the run.
        public let devicePoolArn: String?
        /// The results of a device filter used to select the devices for a test run.
        public let deviceSelectionResult: DeviceSelectionResult?
        /// For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.
        public let eventCount: Int?
        /// The number of minutes the job executes before it times out.
        public let jobTimeoutMinutes: Int?
        /// Information about the locale that is used for the run.
        public let locale: String?
        /// Information about the location that is used for the run.
        public let location: Location?
        /// A message about the run's result.
        public let message: String?
        /// The run's name.
        public let name: String?
        /// The network profile being used for a test run.
        public let networkProfile: NetworkProfile?
        /// Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.
        public let parsingResultUrl: String?
        /// The run's platform. Allowed values include:   ANDROID   IOS
        public let platform: DevicePlatform?
        /// Information about the radio states for the run.
        public let radios: Radios?
        /// The run's result. Allowed values include:   PENDING   PASSED   WARNED   FAILED   SKIPPED   ERRORED   STOPPED
        public let result: ExecutionResult?
        /// Supporting field for the result field. Set only if result is SKIPPED. PARSING_FAILED if the result is skipped because of test package parsing failure.
        public let resultCode: ExecutionResultCode?
        /// For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.
        public let seed: Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see Do you modify my app? in the AWS Device Farm FAQs.
        public let skipAppResign: Bool?
        /// The run's start time.
        public let started: Date?
        /// The run's status. Allowed values include:   PENDING   PENDING_CONCURRENCY   PENDING_DEVICE   PROCESSING   SCHEDULING   PREPARING   RUNNING   COMPLETED   STOPPING
        public let status: ExecutionStatus?
        /// The run's stop time.
        public let stopped: Date?
        /// The ARN of the YAML-formatted test specification for the run.
        public let testSpecArn: String?
        /// The total number of jobs for the run.
        public let totalJobs: Int?
        /// The run's type. Must be one of the following values:   BUILTIN_FUZZ   BUILTIN_EXPLORER  For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.    APPIUM_JAVA_JUNIT   APPIUM_JAVA_TESTNG   APPIUM_PYTHON   APPIUM_NODE   APPIUM_RUBY   APPIUM_WEB_JAVA_JUNIT   APPIUM_WEB_JAVA_TESTNG   APPIUM_WEB_PYTHON   APPIUM_WEB_NODE   APPIUM_WEB_RUBY   CALABASH   INSTRUMENTATION   UIAUTOMATION   UIAUTOMATOR   XCTEST   XCTEST_UI
        public let type: TestType?
        /// The Device Farm console URL for the recording of the run.
        public let webUrl: String?

        public init(appUpload: String? = nil, arn: String? = nil, billingMethod: BillingMethod? = nil, completedJobs: Int? = nil, counters: Counters? = nil, created: Date? = nil, customerArtifactPaths: CustomerArtifactPaths? = nil, deviceMinutes: DeviceMinutes? = nil, devicePoolArn: String? = nil, deviceSelectionResult: DeviceSelectionResult? = nil, eventCount: Int? = nil, jobTimeoutMinutes: Int? = nil, locale: String? = nil, location: Location? = nil, message: String? = nil, name: String? = nil, networkProfile: NetworkProfile? = nil, parsingResultUrl: String? = nil, platform: DevicePlatform? = nil, radios: Radios? = nil, result: ExecutionResult? = nil, resultCode: ExecutionResultCode? = nil, seed: Int? = nil, skipAppResign: Bool? = nil, started: Date? = nil, status: ExecutionStatus? = nil, stopped: Date? = nil, testSpecArn: String? = nil, totalJobs: Int? = nil, type: TestType? = nil, webUrl: String? = nil) {
            self.appUpload = appUpload
            self.arn = arn
            self.billingMethod = billingMethod
            self.completedJobs = completedJobs
            self.counters = counters
            self.created = created
            self.customerArtifactPaths = customerArtifactPaths
            self.deviceMinutes = deviceMinutes
            self.devicePoolArn = devicePoolArn
            self.deviceSelectionResult = deviceSelectionResult
            self.eventCount = eventCount
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.locale = locale
            self.location = location
            self.message = message
            self.name = name
            self.networkProfile = networkProfile
            self.parsingResultUrl = parsingResultUrl
            self.platform = platform
            self.radios = radios
            self.result = result
            self.resultCode = resultCode
            self.seed = seed
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
            self.testSpecArn = testSpecArn
            self.totalJobs = totalJobs
            self.type = type
            self.webUrl = webUrl
        }

        private enum CodingKeys: String, CodingKey {
            case appUpload
            case arn
            case billingMethod
            case completedJobs
            case counters
            case created
            case customerArtifactPaths
            case deviceMinutes
            case devicePoolArn
            case deviceSelectionResult
            case eventCount
            case jobTimeoutMinutes
            case locale
            case location
            case message
            case name
            case networkProfile
            case parsingResultUrl
            case platform
            case radios
            case result
            case resultCode
            case seed
            case skipAppResign
            case started
            case status
            case stopped
            case testSpecArn
            case totalJobs
            case type
            case webUrl
        }
    }

    public struct Sample: AWSDecodableShape {
        /// The sample's ARN.
        public let arn: String?
        /// The sample's type. Must be one of the following values:   CPU: A CPU sample type. This is expressed as the app processing CPU time (including child processes) as reported by process, as a percentage.   MEMORY: A memory usage sample type. This is expressed as the total proportional set size of an app process, in kilobytes.   NATIVE_AVG_DRAWTIME   NATIVE_FPS   NATIVE_FRAMES   NATIVE_MAX_DRAWTIME   NATIVE_MIN_DRAWTIME   OPENGL_AVG_DRAWTIME   OPENGL_FPS   OPENGL_FRAMES   OPENGL_MAX_DRAWTIME   OPENGL_MIN_DRAWTIME   RX   RX_RATE: The total number of bytes per second (TCP and UDP) that are sent, by app process.   THREADS: A threads sample type. This is expressed as the total number of threads per app process.   TX   TX_RATE: The total number of bytes per second (TCP and UDP) that are received, by app process.
        public let type: SampleType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the sample's file.
        public let url: String?

        public init(arn: String? = nil, type: SampleType? = nil, url: String? = nil) {
            self.arn = arn
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case type
            case url
        }
    }

    public struct ScheduleRunConfiguration: AWSEncodableShape {
        /// A list of upload ARNs for app packages to be installed with your app.
        public let auxiliaryApps: [String]?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.  If you have purchased unmetered device slots, you must set this parameter to unmetered to make use of them. Otherwise, your run counts against your metered time.
        public let billingMethod: BillingMethod?
        /// Input CustomerArtifactPaths object for the scheduled run configuration.
        public let customerArtifactPaths: CustomerArtifactPaths?
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm extracts to external data for Android or the app's sandbox for iOS.
        public let extraDataPackageArn: String?
        /// Information about the locale that is used for the run.
        public let locale: String?
        /// Information about the location that is used for the run.
        public let location: Location?
        /// Reserved for internal use.
        public let networkProfileArn: String?
        /// Information about the radio states for the run.
        public let radios: Radios?
        /// An array of ARNs for your VPC endpoint configurations.
        public let vpceConfigurationArns: [String]?

        public init(auxiliaryApps: [String]? = nil, billingMethod: BillingMethod? = nil, customerArtifactPaths: CustomerArtifactPaths? = nil, extraDataPackageArn: String? = nil, locale: String? = nil, location: Location? = nil, networkProfileArn: String? = nil, radios: Radios? = nil, vpceConfigurationArns: [String]? = nil) {
            self.auxiliaryApps = auxiliaryApps
            self.billingMethod = billingMethod
            self.customerArtifactPaths = customerArtifactPaths
            self.extraDataPackageArn = extraDataPackageArn
            self.locale = locale
            self.location = location
            self.networkProfileArn = networkProfileArn
            self.radios = radios
            self.vpceConfigurationArns = vpceConfigurationArns
        }

        public func validate(name: String) throws {
            try self.auxiliaryApps?.forEach {
                try validate($0, name: "auxiliaryApps[]", parent: name, max: 1011)
                try validate($0, name: "auxiliaryApps[]", parent: name, min: 32)
                try validate($0, name: "auxiliaryApps[]", parent: name, pattern: "^arn:.+")
            }
            try self.validate(self.extraDataPackageArn, name: "extraDataPackageArn", parent: name, max: 1011)
            try self.validate(self.extraDataPackageArn, name: "extraDataPackageArn", parent: name, min: 32)
            try self.validate(self.extraDataPackageArn, name: "extraDataPackageArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.networkProfileArn, name: "networkProfileArn", parent: name, max: 1011)
            try self.validate(self.networkProfileArn, name: "networkProfileArn", parent: name, min: 32)
            try self.validate(self.networkProfileArn, name: "networkProfileArn", parent: name, pattern: "^arn:.+")
            try self.vpceConfigurationArns?.forEach {
                try validate($0, name: "vpceConfigurationArns[]", parent: name, max: 1011)
                try validate($0, name: "vpceConfigurationArns[]", parent: name, min: 32)
                try validate($0, name: "vpceConfigurationArns[]", parent: name, pattern: "^arn:.+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case auxiliaryApps
            case billingMethod
            case customerArtifactPaths
            case extraDataPackageArn
            case locale
            case location
            case networkProfileArn
            case radios
            case vpceConfigurationArns
        }
    }

    public struct ScheduleRunRequest: AWSEncodableShape {
        /// The ARN of an application package to run tests against, created with CreateUpload. See ListUploads.
        public let appArn: String?
        /// Information about the settings for the run to be scheduled.
        public let configuration: ScheduleRunConfiguration?
        /// The ARN of the device pool for the run to be scheduled.
        public let devicePoolArn: String?
        /// The filter criteria used to dynamically select a set of devices for a test run and the maximum number of devices to be included in the run. Either  devicePoolArn  or  deviceSelectionConfiguration  is required in a request.
        public let deviceSelectionConfiguration: DeviceSelectionConfiguration?
        /// Specifies configuration information about a test run, such as the execution timeout (in minutes).
        public let executionConfiguration: ExecutionConfiguration?
        /// The name for the run to be scheduled.
        public let name: String?
        /// The ARN of the project for the run to be scheduled.
        public let projectArn: String
        /// Information about the test for the run to be scheduled.
        public let test: ScheduleRunTest

        public init(appArn: String? = nil, configuration: ScheduleRunConfiguration? = nil, devicePoolArn: String? = nil, deviceSelectionConfiguration: DeviceSelectionConfiguration? = nil, executionConfiguration: ExecutionConfiguration? = nil, name: String? = nil, projectArn: String, test: ScheduleRunTest) {
            self.appArn = appArn
            self.configuration = configuration
            self.devicePoolArn = devicePoolArn
            self.deviceSelectionConfiguration = deviceSelectionConfiguration
            self.executionConfiguration = executionConfiguration
            self.name = name
            self.projectArn = projectArn
            self.test = test
        }

        public func validate(name: String) throws {
            try self.validate(self.appArn, name: "appArn", parent: name, max: 1011)
            try self.validate(self.appArn, name: "appArn", parent: name, min: 32)
            try self.validate(self.appArn, name: "appArn", parent: name, pattern: "^arn:.+")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.devicePoolArn, name: "devicePoolArn", parent: name, max: 1011)
            try self.validate(self.devicePoolArn, name: "devicePoolArn", parent: name, min: 32)
            try self.validate(self.devicePoolArn, name: "devicePoolArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:.+")
            try self.test.validate(name: "\(name).test")
        }

        private enum CodingKeys: String, CodingKey {
            case appArn
            case configuration
            case devicePoolArn
            case deviceSelectionConfiguration
            case executionConfiguration
            case name
            case projectArn
            case test
        }
    }

    public struct ScheduleRunResult: AWSDecodableShape {
        /// Information about the scheduled run.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run
        }
    }

    public struct ScheduleRunTest: AWSEncodableShape {
        /// The test's filter.
        public let filter: String?
        /// The test's parameters, such as test framework parameters and fixture settings. Parameters are represented by name-value pairs of strings. For all tests:    app_performance_monitoring: Performance monitoring is enabled by default. Set this parameter to false to disable it.   For Calabash tests:   profile: A cucumber profile (for example, my_profile_name).   tags: You can limit execution to features or scenarios that have (or don't have) certain tags (for example, @smoke or @smoke,~@wip).   For Appium tests (all types):   appium_version: The Appium version. Currently supported values are 1.6.5 (and later), latest, and default.   latest runs the latest Appium version supported by Device Farm (1.9.1).   For default, Device Farm selects a compatible version of Appium for the device. The current behavior is to run 1.7.2 on Android devices and iOS 9 and earlier and 1.7.2 for iOS 10 and later.   This behavior is subject to change.     For fuzz tests (Android only):   event_count: The number of events, between 1 and 10000, that the UI fuzz test should perform.   throttle: The time, in ms, between 0 and 1000, that the UI fuzz test should wait between events.   seed: A seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.   For Explorer tests:   username: A user name to use if the Explorer encounters a login form. If not supplied, no user name is inserted.   password: A password to use if the Explorer encounters a login form. If not supplied, no password is inserted.   For Instrumentation:   filter: A test filter string. Examples:   Running a single test case: com.android.abc.Test1    Running a single test: com.android.abc.Test1#smoke    Running multiple tests: com.android.abc.Test1,com.android.abc.Test2      For XCTest and XCTestUI:   filter: A test filter string. Examples:   Running a single test class: LoginTests    Running a multiple test classes: LoginTests,SmokeTests    Running a single test: LoginTests/testValid    Running multiple tests: LoginTests/testValid,LoginTests/testInvalid      For UIAutomator:   filter: A test filter string. Examples:   Running a single test case: com.android.abc.Test1    Running a single test: com.android.abc.Test1#smoke    Running multiple tests: com.android.abc.Test1,com.android.abc.Test2
        public let parameters: [String: String]?
        /// The ARN of the uploaded test to be run.
        public let testPackageArn: String?
        /// The ARN of the YAML-formatted test specification.
        public let testSpecArn: String?
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ   BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT   APPIUM_JAVA_TESTNG   APPIUM_PYTHON   APPIUM_NODE   APPIUM_RUBY   APPIUM_WEB_JAVA_JUNIT   APPIUM_WEB_JAVA_TESTNG   APPIUM_WEB_PYTHON   APPIUM_WEB_NODE   APPIUM_WEB_RUBY   CALABASH   INSTRUMENTATION   UIAUTOMATION   UIAUTOMATOR   XCTEST   XCTEST_UI
        public let type: TestType

        public init(filter: String? = nil, parameters: [String: String]? = nil, testPackageArn: String? = nil, testSpecArn: String? = nil, type: TestType) {
            self.filter = filter
            self.parameters = parameters
            self.testPackageArn = testPackageArn
            self.testSpecArn = testSpecArn
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.filter, name: "filter", parent: name, max: 8192)
            try self.validate(self.filter, name: "filter", parent: name, min: 0)
            try self.validate(self.testPackageArn, name: "testPackageArn", parent: name, max: 1011)
            try self.validate(self.testPackageArn, name: "testPackageArn", parent: name, min: 32)
            try self.validate(self.testPackageArn, name: "testPackageArn", parent: name, pattern: "^arn:.+")
            try self.validate(self.testSpecArn, name: "testSpecArn", parent: name, max: 1011)
            try self.validate(self.testSpecArn, name: "testSpecArn", parent: name, min: 32)
            try self.validate(self.testSpecArn, name: "testSpecArn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case filter
            case parameters
            case testPackageArn
            case testSpecArn
            case type
        }
    }

    public struct StopJobRequest: AWSEncodableShape {
        /// Represents the Amazon Resource Name (ARN) of the Device Farm job to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct StopJobResult: AWSDecodableShape {
        /// The job that was stopped.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job
        }
    }

    public struct StopRemoteAccessSessionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the remote access session to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct StopRemoteAccessSessionResult: AWSDecodableShape {
        /// A container that represents the metadata from the service about the remote access session you are stopping.
        public let remoteAccessSession: RemoteAccessSession?

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        private enum CodingKeys: String, CodingKey {
            case remoteAccessSession
        }
    }

    public struct StopRunRequest: AWSEncodableShape {
        /// Represents the Amazon Resource Name (ARN) of the Device Farm run to stop.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct StopRunResult: AWSDecodableShape {
        /// The run that was stopped.
        public let run: Run?

        public init(run: Run? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run
        }
    }

    public struct Suite: AWSDecodableShape {
        /// The suite's ARN.
        public let arn: String?
        /// The suite's result counters.
        public let counters: Counters?
        /// When the suite was created.
        public let created: Date?
        /// Represents the total (metered or unmetered) minutes used by the test suite.
        public let deviceMinutes: DeviceMinutes?
        /// A message about the suite's result.
        public let message: String?
        /// The suite's name.
        public let name: String?
        /// The suite's result. Allowed values include:   PENDING   PASSED   WARNED   FAILED   SKIPPED   ERRORED   STOPPED
        public let result: ExecutionResult?
        /// The suite's start time.
        public let started: Date?
        /// The suite's status. Allowed values include:   PENDING   PENDING_CONCURRENCY   PENDING_DEVICE   PROCESSING   SCHEDULING   PREPARING   RUNNING   COMPLETED   STOPPING
        public let status: ExecutionStatus?
        /// The suite's stop time.
        public let stopped: Date?
        /// The suite's type. Must be one of the following values:   BUILTIN_FUZZ   BUILTIN_EXPLORER   Only available for Android; an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.    APPIUM_JAVA_JUNIT   APPIUM_JAVA_TESTNG   APPIUM_PYTHON   APPIUM_NODE   APPIUM_RUBY   APPIUM_WEB_JAVA_JUNIT   APPIUM_WEB_JAVA_TESTNG   APPIUM_WEB_PYTHON   APPIUM_WEB_NODE   APPIUM_WEB_RUBY   CALABASH   INSTRUMENTATION   UIAUTOMATION   UIAUTOMATOR   XCTEST   XCTEST_UI
        public let type: TestType?

        public init(arn: String? = nil, counters: Counters? = nil, created: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, name: String? = nil, result: ExecutionResult? = nil, started: Date? = nil, status: ExecutionStatus? = nil, stopped: Date? = nil, type: TestType? = nil) {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case counters
            case created
            case deviceMinutes
            case message
            case name
            case result
            case started
            case status
            case stopped
            case type
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor in a tag category (key).
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource or resources to which to add tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
        public let resourceARN: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 32)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws:devicefarm:.+")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 150)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Test: AWSDecodableShape {
        /// The test's ARN.
        public let arn: String?
        /// The test's result counters.
        public let counters: Counters?
        /// When the test was created.
        public let created: Date?
        /// Represents the total (metered or unmetered) minutes used by the test.
        public let deviceMinutes: DeviceMinutes?
        /// A message about the test's result.
        public let message: String?
        /// The test's name.
        public let name: String?
        /// The test's result. Allowed values include:   PENDING   PASSED   WARNED   FAILED   SKIPPED   ERRORED   STOPPED
        public let result: ExecutionResult?
        /// The test's start time.
        public let started: Date?
        /// The test's status. Allowed values include:   PENDING   PENDING_CONCURRENCY   PENDING_DEVICE   PROCESSING   SCHEDULING   PREPARING   RUNNING   COMPLETED   STOPPING
        public let status: ExecutionStatus?
        /// The test's stop time.
        public let stopped: Date?
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ   BUILTIN_EXPLORER  For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.    APPIUM_JAVA_JUNIT   APPIUM_JAVA_TESTNG   APPIUM_PYTHON   APPIUM_NODE   APPIUM_RUBY   APPIUM_WEB_JAVA_JUNIT   APPIUM_WEB_JAVA_TESTNG   APPIUM_WEB_PYTHON   APPIUM_WEB_NODE   APPIUM_WEB_RUBY   CALABASH   INSTRUMENTATION   UIAUTOMATION   UIAUTOMATOR   XCTEST   XCTEST_UI
        public let type: TestType?

        public init(arn: String? = nil, counters: Counters? = nil, created: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, name: String? = nil, result: ExecutionResult? = nil, started: Date? = nil, status: ExecutionStatus? = nil, stopped: Date? = nil, type: TestType? = nil) {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case counters
            case created
            case deviceMinutes
            case message
            case name
            case result
            case started
            case status
            case stopped
            case type
        }
    }

    public struct TestGridProject: AWSDecodableShape {
        /// The ARN for the project.
        public let arn: String?
        /// When the project was created.
        public let created: Date?
        /// A human-readable description for the project.
        public let description: String?
        /// A human-readable name for the project.
        public let name: String?
        /// The VPC security groups and subnets that are attached to a project.
        public let vpcConfig: TestGridVpcConfig?

        public init(arn: String? = nil, created: Date? = nil, description: String? = nil, name: String? = nil, vpcConfig: TestGridVpcConfig? = nil) {
            self.arn = arn
            self.created = created
            self.description = description
            self.name = name
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case created
            case description
            case name
            case vpcConfig
        }
    }

    public struct TestGridSession: AWSDecodableShape {
        /// The ARN of the session.
        public let arn: String?
        /// The number of billed minutes that were used for this session.
        public let billingMinutes: Double?
        /// The time that the session was started.
        public let created: Date?
        /// The time the session ended.
        public let ended: Date?
        /// A JSON object of options and parameters passed to the Selenium WebDriver.
        public let seleniumProperties: String?
        /// The state of the session.
        public let status: TestGridSessionStatus?

        public init(arn: String? = nil, billingMinutes: Double? = nil, created: Date? = nil, ended: Date? = nil, seleniumProperties: String? = nil, status: TestGridSessionStatus? = nil) {
            self.arn = arn
            self.billingMinutes = billingMinutes
            self.created = created
            self.ended = ended
            self.seleniumProperties = seleniumProperties
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case billingMinutes
            case created
            case ended
            case seleniumProperties
            case status
        }
    }

    public struct TestGridSessionAction: AWSDecodableShape {
        /// The action taken by the session.
        public let action: String?
        /// The time, in milliseconds, that the action took to complete in the browser.
        public let duration: Int64?
        /// HTTP method that the browser used to make the request.
        public let requestMethod: String?
        /// The time that the session invoked the action.
        public let started: Date?
        /// HTTP status code returned to the browser when the action was taken.
        public let statusCode: String?

        public init(action: String? = nil, duration: Int64? = nil, requestMethod: String? = nil, started: Date? = nil, statusCode: String? = nil) {
            self.action = action
            self.duration = duration
            self.requestMethod = requestMethod
            self.started = started
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case duration
            case requestMethod
            case started
            case statusCode
        }
    }

    public struct TestGridSessionArtifact: AWSDecodableShape {
        /// The file name of the artifact.
        public let filename: String?
        /// The kind of artifact.
        public let type: TestGridSessionArtifactType?
        /// A semi-stable URL to the content of the object.
        public let url: String?

        public init(filename: String? = nil, type: TestGridSessionArtifactType? = nil, url: String? = nil) {
            self.filename = filename
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case filename
            case type
            case url
        }
    }

    public struct TestGridVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of VPC security group IDs in your Amazon VPC.
        public let securityGroupIds: [String]
        /// A list of VPC subnet IDs in your Amazon VPC.
        public let subnetIds: [String]
        /// The ID of the Amazon VPC.
        public let vpcId: String

        public init(securityGroupIds: [String], subnetIds: [String], vpcId: String) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 4096)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: ".*\\S.*")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 4096)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: ".*\\S.*")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 8)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 4096)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds
            case subnetIds
            case vpcId
        }
    }

    public struct TrialMinutes: AWSDecodableShape {
        /// The number of free trial minutes remaining in the account.
        public let remaining: Double?
        /// The total number of free trial minutes that the account started with.
        public let total: Double?

        public init(remaining: Double? = nil, total: Double? = nil) {
            self.remaining = remaining
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case remaining
            case total
        }
    }

    public struct UniqueProblem: AWSDecodableShape {
        /// A message about the unique problems' result.
        public let message: String?
        /// Information about the problems.
        public let problems: [Problem]?

        public init(message: String? = nil, problems: [Problem]? = nil) {
            self.message = message
            self.problems = problems
        }

        private enum CodingKeys: String, CodingKey {
            case message
            case problems
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource or resources from which to delete tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
        public let resourceARN: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 32)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:aws:devicefarm:.+")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 150)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDeviceInstanceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the device instance.
        public let arn: String
        /// An array of strings that you want to associate with the device instance.
        public let labels: [String]?
        /// The ARN of the profile that you want to associate with the device instance.
        public let profileArn: String?

        public init(arn: String, labels: [String]? = nil, profileArn: String? = nil) {
            self.arn = arn
            self.labels = labels
            self.profileArn = profileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.profileArn, name: "profileArn", parent: name, max: 1011)
            try self.validate(self.profileArn, name: "profileArn", parent: name, min: 32)
            try self.validate(self.profileArn, name: "profileArn", parent: name, pattern: "^arn:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case labels
            case profileArn
        }
    }

    public struct UpdateDeviceInstanceResult: AWSDecodableShape {
        /// An object that contains information about your device instance.
        public let deviceInstance: DeviceInstance?

        public init(deviceInstance: DeviceInstance? = nil) {
            self.deviceInstance = deviceInstance
        }

        private enum CodingKeys: String, CodingKey {
            case deviceInstance
        }
    }

    public struct UpdateDevicePoolRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Device Farm device pool to update.
        public let arn: String
        /// Sets whether the maxDevices parameter applies to your device pool. If you set this parameter to true, the maxDevices parameter does not apply, and Device Farm does not limit the number of devices that it adds to your device pool. In this case, Device Farm adds all available devices that meet the criteria specified in the rules parameter. If you use this parameter in your request, you cannot use the maxDevices parameter in the same request.
        public let clearMaxDevices: Bool?
        /// A description of the device pool to update.
        public let description: String?
        /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and that meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests. If you use this parameter in your request, you cannot use the clearMaxDevices parameter in the same request.
        public let maxDevices: Int?
        /// A string that represents the name of the device pool to update.
        public let name: String?
        /// Represents the rules to modify for the device pool. Updating rules is optional. If you update rules for your request, the update replaces the existing rules.
        public let rules: [Rule]?

        public init(arn: String, clearMaxDevices: Bool? = nil, description: String? = nil, maxDevices: Int? = nil, name: String? = nil, rules: [Rule]? = nil) {
            self.arn = arn
            self.clearMaxDevices = clearMaxDevices
            self.description = description
            self.maxDevices = maxDevices
            self.name = name
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.description, name: "description", parent: name, max: 16384)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case clearMaxDevices
            case description
            case maxDevices
            case name
            case rules
        }
    }

    public struct UpdateDevicePoolResult: AWSDecodableShape {
        /// The device pool you just updated.
        public let devicePool: DevicePool?

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        private enum CodingKeys: String, CodingKey {
            case devicePool
        }
    }

    public struct UpdateInstanceProfileRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String
        /// The updated description for your instance profile.
        public let description: String?
        /// An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run is over. The list of packages is only considered if you set packageCleanup to true.
        public let excludeAppPackagesFromCleanup: [String]?
        /// The updated name for your instance profile.
        public let name: String?
        /// The updated choice for whether you want to specify package cleanup. The default value is false for private devices.
        public let packageCleanup: Bool?
        /// The updated choice for whether you want to reboot the device after use. The default value is true.
        public let rebootAfterUse: Bool?

        public init(arn: String, description: String? = nil, excludeAppPackagesFromCleanup: [String]? = nil, name: String? = nil, packageCleanup: Bool? = nil, rebootAfterUse: Bool? = nil) {
            self.arn = arn
            self.description = description
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.packageCleanup = packageCleanup
            self.rebootAfterUse = rebootAfterUse
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.description, name: "description", parent: name, max: 16384)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case excludeAppPackagesFromCleanup
            case name
            case packageCleanup
            case rebootAfterUse
        }
    }

    public struct UpdateInstanceProfileResult: AWSDecodableShape {
        /// An object that contains information about your instance profile.
        public let instanceProfile: InstanceProfile?

        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile
        }
    }

    public struct UpdateNetworkProfileRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project for which you want to update network profile settings.
        public let arn: String
        /// The description of the network profile about which you are returning information.
        public let description: String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let downlinkBandwidthBits: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let downlinkDelayMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let downlinkJitterMs: Int64?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public let downlinkLossPercent: Int?
        /// The name of the network profile about which you are returning information.
        public let name: String?
        /// The type of network profile to return information about. Valid values are listed here.
        public let type: NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public let uplinkBandwidthBits: Int64?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public let uplinkDelayMs: Int64?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public let uplinkJitterMs: Int64?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public let uplinkLossPercent: Int?

        public init(arn: String, description: String? = nil, downlinkBandwidthBits: Int64? = nil, downlinkDelayMs: Int64? = nil, downlinkJitterMs: Int64? = nil, downlinkLossPercent: Int? = nil, name: String? = nil, type: NetworkProfileType? = nil, uplinkBandwidthBits: Int64? = nil, uplinkDelayMs: Int64? = nil, uplinkJitterMs: Int64? = nil, uplinkLossPercent: Int? = nil) {
            self.arn = arn
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.downlinkDelayMs = downlinkDelayMs
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkLossPercent = downlinkLossPercent
            self.name = name
            self.type = type
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkJitterMs = uplinkJitterMs
            self.uplinkLossPercent = uplinkLossPercent
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.description, name: "description", parent: name, max: 16384)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.downlinkLossPercent, name: "downlinkLossPercent", parent: name, max: 100)
            try self.validate(self.downlinkLossPercent, name: "downlinkLossPercent", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
            try self.validate(self.uplinkLossPercent, name: "uplinkLossPercent", parent: name, max: 100)
            try self.validate(self.uplinkLossPercent, name: "uplinkLossPercent", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case downlinkBandwidthBits
            case downlinkDelayMs
            case downlinkJitterMs
            case downlinkLossPercent
            case name
            case type
            case uplinkBandwidthBits
            case uplinkDelayMs
            case uplinkJitterMs
            case uplinkLossPercent
        }
    }

    public struct UpdateNetworkProfileResult: AWSDecodableShape {
        /// A list of the available network profiles.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the project whose name to update.
        public let arn: String
        /// The number of minutes a test run in the project executes before it times out.
        public let defaultJobTimeoutMinutes: Int?
        /// A string that represents the new name of the project that you are updating.
        public let name: String?

        public init(arn: String, defaultJobTimeoutMinutes: Int? = nil, name: String? = nil) {
            self.arn = arn
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case defaultJobTimeoutMinutes
            case name
        }
    }

    public struct UpdateProjectResult: AWSDecodableShape {
        /// The project to update.
        public let project: Project?

        public init(project: Project? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project
        }
    }

    public struct UpdateTestGridProjectRequest: AWSEncodableShape {
        /// Human-readable description for the project.
        public let description: String?
        /// Human-readable name for the project.
        public let name: String?
        /// ARN of the project to update.
        public let projectArn: String
        /// The VPC security groups and subnets that are attached to a project.
        public let vpcConfig: TestGridVpcConfig?

        public init(description: String? = nil, name: String? = nil, projectArn: String, vpcConfig: TestGridVpcConfig? = nil) {
            self.description = description
            self.name = name
            self.projectArn = projectArn
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: ".*\\S.*")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.validate(self.projectArn, name: "projectArn", parent: name, max: 1011)
            try self.validate(self.projectArn, name: "projectArn", parent: name, min: 32)
            try self.validate(self.projectArn, name: "projectArn", parent: name, pattern: "^arn:aws:devicefarm:.+")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case projectArn
            case vpcConfig
        }
    }

    public struct UpdateTestGridProjectResult: AWSDecodableShape {
        /// The project, including updated information.
        public let testGridProject: TestGridProject?

        public init(testGridProject: TestGridProject? = nil) {
            self.testGridProject = testGridProject
        }

        private enum CodingKeys: String, CodingKey {
            case testGridProject
        }
    }

    public struct UpdateUploadRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the uploaded test spec.
        public let arn: String
        /// The upload's content type (for example, application/x-yaml).
        public let contentType: String?
        /// Set to true if the YAML file has changed and must be updated. Otherwise, set to false.
        public let editContent: Bool?
        /// The upload's test spec file name. The name must not contain any forward slashes (/). The test spec file name must end with the .yaml or .yml file extension.
        public let name: String?

        public init(arn: String, contentType: String? = nil, editContent: Bool? = nil, name: String? = nil) {
            self.arn = arn
            self.contentType = contentType
            self.editContent = editContent
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 64)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case contentType
            case editContent
            case name
        }
    }

    public struct UpdateUploadResult: AWSDecodableShape {
        /// A test spec uploaded to Device Farm.
        public let upload: Upload?

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        private enum CodingKeys: String, CodingKey {
            case upload
        }
    }

    public struct UpdateVPCEConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to update.
        public let arn: String
        /// The DNS (domain) name used to connect to your private service in your VPC. The DNS name must not already be in use on the internet.
        public let serviceDnsName: String?
        /// An optional description that provides details about your VPC endpoint configuration.
        public let vpceConfigurationDescription: String?
        /// The friendly name you give to your VPC endpoint configuration to manage your configurations more easily.
        public let vpceConfigurationName: String?
        /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
        public let vpceServiceName: String?

        public init(arn: String, serviceDnsName: String? = nil, vpceConfigurationDescription: String? = nil, vpceConfigurationName: String? = nil, vpceServiceName: String? = nil) {
            self.arn = arn
            self.serviceDnsName = serviceDnsName
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.vpceConfigurationName = vpceConfigurationName
            self.vpceServiceName = vpceServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1011)
            try self.validate(self.arn, name: "arn", parent: name, min: 32)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.+")
            try self.validate(self.serviceDnsName, name: "serviceDnsName", parent: name, max: 2048)
            try self.validate(self.serviceDnsName, name: "serviceDnsName", parent: name, min: 0)
            try self.validate(self.vpceConfigurationDescription, name: "vpceConfigurationDescription", parent: name, max: 2048)
            try self.validate(self.vpceConfigurationDescription, name: "vpceConfigurationDescription", parent: name, min: 0)
            try self.validate(self.vpceConfigurationName, name: "vpceConfigurationName", parent: name, max: 1024)
            try self.validate(self.vpceConfigurationName, name: "vpceConfigurationName", parent: name, min: 0)
            try self.validate(self.vpceServiceName, name: "vpceServiceName", parent: name, max: 2048)
            try self.validate(self.vpceServiceName, name: "vpceServiceName", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case serviceDnsName
            case vpceConfigurationDescription
            case vpceConfigurationName
            case vpceServiceName
        }
    }

    public struct UpdateVPCEConfigurationResult: AWSDecodableShape {
        /// An object that contains information about your VPC endpoint configuration.
        public let vpceConfiguration: VPCEConfiguration?

        public init(vpceConfiguration: VPCEConfiguration? = nil) {
            self.vpceConfiguration = vpceConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case vpceConfiguration
        }
    }

    public struct Upload: AWSDecodableShape {
        /// The upload's ARN.
        public let arn: String?
        /// The upload's category. Allowed values include:   CURATED: An upload managed by AWS Device Farm.   PRIVATE: An upload managed by the AWS Device Farm customer.
        public let category: UploadCategory?
        /// The upload's content type (for example, application/octet-stream).
        public let contentType: String?
        /// When the upload was created.
        public let created: Date?
        /// A message about the upload's result.
        public let message: String?
        /// The upload's metadata. For example, for Android, this contains information that is parsed from the manifest and is displayed in the AWS Device Farm console after the associated app is uploaded.
        public let metadata: String?
        /// The upload's file name.
        public let name: String?
        /// The upload's status. Must be one of the following values:   FAILED   INITIALIZED   PROCESSING   SUCCEEDED
        public let status: UploadStatus?
        /// The upload's type. Must be one of the following values:   ANDROID_APP   IOS_APP   WEB_APP   EXTERNAL_DATA   APPIUM_JAVA_JUNIT_TEST_PACKAGE   APPIUM_JAVA_TESTNG_TEST_PACKAGE   APPIUM_PYTHON_TEST_PACKAGE   APPIUM_NODE_TEST_PACKAGE   APPIUM_RUBY_TEST_PACKAGE   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE   APPIUM_WEB_PYTHON_TEST_PACKAGE   APPIUM_WEB_NODE_TEST_PACKAGE   APPIUM_WEB_RUBY_TEST_PACKAGE   CALABASH_TEST_PACKAGE   INSTRUMENTATION_TEST_PACKAGE   UIAUTOMATION_TEST_PACKAGE   UIAUTOMATOR_TEST_PACKAGE   XCTEST_TEST_PACKAGE   XCTEST_UI_TEST_PACKAGE   APPIUM_JAVA_JUNIT_TEST_SPEC   APPIUM_JAVA_TESTNG_TEST_SPEC   APPIUM_PYTHON_TEST_SPEC   APPIUM_NODE_TEST_SPEC   APPIUM_RUBY_TEST_SPEC   APPIUM_WEB_JAVA_JUNIT_TEST_SPEC   APPIUM_WEB_JAVA_TESTNG_TEST_SPEC   APPIUM_WEB_PYTHON_TEST_SPEC   APPIUM_WEB_NODE_TEST_SPEC   APPIUM_WEB_RUBY_TEST_SPEC   INSTRUMENTATION_TEST_SPEC   XCTEST_UI_TEST_SPEC
        public let type: UploadType?
        /// The presigned Amazon S3 URL that was used to store a file using a PUT request.
        public let url: String?

        public init(arn: String? = nil, category: UploadCategory? = nil, contentType: String? = nil, created: Date? = nil, message: String? = nil, metadata: String? = nil, name: String? = nil, status: UploadStatus? = nil, type: UploadType? = nil, url: String? = nil) {
            self.arn = arn
            self.category = category
            self.contentType = contentType
            self.created = created
            self.message = message
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case category
            case contentType
            case created
            case message
            case metadata
            case name
            case status
            case type
            case url
        }
    }

    public struct VPCEConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration.
        public let arn: String?
        /// The DNS name that maps to the private IP address of the service you want to access.
        public let serviceDnsName: String?
        /// An optional description that provides details about your VPC endpoint configuration.
        public let vpceConfigurationDescription: String?
        /// The friendly name you give to your VPC endpoint configuration to manage your configurations more easily.
        public let vpceConfigurationName: String?
        /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
        public let vpceServiceName: String?

        public init(arn: String? = nil, serviceDnsName: String? = nil, vpceConfigurationDescription: String? = nil, vpceConfigurationName: String? = nil, vpceServiceName: String? = nil) {
            self.arn = arn
            self.serviceDnsName = serviceDnsName
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.vpceConfigurationName = vpceConfigurationName
            self.vpceServiceName = vpceServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case serviceDnsName
            case vpceConfigurationDescription
            case vpceConfigurationName
            case vpceServiceName
        }
    }
}
