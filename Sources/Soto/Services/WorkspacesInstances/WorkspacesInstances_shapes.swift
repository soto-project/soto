//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension WorkspacesInstances {
    // MARK: Enums

    public enum AmdSevSnpEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        public var description: String { return self.rawValue }
    }

    public enum AutoRecoveryEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case disabled = "disabled"
        public var description: String { return self.rawValue }
    }

    public enum BandwidthWeightingEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case ebs1 = "ebs-1"
        case vpc1 = "vpc-1"
        public var description: String { return self.rawValue }
    }

    public enum CapacityReservationPreferenceEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case capacityReservationsOnly = "capacity-reservations-only"
        case none = "none"
        case open = "open"
        public var description: String { return self.rawValue }
    }

    public enum CpuCreditsEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case standard = "standard"
        case unlimited = "unlimited"
        public var description: String { return self.rawValue }
    }

    public enum DisassociateModeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case force = "FORCE"
        case noForce = "NO_FORCE"
        public var description: String { return self.rawValue }
    }

    public enum HostnameTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ipName = "ip-name"
        case resourceName = "resource-name"
        public var description: String { return self.rawValue }
    }

    public enum HttpEndpointEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        public var description: String { return self.rawValue }
    }

    public enum HttpProtocolIpv6Enum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        public var description: String { return self.rawValue }
    }

    public enum HttpTokensEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optional = "optional"
        case required = "required"
        public var description: String { return self.rawValue }
    }

    public enum InstanceInterruptionBehaviorEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hibernate = "hibernate"
        case stop = "stop"
        public var description: String { return self.rawValue }
    }

    public enum InstanceMetadataTagsEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        public var description: String { return self.rawValue }
    }

    public enum InterfaceTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case efa = "efa"
        case efaOnly = "efa-only"
        case interface = "interface"
        public var description: String { return self.rawValue }
    }

    public enum MarketTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case capacityBlock = "capacity-block"
        case spot = "spot"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionStateEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allocated = "ALLOCATED"
        case allocating = "ALLOCATING"
        case deallocated = "DEALLOCATED"
        case deallocating = "DEALLOCATING"
        case errorAllocating = "ERROR_ALLOCATING"
        case errorDeallocating = "ERROR_DEALLOCATING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case instance = "instance"
        case networkInterface = "network-interface"
        case spotInstancesRequest = "spot-instances-request"
        case volume = "volume"
        public var description: String { return self.rawValue }
    }

    public enum SpotInstanceTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneTime = "one-time"
        case persistent = "persistent"
        public var description: String { return self.rawValue }
    }

    public enum TenancyEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case dedicated = "dedicated"
        case host = "host"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case dependencyFailure = "DEPENDENCY_FAILURE"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case other = "OTHER"
        case unknownOperation = "UNKNOWN_OPERATION"
        case unsupportedOperation = "UNSUPPORTED_OPERATION"
        public var description: String { return self.rawValue }
    }

    public enum VolumeTypeEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gp2 = "gp2"
        case gp3 = "gp3"
        case io1 = "io1"
        case io2 = "io2"
        case sc1 = "sc1"
        case st1 = "st1"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateVolumeRequest: AWSEncodableShape {
        /// Device path for volume attachment.
        public let device: String
        /// Volume to be attached.
        public let volumeId: String
        /// WorkSpace Instance to attach volume to.
        public let workspaceInstanceId: String

        @inlinable
        public init(device: String, volumeId: String, workspaceInstanceId: String) {
            self.device = device
            self.volumeId = volumeId
            self.workspaceInstanceId = workspaceInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.device, name: "device", parent: name, max: 32)
            try self.validate(self.volumeId, name: "volumeId", parent: name, pattern: "^vol-[0-9a-zA-Z]{1,63}$")
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, max: 70)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, min: 15)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, pattern: "^wsinst-[0-9a-zA-Z]{8,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
            case volumeId = "VolumeId"
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct AssociateVolumeResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BlockDeviceMappingRequest: AWSEncodableShape {
        /// Name of the device for storage mapping.
        public let deviceName: String?
        /// EBS volume configuration for the device.
        public let ebs: EbsBlockDevice?
        /// Indicates device should not be mapped.
        public let noDevice: String?
        /// Virtual device name for ephemeral storage.
        public let virtualName: String?

        @inlinable
        public init(deviceName: String? = nil, ebs: EbsBlockDevice? = nil, noDevice: String? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 32)
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.noDevice, name: "noDevice", parent: name, max: 32)
            try self.validate(self.virtualName, name: "virtualName", parent: name, pattern: "^ephemeral(0|[1-9][0-9]{0,2})$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "DeviceName"
            case ebs = "Ebs"
            case noDevice = "NoDevice"
            case virtualName = "VirtualName"
        }
    }

    public struct CapacityReservationSpecification: AWSEncodableShape {
        /// Preference for using capacity reservation.
        public let capacityReservationPreference: CapacityReservationPreferenceEnum?
        /// Specific capacity reservation target.
        public let capacityReservationTarget: CapacityReservationTarget?

        @inlinable
        public init(capacityReservationPreference: CapacityReservationPreferenceEnum? = nil, capacityReservationTarget: CapacityReservationTarget? = nil) {
            self.capacityReservationPreference = capacityReservationPreference
            self.capacityReservationTarget = capacityReservationTarget
        }

        public func validate(name: String) throws {
            try self.capacityReservationTarget?.validate(name: "\(name).capacityReservationTarget")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityReservationPreference = "CapacityReservationPreference"
            case capacityReservationTarget = "CapacityReservationTarget"
        }
    }

    public struct CapacityReservationTarget: AWSEncodableShape {
        /// Unique identifier for the capacity reservation.
        public let capacityReservationId: String?
        /// ARN of the capacity reservation resource group.
        public let capacityReservationResourceGroupArn: String?

        @inlinable
        public init(capacityReservationId: String? = nil, capacityReservationResourceGroupArn: String? = nil) {
            self.capacityReservationId = capacityReservationId
            self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityReservationId, name: "capacityReservationId", parent: name, max: 128)
            try self.validate(self.capacityReservationResourceGroupArn, name: "capacityReservationResourceGroupArn", parent: name, max: 2048)
            try self.validate(self.capacityReservationResourceGroupArn, name: "capacityReservationResourceGroupArn", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityReservationId = "CapacityReservationId"
            case capacityReservationResourceGroupArn = "CapacityReservationResourceGroupArn"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// Description of the conflict encountered.
        public let message: String
        /// Identifier of the conflicting resource.
        public let resourceId: String
        /// Type of the conflicting resource.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ConnectionTrackingSpecificationRequest: AWSEncodableShape {
        /// Timeout for established TCP connections.
        public let tcpEstablishedTimeout: Int?
        /// Timeout for UDP stream connections.
        public let udpStreamTimeout: Int?
        /// General timeout for UDP connections.
        public let udpTimeout: Int?

        @inlinable
        public init(tcpEstablishedTimeout: Int? = nil, udpStreamTimeout: Int? = nil, udpTimeout: Int? = nil) {
            self.tcpEstablishedTimeout = tcpEstablishedTimeout
            self.udpStreamTimeout = udpStreamTimeout
            self.udpTimeout = udpTimeout
        }

        public func validate(name: String) throws {
            try self.validate(self.tcpEstablishedTimeout, name: "tcpEstablishedTimeout", parent: name, min: 0)
            try self.validate(self.udpStreamTimeout, name: "udpStreamTimeout", parent: name, min: 0)
            try self.validate(self.udpTimeout, name: "udpTimeout", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tcpEstablishedTimeout = "TcpEstablishedTimeout"
            case udpStreamTimeout = "UdpStreamTimeout"
            case udpTimeout = "UdpTimeout"
        }
    }

    public struct CpuOptionsRequest: AWSEncodableShape {
        /// AMD Secure Encrypted Virtualization configuration.
        public let amdSevSnp: AmdSevSnpEnum?
        /// Number of CPU cores to allocate.
        public let coreCount: Int?
        /// Number of threads per CPU core.
        public let threadsPerCore: Int?

        @inlinable
        public init(amdSevSnp: AmdSevSnpEnum? = nil, coreCount: Int? = nil, threadsPerCore: Int? = nil) {
            self.amdSevSnp = amdSevSnp
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }

        public func validate(name: String) throws {
            try self.validate(self.coreCount, name: "coreCount", parent: name, min: 0)
            try self.validate(self.threadsPerCore, name: "threadsPerCore", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case amdSevSnp = "AmdSevSnp"
            case coreCount = "CoreCount"
            case threadsPerCore = "ThreadsPerCore"
        }
    }

    public struct CreateVolumeRequest: AWSEncodableShape {
        /// Availability zone for the volume.
        public let availabilityZone: String
        /// Unique token to prevent duplicate volume creation.
        public let clientToken: String?
        /// Indicates if the volume should be encrypted.
        public let encrypted: Bool?
        /// Input/output operations per second for the volume.
        public let iops: Int?
        /// KMS key for volume encryption.
        public let kmsKeyId: String?
        /// Volume size in gigabytes.
        public let sizeInGB: Int?
        /// Source snapshot for volume creation.
        public let snapshotId: String?
        /// Metadata tags for the volume.
        public let tagSpecifications: [TagSpecification]?
        /// Volume throughput performance.
        public let throughput: Int?
        /// Type of EBS volume.
        public let volumeType: VolumeTypeEnum?

        @inlinable
        public init(availabilityZone: String, clientToken: String? = CreateVolumeRequest.idempotencyToken(), encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, sizeInGB: Int? = nil, snapshotId: String? = nil, tagSpecifications: [TagSpecification]? = nil, throughput: Int? = nil, volumeType: VolumeTypeEnum? = nil) {
            self.availabilityZone = availabilityZone
            self.clientToken = clientToken
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.sizeInGB = sizeInGB
            self.snapshotId = snapshotId
            self.tagSpecifications = tagSpecifications
            self.throughput = throughput
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.iops, name: "iops", parent: name, min: 0)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 128)
            try self.validate(self.sizeInGB, name: "sizeInGB", parent: name, min: 0)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^snap-[0-9a-zA-Z]{1,63}$")
            try self.tagSpecifications?.forEach {
                try $0.validate(name: "\(name).tagSpecifications[]")
            }
            try self.validate(self.tagSpecifications, name: "tagSpecifications", parent: name, max: 30)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case clientToken = "ClientToken"
            case encrypted = "Encrypted"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case sizeInGB = "SizeInGB"
            case snapshotId = "SnapshotId"
            case tagSpecifications = "TagSpecifications"
            case throughput = "Throughput"
            case volumeType = "VolumeType"
        }
    }

    public struct CreateVolumeResponse: AWSDecodableShape {
        /// Unique identifier for the new volume.
        public let volumeId: String?

        @inlinable
        public init(volumeId: String? = nil) {
            self.volumeId = volumeId
        }

        private enum CodingKeys: String, CodingKey {
            case volumeId = "VolumeId"
        }
    }

    public struct CreateWorkspaceInstanceRequest: AWSEncodableShape {
        /// Unique token to ensure idempotent instance creation, preventing duplicate workspace launches.
        public let clientToken: String?
        /// Comprehensive configuration settings for the WorkSpaces Instance, including network, compute, and storage parameters.
        public let managedInstance: ManagedInstanceRequest
        /// Optional metadata tags for categorizing and managing WorkSpaces Instances.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateWorkspaceInstanceRequest.idempotencyToken(), managedInstance: ManagedInstanceRequest, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.managedInstance = managedInstance
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.managedInstance.validate(name: "\(name).managedInstance")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case managedInstance = "ManagedInstance"
            case tags = "Tags"
        }
    }

    public struct CreateWorkspaceInstanceResponse: AWSDecodableShape {
        /// Unique identifier assigned to the newly created WorkSpaces Instance.
        public let workspaceInstanceId: String?

        @inlinable
        public init(workspaceInstanceId: String? = nil) {
            self.workspaceInstanceId = workspaceInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct CreditSpecificationRequest: AWSEncodableShape {
        /// CPU credit specification mode.
        public let cpuCredits: CpuCreditsEnum?

        @inlinable
        public init(cpuCredits: CpuCreditsEnum? = nil) {
            self.cpuCredits = cpuCredits
        }

        private enum CodingKeys: String, CodingKey {
            case cpuCredits = "CpuCredits"
        }
    }

    public struct DeleteVolumeRequest: AWSEncodableShape {
        /// Identifier of the volume to delete.
        public let volumeId: String

        @inlinable
        public init(volumeId: String) {
            self.volumeId = volumeId
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeId, name: "volumeId", parent: name, pattern: "^vol-[0-9a-zA-Z]{1,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case volumeId = "VolumeId"
        }
    }

    public struct DeleteVolumeResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkspaceInstanceRequest: AWSEncodableShape {
        /// Unique identifier of the WorkSpaces Instance targeted for deletion.
        public let workspaceInstanceId: String

        @inlinable
        public init(workspaceInstanceId: String) {
            self.workspaceInstanceId = workspaceInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, max: 70)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, min: 15)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, pattern: "^wsinst-[0-9a-zA-Z]{8,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct DeleteWorkspaceInstanceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateVolumeRequest: AWSEncodableShape {
        /// Device path of volume to detach.
        public let device: String?
        /// Mode for volume detachment.
        public let disassociateMode: DisassociateModeEnum?
        /// Volume to be detached.
        public let volumeId: String
        /// WorkSpace Instance to detach volume from.
        public let workspaceInstanceId: String

        @inlinable
        public init(device: String? = nil, disassociateMode: DisassociateModeEnum? = nil, volumeId: String, workspaceInstanceId: String) {
            self.device = device
            self.disassociateMode = disassociateMode
            self.volumeId = volumeId
            self.workspaceInstanceId = workspaceInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.device, name: "device", parent: name, max: 32)
            try self.validate(self.volumeId, name: "volumeId", parent: name, pattern: "^vol-[0-9a-zA-Z]{1,63}$")
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, max: 70)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, min: 15)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, pattern: "^wsinst-[0-9a-zA-Z]{8,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
            case disassociateMode = "DisassociateMode"
            case volumeId = "VolumeId"
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct DisassociateVolumeResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EC2InstanceError: AWSDecodableShape {
        /// Unique error code identifying the specific EC2 instance error.
        public let ec2ErrorCode: String?
        /// Detailed description of the EC2 instance error.
        public let ec2ErrorMessage: String?
        /// Type of exception encountered during EC2 instance operation.
        public let ec2ExceptionType: String?

        @inlinable
        public init(ec2ErrorCode: String? = nil, ec2ErrorMessage: String? = nil, ec2ExceptionType: String? = nil) {
            self.ec2ErrorCode = ec2ErrorCode
            self.ec2ErrorMessage = ec2ErrorMessage
            self.ec2ExceptionType = ec2ExceptionType
        }

        private enum CodingKeys: String, CodingKey {
            case ec2ErrorCode = "EC2ErrorCode"
            case ec2ErrorMessage = "EC2ErrorMessage"
            case ec2ExceptionType = "EC2ExceptionType"
        }
    }

    public struct EC2ManagedInstance: AWSDecodableShape {
        /// Unique identifier of the managed EC2 instance.
        public let instanceId: String?

        @inlinable
        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
        }
    }

    public struct EbsBlockDevice: AWSEncodableShape {
        /// Indicates if the volume is encrypted.
        public let encrypted: Bool?
        /// Input/output operations per second for the volume.
        public let iops: Int?
        /// KMS key used for volume encryption.
        public let kmsKeyId: String?
        /// Volume data transfer rate.
        public let throughput: Int?
        /// Size of the EBS volume in gigabytes.
        public let volumeSize: Int?
        /// Type of EBS volume (e.g., gp2, io1).
        public let volumeType: VolumeTypeEnum?

        @inlinable
        public init(encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, throughput: Int? = nil, volumeSize: Int? = nil, volumeType: VolumeTypeEnum? = nil) {
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, min: 0)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 128)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 0)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case encrypted = "Encrypted"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case throughput = "Throughput"
            case volumeSize = "VolumeSize"
            case volumeType = "VolumeType"
        }
    }

    public struct EnaSrdSpecificationRequest: AWSEncodableShape {
        /// Enables or disables ENA SRD for network performance.
        public let enaSrdEnabled: Bool?
        /// Configures UDP-specific ENA SRD settings.
        public let enaSrdUdpSpecification: EnaSrdUdpSpecificationRequest?

        @inlinable
        public init(enaSrdEnabled: Bool? = nil, enaSrdUdpSpecification: EnaSrdUdpSpecificationRequest? = nil) {
            self.enaSrdEnabled = enaSrdEnabled
            self.enaSrdUdpSpecification = enaSrdUdpSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case enaSrdEnabled = "EnaSrdEnabled"
            case enaSrdUdpSpecification = "EnaSrdUdpSpecification"
        }
    }

    public struct EnaSrdUdpSpecificationRequest: AWSEncodableShape {
        /// Enables or disables ENA SRD for UDP traffic.
        public let enaSrdUdpEnabled: Bool?

        @inlinable
        public init(enaSrdUdpEnabled: Bool? = nil) {
            self.enaSrdUdpEnabled = enaSrdUdpEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case enaSrdUdpEnabled = "EnaSrdUdpEnabled"
        }
    }

    public struct EnclaveOptionsRequest: AWSEncodableShape {
        /// Enables or disables AWS Nitro Enclaves for enhanced security.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct GetWorkspaceInstanceRequest: AWSEncodableShape {
        /// Unique identifier of the WorkSpace Instance to retrieve.
        public let workspaceInstanceId: String

        @inlinable
        public init(workspaceInstanceId: String) {
            self.workspaceInstanceId = workspaceInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, max: 70)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, min: 15)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, pattern: "^wsinst-[0-9a-zA-Z]{8,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct GetWorkspaceInstanceResponse: AWSDecodableShape {
        /// Includes any underlying EC2 instance errors encountered.
        public let ec2InstanceErrors: [EC2InstanceError]?
        /// Details of the associated EC2 managed instance.
        public let ec2ManagedInstance: EC2ManagedInstance?
        /// Current provisioning state of the WorkSpaces Instance.
        public let provisionState: ProvisionStateEnum?
        /// Captures any errors specific to the WorkSpace Instance lifecycle.
        public let workspaceInstanceErrors: [WorkspaceInstanceError]?
        /// Unique identifier of the retrieved WorkSpaces Instance.
        public let workspaceInstanceId: String?

        @inlinable
        public init(ec2InstanceErrors: [EC2InstanceError]? = nil, ec2ManagedInstance: EC2ManagedInstance? = nil, provisionState: ProvisionStateEnum? = nil, workspaceInstanceErrors: [WorkspaceInstanceError]? = nil, workspaceInstanceId: String? = nil) {
            self.ec2InstanceErrors = ec2InstanceErrors
            self.ec2ManagedInstance = ec2ManagedInstance
            self.provisionState = provisionState
            self.workspaceInstanceErrors = workspaceInstanceErrors
            self.workspaceInstanceId = workspaceInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceErrors = "EC2InstanceErrors"
            case ec2ManagedInstance = "EC2ManagedInstance"
            case provisionState = "ProvisionState"
            case workspaceInstanceErrors = "WorkspaceInstanceErrors"
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct HibernationOptionsRequest: AWSEncodableShape {
        /// Enables or disables instance hibernation capability.
        public let configured: Bool?

        @inlinable
        public init(configured: Bool? = nil) {
            self.configured = configured
        }

        private enum CodingKeys: String, CodingKey {
            case configured = "Configured"
        }
    }

    public struct IamInstanceProfileSpecification: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the IAM instance profile.
        public let arn: String?
        /// Name of the IAM instance profile.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:.*")
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct InstanceIpv6Address: AWSEncodableShape {
        /// Specific IPv6 address assigned to the instance.
        public let ipv6Address: String?
        /// Indicates if this is the primary IPv6 address for the instance.
        public let isPrimaryIpv6: Bool?

        @inlinable
        public init(ipv6Address: String? = nil, isPrimaryIpv6: Bool? = nil) {
            self.ipv6Address = ipv6Address
            self.isPrimaryIpv6 = isPrimaryIpv6
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6Address, name: "ipv6Address", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Address = "Ipv6Address"
            case isPrimaryIpv6 = "IsPrimaryIpv6"
        }
    }

    public struct InstanceMaintenanceOptionsRequest: AWSEncodableShape {
        /// Enables or disables automatic instance recovery.
        public let autoRecovery: AutoRecoveryEnum?

        @inlinable
        public init(autoRecovery: AutoRecoveryEnum? = nil) {
            self.autoRecovery = autoRecovery
        }

        private enum CodingKeys: String, CodingKey {
            case autoRecovery = "AutoRecovery"
        }
    }

    public struct InstanceMarketOptionsRequest: AWSEncodableShape {
        /// Specifies the type of marketplace for instance deployment.
        public let marketType: MarketTypeEnum?
        /// Configuration options for spot instance deployment.
        public let spotOptions: SpotMarketOptions?

        @inlinable
        public init(marketType: MarketTypeEnum? = nil, spotOptions: SpotMarketOptions? = nil) {
            self.marketType = marketType
            self.spotOptions = spotOptions
        }

        public func validate(name: String) throws {
            try self.spotOptions?.validate(name: "\(name).spotOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case marketType = "MarketType"
            case spotOptions = "SpotOptions"
        }
    }

    public struct InstanceMetadataOptionsRequest: AWSEncodableShape {
        /// Enables or disables HTTP endpoint for instance metadata.
        public let httpEndpoint: HttpEndpointEnum?
        /// Configures IPv6 support for instance metadata HTTP protocol.
        public let httpProtocolIpv6: HttpProtocolIpv6Enum?
        /// Sets maximum number of network hops for metadata PUT responses.
        public let httpPutResponseHopLimit: Int?
        /// Configures token requirement for instance metadata retrieval.
        public let httpTokens: HttpTokensEnum?
        /// Enables or disables instance metadata tags retrieval.
        public let instanceMetadataTags: InstanceMetadataTagsEnum?

        @inlinable
        public init(httpEndpoint: HttpEndpointEnum? = nil, httpProtocolIpv6: HttpProtocolIpv6Enum? = nil, httpPutResponseHopLimit: Int? = nil, httpTokens: HttpTokensEnum? = nil, instanceMetadataTags: InstanceMetadataTagsEnum? = nil) {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }

        public func validate(name: String) throws {
            try self.validate(self.httpPutResponseHopLimit, name: "httpPutResponseHopLimit", parent: name, max: 64)
            try self.validate(self.httpPutResponseHopLimit, name: "httpPutResponseHopLimit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case httpProtocolIpv6 = "HttpProtocolIpv6"
            case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
            case httpTokens = "HttpTokens"
            case instanceMetadataTags = "InstanceMetadataTags"
        }
    }

    public struct InstanceNetworkInterfaceSpecification: AWSEncodableShape {
        /// Enables carrier IP address association.
        public let associateCarrierIpAddress: Bool?
        /// Enables public IP address assignment.
        public let associatePublicIpAddress: Bool?
        /// Configures network connection tracking parameters.
        public let connectionTrackingSpecification: ConnectionTrackingSpecificationRequest?
        /// Descriptive text for the network interface.
        public let description: String?
        /// Unique index for the network interface.
        public let deviceIndex: Int?
        /// Configures Elastic Network Adapter Scalable Reliable Datagram settings.
        public let enaSrdSpecification: EnaSrdSpecificationRequest?
        /// Security groups associated with the network interface.
        public let groups: [String]?
        /// Specifies the type of network interface.
        public let interfaceType: InterfaceTypeEnum?
        /// Number of IPv4 prefixes to assign.
        public let ipv4PrefixCount: Int?
        /// IPv4 prefix configurations for the interface.
        public let ipv4Prefixes: [Ipv4PrefixSpecificationRequest]?
        /// Number of IPv6 addresses to assign.
        public let ipv6AddressCount: Int?
        /// Specific IPv6 addresses for the interface.
        public let ipv6Addresses: [InstanceIpv6Address]?
        /// Number of IPv6 prefixes to assign.
        public let ipv6PrefixCount: Int?
        /// IPv6 prefix configurations for the interface.
        public let ipv6Prefixes: [Ipv6PrefixSpecificationRequest]?
        /// Index of the network card for multiple network interfaces.
        public let networkCardIndex: Int?
        /// Unique identifier for the network interface.
        public let networkInterfaceId: String?
        /// Indicates the primary IPv6 configuration.
        public let primaryIpv6: Bool?
        /// Primary private IP address for the interface.
        public let privateIpAddress: String?
        /// List of private IP addresses for the interface.
        public let privateIpAddresses: [PrivateIpAddressSpecification]?
        /// Number of additional private IP addresses to assign.
        public let secondaryPrivateIpAddressCount: Int?
        /// Subnet identifier for the network interface.
        public let subnetId: String?

        @inlinable
        public init(associateCarrierIpAddress: Bool? = nil, associatePublicIpAddress: Bool? = nil, connectionTrackingSpecification: ConnectionTrackingSpecificationRequest? = nil, description: String? = nil, deviceIndex: Int? = nil, enaSrdSpecification: EnaSrdSpecificationRequest? = nil, groups: [String]? = nil, interfaceType: InterfaceTypeEnum? = nil, ipv4PrefixCount: Int? = nil, ipv4Prefixes: [Ipv4PrefixSpecificationRequest]? = nil, ipv6AddressCount: Int? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, ipv6PrefixCount: Int? = nil, ipv6Prefixes: [Ipv6PrefixSpecificationRequest]? = nil, networkCardIndex: Int? = nil, networkInterfaceId: String? = nil, primaryIpv6: Bool? = nil, privateIpAddress: String? = nil, privateIpAddresses: [PrivateIpAddressSpecification]? = nil, secondaryPrivateIpAddressCount: Int? = nil, subnetId: String? = nil) {
            self.associateCarrierIpAddress = associateCarrierIpAddress
            self.associatePublicIpAddress = associatePublicIpAddress
            self.connectionTrackingSpecification = connectionTrackingSpecification
            self.description = description
            self.deviceIndex = deviceIndex
            self.enaSrdSpecification = enaSrdSpecification
            self.groups = groups
            self.interfaceType = interfaceType
            self.ipv4PrefixCount = ipv4PrefixCount
            self.ipv4Prefixes = ipv4Prefixes
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.ipv6PrefixCount = ipv6PrefixCount
            self.ipv6Prefixes = ipv6Prefixes
            self.networkCardIndex = networkCardIndex
            self.networkInterfaceId = networkInterfaceId
            self.primaryIpv6 = primaryIpv6
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.connectionTrackingSpecification?.validate(name: "\(name).connectionTrackingSpecification")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.deviceIndex, name: "deviceIndex", parent: name, min: 0)
            try self.groups?.forEach {
                try validate($0, name: "groups[]", parent: name, pattern: "^sg-[0-9a-zA-Z]{1,63}$")
            }
            try self.validate(self.ipv4PrefixCount, name: "ipv4PrefixCount", parent: name, min: 0)
            try self.ipv4Prefixes?.forEach {
                try $0.validate(name: "\(name).ipv4Prefixes[]")
            }
            try self.validate(self.ipv6AddressCount, name: "ipv6AddressCount", parent: name, min: 0)
            try self.ipv6Addresses?.forEach {
                try $0.validate(name: "\(name).ipv6Addresses[]")
            }
            try self.validate(self.ipv6PrefixCount, name: "ipv6PrefixCount", parent: name, min: 0)
            try self.ipv6Prefixes?.forEach {
                try $0.validate(name: "\(name).ipv6Prefixes[]")
            }
            try self.validate(self.networkCardIndex, name: "networkCardIndex", parent: name, min: 0)
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "^eni-[0-9a-zA-Z]{1,63}$")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "^(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$")
            try self.privateIpAddresses?.forEach {
                try $0.validate(name: "\(name).privateIpAddresses[]")
            }
            try self.validate(self.secondaryPrivateIpAddressCount, name: "secondaryPrivateIpAddressCount", parent: name, min: 0)
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "^subnet-[0-9a-zA-Z]{1,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case associateCarrierIpAddress = "AssociateCarrierIpAddress"
            case associatePublicIpAddress = "AssociatePublicIpAddress"
            case connectionTrackingSpecification = "ConnectionTrackingSpecification"
            case description = "Description"
            case deviceIndex = "DeviceIndex"
            case enaSrdSpecification = "EnaSrdSpecification"
            case groups = "Groups"
            case interfaceType = "InterfaceType"
            case ipv4PrefixCount = "Ipv4PrefixCount"
            case ipv4Prefixes = "Ipv4Prefixes"
            case ipv6AddressCount = "Ipv6AddressCount"
            case ipv6Addresses = "Ipv6Addresses"
            case ipv6PrefixCount = "Ipv6PrefixCount"
            case ipv6Prefixes = "Ipv6Prefixes"
            case networkCardIndex = "NetworkCardIndex"
            case networkInterfaceId = "NetworkInterfaceId"
            case primaryIpv6 = "PrimaryIpv6"
            case privateIpAddress = "PrivateIpAddress"
            case privateIpAddresses = "PrivateIpAddresses"
            case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
            case subnetId = "SubnetId"
        }
    }

    public struct InstanceNetworkPerformanceOptionsRequest: AWSEncodableShape {
        /// Defines bandwidth allocation strategy for network interfaces.
        public let bandwidthWeighting: BandwidthWeightingEnum?

        @inlinable
        public init(bandwidthWeighting: BandwidthWeightingEnum? = nil) {
            self.bandwidthWeighting = bandwidthWeighting
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidthWeighting = "BandwidthWeighting"
        }
    }

    public struct InstanceTypeInfo: AWSDecodableShape {
        /// Unique identifier for the WorkSpace Instance type.
        public let instanceType: String?

        @inlinable
        public init(instanceType: String? = nil) {
            self.instanceType = instanceType
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        /// Description of the internal server error.
        public let message: String
        /// Recommended wait time before retrying the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct Ipv4PrefixSpecificationRequest: AWSEncodableShape {
        /// Specific IPv4 prefix for network interface configuration.
        public let ipv4Prefix: String?

        @inlinable
        public init(ipv4Prefix: String? = nil) {
            self.ipv4Prefix = ipv4Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv4Prefix, name: "ipv4Prefix", parent: name, pattern: "(?:(?:\\d|[01]?\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d|\\d)(?:/\\d{1,2})?")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv4Prefix = "Ipv4Prefix"
        }
    }

    public struct Ipv6PrefixSpecificationRequest: AWSEncodableShape {
        /// Specific IPv6 prefix for network interface configuration.
        public let ipv6Prefix: String?

        @inlinable
        public init(ipv6Prefix: String? = nil) {
            self.ipv6Prefix = ipv6Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6Prefix, name: "ipv6Prefix", parent: name, pattern: "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/([0-9]{1,2}|1[01][0-9]|12[0-8])$")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Prefix = "Ipv6Prefix"
        }
    }

    public struct LicenseConfigurationRequest: AWSEncodableShape {
        /// ARN of the license configuration for the WorkSpace Instance.
        public let licenseConfigurationArn: String?

        @inlinable
        public init(licenseConfigurationArn: String? = nil) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseConfigurationArn, name: "licenseConfigurationArn", parent: name, max: 2048)
            try self.validate(self.licenseConfigurationArn, name: "licenseConfigurationArn", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
        }
    }

    public struct ListInstanceTypesRequest: AWSEncodableShape {
        /// Maximum number of instance types to return in a single API call. Enables pagination of instance type results.
        public let maxResults: Int?
        /// Pagination token for retrieving subsequent pages of instance type results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListInstanceTypesResponse: AWSDecodableShape {
        /// Collection of supported instance types for WorkSpaces Instances.
        public let instanceTypes: [InstanceTypeInfo]
        /// Token for retrieving additional instance types if the result set is paginated.
        public let nextToken: String?

        @inlinable
        public init(instanceTypes: [InstanceTypeInfo], nextToken: String? = nil) {
            self.instanceTypes = instanceTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceTypes = "InstanceTypes"
            case nextToken = "NextToken"
        }
    }

    public struct ListRegionsRequest: AWSEncodableShape {
        /// Maximum number of regions to return in a single API call. Enables pagination of region results.
        public let maxResults: Int?
        /// Pagination token for retrieving subsequent pages of region results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRegionsResponse: AWSDecodableShape {
        /// Token for retrieving additional regions if the result set is paginated.
        public let nextToken: String?
        /// Collection of AWS regions supported by WorkSpaces Instances.
        public let regions: [Region]

        @inlinable
        public init(nextToken: String? = nil, regions: [Region]) {
            self.nextToken = nextToken
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case regions = "Regions"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// Unique identifier of the WorkSpace Instance.
        public let workspaceInstanceId: String

        @inlinable
        public init(workspaceInstanceId: String) {
            self.workspaceInstanceId = workspaceInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, max: 70)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, min: 15)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, pattern: "^wsinst-[0-9a-zA-Z]{8,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Collection of tags associated with the WorkSpace Instance.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListWorkspaceInstancesRequest: AWSEncodableShape {
        /// Maximum number of WorkSpaces Instances to return in a single response.
        public let maxResults: Int?
        /// Pagination token for retrieving subsequent pages of WorkSpaces Instances.
        public let nextToken: String?
        /// Filter WorkSpaces Instances by their current provisioning states.
        public let provisionStates: [ProvisionStateEnum]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, provisionStates: [ProvisionStateEnum]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.provisionStates = provisionStates
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case provisionStates = "ProvisionStates"
        }
    }

    public struct ListWorkspaceInstancesResponse: AWSDecodableShape {
        /// Token for retrieving additional WorkSpaces Instances if the result set is paginated.
        public let nextToken: String?
        /// Collection of WorkSpaces Instances returned by the query.
        public let workspaceInstances: [WorkspaceInstance]

        @inlinable
        public init(nextToken: String? = nil, workspaceInstances: [WorkspaceInstance]) {
            self.nextToken = nextToken
            self.workspaceInstances = workspaceInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workspaceInstances = "WorkspaceInstances"
        }
    }

    public struct ManagedInstanceRequest: AWSEncodableShape {
        /// Configures block device mappings for storage.
        public let blockDeviceMappings: [BlockDeviceMappingRequest]?
        /// Specifies capacity reservation preferences.
        public let capacityReservationSpecification: CapacityReservationSpecification?
        /// Configures CPU-specific settings.
        public let cpuOptions: CpuOptionsRequest?
        /// Defines CPU credit configuration for burstable instances.
        public let creditSpecification: CreditSpecificationRequest?
        /// Prevents API-initiated instance stop.
        public let disableApiStop: Bool?
        /// Enables optimized EBS performance.
        public let ebsOptimized: Bool?
        /// Enables primary IPv6 address configuration.
        public let enablePrimaryIpv6: Bool?
        /// Configures AWS Nitro Enclave settings.
        public let enclaveOptions: EnclaveOptionsRequest?
        /// Configures instance hibernation capabilities.
        public let hibernationOptions: HibernationOptionsRequest?
        /// Specifies IAM instance profile configuration.
        public let iamInstanceProfile: IamInstanceProfileSpecification?
        /// Identifies the Amazon Machine Image (AMI) for the instance.
        public let imageId: String?
        /// Configures marketplace-specific deployment options.
        public let instanceMarketOptions: InstanceMarketOptionsRequest?
        /// Specifies the WorkSpace Instance type.
        public let instanceType: String?
        /// Specifies number of IPv6 addresses to assign.
        public let ipv6AddressCount: Int?
        /// Configures specific IPv6 addresses.
        public let ipv6Addresses: [InstanceIpv6Address]?
        /// Identifies the kernel for the instance.
        public let kernelId: String?
        /// Specifies the key pair for instance access.
        public let keyName: String?
        /// Configures license-related settings.
        public let licenseSpecifications: [LicenseConfigurationRequest]?
        /// Defines automatic maintenance settings.
        public let maintenanceOptions: InstanceMaintenanceOptionsRequest?
        /// Configures instance metadata service settings.
        public let metadataOptions: InstanceMetadataOptionsRequest?
        /// Enables or disables detailed instance monitoring.
        public let monitoring: RunInstancesMonitoringEnabled?
        /// Configures network interface settings.
        public let networkInterfaces: [InstanceNetworkInterfaceSpecification]?
        /// Defines network performance configuration.
        public let networkPerformanceOptions: InstanceNetworkPerformanceOptionsRequest?
        /// Specifies instance placement preferences.
        public let placement: Placement?
        /// Configures private DNS name settings.
        public let privateDnsNameOptions: PrivateDnsNameOptionsRequest?
        /// Specifies the primary private IP address.
        public let privateIpAddress: String?
        /// Identifies the ramdisk for the instance.
        public let ramdiskId: String?
        /// Specifies security group identifiers.
        public let securityGroupIds: [String]?
        /// Configures security group settings.
        public let securityGroups: [String]?
        /// Identifies the subnet for the instance.
        public let subnetId: String?
        /// Configures resource tagging specifications.
        public let tagSpecifications: [TagSpecification]?
        /// Provides custom initialization data for the instance.
        public let userData: String?

        @inlinable
        public init(blockDeviceMappings: [BlockDeviceMappingRequest]? = nil, capacityReservationSpecification: CapacityReservationSpecification? = nil, cpuOptions: CpuOptionsRequest? = nil, creditSpecification: CreditSpecificationRequest? = nil, disableApiStop: Bool? = nil, ebsOptimized: Bool? = nil, enablePrimaryIpv6: Bool? = nil, enclaveOptions: EnclaveOptionsRequest? = nil, hibernationOptions: HibernationOptionsRequest? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, instanceMarketOptions: InstanceMarketOptionsRequest? = nil, instanceType: String? = nil, ipv6AddressCount: Int? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, kernelId: String? = nil, keyName: String? = nil, licenseSpecifications: [LicenseConfigurationRequest]? = nil, maintenanceOptions: InstanceMaintenanceOptionsRequest? = nil, metadataOptions: InstanceMetadataOptionsRequest? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, networkPerformanceOptions: InstanceNetworkPerformanceOptionsRequest? = nil, placement: Placement? = nil, privateDnsNameOptions: PrivateDnsNameOptionsRequest? = nil, privateIpAddress: String? = nil, ramdiskId: String? = nil, securityGroupIds: [String]? = nil, securityGroups: [String]? = nil, subnetId: String? = nil, tagSpecifications: [TagSpecification]? = nil, userData: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.capacityReservationSpecification = capacityReservationSpecification
            self.cpuOptions = cpuOptions
            self.creditSpecification = creditSpecification
            self.disableApiStop = disableApiStop
            self.ebsOptimized = ebsOptimized
            self.enablePrimaryIpv6 = enablePrimaryIpv6
            self.enclaveOptions = enclaveOptions
            self.hibernationOptions = hibernationOptions
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceMarketOptions = instanceMarketOptions
            self.instanceType = instanceType
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.kernelId = kernelId
            self.keyName = keyName
            self.licenseSpecifications = licenseSpecifications
            self.maintenanceOptions = maintenanceOptions
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaces = networkInterfaces
            self.networkPerformanceOptions = networkPerformanceOptions
            self.placement = placement
            self.privateDnsNameOptions = privateDnsNameOptions
            self.privateIpAddress = privateIpAddress
            self.ramdiskId = ramdiskId
            self.securityGroupIds = securityGroupIds
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.tagSpecifications = tagSpecifications
            self.userData = userData
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.capacityReservationSpecification?.validate(name: "\(name).capacityReservationSpecification")
            try self.cpuOptions?.validate(name: "\(name).cpuOptions")
            try self.iamInstanceProfile?.validate(name: "\(name).iamInstanceProfile")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "^ami-[0-9a-zA-Z]{1,63}$")
            try self.instanceMarketOptions?.validate(name: "\(name).instanceMarketOptions")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^([a-z0-9-]+)\\.([a-z0-9]+)$")
            try self.validate(self.ipv6AddressCount, name: "ipv6AddressCount", parent: name, min: 0)
            try self.ipv6Addresses?.forEach {
                try $0.validate(name: "\(name).ipv6Addresses[]")
            }
            try self.validate(self.kernelId, name: "kernelId", parent: name, max: 128)
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.licenseSpecifications?.forEach {
                try $0.validate(name: "\(name).licenseSpecifications[]")
            }
            try self.metadataOptions?.validate(name: "\(name).metadataOptions")
            try self.networkInterfaces?.forEach {
                try $0.validate(name: "\(name).networkInterfaces[]")
            }
            try self.placement?.validate(name: "\(name).placement")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "^(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$")
            try self.validate(self.ramdiskId, name: "ramdiskId", parent: name, max: 128)
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-zA-Z]{1,63}$")
            }
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "^(?!sg-)[\\w .:/()#,@\\[\\]+=&;{}!$*-]{0,255}$")
            }
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "^subnet-[0-9a-zA-Z]{1,63}$")
            try self.tagSpecifications?.forEach {
                try $0.validate(name: "\(name).tagSpecifications[]")
            }
            try self.validate(self.tagSpecifications, name: "tagSpecifications", parent: name, max: 30)
            try self.validate(self.userData, name: "userData", parent: name, max: 16000)
        }

        private enum CodingKeys: String, CodingKey {
            case blockDeviceMappings = "BlockDeviceMappings"
            case capacityReservationSpecification = "CapacityReservationSpecification"
            case cpuOptions = "CpuOptions"
            case creditSpecification = "CreditSpecification"
            case disableApiStop = "DisableApiStop"
            case ebsOptimized = "EbsOptimized"
            case enablePrimaryIpv6 = "EnablePrimaryIpv6"
            case enclaveOptions = "EnclaveOptions"
            case hibernationOptions = "HibernationOptions"
            case iamInstanceProfile = "IamInstanceProfile"
            case imageId = "ImageId"
            case instanceMarketOptions = "InstanceMarketOptions"
            case instanceType = "InstanceType"
            case ipv6AddressCount = "Ipv6AddressCount"
            case ipv6Addresses = "Ipv6Addresses"
            case kernelId = "KernelId"
            case keyName = "KeyName"
            case licenseSpecifications = "LicenseSpecifications"
            case maintenanceOptions = "MaintenanceOptions"
            case metadataOptions = "MetadataOptions"
            case monitoring = "Monitoring"
            case networkInterfaces = "NetworkInterfaces"
            case networkPerformanceOptions = "NetworkPerformanceOptions"
            case placement = "Placement"
            case privateDnsNameOptions = "PrivateDnsNameOptions"
            case privateIpAddress = "PrivateIpAddress"
            case ramdiskId = "RamdiskId"
            case securityGroupIds = "SecurityGroupIds"
            case securityGroups = "SecurityGroups"
            case subnetId = "SubnetId"
            case tagSpecifications = "TagSpecifications"
            case userData = "UserData"
        }
    }

    public struct Placement: AWSEncodableShape {
        /// Specifies host affinity for dedicated instances.
        public let affinity: String?
        /// Identifies the specific AWS availability zone.
        public let availabilityZone: String?
        /// Unique identifier for placement group.
        public let groupId: String?
        /// Name of the placement group.
        public let groupName: String?
        /// Identifies the specific dedicated host.
        public let hostId: String?
        /// ARN of the host resource group.
        public let hostResourceGroupArn: String?
        /// Specifies partition number for partition placement groups.
        public let partitionNumber: Int?
        /// Defines instance tenancy configuration.
        public let tenancy: TenancyEnum?

        @inlinable
        public init(affinity: String? = nil, availabilityZone: String? = nil, groupId: String? = nil, groupName: String? = nil, hostId: String? = nil, hostResourceGroupArn: String? = nil, partitionNumber: Int? = nil, tenancy: TenancyEnum? = nil) {
            self.affinity = affinity
            self.availabilityZone = availabilityZone
            self.groupId = groupId
            self.groupName = groupName
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.partitionNumber = partitionNumber
            self.tenancy = tenancy
        }

        public func validate(name: String) throws {
            try self.validate(self.affinity, name: "affinity", parent: name, max: 64)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "^[a-z]{2}-[a-z]+-\\d[a-z](-[a-z0-9]+)?$")
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "^pg-[0-9a-zA-Z]{1,63}$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 64)
            try self.validate(self.hostId, name: "hostId", parent: name, pattern: "^h-[0-9a-zA-Z]{1,63}$")
            try self.validate(self.hostResourceGroupArn, name: "hostResourceGroupArn", parent: name, max: 2048)
            try self.validate(self.hostResourceGroupArn, name: "hostResourceGroupArn", parent: name, pattern: "^arn:.*")
            try self.validate(self.partitionNumber, name: "partitionNumber", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case affinity = "Affinity"
            case availabilityZone = "AvailabilityZone"
            case groupId = "GroupId"
            case groupName = "GroupName"
            case hostId = "HostId"
            case hostResourceGroupArn = "HostResourceGroupArn"
            case partitionNumber = "PartitionNumber"
            case tenancy = "Tenancy"
        }
    }

    public struct PrivateDnsNameOptionsRequest: AWSEncodableShape {
        /// Enables DNS AAAA record for resource name resolution.
        public let enableResourceNameDnsAAAARecord: Bool?
        /// Enables DNS A record for resource name resolution.
        public let enableResourceNameDnsARecord: Bool?
        /// Specifies the type of hostname configuration.
        public let hostnameType: HostnameTypeEnum?

        @inlinable
        public init(enableResourceNameDnsAAAARecord: Bool? = nil, enableResourceNameDnsARecord: Bool? = nil, hostnameType: HostnameTypeEnum? = nil) {
            self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
            self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
            self.hostnameType = hostnameType
        }

        private enum CodingKeys: String, CodingKey {
            case enableResourceNameDnsAAAARecord = "EnableResourceNameDnsAAAARecord"
            case enableResourceNameDnsARecord = "EnableResourceNameDnsARecord"
            case hostnameType = "HostnameType"
        }
    }

    public struct PrivateIpAddressSpecification: AWSEncodableShape {
        /// Indicates if this is the primary private IP address.
        public let primary: Bool?
        /// Specific private IP address for the network interface.
        public let privateIpAddress: String?

        @inlinable
        public init(primary: Bool? = nil, privateIpAddress: String? = nil) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "^(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$")
        }

        private enum CodingKeys: String, CodingKey {
            case primary = "Primary"
            case privateIpAddress = "PrivateIpAddress"
        }
    }

    public struct Region: AWSDecodableShape {
        /// Name of the AWS region.
        public let regionName: String?

        @inlinable
        public init(regionName: String? = nil) {
            self.regionName = regionName
        }

        private enum CodingKeys: String, CodingKey {
            case regionName = "RegionName"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// Details about the missing resource.
        public let message: String
        /// Identifier of the resource that was not found.
        public let resourceId: String
        /// Type of the resource that was not found.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RunInstancesMonitoringEnabled: AWSEncodableShape {
        /// Enables or disables detailed instance monitoring.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// Description of the quota limitation.
        public let message: String
        /// Specific code for the exceeded quota.
        public let quotaCode: String
        /// Identifier of the resource related to the quota.
        public let resourceId: String
        /// Type of resource related to the quota.
        public let resourceType: String
        /// Code identifying the service with the quota limitation.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case serviceCode = "ServiceCode"
        }
    }

    public struct SpotMarketOptions: AWSEncodableShape {
        /// Duration of spot instance block reservation.
        public let blockDurationMinutes: Int?
        /// Specifies behavior when spot instance is interrupted.
        public let instanceInterruptionBehavior: InstanceInterruptionBehaviorEnum?
        /// Maximum hourly price for spot instance.
        public let maxPrice: String?
        /// Defines the type of spot instance request.
        public let spotInstanceType: SpotInstanceTypeEnum?
        /// Timestamp until which spot instance request is valid.
        public let validUntilUtc: Date?

        @inlinable
        public init(blockDurationMinutes: Int? = nil, instanceInterruptionBehavior: InstanceInterruptionBehaviorEnum? = nil, maxPrice: String? = nil, spotInstanceType: SpotInstanceTypeEnum? = nil, validUntilUtc: Date? = nil) {
            self.blockDurationMinutes = blockDurationMinutes
            self.instanceInterruptionBehavior = instanceInterruptionBehavior
            self.maxPrice = maxPrice
            self.spotInstanceType = spotInstanceType
            self.validUntilUtc = validUntilUtc
        }

        public func validate(name: String) throws {
            try self.validate(self.blockDurationMinutes, name: "blockDurationMinutes", parent: name, min: 0)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case blockDurationMinutes = "BlockDurationMinutes"
            case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
            case maxPrice = "MaxPrice"
            case spotInstanceType = "SpotInstanceType"
            case validUntilUtc = "ValidUntilUtc"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier for the tag.
        public let key: String?
        /// Value associated with the tag key.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Tags to be added to the WorkSpace Instance.
        public let tags: [Tag]
        /// Unique identifier of the WorkSpace Instance to tag.
        public let workspaceInstanceId: String

        @inlinable
        public init(tags: [Tag], workspaceInstanceId: String) {
            self.tags = tags
            self.workspaceInstanceId = workspaceInstanceId
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 30)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, max: 70)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, min: 15)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, pattern: "^wsinst-[0-9a-zA-Z]{8,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagSpecification: AWSEncodableShape {
        /// Type of resource being tagged.
        public let resourceType: ResourceTypeEnum?
        /// Collection of tags for the specified resource.
        public let tags: [Tag]?

        @inlinable
        public init(resourceType: ResourceTypeEnum? = nil, tags: [Tag]? = nil) {
            self.resourceType = resourceType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case tags = "Tags"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        /// Description of the throttling event.
        public let message: String
        /// Specific code for the throttling quota.
        public let quotaCode: String?
        /// Recommended wait time before retrying the request.
        public let retryAfterSeconds: Int?
        /// Code identifying the service experiencing throttling.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case serviceCode = "ServiceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Keys of tags to be removed.
        public let tagKeys: [String]
        /// Unique identifier of the WorkSpace Instance to untag.
        public let workspaceInstanceId: String

        @inlinable
        public init(tagKeys: [String], workspaceInstanceId: String) {
            self.tagKeys = tagKeys
            self.workspaceInstanceId = workspaceInstanceId
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 30)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, max: 70)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, min: 15)
            try self.validate(self.workspaceInstanceId, name: "workspaceInstanceId", parent: name, pattern: "^wsinst-[0-9a-zA-Z]{8,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "TagKeys"
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ValidationException: AWSErrorShape {
        /// List of fields that failed validation.
        public let fieldList: [ValidationExceptionField]?
        /// Overall description of validation failures.
        public let message: String
        /// Specific reason for the validation failure.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "FieldList"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// Detailed error message describing the validation issue.
        public let message: String
        /// Name of the field that failed validation.
        public let name: String
        /// Reason for the validation failure.
        public let reason: String

        @inlinable
        public init(message: String, name: String, reason: String) {
            self.message = message
            self.name = name
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
            case reason = "Reason"
        }
    }

    public struct WorkspaceInstance: AWSDecodableShape {
        /// Details of the associated EC2 managed instance.
        public let ec2ManagedInstance: EC2ManagedInstance?
        /// Current provisioning state of the WorkSpace Instance.
        public let provisionState: ProvisionStateEnum?
        /// Unique identifier for the WorkSpace Instance.
        public let workspaceInstanceId: String?

        @inlinable
        public init(ec2ManagedInstance: EC2ManagedInstance? = nil, provisionState: ProvisionStateEnum? = nil, workspaceInstanceId: String? = nil) {
            self.ec2ManagedInstance = ec2ManagedInstance
            self.provisionState = provisionState
            self.workspaceInstanceId = workspaceInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case ec2ManagedInstance = "EC2ManagedInstance"
            case provisionState = "ProvisionState"
            case workspaceInstanceId = "WorkspaceInstanceId"
        }
    }

    public struct WorkspaceInstanceError: AWSDecodableShape {
        /// Unique error code for the WorkSpace Instance error.
        public let errorCode: String?
        /// Detailed description of the WorkSpace Instance error.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }
}

// MARK: - Errors

/// Error enum for WorkspacesInstances
public struct WorkspacesInstancesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize WorkspacesInstances
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Indicates insufficient permissions to perform the requested action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Signals a conflict with the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// Indicates an unexpected server-side error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Indicates the requested resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Indicates that a service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Indicates the request rate has exceeded limits.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Indicates invalid input parameters in the request.
    public static var validationException: Self { .init(.validationException) }
}

extension WorkspacesInstancesErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": WorkspacesInstances.ConflictException.self,
        "InternalServerException": WorkspacesInstances.InternalServerException.self,
        "ResourceNotFoundException": WorkspacesInstances.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": WorkspacesInstances.ServiceQuotaExceededException.self,
        "ThrottlingException": WorkspacesInstances.ThrottlingException.self,
        "ValidationException": WorkspacesInstances.ValidationException.self
    ]
}

extension WorkspacesInstancesErrorType: Equatable {
    public static func == (lhs: WorkspacesInstancesErrorType, rhs: WorkspacesInstancesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WorkspacesInstancesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
