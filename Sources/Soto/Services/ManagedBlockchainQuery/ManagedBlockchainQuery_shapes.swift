//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if compiler(>=5.7) && os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
import SotoCore

extension ManagedBlockchainQuery {
    // MARK: Enums

    public enum ErrorType: String, CustomStringConvertible, Codable, Sendable {
        /// An API request retrieving an item that can't be found
        case resourceNotFoundException = "RESOURCE_NOT_FOUND_EXCEPTION"
        /// An API request validation exception
        case validationException = "VALIDATION_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum ListTransactionsSortBy: String, CustomStringConvertible, Codable, Sendable {
        /// Timestamp of a transaction
        case transactionTimestamp = "TRANSACTION_TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum QueryNetwork: String, CustomStringConvertible, Codable, Sendable {
        /// Bitcoin main network
        case bitcoinMainnet = "BITCOIN_MAINNET"
        /// Ethereum main network
        case ethereumMainnet = "ETHEREUM_MAINNET"
        public var description: String { return self.rawValue }
    }

    public enum QueryTransactionEventType: String, CustomStringConvertible, Codable, Sendable {
        /// A Bitcoin Vin transfer type
        case bitcoinVin = "BITCOIN_VIN"
        /// A Bitcoin Vout transfer type
        case bitcoinVout = "BITCOIN_VOUT"
        /// An ERC1155 transfer type
        case erc1155Transfer = "ERC1155_TRANSFER"
        /// An ERC20_BURN transfer type
        case erc20Burn = "ERC20_BURN"
        /// An ERC20_DEPOSIT transfer type
        case erc20Deposit = "ERC20_DEPOSIT"
        /// An ERC20_MINT transfer type
        case erc20Mint = "ERC20_MINT"
        /// An ERC20 transfer type
        case erc20Transfer = "ERC20_TRANSFER"
        /// An ERC20_WITHDRAWAL transfer type
        case erc20Withdrawal = "ERC20_WITHDRAWAL"
        /// An ERC721 transfer type
        case erc721Transfer = "ERC721_TRANSFER"
        /// An ETH transfer type
        case ethTransfer = "ETH_TRANSFER"
        /// An internal ETH transfer type
        case internalEthTransfer = "INTERNAL_ETH_TRANSFER"
        public var description: String { return self.rawValue }
    }

    public enum QueryTransactionStatus: String, CustomStringConvertible, Codable, Sendable {
        /// The transaction completed on the blockchain, but failed
        case failed = "FAILED"
        /// The transaction has been confirmed and is final in the blockchain
        case final = "FINAL"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable {
        /// Result sorted in ascending order
        case ascending = "ASCENDING"
        /// Result sorted in descending order
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchGetTokenBalanceErrorItem: AWSDecodableShape {
        public let atBlockchainInstant: BlockchainInstant?
        /// The error code associated with the error.
        public let errorCode: String
        /// The message associated with the error.
        public let errorMessage: String
        /// The type of error.
        public let errorType: ErrorType
        public let ownerIdentifier: OwnerIdentifier?
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant? = nil, errorCode: String, errorMessage: String, errorType: ErrorType, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case errorType = "errorType"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct BatchGetTokenBalanceInput: AWSEncodableShape {
        /// An array of GetTokenBalanceInput objects whose balance is being requested.
        public let getTokenBalanceInputs: [BatchGetTokenBalanceInputItem]?

        public init(getTokenBalanceInputs: [BatchGetTokenBalanceInputItem]? = nil) {
            self.getTokenBalanceInputs = getTokenBalanceInputs
        }

        public func validate(name: String) throws {
            try self.getTokenBalanceInputs?.forEach {
                try $0.validate(name: "\(name).getTokenBalanceInputs[]")
            }
            try self.validate(self.getTokenBalanceInputs, name: "getTokenBalanceInputs", parent: name, max: 10)
            try self.validate(self.getTokenBalanceInputs, name: "getTokenBalanceInputs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case getTokenBalanceInputs = "getTokenBalanceInputs"
        }
    }

    public struct BatchGetTokenBalanceInputItem: AWSEncodableShape {
        public let atBlockchainInstant: BlockchainInstant?
        public let ownerIdentifier: OwnerIdentifier
        public let tokenIdentifier: TokenIdentifier

        public init(atBlockchainInstant: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier, tokenIdentifier: TokenIdentifier) {
            self.atBlockchainInstant = atBlockchainInstant
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        public func validate(name: String) throws {
            try self.ownerIdentifier.validate(name: "\(name).ownerIdentifier")
            try self.tokenIdentifier.validate(name: "\(name).tokenIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct BatchGetTokenBalanceOutput: AWSDecodableShape {
        /// An array of BatchGetTokenBalanceErrorItem objects returned from the request.
        public let errors: [BatchGetTokenBalanceErrorItem]
        /// An array of BatchGetTokenBalanceOutputItem objects returned by the response.
        public let tokenBalances: [BatchGetTokenBalanceOutputItem]

        public init(errors: [BatchGetTokenBalanceErrorItem], tokenBalances: [BatchGetTokenBalanceOutputItem]) {
            self.errors = errors
            self.tokenBalances = tokenBalances
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case tokenBalances = "tokenBalances"
        }
    }

    public struct BatchGetTokenBalanceOutputItem: AWSDecodableShape {
        public let atBlockchainInstant: BlockchainInstant
        /// The container for the token balance.
        public let balance: String
        public let lastUpdatedTime: BlockchainInstant?
        public let ownerIdentifier: OwnerIdentifier?
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant, balance: String, lastUpdatedTime: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case balance = "balance"
            case lastUpdatedTime = "lastUpdatedTime"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct BlockchainInstant: AWSEncodableShape & AWSDecodableShape {
        /// The container of the Timestamp of the blockchain instant.  This timestamp will only be recorded up to  the second.
        public let time: Date?

        public init(time: Date? = nil) {
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case time = "time"
        }
    }

    public struct GetTokenBalanceInput: AWSEncodableShape {
        /// The time for when the TokenBalance is requested or  the current time if a time is not provided in the request.  This time will only be recorded up to the second.
        public let atBlockchainInstant: BlockchainInstant?
        /// The container for the identifier for the owner.
        public let ownerIdentifier: OwnerIdentifier
        /// The container for the identifier for the token, including the unique  token ID and its blockchain network.
        public let tokenIdentifier: TokenIdentifier

        public init(atBlockchainInstant: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier, tokenIdentifier: TokenIdentifier) {
            self.atBlockchainInstant = atBlockchainInstant
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        public func validate(name: String) throws {
            try self.ownerIdentifier.validate(name: "\(name).ownerIdentifier")
            try self.tokenIdentifier.validate(name: "\(name).tokenIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct GetTokenBalanceOutput: AWSDecodableShape {
        public let atBlockchainInstant: BlockchainInstant
        /// The container for the token balance.
        public let balance: String
        public let lastUpdatedTime: BlockchainInstant?
        public let ownerIdentifier: OwnerIdentifier?
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant, balance: String, lastUpdatedTime: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case balance = "balance"
            case lastUpdatedTime = "lastUpdatedTime"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct GetTransactionInput: AWSEncodableShape {
        /// The blockchain network where the transaction occurred.
        public let network: QueryNetwork
        /// The hash of the transaction.  It is generated whenever a transaction is verified and added to the blockchain.
        public let transactionHash: String

        public init(network: QueryNetwork, transactionHash: String) {
            self.network = network
            self.transactionHash = transactionHash
        }

        public func validate(name: String) throws {
            try self.validate(self.transactionHash, name: "transactionHash", parent: name, pattern: "^(0x[A-Fa-f0-9]{64}|[A-Fa-f0-9]{64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case network = "network"
            case transactionHash = "transactionHash"
        }
    }

    public struct GetTransactionOutput: AWSDecodableShape {
        /// Contains the details of the transaction.
        public let transaction: Transaction

        public init(transaction: Transaction) {
            self.transaction = transaction
        }

        private enum CodingKeys: String, CodingKey {
            case transaction = "transaction"
        }
    }

    public struct ListTokenBalancesInput: AWSEncodableShape {
        /// The maximum number of token balances to return.
        public let maxResults: Int?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The contract or wallet address on the blockchain network by which to filter the  request. You must specify the address property of the ownerFilter  when listing balances of tokens owned by the address.
        public let ownerFilter: OwnerFilter?
        /// The contract address or a token identifier on the  blockchain network by which to filter the request. You must specify the contractAddress  property of this container when listing tokens minted by a contract.  You must always specify the network property of this  container when using this operation.
        public let tokenFilter: TokenFilter

        public init(maxResults: Int? = nil, nextToken: String? = nil, ownerFilter: OwnerFilter? = nil, tokenFilter: TokenFilter) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerFilter = ownerFilter
            self.tokenFilter = tokenFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
            try self.ownerFilter?.validate(name: "\(name).ownerFilter")
            try self.tokenFilter.validate(name: "\(name).tokenFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case ownerFilter = "ownerFilter"
            case tokenFilter = "tokenFilter"
        }
    }

    public struct ListTokenBalancesOutput: AWSDecodableShape {
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An array of TokenBalance objects. Each object contains details about  the token balance.
        public let tokenBalances: [TokenBalance]

        public init(nextToken: String? = nil, tokenBalances: [TokenBalance]) {
            self.nextToken = nextToken
            self.tokenBalances = tokenBalances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tokenBalances = "tokenBalances"
        }
    }

    public struct ListTransactionEventsInput: AWSEncodableShape {
        /// The maximum number of transaction events to list.  Even if additional results can be retrieved, the request can return less  results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the  returned nextToken value. The value of nextToken is  null when there are no more results to return
        public let maxResults: Int?
        /// The blockchain network where the transaction events occurred.
        public let network: QueryNetwork
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let transactionHash: String

        public init(maxResults: Int? = nil, network: QueryNetwork, nextToken: String? = nil, transactionHash: String) {
            self.maxResults = maxResults
            self.network = network
            self.nextToken = nextToken
            self.transactionHash = transactionHash
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
            try self.validate(self.transactionHash, name: "transactionHash", parent: name, pattern: "^(0x[A-Fa-f0-9]{64}|[A-Fa-f0-9]{64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case network = "network"
            case nextToken = "nextToken"
            case transactionHash = "transactionHash"
        }
    }

    public struct ListTransactionEventsOutput: AWSDecodableShape {
        /// An array of TransactionEvent objects. Each object contains details  about the transaction events.
        public let events: [TransactionEvent]
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(events: [TransactionEvent], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListTransactionsInput: AWSEncodableShape {
        /// The address (either a contract or wallet), whose transactions are being requested.
        public let address: String
        public let fromBlockchainInstant: BlockchainInstant?
        /// The maximum number of transactions to list.  Even if additional results can be retrieved, the request can return less  results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the  returned nextToken value. The value of nextToken is  null when there are no more results to return
        public let maxResults: Int?
        /// The blockchain network where the transactions occurred.
        public let network: QueryNetwork
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// Sorts items in an ascending order if the first page starts at fromTime.  Sorts items in a descending order if the first page starts at toTime.
        public let sort: ListTransactionsSort?
        public let toBlockchainInstant: BlockchainInstant?

        public init(address: String, fromBlockchainInstant: BlockchainInstant? = nil, maxResults: Int? = nil, network: QueryNetwork, nextToken: String? = nil, sort: ListTransactionsSort? = nil, toBlockchainInstant: BlockchainInstant? = nil) {
            self.address = address
            self.fromBlockchainInstant = fromBlockchainInstant
            self.maxResults = maxResults
            self.network = network
            self.nextToken = nextToken
            self.sort = sort
            self.toBlockchainInstant = toBlockchainInstant
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
            case fromBlockchainInstant = "fromBlockchainInstant"
            case maxResults = "maxResults"
            case network = "network"
            case nextToken = "nextToken"
            case sort = "sort"
            case toBlockchainInstant = "toBlockchainInstant"
        }
    }

    public struct ListTransactionsOutput: AWSDecodableShape {
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The array of transactions returned by the request.
        public let transactions: [TransactionOutputItem]

        public init(nextToken: String? = nil, transactions: [TransactionOutputItem]) {
            self.nextToken = nextToken
            self.transactions = transactions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case transactions = "transactions"
        }
    }

    public struct ListTransactionsSort: AWSEncodableShape {
        /// Defaults to the value TRANSACTION_TIMESTAMP.
        public let sortBy: ListTransactionsSortBy?
        /// The container for the sort order for ListTransactions.  The SortOrder field only accepts the values ASCENDING  and DESCENDING. Not providing SortOrder will default  to ASCENDING.
        public let sortOrder: SortOrder?

        public init(sortBy: ListTransactionsSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct OwnerFilter: AWSEncodableShape {
        /// The contract or wallet address.
        public let address: String

        public init(address: String) {
            self.address = address
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
        }
    }

    public struct OwnerIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The contract or wallet address for the owner.
        public let address: String

        public init(address: String) {
            self.address = address
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
        }
    }

    public struct TokenBalance: AWSDecodableShape {
        /// The time for when the TokenBalance is requested or  the current time if a time is not provided in the request.  This time will only be recorded up to the second.
        public let atBlockchainInstant: BlockchainInstant
        /// The container of the token balance.
        public let balance: String
        /// The timestamp of the last transaction at which the balance for the token in the wallet was updated.
        public let lastUpdatedTime: BlockchainInstant?
        /// The container for the identifier of the owner.
        public let ownerIdentifier: OwnerIdentifier?
        /// The identifier for the token, including the unique token ID and its blockchain network.
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant, balance: String, lastUpdatedTime: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case balance = "balance"
            case lastUpdatedTime = "lastUpdatedTime"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct TokenFilter: AWSEncodableShape {
        /// This is the address of the contract.
        public let contractAddress: String?
        /// The blockchain network of the token.
        public let network: QueryNetwork
        /// The unique identifier of the token.
        public let tokenId: String?

        public init(contractAddress: String? = nil, network: QueryNetwork, tokenId: String? = nil) {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }

        public func validate(name: String) throws {
            try self.validate(self.contractAddress, name: "contractAddress", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
            try self.validate(self.tokenId, name: "tokenId", parent: name, pattern: "^[a-zA-Z0-9]{1,66}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contractAddress = "contractAddress"
            case network = "network"
            case tokenId = "tokenId"
        }
    }

    public struct TokenIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// This is the token's contract address.
        public let contractAddress: String?
        /// The blockchain network of the token.
        public let network: QueryNetwork
        /// The unique identifier of the token.
        public let tokenId: String?

        public init(contractAddress: String? = nil, network: QueryNetwork, tokenId: String? = nil) {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }

        public func validate(name: String) throws {
            try self.validate(self.contractAddress, name: "contractAddress", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
            try self.validate(self.tokenId, name: "tokenId", parent: name, pattern: "^[a-zA-Z0-9]{1,66}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contractAddress = "contractAddress"
            case network = "network"
            case tokenId = "tokenId"
        }
    }

    public struct Transaction: AWSDecodableShape {
        /// The block hash is a unique identifier for a block. It is a fixed-size  string that is calculated by using the information in the block. The block  hash is used to verify the integrity of the data in the block.
        public let blockHash: String?
        /// The block number in which the transaction is recorded.
        public let blockNumber: String?
        /// The blockchain address for the contract.
        public let contractAddress: String?
        /// The amount of gas used up to the specified point in the block.
        public let cumulativeGasUsed: String?
        /// The effective gas price.
        public let effectiveGasPrice: String?
        /// The initiator of the transaction. It is either in the form a public key or a  contract address.
        public let from: String?
        /// The amount of gas used for the transaction.
        public let gasUsed: String?
        /// The blockchain network where the transaction occured.
        public let network: QueryNetwork
        /// The number of transactions in the block.
        public let numberOfTransactions: Int64
        /// The signature of the transaction. The X coordinate of a point R.
        public let signatureR: String?
        /// The signature of the transaction. The Y coordinate of a point S.
        public let signatureS: String?
        /// The signature of the transaction. The Z coordinate of a point V.
        public let signatureV: Int?
        /// The status of the transaction.
        public let status: QueryTransactionStatus
        /// The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let to: String
        /// The transaction fee.
        public let transactionFee: String?
        /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let transactionHash: String
        /// The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let transactionId: String?
        /// The index of the transaction within a blockchain.
        public let transactionIndex: Int64
        /// The Timestamp of the transaction.
        public let transactionTimestamp: Date

        public init(blockHash: String? = nil, blockNumber: String? = nil, contractAddress: String? = nil, cumulativeGasUsed: String? = nil, effectiveGasPrice: String? = nil, from: String? = nil, gasUsed: String? = nil, network: QueryNetwork, numberOfTransactions: Int64, signatureR: String? = nil, signatureS: String? = nil, signatureV: Int? = nil, status: QueryTransactionStatus, to: String, transactionFee: String? = nil, transactionHash: String, transactionId: String? = nil, transactionIndex: Int64, transactionTimestamp: Date) {
            self.blockHash = blockHash
            self.blockNumber = blockNumber
            self.contractAddress = contractAddress
            self.cumulativeGasUsed = cumulativeGasUsed
            self.effectiveGasPrice = effectiveGasPrice
            self.from = from
            self.gasUsed = gasUsed
            self.network = network
            self.numberOfTransactions = numberOfTransactions
            self.signatureR = signatureR
            self.signatureS = signatureS
            self.signatureV = signatureV
            self.status = status
            self.to = to
            self.transactionFee = transactionFee
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.transactionIndex = transactionIndex
            self.transactionTimestamp = transactionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case blockHash = "blockHash"
            case blockNumber = "blockNumber"
            case contractAddress = "contractAddress"
            case cumulativeGasUsed = "cumulativeGasUsed"
            case effectiveGasPrice = "effectiveGasPrice"
            case from = "from"
            case gasUsed = "gasUsed"
            case network = "network"
            case numberOfTransactions = "numberOfTransactions"
            case signatureR = "signatureR"
            case signatureS = "signatureS"
            case signatureV = "signatureV"
            case status = "status"
            case to = "to"
            case transactionFee = "transactionFee"
            case transactionHash = "transactionHash"
            case transactionId = "transactionId"
            case transactionIndex = "transactionIndex"
            case transactionTimestamp = "transactionTimestamp"
        }
    }

    public struct TransactionEvent: AWSDecodableShape {
        /// The blockchain address. for the contract
        public let contractAddress: String?
        /// The type of transaction event.
        public let eventType: QueryTransactionEventType
        /// The wallet address initiating the transaction. It can either be a public key or a contract.
        public let from: String?
        /// The blockchain network where the transaction occurred.
        public let network: QueryNetwork
        /// The wallet address receiving the transaction.  It can either be a public key or a contract.
        public let to: String?
        /// The unique identifier for the token involved in the transaction.
        public let tokenId: String?
        /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let transactionHash: String
        /// The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let transactionId: String?
        /// The value that was transacted.
        public let value: String?
        /// The position of the vout in the transaction output list.
        public let voutIndex: Int?

        public init(contractAddress: String? = nil, eventType: QueryTransactionEventType, from: String? = nil, network: QueryNetwork, to: String? = nil, tokenId: String? = nil, transactionHash: String, transactionId: String? = nil, value: String? = nil, voutIndex: Int? = nil) {
            self.contractAddress = contractAddress
            self.eventType = eventType
            self.from = from
            self.network = network
            self.to = to
            self.tokenId = tokenId
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.value = value
            self.voutIndex = voutIndex
        }

        private enum CodingKeys: String, CodingKey {
            case contractAddress = "contractAddress"
            case eventType = "eventType"
            case from = "from"
            case network = "network"
            case to = "to"
            case tokenId = "tokenId"
            case transactionHash = "transactionHash"
            case transactionId = "transactionId"
            case value = "value"
            case voutIndex = "voutIndex"
        }
    }

    public struct TransactionOutputItem: AWSDecodableShape {
        /// The blockchain network where the transaction occurred.
        public let network: QueryNetwork
        /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let transactionHash: String
        /// The time when the transaction occurred.
        public let transactionTimestamp: Date

        public init(network: QueryNetwork, transactionHash: String, transactionTimestamp: Date) {
            self.network = network
            self.transactionHash = transactionHash
            self.transactionTimestamp = transactionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case network = "network"
            case transactionHash = "transactionHash"
            case transactionTimestamp = "transactionTimestamp"
        }
    }
}

// MARK: - Errors

/// Error enum for ManagedBlockchainQuery
public struct ManagedBlockchainQueryErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ManagedBlockchainQuery
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The Amazon Web Services account doesn’t have access to this resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request processing has failed because of an internal error in the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded for this resource.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request or operation couldn't be performed because a service is throttling  requests. The most common source of throttling errors is when you create resources  that exceed your service limit for this resource type. Request a limit increase or  delete unused resources, if possible.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The resource passed is invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension ManagedBlockchainQueryErrorType: Equatable {
    public static func == (lhs: ManagedBlockchainQueryErrorType, rhs: ManagedBlockchainQueryErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ManagedBlockchainQueryErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
