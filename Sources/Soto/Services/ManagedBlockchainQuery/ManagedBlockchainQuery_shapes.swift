//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ManagedBlockchainQuery {
    // MARK: Enums

    public enum ConfirmationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case final = "FINAL"
        case nonfinal = "NONFINAL"
        public var description: String { return self.rawValue }
    }

    public enum ErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// An API request retrieving an item that can't be found
        case resourceNotFoundException = "RESOURCE_NOT_FOUND_EXCEPTION"
        /// An API request validation exception
        case validationException = "VALIDATION_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ListFilteredTransactionEventsSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Timestamp of a transaction
        case blockchainInstant = "blockchainInstant"
        public var description: String { return self.rawValue }
    }

    public enum ListTransactionsSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Timestamp of a transaction
        case transactionTimestamp = "TRANSACTION_TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum QueryNetwork: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Bitcoin main network
        case bitcoinMainnet = "BITCOIN_MAINNET"
        /// Bitcoin test network
        case bitcoinTestnet = "BITCOIN_TESTNET"
        /// Ethereum main network
        case ethereumMainnet = "ETHEREUM_MAINNET"
        /// SEPOLIA network (ethereum testnet)
        case ethereumSepoliaTestnet = "ETHEREUM_SEPOLIA_TESTNET"
        public var description: String { return self.rawValue }
    }

    public enum QueryTokenStandard: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case erc1155 = "ERC1155"
        case erc20 = "ERC20"
        case erc721 = "ERC721"
        public var description: String { return self.rawValue }
    }

    public enum QueryTransactionEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// A Bitcoin Vin transfer type
        case bitcoinVin = "BITCOIN_VIN"
        /// A Bitcoin Vout transfer type
        case bitcoinVout = "BITCOIN_VOUT"
        /// An ERC1155 transfer type
        case erc1155Transfer = "ERC1155_TRANSFER"
        /// An ERC20_BURN transfer type
        case erc20Burn = "ERC20_BURN"
        /// An ERC20_DEPOSIT transfer type
        case erc20Deposit = "ERC20_DEPOSIT"
        /// An ERC20_MINT transfer type
        case erc20Mint = "ERC20_MINT"
        /// An ERC20 transfer type
        case erc20Transfer = "ERC20_TRANSFER"
        /// An ERC20_WITHDRAWAL transfer type
        case erc20Withdrawal = "ERC20_WITHDRAWAL"
        /// An ERC721 transfer type
        case erc721Transfer = "ERC721_TRANSFER"
        /// An ETH transfer type
        case ethTransfer = "ETH_TRANSFER"
        /// An internal ETH transfer type
        case internalEthTransfer = "INTERNAL_ETH_TRANSFER"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Result sorted in ascending order
        case ascending = "ASCENDING"
        /// Result sorted in descending order
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddressIdentifierFilter: AWSEncodableShape {
        /// The container for the recipient address of the transaction.
        public let transactionEventToAddress: [String]

        public init(transactionEventToAddress: [String]) {
            self.transactionEventToAddress = transactionEventToAddress
        }

        public func validate(name: String) throws {
            try self.transactionEventToAddress.forEach {
                try validate($0, name: "transactionEventToAddress[]", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case transactionEventToAddress = "transactionEventToAddress"
        }
    }

    public struct AssetContract: AWSDecodableShape {
        /// The container for the contract identifier containing its blockchain network  and address.
        public let contractIdentifier: ContractIdentifier
        /// The address of the contract deployer.
        public let deployerAddress: String
        /// The token standard of the contract.
        public let tokenStandard: QueryTokenStandard

        public init(contractIdentifier: ContractIdentifier, deployerAddress: String, tokenStandard: QueryTokenStandard) {
            self.contractIdentifier = contractIdentifier
            self.deployerAddress = deployerAddress
            self.tokenStandard = tokenStandard
        }

        private enum CodingKeys: String, CodingKey {
            case contractIdentifier = "contractIdentifier"
            case deployerAddress = "deployerAddress"
            case tokenStandard = "tokenStandard"
        }
    }

    public struct BatchGetTokenBalanceErrorItem: AWSDecodableShape {
        public let atBlockchainInstant: BlockchainInstant?
        /// The error code associated with the error.
        public let errorCode: String
        /// The message associated with the error.
        public let errorMessage: String
        /// The type of error.
        public let errorType: ErrorType
        public let ownerIdentifier: OwnerIdentifier?
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant? = nil, errorCode: String, errorMessage: String, errorType: ErrorType, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case errorType = "errorType"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct BatchGetTokenBalanceInput: AWSEncodableShape {
        /// An array of BatchGetTokenBalanceInputItem objects whose balance is being requested.
        public let getTokenBalanceInputs: [BatchGetTokenBalanceInputItem]?

        public init(getTokenBalanceInputs: [BatchGetTokenBalanceInputItem]? = nil) {
            self.getTokenBalanceInputs = getTokenBalanceInputs
        }

        public func validate(name: String) throws {
            try self.getTokenBalanceInputs?.forEach {
                try $0.validate(name: "\(name).getTokenBalanceInputs[]")
            }
            try self.validate(self.getTokenBalanceInputs, name: "getTokenBalanceInputs", parent: name, max: 10)
            try self.validate(self.getTokenBalanceInputs, name: "getTokenBalanceInputs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case getTokenBalanceInputs = "getTokenBalanceInputs"
        }
    }

    public struct BatchGetTokenBalanceInputItem: AWSEncodableShape {
        public let atBlockchainInstant: BlockchainInstant?
        public let ownerIdentifier: OwnerIdentifier
        public let tokenIdentifier: TokenIdentifier

        public init(atBlockchainInstant: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier, tokenIdentifier: TokenIdentifier) {
            self.atBlockchainInstant = atBlockchainInstant
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        public func validate(name: String) throws {
            try self.ownerIdentifier.validate(name: "\(name).ownerIdentifier")
            try self.tokenIdentifier.validate(name: "\(name).tokenIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct BatchGetTokenBalanceOutput: AWSDecodableShape {
        /// An array of BatchGetTokenBalanceErrorItem objects returned from the request.
        public let errors: [BatchGetTokenBalanceErrorItem]
        /// An array of BatchGetTokenBalanceOutputItem objects returned by the response.
        public let tokenBalances: [BatchGetTokenBalanceOutputItem]

        public init(errors: [BatchGetTokenBalanceErrorItem], tokenBalances: [BatchGetTokenBalanceOutputItem]) {
            self.errors = errors
            self.tokenBalances = tokenBalances
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case tokenBalances = "tokenBalances"
        }
    }

    public struct BatchGetTokenBalanceOutputItem: AWSDecodableShape {
        public let atBlockchainInstant: BlockchainInstant
        /// The container for the token balance.
        public let balance: String
        public let lastUpdatedTime: BlockchainInstant?
        public let ownerIdentifier: OwnerIdentifier?
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant, balance: String, lastUpdatedTime: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case balance = "balance"
            case lastUpdatedTime = "lastUpdatedTime"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct BlockchainInstant: AWSEncodableShape & AWSDecodableShape {
        /// The container of the Timestamp of the blockchain instant.  This timestamp will only be recorded up to  the second.
        public let time: Date?

        public init(time: Date? = nil) {
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case time = "time"
        }
    }

    public struct ConfirmationStatusFilter: AWSEncodableShape {
        /// The container to determine whether to list results that have only reached  finality . Transactions  that have reached finality are always part of the response.
        public let include: [ConfirmationStatus]

        public init(include: [ConfirmationStatus]) {
            self.include = include
        }

        public func validate(name: String) throws {
            try self.validate(self.include, name: "include", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case include = "include"
        }
    }

    public struct ContractFilter: AWSEncodableShape {
        /// The network address of the deployer.
        public let deployerAddress: String
        /// The blockchain network of the contract.
        public let network: QueryNetwork
        /// The container for the token standard.
        public let tokenStandard: QueryTokenStandard

        public init(deployerAddress: String, network: QueryNetwork, tokenStandard: QueryTokenStandard) {
            self.deployerAddress = deployerAddress
            self.network = network
            self.tokenStandard = tokenStandard
        }

        public func validate(name: String) throws {
            try self.validate(self.deployerAddress, name: "deployerAddress", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
        }

        private enum CodingKeys: String, CodingKey {
            case deployerAddress = "deployerAddress"
            case network = "network"
            case tokenStandard = "tokenStandard"
        }
    }

    public struct ContractIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// Container for the blockchain address about a contract.
        public let contractAddress: String
        /// The blockchain network of the contract.
        public let network: QueryNetwork

        public init(contractAddress: String, network: QueryNetwork) {
            self.contractAddress = contractAddress
            self.network = network
        }

        public func validate(name: String) throws {
            try self.validate(self.contractAddress, name: "contractAddress", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contractAddress = "contractAddress"
            case network = "network"
        }
    }

    public struct ContractMetadata: AWSDecodableShape {
        /// The decimals used by the token contract.
        public let decimals: Int?
        /// The name of the token contract.
        public let name: String?
        /// The symbol of the token contract.
        public let symbol: String?

        public init(decimals: Int? = nil, name: String? = nil, symbol: String? = nil) {
            self.decimals = decimals
            self.name = name
            self.symbol = symbol
        }

        private enum CodingKeys: String, CodingKey {
            case decimals = "decimals"
            case name = "name"
            case symbol = "symbol"
        }
    }

    public struct GetAssetContractInput: AWSEncodableShape {
        /// Contains the blockchain address and network information about the contract.
        public let contractIdentifier: ContractIdentifier

        public init(contractIdentifier: ContractIdentifier) {
            self.contractIdentifier = contractIdentifier
        }

        public func validate(name: String) throws {
            try self.contractIdentifier.validate(name: "\(name).contractIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case contractIdentifier = "contractIdentifier"
        }
    }

    public struct GetAssetContractOutput: AWSDecodableShape {
        /// Contains the blockchain address and network information about the contract.
        public let contractIdentifier: ContractIdentifier
        /// The address of the deployer of contract.
        public let deployerAddress: String
        public let metadata: ContractMetadata?
        /// The token standard of the contract requested.
        public let tokenStandard: QueryTokenStandard

        public init(contractIdentifier: ContractIdentifier, deployerAddress: String, metadata: ContractMetadata? = nil, tokenStandard: QueryTokenStandard) {
            self.contractIdentifier = contractIdentifier
            self.deployerAddress = deployerAddress
            self.metadata = metadata
            self.tokenStandard = tokenStandard
        }

        private enum CodingKeys: String, CodingKey {
            case contractIdentifier = "contractIdentifier"
            case deployerAddress = "deployerAddress"
            case metadata = "metadata"
            case tokenStandard = "tokenStandard"
        }
    }

    public struct GetTokenBalanceInput: AWSEncodableShape {
        /// The time for when the TokenBalance is requested or  the current time if a time is not provided in the request.  This time will only be recorded up to the second.
        public let atBlockchainInstant: BlockchainInstant?
        /// The container for the identifier for the owner.
        public let ownerIdentifier: OwnerIdentifier
        /// The container for the identifier for the token, including the unique  token ID and its blockchain network.
        public let tokenIdentifier: TokenIdentifier

        public init(atBlockchainInstant: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier, tokenIdentifier: TokenIdentifier) {
            self.atBlockchainInstant = atBlockchainInstant
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        public func validate(name: String) throws {
            try self.ownerIdentifier.validate(name: "\(name).ownerIdentifier")
            try self.tokenIdentifier.validate(name: "\(name).tokenIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct GetTokenBalanceOutput: AWSDecodableShape {
        public let atBlockchainInstant: BlockchainInstant
        /// The container for the token balance.
        public let balance: String
        public let lastUpdatedTime: BlockchainInstant?
        public let ownerIdentifier: OwnerIdentifier?
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant, balance: String, lastUpdatedTime: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case balance = "balance"
            case lastUpdatedTime = "lastUpdatedTime"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct GetTransactionInput: AWSEncodableShape {
        /// The blockchain network where the transaction occurred.
        public let network: QueryNetwork
        /// The hash of a transaction. It is generated when a transaction is created.
        public let transactionHash: String?
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.   transactionId is only supported on the Bitcoin networks.
        public let transactionId: String?

        public init(network: QueryNetwork, transactionHash: String? = nil, transactionId: String? = nil) {
            self.network = network
            self.transactionHash = transactionHash
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.transactionHash, name: "transactionHash", parent: name, pattern: "^(0x[A-Fa-f0-9]{64}|[A-Fa-f0-9]{64})$")
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^(0x[A-Fa-f0-9]{64}|[A-Fa-f0-9]{64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case network = "network"
            case transactionHash = "transactionHash"
            case transactionId = "transactionId"
        }
    }

    public struct GetTransactionOutput: AWSDecodableShape {
        /// Contains the details of the transaction.
        public let transaction: Transaction

        public init(transaction: Transaction) {
            self.transaction = transaction
        }

        private enum CodingKeys: String, CodingKey {
            case transaction = "transaction"
        }
    }

    public struct ListAssetContractsInput: AWSEncodableShape {
        /// Contains the filter parameter for the request.
        public let contractFilter: ContractFilter
        /// The maximum number of contracts to list. Default: 100   Even if additional results can be retrieved, the request can return less  results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the  returned nextToken value. The value of nextToken is  null when there are no more results to return
        public let maxResults: Int?
        ///  The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(contractFilter: ContractFilter, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contractFilter = contractFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.contractFilter.validate(name: "\(name).contractFilter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
        }

        private enum CodingKeys: String, CodingKey {
            case contractFilter = "contractFilter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetContractsOutput: AWSDecodableShape {
        /// An array of contract objects that contain the properties for each contract.
        public let contracts: [AssetContract]
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(contracts: [AssetContract], nextToken: String? = nil) {
            self.contracts = contracts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contracts = "contracts"
            case nextToken = "nextToken"
        }
    }

    public struct ListFilteredTransactionEventsInput: AWSEncodableShape {
        /// This is the unique public address on the blockchain for which the transaction events are being requested.
        public let addressIdentifierFilter: AddressIdentifierFilter
        public let confirmationStatusFilter: ConfirmationStatusFilter?
        /// The maximum number of transaction events to list. Default: 100   Even if additional results can be retrieved, the request can return less  results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the  returned nextToken value. The value of nextToken is  null when there are no more results to return
        public let maxResults: Int?
        /// The blockchain network where the transaction occurred. Valid Values: BITCOIN_MAINNET | BITCOIN_TESTNET
        public let network: String
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The order by which the results will be sorted.
        public let sort: ListFilteredTransactionEventsSort?
        /// This container specifies the time frame for the transaction events returned in the response.
        public let timeFilter: TimeFilter?
        /// This container specifies filtering attributes related to BITCOIN_VOUT event types
        public let voutFilter: VoutFilter?

        public init(addressIdentifierFilter: AddressIdentifierFilter, confirmationStatusFilter: ConfirmationStatusFilter? = nil, maxResults: Int? = nil, network: String, nextToken: String? = nil, sort: ListFilteredTransactionEventsSort? = nil, timeFilter: TimeFilter? = nil, voutFilter: VoutFilter? = nil) {
            self.addressIdentifierFilter = addressIdentifierFilter
            self.confirmationStatusFilter = confirmationStatusFilter
            self.maxResults = maxResults
            self.network = network
            self.nextToken = nextToken
            self.sort = sort
            self.timeFilter = timeFilter
            self.voutFilter = voutFilter
        }

        public func validate(name: String) throws {
            try self.addressIdentifierFilter.validate(name: "\(name).addressIdentifierFilter")
            try self.confirmationStatusFilter?.validate(name: "\(name).confirmationStatusFilter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
        }

        private enum CodingKeys: String, CodingKey {
            case addressIdentifierFilter = "addressIdentifierFilter"
            case confirmationStatusFilter = "confirmationStatusFilter"
            case maxResults = "maxResults"
            case network = "network"
            case nextToken = "nextToken"
            case sort = "sort"
            case timeFilter = "timeFilter"
            case voutFilter = "voutFilter"
        }
    }

    public struct ListFilteredTransactionEventsOutput: AWSDecodableShape {
        /// The transaction events returned by the request.
        public let events: [TransactionEvent]
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(events: [TransactionEvent], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListFilteredTransactionEventsSort: AWSEncodableShape {
        /// Container on how the results will be sorted by?
        public let sortBy: ListFilteredTransactionEventsSortBy?
        /// The container for the sort order for ListFilteredTransactionEvents.  The SortOrder field only accepts the values ASCENDING  and DESCENDING. Not providing SortOrder will default  to ASCENDING.
        public let sortOrder: SortOrder?

        public init(sortBy: ListFilteredTransactionEventsSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListTokenBalancesInput: AWSEncodableShape {
        /// The maximum number of token balances to return. Default: 100   Even if additional results can be retrieved, the request can return less  results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the  returned nextToken value. The value of nextToken is  null when there are no more results to return
        public let maxResults: Int?
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The contract or wallet address on the blockchain network by which to filter the  request. You must specify the address property of the ownerFilter  when listing balances of tokens owned by the address.
        public let ownerFilter: OwnerFilter?
        /// The contract address or a token identifier on the  blockchain network by which to filter the request. You must specify the contractAddress  property of this container when listing tokens minted by a contract.  You must always specify the network property of this  container when using this operation.
        public let tokenFilter: TokenFilter

        public init(maxResults: Int? = nil, nextToken: String? = nil, ownerFilter: OwnerFilter? = nil, tokenFilter: TokenFilter) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerFilter = ownerFilter
            self.tokenFilter = tokenFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
            try self.ownerFilter?.validate(name: "\(name).ownerFilter")
            try self.tokenFilter.validate(name: "\(name).tokenFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case ownerFilter = "ownerFilter"
            case tokenFilter = "tokenFilter"
        }
    }

    public struct ListTokenBalancesOutput: AWSDecodableShape {
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// An array of TokenBalance objects. Each object contains details about  the token balance.
        public let tokenBalances: [TokenBalance]

        public init(nextToken: String? = nil, tokenBalances: [TokenBalance]) {
            self.nextToken = nextToken
            self.tokenBalances = tokenBalances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tokenBalances = "tokenBalances"
        }
    }

    public struct ListTransactionEventsInput: AWSEncodableShape {
        /// The maximum number of transaction events to list. Default: 100   Even if additional results can be retrieved, the request can return less  results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the  returned nextToken value. The value of nextToken is  null when there are no more results to return
        public let maxResults: Int?
        /// The blockchain network where the transaction events occurred.
        public let network: QueryNetwork
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The hash of a transaction. It is generated when a transaction is created.
        public let transactionHash: String?
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.   transactionId is only supported on the Bitcoin networks.
        public let transactionId: String?

        public init(maxResults: Int? = nil, network: QueryNetwork, nextToken: String? = nil, transactionHash: String? = nil, transactionId: String? = nil) {
            self.maxResults = maxResults
            self.network = network
            self.nextToken = nextToken
            self.transactionHash = transactionHash
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
            try self.validate(self.transactionHash, name: "transactionHash", parent: name, pattern: "^(0x[A-Fa-f0-9]{64}|[A-Fa-f0-9]{64})$")
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^(0x[A-Fa-f0-9]{64}|[A-Fa-f0-9]{64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case network = "network"
            case nextToken = "nextToken"
            case transactionHash = "transactionHash"
            case transactionId = "transactionId"
        }
    }

    public struct ListTransactionEventsOutput: AWSDecodableShape {
        /// An array of TransactionEvent objects. Each object contains details  about the transaction events.
        public let events: [TransactionEvent]
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?

        public init(events: [TransactionEvent], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListTransactionsInput: AWSEncodableShape {
        /// The address (either a contract or wallet), whose transactions are being requested.
        public let address: String
        /// This filter is used to include transactions in the response that haven't reached  finality . Transactions that have reached finality are always  part of the response.
        public let confirmationStatusFilter: ConfirmationStatusFilter?
        public let fromBlockchainInstant: BlockchainInstant?
        /// The maximum number of transactions to list. Default: 100   Even if additional results can be retrieved, the request can return less  results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the  returned nextToken value. The value of nextToken is  null when there are no more results to return
        public let maxResults: Int?
        /// The blockchain network where the transactions occurred.
        public let network: QueryNetwork
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The order by which the results will be sorted.
        public let sort: ListTransactionsSort?
        public let toBlockchainInstant: BlockchainInstant?

        public init(address: String, confirmationStatusFilter: ConfirmationStatusFilter? = nil, fromBlockchainInstant: BlockchainInstant? = nil, maxResults: Int? = nil, network: QueryNetwork, nextToken: String? = nil, sort: ListTransactionsSort? = nil, toBlockchainInstant: BlockchainInstant? = nil) {
            self.address = address
            self.confirmationStatusFilter = confirmationStatusFilter
            self.fromBlockchainInstant = fromBlockchainInstant
            self.maxResults = maxResults
            self.network = network
            self.nextToken = nextToken
            self.sort = sort
            self.toBlockchainInstant = toBlockchainInstant
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
            try self.confirmationStatusFilter?.validate(name: "\(name).confirmationStatusFilter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
            case confirmationStatusFilter = "confirmationStatusFilter"
            case fromBlockchainInstant = "fromBlockchainInstant"
            case maxResults = "maxResults"
            case network = "network"
            case nextToken = "nextToken"
            case sort = "sort"
            case toBlockchainInstant = "toBlockchainInstant"
        }
    }

    public struct ListTransactionsOutput: AWSDecodableShape {
        /// The pagination token that indicates the next set of results to retrieve.
        public let nextToken: String?
        /// The array of transactions returned by the request.
        public let transactions: [TransactionOutputItem]

        public init(nextToken: String? = nil, transactions: [TransactionOutputItem]) {
            self.nextToken = nextToken
            self.transactions = transactions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case transactions = "transactions"
        }
    }

    public struct ListTransactionsSort: AWSEncodableShape {
        /// Defaults to the value TRANSACTION_TIMESTAMP.
        public let sortBy: ListTransactionsSortBy?
        /// The container for the sort order for ListTransactions.  The SortOrder field only accepts the values ASCENDING  and DESCENDING. Not providing SortOrder will default  to ASCENDING.
        public let sortOrder: SortOrder?

        public init(sortBy: ListTransactionsSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct OwnerFilter: AWSEncodableShape {
        /// The contract or wallet address.
        public let address: String

        public init(address: String) {
            self.address = address
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
        }
    }

    public struct OwnerIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The contract or wallet address for the owner.
        public let address: String

        public init(address: String) {
            self.address = address
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
        }
    }

    public struct TimeFilter: AWSEncodableShape {
        public let from: BlockchainInstant?
        public let to: BlockchainInstant?

        public init(from: BlockchainInstant? = nil, to: BlockchainInstant? = nil) {
            self.from = from
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "from"
            case to = "to"
        }
    }

    public struct TokenBalance: AWSDecodableShape {
        /// The time for when the TokenBalance is requested or  the current time if a time is not provided in the request.  This time will only be recorded up to the second.
        public let atBlockchainInstant: BlockchainInstant
        /// The container of the token balance.
        public let balance: String
        /// The Timestamp of the last transaction at which the balance for the token in the wallet was updated.
        public let lastUpdatedTime: BlockchainInstant?
        /// The container for the identifier of the owner.
        public let ownerIdentifier: OwnerIdentifier?
        /// The identifier for the token, including the unique token ID and its blockchain network.
        public let tokenIdentifier: TokenIdentifier?

        public init(atBlockchainInstant: BlockchainInstant, balance: String, lastUpdatedTime: BlockchainInstant? = nil, ownerIdentifier: OwnerIdentifier? = nil, tokenIdentifier: TokenIdentifier? = nil) {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case atBlockchainInstant = "atBlockchainInstant"
            case balance = "balance"
            case lastUpdatedTime = "lastUpdatedTime"
            case ownerIdentifier = "ownerIdentifier"
            case tokenIdentifier = "tokenIdentifier"
        }
    }

    public struct TokenFilter: AWSEncodableShape {
        /// This is the address of the contract.
        public let contractAddress: String?
        /// The blockchain network of the token.
        public let network: QueryNetwork
        /// The unique identifier of the token.
        public let tokenId: String?

        public init(contractAddress: String? = nil, network: QueryNetwork, tokenId: String? = nil) {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }

        public func validate(name: String) throws {
            try self.validate(self.contractAddress, name: "contractAddress", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
            try self.validate(self.tokenId, name: "tokenId", parent: name, pattern: "^[a-zA-Z0-9]{1,66}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contractAddress = "contractAddress"
            case network = "network"
            case tokenId = "tokenId"
        }
    }

    public struct TokenIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// This is the token's contract address.
        public let contractAddress: String?
        /// The blockchain network of the token.
        public let network: QueryNetwork
        /// The unique identifier of the token.  For native tokens, use the 3 character abbreviation that best matches your token.  For example, btc for Bitcoin, eth for Ether, etc. For all other token types you must  specify the tokenId in the 64 character hexadecimal tokenid format.
        public let tokenId: String?

        public init(contractAddress: String? = nil, network: QueryNetwork, tokenId: String? = nil) {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }

        public func validate(name: String) throws {
            try self.validate(self.contractAddress, name: "contractAddress", parent: name, pattern: "^[-A-Za-z0-9]{13,74}$")
            try self.validate(self.tokenId, name: "tokenId", parent: name, pattern: "^[a-zA-Z0-9]{1,66}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contractAddress = "contractAddress"
            case network = "network"
            case tokenId = "tokenId"
        }
    }

    public struct Transaction: AWSDecodableShape {
        /// The block hash is a unique identifier for a block. It is a fixed-size  string that is calculated by using the information in the block. The block  hash is used to verify the integrity of the data in the block.
        public let blockHash: String?
        /// The block number in which the transaction is recorded.
        public let blockNumber: String?
        /// Specifies whether the transaction has reached Finality.
        public let confirmationStatus: ConfirmationStatus?
        /// The blockchain address for the contract.
        public let contractAddress: String?
        /// The amount of gas used up to the specified point in the block.
        public let cumulativeGasUsed: String?
        /// The effective gas price.
        public let effectiveGasPrice: String?
        /// Identifies whether the transaction has succeeded or failed.
        public let executionStatus: ExecutionStatus?
        /// The initiator of the transaction. It is either in the form a public key or a  contract address.
        public let from: String?
        /// The amount of gas used for the transaction.
        public let gasUsed: String?
        /// The blockchain network where the transaction occurred.
        public let network: QueryNetwork
        /// The number of transactions in the block.
        public let numberOfTransactions: Int64
        /// The signature of the transaction. The X coordinate of a point R.
        public let signatureR: String?
        /// The signature of the transaction. The Y coordinate of a point S.
        public let signatureS: String?
        /// The signature of the transaction. The Z coordinate of a point V.
        public let signatureV: Int?
        /// The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public let to: String
        /// The transaction fee.
        public let transactionFee: String?
        /// The hash of a transaction. It is generated when a transaction is created.
        public let transactionHash: String
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.
        public let transactionId: String?
        /// The index of the transaction within a blockchain.
        public let transactionIndex: Int64
        /// The Timestamp of the transaction.
        public let transactionTimestamp: Date

        public init(blockHash: String? = nil, blockNumber: String? = nil, confirmationStatus: ConfirmationStatus? = nil, contractAddress: String? = nil, cumulativeGasUsed: String? = nil, effectiveGasPrice: String? = nil, executionStatus: ExecutionStatus? = nil, from: String? = nil, gasUsed: String? = nil, network: QueryNetwork, numberOfTransactions: Int64, signatureR: String? = nil, signatureS: String? = nil, signatureV: Int? = nil, to: String, transactionFee: String? = nil, transactionHash: String, transactionId: String? = nil, transactionIndex: Int64, transactionTimestamp: Date) {
            self.blockHash = blockHash
            self.blockNumber = blockNumber
            self.confirmationStatus = confirmationStatus
            self.contractAddress = contractAddress
            self.cumulativeGasUsed = cumulativeGasUsed
            self.effectiveGasPrice = effectiveGasPrice
            self.executionStatus = executionStatus
            self.from = from
            self.gasUsed = gasUsed
            self.network = network
            self.numberOfTransactions = numberOfTransactions
            self.signatureR = signatureR
            self.signatureS = signatureS
            self.signatureV = signatureV
            self.to = to
            self.transactionFee = transactionFee
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.transactionIndex = transactionIndex
            self.transactionTimestamp = transactionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case blockHash = "blockHash"
            case blockNumber = "blockNumber"
            case confirmationStatus = "confirmationStatus"
            case contractAddress = "contractAddress"
            case cumulativeGasUsed = "cumulativeGasUsed"
            case effectiveGasPrice = "effectiveGasPrice"
            case executionStatus = "executionStatus"
            case from = "from"
            case gasUsed = "gasUsed"
            case network = "network"
            case numberOfTransactions = "numberOfTransactions"
            case signatureR = "signatureR"
            case signatureS = "signatureS"
            case signatureV = "signatureV"
            case to = "to"
            case transactionFee = "transactionFee"
            case transactionHash = "transactionHash"
            case transactionId = "transactionId"
            case transactionIndex = "transactionIndex"
            case transactionTimestamp = "transactionTimestamp"
        }
    }

    public struct TransactionEvent: AWSDecodableShape {
        public let blockchainInstant: BlockchainInstant?
        /// This container specifies whether the transaction has reached Finality.
        public let confirmationStatus: ConfirmationStatus?
        /// The blockchain address for the contract
        public let contractAddress: String?
        /// The type of transaction event.
        public let eventType: QueryTransactionEventType
        /// The wallet address initiating the transaction. It can either be a public key or a contract.
        public let from: String?
        /// The blockchain network where the transaction occurred.
        public let network: QueryNetwork
        /// The position of the spent transaction output in the output list of the creating transaction.  This is only returned for BITCOIN_VIN event types.
        public let spentVoutIndex: Int?
        /// The transactionHash that created the spent transaction output.  This is only returned for BITCOIN_VIN event types.
        public let spentVoutTransactionHash: String?
        /// The transactionId that created the spent transaction output.  This is only returned for BITCOIN_VIN event types.
        public let spentVoutTransactionId: String?
        /// The wallet address receiving the transaction.  It can either be a public key or a contract.
        public let to: String?
        /// The unique identifier for the token involved in the transaction.
        public let tokenId: String?
        /// The hash of a transaction. It is generated when a transaction is created.
        public let transactionHash: String
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.
        public let transactionId: String?
        /// The value that was transacted.
        public let value: String?
        /// The position of the transaction output in the transaction output list.
        public let voutIndex: Int?
        /// Specifies if the transaction output is spent or unspent. This is only returned for BITCOIN_VOUT event types.  This is only returned for BITCOIN_VOUT event types.
        public let voutSpent: Bool?

        public init(blockchainInstant: BlockchainInstant? = nil, confirmationStatus: ConfirmationStatus? = nil, contractAddress: String? = nil, eventType: QueryTransactionEventType, from: String? = nil, network: QueryNetwork, spentVoutIndex: Int? = nil, spentVoutTransactionHash: String? = nil, spentVoutTransactionId: String? = nil, to: String? = nil, tokenId: String? = nil, transactionHash: String, transactionId: String? = nil, value: String? = nil, voutIndex: Int? = nil, voutSpent: Bool? = nil) {
            self.blockchainInstant = blockchainInstant
            self.confirmationStatus = confirmationStatus
            self.contractAddress = contractAddress
            self.eventType = eventType
            self.from = from
            self.network = network
            self.spentVoutIndex = spentVoutIndex
            self.spentVoutTransactionHash = spentVoutTransactionHash
            self.spentVoutTransactionId = spentVoutTransactionId
            self.to = to
            self.tokenId = tokenId
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.value = value
            self.voutIndex = voutIndex
            self.voutSpent = voutSpent
        }

        private enum CodingKeys: String, CodingKey {
            case blockchainInstant = "blockchainInstant"
            case confirmationStatus = "confirmationStatus"
            case contractAddress = "contractAddress"
            case eventType = "eventType"
            case from = "from"
            case network = "network"
            case spentVoutIndex = "spentVoutIndex"
            case spentVoutTransactionHash = "spentVoutTransactionHash"
            case spentVoutTransactionId = "spentVoutTransactionId"
            case to = "to"
            case tokenId = "tokenId"
            case transactionHash = "transactionHash"
            case transactionId = "transactionId"
            case value = "value"
            case voutIndex = "voutIndex"
            case voutSpent = "voutSpent"
        }
    }

    public struct TransactionOutputItem: AWSDecodableShape {
        /// Specifies whether to list transactions that have not reached Finality.
        public let confirmationStatus: ConfirmationStatus?
        /// The blockchain network where the transaction occurred.
        public let network: QueryNetwork
        /// The hash of a transaction. It is generated when a transaction is created.
        public let transactionHash: String
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.
        public let transactionId: String?
        /// The time when the transaction occurred.
        public let transactionTimestamp: Date

        public init(confirmationStatus: ConfirmationStatus? = nil, network: QueryNetwork, transactionHash: String, transactionId: String? = nil, transactionTimestamp: Date) {
            self.confirmationStatus = confirmationStatus
            self.network = network
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.transactionTimestamp = transactionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case confirmationStatus = "confirmationStatus"
            case network = "network"
            case transactionHash = "transactionHash"
            case transactionId = "transactionId"
            case transactionTimestamp = "transactionTimestamp"
        }
    }

    public struct VoutFilter: AWSEncodableShape {
        /// Specifies if the transaction output is spent or unspent.
        public let voutSpent: Bool

        public init(voutSpent: Bool) {
            self.voutSpent = voutSpent
        }

        private enum CodingKeys: String, CodingKey {
            case voutSpent = "voutSpent"
        }
    }
}

// MARK: - Errors

/// Error enum for ManagedBlockchainQuery
public struct ManagedBlockchainQueryErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ManagedBlockchainQuery
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The Amazon Web Services account doesn’t have access to this resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request processing has failed because of an internal error in the service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded for this resource.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request or operation couldn't be performed because a service is throttling  requests. The most common source of throttling errors is when you create resources  that exceed your service limit for this resource type. Request a limit increase or  delete unused resources, if possible.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The resource passed is invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension ManagedBlockchainQueryErrorType: Equatable {
    public static func == (lhs: ManagedBlockchainQueryErrorType, rhs: ManagedBlockchainQueryErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ManagedBlockchainQueryErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
