//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ApplicationSignals {
    // MARK: Enums

    public enum DurationUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        case hour = "HOUR"
        case minute = "MINUTE"
        case month = "MONTH"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case periodBased = "PeriodBased"
        case requestBased = "RequestBased"
        public var description: String { return self.rawValue }
    }

    public enum MetricSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudwatchMetric = "CloudWatchMetric"
        case serviceDependency = "ServiceDependency"
        case serviceOperation = "ServiceOperation"
        public var description: String { return self.rawValue }
    }

    public enum ServiceLevelIndicatorComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case greaterThan = "GreaterThan"
        case greaterThanOrEqualTo = "GreaterThanOrEqualTo"
        case lessThan = "LessThan"
        case lessThanOrEqualTo = "LessThanOrEqualTo"
        public var description: String { return self.rawValue }
    }

    public enum ServiceLevelIndicatorMetricType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case availability = "AVAILABILITY"
        case latency = "LATENCY"
        public var description: String { return self.rawValue }
    }

    public enum ServiceLevelObjectiveBudgetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case breached = "BREACHED"
        case insufficientData = "INSUFFICIENT_DATA"
        case ok = "OK"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum StandardUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bits = "Bits"
        case bitsSecond = "Bits/Second"
        case bytes = "Bytes"
        case bytesSecond = "Bytes/Second"
        case count = "Count"
        case countSecond = "Count/Second"
        case gigabits = "Gigabits"
        case gigabitsSecond = "Gigabits/Second"
        case gigabytes = "Gigabytes"
        case gigabytesSecond = "Gigabytes/Second"
        case kilobits = "Kilobits"
        case kilobitsSecond = "Kilobits/Second"
        case kilobytes = "Kilobytes"
        case kilobytesSecond = "Kilobytes/Second"
        case megabits = "Megabits"
        case megabitsSecond = "Megabits/Second"
        case megabytes = "Megabytes"
        case megabytesSecond = "Megabytes/Second"
        case microseconds = "Microseconds"
        case milliseconds = "Milliseconds"
        case none = "None"
        case percent = "Percent"
        case seconds = "Seconds"
        case terabits = "Terabits"
        case terabitsSecond = "Terabits/Second"
        case terabytes = "Terabytes"
        case terabytesSecond = "Terabytes/Second"
        public var description: String { return self.rawValue }
    }

    public enum Interval: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// If the interval is a calendar interval, this structure contains the interval specifications.
        case calendarInterval(CalendarInterval)
        /// If the interval is a rolling interval, this structure contains the interval specifications.
        case rollingInterval(RollingInterval)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .calendarInterval:
                let value = try container.decode(CalendarInterval.self, forKey: .calendarInterval)
                self = .calendarInterval(value)
            case .rollingInterval:
                let value = try container.decode(RollingInterval.self, forKey: .rollingInterval)
                self = .rollingInterval(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .calendarInterval(let value):
                try container.encode(value, forKey: .calendarInterval)
            case .rollingInterval(let value):
                try container.encode(value, forKey: .rollingInterval)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .calendarInterval(let value):
                try value.validate(name: "\(name).calendarInterval")
            case .rollingInterval(let value):
                try value.validate(name: "\(name).rollingInterval")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case calendarInterval = "CalendarInterval"
            case rollingInterval = "RollingInterval"
        }
    }

    public enum MonitoredRequestCountMetricDataQueries: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// If you want to count "bad requests" to determine the percentage of successful requests for this request-based SLO, specify the metric to use as "bad requests" in this structure.
        case badCountMetric([MetricDataQuery])
        /// If you want to count "good requests" to determine the percentage of successful requests for this request-based SLO, specify the metric to use as "good requests" in this structure.
        case goodCountMetric([MetricDataQuery])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .badCountMetric:
                let value = try container.decode([MetricDataQuery].self, forKey: .badCountMetric)
                self = .badCountMetric(value)
            case .goodCountMetric:
                let value = try container.decode([MetricDataQuery].self, forKey: .goodCountMetric)
                self = .goodCountMetric(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .badCountMetric(let value):
                try container.encode(value, forKey: .badCountMetric)
            case .goodCountMetric(let value):
                try container.encode(value, forKey: .goodCountMetric)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .badCountMetric(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).badCountMetric[]")
                }
            case .goodCountMetric(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).goodCountMetric[]")
                }
            }
        }

        private enum CodingKeys: String, CodingKey {
            case badCountMetric = "BadCountMetric"
            case goodCountMetric = "GoodCountMetric"
        }
    }

    // MARK: Shapes

    public struct BatchGetServiceLevelObjectiveBudgetReportInput: AWSEncodableShape {
        /// An array containing the IDs of the service level objectives that you want to include in the report.
        public let sloIds: [String]
        /// The date and time that you want the report to be for. It is expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.
        public let timestamp: Date

        @inlinable
        public init(sloIds: [String], timestamp: Date) {
            self.sloIds = sloIds
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.sloIds, name: "sloIds", parent: name, max: 50)
            try self.validate(self.sloIds, name: "sloIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sloIds = "SloIds"
            case timestamp = "Timestamp"
        }
    }

    public struct BatchGetServiceLevelObjectiveBudgetReportOutput: AWSDecodableShape {
        /// An array of structures, where each structure includes an error indicating that one  of the requests in the array was not valid.
        public let errors: [ServiceLevelObjectiveBudgetReportError]
        /// An array of structures, where each structure is one budget report.
        public let reports: [ServiceLevelObjectiveBudgetReport]
        /// The date and time that the report is for. It is expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.
        public let timestamp: Date

        @inlinable
        public init(errors: [ServiceLevelObjectiveBudgetReportError], reports: [ServiceLevelObjectiveBudgetReport], timestamp: Date) {
            self.errors = errors
            self.reports = reports
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case reports = "Reports"
            case timestamp = "Timestamp"
        }
    }

    public struct BatchUpdateExclusionWindowsError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String
        /// The error message.
        public let errorMessage: String
        /// The SLO ID in the error.
        public let sloId: String

        @inlinable
        public init(errorCode: String, errorMessage: String, sloId: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.sloId = sloId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case sloId = "SloId"
        }
    }

    public struct BatchUpdateExclusionWindowsInput: AWSEncodableShape {
        /// A list of exclusion windows to add to the specified SLOs. You can add up to 10 exclusion windows per SLO.
        public let addExclusionWindows: [ExclusionWindow]?
        /// A list of exclusion windows to remove from the specified SLOs. The window configuration must match an existing exclusion window.
        public let removeExclusionWindows: [ExclusionWindow]?
        /// The list of SLO IDs to add or remove exclusion windows from.
        public let sloIds: [String]

        @inlinable
        public init(addExclusionWindows: [ExclusionWindow]? = nil, removeExclusionWindows: [ExclusionWindow]? = nil, sloIds: [String]) {
            self.addExclusionWindows = addExclusionWindows
            self.removeExclusionWindows = removeExclusionWindows
            self.sloIds = sloIds
        }

        public func validate(name: String) throws {
            try self.addExclusionWindows?.forEach {
                try $0.validate(name: "\(name).addExclusionWindows[]")
            }
            try self.validate(self.addExclusionWindows, name: "addExclusionWindows", parent: name, max: 10)
            try self.removeExclusionWindows?.forEach {
                try $0.validate(name: "\(name).removeExclusionWindows[]")
            }
            try self.validate(self.removeExclusionWindows, name: "removeExclusionWindows", parent: name, max: 10)
            try self.validate(self.sloIds, name: "sloIds", parent: name, max: 50)
            try self.validate(self.sloIds, name: "sloIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addExclusionWindows = "AddExclusionWindows"
            case removeExclusionWindows = "RemoveExclusionWindows"
            case sloIds = "SloIds"
        }
    }

    public struct BatchUpdateExclusionWindowsOutput: AWSDecodableShape {
        /// A list of errors that occurred while processing the request.
        public let errors: [BatchUpdateExclusionWindowsError]
        /// The list of SLO IDs that were successfully processed.
        public let sloIds: [String]

        @inlinable
        public init(errors: [BatchUpdateExclusionWindowsError], sloIds: [String]) {
            self.errors = errors
            self.sloIds = sloIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case sloIds = "SloIds"
        }
    }

    public struct BurnRateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of minutes to use as the look-back window.
        public let lookBackWindowMinutes: Int

        @inlinable
        public init(lookBackWindowMinutes: Int) {
            self.lookBackWindowMinutes = lookBackWindowMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.lookBackWindowMinutes, name: "lookBackWindowMinutes", parent: name, max: 10080)
            try self.validate(self.lookBackWindowMinutes, name: "lookBackWindowMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case lookBackWindowMinutes = "LookBackWindowMinutes"
        }
    }

    public struct CalendarInterval: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the duration of each calendar interval. For example, if Duration is 1 and DurationUnit is MONTH, each interval is one month, aligned with the calendar.
        public let duration: Int
        /// Specifies the calendar interval unit.
        public let durationUnit: DurationUnit
        /// The date and time when you want the first interval to start. Be sure to choose a time that configures the  intervals the way that you want. For example, if you want weekly intervals starting on Mondays at 6 a.m., be sure to specify a start time that is a Monday at 6 a.m. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  As soon as one calendar interval ends, another automatically begins.
        public let startTime: Date

        @inlinable
        public init(duration: Int, durationUnit: DurationUnit, startTime: Date) {
            self.duration = duration
            self.durationUnit = durationUnit
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case durationUnit = "DurationUnit"
            case startTime = "StartTime"
        }
    }

    public struct CreateServiceLevelObjectiveInput: AWSEncodableShape {
        /// Use this array to create burn rates for this SLO. Each  burn rate is a metric that indicates how fast the service is consuming the error budget, relative to the attainment goal of the SLO.
        public let burnRateConfigurations: [BurnRateConfiguration]?
        /// An optional description for this SLO.
        public let description: String?
        /// This structure contains the attributes that determine the goal of the SLO.
        public let goal: Goal?
        /// A name for this SLO.
        public let name: String
        /// If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both RequestBasedSliConfig and SliConfig in the same operation.
        public let requestBasedSliConfig: RequestBasedServiceLevelIndicatorConfig?
        /// If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both RequestBasedSliConfig and SliConfig in the same operation.
        public let sliConfig: ServiceLevelIndicatorConfig?
        /// A list of key-value pairs to associate with the SLO. You can associate as many as 50 tags with an SLO. To be able to associate tags with the SLO when you create the SLO, you must have the cloudwatch:TagResource permission. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values.
        public let tags: [Tag]?

        @inlinable
        public init(burnRateConfigurations: [BurnRateConfiguration]? = nil, description: String? = nil, goal: Goal? = nil, name: String, requestBasedSliConfig: RequestBasedServiceLevelIndicatorConfig? = nil, sliConfig: ServiceLevelIndicatorConfig? = nil, tags: [Tag]? = nil) {
            self.burnRateConfigurations = burnRateConfigurations
            self.description = description
            self.goal = goal
            self.name = name
            self.requestBasedSliConfig = requestBasedSliConfig
            self.sliConfig = sliConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.burnRateConfigurations?.forEach {
                try $0.validate(name: "\(name).burnRateConfigurations[]")
            }
            try self.validate(self.burnRateConfigurations, name: "burnRateConfigurations", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.goal?.validate(name: "\(name).goal")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$")
            try self.requestBasedSliConfig?.validate(name: "\(name).requestBasedSliConfig")
            try self.sliConfig?.validate(name: "\(name).sliConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case burnRateConfigurations = "BurnRateConfigurations"
            case description = "Description"
            case goal = "Goal"
            case name = "Name"
            case requestBasedSliConfig = "RequestBasedSliConfig"
            case sliConfig = "SliConfig"
            case tags = "Tags"
        }
    }

    public struct CreateServiceLevelObjectiveOutput: AWSDecodableShape {
        /// A structure that contains information about the SLO that you just created.
        public let slo: ServiceLevelObjective

        @inlinable
        public init(slo: ServiceLevelObjective) {
            self.slo = slo
        }

        private enum CodingKeys: String, CodingKey {
            case slo = "Slo"
        }
    }

    public struct DeleteServiceLevelObjectiveInput: AWSEncodableShape {
        /// The ARN or name of the service level objective to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$|^arn:aws:application-signals:[^:]*:[^:]*:slo/[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceLevelObjectiveOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DependencyConfig: AWSEncodableShape & AWSDecodableShape {
        /// This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let dependencyKeyAttributes: [String: String]
        /// The name of the called operation in the dependency.
        public let dependencyOperationName: String

        @inlinable
        public init(dependencyKeyAttributes: [String: String], dependencyOperationName: String) {
            self.dependencyKeyAttributes = dependencyKeyAttributes
            self.dependencyOperationName = dependencyOperationName
        }

        public func validate(name: String) throws {
            try self.dependencyKeyAttributes.forEach {
                try validate($0.key, name: "dependencyKeyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "dependencyKeyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "dependencyKeyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "dependencyKeyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.dependencyKeyAttributes, name: "dependencyKeyAttributes", parent: name, max: 4)
            try self.validate(self.dependencyKeyAttributes, name: "dependencyKeyAttributes", parent: name, min: 1)
            try self.validate(self.dependencyOperationName, name: "dependencyOperationName", parent: name, max: 255)
            try self.validate(self.dependencyOperationName, name: "dependencyOperationName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyKeyAttributes = "DependencyKeyAttributes"
            case dependencyOperationName = "DependencyOperationName"
        }
    }

    public struct Dimension: AWSEncodableShape & AWSDecodableShape {
        /// The name of the dimension. Dimension names must contain only ASCII characters, must include  at least one non-whitespace character, and cannot start with a colon (:). ASCII control characters are not supported as part of dimension names.
        public let name: String
        /// The value of the dimension. Dimension values must contain only ASCII characters and must include  at least one non-whitespace character. ASCII control characters are not supported as part of dimension values.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct ExclusionWindow: AWSEncodableShape & AWSDecodableShape {
        /// A description explaining why this time period should be excluded from SLO calculations.
        public let reason: String?
        /// The recurrence rule for the SLO time window exclusion. Supports both cron and rate expressions.
        public let recurrenceRule: RecurrenceRule?
        /// The start of the SLO time window exclusion. Defaults to current time if not specified.
        public let startTime: Date?
        /// The SLO time window exclusion .
        public let window: Window

        @inlinable
        public init(reason: String? = nil, recurrenceRule: RecurrenceRule? = nil, startTime: Date? = nil, window: Window) {
            self.reason = reason
            self.recurrenceRule = recurrenceRule
            self.startTime = startTime
            self.window = window
        }

        public func validate(name: String) throws {
            try self.validate(self.reason, name: "reason", parent: name, max: 1024)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
            try self.recurrenceRule?.validate(name: "\(name).recurrenceRule")
            try self.window.validate(name: "\(name).window")
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "Reason"
            case recurrenceRule = "RecurrenceRule"
            case startTime = "StartTime"
            case window = "Window"
        }
    }

    public struct GetServiceInput: AWSEncodableShape {
        /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let endTime: Date
        /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]
        /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, keyAttributes: [String: String], startTime: Date) {
            self.endTime = endTime
            self.keyAttributes = keyAttributes
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "EndTime")
            try container.encode(self.keyAttributes, forKey: .keyAttributes)
            request.encodeQuery(self.startTime, key: "StartTime")
        }

        public func validate(name: String) throws {
            try self.keyAttributes.forEach {
                try validate($0.key, name: "keyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, max: 4)
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case keyAttributes = "KeyAttributes"
        }
    }

    public struct GetServiceLevelObjectiveInput: AWSEncodableShape {
        /// The ARN or name of the SLO that you want to retrieve information about. You can find the ARNs  of SLOs by using the ListServiceLevelObjectives operation.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$|^arn:aws:application-signals:[^:]*:[^:]*:slo/[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceLevelObjectiveOutput: AWSDecodableShape {
        /// A structure containing the information about the SLO.
        public let slo: ServiceLevelObjective

        @inlinable
        public init(slo: ServiceLevelObjective) {
            self.slo = slo
        }

        private enum CodingKeys: String, CodingKey {
            case slo = "Slo"
        }
    }

    public struct GetServiceOutput: AWSDecodableShape {
        /// The end time of the data included in the response. In a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057. This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let endTime: Date
        /// An array of string-to-string maps that each contain information about one log group associated with this service. Each  string-to-string map includes the following fields:    "Type": "AWS::Resource"     "ResourceType": "AWS::Logs::LogGroup"     "Identifier": "name-of-log-group"
        public let logGroupReferences: [[String: String]]?
        /// A structure containing information about the service.
        public let service: Service
        /// The start time of the data included in the response. In a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057. This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, logGroupReferences: [[String: String]]? = nil, service: Service, startTime: Date) {
            self.endTime = endTime
            self.logGroupReferences = logGroupReferences
            self.service = service
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case logGroupReferences = "LogGroupReferences"
            case service = "Service"
            case startTime = "StartTime"
        }
    }

    public struct Goal: AWSEncodableShape & AWSDecodableShape {
        /// The threshold that determines if the goal is being met. If this is a period-based SLO, the attainment goal is the  percentage of good periods that meet the threshold requirements to the total periods within the interval.  For example, an attainment goal of 99.9% means that within your interval, you are targeting 99.9% of the  periods to be in healthy state. If this is a request-based SLO, the attainment goal is the percentage of requests that must be  successful to meet the attainment goal. If you omit this parameter, 99 is used to represent 99% as the attainment goal.
        public let attainmentGoal: Double?
        /// The time period used to evaluate the SLO. It can be either a calendar interval or rolling interval. If you omit this parameter, a rolling interval of 7 days is used.
        public let interval: Interval?
        /// The percentage of remaining budget over total budget that you want to get warnings for.  If you omit this parameter, the default of 50.0 is used.
        public let warningThreshold: Double?

        @inlinable
        public init(attainmentGoal: Double? = nil, interval: Interval? = nil, warningThreshold: Double? = nil) {
            self.attainmentGoal = attainmentGoal
            self.interval = interval
            self.warningThreshold = warningThreshold
        }

        public func validate(name: String) throws {
            try self.interval?.validate(name: "\(name).interval")
        }

        private enum CodingKeys: String, CodingKey {
            case attainmentGoal = "AttainmentGoal"
            case interval = "Interval"
            case warningThreshold = "WarningThreshold"
        }
    }

    public struct ListServiceDependenciesInput: AWSEncodableShape {
        /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested end time will be rounded to the nearest hour.
        public let endTime: Date
        /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]
        /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
        public let maxResults: Int?
        /// Include this value, if it was returned by the previous operation, to get the next set of service dependencies.
        public let nextToken: String?
        /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, keyAttributes: [String: String], maxResults: Int? = nil, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.keyAttributes = keyAttributes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "EndTime")
            try container.encode(self.keyAttributes, forKey: .keyAttributes)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.startTime, key: "StartTime")
        }

        public func validate(name: String) throws {
            try self.keyAttributes.forEach {
                try validate($0.key, name: "keyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, max: 4)
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case keyAttributes = "KeyAttributes"
        }
    }

    public struct ListServiceDependenciesOutput: AWSDecodableShape {
        /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let endTime: Date
        /// Include this value in your next use of this API to get next set  of service dependencies.
        public let nextToken: String?
        /// An array, where each object in the array contains information about one of the dependencies of this service.
        public let serviceDependencies: [ServiceDependency]
        /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, nextToken: String? = nil, serviceDependencies: [ServiceDependency], startTime: Date) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.serviceDependencies = serviceDependencies
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case serviceDependencies = "ServiceDependencies"
            case startTime = "StartTime"
        }
    }

    public struct ListServiceDependentsInput: AWSEncodableShape {
        /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let endTime: Date
        /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]
        /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
        public let maxResults: Int?
        /// Include this value, if it was returned by the previous operation, to get the next set of service dependents.
        public let nextToken: String?
        /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, keyAttributes: [String: String], maxResults: Int? = nil, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.keyAttributes = keyAttributes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "EndTime")
            try container.encode(self.keyAttributes, forKey: .keyAttributes)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.startTime, key: "StartTime")
        }

        public func validate(name: String) throws {
            try self.keyAttributes.forEach {
                try validate($0.key, name: "keyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, max: 4)
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case keyAttributes = "KeyAttributes"
        }
    }

    public struct ListServiceDependentsOutput: AWSDecodableShape {
        /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let endTime: Date
        /// Include this value in your next use of this API to get next set  of service dependents.
        public let nextToken: String?
        /// An array, where each object in the array contains information about one of the dependents of this service.
        public let serviceDependents: [ServiceDependent]
        /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, nextToken: String? = nil, serviceDependents: [ServiceDependent], startTime: Date) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.serviceDependents = serviceDependents
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case serviceDependents = "ServiceDependents"
            case startTime = "StartTime"
        }
    }

    public struct ListServiceLevelObjectiveExclusionWindowsInput: AWSEncodableShape {
        /// The ID of the SLO to list exclusion windows for.
        public let id: String
        /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
        public let maxResults: Int?
        /// Include this value, if it was returned by the previous operation, to get the next set of service level objectives.
        public let nextToken: String?

        @inlinable
        public init(id: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.id = id
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$|^arn:aws:application-signals:[^:]*:[^:]*:slo/[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceLevelObjectiveExclusionWindowsOutput: AWSDecodableShape {
        /// A list of exclusion windows configured for the SLO.
        public let exclusionWindows: [ExclusionWindow]
        /// Include this value, if it was returned by the previous operation, to get the next set of service level objectives.
        public let nextToken: String?

        @inlinable
        public init(exclusionWindows: [ExclusionWindow], nextToken: String? = nil) {
            self.exclusionWindows = exclusionWindows
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exclusionWindows = "ExclusionWindows"
            case nextToken = "NextToken"
        }
    }

    public struct ListServiceLevelObjectivesInput: AWSEncodableShape {
        /// Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
        public let dependencyConfig: DependencyConfig?
        /// If you are using this operation in a monitoring account, specify true to include SLO from source accounts in the returned data.   When you are monitoring an account, you can use Amazon Web Services account ID in KeyAttribute filter for service source account and SloOwnerawsaccountID for SLO source account with IncludeLinkedAccounts to filter the returned data to only a single source account.
        public let includeLinkedAccounts: Bool?
        /// You can use this optional field to specify which services you want to retrieve SLO information for. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]?
        /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
        public let maxResults: Int?
        /// Use this optional field to only include SLOs with the specified metric source types in the output. Supported types are:   Service operation   Service dependency   CloudWatch metric
        public let metricSourceTypes: [MetricSourceType]?
        /// Include this value, if it was returned by the previous operation, to get the next set of service level objectives.
        public let nextToken: String?
        /// The name of the operation that this SLO is associated with.
        public let operationName: String?
        /// SLO's Amazon Web Services account ID.
        public let sloOwnerAwsAccountId: String?

        @inlinable
        public init(dependencyConfig: DependencyConfig? = nil, includeLinkedAccounts: Bool? = nil, keyAttributes: [String: String]? = nil, maxResults: Int? = nil, metricSourceTypes: [MetricSourceType]? = nil, nextToken: String? = nil, operationName: String? = nil, sloOwnerAwsAccountId: String? = nil) {
            self.dependencyConfig = dependencyConfig
            self.includeLinkedAccounts = includeLinkedAccounts
            self.keyAttributes = keyAttributes
            self.maxResults = maxResults
            self.metricSourceTypes = metricSourceTypes
            self.nextToken = nextToken
            self.operationName = operationName
            self.sloOwnerAwsAccountId = sloOwnerAwsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.dependencyConfig, forKey: .dependencyConfig)
            request.encodeQuery(self.includeLinkedAccounts, key: "IncludeLinkedAccounts")
            try container.encodeIfPresent(self.keyAttributes, forKey: .keyAttributes)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            try container.encodeIfPresent(self.metricSourceTypes, forKey: .metricSourceTypes)
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.operationName, key: "OperationName")
            request.encodeQuery(self.sloOwnerAwsAccountId, key: "SloOwnerAwsAccountId")
        }

        public func validate(name: String) throws {
            try self.dependencyConfig?.validate(name: "\(name).dependencyConfig")
            try self.keyAttributes?.forEach {
                try validate($0.key, name: "keyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, max: 4)
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.metricSourceTypes, name: "metricSourceTypes", parent: name, max: 3)
            try self.validate(self.metricSourceTypes, name: "metricSourceTypes", parent: name, min: 1)
            try self.validate(self.operationName, name: "operationName", parent: name, max: 255)
            try self.validate(self.operationName, name: "operationName", parent: name, min: 1)
            try self.validate(self.sloOwnerAwsAccountId, name: "sloOwnerAwsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyConfig = "DependencyConfig"
            case keyAttributes = "KeyAttributes"
            case metricSourceTypes = "MetricSourceTypes"
        }
    }

    public struct ListServiceLevelObjectivesOutput: AWSDecodableShape {
        /// Include this value in your next use of this API to get next set  of service level objectives.
        public let nextToken: String?
        /// An array of structures, where each structure contains information about one SLO.
        public let sloSummaries: [ServiceLevelObjectiveSummary]?

        @inlinable
        public init(nextToken: String? = nil, sloSummaries: [ServiceLevelObjectiveSummary]? = nil) {
            self.nextToken = nextToken
            self.sloSummaries = sloSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sloSummaries = "SloSummaries"
        }
    }

    public struct ListServiceOperationsInput: AWSEncodableShape {
        /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested end time will be rounded to the nearest hour.
        public let endTime: Date
        /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]
        /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
        public let maxResults: Int?
        /// Include this value, if it was returned by the previous operation, to get the next set of service operations.
        public let nextToken: String?
        /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, keyAttributes: [String: String], maxResults: Int? = nil, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.keyAttributes = keyAttributes
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "EndTime")
            try container.encode(self.keyAttributes, forKey: .keyAttributes)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.startTime, key: "StartTime")
        }

        public func validate(name: String) throws {
            try self.keyAttributes.forEach {
                try validate($0.key, name: "keyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, max: 4)
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case keyAttributes = "KeyAttributes"
        }
    }

    public struct ListServiceOperationsOutput: AWSDecodableShape {
        /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let endTime: Date
        /// Include this value in your next use of this API to get next set  of service operations.
        public let nextToken: String?
        /// An array of structures that each contain information about one operation of this service.
        public let serviceOperations: [ServiceOperation]
        /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, nextToken: String? = nil, serviceOperations: [ServiceOperation], startTime: Date) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.serviceOperations = serviceOperations
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case serviceOperations = "ServiceOperations"
            case startTime = "StartTime"
        }
    }

    public struct ListServicesInput: AWSEncodableShape {
        /// Amazon Web Services Account ID.
        public let awsAccountId: String?
        /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let endTime: Date
        /// If you are using this operation in a monitoring account, specify true to include services from source accounts in the returned data.
        public let includeLinkedAccounts: Bool?
        ///  The maximum number  of results  to return  in one operation.  If you omit this parameter,  the default of 50 is used.
        public let maxResults: Int?
        /// Include this value, if it was returned by the previous operation, to get the next set of services.
        public let nextToken: String?
        /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(awsAccountId: String? = nil, endTime: Date, includeLinkedAccounts: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date) {
            self.awsAccountId = awsAccountId
            self.endTime = endTime
            self.includeLinkedAccounts = includeLinkedAccounts
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.endTime, key: "EndTime")
            request.encodeQuery(self.includeLinkedAccounts, key: "IncludeLinkedAccounts")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.startTime, key: "StartTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServicesOutput: AWSDecodableShape {
        /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let endTime: Date
        /// Include this value in your next use of this API to get next set  of services.
        public let nextToken: String?
        /// An array of structures, where each structure contains some information about a service. To get complete information about a service, use  GetService.
        public let serviceSummaries: [ServiceSummary]
        /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  This displays the time that Application Signals used for the request. It might not match your request exactly, because  it was rounded to the nearest hour.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, nextToken: String? = nil, serviceSummaries: [ServiceSummary], startTime: Date) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.serviceSummaries = serviceSummaries
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case serviceSummaries = "ServiceSummaries"
            case startTime = "StartTime"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the CloudWatch resource that you want to view tags for. The ARN format of an Application Signals SLO is  arn:aws:cloudwatch:Region:account-id:slo:slo-name   For more information about ARN format, see  Resource Types Defined by Amazon CloudWatch in the Amazon Web Services General Reference.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tag keys and values associated with the resource you specified.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {
        /// An array of one or more dimensions to use to define the metric that you want to use.  For more information, see  Dimensions.
        public let dimensions: [Dimension]?
        /// The name of the metric to use.
        public let metricName: String?
        /// The namespace of the metric. For more information, see  Namespaces.
        public let namespace: String?

        @inlinable
        public init(dimensions: [Dimension]? = nil, metricName: String? = nil, namespace: String? = nil) {
            self.dimensions = dimensions
            self.metricName = metricName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.validate(self.dimensions, name: "dimensions", parent: name, max: 30)
            try self.validate(self.metricName, name: "metricName", parent: name, max: 255)
            try self.validate(self.metricName, name: "metricName", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[^:].*")
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case metricName = "MetricName"
            case namespace = "Namespace"
        }
    }

    public struct MetricDataQuery: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the account where this metric is located.  If you are performing this operation in a monitoring account,  use this to specify which source account to retrieve this metric from.
        public let accountId: String?
        /// This field can contain a metric math expression to be performed on the other metrics that you are retrieving within this MetricDataQueries structure.  A math expression can use the Id of the other metrics or queries to refer to those metrics, and can also use  the Id of other  expressions to use the result of those expressions. For more information about metric math expressions, see  Metric Math Syntax and Functions in the Amazon CloudWatch User Guide. Within each MetricDataQuery object, you must specify either  Expression or MetricStat but not both.
        public let expression: String?
        /// A short name used to tie this object to the results in the response. This Id must be unique  within a MetricDataQueries array. If you are performing math expressions on this set of data,  this name represents that data and can serve as a variable in the metric math expression. The valid characters  are letters, numbers, and underscore. The first character must be a lowercase letter.
        public let id: String
        /// A human-readable label for this metric or expression. This is especially useful  if this is an expression, so that you know what the value represents. If the metric or expression is shown in a  CloudWatch dashboard widget, the label is shown. If Label is omitted, CloudWatch  generates a default. You can put dynamic expressions into a label, so that it is more descriptive.  For more information, see Using Dynamic Labels.
        public let label: String?
        /// A metric to be used directly for the SLO, or to be used in the math expression that will be used for the SLO. Within one MetricDataQuery object, you must specify either  Expression or MetricStat but not both.
        public let metricStat: MetricStat?
        /// The granularity, in seconds, of the returned data points for this metric. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a PutMetricData call that includes a StorageResolution of 1 second. If the StartTime parameter specifies a time stamp that is greater than 3 hours ago, you must specify the period as follows or no data points in that time range is returned:   Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).   Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).   Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).
        public let period: Int?
        /// Use this only if you are using a metric math expression for the SLO.  Specify true for ReturnData for only the one expression result to use as the alarm. For all  other metrics and expressions in the same CreateServiceLevelObjective operation, specify ReturnData as false.
        public let returnData: Bool?

        @inlinable
        public init(accountId: String? = nil, expression: String? = nil, id: String, label: String? = nil, metricStat: MetricStat? = nil, period: Int? = nil, returnData: Bool? = nil) {
            self.accountId = accountId
            self.expression = expression
            self.id = id
            self.label = label
            self.metricStat = metricStat
            self.period = period
            self.returnData = returnData
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 255)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.metricStat?.validate(name: "\(name).metricStat")
            try self.validate(self.period, name: "period", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case expression = "Expression"
            case id = "Id"
            case label = "Label"
            case metricStat = "MetricStat"
            case period = "Period"
            case returnData = "ReturnData"
        }
    }

    public struct MetricReference: AWSDecodableShape {
        /// Amazon Web Services account ID.
        public let accountId: String?
        /// An array of one or more dimensions that further define the metric.  For more information, see  CloudWatchDimensions.
        public let dimensions: [Dimension]?
        /// The name of the metric.
        public let metricName: String
        /// Used to display the appropriate statistics in the CloudWatch console.
        public let metricType: String
        /// The namespace of the metric. For more information, see  CloudWatchNamespaces.
        public let namespace: String

        @inlinable
        public init(accountId: String? = nil, dimensions: [Dimension]? = nil, metricName: String, metricType: String, namespace: String) {
            self.accountId = accountId
            self.dimensions = dimensions
            self.metricName = metricName
            self.metricType = metricType
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case dimensions = "Dimensions"
            case metricName = "MetricName"
            case metricType = "MetricType"
            case namespace = "Namespace"
        }
    }

    public struct MetricStat: AWSEncodableShape & AWSDecodableShape {
        /// The metric to use as the service level indicator, including the metric name, namespace, and dimensions.
        public let metric: Metric
        /// The granularity, in seconds, to be used for the metric. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a PutMetricData call that includes a StorageResolution of 1 second.
        public let period: Int
        /// The statistic to use for comparison to the threshold. It can be any CloudWatch statistic or extended statistic. For more information about statistics,  see CloudWatch statistics definitions.
        public let stat: String
        /// If you omit Unit then all data that was collected with any unit is returned, along with the corresponding units that were specified when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified. If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.
        public let unit: StandardUnit?

        @inlinable
        public init(metric: Metric, period: Int, stat: String, unit: StandardUnit? = nil) {
            self.metric = metric
            self.period = period
            self.stat = stat
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.metric.validate(name: "\(name).metric")
            try self.validate(self.period, name: "period", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case period = "Period"
            case stat = "Stat"
            case unit = "Unit"
        }
    }

    public struct RecurrenceRule: AWSEncodableShape & AWSDecodableShape {
        /// A cron or rate expression that specifies the schedule for the exclusion window.
        public let expression: String

        @inlinable
        public init(expression: String) {
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
        }
    }

    public struct RequestBasedServiceLevelIndicator: AWSDecodableShape {
        /// The arithmetic operation used when comparing the specified metric to the threshold.
        public let comparisonOperator: ServiceLevelIndicatorComparisonOperator?
        /// This value is the threshold that  the observed metric values of the SLI metric are compared to.
        public let metricThreshold: Double?
        /// A structure that contains information about the metric that the SLO monitors.
        public let requestBasedSliMetric: RequestBasedServiceLevelIndicatorMetric

        @inlinable
        public init(comparisonOperator: ServiceLevelIndicatorComparisonOperator? = nil, metricThreshold: Double? = nil, requestBasedSliMetric: RequestBasedServiceLevelIndicatorMetric) {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.requestBasedSliMetric = requestBasedSliMetric
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case metricThreshold = "MetricThreshold"
            case requestBasedSliMetric = "RequestBasedSliMetric"
        }
    }

    public struct RequestBasedServiceLevelIndicatorConfig: AWSEncodableShape {
        /// The arithmetic operation to use when comparing the specified metric to the threshold. This parameter is required if this SLO is tracking the Latency metric.
        public let comparisonOperator: ServiceLevelIndicatorComparisonOperator?
        /// The value that the SLI metric is compared to. This parameter is required if this SLO is tracking the Latency metric.
        public let metricThreshold: Double?
        /// Use this structure to specify the metric to be used for the SLO.
        public let requestBasedSliMetricConfig: RequestBasedServiceLevelIndicatorMetricConfig

        @inlinable
        public init(comparisonOperator: ServiceLevelIndicatorComparisonOperator? = nil, metricThreshold: Double? = nil, requestBasedSliMetricConfig: RequestBasedServiceLevelIndicatorMetricConfig) {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.requestBasedSliMetricConfig = requestBasedSliMetricConfig
        }

        public func validate(name: String) throws {
            try self.requestBasedSliMetricConfig.validate(name: "\(name).requestBasedSliMetricConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case metricThreshold = "MetricThreshold"
            case requestBasedSliMetricConfig = "RequestBasedSliMetricConfig"
        }
    }

    public struct RequestBasedServiceLevelIndicatorMetric: AWSDecodableShape {
        /// Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
        public let dependencyConfig: DependencyConfig?
        /// This is a string-to-string map that contains information about the type of object that this SLO is related to. It can  include the following fields.    Type designates the type of object that this SLO is related to.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]?
        /// If the SLO monitors either the LATENCY or AVAILABILITY metric that Application Signals  collects, this field displays which of those metrics is used.
        public let metricType: ServiceLevelIndicatorMetricType?
        /// This structure defines the metric that is used as the "good request" or "bad request" value for a request-based SLO.  This value observed for the metric defined in   TotalRequestCountMetric is divided by the number found for  MonitoredRequestCountMetric to determine the percentage of successful requests that  this SLO tracks.
        public let monitoredRequestCountMetric: MonitoredRequestCountMetricDataQueries
        /// If the SLO monitors a specific operation of the service, this field displays that operation name.
        public let operationName: String?
        /// This structure defines the metric that is used as the "total requests" number for a request-based SLO.  The number observed for this metric is divided by the number of "good requests" or "bad requests" that is  observed for the metric defined in  MonitoredRequestCountMetric.
        public let totalRequestCountMetric: [MetricDataQuery]

        @inlinable
        public init(dependencyConfig: DependencyConfig? = nil, keyAttributes: [String: String]? = nil, metricType: ServiceLevelIndicatorMetricType? = nil, monitoredRequestCountMetric: MonitoredRequestCountMetricDataQueries, operationName: String? = nil, totalRequestCountMetric: [MetricDataQuery]) {
            self.dependencyConfig = dependencyConfig
            self.keyAttributes = keyAttributes
            self.metricType = metricType
            self.monitoredRequestCountMetric = monitoredRequestCountMetric
            self.operationName = operationName
            self.totalRequestCountMetric = totalRequestCountMetric
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyConfig = "DependencyConfig"
            case keyAttributes = "KeyAttributes"
            case metricType = "MetricType"
            case monitoredRequestCountMetric = "MonitoredRequestCountMetric"
            case operationName = "OperationName"
            case totalRequestCountMetric = "TotalRequestCountMetric"
        }
    }

    public struct RequestBasedServiceLevelIndicatorMetricConfig: AWSEncodableShape {
        /// Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
        public let dependencyConfig: DependencyConfig?
        /// If this SLO is related to a metric collected by Application Signals, you must use this field to specify which service  the SLO metric is related to. To do so, you must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]?
        /// If the SLO is to monitor either the LATENCY or AVAILABILITY metric that Application Signals  collects, use this field to specify which of those metrics is used.
        public let metricType: ServiceLevelIndicatorMetricType?
        /// Use this structure to define the metric that you want to use as the "good request" or "bad request" value for a request-based SLO.  This value observed for the metric defined in   TotalRequestCountMetric will be divided by the number found for  MonitoredRequestCountMetric to determine the percentage of successful requests that  this SLO tracks.
        public let monitoredRequestCountMetric: MonitoredRequestCountMetricDataQueries?
        /// If the SLO is to monitor a specific operation of the service, use this field to specify the name of that operation.
        public let operationName: String?
        /// Use this structure to define the metric that you want to use as the "total requests" number for a request-based SLO.  This result will be divided by the "good request" or "bad request" value defined in   MonitoredRequestCountMetric.
        public let totalRequestCountMetric: [MetricDataQuery]?

        @inlinable
        public init(dependencyConfig: DependencyConfig? = nil, keyAttributes: [String: String]? = nil, metricType: ServiceLevelIndicatorMetricType? = nil, monitoredRequestCountMetric: MonitoredRequestCountMetricDataQueries? = nil, operationName: String? = nil, totalRequestCountMetric: [MetricDataQuery]? = nil) {
            self.dependencyConfig = dependencyConfig
            self.keyAttributes = keyAttributes
            self.metricType = metricType
            self.monitoredRequestCountMetric = monitoredRequestCountMetric
            self.operationName = operationName
            self.totalRequestCountMetric = totalRequestCountMetric
        }

        public func validate(name: String) throws {
            try self.dependencyConfig?.validate(name: "\(name).dependencyConfig")
            try self.keyAttributes?.forEach {
                try validate($0.key, name: "keyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, max: 4)
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, min: 1)
            try self.monitoredRequestCountMetric?.validate(name: "\(name).monitoredRequestCountMetric")
            try self.validate(self.operationName, name: "operationName", parent: name, max: 255)
            try self.validate(self.operationName, name: "operationName", parent: name, min: 1)
            try self.totalRequestCountMetric?.forEach {
                try $0.validate(name: "\(name).totalRequestCountMetric[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyConfig = "DependencyConfig"
            case keyAttributes = "KeyAttributes"
            case metricType = "MetricType"
            case monitoredRequestCountMetric = "MonitoredRequestCountMetric"
            case operationName = "OperationName"
            case totalRequestCountMetric = "TotalRequestCountMetric"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// Can't find the resource id.
        public let resourceId: String
        /// The resource type is not valid.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RollingInterval: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the duration of each rolling interval. For example, if Duration is 7 and DurationUnit is DAY, each rolling interval is seven days.
        public let duration: Int
        /// Specifies the rolling interval unit.
        public let durationUnit: DurationUnit

        @inlinable
        public init(duration: Int, durationUnit: DurationUnit) {
            self.duration = duration
            self.durationUnit = durationUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case durationUnit = "DurationUnit"
        }
    }

    public struct Service: AWSDecodableShape {
        /// This structure contains one or more string-to-string maps that help identify this service. It can include platform attributes, application attributes, and telemetry attributes. Platform attributes contain information the service's platform.    PlatformType defines the hosted-in platform.    EKS.Cluster is the name of the Amazon EKS cluster.    K8s.Cluster is the name of the self-hosted Kubernetes cluster.    K8s.Namespace is the name of the Kubernetes namespace in either Amazon EKS or Kubernetes clusters.    K8s.Workload is the name of the Kubernetes workload in either Amazon EKS or Kubernetes clusters.    K8s.Node is the name of the Kubernetes node in either Amazon EKS or Kubernetes clusters.    K8s.Pod is the name of the Kubernetes pod in either Amazon EKS or Kubernetes clusters.    EC2.AutoScalingGroup is the name of the Amazon EC2 Auto Scaling group.    EC2.InstanceId is the ID of the Amazon EC2 instance.    Host is the name of the host, for all platform types.   Application attributes contain information about the application.    AWS.Application is the application's name in Amazon Web Services Service Catalog AppRegistry.    AWS.Application.ARN is the application's ARN in Amazon Web Services Service Catalog AppRegistry.   Telemetry attributes contain telemetry information.    Telemetry.SDK is the fingerprint of the OpenTelemetry SDK version for instrumented services.    Telemetry.Agent is the fingerprint of the agent used to collect and send telemetry data.    Telemetry.Source Specifies the point of application where the telemetry was collected or specifies what was used for the source of telemetry data.
        public let attributeMaps: [[String: String]]?
        /// This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]
        /// An array of string-to-string maps that each contain information about one log group associated with this service. Each  string-to-string map includes the following fields:    "Type": "AWS::Resource"     "ResourceType": "AWS::Logs::LogGroup"     "Identifier": "name-of-log-group"
        public let logGroupReferences: [[String: String]]?
        /// An array of structures that each contain information about one metric associated with this service.
        public let metricReferences: [MetricReference]

        @inlinable
        public init(attributeMaps: [[String: String]]? = nil, keyAttributes: [String: String], logGroupReferences: [[String: String]]? = nil, metricReferences: [MetricReference]) {
            self.attributeMaps = attributeMaps
            self.keyAttributes = keyAttributes
            self.logGroupReferences = logGroupReferences
            self.metricReferences = metricReferences
        }

        private enum CodingKeys: String, CodingKey {
            case attributeMaps = "AttributeMaps"
            case keyAttributes = "KeyAttributes"
            case logGroupReferences = "LogGroupReferences"
            case metricReferences = "MetricReferences"
        }
    }

    public struct ServiceDependency: AWSDecodableShape {
        /// This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let dependencyKeyAttributes: [String: String]
        /// The name of the called operation in the dependency.
        public let dependencyOperationName: String
        /// An array of structures that each contain information about one metric associated with this service dependency that was discovered by Application Signals.
        public let metricReferences: [MetricReference]
        /// The name of the operation in this service that calls the dependency.
        public let operationName: String

        @inlinable
        public init(dependencyKeyAttributes: [String: String], dependencyOperationName: String, metricReferences: [MetricReference], operationName: String) {
            self.dependencyKeyAttributes = dependencyKeyAttributes
            self.dependencyOperationName = dependencyOperationName
            self.metricReferences = metricReferences
            self.operationName = operationName
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyKeyAttributes = "DependencyKeyAttributes"
            case dependencyOperationName = "DependencyOperationName"
            case metricReferences = "MetricReferences"
            case operationName = "OperationName"
        }
    }

    public struct ServiceDependent: AWSDecodableShape {
        /// This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let dependentKeyAttributes: [String: String]
        /// If the dependent invoker was a service that invoked it from an operation, the name of that dependent operation is displayed here.
        public let dependentOperationName: String?
        /// An array of structures that each contain information about one metric associated with this service dependent that was discovered by Application Signals.
        public let metricReferences: [MetricReference]
        /// If the invoked entity is an operation on an entity, the name of that dependent operation is displayed here.
        public let operationName: String?

        @inlinable
        public init(dependentKeyAttributes: [String: String], dependentOperationName: String? = nil, metricReferences: [MetricReference], operationName: String? = nil) {
            self.dependentKeyAttributes = dependentKeyAttributes
            self.dependentOperationName = dependentOperationName
            self.metricReferences = metricReferences
            self.operationName = operationName
        }

        private enum CodingKeys: String, CodingKey {
            case dependentKeyAttributes = "DependentKeyAttributes"
            case dependentOperationName = "DependentOperationName"
            case metricReferences = "MetricReferences"
            case operationName = "OperationName"
        }
    }

    public struct ServiceLevelIndicator: AWSDecodableShape {
        /// The arithmetic operation used when comparing the specified metric to the threshold.
        public let comparisonOperator: ServiceLevelIndicatorComparisonOperator
        /// The value that the SLI metric is compared to.
        public let metricThreshold: Double
        /// A structure that contains information about the metric that the SLO monitors.
        public let sliMetric: ServiceLevelIndicatorMetric

        @inlinable
        public init(comparisonOperator: ServiceLevelIndicatorComparisonOperator, metricThreshold: Double, sliMetric: ServiceLevelIndicatorMetric) {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.sliMetric = sliMetric
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case metricThreshold = "MetricThreshold"
            case sliMetric = "SliMetric"
        }
    }

    public struct ServiceLevelIndicatorConfig: AWSEncodableShape {
        /// The arithmetic operation to use when comparing the specified metric to the threshold.
        public let comparisonOperator: ServiceLevelIndicatorComparisonOperator
        /// This parameter is used only when a request-based SLO tracks the Latency metric. Specify the threshold value that the  observed Latency metric values are to be compared to.
        public let metricThreshold: Double
        /// Use this structure to specify the metric to be used for the SLO.
        public let sliMetricConfig: ServiceLevelIndicatorMetricConfig

        @inlinable
        public init(comparisonOperator: ServiceLevelIndicatorComparisonOperator, metricThreshold: Double, sliMetricConfig: ServiceLevelIndicatorMetricConfig) {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.sliMetricConfig = sliMetricConfig
        }

        public func validate(name: String) throws {
            try self.sliMetricConfig.validate(name: "\(name).sliMetricConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case metricThreshold = "MetricThreshold"
            case sliMetricConfig = "SliMetricConfig"
        }
    }

    public struct ServiceLevelIndicatorMetric: AWSDecodableShape {
        /// Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
        public let dependencyConfig: DependencyConfig?
        /// This is a string-to-string map that contains information about the type of object that this SLO is related to. It can  include the following fields.    Type designates the type of object that this SLO is related to.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]?
        /// If this SLO monitors a CloudWatch metric or the result of a CloudWatch metric math expression,  this structure includes the information about that metric or expression.
        public let metricDataQueries: [MetricDataQuery]
        /// If the SLO monitors either the LATENCY or AVAILABILITY metric that Application Signals  collects, this field displays which of those metrics is used.
        public let metricType: ServiceLevelIndicatorMetricType?
        /// If the SLO monitors a specific operation of the service, this field displays that operation name.
        public let operationName: String?

        @inlinable
        public init(dependencyConfig: DependencyConfig? = nil, keyAttributes: [String: String]? = nil, metricDataQueries: [MetricDataQuery], metricType: ServiceLevelIndicatorMetricType? = nil, operationName: String? = nil) {
            self.dependencyConfig = dependencyConfig
            self.keyAttributes = keyAttributes
            self.metricDataQueries = metricDataQueries
            self.metricType = metricType
            self.operationName = operationName
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyConfig = "DependencyConfig"
            case keyAttributes = "KeyAttributes"
            case metricDataQueries = "MetricDataQueries"
            case metricType = "MetricType"
            case operationName = "OperationName"
        }
    }

    public struct ServiceLevelIndicatorMetricConfig: AWSEncodableShape {
        /// Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
        public let dependencyConfig: DependencyConfig?
        /// If this SLO is related to a metric collected by Application Signals, you must use this field to specify which service  the SLO metric is related to. To do so, you must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]?
        /// If this SLO monitors a CloudWatch metric or the result of a CloudWatch metric math expression,  use this structure to specify that metric or expression.
        public let metricDataQueries: [MetricDataQuery]?
        /// If the SLO is to monitor either the LATENCY or AVAILABILITY metric that Application Signals  collects, use this field to specify which of those metrics is used.
        public let metricType: ServiceLevelIndicatorMetricType?
        /// If the SLO is to monitor a specific operation of the service, use this field to specify the name of that operation.
        public let operationName: String?
        /// The number of seconds to use as the period for SLO evaluation. Your application's performance is compared to the  SLI during each period. For each period, the application is determined to have either achieved or not achieved the necessary performance.
        public let periodSeconds: Int?
        /// The statistic to use for comparison to the threshold. It can be any CloudWatch statistic or extended statistic. For more information about statistics,  see CloudWatch statistics definitions.
        public let statistic: String?

        @inlinable
        public init(dependencyConfig: DependencyConfig? = nil, keyAttributes: [String: String]? = nil, metricDataQueries: [MetricDataQuery]? = nil, metricType: ServiceLevelIndicatorMetricType? = nil, operationName: String? = nil, periodSeconds: Int? = nil, statistic: String? = nil) {
            self.dependencyConfig = dependencyConfig
            self.keyAttributes = keyAttributes
            self.metricDataQueries = metricDataQueries
            self.metricType = metricType
            self.operationName = operationName
            self.periodSeconds = periodSeconds
            self.statistic = statistic
        }

        public func validate(name: String) throws {
            try self.dependencyConfig?.validate(name: "\(name).dependencyConfig")
            try self.keyAttributes?.forEach {
                try validate($0.key, name: "keyAttributes.key", parent: name, pattern: "^[a-zA-Z]{1,50}$")
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "keyAttributes[\"\($0.key)\"]", parent: name, pattern: "^[ -~]*[!-~]+[ -~]*$")
            }
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, max: 4)
            try self.validate(self.keyAttributes, name: "keyAttributes", parent: name, min: 1)
            try self.metricDataQueries?.forEach {
                try $0.validate(name: "\(name).metricDataQueries[]")
            }
            try self.validate(self.operationName, name: "operationName", parent: name, max: 255)
            try self.validate(self.operationName, name: "operationName", parent: name, min: 1)
            try self.validate(self.periodSeconds, name: "periodSeconds", parent: name, max: 900)
            try self.validate(self.periodSeconds, name: "periodSeconds", parent: name, min: 60)
            try self.validate(self.statistic, name: "statistic", parent: name, max: 20)
            try self.validate(self.statistic, name: "statistic", parent: name, min: 1)
            try self.validate(self.statistic, name: "statistic", parent: name, pattern: "^[a-zA-Z0-9.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dependencyConfig = "DependencyConfig"
            case keyAttributes = "KeyAttributes"
            case metricDataQueries = "MetricDataQueries"
            case metricType = "MetricType"
            case operationName = "OperationName"
            case periodSeconds = "PeriodSeconds"
            case statistic = "Statistic"
        }
    }

    public struct ServiceLevelObjective: AWSDecodableShape {
        /// The ARN of this SLO.
        public let arn: String
        /// Each object in this array defines the length of the look-back window used to calculate one burn rate metric for this SLO. The burn rate measures how fast the service is consuming the error budget, relative to the attainment goal of the SLO.
        public let burnRateConfigurations: [BurnRateConfiguration]?
        /// The date and time that this SLO was created. When used in a raw HTTP Query API, it is formatted as  yyyy-MM-dd'T'HH:mm:ss. For example,  2019-07-01T23:59:59.
        public let createdTime: Date
        /// The description that you created for this SLO.
        public let description: String?
        /// Displays whether this is a period-based SLO or a request-based SLO.
        public let evaluationType: EvaluationType?
        public let goal: Goal
        /// The time that this SLO was most recently updated. When used in a raw HTTP Query API, it is formatted as  yyyy-MM-dd'T'HH:mm:ss. For example,  2019-07-01T23:59:59.
        public let lastUpdatedTime: Date
        /// Displays the SLI metric source type for this SLO. Supported types are:   Service operation   Service dependency   CloudWatch metric
        public let metricSourceType: MetricSourceType?
        /// The name of this SLO.
        public let name: String
        /// A structure containing information about the performance metric that this SLO monitors, if this is a request-based SLO.
        public let requestBasedSli: RequestBasedServiceLevelIndicator?
        /// A structure containing information about the performance metric that this SLO monitors, if this is a period-based SLO.
        public let sli: ServiceLevelIndicator?

        @inlinable
        public init(arn: String, burnRateConfigurations: [BurnRateConfiguration]? = nil, createdTime: Date, description: String? = nil, evaluationType: EvaluationType? = nil, goal: Goal, lastUpdatedTime: Date, metricSourceType: MetricSourceType? = nil, name: String, requestBasedSli: RequestBasedServiceLevelIndicator? = nil, sli: ServiceLevelIndicator? = nil) {
            self.arn = arn
            self.burnRateConfigurations = burnRateConfigurations
            self.createdTime = createdTime
            self.description = description
            self.evaluationType = evaluationType
            self.goal = goal
            self.lastUpdatedTime = lastUpdatedTime
            self.metricSourceType = metricSourceType
            self.name = name
            self.requestBasedSli = requestBasedSli
            self.sli = sli
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case burnRateConfigurations = "BurnRateConfigurations"
            case createdTime = "CreatedTime"
            case description = "Description"
            case evaluationType = "EvaluationType"
            case goal = "Goal"
            case lastUpdatedTime = "LastUpdatedTime"
            case metricSourceType = "MetricSourceType"
            case name = "Name"
            case requestBasedSli = "RequestBasedSli"
            case sli = "Sli"
        }
    }

    public struct ServiceLevelObjectiveBudgetReport: AWSDecodableShape {
        /// The ARN of the SLO that this report is for.
        public let arn: String
        /// A number between 0 and 100 that represents the success percentage of your application compared to the goal set by the SLO. If this is a period-based SLO, the number is the percentage of time periods that the service has  attained the SLO's attainment goal, as of the time of the request. If this is a request-based SLO, the number is the number of successful requests divided by the number of total requests, multiplied by 100, during the time range that you specified in your request.
        public let attainment: Double?
        /// This field is displayed only for request-based SLOs. It displays the number of failed requests that can be tolerated before any more successful requests occur, and still have the application meet its SLO goal. This number can go up and down between different reports, based on both how many successful requests and how many failed  requests occur in that time.
        public let budgetRequestsRemaining: Int?
        /// The budget amount remaining before the SLO status becomes BREACHING, at the time specified in the  Timestemp parameter of the request. If this value is negative, then the SLO is already in BREACHING status. This field is included only  if the SLO is a period-based SLO.
        public let budgetSecondsRemaining: Int?
        /// The status of this SLO, as it relates to the error budget for the entire time interval.    OK means that the SLO had remaining budget above the warning threshold, as of the time that you specified in TimeStamp.    WARNING means that the SLO's remaining budget was below the warning threshold, as of the time that you specified in TimeStamp.    BREACHED means that the SLO's budget was exhausted, as of the time that you specified in TimeStamp.    INSUFFICIENT_DATA means that the specified start and end times were before the SLO was created, or that attainment data is missing.
        public let budgetStatus: ServiceLevelObjectiveBudgetStatus
        /// Displays whether this budget report is for a period-based SLO or a request-based SLO.
        public let evaluationType: EvaluationType?
        public let goal: Goal?
        /// The name of the SLO that this report is for.
        public let name: String
        public let requestBasedSli: RequestBasedServiceLevelIndicator?
        /// A structure that contains information about the performance metric that this SLO monitors.
        public let sli: ServiceLevelIndicator?
        /// This field is displayed only for request-based SLOs. It displays the total number of failed requests that can be tolerated during the time range between the start of the  interval and the time stamp supplied in the budget report request. It is based on the total number of requests that occurred, and the percentage specified in the attainment goal. If the number of failed requests matches this number or is higher, then  this SLO is currently breaching. This number can go up and down between reports with different time stamps, based on both how many total requests occur.
        public let totalBudgetRequests: Int?
        /// The total number of seconds in the error budget for the interval. This field is included only  if the SLO is a period-based SLO.
        public let totalBudgetSeconds: Int?

        @inlinable
        public init(arn: String, attainment: Double? = nil, budgetRequestsRemaining: Int? = nil, budgetSecondsRemaining: Int? = nil, budgetStatus: ServiceLevelObjectiveBudgetStatus, evaluationType: EvaluationType? = nil, goal: Goal? = nil, name: String, requestBasedSli: RequestBasedServiceLevelIndicator? = nil, sli: ServiceLevelIndicator? = nil, totalBudgetRequests: Int? = nil, totalBudgetSeconds: Int? = nil) {
            self.arn = arn
            self.attainment = attainment
            self.budgetRequestsRemaining = budgetRequestsRemaining
            self.budgetSecondsRemaining = budgetSecondsRemaining
            self.budgetStatus = budgetStatus
            self.evaluationType = evaluationType
            self.goal = goal
            self.name = name
            self.requestBasedSli = requestBasedSli
            self.sli = sli
            self.totalBudgetRequests = totalBudgetRequests
            self.totalBudgetSeconds = totalBudgetSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case attainment = "Attainment"
            case budgetRequestsRemaining = "BudgetRequestsRemaining"
            case budgetSecondsRemaining = "BudgetSecondsRemaining"
            case budgetStatus = "BudgetStatus"
            case evaluationType = "EvaluationType"
            case goal = "Goal"
            case name = "Name"
            case requestBasedSli = "RequestBasedSli"
            case sli = "Sli"
            case totalBudgetRequests = "TotalBudgetRequests"
            case totalBudgetSeconds = "TotalBudgetSeconds"
        }
    }

    public struct ServiceLevelObjectiveBudgetReportError: AWSDecodableShape {
        /// The ARN of the SLO that this error is related to.
        public let arn: String
        /// The error code for this error.
        public let errorCode: String
        /// The message for this error.
        public let errorMessage: String
        /// The name of the SLO that this error is related to.
        public let name: String

        @inlinable
        public init(arn: String, errorCode: String, errorMessage: String, name: String) {
            self.arn = arn
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case name = "Name"
        }
    }

    public struct ServiceLevelObjectiveSummary: AWSDecodableShape {
        /// The ARN of this service level objective.
        public let arn: String
        /// The date and time that this service level objective was created. It is expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.
        public let createdTime: Date?
        /// Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
        public let dependencyConfig: DependencyConfig?
        /// Displays whether this is a period-based SLO or a request-based SLO.
        public let evaluationType: EvaluationType?
        /// This is a string-to-string map. It can  include the following fields.    Type designates the type of object this service level objective is for.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]?
        /// Displays the SLI metric source type for this SLO. Supported types are:   Service operation   Service dependency   CloudWatch metric
        public let metricSourceType: MetricSourceType?
        /// The name of the service level objective.
        public let name: String
        /// If this service level objective is specific to a single operation, this  field displays the name of that operation.
        public let operationName: String?

        @inlinable
        public init(arn: String, createdTime: Date? = nil, dependencyConfig: DependencyConfig? = nil, evaluationType: EvaluationType? = nil, keyAttributes: [String: String]? = nil, metricSourceType: MetricSourceType? = nil, name: String, operationName: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dependencyConfig = dependencyConfig
            self.evaluationType = evaluationType
            self.keyAttributes = keyAttributes
            self.metricSourceType = metricSourceType
            self.name = name
            self.operationName = operationName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dependencyConfig = "DependencyConfig"
            case evaluationType = "EvaluationType"
            case keyAttributes = "KeyAttributes"
            case metricSourceType = "MetricSourceType"
            case name = "Name"
            case operationName = "OperationName"
        }
    }

    public struct ServiceOperation: AWSDecodableShape {
        /// An array of structures that each contain information about one metric associated with this service operation that was discovered by Application Signals.
        public let metricReferences: [MetricReference]
        /// The name of the operation, discovered by Application Signals.
        public let name: String

        @inlinable
        public init(metricReferences: [MetricReference], name: String) {
            self.metricReferences = metricReferences
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case metricReferences = "MetricReferences"
            case name = "Name"
        }
    }

    public struct ServiceSummary: AWSDecodableShape {
        /// This structure contains one or more string-to-string maps that help identify this service. It can include platform attributes, application attributes, and telemetry attributes. Platform attributes contain information the service's platform.    PlatformType defines the hosted-in platform.    EKS.Cluster is the name of the Amazon EKS cluster.    K8s.Cluster is the name of the self-hosted Kubernetes cluster.    K8s.Namespace is the name of the Kubernetes namespace in either Amazon EKS or Kubernetes clusters.    K8s.Workload is the name of the Kubernetes workload in either Amazon EKS or Kubernetes clusters.    K8s.Node is the name of the Kubernetes node in either Amazon EKS or Kubernetes clusters.    K8s.Pod is the name of the Kubernetes pod in either Amazon EKS or Kubernetes clusters.    EC2.AutoScalingGroup is the name of the Amazon EC2 Auto Scaling group.    EC2.InstanceId is the ID of the Amazon EC2 instance.    Host is the name of the host, for all platform types.   Application attributes contain information about the application.    AWS.Application is the application's name in Amazon Web Services Service Catalog AppRegistry.    AWS.Application.ARN is the application's ARN in Amazon Web Services Service Catalog AppRegistry.   Telemetry attributes contain telemetry information.    Telemetry.SDK is the fingerprint of the OpenTelemetry SDK version for instrumented services.    Telemetry.Agent is the fingerprint of the agent used to collect and send telemetry data.    Telemetry.Source Specifies the point of application where the telemetry was collected or specifies what was used for the source of telemetry data.
        public let attributeMaps: [[String: String]]?
        /// This is a string-to-string map that help identify the objects discovered by Application Signals. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
        public let keyAttributes: [String: String]
        /// An array of structures that each contain information about one metric associated with this service.
        public let metricReferences: [MetricReference]

        @inlinable
        public init(attributeMaps: [[String: String]]? = nil, keyAttributes: [String: String], metricReferences: [MetricReference]) {
            self.attributeMaps = attributeMaps
            self.keyAttributes = keyAttributes
            self.metricReferences = metricReferences
        }

        private enum CodingKeys: String, CodingKey {
            case attributeMaps = "AttributeMaps"
            case keyAttributes = "KeyAttributes"
            case metricReferences = "MetricReferences"
        }
    }

    public struct StartDiscoveryInput: AWSEncodableShape {
        public init() {}
    }

    public struct StartDiscoveryOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A string that you can use to assign a value. The combination of tag keys and values can help you organize and categorize your  resources.
        public let key: String
        /// The value for the specified tag key.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the CloudWatch resource that you want to set tags for. The ARN format of an Application Signals SLO is  arn:aws:cloudwatch:Region:account-id:slo:slo-name   For more information about ARN format, see  Resource Types Defined by Amazon CloudWatch in the Amazon Web Services General Reference.
        public let resourceArn: String
        /// The list of key-value pairs to associate with the alarm.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the CloudWatch resource that you want to delete tags from. The ARN format of an Application Signals SLO is  arn:aws:cloudwatch:Region:account-id:slo:slo-name   For more information about ARN format, see  Resource Types Defined by Amazon CloudWatch in the Amazon Web Services General Reference.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServiceLevelObjectiveInput: AWSEncodableShape {
        /// Use this array to create burn rates for this SLO. Each  burn rate is a metric that indicates how fast the service is consuming the error budget, relative to the attainment goal of the SLO.
        public let burnRateConfigurations: [BurnRateConfiguration]?
        /// An optional description for the SLO.
        public let description: String?
        /// A structure that contains the attributes that determine the goal of the SLO. This includes the time period for evaluation and the attainment threshold.
        public let goal: Goal?
        /// The Amazon Resource Name (ARN) or name of the service level objective that you want to update.
        public let id: String
        /// If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both SliConfig and RequestBasedSliConfig in the same operation.
        public let requestBasedSliConfig: RequestBasedServiceLevelIndicatorConfig?
        /// If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor.
        public let sliConfig: ServiceLevelIndicatorConfig?

        @inlinable
        public init(burnRateConfigurations: [BurnRateConfiguration]? = nil, description: String? = nil, goal: Goal? = nil, id: String, requestBasedSliConfig: RequestBasedServiceLevelIndicatorConfig? = nil, sliConfig: ServiceLevelIndicatorConfig? = nil) {
            self.burnRateConfigurations = burnRateConfigurations
            self.description = description
            self.goal = goal
            self.id = id
            self.requestBasedSliConfig = requestBasedSliConfig
            self.sliConfig = sliConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.burnRateConfigurations, forKey: .burnRateConfigurations)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.goal, forKey: .goal)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.requestBasedSliConfig, forKey: .requestBasedSliConfig)
            try container.encodeIfPresent(self.sliConfig, forKey: .sliConfig)
        }

        public func validate(name: String) throws {
            try self.burnRateConfigurations?.forEach {
                try $0.validate(name: "\(name).burnRateConfigurations[]")
            }
            try self.validate(self.burnRateConfigurations, name: "burnRateConfigurations", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.goal?.validate(name: "\(name).goal")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$|^arn:aws:application-signals:[^:]*:[^:]*:slo/[0-9A-Za-z][-._0-9A-Za-z ]{0,126}[0-9A-Za-z]$")
            try self.requestBasedSliConfig?.validate(name: "\(name).requestBasedSliConfig")
            try self.sliConfig?.validate(name: "\(name).sliConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case burnRateConfigurations = "BurnRateConfigurations"
            case description = "Description"
            case goal = "Goal"
            case requestBasedSliConfig = "RequestBasedSliConfig"
            case sliConfig = "SliConfig"
        }
    }

    public struct UpdateServiceLevelObjectiveOutput: AWSDecodableShape {
        /// A structure that contains information about the SLO that you just updated.
        public let slo: ServiceLevelObjective

        @inlinable
        public init(slo: ServiceLevelObjective) {
            self.slo = slo
        }

        private enum CodingKeys: String, CodingKey {
            case slo = "Slo"
        }
    }

    public struct Window: AWSEncodableShape & AWSDecodableShape {
        /// The number of time units for the exclusion window length.
        public let duration: Int
        /// The unit of time for the exclusion window duration. Valid values: MINUTE, HOUR, DAY, MONTH.
        public let durationUnit: DurationUnit

        @inlinable
        public init(duration: Int, durationUnit: DurationUnit) {
            self.duration = duration
            self.durationUnit = durationUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case durationUnit = "DurationUnit"
        }
    }
}

// MARK: - Errors

/// Error enum for ApplicationSignals
public struct ApplicationSignalsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ApplicationSignals
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// This operation attempted to create a resource that already exists.
    public static var conflictException: Self { .init(.conflictException) }
    /// Resource not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was throttled because of quota limits.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The resource is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension ApplicationSignalsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": ApplicationSignals.ResourceNotFoundException.self
    ]
}

extension ApplicationSignalsErrorType: Equatable {
    public static func == (lhs: ApplicationSignalsErrorType, rhs: ApplicationSignalsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ApplicationSignalsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
