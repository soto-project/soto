//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS ApplicationSignals service.
///
/// Use CloudWatch Application Signals for comprehensive observability of your cloud-based applications.  It enables real-time service health dashboards and helps you track long-term performance trends against your business goals.  The application-centric view provides you with unified visibility across your applications, services, and  dependencies, so you can proactively monitor and efficiently triage any issues that may arise,  ensuring optimal customer experience. Application Signals provides the following benefits:   Automatically collect metrics and traces from your applications, and display key metrics such as call volume, availability, latency, faults, and errors.    Create and monitor service level objectives (SLOs).    See a map of your application topology that Application Signals automatically discovers, that gives you a visual representation of your applications, dependencies, and their connectivity.   Application Signals works with CloudWatch RUM, CloudWatch Synthetics canaries, and Amazon Web Services Service Catalog AppRegistry, to display your client pages, Synthetics canaries,  and application names within dashboards and maps.
public struct ApplicationSignals: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the ApplicationSignals client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "ApplicationSignals",
            serviceIdentifier: "application-signals",
            serviceProtocol: .restjson,
            apiVersion: "2024-04-15",
            endpoint: endpoint,
            errorType: ApplicationSignalsErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Use this operation to retrieve one or more service level objective (SLO) budget reports. An error budget is the amount of time or requests in an unhealthy state that your service can  accumulate during an interval before your overall SLO budget health is breached and the SLO is considered to be unmet. For example, an SLO with a threshold of 99.95% and a monthly interval translates to an error budget of 21.9 minutes of  downtime in a 30-day month. Budget reports include a health indicator, the attainment value, and  remaining budget. For more information about SLO error budgets, see   SLO concepts.
    @Sendable
    @inlinable
    public func batchGetServiceLevelObjectiveBudgetReport(_ input: BatchGetServiceLevelObjectiveBudgetReportInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetServiceLevelObjectiveBudgetReportOutput {
        try await self.client.execute(
            operation: "BatchGetServiceLevelObjectiveBudgetReport", 
            path: "/budget-report", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use this operation to retrieve one or more service level objective (SLO) budget reports. An error budget is the amount of time or requests in an unhealthy state that your service can  accumulate during an interval before your overall SLO budget health is breached and the SLO is considered to be unmet. For example, an SLO with a threshold of 99.95% and a monthly interval translates to an error budget of 21.9 minutes of  downtime in a 30-day month. Budget reports include a health indicator, the attainment value, and  remaining budget. For more information about SLO error budgets, see   SLO concepts.
    ///
    /// Parameters:
    ///   - sloIds: An array containing the IDs of the service level objectives that you want to include in the report.
    ///   - timestamp: The date and time that you want the report to be for. It is expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetServiceLevelObjectiveBudgetReport(
        sloIds: [String],
        timestamp: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetServiceLevelObjectiveBudgetReportOutput {
        let input = BatchGetServiceLevelObjectiveBudgetReportInput(
            sloIds: sloIds, 
            timestamp: timestamp
        )
        return try await self.batchGetServiceLevelObjectiveBudgetReport(input, logger: logger)
    }

    /// Add or remove time window exclusions for one or more Service Level Objectives (SLOs).
    @Sendable
    @inlinable
    public func batchUpdateExclusionWindows(_ input: BatchUpdateExclusionWindowsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateExclusionWindowsOutput {
        try await self.client.execute(
            operation: "BatchUpdateExclusionWindows", 
            path: "/exclusion-windows", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Add or remove time window exclusions for one or more Service Level Objectives (SLOs).
    ///
    /// Parameters:
    ///   - addExclusionWindows: A list of exclusion windows to add to the specified SLOs. You can add up to 10 exclusion windows per SLO.
    ///   - removeExclusionWindows: A list of exclusion windows to remove from the specified SLOs. The window configuration must match an existing exclusion window.
    ///   - sloIds: The list of SLO IDs to add or remove exclusion windows from.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateExclusionWindows(
        addExclusionWindows: [ExclusionWindow]? = nil,
        removeExclusionWindows: [ExclusionWindow]? = nil,
        sloIds: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateExclusionWindowsOutput {
        let input = BatchUpdateExclusionWindowsInput(
            addExclusionWindows: addExclusionWindows, 
            removeExclusionWindows: removeExclusionWindows, 
            sloIds: sloIds
        )
        return try await self.batchUpdateExclusionWindows(input, logger: logger)
    }

    /// Creates a service level objective (SLO), which can help you ensure that your critical business operations are  meeting customer expectations. Use SLOs to set and track specific target levels for the reliability and availability of your applications and services. SLOs use service level indicators (SLIs) to  calculate whether the application is performing at the level that you want. Create an SLO to set a target for a service or operation’s availability or latency. CloudWatch measures this target frequently you can find whether it has been breached.  The target performance quality that is defined for an SLO is the attainment goal. You can set SLO targets for your applications that are discovered by Application Signals, using critical metrics such as latency and availability.  You can also set SLOs against any CloudWatch metric or math expression that produces a time series.  You can't create an SLO for a service operation that was discovered by Application Signals until after that operation has reported standard metrics to Application Signals.  When you create an SLO, you specify whether it is a period-based SLO or a request-based SLO. Each type of SLO has a different way of evaluating  your application's performance against its attainment goal.   A period-based SLO uses defined periods of time within  a specified total time interval. For each period of time, Application Signals determines whether the  application met its goal. The attainment rate is calculated as the number of good periods/number of total periods. For example, for a period-based SLO, meeting an attainment goal of 99.9% means that within your interval, your application must meet its performance goal during at least 99.9% of the  time periods.   A request-based SLO doesn't use pre-defined periods of time. Instead,  the SLO measures number of good requests/number of total requests during the interval. At any time, you can find the ratio of  good requests to total requests for the interval up to the time stamp that you specify, and measure that ratio against the goal set in your SLO.   After you have created an SLO, you can retrieve error budget reports for it.  An error budget is the amount of time or amount of requests that your application can be non-compliant with the SLO's goal, and still have your application meet the goal.   For a period-based SLO, the error budget starts at a number defined by the highest number of periods that can fail to meet the threshold,  while still meeting the overall goal. The remaining error budget decreases with every failed period that is recorded. The error budget within one interval can never increase. For example, an SLO with a threshold that 99.95% of requests must be completed under 2000ms every month  translates to an error budget of 21.9 minutes of downtime per month.   For a request-based SLO, the remaining error budget is dynamic and can increase or decrease, depending on  the ratio of good requests to total requests.   For more information about SLOs, see  Service level objectives (SLOs).  When you perform a CreateServiceLevelObjective operation, Application Signals creates the AWSServiceRoleForCloudWatchApplicationSignals service-linked role,  if it doesn't already exist in your account. This service- linked role has the following permissions:    xray:GetServiceGraph     logs:StartQuery     logs:GetQueryResults     cloudwatch:GetMetricData     cloudwatch:ListMetrics     tag:GetResources     autoscaling:DescribeAutoScalingGroups
    @Sendable
    @inlinable
    public func createServiceLevelObjective(_ input: CreateServiceLevelObjectiveInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateServiceLevelObjectiveOutput {
        try await self.client.execute(
            operation: "CreateServiceLevelObjective", 
            path: "/slo", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a service level objective (SLO), which can help you ensure that your critical business operations are  meeting customer expectations. Use SLOs to set and track specific target levels for the reliability and availability of your applications and services. SLOs use service level indicators (SLIs) to  calculate whether the application is performing at the level that you want. Create an SLO to set a target for a service or operation’s availability or latency. CloudWatch measures this target frequently you can find whether it has been breached.  The target performance quality that is defined for an SLO is the attainment goal. You can set SLO targets for your applications that are discovered by Application Signals, using critical metrics such as latency and availability.  You can also set SLOs against any CloudWatch metric or math expression that produces a time series.  You can't create an SLO for a service operation that was discovered by Application Signals until after that operation has reported standard metrics to Application Signals.  When you create an SLO, you specify whether it is a period-based SLO or a request-based SLO. Each type of SLO has a different way of evaluating  your application's performance against its attainment goal.   A period-based SLO uses defined periods of time within  a specified total time interval. For each period of time, Application Signals determines whether the  application met its goal. The attainment rate is calculated as the number of good periods/number of total periods. For example, for a period-based SLO, meeting an attainment goal of 99.9% means that within your interval, your application must meet its performance goal during at least 99.9% of the  time periods.   A request-based SLO doesn't use pre-defined periods of time. Instead,  the SLO measures number of good requests/number of total requests during the interval. At any time, you can find the ratio of  good requests to total requests for the interval up to the time stamp that you specify, and measure that ratio against the goal set in your SLO.   After you have created an SLO, you can retrieve error budget reports for it.  An error budget is the amount of time or amount of requests that your application can be non-compliant with the SLO's goal, and still have your application meet the goal.   For a period-based SLO, the error budget starts at a number defined by the highest number of periods that can fail to meet the threshold,  while still meeting the overall goal. The remaining error budget decreases with every failed period that is recorded. The error budget within one interval can never increase. For example, an SLO with a threshold that 99.95% of requests must be completed under 2000ms every month  translates to an error budget of 21.9 minutes of downtime per month.   For a request-based SLO, the remaining error budget is dynamic and can increase or decrease, depending on  the ratio of good requests to total requests.   For more information about SLOs, see  Service level objectives (SLOs).  When you perform a CreateServiceLevelObjective operation, Application Signals creates the AWSServiceRoleForCloudWatchApplicationSignals service-linked role,  if it doesn't already exist in your account. This service- linked role has the following permissions:    xray:GetServiceGraph     logs:StartQuery     logs:GetQueryResults     cloudwatch:GetMetricData     cloudwatch:ListMetrics     tag:GetResources     autoscaling:DescribeAutoScalingGroups
    ///
    /// Parameters:
    ///   - burnRateConfigurations: Use this array to create burn rates for this SLO. Each  burn rate is a metric that indicates how fast the service is consuming the error budget, relative to the attainment goal of the SLO.
    ///   - description: An optional description for this SLO.
    ///   - goal: This structure contains the attributes that determine the goal of the SLO.
    ///   - name: A name for this SLO.
    ///   - requestBasedSliConfig: If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both RequestBasedSliConfig and SliConfig in the same operation.
    ///   - sliConfig: If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both RequestBasedSliConfig and SliConfig in the same operation.
    ///   - tags: A list of key-value pairs to associate with the SLO. You can associate as many as 50 tags with an SLO. To be able to associate tags with the SLO when you create the SLO, you must have the cloudwatch:TagResource permission. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values.
    ///   - logger: Logger use during operation
    @inlinable
    public func createServiceLevelObjective(
        burnRateConfigurations: [BurnRateConfiguration]? = nil,
        description: String? = nil,
        goal: Goal? = nil,
        name: String,
        requestBasedSliConfig: RequestBasedServiceLevelIndicatorConfig? = nil,
        sliConfig: ServiceLevelIndicatorConfig? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateServiceLevelObjectiveOutput {
        let input = CreateServiceLevelObjectiveInput(
            burnRateConfigurations: burnRateConfigurations, 
            description: description, 
            goal: goal, 
            name: name, 
            requestBasedSliConfig: requestBasedSliConfig, 
            sliConfig: sliConfig, 
            tags: tags
        )
        return try await self.createServiceLevelObjective(input, logger: logger)
    }

    /// Deletes the specified service level objective.
    @Sendable
    @inlinable
    public func deleteServiceLevelObjective(_ input: DeleteServiceLevelObjectiveInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteServiceLevelObjectiveOutput {
        try await self.client.execute(
            operation: "DeleteServiceLevelObjective", 
            path: "/slo/{Id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified service level objective.
    ///
    /// Parameters:
    ///   - id: The ARN or name of the service level objective to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteServiceLevelObjective(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteServiceLevelObjectiveOutput {
        let input = DeleteServiceLevelObjectiveInput(
            id: id
        )
        return try await self.deleteServiceLevelObjective(input, logger: logger)
    }

    /// Returns information about a service discovered by Application Signals.
    @Sendable
    @inlinable
    public func getService(_ input: GetServiceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetServiceOutput {
        try await self.client.execute(
            operation: "GetService", 
            path: "/service", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a service discovered by Application Signals.
    ///
    /// Parameters:
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - keyAttributes: Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger use during operation
    @inlinable
    public func getService(
        endTime: Date,
        keyAttributes: [String: String],
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetServiceOutput {
        let input = GetServiceInput(
            endTime: endTime, 
            keyAttributes: keyAttributes, 
            startTime: startTime
        )
        return try await self.getService(input, logger: logger)
    }

    /// Returns information about one SLO created in the account.
    @Sendable
    @inlinable
    public func getServiceLevelObjective(_ input: GetServiceLevelObjectiveInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetServiceLevelObjectiveOutput {
        try await self.client.execute(
            operation: "GetServiceLevelObjective", 
            path: "/slo/{Id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about one SLO created in the account.
    ///
    /// Parameters:
    ///   - id: The ARN or name of the SLO that you want to retrieve information about. You can find the ARNs  of SLOs by using the ListServiceLevelObjectives operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func getServiceLevelObjective(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetServiceLevelObjectiveOutput {
        let input = GetServiceLevelObjectiveInput(
            id: id
        )
        return try await self.getServiceLevelObjective(input, logger: logger)
    }

    /// Returns a list of service dependencies of the service that you specify. A dependency is an infrastructure  component that an operation of this service connects with. Dependencies can include Amazon Web Services  services, Amazon Web Services resources, and third-party services.
    @Sendable
    @inlinable
    public func listServiceDependencies(_ input: ListServiceDependenciesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListServiceDependenciesOutput {
        try await self.client.execute(
            operation: "ListServiceDependencies", 
            path: "/service-dependencies", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of service dependencies of the service that you specify. A dependency is an infrastructure  component that an operation of this service connects with. Dependencies can include Amazon Web Services  services, Amazon Web Services resources, and third-party services.
    ///
    /// Parameters:
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested end time will be rounded to the nearest hour.
    ///   - keyAttributes: Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - nextToken: Include this value, if it was returned by the previous operation, to get the next set of service dependencies.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger use during operation
    @inlinable
    public func listServiceDependencies(
        endTime: Date,
        keyAttributes: [String: String],
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListServiceDependenciesOutput {
        let input = ListServiceDependenciesInput(
            endTime: endTime, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime
        )
        return try await self.listServiceDependencies(input, logger: logger)
    }

    /// Returns the list of dependents that invoked the specified service during the provided time range. Dependents include  other services, CloudWatch Synthetics canaries, and clients that are instrumented with CloudWatch RUM app monitors.
    @Sendable
    @inlinable
    public func listServiceDependents(_ input: ListServiceDependentsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListServiceDependentsOutput {
        try await self.client.execute(
            operation: "ListServiceDependents", 
            path: "/service-dependents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the list of dependents that invoked the specified service during the provided time range. Dependents include  other services, CloudWatch Synthetics canaries, and clients that are instrumented with CloudWatch RUM app monitors.
    ///
    /// Parameters:
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - keyAttributes: Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - nextToken: Include this value, if it was returned by the previous operation, to get the next set of service dependents.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger use during operation
    @inlinable
    public func listServiceDependents(
        endTime: Date,
        keyAttributes: [String: String],
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListServiceDependentsOutput {
        let input = ListServiceDependentsInput(
            endTime: endTime, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime
        )
        return try await self.listServiceDependents(input, logger: logger)
    }

    /// Retrieves all exclusion windows configured for a specific SLO.
    @Sendable
    @inlinable
    public func listServiceLevelObjectiveExclusionWindows(_ input: ListServiceLevelObjectiveExclusionWindowsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListServiceLevelObjectiveExclusionWindowsOutput {
        try await self.client.execute(
            operation: "ListServiceLevelObjectiveExclusionWindows", 
            path: "/slo/{Id}/exclusion-windows", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all exclusion windows configured for a specific SLO.
    ///
    /// Parameters:
    ///   - id: The ID of the SLO to list exclusion windows for.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - nextToken: Include this value, if it was returned by the previous operation, to get the next set of service level objectives.
    ///   - logger: Logger use during operation
    @inlinable
    public func listServiceLevelObjectiveExclusionWindows(
        id: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListServiceLevelObjectiveExclusionWindowsOutput {
        let input = ListServiceLevelObjectiveExclusionWindowsInput(
            id: id, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listServiceLevelObjectiveExclusionWindows(input, logger: logger)
    }

    /// Returns a list of SLOs created in this account.
    @Sendable
    @inlinable
    public func listServiceLevelObjectives(_ input: ListServiceLevelObjectivesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListServiceLevelObjectivesOutput {
        try await self.client.execute(
            operation: "ListServiceLevelObjectives", 
            path: "/slos", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of SLOs created in this account.
    ///
    /// Parameters:
    ///   - dependencyConfig: Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
    ///   - includeLinkedAccounts: If you are using this operation in a monitoring account, specify true to include SLO from source accounts in the returned data.   When you are monitoring an account, you can use Amazon Web Services account ID in KeyAttribute filter for service source account and SloOwnerawsaccountID for SLO source account with IncludeLinkedAccounts to filter the returned data to only a single source account.
    ///   - keyAttributes: You can use this optional field to specify which services you want to retrieve SLO information for. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - metricSourceTypes: Use this optional field to only include SLOs with the specified metric source types in the output. Supported types are:   Service operation   Service dependency   CloudWatch metric
    ///   - nextToken: Include this value, if it was returned by the previous operation, to get the next set of service level objectives.
    ///   - operationName: The name of the operation that this SLO is associated with.
    ///   - sloOwnerAwsAccountId: SLO's Amazon Web Services account ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listServiceLevelObjectives(
        dependencyConfig: DependencyConfig? = nil,
        includeLinkedAccounts: Bool? = nil,
        keyAttributes: [String: String]? = nil,
        maxResults: Int? = nil,
        metricSourceTypes: [MetricSourceType]? = nil,
        nextToken: String? = nil,
        operationName: String? = nil,
        sloOwnerAwsAccountId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListServiceLevelObjectivesOutput {
        let input = ListServiceLevelObjectivesInput(
            dependencyConfig: dependencyConfig, 
            includeLinkedAccounts: includeLinkedAccounts, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            metricSourceTypes: metricSourceTypes, 
            nextToken: nextToken, 
            operationName: operationName, 
            sloOwnerAwsAccountId: sloOwnerAwsAccountId
        )
        return try await self.listServiceLevelObjectives(input, logger: logger)
    }

    /// Returns a list of the operations of this service that have been discovered by Application Signals. Only the operations that were invoked during the specified time range are returned.
    @Sendable
    @inlinable
    public func listServiceOperations(_ input: ListServiceOperationsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListServiceOperationsOutput {
        try await self.client.execute(
            operation: "ListServiceOperations", 
            path: "/service-operations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the operations of this service that have been discovered by Application Signals. Only the operations that were invoked during the specified time range are returned.
    ///
    /// Parameters:
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested end time will be rounded to the nearest hour.
    ///   - keyAttributes: Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - nextToken: Include this value, if it was returned by the previous operation, to get the next set of service operations.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger use during operation
    @inlinable
    public func listServiceOperations(
        endTime: Date,
        keyAttributes: [String: String],
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListServiceOperationsOutput {
        let input = ListServiceOperationsInput(
            endTime: endTime, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime
        )
        return try await self.listServiceOperations(input, logger: logger)
    }

    /// Returns a list of services that have been discovered by Application Signals.  A service represents a minimum logical and transactional unit that completes a business function. Services are discovered through Application Signals instrumentation.
    @Sendable
    @inlinable
    public func listServices(_ input: ListServicesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListServicesOutput {
        try await self.client.execute(
            operation: "ListServices", 
            path: "/services", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of services that have been discovered by Application Signals.  A service represents a minimum logical and transactional unit that completes a business function. Services are discovered through Application Signals instrumentation.
    ///
    /// Parameters:
    ///   - awsAccountId: Amazon Web Services Account ID.
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - includeLinkedAccounts: If you are using this operation in a monitoring account, specify true to include services from source accounts in the returned data.
    ///   - maxResults:  The maximum number  of results  to return  in one operation.  If you omit this parameter,  the default of 50 is used.
    ///   - nextToken: Include this value, if it was returned by the previous operation, to get the next set of services.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger use during operation
    @inlinable
    public func listServices(
        awsAccountId: String? = nil,
        endTime: Date,
        includeLinkedAccounts: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListServicesOutput {
        let input = ListServicesInput(
            awsAccountId: awsAccountId, 
            endTime: endTime, 
            includeLinkedAccounts: includeLinkedAccounts, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startTime: startTime
        )
        return try await self.listServices(input, logger: logger)
    }

    /// Displays the tags associated with a CloudWatch resource. Tags can be assigned to service level objectives.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Displays the tags associated with a CloudWatch resource. Tags can be assigned to service level objectives.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the CloudWatch resource that you want to view tags for. The ARN format of an Application Signals SLO is  arn:aws:cloudwatch:Region:account-id:slo:slo-name   For more information about ARN format, see  Resource Types Defined by Amazon CloudWatch in the Amazon Web Services General Reference.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Enables this Amazon Web Services account to be able to use CloudWatch Application Signals  by creating the AWSServiceRoleForCloudWatchApplicationSignals service-linked role. This service- linked role has the following permissions:    xray:GetServiceGraph     logs:StartQuery     logs:GetQueryResults     cloudwatch:GetMetricData     cloudwatch:ListMetrics     tag:GetResources     autoscaling:DescribeAutoScalingGroups    After completing this step, you still need to instrument your Java and Python applications to send data  to Application Signals. For more information, see   Enabling Application Signals.
    @Sendable
    @inlinable
    public func startDiscovery(_ input: StartDiscoveryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> StartDiscoveryOutput {
        try await self.client.execute(
            operation: "StartDiscovery", 
            path: "/start-discovery", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables this Amazon Web Services account to be able to use CloudWatch Application Signals  by creating the AWSServiceRoleForCloudWatchApplicationSignals service-linked role. This service- linked role has the following permissions:    xray:GetServiceGraph     logs:StartQuery     logs:GetQueryResults     cloudwatch:GetMetricData     cloudwatch:ListMetrics     tag:GetResources     autoscaling:DescribeAutoScalingGroups    After completing this step, you still need to instrument your Java and Python applications to send data  to Application Signals. For more information, see   Enabling Application Signals.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func startDiscovery(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartDiscoveryOutput {
        let input = StartDiscoveryInput(
        )
        return try await self.startDiscovery(input, logger: logger)
    }

    /// Assigns one or more tags (key-value pairs) to the specified CloudWatch resource, such as a service level objective. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can use the TagResource action with an alarm that already has tags. If you specify a new tag key for the alarm,  this tag is appended to the list of tags associated with the alarm. If you specify a tag key that is already associated with the alarm, the new tag value that you specify replaces the previous value for that tag. You can associate as many as 50 tags with a CloudWatch resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tag-resource", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Assigns one or more tags (key-value pairs) to the specified CloudWatch resource, such as a service level objective. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can use the TagResource action with an alarm that already has tags. If you specify a new tag key for the alarm,  this tag is appended to the list of tags associated with the alarm. If you specify a tag key that is already associated with the alarm, the new tag value that you specify replaces the previous value for that tag. You can associate as many as 50 tags with a CloudWatch resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the CloudWatch resource that you want to set tags for. The ARN format of an Application Signals SLO is  arn:aws:cloudwatch:Region:account-id:slo:slo-name   For more information about ARN format, see  Resource Types Defined by Amazon CloudWatch in the Amazon Web Services General Reference.
    ///   - tags: The list of key-value pairs to associate with the alarm.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes one or more tags from the specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/untag-resource", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes one or more tags from the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the CloudWatch resource that you want to delete tags from. The ARN format of an Application Signals SLO is  arn:aws:cloudwatch:Region:account-id:slo:slo-name   For more information about ARN format, see  Resource Types Defined by Amazon CloudWatch in the Amazon Web Services General Reference.
    ///   - tagKeys: The list of tag keys to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates an existing service level objective (SLO). If you omit parameters, the previous values of those parameters are retained.  You cannot change from a period-based SLO to a request-based SLO,  or change from a request-based SLO to a period-based SLO.
    @Sendable
    @inlinable
    public func updateServiceLevelObjective(_ input: UpdateServiceLevelObjectiveInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateServiceLevelObjectiveOutput {
        try await self.client.execute(
            operation: "UpdateServiceLevelObjective", 
            path: "/slo/{Id}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing service level objective (SLO). If you omit parameters, the previous values of those parameters are retained.  You cannot change from a period-based SLO to a request-based SLO,  or change from a request-based SLO to a period-based SLO.
    ///
    /// Parameters:
    ///   - burnRateConfigurations: Use this array to create burn rates for this SLO. Each  burn rate is a metric that indicates how fast the service is consuming the error budget, relative to the attainment goal of the SLO.
    ///   - description: An optional description for the SLO.
    ///   - goal: A structure that contains the attributes that determine the goal of the SLO. This includes the time period for evaluation and the attainment threshold.
    ///   - id: The Amazon Resource Name (ARN) or name of the service level objective that you want to update.
    ///   - requestBasedSliConfig: If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both SliConfig and RequestBasedSliConfig in the same operation.
    ///   - sliConfig: If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateServiceLevelObjective(
        burnRateConfigurations: [BurnRateConfiguration]? = nil,
        description: String? = nil,
        goal: Goal? = nil,
        id: String,
        requestBasedSliConfig: RequestBasedServiceLevelIndicatorConfig? = nil,
        sliConfig: ServiceLevelIndicatorConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateServiceLevelObjectiveOutput {
        let input = UpdateServiceLevelObjectiveInput(
            burnRateConfigurations: burnRateConfigurations, 
            description: description, 
            goal: goal, 
            id: id, 
            requestBasedSliConfig: requestBasedSliConfig, 
            sliConfig: sliConfig
        )
        return try await self.updateServiceLevelObjective(input, logger: logger)
    }
}

extension ApplicationSignals {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: ApplicationSignals, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ApplicationSignals {
    /// Return PaginatorSequence for operation ``listServiceDependencies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceDependenciesPaginator(
        _ input: ListServiceDependenciesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListServiceDependenciesInput, ListServiceDependenciesOutput> {
        return .init(
            input: input,
            command: self.listServiceDependencies,
            inputKey: \ListServiceDependenciesInput.nextToken,
            outputKey: \ListServiceDependenciesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listServiceDependencies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested end time will be rounded to the nearest hour.
    ///   - keyAttributes: Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceDependenciesPaginator(
        endTime: Date,
        keyAttributes: [String: String],
        maxResults: Int? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListServiceDependenciesInput, ListServiceDependenciesOutput> {
        let input = ListServiceDependenciesInput(
            endTime: endTime, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            startTime: startTime
        )
        return self.listServiceDependenciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listServiceDependents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceDependentsPaginator(
        _ input: ListServiceDependentsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListServiceDependentsInput, ListServiceDependentsOutput> {
        return .init(
            input: input,
            command: self.listServiceDependents,
            inputKey: \ListServiceDependentsInput.nextToken,
            outputKey: \ListServiceDependentsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listServiceDependents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - keyAttributes: Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceDependentsPaginator(
        endTime: Date,
        keyAttributes: [String: String],
        maxResults: Int? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListServiceDependentsInput, ListServiceDependentsOutput> {
        let input = ListServiceDependentsInput(
            endTime: endTime, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            startTime: startTime
        )
        return self.listServiceDependentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listServiceLevelObjectiveExclusionWindows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceLevelObjectiveExclusionWindowsPaginator(
        _ input: ListServiceLevelObjectiveExclusionWindowsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListServiceLevelObjectiveExclusionWindowsInput, ListServiceLevelObjectiveExclusionWindowsOutput> {
        return .init(
            input: input,
            command: self.listServiceLevelObjectiveExclusionWindows,
            inputKey: \ListServiceLevelObjectiveExclusionWindowsInput.nextToken,
            outputKey: \ListServiceLevelObjectiveExclusionWindowsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listServiceLevelObjectiveExclusionWindows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - id: The ID of the SLO to list exclusion windows for.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceLevelObjectiveExclusionWindowsPaginator(
        id: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListServiceLevelObjectiveExclusionWindowsInput, ListServiceLevelObjectiveExclusionWindowsOutput> {
        let input = ListServiceLevelObjectiveExclusionWindowsInput(
            id: id, 
            maxResults: maxResults
        )
        return self.listServiceLevelObjectiveExclusionWindowsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listServiceLevelObjectives(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceLevelObjectivesPaginator(
        _ input: ListServiceLevelObjectivesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListServiceLevelObjectivesInput, ListServiceLevelObjectivesOutput> {
        return .init(
            input: input,
            command: self.listServiceLevelObjectives,
            inputKey: \ListServiceLevelObjectivesInput.nextToken,
            outputKey: \ListServiceLevelObjectivesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listServiceLevelObjectives(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dependencyConfig: Identifies the dependency using the DependencyKeyAttributes and DependencyOperationName.
    ///   - includeLinkedAccounts: If you are using this operation in a monitoring account, specify true to include SLO from source accounts in the returned data.   When you are monitoring an account, you can use Amazon Web Services account ID in KeyAttribute filter for service source account and SloOwnerawsaccountID for SLO source account with IncludeLinkedAccounts to filter the returned data to only a single source account.
    ///   - keyAttributes: You can use this optional field to specify which services you want to retrieve SLO information for. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - metricSourceTypes: Use this optional field to only include SLOs with the specified metric source types in the output. Supported types are:   Service operation   Service dependency   CloudWatch metric
    ///   - operationName: The name of the operation that this SLO is associated with.
    ///   - sloOwnerAwsAccountId: SLO's Amazon Web Services account ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceLevelObjectivesPaginator(
        dependencyConfig: DependencyConfig? = nil,
        includeLinkedAccounts: Bool? = nil,
        keyAttributes: [String: String]? = nil,
        maxResults: Int? = nil,
        metricSourceTypes: [MetricSourceType]? = nil,
        operationName: String? = nil,
        sloOwnerAwsAccountId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListServiceLevelObjectivesInput, ListServiceLevelObjectivesOutput> {
        let input = ListServiceLevelObjectivesInput(
            dependencyConfig: dependencyConfig, 
            includeLinkedAccounts: includeLinkedAccounts, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            metricSourceTypes: metricSourceTypes, 
            operationName: operationName, 
            sloOwnerAwsAccountId: sloOwnerAwsAccountId
        )
        return self.listServiceLevelObjectivesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listServiceOperations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceOperationsPaginator(
        _ input: ListServiceOperationsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListServiceOperationsInput, ListServiceOperationsOutput> {
        return .init(
            input: input,
            command: self.listServiceOperations,
            inputKey: \ListServiceOperationsInput.nextToken,
            outputKey: \ListServiceOperationsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listServiceOperations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested end time will be rounded to the nearest hour.
    ///   - keyAttributes: Use this field to specify which service you want to retrieve information for. You must specify at least the Type,  Name, and Environment attributes. This is a string-to-string map. It can  include the following fields.    Type designates the type of object this is.    ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.    Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.    Identifier identifies the resource objects of this resource.  This is used only if the value of the Type field is Resource or AWS::Resource.    Environment specifies the location where this object is hosted, or what it belongs to.
    ///   - maxResults: The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger used for logging
    @inlinable
    public func listServiceOperationsPaginator(
        endTime: Date,
        keyAttributes: [String: String],
        maxResults: Int? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListServiceOperationsInput, ListServiceOperationsOutput> {
        let input = ListServiceOperationsInput(
            endTime: endTime, 
            keyAttributes: keyAttributes, 
            maxResults: maxResults, 
            startTime: startTime
        )
        return self.listServiceOperationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listServices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listServicesPaginator(
        _ input: ListServicesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListServicesInput, ListServicesOutput> {
        return .init(
            input: input,
            command: self.listServices,
            inputKey: \ListServicesInput.nextToken,
            outputKey: \ListServicesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listServices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - awsAccountId: Amazon Web Services Account ID.
    ///   - endTime: The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - includeLinkedAccounts: If you are using this operation in a monitoring account, specify true to include services from source accounts in the returned data.
    ///   - maxResults:  The maximum number  of results  to return  in one operation.  If you omit this parameter,  the default of 50 is used.
    ///   - startTime: The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as  be epoch time in seconds. For example: 1698778057  Your requested start time will be rounded to the nearest hour.
    ///   - logger: Logger used for logging
    @inlinable
    public func listServicesPaginator(
        awsAccountId: String? = nil,
        endTime: Date,
        includeLinkedAccounts: Bool? = nil,
        maxResults: Int? = nil,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListServicesInput, ListServicesOutput> {
        let input = ListServicesInput(
            awsAccountId: awsAccountId, 
            endTime: endTime, 
            includeLinkedAccounts: includeLinkedAccounts, 
            maxResults: maxResults, 
            startTime: startTime
        )
        return self.listServicesPaginator(input, logger: logger)
    }
}

extension ApplicationSignals.ListServiceDependenciesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ApplicationSignals.ListServiceDependenciesInput {
        return .init(
            endTime: self.endTime,
            keyAttributes: self.keyAttributes,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )
    }
}

extension ApplicationSignals.ListServiceDependentsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ApplicationSignals.ListServiceDependentsInput {
        return .init(
            endTime: self.endTime,
            keyAttributes: self.keyAttributes,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )
    }
}

extension ApplicationSignals.ListServiceLevelObjectiveExclusionWindowsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ApplicationSignals.ListServiceLevelObjectiveExclusionWindowsInput {
        return .init(
            id: self.id,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ApplicationSignals.ListServiceLevelObjectivesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ApplicationSignals.ListServiceLevelObjectivesInput {
        return .init(
            dependencyConfig: self.dependencyConfig,
            includeLinkedAccounts: self.includeLinkedAccounts,
            keyAttributes: self.keyAttributes,
            maxResults: self.maxResults,
            metricSourceTypes: self.metricSourceTypes,
            nextToken: token,
            operationName: self.operationName,
            sloOwnerAwsAccountId: self.sloOwnerAwsAccountId
        )
    }
}

extension ApplicationSignals.ListServiceOperationsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ApplicationSignals.ListServiceOperationsInput {
        return .init(
            endTime: self.endTime,
            keyAttributes: self.keyAttributes,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )
    }
}

extension ApplicationSignals.ListServicesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ApplicationSignals.ListServicesInput {
        return .init(
            awsAccountId: self.awsAccountId,
            endTime: self.endTime,
            includeLinkedAccounts: self.includeLinkedAccounts,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )
    }
}
