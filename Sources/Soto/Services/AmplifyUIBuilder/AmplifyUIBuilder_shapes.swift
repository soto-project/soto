//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AmplifyUIBuilder {
    // MARK: Enums

    public enum CodegenGenericDataFieldDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `enum` = "Enum"
        case awsDate = "AWSDate"
        case awsDateTime = "AWSDateTime"
        case awsEmail = "AWSEmail"
        case awsIpAddress = "AWSIPAddress"
        case awsJson = "AWSJSON"
        case awsPhone = "AWSPhone"
        case awsTime = "AWSTime"
        case awsTimestamp = "AWSTimestamp"
        case awsUrl = "AWSURL"
        case boolean = "Boolean"
        case float = "Float"
        case id = "ID"
        case int = "Int"
        case model = "Model"
        case nonModel = "NonModel"
        case string = "String"
        public var description: String { return self.rawValue }
    }

    public enum CodegenJobGenericDataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataStore = "DataStore"
        public var description: String { return self.rawValue }
    }

    public enum CodegenJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "failed"
        case inProgress = "in_progress"
        case succeeded = "succeeded"
        public var description: String { return self.rawValue }
    }

    public enum FixedPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case first = "first"
        public var description: String { return self.rawValue }
    }

    public enum FormActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "create"
        case update = "update"
        public var description: String { return self.rawValue }
    }

    public enum FormButtonsPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottom = "bottom"
        case top = "top"
        case topAndBottom = "top_and_bottom"
        public var description: String { return self.rawValue }
    }

    public enum FormDataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Will use passed in hooks to use when creating a form from scratch
        case custom = "Custom"
        /// Will use a provided Amplify DataStore enabled API
        case dataStore = "DataStore"
        public var description: String { return self.rawValue }
    }

    public enum GenericDataRelationshipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case belongsTo = "BELONGS_TO"
        case hasMany = "HAS_MANY"
        case hasOne = "HAS_ONE"
        public var description: String { return self.rawValue }
    }

    public enum JSModule: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case es2020 = "es2020"
        case esnext = "esnext"
        public var description: String { return self.rawValue }
    }

    public enum JSScript: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case js = "js"
        case jsx = "jsx"
        case tsx = "tsx"
        public var description: String { return self.rawValue }
    }

    public enum JSTarget: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case es2015 = "es2015"
        case es2020 = "es2020"
        public var description: String { return self.rawValue }
    }

    public enum LabelDecorator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "none"
        case optional = "optional"
        case required = "required"
        public var description: String { return self.rawValue }
    }

    public enum SortDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum StorageAccessLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "private"
        case `public` = "public"
        case protected = "protected"
        public var description: String { return self.rawValue }
    }

    public enum TokenProviders: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The figma token provider.
        case figma = "figma"
        public var description: String { return self.rawValue }
    }

    public enum ApiConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration for an application using DataStore APIs.
        case dataStoreConfig(DataStoreRenderConfig)
        /// The configuration for an application using GraphQL APIs.
        case graphQLConfig(GraphQLRenderConfig)
        /// The configuration for an application with no API being used.
        case noApiConfig(NoApiRenderConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dataStoreConfig:
                let value = try container.decode(DataStoreRenderConfig.self, forKey: .dataStoreConfig)
                self = .dataStoreConfig(value)
            case .graphQLConfig:
                let value = try container.decode(GraphQLRenderConfig.self, forKey: .graphQLConfig)
                self = .graphQLConfig(value)
            case .noApiConfig:
                let value = try container.decode(NoApiRenderConfig.self, forKey: .noApiConfig)
                self = .noApiConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dataStoreConfig(let value):
                try container.encode(value, forKey: .dataStoreConfig)
            case .graphQLConfig(let value):
                try container.encode(value, forKey: .graphQLConfig)
            case .noApiConfig(let value):
                try container.encode(value, forKey: .noApiConfig)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dataStoreConfig = "dataStoreConfig"
            case graphQLConfig = "graphQLConfig"
            case noApiConfig = "noApiConfig"
        }
    }

    public enum FieldPosition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The field position is below the field specified by the string.
        case below(String)
        /// The field position is fixed and doesn't change in relation to other fields.
        case fixed(FixedPosition)
        /// The field position is to the right of the field specified by the string.
        case rightOf(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .below:
                let value = try container.decode(String.self, forKey: .below)
                self = .below(value)
            case .fixed:
                let value = try container.decode(FixedPosition.self, forKey: .fixed)
                self = .fixed(value)
            case .rightOf:
                let value = try container.decode(String.self, forKey: .rightOf)
                self = .rightOf(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .below(let value):
                try container.encode(value, forKey: .below)
            case .fixed(let value):
                try container.encode(value, forKey: .fixed)
            case .rightOf(let value):
                try container.encode(value, forKey: .rightOf)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case below = "below"
            case fixed = "fixed"
            case rightOf = "rightOf"
        }
    }

    public enum FormStyleConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A reference to a design token to use to bind the form's style properties to an existing theme.
        case tokenReference(String)
        /// The value of the style setting.
        case value(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .tokenReference:
                let value = try container.decode(String.self, forKey: .tokenReference)
                self = .tokenReference(value)
            case .value:
                let value = try container.decode(String.self, forKey: .value)
                self = .value(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .tokenReference(let value):
                try container.encode(value, forKey: .tokenReference)
            case .value(let value):
                try container.encode(value, forKey: .value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tokenReference = "tokenReference"
            case value = "value"
        }
    }

    // MARK: Shapes

    public struct ActionParameters: AWSEncodableShape & AWSDecodableShape {
        /// The HTML anchor link to the location to open. Specify this value for a navigation action.
        public let anchor: ComponentProperty?
        /// A dictionary of key-value pairs mapping Amplify Studio properties to fields in a data model. Use when the action performs an operation on an Amplify DataStore model.
        public let fields: [String: ComponentProperty]?
        /// Specifies whether the user should be signed out globally. Specify this value for an auth sign out action.
        public let global: ComponentProperty?
        /// The unique ID of the component that the ActionParameters apply to.
        public let id: ComponentProperty?
        /// The name of the data model. Use when the action performs an operation on an Amplify DataStore model.
        public let model: String?
        /// A key-value pair that specifies the state property name and its initial value.
        public let state: MutationActionSetStateParameter?
        /// The element within the same component to modify when the action occurs.
        public let target: ComponentProperty?
        /// The type of navigation action. Valid values are url and anchor. This value is required for a navigation action.
        public let type: ComponentProperty?
        /// The URL to the location to open. Specify this value for a navigation action.
        public let url: ComponentProperty?

        @inlinable
        public init(anchor: ComponentProperty? = nil, fields: [String: ComponentProperty]? = nil, global: ComponentProperty? = nil, id: ComponentProperty? = nil, model: String? = nil, state: MutationActionSetStateParameter? = nil, target: ComponentProperty? = nil, type: ComponentProperty? = nil, url: ComponentProperty? = nil) {
            self.anchor = anchor
            self.fields = fields
            self.global = global
            self.id = id
            self.model = model
            self.state = state
            self.target = target
            self.type = type
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case anchor = "anchor"
            case fields = "fields"
            case global = "global"
            case id = "id"
            case model = "model"
            case state = "state"
            case target = "target"
            case type = "type"
            case url = "url"
        }
    }

    public struct CodegenDependency: AWSDecodableShape {
        /// Determines if the dependency package is using Semantic versioning. If set to true, it indicates that the dependency package uses Semantic versioning.
        public let isSemVer: Bool?
        /// Name of the dependency package.
        public let name: String?
        /// Indicates the reason to include the dependency package in your project code.
        public let reason: String?
        /// Indicates the version of the supported dependency package.
        public let supportedVersion: String?

        @inlinable
        public init(isSemVer: Bool? = nil, name: String? = nil, reason: String? = nil, supportedVersion: String? = nil) {
            self.isSemVer = isSemVer
            self.name = name
            self.reason = reason
            self.supportedVersion = supportedVersion
        }

        private enum CodingKeys: String, CodingKey {
            case isSemVer = "isSemVer"
            case name = "name"
            case reason = "reason"
            case supportedVersion = "supportedVersion"
        }
    }

    public struct CodegenFeatureFlags: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether a code generation job supports non models.
        public let isNonModelSupported: Bool?
        /// Specifes whether a code generation job supports data relationships.
        public let isRelationshipSupported: Bool?

        @inlinable
        public init(isNonModelSupported: Bool? = nil, isRelationshipSupported: Bool? = nil) {
            self.isNonModelSupported = isNonModelSupported
            self.isRelationshipSupported = isRelationshipSupported
        }

        private enum CodingKeys: String, CodingKey {
            case isNonModelSupported = "isNonModelSupported"
            case isRelationshipSupported = "isRelationshipSupported"
        }
    }

    public struct CodegenGenericDataEnum: AWSEncodableShape & AWSDecodableShape {
        /// The list of enum values in the generic data schema.
        public let values: [String]

        @inlinable
        public init(values: [String]) {
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case values = "values"
        }
    }

    public struct CodegenGenericDataField: AWSEncodableShape & AWSDecodableShape {
        /// The data type for the generic data field.
        public let dataType: CodegenGenericDataFieldDataType
        /// The value of the data type for the generic data field.
        public let dataTypeValue: String
        /// Specifies whether the generic data field is an array.
        public let isArray: Bool
        /// Specifies whether the generic data field is read-only.
        public let readOnly: Bool
        /// The relationship of the generic data schema.
        public let relationship: CodegenGenericDataRelationshipType?
        /// Specifies whether the generic data field is required.
        public let required: Bool

        @inlinable
        public init(dataType: CodegenGenericDataFieldDataType, dataTypeValue: String, isArray: Bool, readOnly: Bool, relationship: CodegenGenericDataRelationshipType? = nil, required: Bool) {
            self.dataType = dataType
            self.dataTypeValue = dataTypeValue
            self.isArray = isArray
            self.readOnly = readOnly
            self.relationship = relationship
            self.required = required
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case dataTypeValue = "dataTypeValue"
            case isArray = "isArray"
            case readOnly = "readOnly"
            case relationship = "relationship"
            case required = "required"
        }
    }

    public struct CodegenGenericDataModel: AWSEncodableShape & AWSDecodableShape {
        /// The fields in the generic data model.
        public let fields: [String: CodegenGenericDataField]
        /// Specifies whether the generic data model is a join table.
        public let isJoinTable: Bool?
        /// The primary keys of the generic data model.
        public let primaryKeys: [String]

        @inlinable
        public init(fields: [String: CodegenGenericDataField], isJoinTable: Bool? = nil, primaryKeys: [String]) {
            self.fields = fields
            self.isJoinTable = isJoinTable
            self.primaryKeys = primaryKeys
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case isJoinTable = "isJoinTable"
            case primaryKeys = "primaryKeys"
        }
    }

    public struct CodegenGenericDataNonModel: AWSEncodableShape & AWSDecodableShape {
        /// The fields in a generic data schema non model.
        public let fields: [String: CodegenGenericDataField]

        @inlinable
        public init(fields: [String: CodegenGenericDataField]) {
            self.fields = fields
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
        }
    }

    public struct CodegenGenericDataRelationshipType: AWSEncodableShape & AWSDecodableShape {
        /// The associated fields of the data relationship.
        public let associatedFields: [String]?
        /// The value of the belongsTo field on the related data model.
        public let belongsToFieldOnRelatedModel: String?
        /// Specifies whether the relationship can unlink the associated model.
        public let canUnlinkAssociatedModel: Bool?
        /// Specifies whether the @index directive is supported for a hasMany data relationship.
        public let isHasManyIndex: Bool?
        /// The name of the related join field in the data relationship.
        public let relatedJoinFieldName: String?
        /// The name of the related join table in the data relationship.
        public let relatedJoinTableName: String?
        /// The related model fields in the data relationship.
        public let relatedModelFields: [String]?
        /// The name of the related model in the data relationship.
        public let relatedModelName: String
        /// The data relationship type.
        public let type: GenericDataRelationshipType

        @inlinable
        public init(associatedFields: [String]? = nil, belongsToFieldOnRelatedModel: String? = nil, canUnlinkAssociatedModel: Bool? = nil, isHasManyIndex: Bool? = nil, relatedJoinFieldName: String? = nil, relatedJoinTableName: String? = nil, relatedModelFields: [String]? = nil, relatedModelName: String, type: GenericDataRelationshipType) {
            self.associatedFields = associatedFields
            self.belongsToFieldOnRelatedModel = belongsToFieldOnRelatedModel
            self.canUnlinkAssociatedModel = canUnlinkAssociatedModel
            self.isHasManyIndex = isHasManyIndex
            self.relatedJoinFieldName = relatedJoinFieldName
            self.relatedJoinTableName = relatedJoinTableName
            self.relatedModelFields = relatedModelFields
            self.relatedModelName = relatedModelName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case associatedFields = "associatedFields"
            case belongsToFieldOnRelatedModel = "belongsToFieldOnRelatedModel"
            case canUnlinkAssociatedModel = "canUnlinkAssociatedModel"
            case isHasManyIndex = "isHasManyIndex"
            case relatedJoinFieldName = "relatedJoinFieldName"
            case relatedJoinTableName = "relatedJoinTableName"
            case relatedModelFields = "relatedModelFields"
            case relatedModelName = "relatedModelName"
            case type = "type"
        }
    }

    public struct CodegenJob: AWSDecodableShape {
        /// The ID of the Amplify app associated with the code generation job.
        public let appId: String
        /// The CodegenJobAsset to use for the code generation job.
        public let asset: CodegenJobAsset?
        /// Specifies whether to autogenerate forms in the code generation job.
        public let autoGenerateForms: Bool?
        /// The time that the code generation job was created.
        public let createdAt: Date?
        /// Lists the dependency packages that may be required for the project code to run.
        public let dependencies: [CodegenDependency]?
        /// The name of the backend environment associated with the code generation job.
        public let environmentName: String
        public let features: CodegenFeatureFlags?
        public let genericDataSchema: CodegenJobGenericDataSchema?
        /// The unique ID for the code generation job.
        public let id: String
        /// The time that the code generation job was modified.
        public let modifiedAt: Date?
        public let renderConfig: CodegenJobRenderConfig?
        /// The status of the code generation job.
        public let status: CodegenJobStatus?
        /// The customized status message for the code generation job.
        public let statusMessage: String?
        /// One or more key-value pairs to use when tagging the code generation job.
        public let tags: [String: String]?

        @inlinable
        public init(appId: String, asset: CodegenJobAsset? = nil, autoGenerateForms: Bool? = nil, createdAt: Date? = nil, dependencies: [CodegenDependency]? = nil, environmentName: String, features: CodegenFeatureFlags? = nil, genericDataSchema: CodegenJobGenericDataSchema? = nil, id: String, modifiedAt: Date? = nil, renderConfig: CodegenJobRenderConfig? = nil, status: CodegenJobStatus? = nil, statusMessage: String? = nil, tags: [String: String]? = nil) {
            self.appId = appId
            self.asset = asset
            self.autoGenerateForms = autoGenerateForms
            self.createdAt = createdAt
            self.dependencies = dependencies
            self.environmentName = environmentName
            self.features = features
            self.genericDataSchema = genericDataSchema
            self.id = id
            self.modifiedAt = modifiedAt
            self.renderConfig = renderConfig
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case asset = "asset"
            case autoGenerateForms = "autoGenerateForms"
            case createdAt = "createdAt"
            case dependencies = "dependencies"
            case environmentName = "environmentName"
            case features = "features"
            case genericDataSchema = "genericDataSchema"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case renderConfig = "renderConfig"
            case status = "status"
            case statusMessage = "statusMessage"
            case tags = "tags"
        }
    }

    public struct CodegenJobAsset: AWSDecodableShape {
        /// The URL to use to access the asset.
        public let downloadUrl: String?

        @inlinable
        public init(downloadUrl: String? = nil) {
            self.downloadUrl = downloadUrl
        }

        private enum CodingKeys: String, CodingKey {
            case downloadUrl = "downloadUrl"
        }
    }

    public struct CodegenJobGenericDataSchema: AWSEncodableShape & AWSDecodableShape {
        /// The type of the data source for the schema. Currently, the only valid value is an Amplify DataStore.
        public let dataSourceType: CodegenJobGenericDataSourceType
        /// The name of a CodegenGenericDataEnum.
        public let enums: [String: CodegenGenericDataEnum]
        /// The name of a CodegenGenericDataModel.
        public let models: [String: CodegenGenericDataModel]
        /// The name of a CodegenGenericDataNonModel.
        public let nonModels: [String: CodegenGenericDataNonModel]

        @inlinable
        public init(dataSourceType: CodegenJobGenericDataSourceType, enums: [String: CodegenGenericDataEnum], models: [String: CodegenGenericDataModel], nonModels: [String: CodegenGenericDataNonModel]) {
            self.dataSourceType = dataSourceType
            self.enums = enums
            self.models = models
            self.nonModels = nonModels
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType = "dataSourceType"
            case enums = "enums"
            case models = "models"
            case nonModels = "nonModels"
        }
    }

    public struct CodegenJobSummary: AWSDecodableShape {
        /// The unique ID of the Amplify app associated with the code generation job.
        public let appId: String
        /// The time that the code generation job summary was created.
        public let createdAt: Date?
        /// The name of the backend environment associated with the code generation job.
        public let environmentName: String
        /// The unique ID for the code generation job summary.
        public let id: String
        /// The time that the code generation job summary was modified.
        public let modifiedAt: Date?

        @inlinable
        public init(appId: String, createdAt: Date? = nil, environmentName: String, id: String, modifiedAt: Date? = nil) {
            self.appId = appId
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.id = id
            self.modifiedAt = modifiedAt
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case createdAt = "createdAt"
            case environmentName = "environmentName"
            case id = "id"
            case modifiedAt = "modifiedAt"
        }
    }

    public struct Component: AWSDecodableShape {
        /// The unique ID of the Amplify app associated with the component.
        public let appId: String
        /// The information to connect a component's properties to data at runtime. You can't specify tags as a valid property for bindingProperties.
        public let bindingProperties: [String: ComponentBindingPropertiesValue]
        /// A list of the component's ComponentChild instances.
        public let children: [ComponentChild]?
        /// The data binding configuration for the component's properties. Use this for a collection component. You can't specify tags as a valid property for collectionProperties.
        public let collectionProperties: [String: ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        public let componentType: String
        /// The time that the component was created.
        public let createdAt: Date
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// Describes the events that can be raised on the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public let events: [String: ComponentEvent]?
        /// The unique ID of the component.
        public let id: String
        /// The time that the component was modified.
        public let modifiedAt: Date?
        /// The name of the component.
        public let name: String
        /// Describes the component's properties that can be overriden in a customized instance of the component. You can't specify tags as a valid property for overrides.
        public let overrides: [String: [String: String]]
        /// Describes the component's properties. You can't specify tags as a valid property for properties.
        public let properties: [String: ComponentProperty]
        /// The schema version of the component when it was imported.
        public let schemaVersion: String?
        /// The unique ID of the component in its original source system, such as Figma.
        public let sourceId: String?
        /// One or more key-value pairs to use when tagging the component.
        public let tags: [String: String]?
        /// A list of the component's variants. A variant is a unique style configuration of a main component.
        public let variants: [ComponentVariant]

        @inlinable
        public init(appId: String, bindingProperties: [String: ComponentBindingPropertiesValue], children: [ComponentChild]? = nil, collectionProperties: [String: ComponentDataConfiguration]? = nil, componentType: String, createdAt: Date, environmentName: String, events: [String: ComponentEvent]? = nil, id: String, modifiedAt: Date? = nil, name: String, overrides: [String: [String: String]], properties: [String: ComponentProperty], schemaVersion: String? = nil, sourceId: String? = nil, tags: [String: String]? = nil, variants: [ComponentVariant]) {
            self.appId = appId
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.events = events
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case bindingProperties = "bindingProperties"
            case children = "children"
            case collectionProperties = "collectionProperties"
            case componentType = "componentType"
            case createdAt = "createdAt"
            case environmentName = "environmentName"
            case events = "events"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case overrides = "overrides"
            case properties = "properties"
            case schemaVersion = "schemaVersion"
            case sourceId = "sourceId"
            case tags = "tags"
            case variants = "variants"
        }
    }

    public struct ComponentBindingPropertiesValue: AWSEncodableShape & AWSDecodableShape {
        /// Describes the properties to customize with data at runtime.
        public let bindingProperties: ComponentBindingPropertiesValueProperties?
        /// The default value of the property.
        public let defaultValue: String?
        /// The property type.
        public let type: String?

        @inlinable
        public init(bindingProperties: ComponentBindingPropertiesValueProperties? = nil, defaultValue: String? = nil, type: String? = nil) {
            self.bindingProperties = bindingProperties
            self.defaultValue = defaultValue
            self.type = type
        }

        public func validate(name: String) throws {
            try self.bindingProperties?.validate(name: "\(name).bindingProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case bindingProperties = "bindingProperties"
            case defaultValue = "defaultValue"
            case type = "type"
        }
    }

    public struct ComponentBindingPropertiesValueProperties: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon S3 bucket.
        public let bucket: String?
        /// The default value to assign to the property.
        public let defaultValue: String?
        /// The field to bind the data to.
        public let field: String?
        /// The storage key for an Amazon S3 bucket.
        public let key: String?
        /// An Amplify DataStore model.
        public let model: String?
        /// A list of predicates for binding a component's properties to data.
        public let predicates: [Predicate]?
        /// The name of a component slot.
        public let slotName: String?
        /// An authenticated user attribute.
        public let userAttribute: String?

        @inlinable
        public init(bucket: String? = nil, defaultValue: String? = nil, field: String? = nil, key: String? = nil, model: String? = nil, predicates: [Predicate]? = nil, slotName: String? = nil, userAttribute: String? = nil) {
            self.bucket = bucket
            self.defaultValue = defaultValue
            self.field = field
            self.key = key
            self.model = model
            self.predicates = predicates
            self.slotName = slotName
            self.userAttribute = userAttribute
        }

        public func validate(name: String) throws {
            try self.predicates?.forEach {
                try $0.validate(name: "\(name).predicates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case defaultValue = "defaultValue"
            case field = "field"
            case key = "key"
            case model = "model"
            case predicates = "predicates"
            case slotName = "slotName"
            case userAttribute = "userAttribute"
        }
    }

    public struct ComponentChild: AWSEncodableShape & AWSDecodableShape {
        /// The list of ComponentChild instances for this component.
        public let children: [ComponentChild]?
        /// The type of the child component.
        public let componentType: String
        /// Describes the events that can be raised on the child component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public let events: [String: ComponentEvent]?
        /// The name of the child component.
        public let name: String
        /// Describes the properties of the child component. You can't specify tags as a valid property for properties.
        public let properties: [String: ComponentProperty]
        /// The unique ID of the child component in its original source system, such as Figma.
        public let sourceId: String?

        @inlinable
        public init(children: [ComponentChild]? = nil, componentType: String, events: [String: ComponentEvent]? = nil, name: String, properties: [String: ComponentProperty], sourceId: String? = nil) {
            self.children = children
            self.componentType = componentType
            self.events = events
            self.name = name
            self.properties = properties
            self.sourceId = sourceId
        }

        private enum CodingKeys: String, CodingKey {
            case children = "children"
            case componentType = "componentType"
            case events = "events"
            case name = "name"
            case properties = "properties"
            case sourceId = "sourceId"
        }
    }

    public final class ComponentConditionProperty: AWSEncodableShape & AWSDecodableShape {
        /// The value to assign to the property if the condition is not met.
        public let `else`: ComponentProperty?
        /// The name of a field. Specify this when the property is a data model.
        public let field: String?
        /// The value of the property to evaluate.
        public let operand: String?
        /// The type of the property to evaluate.
        public let operandType: String?
        /// The operator to use to perform the evaluation, such as eq to represent equals.
        public let `operator`: String?
        /// The name of the conditional property.
        public let property: String?
        /// The value to assign to the property if the condition is met.
        public let then: ComponentProperty?

        @inlinable
        public init(else: ComponentProperty? = nil, field: String? = nil, operand: String? = nil, operandType: String? = nil, operator: String? = nil, property: String? = nil, then: ComponentProperty? = nil) {
            self.`else` = `else`
            self.field = field
            self.operand = operand
            self.operandType = operandType
            self.`operator` = `operator`
            self.property = property
            self.then = then
        }

        private enum CodingKeys: String, CodingKey {
            case `else` = "else"
            case field = "field"
            case operand = "operand"
            case operandType = "operandType"
            case `operator` = "operator"
            case property = "property"
            case then = "then"
        }
    }

    public struct ComponentDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.
        public let identifiers: [String]?
        /// The name of the data model to use to bind data to a component.
        public let model: String
        /// Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.
        public let predicate: Predicate?
        /// Describes how to sort the component's properties.
        public let sort: [SortProperty]?

        @inlinable
        public init(identifiers: [String]? = nil, model: String, predicate: Predicate? = nil, sort: [SortProperty]? = nil) {
            self.identifiers = identifiers
            self.model = model
            self.predicate = predicate
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.predicate?.validate(name: "\(name).predicate")
        }

        private enum CodingKeys: String, CodingKey {
            case identifiers = "identifiers"
            case model = "model"
            case predicate = "predicate"
            case sort = "sort"
        }
    }

    public struct ComponentEvent: AWSEncodableShape & AWSDecodableShape {
        /// The action to perform when a specific event is raised.
        public let action: String?
        /// Binds an event to an action on a component. When you specify a bindingEvent, the event is called when the action is performed.
        public let bindingEvent: String?
        /// Describes information about the action.
        public let parameters: ActionParameters?

        @inlinable
        public init(action: String? = nil, bindingEvent: String? = nil, parameters: ActionParameters? = nil) {
            self.action = action
            self.bindingEvent = bindingEvent
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case bindingEvent = "bindingEvent"
            case parameters = "parameters"
        }
    }

    public final class ComponentProperty: AWSEncodableShape & AWSDecodableShape {
        /// The information to bind the component property to data at runtime.
        public let bindingProperties: ComponentPropertyBindingProperties?
        /// The information to bind the component property to form data.
        public let bindings: [String: FormBindingElement]?
        /// The information to bind the component property to data at runtime. Use this for collection components.
        public let collectionBindingProperties: ComponentPropertyBindingProperties?
        /// The name of the component that is affected by an event.
        public let componentName: String?
        /// A list of component properties to concatenate to create the value to assign to this component property.
        public let concat: [ComponentProperty]?
        /// The conditional expression to use to assign a value to the component property.
        public let condition: ComponentConditionProperty?
        /// Specifies whether the user configured the property in Amplify Studio after importing it.
        public let configured: Bool?
        /// The default value to assign to the component property.
        public let defaultValue: String?
        /// An event that occurs in your app. Use this for workflow data binding.
        public let event: String?
        /// The default value assigned to the property when the component is imported into an app.
        public let importedValue: String?
        /// The data model to use to assign a value to the component property.
        public let model: String?
        /// The name of the component's property that is affected by an event.
        public let property: String?
        /// The component type.
        public let type: String?
        /// An authenticated user attribute to use to assign a value to the component property.
        public let userAttribute: String?
        /// The value to assign to the component property.
        public let value: String?

        @inlinable
        public init(bindingProperties: ComponentPropertyBindingProperties? = nil, bindings: [String: FormBindingElement]? = nil, collectionBindingProperties: ComponentPropertyBindingProperties? = nil, componentName: String? = nil, concat: [ComponentProperty]? = nil, condition: ComponentConditionProperty? = nil, configured: Bool? = nil, defaultValue: String? = nil, event: String? = nil, importedValue: String? = nil, model: String? = nil, property: String? = nil, type: String? = nil, userAttribute: String? = nil, value: String? = nil) {
            self.bindingProperties = bindingProperties
            self.bindings = bindings
            self.collectionBindingProperties = collectionBindingProperties
            self.componentName = componentName
            self.concat = concat
            self.condition = condition
            self.configured = configured
            self.defaultValue = defaultValue
            self.event = event
            self.importedValue = importedValue
            self.model = model
            self.property = property
            self.type = type
            self.userAttribute = userAttribute
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case bindingProperties = "bindingProperties"
            case bindings = "bindings"
            case collectionBindingProperties = "collectionBindingProperties"
            case componentName = "componentName"
            case concat = "concat"
            case condition = "condition"
            case configured = "configured"
            case defaultValue = "defaultValue"
            case event = "event"
            case importedValue = "importedValue"
            case model = "model"
            case property = "property"
            case type = "type"
            case userAttribute = "userAttribute"
            case value = "value"
        }
    }

    public struct ComponentPropertyBindingProperties: AWSEncodableShape & AWSDecodableShape {
        /// The data field to bind the property to.
        public let field: String?
        /// The component property to bind to the data field.
        public let property: String

        @inlinable
        public init(field: String? = nil, property: String) {
            self.field = field
            self.property = property
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case property = "property"
        }
    }

    public struct ComponentSummary: AWSDecodableShape {
        /// The unique ID of the Amplify app associated with the component.
        public let appId: String
        /// The component type.
        public let componentType: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The unique ID of the component.
        public let id: String
        /// The name of the component.
        public let name: String

        @inlinable
        public init(appId: String, componentType: String, environmentName: String, id: String, name: String) {
            self.appId = appId
            self.componentType = componentType
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case componentType = "componentType"
            case environmentName = "environmentName"
            case id = "id"
            case name = "name"
        }
    }

    public struct ComponentVariant: AWSEncodableShape & AWSDecodableShape {
        /// The properties of the component variant that can be overriden when customizing an instance of the component. You can't specify tags as a valid property for overrides.
        public let overrides: [String: [String: String]]?
        /// The combination of variants that comprise this variant. You can't specify tags as a valid property for variantValues.
        public let variantValues: [String: String]?

        @inlinable
        public init(overrides: [String: [String: String]]? = nil, variantValues: [String: String]? = nil) {
            self.overrides = overrides
            self.variantValues = variantValues
        }

        private enum CodingKeys: String, CodingKey {
            case overrides = "overrides"
            case variantValues = "variantValues"
        }
    }

    public struct CreateComponentData: AWSEncodableShape {
        /// The data binding information for the component's properties.
        public let bindingProperties: [String: ComponentBindingPropertiesValue]
        /// A list of child components that are instances of the main component.
        public let children: [ComponentChild]?
        /// The data binding configuration for customizing a component's properties. Use this for a collection component.
        public let collectionProperties: [String: ComponentDataConfiguration]?
        /// The component type. This can be an Amplify custom UI component or another custom component.
        public let componentType: String
        /// The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public let events: [String: ComponentEvent]?
        /// The name of the component
        public let name: String
        /// Describes the component properties that can be overriden to customize an instance of the component.
        public let overrides: [String: [String: String]]
        /// Describes the component's properties.
        public let properties: [String: ComponentProperty]
        /// The schema version of the component when it was imported.
        public let schemaVersion: String?
        /// The unique ID of the component in its original source system, such as Figma.
        public let sourceId: String?
        /// One or more key-value pairs to use when tagging the component data.
        public let tags: [String: String]?
        /// A list of the unique variants of this component.
        public let variants: [ComponentVariant]

        @inlinable
        public init(bindingProperties: [String: ComponentBindingPropertiesValue], children: [ComponentChild]? = nil, collectionProperties: [String: ComponentDataConfiguration]? = nil, componentType: String, events: [String: ComponentEvent]? = nil, name: String, overrides: [String: [String: String]], properties: [String: ComponentProperty], schemaVersion: String? = nil, sourceId: String? = nil, tags: [String: String]? = nil, variants: [ComponentVariant]) {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.events = events
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }

        public func validate(name: String) throws {
            try self.bindingProperties.forEach {
                try $0.value.validate(name: "\(name).bindingProperties[\"\($0.key)\"]")
            }
            try self.collectionProperties?.forEach {
                try $0.value.validate(name: "\(name).collectionProperties[\"\($0.key)\"]")
            }
            try self.validate(self.componentType, name: "componentType", parent: name, max: 255)
            try self.validate(self.componentType, name: "componentType", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bindingProperties = "bindingProperties"
            case children = "children"
            case collectionProperties = "collectionProperties"
            case componentType = "componentType"
            case events = "events"
            case name = "name"
            case overrides = "overrides"
            case properties = "properties"
            case schemaVersion = "schemaVersion"
            case sourceId = "sourceId"
            case tags = "tags"
            case variants = "variants"
        }
    }

    public struct CreateComponentRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app to associate with the component.
        public let appId: String
        /// The unique client token.
        public let clientToken: String?
        /// Represents the configuration of the component to create.
        public let componentToCreate: CreateComponentData
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String

        @inlinable
        public init(appId: String, clientToken: String? = CreateComponentRequest.idempotencyToken(), componentToCreate: CreateComponentData, environmentName: String) {
            self.appId = appId
            self.clientToken = clientToken
            self.componentToCreate = componentToCreate
            self.environmentName = environmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            try container.encode(self.componentToCreate)
            request.encodePath(self.environmentName, key: "environmentName")
        }

        public func validate(name: String) throws {
            try self.componentToCreate.validate(name: "\(name).componentToCreate")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateComponentResponse: AWSDecodableShape {
        /// Describes the configuration of the new component.
        public let entity: Component

        @inlinable
        public init(entity: Component) {
            self.entity = entity
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.entity = try container.decode(Component.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateFormData: AWSEncodableShape {
        /// The FormCTA object that stores the call to action configuration for the form.
        public let cta: FormCTA?
        /// The type of data source to use to create the form.
        public let dataType: FormDataTypeConfig
        /// The configuration information for the form's fields.
        public let fields: [String: FieldConfig]
        /// Specifies whether to perform a create or update action on the form.
        public let formActionType: FormActionType
        /// Specifies an icon or decoration to display on the form.
        public let labelDecorator: LabelDecorator?
        /// The name of the form.
        public let name: String
        /// The schema version of the form.
        public let schemaVersion: String
        /// The configuration information for the visual helper elements for the form. These elements are not associated with any data.
        public let sectionalElements: [String: SectionalElement]
        /// The configuration for the form's style.
        public let style: FormStyle
        /// One or more key-value pairs to use when tagging the form data.
        public let tags: [String: String]?

        @inlinable
        public init(cta: FormCTA? = nil, dataType: FormDataTypeConfig, fields: [String: FieldConfig], formActionType: FormActionType, labelDecorator: LabelDecorator? = nil, name: String, schemaVersion: String, sectionalElements: [String: SectionalElement], style: FormStyle, tags: [String: String]? = nil) {
            self.cta = cta
            self.dataType = dataType
            self.fields = fields
            self.formActionType = formActionType
            self.labelDecorator = labelDecorator
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cta = "cta"
            case dataType = "dataType"
            case fields = "fields"
            case formActionType = "formActionType"
            case labelDecorator = "labelDecorator"
            case name = "name"
            case schemaVersion = "schemaVersion"
            case sectionalElements = "sectionalElements"
            case style = "style"
            case tags = "tags"
        }
    }

    public struct CreateFormRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app to associate with the form.
        public let appId: String
        /// The unique client token.
        public let clientToken: String?
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// Represents the configuration of the form to create.
        public let formToCreate: CreateFormData

        @inlinable
        public init(appId: String, clientToken: String? = CreateFormRequest.idempotencyToken(), environmentName: String, formToCreate: CreateFormData) {
            self.appId = appId
            self.clientToken = clientToken
            self.environmentName = environmentName
            self.formToCreate = formToCreate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentName, key: "environmentName")
            try container.encode(self.formToCreate)
        }

        public func validate(name: String) throws {
            try self.formToCreate.validate(name: "\(name).formToCreate")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateFormResponse: AWSDecodableShape {
        /// Describes the configuration of the new form.
        public let entity: Form

        @inlinable
        public init(entity: Form) {
            self.entity = entity
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.entity = try container.decode(Form.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateThemeData: AWSEncodableShape {
        /// The name of the theme.
        public let name: String
        /// Describes the properties that can be overriden to customize an instance of the theme.
        public let overrides: [ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme data.
        public let tags: [String: String]?
        /// A list of key-value pairs that denes the properties of the theme.
        public let values: [ThemeValues]

        @inlinable
        public init(name: String, overrides: [ThemeValues]? = nil, tags: [String: String]? = nil, values: [ThemeValues]) {
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case overrides = "overrides"
            case tags = "tags"
            case values = "values"
        }
    }

    public struct CreateThemeRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app associated with the theme.
        public let appId: String
        /// The unique client token.
        public let clientToken: String?
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// Represents the configuration of the theme to create.
        public let themeToCreate: CreateThemeData

        @inlinable
        public init(appId: String, clientToken: String? = CreateThemeRequest.idempotencyToken(), environmentName: String, themeToCreate: CreateThemeData) {
            self.appId = appId
            self.clientToken = clientToken
            self.environmentName = environmentName
            self.themeToCreate = themeToCreate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentName, key: "environmentName")
            try container.encode(self.themeToCreate)
        }

        public func validate(name: String) throws {
            try self.themeToCreate.validate(name: "\(name).themeToCreate")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateThemeResponse: AWSDecodableShape {
        /// Describes the configuration of the new theme.
        public let entity: Theme

        @inlinable
        public init(entity: Theme) {
            self.entity = entity
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.entity = try container.decode(Theme.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DataStoreRenderConfig: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct DeleteComponentRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app associated with the component to delete.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The unique ID of the component to delete.
        public let id: String

        @inlinable
        public init(appId: String, environmentName: String, id: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFormRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app associated with the form to delete.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The unique ID of the form to delete.
        public let id: String

        @inlinable
        public init(appId: String, environmentName: String, id: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThemeRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app associated with the theme to delete.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The unique ID of the theme to delete.
        public let id: String

        @inlinable
        public init(appId: String, environmentName: String, id: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExchangeCodeForTokenRequest: AWSEncodableShape {
        /// The third-party provider for the token. The only valid value is figma.
        public let provider: TokenProviders
        /// Describes the configuration of the request.
        public let request: ExchangeCodeForTokenRequestBody

        @inlinable
        public init(provider: TokenProviders, request: ExchangeCodeForTokenRequestBody) {
            self.provider = provider
            self.request = request
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.provider, key: "provider")
            try container.encode(self.request)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExchangeCodeForTokenRequestBody: AWSEncodableShape {
        /// The ID of the client to request the token from.
        public let clientId: String?
        /// The access code to send in the request.
        public let code: String
        /// The location of the application that will receive the access code.
        public let redirectUri: String

        @inlinable
        public init(clientId: String? = nil, code: String, redirectUri: String) {
            self.clientId = clientId
            self.code = code
            self.redirectUri = redirectUri
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case code = "code"
            case redirectUri = "redirectUri"
        }
    }

    public struct ExchangeCodeForTokenResponse: AWSDecodableShape {
        /// The access token.
        public let accessToken: String
        /// The date and time when the new access token expires.
        public let expiresIn: Int
        /// The token to use to refresh a previously issued access token that might have expired.
        public let refreshToken: String

        @inlinable
        public init(accessToken: String, expiresIn: Int, refreshToken: String) {
            self.accessToken = accessToken
            self.expiresIn = expiresIn
            self.refreshToken = refreshToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case expiresIn = "expiresIn"
            case refreshToken = "refreshToken"
        }
    }

    public struct ExportComponentsRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app to export components to.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportComponentsResponse: AWSDecodableShape {
        /// Represents the configuration of the exported components.
        public let entities: [Component]
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(entities: [Component], nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct ExportFormsRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app to export forms to.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportFormsResponse: AWSDecodableShape {
        /// Represents the configuration of the exported forms.
        public let entities: [Form]
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(entities: [Form], nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct ExportThemesRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app to export the themes to.
        public let appId: String
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportThemesResponse: AWSDecodableShape {
        /// Represents the configuration of the exported themes.
        public let entities: [Theme]
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(entities: [Theme], nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct FieldConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to hide a field.
        public let excluded: Bool?
        /// Describes the configuration for the default input value to display for a field.
        public let inputType: FieldInputConfig?
        /// The label for the field.
        public let label: String?
        /// Specifies the field position.
        public let position: FieldPosition?
        /// The validations to perform on the value in the field.
        public let validations: [FieldValidationConfiguration]?

        @inlinable
        public init(excluded: Bool? = nil, inputType: FieldInputConfig? = nil, label: String? = nil, position: FieldPosition? = nil, validations: [FieldValidationConfiguration]? = nil) {
            self.excluded = excluded
            self.inputType = inputType
            self.label = label
            self.position = position
            self.validations = validations
        }

        private enum CodingKeys: String, CodingKey {
            case excluded = "excluded"
            case inputType = "inputType"
            case label = "label"
            case position = "position"
            case validations = "validations"
        }
    }

    public struct FieldInputConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether a field has a default value.
        public let defaultChecked: Bool?
        /// The default country code for a phone number.
        public let defaultCountryCode: String?
        /// The default value for the field.
        public let defaultValue: String?
        /// The text to display to describe the field.
        public let descriptiveText: String?
        /// The configuration for the file uploader field.
        public let fileUploaderConfig: FileUploaderFieldConfig?
        /// Specifies whether to render the field as an array. This property is ignored if the dataSourceType for the form is a Data Store.
        public let isArray: Bool?
        /// The maximum value to display for the field.
        public let maxValue: Float?
        /// The minimum value to display for the field.
        public let minValue: Float?
        /// The name of the field.
        public let name: String?
        /// The text to display as a placeholder for the field.
        public let placeholder: String?
        /// Specifies a read only field.
        public let readOnly: Bool?
        /// Specifies a field that requires input.
        public let required: Bool?
        /// The stepping increment for a numeric value in a field.
        public let step: Float?
        /// The input type for the field.
        public let type: String
        /// The value for the field.
        public let value: String?
        /// The information to use to customize the input fields with data at runtime.
        public let valueMappings: ValueMappings?

        @inlinable
        public init(defaultChecked: Bool? = nil, defaultCountryCode: String? = nil, defaultValue: String? = nil, descriptiveText: String? = nil, fileUploaderConfig: FileUploaderFieldConfig? = nil, isArray: Bool? = nil, maxValue: Float? = nil, minValue: Float? = nil, name: String? = nil, placeholder: String? = nil, readOnly: Bool? = nil, required: Bool? = nil, step: Float? = nil, type: String, value: String? = nil, valueMappings: ValueMappings? = nil) {
            self.defaultChecked = defaultChecked
            self.defaultCountryCode = defaultCountryCode
            self.defaultValue = defaultValue
            self.descriptiveText = descriptiveText
            self.fileUploaderConfig = fileUploaderConfig
            self.isArray = isArray
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.placeholder = placeholder
            self.readOnly = readOnly
            self.required = required
            self.step = step
            self.type = type
            self.value = value
            self.valueMappings = valueMappings
        }

        private enum CodingKeys: String, CodingKey {
            case defaultChecked = "defaultChecked"
            case defaultCountryCode = "defaultCountryCode"
            case defaultValue = "defaultValue"
            case descriptiveText = "descriptiveText"
            case fileUploaderConfig = "fileUploaderConfig"
            case isArray = "isArray"
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
            case placeholder = "placeholder"
            case readOnly = "readOnly"
            case required = "required"
            case step = "step"
            case type = "type"
            case value = "value"
            case valueMappings = "valueMappings"
        }
    }

    public struct FieldValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The validation to perform on a number value.
        public let numValues: [Int]?
        /// The validation to perform on a string value.
        public let strValues: [String]?
        /// The validation to perform on an object type.
        public let type: String
        /// The validation message to display.
        public let validationMessage: String?

        @inlinable
        public init(numValues: [Int]? = nil, strValues: [String]? = nil, type: String, validationMessage: String? = nil) {
            self.numValues = numValues
            self.strValues = strValues
            self.type = type
            self.validationMessage = validationMessage
        }

        private enum CodingKeys: String, CodingKey {
            case numValues = "numValues"
            case strValues = "strValues"
            case type = "type"
            case validationMessage = "validationMessage"
        }
    }

    public struct FileUploaderFieldConfig: AWSEncodableShape & AWSDecodableShape {
        /// The file types that are allowed to be uploaded by the file uploader. Provide this information in an array of strings specifying the valid file extensions.
        public let acceptedFileTypes: [String]
        /// The access level to assign to the uploaded files in the Amazon S3 bucket where they are stored. The valid values for this property are private, protected, or public. For detailed information about the permissions associated with each access level, see File access levels in the Amplify documentation.
        public let accessLevel: StorageAccessLevel
        /// Allows the file upload operation to be paused and resumed. The default value is false. When isResumable is set to true, the file uploader uses a multipart upload to break the files into chunks before upload. The progress of the upload isn't continuous, because the file uploader uploads a chunk at a time.
        public let isResumable: Bool?
        /// Specifies the maximum number of files that can be selected to upload. The default value is an unlimited number of files.
        public let maxFileCount: Int?
        /// The maximum file size in bytes that the file uploader will accept. The default value is an unlimited file size.
        public let maxSize: Int?
        /// Specifies whether to display or hide the image preview after selecting a file for upload. The default value is true to display the image preview.
        public let showThumbnails: Bool?

        @inlinable
        public init(acceptedFileTypes: [String], accessLevel: StorageAccessLevel, isResumable: Bool? = nil, maxFileCount: Int? = nil, maxSize: Int? = nil, showThumbnails: Bool? = nil) {
            self.acceptedFileTypes = acceptedFileTypes
            self.accessLevel = accessLevel
            self.isResumable = isResumable
            self.maxFileCount = maxFileCount
            self.maxSize = maxSize
            self.showThumbnails = showThumbnails
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedFileTypes = "acceptedFileTypes"
            case accessLevel = "accessLevel"
            case isResumable = "isResumable"
            case maxFileCount = "maxFileCount"
            case maxSize = "maxSize"
            case showThumbnails = "showThumbnails"
        }
    }

    public struct Form: AWSDecodableShape {
        /// The unique ID of the Amplify app associated with the form.
        public let appId: String
        /// Stores the call to action configuration for the form.
        public let cta: FormCTA?
        /// The type of data source to use to create the form.
        public let dataType: FormDataTypeConfig
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// Stores the information about the form's fields.
        public let fields: [String: FieldConfig]
        /// The operation to perform on the specified form.
        public let formActionType: FormActionType
        /// The unique ID of the form.
        public let id: String
        /// Specifies an icon or decoration to display on the form.
        public let labelDecorator: LabelDecorator?
        /// The name of the form.
        public let name: String
        /// The schema version of the form when it was imported.
        public let schemaVersion: String
        /// Stores the visual helper elements for the form that are not associated with any data.
        public let sectionalElements: [String: SectionalElement]
        /// Stores the configuration for the form's style.
        public let style: FormStyle
        /// One or more key-value pairs to use when tagging the form.
        public let tags: [String: String]?

        @inlinable
        public init(appId: String, cta: FormCTA? = nil, dataType: FormDataTypeConfig, environmentName: String, fields: [String: FieldConfig], formActionType: FormActionType, id: String, labelDecorator: LabelDecorator? = nil, name: String, schemaVersion: String, sectionalElements: [String: SectionalElement], style: FormStyle, tags: [String: String]? = nil) {
            self.appId = appId
            self.cta = cta
            self.dataType = dataType
            self.environmentName = environmentName
            self.fields = fields
            self.formActionType = formActionType
            self.id = id
            self.labelDecorator = labelDecorator
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case cta = "cta"
            case dataType = "dataType"
            case environmentName = "environmentName"
            case fields = "fields"
            case formActionType = "formActionType"
            case id = "id"
            case labelDecorator = "labelDecorator"
            case name = "name"
            case schemaVersion = "schemaVersion"
            case sectionalElements = "sectionalElements"
            case style = "style"
            case tags = "tags"
        }
    }

    public struct FormBindingElement: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component to retrieve a value from.
        public let element: String
        /// The property to retrieve a value from.
        public let property: String

        @inlinable
        public init(element: String, property: String) {
            self.element = element
            self.property = property
        }

        private enum CodingKeys: String, CodingKey {
            case element = "element"
            case property = "property"
        }
    }

    public struct FormButton: AWSEncodableShape & AWSDecodableShape {
        /// Describes the button's properties.
        public let children: String?
        /// Specifies whether the button is visible on the form.
        public let excluded: Bool?
        /// The position of the button.
        public let position: FieldPosition?

        @inlinable
        public init(children: String? = nil, excluded: Bool? = nil, position: FieldPosition? = nil) {
            self.children = children
            self.excluded = excluded
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case children = "children"
            case excluded = "excluded"
            case position = "position"
        }
    }

    public struct FormCTA: AWSEncodableShape & AWSDecodableShape {
        /// Displays a cancel button.
        public let cancel: FormButton?
        /// Displays a clear button.
        public let clear: FormButton?
        /// The position of the button.
        public let position: FormButtonsPosition?
        /// Displays a submit button.
        public let submit: FormButton?

        @inlinable
        public init(cancel: FormButton? = nil, clear: FormButton? = nil, position: FormButtonsPosition? = nil, submit: FormButton? = nil) {
            self.cancel = cancel
            self.clear = clear
            self.position = position
            self.submit = submit
        }

        private enum CodingKeys: String, CodingKey {
            case cancel = "cancel"
            case clear = "clear"
            case position = "position"
            case submit = "submit"
        }
    }

    public struct FormDataTypeConfig: AWSEncodableShape & AWSDecodableShape {
        /// The data source type, either an Amplify DataStore model or a custom data type.
        public let dataSourceType: FormDataSourceType
        /// The unique name of the data type you are using as the data source for the form.
        public let dataTypeName: String

        @inlinable
        public init(dataSourceType: FormDataSourceType, dataTypeName: String) {
            self.dataSourceType = dataSourceType
            self.dataTypeName = dataTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType = "dataSourceType"
            case dataTypeName = "dataTypeName"
        }
    }

    public struct FormInputBindingPropertiesValue: AWSEncodableShape & AWSDecodableShape {
        /// Describes the properties to customize with data at runtime.
        public let bindingProperties: FormInputBindingPropertiesValueProperties?
        /// The property type.
        public let type: String?

        @inlinable
        public init(bindingProperties: FormInputBindingPropertiesValueProperties? = nil, type: String? = nil) {
            self.bindingProperties = bindingProperties
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case bindingProperties = "bindingProperties"
            case type = "type"
        }
    }

    public struct FormInputBindingPropertiesValueProperties: AWSEncodableShape & AWSDecodableShape {
        /// An Amplify DataStore model.
        public let model: String?

        @inlinable
        public init(model: String? = nil) {
            self.model = model
        }

        private enum CodingKeys: String, CodingKey {
            case model = "model"
        }
    }

    public struct FormInputValueProperty: AWSEncodableShape & AWSDecodableShape {
        /// The information to bind fields to data at runtime.
        public let bindingProperties: FormInputValuePropertyBindingProperties?
        /// A list of form properties to concatenate to create the value to assign to this field property.
        public let concat: [FormInputValueProperty]?
        /// The value to assign to the input field.
        public let value: String?

        @inlinable
        public init(bindingProperties: FormInputValuePropertyBindingProperties? = nil, concat: [FormInputValueProperty]? = nil, value: String? = nil) {
            self.bindingProperties = bindingProperties
            self.concat = concat
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case bindingProperties = "bindingProperties"
            case concat = "concat"
            case value = "value"
        }
    }

    public struct FormInputValuePropertyBindingProperties: AWSEncodableShape & AWSDecodableShape {
        /// The data field to bind the property to.
        public let field: String?
        /// The form property to bind to the data field.
        public let property: String

        @inlinable
        public init(field: String? = nil, property: String) {
            self.field = field
            self.property = property
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case property = "property"
        }
    }

    public struct FormStyle: AWSEncodableShape & AWSDecodableShape {
        /// The spacing for the horizontal gap.
        public let horizontalGap: FormStyleConfig?
        /// The size of the outer padding for the form.
        public let outerPadding: FormStyleConfig?
        /// The spacing for the vertical gap.
        public let verticalGap: FormStyleConfig?

        @inlinable
        public init(horizontalGap: FormStyleConfig? = nil, outerPadding: FormStyleConfig? = nil, verticalGap: FormStyleConfig? = nil) {
            self.horizontalGap = horizontalGap
            self.outerPadding = outerPadding
            self.verticalGap = verticalGap
        }

        private enum CodingKeys: String, CodingKey {
            case horizontalGap = "horizontalGap"
            case outerPadding = "outerPadding"
            case verticalGap = "verticalGap"
        }
    }

    public struct FormSummary: AWSDecodableShape {
        /// The unique ID for the app associated with the form summary.
        public let appId: String
        /// The form's data source type.
        public let dataType: FormDataTypeConfig
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The type of operation to perform on the form.
        public let formActionType: FormActionType
        /// The ID of the form.
        public let id: String
        /// The name of the form.
        public let name: String

        @inlinable
        public init(appId: String, dataType: FormDataTypeConfig, environmentName: String, formActionType: FormActionType, id: String, name: String) {
            self.appId = appId
            self.dataType = dataType
            self.environmentName = environmentName
            self.formActionType = formActionType
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case dataType = "dataType"
            case environmentName = "environmentName"
            case formActionType = "formActionType"
            case id = "id"
            case name = "name"
        }
    }

    public struct GetCodegenJobRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app associated with the code generation job.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app associated with the code generation job.
        public let environmentName: String
        /// The unique ID of the code generation job.
        public let id: String

        @inlinable
        public init(appId: String, environmentName: String, id: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodegenJobResponse: AWSDecodableShape {
        /// The configuration settings for the code generation job.
        public let job: CodegenJob

        @inlinable
        public init(job: CodegenJob) {
            self.job = job
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.job = try container.decode(CodegenJob.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app.
        public let appId: String
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The unique ID of the component.
        public let id: String

        @inlinable
        public init(appId: String, environmentName: String, id: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentResponse: AWSDecodableShape {
        /// Represents the configuration settings for the component.
        public let component: Component

        @inlinable
        public init(component: Component) {
            self.component = component
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.component = try container.decode(Component.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFormRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app.
        public let appId: String
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The unique ID of the form.
        public let id: String

        @inlinable
        public init(appId: String, environmentName: String, id: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFormResponse: AWSDecodableShape {
        /// Represents the configuration settings for the form.
        public let form: Form

        @inlinable
        public init(form: Form) {
            self.form = form
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.form = try container.decode(Form.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMetadataRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app.
        public let appId: String
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String

        @inlinable
        public init(appId: String, environmentName: String) {
            self.appId = appId
            self.environmentName = environmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMetadataResponse: AWSDecodableShape {
        /// Represents the configuration settings for the features metadata.
        public let features: [String: String]

        @inlinable
        public init(features: [String: String]) {
            self.features = features
        }

        private enum CodingKeys: String, CodingKey {
            case features = "features"
        }
    }

    public struct GetThemeRequest: AWSEncodableShape {
        /// The unique ID of the Amplify app.
        public let appId: String
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The unique ID for the theme.
        public let id: String

        @inlinable
        public init(appId: String, environmentName: String, id: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetThemeResponse: AWSDecodableShape {
        /// Represents the configuration settings for the theme.
        public let theme: Theme

        @inlinable
        public init(theme: Theme) {
            self.theme = theme
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.theme = try container.decode(Theme.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GraphQLRenderConfig: AWSEncodableShape & AWSDecodableShape {
        /// The path to the GraphQL fragments file, relative to the component output directory.
        public let fragmentsFilePath: String
        /// The path to the GraphQL mutations file, relative to the component output directory.
        public let mutationsFilePath: String
        /// The path to the GraphQL queries file, relative to the component output directory.
        public let queriesFilePath: String
        /// The path to the GraphQL subscriptions file, relative to the component output directory.
        public let subscriptionsFilePath: String
        /// The path to the GraphQL types file, relative to the component output directory.
        public let typesFilePath: String

        @inlinable
        public init(fragmentsFilePath: String, mutationsFilePath: String, queriesFilePath: String, subscriptionsFilePath: String, typesFilePath: String) {
            self.fragmentsFilePath = fragmentsFilePath
            self.mutationsFilePath = mutationsFilePath
            self.queriesFilePath = queriesFilePath
            self.subscriptionsFilePath = subscriptionsFilePath
            self.typesFilePath = typesFilePath
        }

        private enum CodingKeys: String, CodingKey {
            case fragmentsFilePath = "fragmentsFilePath"
            case mutationsFilePath = "mutationsFilePath"
            case queriesFilePath = "queriesFilePath"
            case subscriptionsFilePath = "subscriptionsFilePath"
            case typesFilePath = "typesFilePath"
        }
    }

    public struct ListCodegenJobsRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The maximum number of jobs to retrieve.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCodegenJobsResponse: AWSDecodableShape {
        /// The list of code generation jobs for the Amplify app.
        public let entities: [CodegenJobSummary]
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(entities: [CodegenJobSummary], nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct ListComponentsRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The maximum number of components to retrieve.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListComponentsResponse: AWSDecodableShape {
        /// The list of components for the Amplify app.
        public let entities: [ComponentSummary]
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(entities: [ComponentSummary], nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct ListFormsRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The maximum number of forms to retrieve.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFormsResponse: AWSDecodableShape {
        /// The list of forms for the Amplify app.
        public let entities: [FormSummary]
        /// The pagination token that's included if more results are available.
        public let nextToken: String?

        @inlinable
        public init(entities: [FormSummary], nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tag key value pairs for a specified Amazon Resource Name (ARN).
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListThemesRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The maximum number of theme results to return in the response.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemesResponse: AWSDecodableShape {
        /// The list of themes for the Amplify app.
        public let entities: [ThemeSummary]
        /// The pagination token that's returned if more results are available.
        public let nextToken: String?

        @inlinable
        public init(entities: [ThemeSummary], nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct MutationActionSetStateParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component that is being modified.
        public let componentName: String
        /// The name of the component property to apply the state configuration to.
        public let property: String
        /// The state configuration to assign to the property.
        public let set: ComponentProperty

        @inlinable
        public init(componentName: String, property: String, set: ComponentProperty) {
            self.componentName = componentName
            self.property = property
            self.set = set
        }

        private enum CodingKeys: String, CodingKey {
            case componentName = "componentName"
            case property = "property"
            case set = "set"
        }
    }

    public struct NoApiRenderConfig: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct Predicate: AWSEncodableShape & AWSDecodableShape {
        /// A list of predicates to combine logically.
        public let and: [Predicate]?
        /// The field to query.
        public let field: String?
        /// The value to use when performing the evaluation.
        public let operand: String?
        /// The type of value to use when performing the evaluation.
        public let operandType: String?
        /// The operator to use to perform the evaluation.
        public let `operator`: String?
        /// A list of predicates to combine logically.
        public let or: [Predicate]?

        @inlinable
        public init(and: [Predicate]? = nil, field: String? = nil, operand: String? = nil, operandType: String? = nil, operator: String? = nil, or: [Predicate]? = nil) {
            self.and = and
            self.field = field
            self.operand = operand
            self.operandType = operandType
            self.`operator` = `operator`
            self.or = or
        }

        public func validate(name: String) throws {
            try self.and?.forEach {
                try $0.validate(name: "\(name).and[]")
            }
            try self.validate(self.operandType, name: "operandType", parent: name, pattern: "^boolean|string|number$")
            try self.or?.forEach {
                try $0.validate(name: "\(name).or[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case and = "and"
            case field = "field"
            case operand = "operand"
            case operandType = "operandType"
            case `operator` = "operator"
            case or = "or"
        }
    }

    public struct PutMetadataFlagBody: AWSEncodableShape {
        /// The new information to store.
        public let newValue: String

        @inlinable
        public init(newValue: String) {
            self.newValue = newValue
        }

        private enum CodingKeys: String, CodingKey {
            case newValue = "newValue"
        }
    }

    public struct PutMetadataFlagRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The metadata information to store.
        public let body: PutMetadataFlagBody
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The name of the feature associated with the metadata.
        public let featureName: String

        @inlinable
        public init(appId: String, body: PutMetadataFlagBody, environmentName: String, featureName: String) {
            self.appId = appId
            self.body = body
            self.environmentName = environmentName
            self.featureName = featureName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            try container.encode(self.body)
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.featureName, key: "featureName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ReactStartCodegenJobData: AWSEncodableShape & AWSDecodableShape {
        /// The API configuration for the code generation job.
        public let apiConfiguration: ApiConfiguration?
        /// Lists the dependency packages that may be required for the project code to run.
        public let dependencies: [String: String]?
        /// Specifies whether the code generation job should render inline source maps.
        public let inlineSourceMap: Bool?
        /// The JavaScript module type.
        public let module: JSModule?
        /// Specifies whether the code generation job should render type declaration files.
        public let renderTypeDeclarations: Bool?
        /// The file type to use for a JavaScript project.
        public let script: JSScript?
        /// The ECMAScript specification to use.
        public let target: JSTarget?

        @inlinable
        public init(apiConfiguration: ApiConfiguration? = nil, dependencies: [String: String]? = nil, inlineSourceMap: Bool? = nil, module: JSModule? = nil, renderTypeDeclarations: Bool? = nil, script: JSScript? = nil, target: JSTarget? = nil) {
            self.apiConfiguration = apiConfiguration
            self.dependencies = dependencies
            self.inlineSourceMap = inlineSourceMap
            self.module = module
            self.renderTypeDeclarations = renderTypeDeclarations
            self.script = script
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case apiConfiguration = "apiConfiguration"
            case dependencies = "dependencies"
            case inlineSourceMap = "inlineSourceMap"
            case module = "module"
            case renderTypeDeclarations = "renderTypeDeclarations"
            case script = "script"
            case target = "target"
        }
    }

    public struct RefreshTokenRequest: AWSEncodableShape {
        /// The third-party provider for the token. The only valid value is figma.
        public let provider: TokenProviders
        /// Information about the refresh token request.
        public let refreshTokenBody: RefreshTokenRequestBody

        @inlinable
        public init(provider: TokenProviders, refreshTokenBody: RefreshTokenRequestBody) {
            self.provider = provider
            self.refreshTokenBody = refreshTokenBody
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.provider, key: "provider")
            try container.encode(self.refreshTokenBody)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RefreshTokenRequestBody: AWSEncodableShape {
        /// The ID of the client to request the token from.
        public let clientId: String?
        /// The token to use to refresh a previously issued access token that might have expired.
        public let token: String

        @inlinable
        public init(clientId: String? = nil, token: String) {
            self.clientId = clientId
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case token = "token"
        }
    }

    public struct RefreshTokenResponse: AWSDecodableShape {
        /// The access token.
        public let accessToken: String
        /// The date and time when the new access token expires.
        public let expiresIn: Int

        @inlinable
        public init(accessToken: String, expiresIn: Int) {
            self.accessToken = accessToken
            self.expiresIn = expiresIn
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case expiresIn = "expiresIn"
        }
    }

    public struct SectionalElement: AWSEncodableShape & AWSDecodableShape {
        /// Excludes a sectional element that was generated by default for a specified data model.
        public let excluded: Bool?
        /// Specifies the size of the font for a Heading sectional element. Valid values are 1 | 2 | 3 | 4 | 5 | 6.
        public let level: Int?
        /// Specifies the orientation for a Divider sectional element. Valid values are horizontal or vertical.
        public let orientation: String?
        /// Specifies the position of the text in a field for a Text sectional element.
        public let position: FieldPosition?
        /// The text for a Text sectional element.
        public let text: String?
        /// The type of sectional element. Valid values are Heading, Text, and Divider.
        public let type: String

        @inlinable
        public init(excluded: Bool? = nil, level: Int? = nil, orientation: String? = nil, position: FieldPosition? = nil, text: String? = nil, type: String) {
            self.excluded = excluded
            self.level = level
            self.orientation = orientation
            self.position = position
            self.text = text
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case excluded = "excluded"
            case level = "level"
            case orientation = "orientation"
            case position = "position"
            case text = "text"
            case type = "type"
        }
    }

    public struct SortProperty: AWSEncodableShape & AWSDecodableShape {
        /// The direction of the sort, either ascending or descending.
        public let direction: SortDirection
        /// The field to perform the sort on.
        public let field: String

        @inlinable
        public init(direction: SortDirection, field: String) {
            self.direction = direction
            self.field = field
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "direction"
            case field = "field"
        }
    }

    public struct StartCodegenJobData: AWSEncodableShape {
        /// Specifies whether to autogenerate forms in the code generation job.
        public let autoGenerateForms: Bool?
        /// The feature flags for a code generation job.
        public let features: CodegenFeatureFlags?
        /// The data schema to use for a code generation job.
        public let genericDataSchema: CodegenJobGenericDataSchema?
        /// The code generation configuration for the codegen job.
        public let renderConfig: CodegenJobRenderConfig
        /// One or more key-value pairs to use when tagging the code generation job data.
        public let tags: [String: String]?

        @inlinable
        public init(autoGenerateForms: Bool? = nil, features: CodegenFeatureFlags? = nil, genericDataSchema: CodegenJobGenericDataSchema? = nil, renderConfig: CodegenJobRenderConfig, tags: [String: String]? = nil) {
            self.autoGenerateForms = autoGenerateForms
            self.features = features
            self.genericDataSchema = genericDataSchema
            self.renderConfig = renderConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case autoGenerateForms = "autoGenerateForms"
            case features = "features"
            case genericDataSchema = "genericDataSchema"
            case renderConfig = "renderConfig"
            case tags = "tags"
        }
    }

    public struct StartCodegenJobRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The idempotency token used to ensure that the code generation job request completes only once.
        public let clientToken: String?
        /// The code generation job resource configuration.
        public let codegenJobToCreate: StartCodegenJobData
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String

        @inlinable
        public init(appId: String, clientToken: String? = StartCodegenJobRequest.idempotencyToken(), codegenJobToCreate: StartCodegenJobData, environmentName: String) {
            self.appId = appId
            self.clientToken = clientToken
            self.codegenJobToCreate = codegenJobToCreate
            self.environmentName = environmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            try container.encode(self.codegenJobToCreate)
            request.encodePath(self.environmentName, key: "environmentName")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.codegenJobToCreate.validate(name: "\(name).codegenJobToCreate")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartCodegenJobResponse: AWSDecodableShape {
        /// The code generation job for a UI component that is associated with an Amplify app.
        public let entity: CodegenJob

        @inlinable
        public init(entity: CodegenJob) {
            self.entity = entity
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.entity = try container.decode(CodegenJob.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to tag a resource.
        public let resourceArn: String
        /// A list of tag key value pairs for a specified Amazon Resource Name (ARN).
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Theme: AWSDecodableShape {
        /// The unique ID for the Amplify app associated with the theme.
        public let appId: String
        /// The time that the theme was created.
        public let createdAt: Date
        /// The name of the backend environment that is a part of the Amplify app.
        public let environmentName: String
        /// The ID for the theme.
        public let id: String
        /// The time that the theme was modified.
        public let modifiedAt: Date?
        /// The name of the theme.
        public let name: String
        /// Describes the properties that can be overriden to customize a theme.
        public let overrides: [ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme.
        public let tags: [String: String]?
        /// A list of key-value pairs that defines the properties of the theme.
        public let values: [ThemeValues]

        @inlinable
        public init(appId: String, createdAt: Date, environmentName: String, id: String, modifiedAt: Date? = nil, name: String, overrides: [ThemeValues]? = nil, tags: [String: String]? = nil, values: [ThemeValues]) {
            self.appId = appId
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case createdAt = "createdAt"
            case environmentName = "environmentName"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case overrides = "overrides"
            case tags = "tags"
            case values = "values"
        }
    }

    public struct ThemeSummary: AWSDecodableShape {
        /// The unique ID for the app associated with the theme summary.
        public let appId: String
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The ID of the theme.
        public let id: String
        /// The name of the theme.
        public let name: String

        @inlinable
        public init(appId: String, environmentName: String, id: String, name: String) {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case environmentName = "environmentName"
            case id = "id"
            case name = "name"
        }
    }

    public struct ThemeValue: AWSEncodableShape & AWSDecodableShape {
        /// A list of key-value pairs that define the theme's properties.
        public let children: [ThemeValues]?
        /// The value of a theme property.
        public let value: String?

        @inlinable
        public init(children: [ThemeValues]? = nil, value: String? = nil) {
            self.children = children
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case children = "children"
            case value = "value"
        }
    }

    public struct ThemeValues: AWSEncodableShape & AWSDecodableShape {
        /// The name of the property.
        public let key: String?
        /// The value of the property.
        public let value: ThemeValue?

        @inlinable
        public init(key: String? = nil, value: ThemeValue? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to untag a resource.
        public let resourceArn: String
        /// The tag keys to use to untag a resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateComponentData: AWSEncodableShape {
        /// The data binding information for the component's properties.
        public let bindingProperties: [String: ComponentBindingPropertiesValue]?
        /// The components that are instances of the main component.
        public let children: [ComponentChild]?
        /// The configuration for binding a component's properties to a data model. Use this for a collection component.
        public let collectionProperties: [String: ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        public let componentType: String?
        /// The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public let events: [String: ComponentEvent]?
        /// The unique ID of the component to update.
        public let id: String?
        /// The name of the component to update.
        public let name: String?
        /// Describes the properties that can be overriden to customize the component.
        public let overrides: [String: [String: String]]?
        /// Describes the component's properties.
        public let properties: [String: ComponentProperty]?
        /// The schema version of the component when it was imported.
        public let schemaVersion: String?
        /// The unique ID of the component in its original source system, such as Figma.
        public let sourceId: String?
        /// A list of the unique variants of the main component being updated.
        public let variants: [ComponentVariant]?

        @inlinable
        public init(bindingProperties: [String: ComponentBindingPropertiesValue]? = nil, children: [ComponentChild]? = nil, collectionProperties: [String: ComponentDataConfiguration]? = nil, componentType: String? = nil, events: [String: ComponentEvent]? = nil, id: String? = nil, name: String? = nil, overrides: [String: [String: String]]? = nil, properties: [String: ComponentProperty]? = nil, schemaVersion: String? = nil, sourceId: String? = nil, variants: [ComponentVariant]? = nil) {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.events = events
            self.id = id
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.variants = variants
        }

        public func validate(name: String) throws {
            try self.bindingProperties?.forEach {
                try $0.value.validate(name: "\(name).bindingProperties[\"\($0.key)\"]")
            }
            try self.collectionProperties?.forEach {
                try $0.value.validate(name: "\(name).collectionProperties[\"\($0.key)\"]")
            }
            try self.validate(self.componentType, name: "componentType", parent: name, max: 255)
            try self.validate(self.componentType, name: "componentType", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bindingProperties = "bindingProperties"
            case children = "children"
            case collectionProperties = "collectionProperties"
            case componentType = "componentType"
            case events = "events"
            case id = "id"
            case name = "name"
            case overrides = "overrides"
            case properties = "properties"
            case schemaVersion = "schemaVersion"
            case sourceId = "sourceId"
            case variants = "variants"
        }
    }

    public struct UpdateComponentRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The unique client token.
        public let clientToken: String?
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The unique ID for the component.
        public let id: String
        /// The configuration of the updated component.
        public let updatedComponent: UpdateComponentData

        @inlinable
        public init(appId: String, clientToken: String? = UpdateComponentRequest.idempotencyToken(), environmentName: String, id: String, updatedComponent: UpdateComponentData) {
            self.appId = appId
            self.clientToken = clientToken
            self.environmentName = environmentName
            self.id = id
            self.updatedComponent = updatedComponent
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
            try container.encode(self.updatedComponent)
        }

        public func validate(name: String) throws {
            try self.updatedComponent.validate(name: "\(name).updatedComponent")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateComponentResponse: AWSDecodableShape {
        /// Describes the configuration of the updated component.
        public let entity: Component

        @inlinable
        public init(entity: Component) {
            self.entity = entity
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.entity = try container.decode(Component.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateFormData: AWSEncodableShape {
        /// The FormCTA object that stores the call to action configuration for the form.
        public let cta: FormCTA?
        /// The type of data source to use to create the form.
        public let dataType: FormDataTypeConfig?
        /// The configuration information for the form's fields.
        public let fields: [String: FieldConfig]?
        /// Specifies whether to perform a create or update action on the form.
        public let formActionType: FormActionType?
        /// Specifies an icon or decoration to display on the form.
        public let labelDecorator: LabelDecorator?
        /// The name of the form.
        public let name: String?
        /// The schema version of the form.
        public let schemaVersion: String?
        /// The configuration information for the visual helper elements for the form. These elements are not associated with any data.
        public let sectionalElements: [String: SectionalElement]?
        /// The configuration for the form's style.
        public let style: FormStyle?

        @inlinable
        public init(cta: FormCTA? = nil, dataType: FormDataTypeConfig? = nil, fields: [String: FieldConfig]? = nil, formActionType: FormActionType? = nil, labelDecorator: LabelDecorator? = nil, name: String? = nil, schemaVersion: String? = nil, sectionalElements: [String: SectionalElement]? = nil, style: FormStyle? = nil) {
            self.cta = cta
            self.dataType = dataType
            self.fields = fields
            self.formActionType = formActionType
            self.labelDecorator = labelDecorator
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cta = "cta"
            case dataType = "dataType"
            case fields = "fields"
            case formActionType = "formActionType"
            case labelDecorator = "labelDecorator"
            case name = "name"
            case schemaVersion = "schemaVersion"
            case sectionalElements = "sectionalElements"
            case style = "style"
        }
    }

    public struct UpdateFormRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The unique client token.
        public let clientToken: String?
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The unique ID for the form.
        public let id: String
        /// The request accepts the following data in JSON format.
        public let updatedForm: UpdateFormData

        @inlinable
        public init(appId: String, clientToken: String? = UpdateFormRequest.idempotencyToken(), environmentName: String, id: String, updatedForm: UpdateFormData) {
            self.appId = appId
            self.clientToken = clientToken
            self.environmentName = environmentName
            self.id = id
            self.updatedForm = updatedForm
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
            try container.encode(self.updatedForm)
        }

        public func validate(name: String) throws {
            try self.updatedForm.validate(name: "\(name).updatedForm")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateFormResponse: AWSDecodableShape {
        /// Describes the configuration of the updated form.
        public let entity: Form

        @inlinable
        public init(entity: Form) {
            self.entity = entity
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.entity = try container.decode(Form.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateThemeData: AWSEncodableShape {
        /// The unique ID of the theme to update.
        public let id: String?
        /// The name of the theme to update.
        public let name: String?
        /// Describes the properties that can be overriden to customize the theme.
        public let overrides: [ThemeValues]?
        /// A list of key-value pairs that define the theme's properties.
        public let values: [ThemeValues]

        @inlinable
        public init(id: String? = nil, name: String? = nil, overrides: [ThemeValues]? = nil, values: [ThemeValues]) {
            self.id = id
            self.name = name
            self.overrides = overrides
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case overrides = "overrides"
            case values = "values"
        }
    }

    public struct UpdateThemeRequest: AWSEncodableShape {
        /// The unique ID for the Amplify app.
        public let appId: String
        /// The unique client token.
        public let clientToken: String?
        /// The name of the backend environment that is part of the Amplify app.
        public let environmentName: String
        /// The unique ID for the theme.
        public let id: String
        /// The configuration of the updated theme.
        public let updatedTheme: UpdateThemeData

        @inlinable
        public init(appId: String, clientToken: String? = UpdateThemeRequest.idempotencyToken(), environmentName: String, id: String, updatedTheme: UpdateThemeData) {
            self.appId = appId
            self.clientToken = clientToken
            self.environmentName = environmentName
            self.id = id
            self.updatedTheme = updatedTheme
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.environmentName, key: "environmentName")
            request.encodePath(self.id, key: "id")
            try container.encode(self.updatedTheme)
        }

        public func validate(name: String) throws {
            try self.updatedTheme.validate(name: "\(name).updatedTheme")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateThemeResponse: AWSDecodableShape {
        /// Describes the configuration of the updated theme.
        public let entity: Theme

        @inlinable
        public init(entity: Theme) {
            self.entity = entity
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.entity = try container.decode(Theme.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ValueMapping: AWSEncodableShape & AWSDecodableShape {
        /// The value to display for the complex object.
        public let displayValue: FormInputValueProperty?
        /// The complex object.
        public let value: FormInputValueProperty

        @inlinable
        public init(displayValue: FormInputValueProperty? = nil, value: FormInputValueProperty) {
            self.displayValue = displayValue
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case displayValue = "displayValue"
            case value = "value"
        }
    }

    public struct ValueMappings: AWSEncodableShape & AWSDecodableShape {
        /// The information to bind fields to data at runtime.
        public let bindingProperties: [String: FormInputBindingPropertiesValue]?
        /// The value and display value pairs.
        public let values: [ValueMapping]

        @inlinable
        public init(bindingProperties: [String: FormInputBindingPropertiesValue]? = nil, values: [ValueMapping]) {
            self.bindingProperties = bindingProperties
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case bindingProperties = "bindingProperties"
            case values = "values"
        }
    }

    public struct CodegenJobRenderConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the ReactStartCodegenJobData object.
        public let react: ReactStartCodegenJobData?

        @inlinable
        public init(react: ReactStartCodegenJobData? = nil) {
            self.react = react
        }

        private enum CodingKeys: String, CodingKey {
            case react = "react"
        }
    }
}

// MARK: - Errors

/// Error enum for AmplifyUIBuilder
public struct AmplifyUIBuilderErrorType: AWSErrorType {
    enum Code: String {
        case internalServerException = "InternalServerException"
        case invalidParameterException = "InvalidParameterException"
        case resourceConflictException = "ResourceConflictException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AmplifyUIBuilder
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An internal error has occurred. Please retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// An invalid or out-of-range value was supplied for the input parameter.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The resource specified in the request conflicts with an existing resource.
    public static var resourceConflictException: Self { .init(.resourceConflictException) }
    /// The requested resource does not exist, or access was denied.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You don't have permission to perform this operation.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension AmplifyUIBuilderErrorType: Equatable {
    public static func == (lhs: AmplifyUIBuilderErrorType, rhs: AmplifyUIBuilderErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AmplifyUIBuilderErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
