//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS ChimeSDKVoice service.
public struct ChimeSDKVoice: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the ChimeSDKVoice client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "voice-chime",
            signingName: "chime",
            serviceProtocol: .restjson,
            apiVersion: "2022-08-03",
            endpoint: endpoint,
            variantEndpoints: [
                [.fips]: .init(endpoints: [
                    "ca-central-1": "voice-chime-fips.ca-central-1.amazonaws.com",
                    "us-east-1": "voice-chime-fips.us-east-1.amazonaws.com",
                    "us-west-2": "voice-chime-fips.us-west-2.amazonaws.com"
                ])
            ],
            errorType: ChimeSDKVoiceErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    public func associatePhoneNumbersWithVoiceConnector(_ input: AssociatePhoneNumbersWithVoiceConnectorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociatePhoneNumbersWithVoiceConnectorResponse> {
        return self.client.execute(operation: "AssociatePhoneNumbersWithVoiceConnector", path: "/voice-connectors/{VoiceConnectorId}?operation=associate-phone-numbers", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func associatePhoneNumbersWithVoiceConnectorGroup(_ input: AssociatePhoneNumbersWithVoiceConnectorGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AssociatePhoneNumbersWithVoiceConnectorGroupResponse> {
        return self.client.execute(operation: "AssociatePhoneNumbersWithVoiceConnectorGroup", path: "/voice-connector-groups/{VoiceConnectorGroupId}?operation=associate-phone-numbers", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func batchDeletePhoneNumber(_ input: BatchDeletePhoneNumberRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BatchDeletePhoneNumberResponse> {
        return self.client.execute(operation: "BatchDeletePhoneNumber", path: "/phone-numbers?operation=batch-delete", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func batchUpdatePhoneNumber(_ input: BatchUpdatePhoneNumberRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BatchUpdatePhoneNumberResponse> {
        return self.client.execute(operation: "BatchUpdatePhoneNumber", path: "/phone-numbers?operation=batch-update", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createPhoneNumberOrder(_ input: CreatePhoneNumberOrderRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreatePhoneNumberOrderResponse> {
        return self.client.execute(operation: "CreatePhoneNumberOrder", path: "/phone-number-orders", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createProxySession(_ input: CreateProxySessionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateProxySessionResponse> {
        return self.client.execute(operation: "CreateProxySession", path: "/voice-connectors/{VoiceConnectorId}/proxy-sessions", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createSipMediaApplication(_ input: CreateSipMediaApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSipMediaApplicationResponse> {
        return self.client.execute(operation: "CreateSipMediaApplication", path: "/sip-media-applications", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createSipMediaApplicationCall(_ input: CreateSipMediaApplicationCallRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSipMediaApplicationCallResponse> {
        return self.client.execute(operation: "CreateSipMediaApplicationCall", path: "/sip-media-applications/{SipMediaApplicationId}/calls", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createSipRule(_ input: CreateSipRuleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateSipRuleResponse> {
        return self.client.execute(operation: "CreateSipRule", path: "/sip-rules", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createVoiceConnector(_ input: CreateVoiceConnectorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateVoiceConnectorResponse> {
        return self.client.execute(operation: "CreateVoiceConnector", path: "/voice-connectors", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func createVoiceConnectorGroup(_ input: CreateVoiceConnectorGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateVoiceConnectorGroupResponse> {
        return self.client.execute(operation: "CreateVoiceConnectorGroup", path: "/voice-connector-groups", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deletePhoneNumber(_ input: DeletePhoneNumberRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeletePhoneNumber", path: "/phone-numbers/{PhoneNumberId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteProxySession(_ input: DeleteProxySessionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteProxySession", path: "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteSipMediaApplication(_ input: DeleteSipMediaApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteSipMediaApplication", path: "/sip-media-applications/{SipMediaApplicationId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteSipRule(_ input: DeleteSipRuleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteSipRule", path: "/sip-rules/{SipRuleId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnector(_ input: DeleteVoiceConnectorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnector", path: "/voice-connectors/{VoiceConnectorId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnectorEmergencyCallingConfiguration(_ input: DeleteVoiceConnectorEmergencyCallingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnectorEmergencyCallingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnectorGroup(_ input: DeleteVoiceConnectorGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnectorGroup", path: "/voice-connector-groups/{VoiceConnectorGroupId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnectorOrigination(_ input: DeleteVoiceConnectorOriginationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnectorOrigination", path: "/voice-connectors/{VoiceConnectorId}/origination", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnectorProxy(_ input: DeleteVoiceConnectorProxyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnectorProxy", path: "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnectorStreamingConfiguration(_ input: DeleteVoiceConnectorStreamingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnectorStreamingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/streaming-configuration", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnectorTermination(_ input: DeleteVoiceConnectorTerminationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnectorTermination", path: "/voice-connectors/{VoiceConnectorId}/termination", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func deleteVoiceConnectorTerminationCredentials(_ input: DeleteVoiceConnectorTerminationCredentialsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteVoiceConnectorTerminationCredentials", path: "/voice-connectors/{VoiceConnectorId}/termination/credentials?operation=delete", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func disassociatePhoneNumbersFromVoiceConnector(_ input: DisassociatePhoneNumbersFromVoiceConnectorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociatePhoneNumbersFromVoiceConnectorResponse> {
        return self.client.execute(operation: "DisassociatePhoneNumbersFromVoiceConnector", path: "/voice-connectors/{VoiceConnectorId}?operation=disassociate-phone-numbers", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func disassociatePhoneNumbersFromVoiceConnectorGroup(_ input: DisassociatePhoneNumbersFromVoiceConnectorGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DisassociatePhoneNumbersFromVoiceConnectorGroupResponse> {
        return self.client.execute(operation: "DisassociatePhoneNumbersFromVoiceConnectorGroup", path: "/voice-connector-groups/{VoiceConnectorGroupId}?operation=disassociate-phone-numbers", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getGlobalSettings(logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGlobalSettingsResponse> {
        return self.client.execute(operation: "GetGlobalSettings", path: "/settings", httpMethod: .GET, serviceConfig: self.config, logger: logger, on: eventLoop)
    }

    public func getPhoneNumber(_ input: GetPhoneNumberRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPhoneNumberResponse> {
        return self.client.execute(operation: "GetPhoneNumber", path: "/phone-numbers/{PhoneNumberId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getPhoneNumberOrder(_ input: GetPhoneNumberOrderRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPhoneNumberOrderResponse> {
        return self.client.execute(operation: "GetPhoneNumberOrder", path: "/phone-number-orders/{PhoneNumberOrderId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getPhoneNumberSettings(logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetPhoneNumberSettingsResponse> {
        return self.client.execute(operation: "GetPhoneNumberSettings", path: "/settings/phone-number", httpMethod: .GET, serviceConfig: self.config, logger: logger, on: eventLoop)
    }

    public func getProxySession(_ input: GetProxySessionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetProxySessionResponse> {
        return self.client.execute(operation: "GetProxySession", path: "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getSipMediaApplication(_ input: GetSipMediaApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSipMediaApplicationResponse> {
        return self.client.execute(operation: "GetSipMediaApplication", path: "/sip-media-applications/{SipMediaApplicationId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getSipMediaApplicationAlexaSkillConfiguration(_ input: GetSipMediaApplicationAlexaSkillConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSipMediaApplicationAlexaSkillConfigurationResponse> {
        return self.client.execute(operation: "GetSipMediaApplicationAlexaSkillConfiguration", path: "/sip-media-applications/{SipMediaApplicationId}/alexa-skill-configuration", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getSipMediaApplicationLoggingConfiguration(_ input: GetSipMediaApplicationLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSipMediaApplicationLoggingConfigurationResponse> {
        return self.client.execute(operation: "GetSipMediaApplicationLoggingConfiguration", path: "/sip-media-applications/{SipMediaApplicationId}/logging-configuration", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getSipRule(_ input: GetSipRuleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSipRuleResponse> {
        return self.client.execute(operation: "GetSipRule", path: "/sip-rules/{SipRuleId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnector(_ input: GetVoiceConnectorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorResponse> {
        return self.client.execute(operation: "GetVoiceConnector", path: "/voice-connectors/{VoiceConnectorId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorEmergencyCallingConfiguration(_ input: GetVoiceConnectorEmergencyCallingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorEmergencyCallingConfigurationResponse> {
        return self.client.execute(operation: "GetVoiceConnectorEmergencyCallingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorGroup(_ input: GetVoiceConnectorGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorGroupResponse> {
        return self.client.execute(operation: "GetVoiceConnectorGroup", path: "/voice-connector-groups/{VoiceConnectorGroupId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorLoggingConfiguration(_ input: GetVoiceConnectorLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorLoggingConfigurationResponse> {
        return self.client.execute(operation: "GetVoiceConnectorLoggingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/logging-configuration", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorOrigination(_ input: GetVoiceConnectorOriginationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorOriginationResponse> {
        return self.client.execute(operation: "GetVoiceConnectorOrigination", path: "/voice-connectors/{VoiceConnectorId}/origination", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorProxy(_ input: GetVoiceConnectorProxyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorProxyResponse> {
        return self.client.execute(operation: "GetVoiceConnectorProxy", path: "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorStreamingConfiguration(_ input: GetVoiceConnectorStreamingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorStreamingConfigurationResponse> {
        return self.client.execute(operation: "GetVoiceConnectorStreamingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/streaming-configuration", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorTermination(_ input: GetVoiceConnectorTerminationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorTerminationResponse> {
        return self.client.execute(operation: "GetVoiceConnectorTermination", path: "/voice-connectors/{VoiceConnectorId}/termination", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func getVoiceConnectorTerminationHealth(_ input: GetVoiceConnectorTerminationHealthRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVoiceConnectorTerminationHealthResponse> {
        return self.client.execute(operation: "GetVoiceConnectorTerminationHealth", path: "/voice-connectors/{VoiceConnectorId}/termination/health", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listAvailableVoiceConnectorRegions(logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAvailableVoiceConnectorRegionsResponse> {
        return self.client.execute(operation: "ListAvailableVoiceConnectorRegions", path: "/voice-connector-regions", httpMethod: .GET, serviceConfig: self.config, logger: logger, on: eventLoop)
    }

    public func listPhoneNumberOrders(_ input: ListPhoneNumberOrdersRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListPhoneNumberOrdersResponse> {
        return self.client.execute(operation: "ListPhoneNumberOrders", path: "/phone-number-orders", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listPhoneNumbers(_ input: ListPhoneNumbersRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListPhoneNumbersResponse> {
        return self.client.execute(operation: "ListPhoneNumbers", path: "/phone-numbers", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listProxySessions(_ input: ListProxySessionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListProxySessionsResponse> {
        return self.client.execute(operation: "ListProxySessions", path: "/voice-connectors/{VoiceConnectorId}/proxy-sessions", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listSipMediaApplications(_ input: ListSipMediaApplicationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSipMediaApplicationsResponse> {
        return self.client.execute(operation: "ListSipMediaApplications", path: "/sip-media-applications", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listSipRules(_ input: ListSipRulesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSipRulesResponse> {
        return self.client.execute(operation: "ListSipRules", path: "/sip-rules", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listSupportedPhoneNumberCountries(_ input: ListSupportedPhoneNumberCountriesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSupportedPhoneNumberCountriesResponse> {
        return self.client.execute(operation: "ListSupportedPhoneNumberCountries", path: "/phone-number-countries", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listVoiceConnectorGroups(_ input: ListVoiceConnectorGroupsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListVoiceConnectorGroupsResponse> {
        return self.client.execute(operation: "ListVoiceConnectorGroups", path: "/voice-connector-groups", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listVoiceConnectorTerminationCredentials(_ input: ListVoiceConnectorTerminationCredentialsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListVoiceConnectorTerminationCredentialsResponse> {
        return self.client.execute(operation: "ListVoiceConnectorTerminationCredentials", path: "/voice-connectors/{VoiceConnectorId}/termination/credentials", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func listVoiceConnectors(_ input: ListVoiceConnectorsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListVoiceConnectorsResponse> {
        return self.client.execute(operation: "ListVoiceConnectors", path: "/voice-connectors", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putSipMediaApplicationAlexaSkillConfiguration(_ input: PutSipMediaApplicationAlexaSkillConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutSipMediaApplicationAlexaSkillConfigurationResponse> {
        return self.client.execute(operation: "PutSipMediaApplicationAlexaSkillConfiguration", path: "/sip-media-applications/{SipMediaApplicationId}/alexa-skill-configuration", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putSipMediaApplicationLoggingConfiguration(_ input: PutSipMediaApplicationLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutSipMediaApplicationLoggingConfigurationResponse> {
        return self.client.execute(operation: "PutSipMediaApplicationLoggingConfiguration", path: "/sip-media-applications/{SipMediaApplicationId}/logging-configuration", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putVoiceConnectorEmergencyCallingConfiguration(_ input: PutVoiceConnectorEmergencyCallingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutVoiceConnectorEmergencyCallingConfigurationResponse> {
        return self.client.execute(operation: "PutVoiceConnectorEmergencyCallingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putVoiceConnectorLoggingConfiguration(_ input: PutVoiceConnectorLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutVoiceConnectorLoggingConfigurationResponse> {
        return self.client.execute(operation: "PutVoiceConnectorLoggingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/logging-configuration", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putVoiceConnectorOrigination(_ input: PutVoiceConnectorOriginationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutVoiceConnectorOriginationResponse> {
        return self.client.execute(operation: "PutVoiceConnectorOrigination", path: "/voice-connectors/{VoiceConnectorId}/origination", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putVoiceConnectorProxy(_ input: PutVoiceConnectorProxyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutVoiceConnectorProxyResponse> {
        return self.client.execute(operation: "PutVoiceConnectorProxy", path: "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putVoiceConnectorStreamingConfiguration(_ input: PutVoiceConnectorStreamingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutVoiceConnectorStreamingConfigurationResponse> {
        return self.client.execute(operation: "PutVoiceConnectorStreamingConfiguration", path: "/voice-connectors/{VoiceConnectorId}/streaming-configuration", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func putVoiceConnectorTermination(_ input: PutVoiceConnectorTerminationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutVoiceConnectorTerminationResponse> {
        return self.client.execute(operation: "PutVoiceConnectorTermination", path: "/voice-connectors/{VoiceConnectorId}/termination", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func putVoiceConnectorTerminationCredentials(_ input: PutVoiceConnectorTerminationCredentialsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "PutVoiceConnectorTerminationCredentials", path: "/voice-connectors/{VoiceConnectorId}/termination/credentials?operation=put", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func restorePhoneNumber(_ input: RestorePhoneNumberRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RestorePhoneNumberResponse> {
        return self.client.execute(operation: "RestorePhoneNumber", path: "/phone-numbers/{PhoneNumberId}?operation=restore", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func searchAvailablePhoneNumbers(_ input: SearchAvailablePhoneNumbersRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<SearchAvailablePhoneNumbersResponse> {
        return self.client.execute(operation: "SearchAvailablePhoneNumbers", path: "/search?type=phone-numbers", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func updateGlobalSettings(_ input: UpdateGlobalSettingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "UpdateGlobalSettings", path: "/settings", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func updatePhoneNumber(_ input: UpdatePhoneNumberRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdatePhoneNumberResponse> {
        return self.client.execute(operation: "UpdatePhoneNumber", path: "/phone-numbers/{PhoneNumberId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    @discardableResult public func updatePhoneNumberSettings(_ input: UpdatePhoneNumberSettingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "UpdatePhoneNumberSettings", path: "/settings/phone-number", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func updateProxySession(_ input: UpdateProxySessionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateProxySessionResponse> {
        return self.client.execute(operation: "UpdateProxySession", path: "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func updateSipMediaApplication(_ input: UpdateSipMediaApplicationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateSipMediaApplicationResponse> {
        return self.client.execute(operation: "UpdateSipMediaApplication", path: "/sip-media-applications/{SipMediaApplicationId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func updateSipMediaApplicationCall(_ input: UpdateSipMediaApplicationCallRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateSipMediaApplicationCallResponse> {
        return self.client.execute(operation: "UpdateSipMediaApplicationCall", path: "/sip-media-applications/{SipMediaApplicationId}/calls/{TransactionId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func updateSipRule(_ input: UpdateSipRuleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateSipRuleResponse> {
        return self.client.execute(operation: "UpdateSipRule", path: "/sip-rules/{SipRuleId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func updateVoiceConnector(_ input: UpdateVoiceConnectorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateVoiceConnectorResponse> {
        return self.client.execute(operation: "UpdateVoiceConnector", path: "/voice-connectors/{VoiceConnectorId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func updateVoiceConnectorGroup(_ input: UpdateVoiceConnectorGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateVoiceConnectorGroupResponse> {
        return self.client.execute(operation: "UpdateVoiceConnectorGroup", path: "/voice-connector-groups/{VoiceConnectorGroupId}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    public func validateE911Address(_ input: ValidateE911AddressRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ValidateE911AddressResponse> {
        return self.client.execute(operation: "ValidateE911Address", path: "/emergency-calling/address", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension ChimeSDKVoice {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: ChimeSDKVoice, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension ChimeSDKVoice {
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPhoneNumberOrdersPaginator<Result>(
        _ input: ListPhoneNumberOrdersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPhoneNumberOrdersResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listPhoneNumberOrders,
            inputKey: \ListPhoneNumberOrdersRequest.nextToken,
            outputKey: \ListPhoneNumberOrdersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPhoneNumberOrdersPaginator(
        _ input: ListPhoneNumberOrdersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPhoneNumberOrdersResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listPhoneNumberOrders,
            inputKey: \ListPhoneNumberOrdersRequest.nextToken,
            outputKey: \ListPhoneNumberOrdersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPhoneNumbersPaginator<Result>(
        _ input: ListPhoneNumbersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPhoneNumbersResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listPhoneNumbers,
            inputKey: \ListPhoneNumbersRequest.nextToken,
            outputKey: \ListPhoneNumbersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPhoneNumbersPaginator(
        _ input: ListPhoneNumbersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPhoneNumbersResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listPhoneNumbers,
            inputKey: \ListPhoneNumbersRequest.nextToken,
            outputKey: \ListPhoneNumbersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProxySessionsPaginator<Result>(
        _ input: ListProxySessionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProxySessionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listProxySessions,
            inputKey: \ListProxySessionsRequest.nextToken,
            outputKey: \ListProxySessionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProxySessionsPaginator(
        _ input: ListProxySessionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProxySessionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listProxySessions,
            inputKey: \ListProxySessionsRequest.nextToken,
            outputKey: \ListProxySessionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSipMediaApplicationsPaginator<Result>(
        _ input: ListSipMediaApplicationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSipMediaApplicationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSipMediaApplications,
            inputKey: \ListSipMediaApplicationsRequest.nextToken,
            outputKey: \ListSipMediaApplicationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSipMediaApplicationsPaginator(
        _ input: ListSipMediaApplicationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSipMediaApplicationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSipMediaApplications,
            inputKey: \ListSipMediaApplicationsRequest.nextToken,
            outputKey: \ListSipMediaApplicationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSipRulesPaginator<Result>(
        _ input: ListSipRulesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSipRulesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSipRules,
            inputKey: \ListSipRulesRequest.nextToken,
            outputKey: \ListSipRulesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSipRulesPaginator(
        _ input: ListSipRulesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSipRulesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSipRules,
            inputKey: \ListSipRulesRequest.nextToken,
            outputKey: \ListSipRulesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listVoiceConnectorGroupsPaginator<Result>(
        _ input: ListVoiceConnectorGroupsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListVoiceConnectorGroupsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listVoiceConnectorGroups,
            inputKey: \ListVoiceConnectorGroupsRequest.nextToken,
            outputKey: \ListVoiceConnectorGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listVoiceConnectorGroupsPaginator(
        _ input: ListVoiceConnectorGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListVoiceConnectorGroupsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listVoiceConnectorGroups,
            inputKey: \ListVoiceConnectorGroupsRequest.nextToken,
            outputKey: \ListVoiceConnectorGroupsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listVoiceConnectorsPaginator<Result>(
        _ input: ListVoiceConnectorsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListVoiceConnectorsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listVoiceConnectors,
            inputKey: \ListVoiceConnectorsRequest.nextToken,
            outputKey: \ListVoiceConnectorsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listVoiceConnectorsPaginator(
        _ input: ListVoiceConnectorsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListVoiceConnectorsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listVoiceConnectors,
            inputKey: \ListVoiceConnectorsRequest.nextToken,
            outputKey: \ListVoiceConnectorsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchAvailablePhoneNumbersPaginator<Result>(
        _ input: SearchAvailablePhoneNumbersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchAvailablePhoneNumbersResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.searchAvailablePhoneNumbers,
            inputKey: \SearchAvailablePhoneNumbersRequest.nextToken,
            outputKey: \SearchAvailablePhoneNumbersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchAvailablePhoneNumbersPaginator(
        _ input: SearchAvailablePhoneNumbersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchAvailablePhoneNumbersResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.searchAvailablePhoneNumbers,
            inputKey: \SearchAvailablePhoneNumbersRequest.nextToken,
            outputKey: \SearchAvailablePhoneNumbersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension ChimeSDKVoice.ListPhoneNumberOrdersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.ListPhoneNumberOrdersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ChimeSDKVoice.ListPhoneNumbersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.ListPhoneNumbersRequest {
        return .init(
            filterName: self.filterName,
            filterValue: self.filterValue,
            maxResults: self.maxResults,
            nextToken: token,
            productType: self.productType,
            status: self.status
        )
    }
}

extension ChimeSDKVoice.ListProxySessionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.ListProxySessionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status,
            voiceConnectorId: self.voiceConnectorId
        )
    }
}

extension ChimeSDKVoice.ListSipMediaApplicationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.ListSipMediaApplicationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ChimeSDKVoice.ListSipRulesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.ListSipRulesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            sipMediaApplicationId: self.sipMediaApplicationId
        )
    }
}

extension ChimeSDKVoice.ListVoiceConnectorGroupsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.ListVoiceConnectorGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ChimeSDKVoice.ListVoiceConnectorsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.ListVoiceConnectorsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ChimeSDKVoice.SearchAvailablePhoneNumbersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ChimeSDKVoice.SearchAvailablePhoneNumbersRequest {
        return .init(
            areaCode: self.areaCode,
            city: self.city,
            country: self.country,
            maxResults: self.maxResults,
            nextToken: token,
            phoneNumberType: self.phoneNumberType,
            state: self.state,
            tollFreePrefix: self.tollFreePrefix
        )
    }
}
