//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS MemoryDB service.
///
/// MemoryDB is a fully managed, Redis OSS-compatible, in-memory database that delivers ultra-fast performance and Multi-AZ durability for modern applications built using microservices architectures.  MemoryDB stores the entire database in-memory, enabling low latency and high throughput data access. It is compatible with Redis OSS, a popular open source data store, enabling you to leverage Redis OSSâ€™ flexible and friendly data structures, APIs, and commands.
public struct MemoryDB: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the MemoryDB client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "AmazonMemoryDB",
            serviceName: "MemoryDB",
            serviceIdentifier: "memory-db",
            signingName: "memorydb",
            serviceProtocol: .json(version: "1.1"),
            apiVersion: "2021-01-01",
            endpoint: endpoint,
            serviceEndpoints: Self.serviceEndpoints,
            errorType: MemoryDBErrorType.self,
            xmlNamespace: "http://memorydb.amazonaws.com/doc/2021-01-01/",
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }


    /// custom endpoints for regions
    static var serviceEndpoints: [String: String] {[
        "fips": "memory-db-fips.us-west-1.amazonaws.com"
    ]}



    // MARK: API Calls

    /// Apply the service update to a list of clusters supplied. For more information on service updates and applying them, see Applying the service updates.
    @Sendable
    @inlinable
    public func batchUpdateCluster(_ input: BatchUpdateClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateClusterResponse {
        try await self.client.execute(
            operation: "BatchUpdateCluster", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Apply the service update to a list of clusters supplied. For more information on service updates and applying them, see Applying the service updates.
    ///
    /// Parameters:
    ///   - clusterNames: The cluster names to apply the updates.
    ///   - serviceUpdate: The unique ID of the service update
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateCluster(
        clusterNames: [String],
        serviceUpdate: ServiceUpdateRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateClusterResponse {
        let input = BatchUpdateClusterRequest(
            clusterNames: clusterNames, 
            serviceUpdate: serviceUpdate
        )
        return try await self.batchUpdateCluster(input, logger: logger)
    }

    /// Makes a copy of an existing snapshot.
    @Sendable
    @inlinable
    public func copySnapshot(_ input: CopySnapshotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CopySnapshotResponse {
        try await self.client.execute(
            operation: "CopySnapshot", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Makes a copy of an existing snapshot.
    ///
    /// Parameters:
    ///   - kmsKeyId: The ID of the KMS key used to encrypt the target snapshot.
    ///   - sourceSnapshotName: The name of an existing snapshot from which to make a copy.
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - targetBucket: The Amazon S3 bucket to which the snapshot is exported. This parameter is used only when exporting a snapshot for external access.  When using this parameter to export a snapshot, be sure MemoryDB has the needed permissions to this S3 bucket. For more information, see   Step 2: Grant MemoryDB Access to Your Amazon S3 Bucket.
    ///   - targetSnapshotName: A name for the snapshot copy. MemoryDB does not permit overwriting a snapshot, therefore this name must be unique within its context - MemoryDB or an Amazon S3 bucket if exporting.
    ///   - logger: Logger use during operation
    @inlinable
    public func copySnapshot(
        kmsKeyId: String? = nil,
        sourceSnapshotName: String,
        tags: [Tag]? = nil,
        targetBucket: String? = nil,
        targetSnapshotName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CopySnapshotResponse {
        let input = CopySnapshotRequest(
            kmsKeyId: kmsKeyId, 
            sourceSnapshotName: sourceSnapshotName, 
            tags: tags, 
            targetBucket: targetBucket, 
            targetSnapshotName: targetSnapshotName
        )
        return try await self.copySnapshot(input, logger: logger)
    }

    /// Creates an Access Control List. For more information, see Authenticating users with Access Contol Lists (ACLs).
    @Sendable
    @inlinable
    public func createACL(_ input: CreateACLRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateACLResponse {
        try await self.client.execute(
            operation: "CreateACL", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an Access Control List. For more information, see Authenticating users with Access Contol Lists (ACLs).
    ///
    /// Parameters:
    ///   - aclName: The name of the Access Control List.
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - userNames: The list of users that belong to the Access Control List.
    ///   - logger: Logger use during operation
    @inlinable
    public func createACL(
        aclName: String,
        tags: [Tag]? = nil,
        userNames: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateACLResponse {
        let input = CreateACLRequest(
            aclName: aclName, 
            tags: tags, 
            userNames: userNames
        )
        return try await self.createACL(input, logger: logger)
    }

    /// Creates a cluster. All nodes in the cluster run the same protocol-compliant engine software.
    @Sendable
    @inlinable
    public func createCluster(_ input: CreateClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateClusterResponse {
        try await self.client.execute(
            operation: "CreateCluster", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a cluster. All nodes in the cluster run the same protocol-compliant engine software.
    ///
    /// Parameters:
    ///   - aclName: The name of the Access Control List to associate with the cluster.
    ///   - autoMinorVersionUpgrade: When set to true, the cluster will automatically receive minor engine version upgrades after launch.
    ///   - clusterName: The name of the cluster. This value must be unique as it also serves as the cluster identifier.
    ///   - dataTiering: Enables data tiering. Data tiering is only supported for clusters using the r6gd node type.  This parameter must be set when using r6gd nodes. For more information, see Data tiering.
    ///   - description: An optional description of the cluster.
    ///   - engineVersion: The version number of the Redis OSS engine to be used for the cluster.
    ///   - kmsKeyId: The ID of the KMS key used to encrypt the cluster.
    ///   - maintenanceWindow: Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:    sun     mon     tue     wed     thu     fri     sat    Example: sun:23:00-mon:01:30
    ///   - nodeType: The compute and memory capacity of the nodes in the cluster.
    ///   - numReplicasPerShard: The number of replicas to apply to each shard. The default value is 1. The maximum is 5.
    ///   - numShards: The number of shards the cluster will contain. The default value is 1.
    ///   - parameterGroupName: The name of the parameter group associated with the cluster.
    ///   - port: The port number on which each of the nodes accepts connections.
    ///   - securityGroupIds: A list of security group names to associate with this cluster.
    ///   - snapshotArns: A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.
    ///   - snapshotName: The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.
    ///   - snapshotRetentionLimit: The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
    ///   - snapshotWindow: The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard. Example: 05:00-09:00 If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.
    ///   - snsTopicArn: The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.
    ///   - subnetGroupName: The name of the subnet group to be used for the cluster.
    ///   - tags: A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.
    ///   - tlsEnabled: A flag to enable in-transit encryption on the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCluster(
        aclName: String,
        autoMinorVersionUpgrade: Bool? = nil,
        clusterName: String,
        dataTiering: Bool? = nil,
        description: String? = nil,
        engineVersion: String? = nil,
        kmsKeyId: String? = nil,
        maintenanceWindow: String? = nil,
        nodeType: String,
        numReplicasPerShard: Int? = nil,
        numShards: Int? = nil,
        parameterGroupName: String? = nil,
        port: Int? = nil,
        securityGroupIds: [String]? = nil,
        snapshotArns: [String]? = nil,
        snapshotName: String? = nil,
        snapshotRetentionLimit: Int? = nil,
        snapshotWindow: String? = nil,
        snsTopicArn: String? = nil,
        subnetGroupName: String? = nil,
        tags: [Tag]? = nil,
        tlsEnabled: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateClusterResponse {
        let input = CreateClusterRequest(
            aclName: aclName, 
            autoMinorVersionUpgrade: autoMinorVersionUpgrade, 
            clusterName: clusterName, 
            dataTiering: dataTiering, 
            description: description, 
            engineVersion: engineVersion, 
            kmsKeyId: kmsKeyId, 
            maintenanceWindow: maintenanceWindow, 
            nodeType: nodeType, 
            numReplicasPerShard: numReplicasPerShard, 
            numShards: numShards, 
            parameterGroupName: parameterGroupName, 
            port: port, 
            securityGroupIds: securityGroupIds, 
            snapshotArns: snapshotArns, 
            snapshotName: snapshotName, 
            snapshotRetentionLimit: snapshotRetentionLimit, 
            snapshotWindow: snapshotWindow, 
            snsTopicArn: snsTopicArn, 
            subnetGroupName: subnetGroupName, 
            tags: tags, 
            tlsEnabled: tlsEnabled
        )
        return try await self.createCluster(input, logger: logger)
    }

    /// Creates a new MemoryDB parameter group. A parameter group is a collection of parameters and their values that are applied to all of the nodes in any cluster. For  more information, see Configuring engine parameters using parameter groups.
    @Sendable
    @inlinable
    public func createParameterGroup(_ input: CreateParameterGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateParameterGroupResponse {
        try await self.client.execute(
            operation: "CreateParameterGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new MemoryDB parameter group. A parameter group is a collection of parameters and their values that are applied to all of the nodes in any cluster. For  more information, see Configuring engine parameters using parameter groups.
    ///
    /// Parameters:
    ///   - description: An optional description of the parameter group.
    ///   - family: The name of the parameter group family that the parameter group can be used with.
    ///   - parameterGroupName: The name of the parameter group.
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - logger: Logger use during operation
    @inlinable
    public func createParameterGroup(
        description: String? = nil,
        family: String,
        parameterGroupName: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateParameterGroupResponse {
        let input = CreateParameterGroupRequest(
            description: description, 
            family: family, 
            parameterGroupName: parameterGroupName, 
            tags: tags
        )
        return try await self.createParameterGroup(input, logger: logger)
    }

    /// Creates a copy of an entire cluster at a specific moment in time.
    @Sendable
    @inlinable
    public func createSnapshot(_ input: CreateSnapshotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSnapshotResponse {
        try await self.client.execute(
            operation: "CreateSnapshot", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a copy of an entire cluster at a specific moment in time.
    ///
    /// Parameters:
    ///   - clusterName: The snapshot is created from this cluster.
    ///   - kmsKeyId: The ID of the KMS key used to encrypt the snapshot.
    ///   - snapshotName: A name for the snapshot being created.
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSnapshot(
        clusterName: String,
        kmsKeyId: String? = nil,
        snapshotName: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSnapshotResponse {
        let input = CreateSnapshotRequest(
            clusterName: clusterName, 
            kmsKeyId: kmsKeyId, 
            snapshotName: snapshotName, 
            tags: tags
        )
        return try await self.createSnapshot(input, logger: logger)
    }

    /// Creates a subnet group. A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.  When you create a cluster in an Amazon VPC, you must specify a subnet group. MemoryDB uses that subnet group to choose a subnet and IP addresses within that subnet to associate with your nodes.  For more information, see Subnets and subnet groups.
    @Sendable
    @inlinable
    public func createSubnetGroup(_ input: CreateSubnetGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSubnetGroupResponse {
        try await self.client.execute(
            operation: "CreateSubnetGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a subnet group. A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.  When you create a cluster in an Amazon VPC, you must specify a subnet group. MemoryDB uses that subnet group to choose a subnet and IP addresses within that subnet to associate with your nodes.  For more information, see Subnets and subnet groups.
    ///
    /// Parameters:
    ///   - description: A description for the subnet group.
    ///   - subnetGroupName: The name of the subnet group.
    ///   - subnetIds: A list of VPC subnet IDs for the subnet group.
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSubnetGroup(
        description: String? = nil,
        subnetGroupName: String,
        subnetIds: [String],
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSubnetGroupResponse {
        let input = CreateSubnetGroupRequest(
            description: description, 
            subnetGroupName: subnetGroupName, 
            subnetIds: subnetIds, 
            tags: tags
        )
        return try await self.createSubnetGroup(input, logger: logger)
    }

    /// Creates a MemoryDB user. For more information, see Authenticating users with Access Contol Lists (ACLs).
    @Sendable
    @inlinable
    public func createUser(_ input: CreateUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateUserResponse {
        try await self.client.execute(
            operation: "CreateUser", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a MemoryDB user. For more information, see Authenticating users with Access Contol Lists (ACLs).
    ///
    /// Parameters:
    ///   - accessString: Access permissions string used for this user.
    ///   - authenticationMode: Denotes the user's authentication properties, such as whether it requires a password to authenticate.
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - userName: The name of the user. This value must be unique as it also serves as the user identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func createUser(
        accessString: String,
        authenticationMode: AuthenticationMode,
        tags: [Tag]? = nil,
        userName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateUserResponse {
        let input = CreateUserRequest(
            accessString: accessString, 
            authenticationMode: authenticationMode, 
            tags: tags, 
            userName: userName
        )
        return try await self.createUser(input, logger: logger)
    }

    /// Deletes an Access Control List. The ACL must first be disassociated from the cluster before it can be deleted. For more information, see Authenticating users with Access Contol Lists (ACLs).
    @Sendable
    @inlinable
    public func deleteACL(_ input: DeleteACLRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteACLResponse {
        try await self.client.execute(
            operation: "DeleteACL", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Access Control List. The ACL must first be disassociated from the cluster before it can be deleted. For more information, see Authenticating users with Access Contol Lists (ACLs).
    ///
    /// Parameters:
    ///   - aclName: The name of the Access Control List to delete
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteACL(
        aclName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteACLResponse {
        let input = DeleteACLRequest(
            aclName: aclName
        )
        return try await self.deleteACL(input, logger: logger)
    }

    /// Deletes a cluster. It also deletes all associated nodes and node endpoints   CreateSnapshot permission is required to create a final snapshot.  Without this permission, the API call will fail with an Access Denied exception.
    @Sendable
    @inlinable
    public func deleteCluster(_ input: DeleteClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteClusterResponse {
        try await self.client.execute(
            operation: "DeleteCluster", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a cluster. It also deletes all associated nodes and node endpoints   CreateSnapshot permission is required to create a final snapshot.  Without this permission, the API call will fail with an Access Denied exception.
    ///
    /// Parameters:
    ///   - clusterName: The name of the cluster to be deleted
    ///   - finalSnapshotName: The user-supplied name of a final cluster snapshot. This is the unique name that identifies the snapshot. MemoryDB creates the snapshot, and then deletes the cluster immediately afterward.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCluster(
        clusterName: String,
        finalSnapshotName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteClusterResponse {
        let input = DeleteClusterRequest(
            clusterName: clusterName, 
            finalSnapshotName: finalSnapshotName
        )
        return try await self.deleteCluster(input, logger: logger)
    }

    /// Deletes the specified parameter group. You cannot delete a parameter group if it is associated with any clusters.  You cannot delete the default parameter groups in your account.
    @Sendable
    @inlinable
    public func deleteParameterGroup(_ input: DeleteParameterGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteParameterGroupResponse {
        try await self.client.execute(
            operation: "DeleteParameterGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified parameter group. You cannot delete a parameter group if it is associated with any clusters.  You cannot delete the default parameter groups in your account.
    ///
    /// Parameters:
    ///   - parameterGroupName: The name of the parameter group to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteParameterGroup(
        parameterGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteParameterGroupResponse {
        let input = DeleteParameterGroupRequest(
            parameterGroupName: parameterGroupName
        )
        return try await self.deleteParameterGroup(input, logger: logger)
    }

    /// Deletes an existing snapshot. When you receive a successful response from this operation, MemoryDB immediately begins deleting the snapshot; you cannot cancel or revert this operation.
    @Sendable
    @inlinable
    public func deleteSnapshot(_ input: DeleteSnapshotRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSnapshotResponse {
        try await self.client.execute(
            operation: "DeleteSnapshot", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing snapshot. When you receive a successful response from this operation, MemoryDB immediately begins deleting the snapshot; you cannot cancel or revert this operation.
    ///
    /// Parameters:
    ///   - snapshotName: The name of the snapshot to delete
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSnapshot(
        snapshotName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSnapshotResponse {
        let input = DeleteSnapshotRequest(
            snapshotName: snapshotName
        )
        return try await self.deleteSnapshot(input, logger: logger)
    }

    /// Deletes a subnet group. You cannot delete a default subnet group or one that is associated with any clusters.
    @Sendable
    @inlinable
    public func deleteSubnetGroup(_ input: DeleteSubnetGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSubnetGroupResponse {
        try await self.client.execute(
            operation: "DeleteSubnetGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a subnet group. You cannot delete a default subnet group or one that is associated with any clusters.
    ///
    /// Parameters:
    ///   - subnetGroupName: The name of the subnet group to delete
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSubnetGroup(
        subnetGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSubnetGroupResponse {
        let input = DeleteSubnetGroupRequest(
            subnetGroupName: subnetGroupName
        )
        return try await self.deleteSubnetGroup(input, logger: logger)
    }

    /// Deletes a user. The user will be removed from all ACLs and in turn removed from all clusters.
    @Sendable
    @inlinable
    public func deleteUser(_ input: DeleteUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteUserResponse {
        try await self.client.execute(
            operation: "DeleteUser", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a user. The user will be removed from all ACLs and in turn removed from all clusters.
    ///
    /// Parameters:
    ///   - userName: The name of the user to delete
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteUser(
        userName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteUserResponse {
        let input = DeleteUserRequest(
            userName: userName
        )
        return try await self.deleteUser(input, logger: logger)
    }

    /// Returns a list of ACLs
    @Sendable
    @inlinable
    public func describeACLs(_ input: DescribeACLsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeACLsResponse {
        try await self.client.execute(
            operation: "DescribeACLs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of ACLs
    ///
    /// Parameters:
    ///   - aclName: The name of the ACL
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeACLs(
        aclName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeACLsResponse {
        let input = DescribeACLsRequest(
            aclName: aclName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeACLs(input, logger: logger)
    }

    /// Returns information about all provisioned clusters if no cluster identifier is specified, or about a specific cluster if a cluster name is supplied.
    @Sendable
    @inlinable
    public func describeClusters(_ input: DescribeClustersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeClustersResponse {
        try await self.client.execute(
            operation: "DescribeClusters", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about all provisioned clusters if no cluster identifier is specified, or about a specific cluster if a cluster name is supplied.
    ///
    /// Parameters:
    ///   - clusterName: The name of the cluster
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - showShardDetails: An optional flag that can be included in the request to retrieve information about the individual shard(s).
    ///   - logger: Logger use during operation
    @inlinable
    public func describeClusters(
        clusterName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        showShardDetails: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeClustersResponse {
        let input = DescribeClustersRequest(
            clusterName: clusterName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            showShardDetails: showShardDetails
        )
        return try await self.describeClusters(input, logger: logger)
    }

    /// Returns a list of the available Redis OSS engine versions.
    @Sendable
    @inlinable
    public func describeEngineVersions(_ input: DescribeEngineVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEngineVersionsResponse {
        try await self.client.execute(
            operation: "DescribeEngineVersions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the available Redis OSS engine versions.
    ///
    /// Parameters:
    ///   - defaultOnly: If true, specifies that only the default version of the specified engine or engine and major version combination is to be returned.
    ///   - engineVersion: The Redis OSS engine version
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - parameterGroupFamily: The name of a specific parameter group family to return details for.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeEngineVersions(
        defaultOnly: Bool? = nil,
        engineVersion: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        parameterGroupFamily: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeEngineVersionsResponse {
        let input = DescribeEngineVersionsRequest(
            defaultOnly: defaultOnly, 
            engineVersion: engineVersion, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            parameterGroupFamily: parameterGroupFamily
        )
        return try await self.describeEngineVersions(input, logger: logger)
    }

    /// Returns events related to clusters, security groups, and parameter groups. You can obtain events specific to a particular cluster, security group, or parameter group by providing the name as a parameter.  By default, only the events occurring within the last hour are returned; however, you can retrieve up to 14 days' worth of events if necessary.
    @Sendable
    @inlinable
    public func describeEvents(_ input: DescribeEventsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEventsResponse {
        try await self.client.execute(
            operation: "DescribeEvents", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns events related to clusters, security groups, and parameter groups. You can obtain events specific to a particular cluster, security group, or parameter group by providing the name as a parameter.  By default, only the events occurring within the last hour are returned; however, you can retrieve up to 14 days' worth of events if necessary.
    ///
    /// Parameters:
    ///   - duration: The number of minutes worth of events to retrieve.
    ///   - endTime: The end of the time interval for which to retrieve events, specified in ISO 8601 format.  Example: 2017-03-30T07:03:49.555Z
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - sourceName: The identifier of the event source for which events are returned. If not specified, all sources are included in the response.
    ///   - sourceType: The event source to retrieve events for. If no value is specified, all events are returned.
    ///   - startTime: The beginning of the time interval to retrieve events for, specified in ISO 8601 format.  Example: 2017-03-30T07:03:49.555Z
    ///   - logger: Logger use during operation
    @inlinable
    public func describeEvents(
        duration: Int? = nil,
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sourceName: String? = nil,
        sourceType: SourceType? = nil,
        startTime: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeEventsResponse {
        let input = DescribeEventsRequest(
            duration: duration, 
            endTime: endTime, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sourceName: sourceName, 
            sourceType: sourceType, 
            startTime: startTime
        )
        return try await self.describeEvents(input, logger: logger)
    }

    /// Returns a list of parameter group descriptions. If a parameter group name is specified, the list contains only the descriptions for that group.
    @Sendable
    @inlinable
    public func describeParameterGroups(_ input: DescribeParameterGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeParameterGroupsResponse {
        try await self.client.execute(
            operation: "DescribeParameterGroups", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of parameter group descriptions. If a parameter group name is specified, the list contains only the descriptions for that group.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - parameterGroupName: The name of a specific  parameter group to return details for.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeParameterGroups(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        parameterGroupName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeParameterGroupsResponse {
        let input = DescribeParameterGroupsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            parameterGroupName: parameterGroupName
        )
        return try await self.describeParameterGroups(input, logger: logger)
    }

    /// Returns the detailed parameter list for a particular parameter group.
    @Sendable
    @inlinable
    public func describeParameters(_ input: DescribeParametersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeParametersResponse {
        try await self.client.execute(
            operation: "DescribeParameters", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the detailed parameter list for a particular parameter group.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - parameterGroupName: he name of a specific  parameter group to return details for.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeParameters(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        parameterGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeParametersResponse {
        let input = DescribeParametersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            parameterGroupName: parameterGroupName
        )
        return try await self.describeParameters(input, logger: logger)
    }

    /// Returns information about reserved nodes for this account, or about a specified reserved node.
    @Sendable
    @inlinable
    public func describeReservedNodes(_ input: DescribeReservedNodesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReservedNodesResponse {
        try await self.client.execute(
            operation: "DescribeReservedNodes", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about reserved nodes for this account, or about a specified reserved node.
    ///
    /// Parameters:
    ///   - duration: The duration filter value, specified in years or seconds. Use this parameter to show only reservations for this duration.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    ///   - nodeType: The node type filter value. Use this parameter to show only those reservations matching the specified  node type. For more information, see Supported node types.
    ///   - offeringType: The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type.  Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    ///   - reservationId: The reserved node identifier filter value. Use this parameter to show only the reservation that matches the specified reservation ID.
    ///   - reservedNodesOfferingId: The offering identifier filter value. Use this parameter to show only purchased reservations matching the specified offering identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeReservedNodes(
        duration: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        nodeType: String? = nil,
        offeringType: String? = nil,
        reservationId: String? = nil,
        reservedNodesOfferingId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeReservedNodesResponse {
        let input = DescribeReservedNodesRequest(
            duration: duration, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            nodeType: nodeType, 
            offeringType: offeringType, 
            reservationId: reservationId, 
            reservedNodesOfferingId: reservedNodesOfferingId
        )
        return try await self.describeReservedNodes(input, logger: logger)
    }

    /// Lists available reserved node offerings.
    @Sendable
    @inlinable
    public func describeReservedNodesOfferings(_ input: DescribeReservedNodesOfferingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReservedNodesOfferingsResponse {
        try await self.client.execute(
            operation: "DescribeReservedNodesOfferings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists available reserved node offerings.
    ///
    /// Parameters:
    ///   - duration: Duration filter value, specified in years or seconds. Use this parameter to show only reservations for a given duration.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional marker returned from a prior request. Use this marker for pagination of results from this operation. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    ///   - nodeType: The node type for the reserved nodes. For more information, see Supported node types.
    ///   - offeringType: The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type.  Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    ///   - reservedNodesOfferingId: The offering identifier filter value. Use this parameter to show only the available offering that matches the specified reservation identifier.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeReservedNodesOfferings(
        duration: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        nodeType: String? = nil,
        offeringType: String? = nil,
        reservedNodesOfferingId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeReservedNodesOfferingsResponse {
        let input = DescribeReservedNodesOfferingsRequest(
            duration: duration, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            nodeType: nodeType, 
            offeringType: offeringType, 
            reservedNodesOfferingId: reservedNodesOfferingId
        )
        return try await self.describeReservedNodesOfferings(input, logger: logger)
    }

    /// Returns details of the service updates
    @Sendable
    @inlinable
    public func describeServiceUpdates(_ input: DescribeServiceUpdatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeServiceUpdatesResponse {
        try await self.client.execute(
            operation: "DescribeServiceUpdates", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns details of the service updates
    ///
    /// Parameters:
    ///   - clusterNames: The list of cluster names to identify service updates to apply
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - serviceUpdateName: The unique ID of the service update to describe.
    ///   - status: The status(es) of the service updates to filter on
    ///   - logger: Logger use during operation
    @inlinable
    public func describeServiceUpdates(
        clusterNames: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceUpdateName: String? = nil,
        status: [ServiceUpdateStatus]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeServiceUpdatesResponse {
        let input = DescribeServiceUpdatesRequest(
            clusterNames: clusterNames, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            serviceUpdateName: serviceUpdateName, 
            status: status
        )
        return try await self.describeServiceUpdates(input, logger: logger)
    }

    /// Returns information about cluster snapshots. By default, DescribeSnapshots lists all of your snapshots; it can optionally describe a single snapshot,  or just the snapshots associated with a particular cluster.
    @Sendable
    @inlinable
    public func describeSnapshots(_ input: DescribeSnapshotsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSnapshotsResponse {
        try await self.client.execute(
            operation: "DescribeSnapshots", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about cluster snapshots. By default, DescribeSnapshots lists all of your snapshots; it can optionally describe a single snapshot,  or just the snapshots associated with a particular cluster.
    ///
    /// Parameters:
    ///   - clusterName: A user-supplied cluster identifier. If this parameter is specified, only snapshots associated with that specific cluster are described.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - showDetail: A Boolean value which if true, the shard configuration is included in the snapshot description.
    ///   - snapshotName: A user-supplied name of the snapshot. If this parameter is specified, only this named snapshot is described.
    ///   - source: If set to system, the output shows snapshots that were automatically created by MemoryDB. If set to user the output shows snapshots that were manually created. If omitted, the output shows both automatically and manually created snapshots.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSnapshots(
        clusterName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        showDetail: Bool? = nil,
        snapshotName: String? = nil,
        source: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSnapshotsResponse {
        let input = DescribeSnapshotsRequest(
            clusterName: clusterName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            showDetail: showDetail, 
            snapshotName: snapshotName, 
            source: source
        )
        return try await self.describeSnapshots(input, logger: logger)
    }

    /// Returns a list of subnet group descriptions. If a subnet group name is specified, the list contains only the description of that group.
    @Sendable
    @inlinable
    public func describeSubnetGroups(_ input: DescribeSubnetGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSubnetGroupsResponse {
        try await self.client.execute(
            operation: "DescribeSubnetGroups", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of subnet group descriptions. If a subnet group name is specified, the list contains only the description of that group.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - subnetGroupName: The name of the subnet group to return details for.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSubnetGroups(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        subnetGroupName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSubnetGroupsResponse {
        let input = DescribeSubnetGroupsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            subnetGroupName: subnetGroupName
        )
        return try await self.describeSubnetGroups(input, logger: logger)
    }

    /// Returns a list of users.
    @Sendable
    @inlinable
    public func describeUsers(_ input: DescribeUsersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeUsersResponse {
        try await self.client.execute(
            operation: "DescribeUsers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of users.
    ///
    /// Parameters:
    ///   - filters: Filter to determine the list of users to return.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - nextToken: An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///   - userName: The name of the user
    ///   - logger: Logger use during operation
    @inlinable
    public func describeUsers(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        userName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeUsersResponse {
        let input = DescribeUsersRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            userName: userName
        )
        return try await self.describeUsers(input, logger: logger)
    }

    /// Used to failover a shard. This API is designed for testing the behavior of your application in case of MemoryDB failover. It is not designed to be used as a production-level tool for initiating a failover to overcome a problem you may have with the cluster. Moreover, in certain conditions such as large scale operational events, Amazon may block this API.
    @Sendable
    @inlinable
    public func failoverShard(_ input: FailoverShardRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> FailoverShardResponse {
        try await self.client.execute(
            operation: "FailoverShard", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Used to failover a shard. This API is designed for testing the behavior of your application in case of MemoryDB failover. It is not designed to be used as a production-level tool for initiating a failover to overcome a problem you may have with the cluster. Moreover, in certain conditions such as large scale operational events, Amazon may block this API.
    ///
    /// Parameters:
    ///   - clusterName: The cluster being failed over
    ///   - shardName: The name of the shard
    ///   - logger: Logger use during operation
    @inlinable
    public func failoverShard(
        clusterName: String,
        shardName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> FailoverShardResponse {
        let input = FailoverShardRequest(
            clusterName: clusterName, 
            shardName: shardName
        )
        return try await self.failoverShard(input, logger: logger)
    }

    /// Lists all available node types that you can scale to from your cluster's current node type.  When you use the UpdateCluster operation to scale your cluster, the value of the NodeType parameter must be one of the node types returned by this operation.
    @Sendable
    @inlinable
    public func listAllowedNodeTypeUpdates(_ input: ListAllowedNodeTypeUpdatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAllowedNodeTypeUpdatesResponse {
        try await self.client.execute(
            operation: "ListAllowedNodeTypeUpdates", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all available node types that you can scale to from your cluster's current node type.  When you use the UpdateCluster operation to scale your cluster, the value of the NodeType parameter must be one of the node types returned by this operation.
    ///
    /// Parameters:
    ///   - clusterName: The name of the cluster you want to scale. MemoryDB uses the cluster name to identify the current node type being used by this cluster, and from that to create a list of node types you can scale up to.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAllowedNodeTypeUpdates(
        clusterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAllowedNodeTypeUpdatesResponse {
        let input = ListAllowedNodeTypeUpdatesRequest(
            clusterName: clusterName
        )
        return try await self.listAllowedNodeTypeUpdates(input, logger: logger)
    }

    /// Lists all tags currently on a named resource.  A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track your MemoryDB resources.  For more information, see Tagging your MemoryDB resources
    @Sendable
    @inlinable
    public func listTags(_ input: ListTagsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsResponse {
        try await self.client.execute(
            operation: "ListTags", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all tags currently on a named resource.  A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track your MemoryDB resources.  For more information, see Tagging your MemoryDB resources
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which you want the list of tags
    ///   - logger: Logger use during operation
    @inlinable
    public func listTags(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsResponse {
        let input = ListTagsRequest(
            resourceArn: resourceArn
        )
        return try await self.listTags(input, logger: logger)
    }

    /// Allows you to purchase a reserved  node offering. Reserved nodes are not eligible for cancellation and are non-refundable.
    @Sendable
    @inlinable
    public func purchaseReservedNodesOffering(_ input: PurchaseReservedNodesOfferingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PurchaseReservedNodesOfferingResponse {
        try await self.client.execute(
            operation: "PurchaseReservedNodesOffering", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows you to purchase a reserved  node offering. Reserved nodes are not eligible for cancellation and are non-refundable.
    ///
    /// Parameters:
    ///   - nodeCount: The number of node instances to reserve.
    ///   - reservationId: A customer-specified identifier to track this reservation.
    ///   - reservedNodesOfferingId: The ID of the reserved node offering to purchase.
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - logger: Logger use during operation
    @inlinable
    public func purchaseReservedNodesOffering(
        nodeCount: Int? = nil,
        reservationId: String? = nil,
        reservedNodesOfferingId: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PurchaseReservedNodesOfferingResponse {
        let input = PurchaseReservedNodesOfferingRequest(
            nodeCount: nodeCount, 
            reservationId: reservationId, 
            reservedNodesOfferingId: reservedNodesOfferingId, 
            tags: tags
        )
        return try await self.purchaseReservedNodesOffering(input, logger: logger)
    }

    /// Modifies the parameters of a parameter group to the engine or system default value. You can reset specific parameters by submitting a list of parameter names. To reset the entire parameter group, specify the AllParameters and ParameterGroupName parameters.
    @Sendable
    @inlinable
    public func resetParameterGroup(_ input: ResetParameterGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ResetParameterGroupResponse {
        try await self.client.execute(
            operation: "ResetParameterGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the parameters of a parameter group to the engine or system default value. You can reset specific parameters by submitting a list of parameter names. To reset the entire parameter group, specify the AllParameters and ParameterGroupName parameters.
    ///
    /// Parameters:
    ///   - allParameters: If true, all parameters in the parameter group are reset to their default values. If false, only the parameters listed by ParameterNames are reset to their default values.
    ///   - parameterGroupName: The name of the parameter group to reset.
    ///   - parameterNames: An array of parameter names to reset to their default values. If AllParameters is true, do not use ParameterNames. If AllParameters is false, you must specify the name of at least one parameter to reset.
    ///   - logger: Logger use during operation
    @inlinable
    public func resetParameterGroup(
        allParameters: Bool? = nil,
        parameterGroupName: String,
        parameterNames: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ResetParameterGroupResponse {
        let input = ResetParameterGroupRequest(
            allParameters: allParameters, 
            parameterGroupName: parameterGroupName, 
            parameterNames: parameterNames
        )
        return try await self.resetParameterGroup(input, logger: logger)
    }

    /// A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track all your MemoryDB resources.
    ///  When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. For more information, see
    ///  Resource-level permissions. For example, you can use cost-allocation tags to your MemoryDB resources, Amazon generates a cost allocation report as a comma-separated value  (CSV) file with your usage and costs aggregated by your tags. You can apply tags that represent business categories  (such as cost centers, application names, or owners) to organize your costs across multiple services.  For more information, see Using Cost Allocation Tags.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A tag is a key-value pair where the key and value are case-sensitive. You can use tags to categorize and track all your MemoryDB resources.
    ///  When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. For more information, see
    ///  Resource-level permissions. For example, you can use cost-allocation tags to your MemoryDB resources, Amazon generates a cost allocation report as a comma-separated value  (CSV) file with your usage and costs aggregated by your tags. You can apply tags that represent business categories  (such as cost centers, application names, or owners) to organize your costs across multiple services.  For more information, see Using Cost Allocation Tags.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to which the tags are to be added
    ///   - tags: A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Use this operation to remove tags on a resource
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Use this operation to remove tags on a resource
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to which the tags are to be removed
    ///   - tagKeys: The list of keys of the tags that are to be removed
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Changes the list of users that belong to the Access Control List.
    @Sendable
    @inlinable
    public func updateACL(_ input: UpdateACLRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateACLResponse {
        try await self.client.execute(
            operation: "UpdateACL", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Changes the list of users that belong to the Access Control List.
    ///
    /// Parameters:
    ///   - aclName: The name of the Access Control List
    ///   - userNamesToAdd: The list of users to add to the Access Control List
    ///   - userNamesToRemove: The list of users to remove from the Access Control List
    ///   - logger: Logger use during operation
    @inlinable
    public func updateACL(
        aclName: String,
        userNamesToAdd: [String]? = nil,
        userNamesToRemove: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateACLResponse {
        let input = UpdateACLRequest(
            aclName: aclName, 
            userNamesToAdd: userNamesToAdd, 
            userNamesToRemove: userNamesToRemove
        )
        return try await self.updateACL(input, logger: logger)
    }

    /// Modifies the settings for a cluster. You can use this operation to change one or more cluster configuration settings by specifying the settings and the new values.
    @Sendable
    @inlinable
    public func updateCluster(_ input: UpdateClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateClusterResponse {
        try await self.client.execute(
            operation: "UpdateCluster", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies the settings for a cluster. You can use this operation to change one or more cluster configuration settings by specifying the settings and the new values.
    ///
    /// Parameters:
    ///   - aclName: The Access Control List that is associated with the cluster
    ///   - clusterName: The name of the cluster to update
    ///   - description: The description of the cluster to update
    ///   - engineVersion: The upgraded version of the engine to be run on the nodes. You can upgrade to a newer engine version, but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cluster and create it anew with the earlier engine version.
    ///   - maintenanceWindow: Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:    sun     mon     tue     wed     thu     fri     sat    Example: sun:23:00-mon:01:30
    ///   - nodeType: A valid node type that you want to scale this cluster up or down to.
    ///   - parameterGroupName: The name of the parameter group to update
    ///   - replicaConfiguration: The number of replicas that will reside in each shard
    ///   - securityGroupIds: The SecurityGroupIds to update
    ///   - shardConfiguration: The number of shards in the cluster
    ///   - snapshotRetentionLimit: The number of days for which MemoryDB retains automatic cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
    ///   - snapshotWindow: The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your cluster.
    ///   - snsTopicArn: The SNS topic ARN to update
    ///   - snsTopicStatus: The status of the Amazon SNS notification topic. Notifications are sent only if the status is active.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCluster(
        aclName: String? = nil,
        clusterName: String,
        description: String? = nil,
        engineVersion: String? = nil,
        maintenanceWindow: String? = nil,
        nodeType: String? = nil,
        parameterGroupName: String? = nil,
        replicaConfiguration: ReplicaConfigurationRequest? = nil,
        securityGroupIds: [String]? = nil,
        shardConfiguration: ShardConfigurationRequest? = nil,
        snapshotRetentionLimit: Int? = nil,
        snapshotWindow: String? = nil,
        snsTopicArn: String? = nil,
        snsTopicStatus: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateClusterResponse {
        let input = UpdateClusterRequest(
            aclName: aclName, 
            clusterName: clusterName, 
            description: description, 
            engineVersion: engineVersion, 
            maintenanceWindow: maintenanceWindow, 
            nodeType: nodeType, 
            parameterGroupName: parameterGroupName, 
            replicaConfiguration: replicaConfiguration, 
            securityGroupIds: securityGroupIds, 
            shardConfiguration: shardConfiguration, 
            snapshotRetentionLimit: snapshotRetentionLimit, 
            snapshotWindow: snapshotWindow, 
            snsTopicArn: snsTopicArn, 
            snsTopicStatus: snsTopicStatus
        )
        return try await self.updateCluster(input, logger: logger)
    }

    /// Updates the parameters of a parameter group. You can modify up to 20 parameters in a single request by submitting a list parameter name and value pairs.
    @Sendable
    @inlinable
    public func updateParameterGroup(_ input: UpdateParameterGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateParameterGroupResponse {
        try await self.client.execute(
            operation: "UpdateParameterGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the parameters of a parameter group. You can modify up to 20 parameters in a single request by submitting a list parameter name and value pairs.
    ///
    /// Parameters:
    ///   - parameterGroupName: The name of the parameter group to update.
    ///   - parameterNameValues: An array of parameter names and values for the parameter update. You must supply at least one parameter name and value; subsequent arguments are optional. A maximum of 20 parameters may be updated per request.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateParameterGroup(
        parameterGroupName: String,
        parameterNameValues: [ParameterNameValue],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateParameterGroupResponse {
        let input = UpdateParameterGroupRequest(
            parameterGroupName: parameterGroupName, 
            parameterNameValues: parameterNameValues
        )
        return try await self.updateParameterGroup(input, logger: logger)
    }

    /// Updates a subnet group. For more information, see Updating a subnet group
    @Sendable
    @inlinable
    public func updateSubnetGroup(_ input: UpdateSubnetGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSubnetGroupResponse {
        try await self.client.execute(
            operation: "UpdateSubnetGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a subnet group. For more information, see Updating a subnet group
    ///
    /// Parameters:
    ///   - description: A description of the subnet group
    ///   - subnetGroupName: The name of the subnet group
    ///   - subnetIds: The EC2 subnet IDs for the subnet group.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSubnetGroup(
        description: String? = nil,
        subnetGroupName: String,
        subnetIds: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSubnetGroupResponse {
        let input = UpdateSubnetGroupRequest(
            description: description, 
            subnetGroupName: subnetGroupName, 
            subnetIds: subnetIds
        )
        return try await self.updateSubnetGroup(input, logger: logger)
    }

    /// Changes user password(s) and/or access string.
    @Sendable
    @inlinable
    public func updateUser(_ input: UpdateUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateUserResponse {
        try await self.client.execute(
            operation: "UpdateUser", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Changes user password(s) and/or access string.
    ///
    /// Parameters:
    ///   - accessString: Access permissions string used for this user.
    ///   - authenticationMode: Denotes the user's authentication properties, such as whether it requires a password to authenticate.
    ///   - userName: The name of the user
    ///   - logger: Logger use during operation
    @inlinable
    public func updateUser(
        accessString: String? = nil,
        authenticationMode: AuthenticationMode? = nil,
        userName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateUserResponse {
        let input = UpdateUserRequest(
            accessString: accessString, 
            authenticationMode: authenticationMode, 
            userName: userName
        )
        return try await self.updateUser(input, logger: logger)
    }
}

extension MemoryDB {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: MemoryDB, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MemoryDB {
    /// Return PaginatorSequence for operation ``describeACLs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeACLsPaginator(
        _ input: DescribeACLsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeACLsRequest, DescribeACLsResponse> {
        return .init(
            input: input,
            command: self.describeACLs,
            inputKey: \DescribeACLsRequest.nextToken,
            outputKey: \DescribeACLsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeACLs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - aclName: The name of the ACL
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeACLsPaginator(
        aclName: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeACLsRequest, DescribeACLsResponse> {
        let input = DescribeACLsRequest(
            aclName: aclName, 
            maxResults: maxResults
        )
        return self.describeACLsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeClustersPaginator(
        _ input: DescribeClustersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeClustersRequest, DescribeClustersResponse> {
        return .init(
            input: input,
            command: self.describeClusters,
            inputKey: \DescribeClustersRequest.nextToken,
            outputKey: \DescribeClustersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterName: The name of the cluster
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - showShardDetails: An optional flag that can be included in the request to retrieve information about the individual shard(s).
    ///   - logger: Logger used for logging
    @inlinable
    public func describeClustersPaginator(
        clusterName: String? = nil,
        maxResults: Int? = nil,
        showShardDetails: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeClustersRequest, DescribeClustersResponse> {
        let input = DescribeClustersRequest(
            clusterName: clusterName, 
            maxResults: maxResults, 
            showShardDetails: showShardDetails
        )
        return self.describeClustersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeEngineVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeEngineVersionsPaginator(
        _ input: DescribeEngineVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEngineVersionsRequest, DescribeEngineVersionsResponse> {
        return .init(
            input: input,
            command: self.describeEngineVersions,
            inputKey: \DescribeEngineVersionsRequest.nextToken,
            outputKey: \DescribeEngineVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeEngineVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - defaultOnly: If true, specifies that only the default version of the specified engine or engine and major version combination is to be returned.
    ///   - engineVersion: The Redis OSS engine version
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - parameterGroupFamily: The name of a specific parameter group family to return details for.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeEngineVersionsPaginator(
        defaultOnly: Bool? = nil,
        engineVersion: String? = nil,
        maxResults: Int? = nil,
        parameterGroupFamily: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeEngineVersionsRequest, DescribeEngineVersionsResponse> {
        let input = DescribeEngineVersionsRequest(
            defaultOnly: defaultOnly, 
            engineVersion: engineVersion, 
            maxResults: maxResults, 
            parameterGroupFamily: parameterGroupFamily
        )
        return self.describeEngineVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeEventsPaginator(
        _ input: DescribeEventsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEventsRequest, DescribeEventsResponse> {
        return .init(
            input: input,
            command: self.describeEvents,
            inputKey: \DescribeEventsRequest.nextToken,
            outputKey: \DescribeEventsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - duration: The number of minutes worth of events to retrieve.
    ///   - endTime: The end of the time interval for which to retrieve events, specified in ISO 8601 format.  Example: 2017-03-30T07:03:49.555Z
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - sourceName: The identifier of the event source for which events are returned. If not specified, all sources are included in the response.
    ///   - sourceType: The event source to retrieve events for. If no value is specified, all events are returned.
    ///   - startTime: The beginning of the time interval to retrieve events for, specified in ISO 8601 format.  Example: 2017-03-30T07:03:49.555Z
    ///   - logger: Logger used for logging
    @inlinable
    public func describeEventsPaginator(
        duration: Int? = nil,
        endTime: Date? = nil,
        maxResults: Int? = nil,
        sourceName: String? = nil,
        sourceType: SourceType? = nil,
        startTime: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeEventsRequest, DescribeEventsResponse> {
        let input = DescribeEventsRequest(
            duration: duration, 
            endTime: endTime, 
            maxResults: maxResults, 
            sourceName: sourceName, 
            sourceType: sourceType, 
            startTime: startTime
        )
        return self.describeEventsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeParameterGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeParameterGroupsPaginator(
        _ input: DescribeParameterGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeParameterGroupsRequest, DescribeParameterGroupsResponse> {
        return .init(
            input: input,
            command: self.describeParameterGroups,
            inputKey: \DescribeParameterGroupsRequest.nextToken,
            outputKey: \DescribeParameterGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeParameterGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - parameterGroupName: The name of a specific  parameter group to return details for.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeParameterGroupsPaginator(
        maxResults: Int? = nil,
        parameterGroupName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeParameterGroupsRequest, DescribeParameterGroupsResponse> {
        let input = DescribeParameterGroupsRequest(
            maxResults: maxResults, 
            parameterGroupName: parameterGroupName
        )
        return self.describeParameterGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeParameters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeParametersPaginator(
        _ input: DescribeParametersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeParametersRequest, DescribeParametersResponse> {
        return .init(
            input: input,
            command: self.describeParameters,
            inputKey: \DescribeParametersRequest.nextToken,
            outputKey: \DescribeParametersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeParameters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - parameterGroupName: he name of a specific  parameter group to return details for.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeParametersPaginator(
        maxResults: Int? = nil,
        parameterGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeParametersRequest, DescribeParametersResponse> {
        let input = DescribeParametersRequest(
            maxResults: maxResults, 
            parameterGroupName: parameterGroupName
        )
        return self.describeParametersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeReservedNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReservedNodesPaginator(
        _ input: DescribeReservedNodesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReservedNodesRequest, DescribeReservedNodesResponse> {
        return .init(
            input: input,
            command: self.describeReservedNodes,
            inputKey: \DescribeReservedNodesRequest.nextToken,
            outputKey: \DescribeReservedNodesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeReservedNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - duration: The duration filter value, specified in years or seconds. Use this parameter to show only reservations for this duration.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    ///   - nodeType: The node type filter value. Use this parameter to show only those reservations matching the specified  node type. For more information, see Supported node types.
    ///   - offeringType: The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type.  Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    ///   - reservationId: The reserved node identifier filter value. Use this parameter to show only the reservation that matches the specified reservation ID.
    ///   - reservedNodesOfferingId: The offering identifier filter value. Use this parameter to show only purchased reservations matching the specified offering identifier.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReservedNodesPaginator(
        duration: String? = nil,
        maxResults: Int? = nil,
        nodeType: String? = nil,
        offeringType: String? = nil,
        reservationId: String? = nil,
        reservedNodesOfferingId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeReservedNodesRequest, DescribeReservedNodesResponse> {
        let input = DescribeReservedNodesRequest(
            duration: duration, 
            maxResults: maxResults, 
            nodeType: nodeType, 
            offeringType: offeringType, 
            reservationId: reservationId, 
            reservedNodesOfferingId: reservedNodesOfferingId
        )
        return self.describeReservedNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeReservedNodesOfferings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReservedNodesOfferingsPaginator(
        _ input: DescribeReservedNodesOfferingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReservedNodesOfferingsRequest, DescribeReservedNodesOfferingsResponse> {
        return .init(
            input: input,
            command: self.describeReservedNodesOfferings,
            inputKey: \DescribeReservedNodesOfferingsRequest.nextToken,
            outputKey: \DescribeReservedNodesOfferingsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeReservedNodesOfferings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - duration: Duration filter value, specified in years or seconds. Use this parameter to show only reservations for a given duration.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a marker is included in the response so that the remaining results can be retrieved.
    ///   - nodeType: The node type for the reserved nodes. For more information, see Supported node types.
    ///   - offeringType: The offering type filter value. Use this parameter to show only the available offerings matching the specified offering type.  Valid values: "All Upfront"|"Partial Upfront"| "No Upfront"
    ///   - reservedNodesOfferingId: The offering identifier filter value. Use this parameter to show only the available offering that matches the specified reservation identifier.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeReservedNodesOfferingsPaginator(
        duration: String? = nil,
        maxResults: Int? = nil,
        nodeType: String? = nil,
        offeringType: String? = nil,
        reservedNodesOfferingId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeReservedNodesOfferingsRequest, DescribeReservedNodesOfferingsResponse> {
        let input = DescribeReservedNodesOfferingsRequest(
            duration: duration, 
            maxResults: maxResults, 
            nodeType: nodeType, 
            offeringType: offeringType, 
            reservedNodesOfferingId: reservedNodesOfferingId
        )
        return self.describeReservedNodesOfferingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeServiceUpdates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeServiceUpdatesPaginator(
        _ input: DescribeServiceUpdatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeServiceUpdatesRequest, DescribeServiceUpdatesResponse> {
        return .init(
            input: input,
            command: self.describeServiceUpdates,
            inputKey: \DescribeServiceUpdatesRequest.nextToken,
            outputKey: \DescribeServiceUpdatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeServiceUpdates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterNames: The list of cluster names to identify service updates to apply
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - serviceUpdateName: The unique ID of the service update to describe.
    ///   - status: The status(es) of the service updates to filter on
    ///   - logger: Logger used for logging
    @inlinable
    public func describeServiceUpdatesPaginator(
        clusterNames: [String]? = nil,
        maxResults: Int? = nil,
        serviceUpdateName: String? = nil,
        status: [ServiceUpdateStatus]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeServiceUpdatesRequest, DescribeServiceUpdatesResponse> {
        let input = DescribeServiceUpdatesRequest(
            clusterNames: clusterNames, 
            maxResults: maxResults, 
            serviceUpdateName: serviceUpdateName, 
            status: status
        )
        return self.describeServiceUpdatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeSnapshots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSnapshotsPaginator(
        _ input: DescribeSnapshotsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeSnapshotsRequest, DescribeSnapshotsResponse> {
        return .init(
            input: input,
            command: self.describeSnapshots,
            inputKey: \DescribeSnapshotsRequest.nextToken,
            outputKey: \DescribeSnapshotsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeSnapshots(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterName: A user-supplied cluster identifier. If this parameter is specified, only snapshots associated with that specific cluster are described.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - showDetail: A Boolean value which if true, the shard configuration is included in the snapshot description.
    ///   - snapshotName: A user-supplied name of the snapshot. If this parameter is specified, only this named snapshot is described.
    ///   - source: If set to system, the output shows snapshots that were automatically created by MemoryDB. If set to user the output shows snapshots that were manually created. If omitted, the output shows both automatically and manually created snapshots.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSnapshotsPaginator(
        clusterName: String? = nil,
        maxResults: Int? = nil,
        showDetail: Bool? = nil,
        snapshotName: String? = nil,
        source: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeSnapshotsRequest, DescribeSnapshotsResponse> {
        let input = DescribeSnapshotsRequest(
            clusterName: clusterName, 
            maxResults: maxResults, 
            showDetail: showDetail, 
            snapshotName: snapshotName, 
            source: source
        )
        return self.describeSnapshotsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeSubnetGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSubnetGroupsPaginator(
        _ input: DescribeSubnetGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeSubnetGroupsRequest, DescribeSubnetGroupsResponse> {
        return .init(
            input: input,
            command: self.describeSubnetGroups,
            inputKey: \DescribeSubnetGroupsRequest.nextToken,
            outputKey: \DescribeSubnetGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeSubnetGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - subnetGroupName: The name of the subnet group to return details for.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSubnetGroupsPaginator(
        maxResults: Int? = nil,
        subnetGroupName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeSubnetGroupsRequest, DescribeSubnetGroupsResponse> {
        let input = DescribeSubnetGroupsRequest(
            maxResults: maxResults, 
            subnetGroupName: subnetGroupName
        )
        return self.describeSubnetGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``describeUsers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeUsersPaginator(
        _ input: DescribeUsersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeUsersRequest, DescribeUsersResponse> {
        return .init(
            input: input,
            command: self.describeUsers,
            inputKey: \DescribeUsersRequest.nextToken,
            outputKey: \DescribeUsersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeUsers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Filter to determine the list of users to return.
    ///   - maxResults: The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    ///   - userName: The name of the user
    ///   - logger: Logger used for logging
    @inlinable
    public func describeUsersPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        userName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeUsersRequest, DescribeUsersResponse> {
        let input = DescribeUsersRequest(
            filters: filters, 
            maxResults: maxResults, 
            userName: userName
        )
        return self.describeUsersPaginator(input, logger: logger)
    }
}

extension MemoryDB.DescribeACLsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeACLsRequest {
        return .init(
            aclName: self.aclName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MemoryDB.DescribeClustersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeClustersRequest {
        return .init(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token,
            showShardDetails: self.showShardDetails
        )
    }
}

extension MemoryDB.DescribeEngineVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeEngineVersionsRequest {
        return .init(
            defaultOnly: self.defaultOnly,
            engineVersion: self.engineVersion,
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupFamily: self.parameterGroupFamily
        )
    }
}

extension MemoryDB.DescribeEventsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeEventsRequest {
        return .init(
            duration: self.duration,
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            sourceName: self.sourceName,
            sourceType: self.sourceType,
            startTime: self.startTime
        )
    }
}

extension MemoryDB.DescribeParameterGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeParameterGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupName: self.parameterGroupName
        )
    }
}

extension MemoryDB.DescribeParametersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeParametersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupName: self.parameterGroupName
        )
    }
}

extension MemoryDB.DescribeReservedNodesOfferingsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeReservedNodesOfferingsRequest {
        return .init(
            duration: self.duration,
            maxResults: self.maxResults,
            nextToken: token,
            nodeType: self.nodeType,
            offeringType: self.offeringType,
            reservedNodesOfferingId: self.reservedNodesOfferingId
        )
    }
}

extension MemoryDB.DescribeReservedNodesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeReservedNodesRequest {
        return .init(
            duration: self.duration,
            maxResults: self.maxResults,
            nextToken: token,
            nodeType: self.nodeType,
            offeringType: self.offeringType,
            reservationId: self.reservationId,
            reservedNodesOfferingId: self.reservedNodesOfferingId
        )
    }
}

extension MemoryDB.DescribeServiceUpdatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeServiceUpdatesRequest {
        return .init(
            clusterNames: self.clusterNames,
            maxResults: self.maxResults,
            nextToken: token,
            serviceUpdateName: self.serviceUpdateName,
            status: self.status
        )
    }
}

extension MemoryDB.DescribeSnapshotsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeSnapshotsRequest {
        return .init(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token,
            showDetail: self.showDetail,
            snapshotName: self.snapshotName,
            source: self.source
        )
    }
}

extension MemoryDB.DescribeSubnetGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeSubnetGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            subnetGroupName: self.subnetGroupName
        )
    }
}

extension MemoryDB.DescribeUsersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MemoryDB.DescribeUsersRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            userName: self.userName
        )
    }
}
