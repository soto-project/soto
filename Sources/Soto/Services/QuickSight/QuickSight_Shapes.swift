//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension QuickSight {
    // MARK: Enums

    public enum AnalysisErrorType: String, CustomStringConvertible, Codable {
        case accessDenied = "ACCESS_DENIED"
        case columnGeographicRoleMismatch = "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case columnReplacementMissing = "COLUMN_REPLACEMENT_MISSING"
        case columnTypeMismatch = "COLUMN_TYPE_MISMATCH"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case parameterNotFound = "PARAMETER_NOT_FOUND"
        case parameterTypeInvalid = "PARAMETER_TYPE_INVALID"
        case parameterValueIncompatible = "PARAMETER_VALUE_INCOMPATIBLE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisFilterAttribute: String, CustomStringConvertible, Codable {
        case quicksightUser = "QUICKSIGHT_USER"
        public var description: String { return self.rawValue }
    }

    public enum AssignmentStatus: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case draft = "DRAFT"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ColumnDataType: String, CustomStringConvertible, Codable {
        case datetime = "DATETIME"
        case decimal = "DECIMAL"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum DashboardBehavior: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DashboardErrorType: String, CustomStringConvertible, Codable {
        case accessDenied = "ACCESS_DENIED"
        case columnGeographicRoleMismatch = "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case columnReplacementMissing = "COLUMN_REPLACEMENT_MISSING"
        case columnTypeMismatch = "COLUMN_TYPE_MISMATCH"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case parameterNotFound = "PARAMETER_NOT_FOUND"
        case parameterTypeInvalid = "PARAMETER_TYPE_INVALID"
        case parameterValueIncompatible = "PARAMETER_VALUE_INCOMPATIBLE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum DashboardFilterAttribute: String, CustomStringConvertible, Codable {
        case quicksightUser = "QUICKSIGHT_USER"
        public var description: String { return self.rawValue }
    }

    public enum DashboardUIState: String, CustomStringConvertible, Codable {
        case collapsed = "COLLAPSED"
        case expanded = "EXPANDED"
        public var description: String { return self.rawValue }
    }

    public enum DataSetImportMode: String, CustomStringConvertible, Codable {
        case directQuery = "DIRECT_QUERY"
        case spice = "SPICE"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceErrorInfoType: String, CustomStringConvertible, Codable {
        case accessDenied = "ACCESS_DENIED"
        case conflict = "CONFLICT"
        case copySourceNotFound = "COPY_SOURCE_NOT_FOUND"
        case engineVersionNotSupported = "ENGINE_VERSION_NOT_SUPPORTED"
        case genericSqlFailure = "GENERIC_SQL_FAILURE"
        case timeout = "TIMEOUT"
        case unknown = "UNKNOWN"
        case unknownHost = "UNKNOWN_HOST"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable {
        case adobeAnalytics = "ADOBE_ANALYTICS"
        case amazonElasticsearch = "AMAZON_ELASTICSEARCH"
        case athena = "ATHENA"
        case aurora = "AURORA"
        case auroraPostgresql = "AURORA_POSTGRESQL"
        case awsIotAnalytics = "AWS_IOT_ANALYTICS"
        case github = "GITHUB"
        case jira = "JIRA"
        case mariadb = "MARIADB"
        case mysql = "MYSQL"
        case oracle = "ORACLE"
        case postgresql = "POSTGRESQL"
        case presto = "PRESTO"
        case redshift = "REDSHIFT"
        case s3 = "S3"
        case salesforce = "SALESFORCE"
        case servicenow = "SERVICENOW"
        case snowflake = "SNOWFLAKE"
        case spark = "SPARK"
        case sqlserver = "SQLSERVER"
        case teradata = "TERADATA"
        case timestream = "TIMESTREAM"
        case twitter = "TWITTER"
        public var description: String { return self.rawValue }
    }

    public enum Edition: String, CustomStringConvertible, Codable {
        case enterprise = "ENTERPRISE"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum EmbeddingIdentityType: String, CustomStringConvertible, Codable {
        case anonymous = "ANONYMOUS"
        case iam = "IAM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum FileFormat: String, CustomStringConvertible, Codable {
        case clf = "CLF"
        case csv = "CSV"
        case elf = "ELF"
        case json = "JSON"
        case tsv = "TSV"
        case xlsx = "XLSX"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable {
        case stringequals = "StringEquals"
        public var description: String { return self.rawValue }
    }

    public enum FolderFilterAttribute: String, CustomStringConvertible, Codable {
        case parentFolderArn = "PARENT_FOLDER_ARN"
        public var description: String { return self.rawValue }
    }

    public enum FolderType: String, CustomStringConvertible, Codable {
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum GeoSpatialCountryCode: String, CustomStringConvertible, Codable {
        case us = "US"
        public var description: String { return self.rawValue }
    }

    public enum GeoSpatialDataRole: String, CustomStringConvertible, Codable {
        case city = "CITY"
        case country = "COUNTRY"
        case county = "COUNTY"
        case latitude = "LATITUDE"
        case longitude = "LONGITUDE"
        case postcode = "POSTCODE"
        case state = "STATE"
        public var description: String { return self.rawValue }
    }

    public enum IdentityStore: String, CustomStringConvertible, Codable {
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable {
        case iam = "IAM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum IngestionErrorType: String, CustomStringConvertible, Codable {
        case accountCapacityLimitExceeded = "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
        case connectionFailure = "CONNECTION_FAILURE"
        case customerError = "CUSTOMER_ERROR"
        case dataSetDeleted = "DATA_SET_DELETED"
        case dataSetNotSpice = "DATA_SET_NOT_SPICE"
        case dataSetSizeLimitExceeded = "DATA_SET_SIZE_LIMIT_EXCEEDED"
        case dataSourceAuthFailed = "DATA_SOURCE_AUTH_FAILED"
        case dataSourceConnectionFailed = "DATA_SOURCE_CONNECTION_FAILED"
        case dataSourceNotFound = "DATA_SOURCE_NOT_FOUND"
        case dataToleranceException = "DATA_TOLERANCE_EXCEPTION"
        case failureToAssumeRole = "FAILURE_TO_ASSUME_ROLE"
        case failureToProcessJsonFile = "FAILURE_TO_PROCESS_JSON_FILE"
        case iamRoleNotAvailable = "IAM_ROLE_NOT_AVAILABLE"
        case ingestionCanceled = "INGESTION_CANCELED"
        case ingestionSuperseded = "INGESTION_SUPERSEDED"
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case invalidDataSourceConfig = "INVALID_DATA_SOURCE_CONFIG"
        case invalidDataprepSyntax = "INVALID_DATAPREP_SYNTAX"
        case invalidDateFormat = "INVALID_DATE_FORMAT"
        case iotDataSetFileEmpty = "IOT_DATA_SET_FILE_EMPTY"
        case iotFileNotFound = "IOT_FILE_NOT_FOUND"
        case oauthTokenFailure = "OAUTH_TOKEN_FAILURE"
        case passwordAuthenticationFailure = "PASSWORD_AUTHENTICATION_FAILURE"
        case permissionDenied = "PERMISSION_DENIED"
        case queryTimeout = "QUERY_TIMEOUT"
        case rowSizeLimitExceeded = "ROW_SIZE_LIMIT_EXCEEDED"
        case s3FileInaccessible = "S3_FILE_INACCESSIBLE"
        case s3ManifestError = "S3_MANIFEST_ERROR"
        case s3UploadedFileDeleted = "S3_UPLOADED_FILE_DELETED"
        case sourceApiLimitExceededFailure = "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
        case sourceResourceLimitExceeded = "SOURCE_RESOURCE_LIMIT_EXCEEDED"
        case spiceTableNotFound = "SPICE_TABLE_NOT_FOUND"
        case sqlException = "SQL_EXCEPTION"
        case sqlInvalidParameterValue = "SQL_INVALID_PARAMETER_VALUE"
        case sqlNumericOverflow = "SQL_NUMERIC_OVERFLOW"
        case sqlSchemaMismatchError = "SQL_SCHEMA_MISMATCH_ERROR"
        case sqlTableNotFound = "SQL_TABLE_NOT_FOUND"
        case sslCertificateValidationFailure = "SSL_CERTIFICATE_VALIDATION_FAILURE"
        case unresolvableHost = "UNRESOLVABLE_HOST"
        case unroutableHost = "UNROUTABLE_HOST"
        public var description: String { return self.rawValue }
    }

    public enum IngestionRequestSource: String, CustomStringConvertible, Codable {
        case manual = "MANUAL"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum IngestionRequestType: String, CustomStringConvertible, Codable {
        case edit = "EDIT"
        case fullRefresh = "FULL_REFRESH"
        case incrementalRefresh = "INCREMENTAL_REFRESH"
        case initialIngestion = "INITIAL_INGESTION"
        public var description: String { return self.rawValue }
    }

    public enum IngestionStatus: String, CustomStringConvertible, Codable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case initialized = "INITIALIZED"
        case queued = "QUEUED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum InputColumnDataType: String, CustomStringConvertible, Codable {
        case bit = "BIT"
        case boolean = "BOOLEAN"
        case datetime = "DATETIME"
        case decimal = "DECIMAL"
        case integer = "INTEGER"
        case json = "JSON"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum JoinType: String, CustomStringConvertible, Codable {
        case inner = "INNER"
        case left = "LEFT"
        case outer = "OUTER"
        case right = "RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum MemberType: String, CustomStringConvertible, Codable {
        case analysis = "ANALYSIS"
        case dashboard = "DASHBOARD"
        case dataset = "DATASET"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceErrorType: String, CustomStringConvertible, Codable {
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case permissionDenied = "PERMISSION_DENIED"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceStatus: String, CustomStringConvertible, Codable {
        case created = "CREATED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case nonRetryableFailure = "NON_RETRYABLE_FAILURE"
        case retryableFailure = "RETRYABLE_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStatus: String, CustomStringConvertible, Codable {
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case creationSuccessful = "CREATION_SUCCESSFUL"
        case deleted = "DELETED"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum RowLevelPermissionFormatVersion: String, CustomStringConvertible, Codable {
        case version1 = "VERSION_1"
        case version2 = "VERSION_2"
        public var description: String { return self.rawValue }
    }

    public enum RowLevelPermissionPolicy: String, CustomStringConvertible, Codable {
        case denyAccess = "DENY_ACCESS"
        case grantAccess = "GRANT_ACCESS"
        public var description: String { return self.rawValue }
    }

    public enum TemplateErrorType: String, CustomStringConvertible, Codable {
        case accessDenied = "ACCESS_DENIED"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum TextQualifier: String, CustomStringConvertible, Codable {
        case doubleQuote = "DOUBLE_QUOTE"
        case singleQuote = "SINGLE_QUOTE"
        public var description: String { return self.rawValue }
    }

    public enum ThemeErrorType: String, CustomStringConvertible, Codable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum ThemeType: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case custom = "CUSTOM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum UserRole: String, CustomStringConvertible, Codable {
        case admin = "ADMIN"
        case author = "AUTHOR"
        case reader = "READER"
        case restrictedAuthor = "RESTRICTED_AUTHOR"
        case restrictedReader = "RESTRICTED_READER"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountCustomization: AWSEncodableShape & AWSDecodableShape {
        /// The default theme for this QuickSight subscription.
        public let defaultTheme: String?

        public init(defaultTheme: String? = nil) {
            self.defaultTheme = defaultTheme
        }

        private enum CodingKeys: String, CodingKey {
            case defaultTheme = "DefaultTheme"
        }
    }

    public struct AccountSettings: AWSDecodableShape {
        /// The "account name" you provided for the QuickSight subscription in your AWS account. You create this name when you sign up for QuickSight. It is unique in all of AWS and it appears only in the console when users sign in.
        public let accountName: String?
        /// The default QuickSight namespace for your AWS account.
        public let defaultNamespace: String?
        /// The edition of QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.
        public let edition: Edition?
        /// The main notification email for your QuickSight subscription.
        public let notificationEmail: String?

        public init(accountName: String? = nil, defaultNamespace: String? = nil, edition: Edition? = nil, notificationEmail: String? = nil) {
            self.accountName = accountName
            self.defaultNamespace = defaultNamespace
            self.edition = edition
            self.notificationEmail = notificationEmail
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "AccountName"
            case defaultNamespace = "DefaultNamespace"
            case edition = "Edition"
            case notificationEmail = "NotificationEmail"
        }
    }

    public struct ActiveIAMPolicyAssignment: AWSDecodableShape {
        /// A name for the IAM policy assignment.
        public let assignmentName: String?
        /// The Amazon Resource Name (ARN) of the resource.
        public let policyArn: String?

        public init(assignmentName: String? = nil, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.policyArn = policyArn
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case policyArn = "PolicyArn"
        }
    }

    public struct AdHocFilteringOption: AWSEncodableShape {
        /// Availability status.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct AmazonElasticsearchParameters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Elasticsearch Service domain.
        public let domain: String

        public init(domain: String) {
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 64)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
        }
    }

    public struct Analysis: AWSDecodableShape {
        /// The ID of the analysis.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the analysis.
        public let arn: String?
        /// The time that the analysis was created.
        public let createdTime: Date?
        /// The ARNs of the datasets of the analysis.
        public let dataSetArns: [String]?
        /// Errors associated with the analysis.
        public let errors: [AnalysisError]?
        /// The time that the analysis was last updated.
        public let lastUpdatedTime: Date?
        /// The descriptive name of the analysis.
        public let name: String?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// Status associated with the analysis.
        public let status: ResourceStatus?
        /// The ARN of the theme of the analysis.
        public let themeArn: String?

        public init(analysisId: String? = nil, arn: String? = nil, createdTime: Date? = nil, dataSetArns: [String]? = nil, errors: [AnalysisError]? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, sheets: [Sheet]? = nil, status: ResourceStatus? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.errors = errors
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sheets = sheets
            self.status = status
            self.themeArn = themeArn
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSetArns = "DataSetArns"
            case errors = "Errors"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case sheets = "Sheets"
            case status = "Status"
            case themeArn = "ThemeArn"
        }
    }

    public struct AnalysisError: AWSDecodableShape {
        /// The message associated with the analysis error.
        public let message: String?
        /// The type of the analysis error.
        public let type: AnalysisErrorType?

        public init(message: String? = nil, type: AnalysisErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct AnalysisSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example "Name": "QUICKSIGHT_USER".
        public let name: AnalysisFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals".
        public let `operator`: FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example "Value". An example is "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String?

        public init(name: AnalysisFilterAttribute? = nil, operator: FilterOperator? = nil, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct AnalysisSourceEntity: AWSEncodableShape {
        /// The source template for the source entity of the analysis.
        public let sourceTemplate: AnalysisSourceTemplate?

        public init(sourceTemplate: AnalysisSourceTemplate? = nil) {
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceTemplate?.validate(name: "\(name).sourceTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct AnalysisSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the source template of an analysis.
        public let arn: String
        /// The dataset references of the source template of an analysis.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct AnalysisSummary: AWSDecodableShape {
        /// The ID of the analysis. This ID displays in the URL.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) for the analysis.
        public let arn: String?
        /// The time that the analysis was created.
        public let createdTime: Date?
        /// The time that the analysis was last updated.
        public let lastUpdatedTime: Date?
        /// The name of the analysis. This name is displayed in the QuickSight console.
        public let name: String?
        /// The last known status for the analysis.
        public let status: ResourceStatus?

        public init(analysisId: String? = nil, arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, status: ResourceStatus? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct AthenaParameters: AWSEncodableShape & AWSDecodableShape {
        /// The workgroup that Amazon Athena uses.
        public let workGroup: String?

        public init(workGroup: String? = nil) {
            self.workGroup = workGroup
        }

        public func validate(name: String) throws {
            try self.validate(self.workGroup, name: "workGroup", parent: name, max: 128)
            try self.validate(self.workGroup, name: "workGroup", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case workGroup = "WorkGroup"
        }
    }

    public struct AuroraParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct AuroraPostgreSqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct AwsIotAnalyticsParameters: AWSEncodableShape & AWSDecodableShape {
        /// Dataset name.
        public let dataSetName: String

        public init(dataSetName: String) {
            self.dataSetName = dataSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, max: 128)
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetName = "DataSetName"
        }
    }

    public struct BorderStyle: AWSEncodableShape & AWSDecodableShape {
        /// The option to enable display of borders for visuals.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct CalculatedColumn: AWSEncodableShape & AWSDecodableShape {
        /// A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        public let columnId: String
        /// Column name.
        public let columnName: String
        /// An expression that defines the calculated column.
        public let expression: String

        public init(columnId: String, columnName: String, expression: String) {
            self.columnId = columnId
            self.columnName = columnName
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.columnId, name: "columnId", parent: name, max: 64)
            try self.validate(self.columnId, name: "columnId", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnId = "ColumnId"
            case columnName = "ColumnName"
            case expression = "Expression"
        }
    }

    public struct CancelIngestionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "ingestionId", location: .uri(locationName: "IngestionId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String

        public init(awsAccountId: String, dataSetId: String, ingestionId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelIngestionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the data ingestion.
        public let arn: String?
        /// An ID for the ingestion.
        public let ingestionId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CastColumnTypeOperation: AWSEncodableShape & AWSDecodableShape {
        /// Column name.
        public let columnName: String
        /// When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        public let format: String?
        /// New column data type.
        public let newColumnType: ColumnDataType

        public init(columnName: String, format: String? = nil, newColumnType: ColumnDataType) {
            self.columnName = columnName
            self.format = format
            self.newColumnType = newColumnType
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.format, name: "format", parent: name, max: 32)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case format = "Format"
            case newColumnType = "NewColumnType"
        }
    }

    public struct ColumnDescription: AWSEncodableShape & AWSDecodableShape {
        /// The text of a description for a column.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 500)
            try self.validate(self.text, name: "text", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct ColumnGroup: AWSEncodableShape & AWSDecodableShape {
        /// Geospatial column group that denotes a hierarchy.
        public let geoSpatialColumnGroup: GeoSpatialColumnGroup?

        public init(geoSpatialColumnGroup: GeoSpatialColumnGroup? = nil) {
            self.geoSpatialColumnGroup = geoSpatialColumnGroup
        }

        public func validate(name: String) throws {
            try self.geoSpatialColumnGroup?.validate(name: "\(name).geoSpatialColumnGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case geoSpatialColumnGroup = "GeoSpatialColumnGroup"
        }
    }

    public struct ColumnGroupColumnSchema: AWSDecodableShape {
        /// The name of the column group's column schema.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ColumnGroupSchema: AWSDecodableShape {
        /// A structure containing the list of schemas for column group columns.
        public let columnGroupColumnSchemaList: [ColumnGroupColumnSchema]?
        /// The name of the column group schema.
        public let name: String?

        public init(columnGroupColumnSchemaList: [ColumnGroupColumnSchema]? = nil, name: String? = nil) {
            self.columnGroupColumnSchemaList = columnGroupColumnSchemaList
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroupColumnSchemaList = "ColumnGroupColumnSchemaList"
            case name = "Name"
        }
    }

    public struct ColumnLevelPermissionRule: AWSEncodableShape & AWSDecodableShape {
        /// An array of column names.
        public let columnNames: [String]?
        /// An array of Amazon Resource Names (ARNs) for QuickSight users or groups.
        public let principals: [String]?

        public init(columnNames: [String]? = nil, principals: [String]? = nil) {
            self.columnNames = columnNames
            self.principals = principals
        }

        public func validate(name: String) throws {
            try self.validate(self.columnNames, name: "columnNames", parent: name, min: 1)
            try self.validate(self.principals, name: "principals", parent: name, max: 100)
            try self.validate(self.principals, name: "principals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "ColumnNames"
            case principals = "Principals"
        }
    }

    public struct ColumnSchema: AWSDecodableShape {
        /// The data type of the column schema.
        public let dataType: String?
        /// The geographic role of the column schema.
        public let geographicRole: String?
        /// The name of the column schema.
        public let name: String?

        public init(dataType: String? = nil, geographicRole: String? = nil, name: String? = nil) {
            self.dataType = dataType
            self.geographicRole = geographicRole
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "DataType"
            case geographicRole = "GeographicRole"
            case name = "Name"
        }
    }

    public struct ColumnTag: AWSEncodableShape & AWSDecodableShape {
        /// A description for a column.
        public let columnDescription: ColumnDescription?
        /// A geospatial role for a column.
        public let columnGeographicRole: GeoSpatialDataRole?

        public init(columnDescription: ColumnDescription? = nil, columnGeographicRole: GeoSpatialDataRole? = nil) {
            self.columnDescription = columnDescription
            self.columnGeographicRole = columnGeographicRole
        }

        public func validate(name: String) throws {
            try self.columnDescription?.validate(name: "\(name).columnDescription")
        }

        private enum CodingKeys: String, CodingKey {
            case columnDescription = "ColumnDescription"
            case columnGeographicRole = "ColumnGeographicRole"
        }
    }

    public struct CreateAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace"))
        ]

        /// The QuickSight customizations you're adding in the current AWS Region. You can add these to an AWS account and a QuickSight namespace.  For example, you can add a default theme by setting AccountCustomization to the midnight theme: "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight::aws:theme/MIDNIGHT" }. Or, you can add a custom theme by specifying "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639" }.
        public let accountCustomization: AccountCustomization
        /// The ID for the AWS account that you want to customize QuickSight for.
        public let awsAccountId: String
        /// The QuickSight namespace that you want to add customizations to.
        public let namespace: String?
        /// A list of the tags that you want to attach to this resource.
        public let tags: [Tag]?

        public init(accountCustomization: AccountCustomization, awsAccountId: String, namespace: String? = nil, tags: [Tag]? = nil) {
            self.accountCustomization = accountCustomization
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case tags = "Tags"
        }
    }

    public struct CreateAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The QuickSight customizations you're adding in the current AWS Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) for the customization that you created for this AWS account.
        public let arn: String?
        /// The ID for the AWS account that you want to customize QuickSight for.
        public let awsAccountId: String?
        /// The namespace associated with the customization you're creating.
        public let namespace: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID for the analysis that you're creating. This ID displays in the URL of the analysis.
        public let analysisId: String
        /// The ID of the AWS account where you are creating an analysis.
        public let awsAccountId: String
        /// A descriptive name for the analysis that you're creating. This name displays for the analysis in the QuickSight console.
        public let name: String
        /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A structure that describes the principals and the resource-level permissions on an analysis. You can use the Permissions structure to grant permissions by providing a list of AWS Identity and Access Management (IAM) action information for each principal listed by Amazon Resource Name (ARN).  To specify no permissions, omit Permissions.
        public let permissions: [ResourcePermission]?
        /// A source entity to use for the analysis that you're creating. This metadata structure contains details that describe a source template and one or more datasets.
        public let sourceEntity: AnalysisSourceEntity
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the analysis.
        public let tags: [Tag]?
        /// The ARN for the theme to apply to the analysis that you're creating. To see the theme in the QuickSight console, make sure that you have access to it.
        public let themeArn: String?

        public init(analysisId: String, awsAccountId: String, name: String, parameters: Parameters? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: AnalysisSourceEntity, tags: [Tag]? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.name = name
            self.parameters = parameters
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.themeArn = themeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 2048)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parameters = "Parameters"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case themeArn = "ThemeArn"
        }
    }

    public struct CreateAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the analysis.
        public let analysisId: String?
        /// The ARN for the analysis.
        public let arn: String?
        /// The status of the creation of the analysis.
        public let creationStatus: ResourceStatus?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateColumnsOperation: AWSEncodableShape & AWSDecodableShape {
        /// Calculated columns to create.
        public let columns: [CalculatedColumn]

        public init(columns: [CalculatedColumn]) {
            self.columns = columns
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 128)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId"))
        ]

        /// The ID of the AWS account where you want to create the dashboard.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the IAM policy.
        public let dashboardId: String
        /// Options for publishing the dashboard when you create it:    AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.     AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.     VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
        public let dashboardPublishOptions: DashboardPublishOptions?
        /// The display name of the dashboard.
        public let name: String
        /// The parameters for the creation of the dashboard, which you want to use to override the default settings. A dashboard can have any type of parameters, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A structure that contains the permissions of the dashboard. You can use this structure for granting permissions by providing a list of IAM action information for each principal ARN.  To specify no permissions, omit the permissions list.
        public let permissions: [ResourcePermission]?
        /// The entity that you are using as a source when you create the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only create a dashboard from a template, so you use a SourceTemplate entity. If you need to create a dashboard from an analysis, first convert the analysis to a template by using the CreateTemplate API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplateARN can contain any AWS Account and any QuickSight-supported AWS Region.  Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: DashboardSourceEntity
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dashboard.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that is used in the source entity. The theme ARN must exist in the same AWS account where you create the dashboard.
        public let themeArn: String?
        /// A description for the first version of the dashboard being created.
        public let versionDescription: String?

        public init(awsAccountId: String, dashboardId: String, dashboardPublishOptions: DashboardPublishOptions? = nil, name: String, parameters: Parameters? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: DashboardSourceEntity, tags: [Tag]? = nil, themeArn: String? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.dashboardPublishOptions = dashboardPublishOptions
            self.name = name
            self.parameters = parameters
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.themeArn = themeArn
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardPublishOptions = "DashboardPublishOptions"
            case name = "Name"
            case parameters = "Parameters"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case themeArn = "ThemeArn"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ARN of the dashboard.
        public let arn: String?
        /// The status of the dashboard creation request.
        public let creationStatus: ResourceStatus?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the dashboard, including the version number of the first version that is created.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
            case versionArn = "VersionArn"
        }
    }

    public struct CreateDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// Groupings of columns that work together in certain QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// An ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// Indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// The display name for the dataset.
        public let name: String
        /// A list of resource permissions on the dataset.
        public let permissions: [ResourcePermission]?
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]
        /// The row-level security configuration for the data that you want to create.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.
        public let tags: [Tag]?

        public init(awsAccountId: String, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, dataSetId: String, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode, logicalTableMap: [String: LogicalTable]? = nil, name: String, permissions: [ResourcePermission]? = nil, physicalTableMap: [String: PhysicalTable], rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.dataSetId = dataSetId
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.permissions = permissions
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.columnGroups?.forEach {
                try $0.validate(name: "\(name).columnGroups[]")
            }
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, max: 8)
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, min: 1)
            try self.columnLevelPermissionRules?.forEach {
                try $0.validate(name: "\(name).columnLevelPermissionRules[]")
            }
            try self.validate(self.columnLevelPermissionRules, name: "columnLevelPermissionRules", parent: name, min: 1)
            try self.fieldFolders?.forEach {
                try validate($0.key, name: "fieldFolders.key", parent: name, max: 1000)
                try validate($0.key, name: "fieldFolders.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).fieldFolders[\"\($0.key)\"]")
            }
            try self.logicalTableMap?.forEach {
                try validate($0.key, name: "logicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "logicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "logicalTableMap.key", parent: name, pattern: "[0-9a-zA-Z-]*")
                try $0.value.validate(name: "\(name).logicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.physicalTableMap.forEach {
                try validate($0.key, name: "physicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "physicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "physicalTableMap.key", parent: name, pattern: "[0-9a-zA-Z-]*")
                try $0.value.validate(name: "\(name).physicalTableMap[\"\($0.key)\"]")
            }
            try self.rowLevelPermissionDataSet?.validate(name: "\(name).rowLevelPermissionDataSet")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case dataSetId = "DataSetId"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case permissions = "Permissions"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case tags = "Tags"
        }
    }

    public struct CreateDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String?
        /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
        public let ingestionArn: String?
        /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
        public let ingestionId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, ingestionArn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.ingestionArn = ingestionArn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case ingestionArn = "IngestionArn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The credentials QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
        public let credentials: DataSourceCredentials?
        /// An ID for the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String
        /// The parameters that QuickSight uses to connect to your underlying source.
        public let dataSourceParameters: DataSourceParameters?
        /// A display name for the data source.
        public let name: String
        /// A list of resource permissions on the data source.
        public let permissions: [ResourcePermission]?
        /// Secure Socket Layer (SSL) properties that apply when QuickSight connects to your underlying source.
        public let sslProperties: SslProperties?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.
        public let tags: [Tag]?
        /// The type of the data source. Currently, the supported types for this operation are: ATHENA, AURORA, AURORA_POSTGRESQL, AMAZON_ELASTICSEARCH, MARIADB, MYSQL, POSTGRESQL, PRESTO, REDSHIFT, S3, SNOWFLAKE, SPARK, SQLSERVER, TERADATA. Use ListDataSources to return a list of all data sources.  AMAZON_ELASTICSEARCH is for Amazon managed Elasticsearch Service.
        public let type: DataSourceType
        /// Use this parameter only when you want QuickSight to use a VPC connection when connecting to your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(awsAccountId: String, credentials: DataSourceCredentials? = nil, dataSourceId: String, dataSourceParameters: DataSourceParameters? = nil, name: String, permissions: [ResourcePermission]? = nil, sslProperties: SslProperties? = nil, tags: [Tag]? = nil, type: DataSourceType, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.awsAccountId = awsAccountId
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.name = name
            self.permissions = permissions
            self.sslProperties = sslProperties
            self.tags = tags
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.credentials?.validate(name: "\(name).credentials")
            try self.dataSourceParameters?.validate(name: "\(name).dataSourceParameters")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case dataSourceId = "DataSourceId"
            case dataSourceParameters = "DataSourceParameters"
            case name = "Name"
            case permissions = "Permissions"
            case sslProperties = "SslProperties"
            case tags = "Tags"
            case type = "Type"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The status of creating the data source.
        public let creationStatus: ResourceStatus?
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateFolderMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId")),
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "MemberId")),
            AWSMemberEncoding(label: "memberType", location: .uri(locationName: "MemberType"))
        ]

        /// The AWS Account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String
        /// The ID of the asset (the dashboard, analysis, or dataset).
        public let memberId: String
        /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET.
        public let memberType: MemberType

        public init(awsAccountId: String, folderId: String, memberId: String, memberType: MemberType) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.memberId = memberId
            self.memberType = memberType
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 2048)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateFolderMembershipResponse: AWSDecodableShape {
        /// Information about the member in the folder.
        public let folderMember: FolderMember?
        /// The request ID.
        public let requestId: String?
        /// The status of the folder membership. If succeeded, the status is SC_OK (200).
        public let status: Int?

        public init(folderMember: FolderMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderMember = folderMember
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderMember = "FolderMember"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId"))
        ]

        /// The AWS Account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String
        /// The type of folder. By default, folderType is SHARED.
        public let folderType: FolderType?
        /// The name of the folder.
        public let name: String?
        /// The Amazon Resource Name (ARN) for the parent folder.  ParentFolderArn can be null. An empty parentFolderArn creates a root-level folder.
        public let parentFolderArn: String?
        /// A structure that describes the principals and the resource-level permissions of a folder. To specify no permissions, omit Permissions.
        public let permissions: [ResourcePermission]?
        /// Tags for the folder.
        public let tags: [Tag]?

        public init(awsAccountId: String, folderId: String, folderType: FolderType? = nil, name: String? = nil, parentFolderArn: String? = nil, permissions: [ResourcePermission]? = nil, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.folderType = folderType
            self.name = name
            self.parentFolderArn = parentFolderArn
            self.permissions = permissions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case folderType = "FolderType"
            case name = "Name"
            case parentFolderArn = "ParentFolderArn"
            case permissions = "Permissions"
            case tags = "Tags"
        }
    }

    public struct CreateFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the newly created folder.
        public let arn: String?
        /// The folder ID for the newly created folder.
        public let folderId: String?
        /// The request ID for the newly created folder.
        public let requestId: String?
        /// The status of the newly created folder. If succeeded, the status is SC_OK (200).
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateGroupMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri(locationName: "GroupName")),
            AWSMemberEncoding(label: "memberName", location: .uri(locationName: "MemberName")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to add the user to.
        public let groupName: String
        /// The name of the user that you want to add to the group membership.
        public let memberName: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateGroupMembershipResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The group member.
        public let groupMember: GroupMember?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMember: GroupMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMember = groupMember
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupMember = "GroupMember"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// A description for the group that you want to create.
        public let description: String?
        /// A name for the group that you want to create.
        public let groupName: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String

        public init(awsAccountId: String, description: String? = nil, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case groupName = "GroupName"
        }
    }

    public struct CreateGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the group.
        public let group: Group?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The name of the assignment, also called a rule. It must be unique within an AWS account.
        public let assignmentName: String
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
        public let assignmentStatus: AssignmentStatus
        /// The ID of the AWS account where you want to assign an IAM policy to QuickSight users or groups.
        public let awsAccountId: String
        /// The QuickSight users, groups, or both that you want to assign the policy to.
        public let identities: [String: [String]]?
        /// The namespace that contains the assignment.
        public let namespace: String
        /// The ARN for the IAM policy to apply to the QuickSight users and groups specified in this assignment.
        public let policyArn: String?

        public init(assignmentName: String, assignmentStatus: AssignmentStatus, awsAccountId: String, identities: [String: [String]]? = nil, namespace: String, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.namespace = namespace
            self.policyArn = policyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct CreateIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID for the assignment.
        public let assignmentId: String?
        /// The name of the assignment. This name must be unique within the AWS account.
        public let assignmentName: String?
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
        public let assignmentStatus: AssignmentStatus?
        /// The QuickSight users, groups, or both that the IAM policy is assigned to.
        public let identities: [String: [String]]?
        /// The ARN for the IAM policy that is applied to the QuickSight users and groups specified in this assignment.
        public let policyArn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.identities = identities
            self.policyArn = policyArn
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateIngestionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "ingestionId", location: .uri(locationName: "IngestionId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String

        public init(awsAccountId: String, dataSetId: String, ingestionId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateIngestionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the data ingestion.
        public let arn: String?
        /// An ID for the ingestion.
        public let ingestionId: String?
        /// The ingestion status.
        public let ingestionStatus: IngestionStatus?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, ingestionId: String? = nil, ingestionStatus: IngestionStatus? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.ingestionId = ingestionId
            self.ingestionStatus = ingestionStatus
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case ingestionId = "IngestionId"
            case ingestionStatus = "IngestionStatus"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID for the AWS account that you want to create the QuickSight namespace in.
        public let awsAccountId: String
        /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
        public let identityStore: IdentityStore
        /// The name that you want to use to describe the new namespace.
        public let namespace: String
        /// The tags that you want to associate with the namespace that you're creating.
        public let tags: [Tag]?

        public init(awsAccountId: String, identityStore: IdentityStore, namespace: String, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.identityStore = identityStore
            self.namespace = namespace
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStore = "IdentityStore"
            case namespace = "Namespace"
            case tags = "Tags"
        }
    }

    public struct CreateNamespaceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ARN of the QuickSight namespace you created.
        public let arn: String?
        /// The AWS Region that you want to use for the free SPICE capacity for the new namespace. This is set to the region that you run CreateNamespace in.
        public let capacityRegion: String?
        /// The status of the creation of the namespace. This is an asynchronous process. A status of CREATED means that your namespace is ready to use. If an error occurs, it indicates if the process is retryable or non-retryable. In the case of a non-retryable error, refer to the error message for follow-up tasks.
        public let creationStatus: NamespaceStatus?
        /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
        public let identityStore: IdentityStore?
        /// The name of the new namespace that you created.
        public let name: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, capacityRegion: String? = nil, creationStatus: NamespaceStatus? = nil, identityStore: IdentityStore? = nil, name: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacityRegion = "CapacityRegion"
            case creationStatus = "CreationStatus"
            case identityStore = "IdentityStore"
            case name = "Name"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The name that you want to give to the template alias that you're creating. Don't start the alias name with the $ character. Alias names that start with $ are reserved by QuickSight.
        public let aliasName: String
        /// The ID of the AWS account that contains the template that you creating an alias for.
        public let awsAccountId: String
        /// An ID for the template.
        public let templateId: String
        /// The version number of the template.
        public let templateVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, templateId: String, templateVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.templateVersionNumber = templateVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.templateVersionNumber, name: "templateVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct CreateTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct CreateTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// A display name for the template.
        public let name: String?
        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The entity that you are using as a source when you create the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any AWS Account and any QuickSight-supported AWS Region.  Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: TemplateSourceEntity
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [Tag]?
        /// An ID for the template that you want to create. This template is unique per AWS Region in each AWS account.
        public let templateId: String
        /// A description of the current template version being created. This API operation creates the first version of the template. Every time UpdateTemplate is called, a new version is created. Each version of the template maintains a description of the version in the VersionDescription field.
        public let versionDescription: String?

        public init(awsAccountId: String, name: String? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: TemplateSourceEntity, tags: [Tag]? = nil, templateId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.name = name
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.templateId = templateId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ARN for the template.
        public let arn: String?
        /// The template creation status.
        public let creationStatus: ResourceStatus?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the template.
        public let templateId: String?
        /// The ARN for the template, including the version information of the first version.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
            case versionArn = "VersionArn"
        }
    }

    public struct CreateThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The name that you want to give to the theme alias that you are creating. The alias name can't begin with a $. Alias names that start with $ are reserved by Amazon QuickSight.
        public let aliasName: String
        /// The ID of the AWS account that contains the theme for the new theme alias.
        public let awsAccountId: String
        /// An ID for the theme alias.
        public let themeId: String
        /// The version number of the theme.
        public let themeVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, themeId: String, themeVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.themeVersionNumber = themeVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.themeVersionNumber, name: "themeVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct CreateThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct CreateThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The ID of the AWS account where you want to store the new theme.
        public let awsAccountId: String
        /// The ID of the theme that a custom theme will inherit from. All themes inherit from one of the starting themes defined by Amazon QuickSight. For a list of the starting themes, use ListThemes or choose Themes from within a QuickSight analysis.
        public let baseThemeId: String
        /// The theme configuration, which contains the theme display properties.
        public let configuration: ThemeConfiguration
        /// A display name for the theme.
        public let name: String
        /// A valid grouping of resource permissions to apply to the new theme.
        public let permissions: [ResourcePermission]?
        /// A map of the key-value pairs for the resource tag or tags that you want to add to the resource.
        public let tags: [Tag]?
        /// An ID for the theme that you want to create. The theme ID is unique per AWS Region in each AWS account.
        public let themeId: String
        /// A description of the first version of the theme that you're creating. Every time UpdateTheme is called, a new version is created. Each version of the theme has a description of the version in the VersionDescription field.
        public let versionDescription: String?

        public init(awsAccountId: String, baseThemeId: String, configuration: ThemeConfiguration, name: String, permissions: [ResourcePermission]? = nil, tags: [Tag]? = nil, themeId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.name = name
            self.permissions = permissions
            self.tags = tags
            self.themeId = themeId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, max: 2048)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, min: 1)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, pattern: "[\\w\\-]+")
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case name = "Name"
            case permissions = "Permissions"
            case tags = "Tags"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the theme.
        public let arn: String?
        /// The theme creation status.
        public let creationStatus: ResourceStatus?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the theme.
        public let themeId: String?
        /// The Amazon Resource Name (ARN) for the new theme.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
            case versionArn = "VersionArn"
        }
    }

    public struct CredentialPair: AWSEncodableShape {
        /// A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the AlternateDataSourceParameters list is null, the DataSourceParameters originally used with these Credentials is automatically allowed.
        public let alternateDataSourceParameters: [DataSourceParameters]?
        /// Password.
        public let password: String
        /// User name.
        public let username: String

        public init(alternateDataSourceParameters: [DataSourceParameters]? = nil, password: String, username: String) {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.alternateDataSourceParameters?.forEach {
                try $0.validate(name: "\(name).alternateDataSourceParameters[]")
            }
            try self.validate(self.alternateDataSourceParameters, name: "alternateDataSourceParameters", parent: name, max: 50)
            try self.validate(self.alternateDataSourceParameters, name: "alternateDataSourceParameters", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, max: 1024)
            try self.validate(self.password, name: "password", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 64)
            try self.validate(self.username, name: "username", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case alternateDataSourceParameters = "AlternateDataSourceParameters"
            case password = "Password"
            case username = "Username"
        }
    }

    public struct CustomSql: AWSEncodableShape & AWSDecodableShape {
        /// The column schema from the SQL query result set.
        public let columns: [InputColumn]?
        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String
        /// A display name for the SQL query result.
        public let name: String
        /// The SQL query.
        public let sqlQuery: String

        public init(columns: [InputColumn]? = nil, dataSourceArn: String, name: String, sqlQuery: String) {
            self.columns = columns
            self.dataSourceArn = dataSourceArn
            self.name = name
            self.sqlQuery = sqlQuery
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 2048)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sqlQuery, name: "sqlQuery", parent: name, max: 65536)
            try self.validate(self.sqlQuery, name: "sqlQuery", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case dataSourceArn = "DataSourceArn"
            case name = "Name"
            case sqlQuery = "SqlQuery"
        }
    }

    public struct Dashboard: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dataset was created.
        public let createdTime: Date?
        /// Dashboard ID.
        public let dashboardId: String?
        /// The last time that this dataset was published.
        public let lastPublishedTime: Date?
        /// The last time that this dataset was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dashboard.
        public let name: String?
        /// Version.
        public let version: DashboardVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, dashboardId: String? = nil, lastPublishedTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, version: DashboardVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dashboardId = "DashboardId"
            case lastPublishedTime = "LastPublishedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct DashboardError: AWSDecodableShape {
        /// Message.
        public let message: String?
        /// Type.
        public let type: DashboardErrorType?

        public init(message: String? = nil, type: DashboardErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct DashboardPublishOptions: AWSEncodableShape {
        /// Ad hoc (one-time) filtering option.
        public let adHocFilteringOption: AdHocFilteringOption?
        /// Export to .csv option.
        public let exportToCSVOption: ExportToCSVOption?
        /// Sheet controls option.
        public let sheetControlsOption: SheetControlsOption?

        public init(adHocFilteringOption: AdHocFilteringOption? = nil, exportToCSVOption: ExportToCSVOption? = nil, sheetControlsOption: SheetControlsOption? = nil) {
            self.adHocFilteringOption = adHocFilteringOption
            self.exportToCSVOption = exportToCSVOption
            self.sheetControlsOption = sheetControlsOption
        }

        private enum CodingKeys: String, CodingKey {
            case adHocFilteringOption = "AdHocFilteringOption"
            case exportToCSVOption = "ExportToCSVOption"
            case sheetControlsOption = "SheetControlsOption"
        }
    }

    public struct DashboardSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_USER".
        public let name: DashboardFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example, "Operator": "StringEquals".
        public let `operator`: FilterOperator
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String?

        public init(name: DashboardFilterAttribute? = nil, operator: FilterOperator, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct DashboardSourceEntity: AWSEncodableShape {
        /// Source template.
        public let sourceTemplate: DashboardSourceTemplate?

        public init(sourceTemplate: DashboardSourceTemplate? = nil) {
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceTemplate?.validate(name: "\(name).sourceTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct DashboardSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// Dataset references.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct DashboardSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard was created.
        public let createdTime: Date?
        /// Dashboard ID.
        public let dashboardId: String?
        /// The last time that this dashboard was published.
        public let lastPublishedTime: Date?
        /// The last time that this dashboard was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dashboard.
        public let name: String?
        /// Published version number.
        public let publishedVersionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, dashboardId: String? = nil, lastPublishedTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, publishedVersionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishedVersionNumber = publishedVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dashboardId = "DashboardId"
            case lastPublishedTime = "LastPublishedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case publishedVersionNumber = "PublishedVersionNumber"
        }
    }

    public struct DashboardVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard version was created.
        public let createdTime: Date?
        /// The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.
        public let dataSetArns: [String]?
        /// Description.
        public let description: String?
        /// Errors associated with this dashboard version.
        public let errors: [DashboardError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// Source entity ARN.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The ARN of the theme associated with a version of the dashboard.
        public let themeArn: String?
        /// Version number for this version of the dashboard.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, dataSetArns: [String]? = nil, description: String? = nil, errors: [DashboardError]? = nil, sheets: [Sheet]? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, themeArn: String? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSetArns = "DataSetArns"
            case description = "Description"
            case errors = "Errors"
            case sheets = "Sheets"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case themeArn = "ThemeArn"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DashboardVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard version was created.
        public let createdTime: Date?
        /// Description.
        public let description: String?
        /// Source entity ARN.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// Version number.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DataColorPalette: AWSEncodableShape & AWSDecodableShape {
        /// The hexadecimal codes for the colors.
        public let colors: [String]?
        /// The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        public let emptyFillColor: String?
        /// The minimum and maximum hexadecimal codes that describe a color gradient.
        public let minMaxGradient: [String]?

        public init(colors: [String]? = nil, emptyFillColor: String? = nil, minMaxGradient: [String]? = nil) {
            self.colors = colors
            self.emptyFillColor = emptyFillColor
            self.minMaxGradient = minMaxGradient
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try validate($0, name: "colors[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 100)
            try self.validate(self.emptyFillColor, name: "emptyFillColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.minMaxGradient?.forEach {
                try validate($0, name: "minMaxGradient[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.minMaxGradient, name: "minMaxGradient", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
            case emptyFillColor = "EmptyFillColor"
            case minMaxGradient = "MinMaxGradient"
        }
    }

    public struct DataSet: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.
        public let consumedSpiceCapacityInBytes: Int64?
        /// The time that this dataset was created.
        public let createdTime: Date?
        /// The ID of the dataset.
        public let dataSetId: String?
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// A value that indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode?
        /// The last time that this dataset was updated.
        public let lastUpdatedTime: Date?
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// A display name for the dataset.
        public let name: String?
        /// The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.
        public let outputColumns: [OutputColumn]?
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]?
        /// The row-level security configuration for the dataset.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?

        public init(arn: String? = nil, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, consumedSpiceCapacityInBytes: Int64? = nil, createdTime: Date? = nil, dataSetId: String? = nil, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode? = nil, lastUpdatedTime: Date? = nil, logicalTableMap: [String: LogicalTable]? = nil, name: String? = nil, outputColumns: [OutputColumn]? = nil, physicalTableMap: [String: PhysicalTable]? = nil, rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil) {
            self.arn = arn
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytes
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.outputColumns = outputColumns
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case consumedSpiceCapacityInBytes = "ConsumedSpiceCapacityInBytes"
            case createdTime = "CreatedTime"
            case dataSetId = "DataSetId"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case lastUpdatedTime = "LastUpdatedTime"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case outputColumns = "OutputColumns"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        }
    }

    public struct DataSetConfiguration: AWSDecodableShape {
        /// A structure containing the list of column group schemas.
        public let columnGroupSchemaList: [ColumnGroupSchema]?
        /// Dataset schema.
        public let dataSetSchema: DataSetSchema?
        /// Placeholder.
        public let placeholder: String?

        public init(columnGroupSchemaList: [ColumnGroupSchema]? = nil, dataSetSchema: DataSetSchema? = nil, placeholder: String? = nil) {
            self.columnGroupSchemaList = columnGroupSchemaList
            self.dataSetSchema = dataSetSchema
            self.placeholder = placeholder
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroupSchemaList = "ColumnGroupSchemaList"
            case dataSetSchema = "DataSetSchema"
            case placeholder = "Placeholder"
        }
    }

    public struct DataSetReference: AWSEncodableShape {
        /// Dataset Amazon Resource Name (ARN).
        public let dataSetArn: String
        /// Dataset placeholder.
        public let dataSetPlaceholder: String

        public init(dataSetArn: String, dataSetPlaceholder: String) {
            self.dataSetArn = dataSetArn
            self.dataSetPlaceholder = dataSetPlaceholder
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetPlaceholder, name: "dataSetPlaceholder", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetPlaceholder = "DataSetPlaceholder"
        }
    }

    public struct DataSetSchema: AWSDecodableShape {
        /// A structure containing the list of column schemas.
        public let columnSchemaList: [ColumnSchema]?

        public init(columnSchemaList: [ColumnSchema]? = nil) {
            self.columnSchemaList = columnSchemaList
        }

        private enum CodingKeys: String, CodingKey {
            case columnSchemaList = "ColumnSchemaList"
        }
    }

    public struct DataSetSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// A value that indicates if the dataset has column level permission configured.
        public let columnLevelPermissionRulesApplied: Bool?
        /// The time that this dataset was created.
        public let createdTime: Date?
        /// The ID of the dataset.
        public let dataSetId: String?
        /// A value that indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode?
        /// The last time that this dataset was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dataset.
        public let name: String?
        /// The row-level security configuration for the dataset.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?

        public init(arn: String? = nil, columnLevelPermissionRulesApplied: Bool? = nil, createdTime: Date? = nil, dataSetId: String? = nil, importMode: DataSetImportMode? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil) {
            self.arn = arn
            self.columnLevelPermissionRulesApplied = columnLevelPermissionRulesApplied
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case columnLevelPermissionRulesApplied = "ColumnLevelPermissionRulesApplied"
            case createdTime = "CreatedTime"
            case dataSetId = "DataSetId"
            case importMode = "ImportMode"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the AlternateDataSourceParameters list is null, the Credentials originally used with this DataSourceParameters are automatically allowed.
        public let alternateDataSourceParameters: [DataSourceParameters]?
        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The time that this data source was created.
        public let createdTime: Date?
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String?
        /// The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
        public let dataSourceParameters: DataSourceParameters?
        /// Error information from the last update or the creation of the data source.
        public let errorInfo: DataSourceErrorInfo?
        /// The last time that this data source was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the data source.
        public let name: String?
        /// Secure Socket Layer (SSL) properties that apply when QuickSight connects to your underlying source.
        public let sslProperties: SslProperties?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The type of the data source. This type indicates which database engine the data source connects to.
        public let type: DataSourceType?
        /// The VPC connection information. You need to use this parameter only when you want QuickSight to use a VPC connection when connecting to your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(alternateDataSourceParameters: [DataSourceParameters]? = nil, arn: String? = nil, createdTime: Date? = nil, dataSourceId: String? = nil, dataSourceParameters: DataSourceParameters? = nil, errorInfo: DataSourceErrorInfo? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, sslProperties: SslProperties? = nil, status: ResourceStatus? = nil, type: DataSourceType? = nil, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.errorInfo = errorInfo
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sslProperties = sslProperties
            self.status = status
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        private enum CodingKeys: String, CodingKey {
            case alternateDataSourceParameters = "AlternateDataSourceParameters"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSourceId = "DataSourceId"
            case dataSourceParameters = "DataSourceParameters"
            case errorInfo = "ErrorInfo"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case sslProperties = "SslProperties"
            case status = "Status"
            case type = "Type"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct DataSourceCredentials: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When CopySourceArn is not null, the credential pair from the data source in the ARN is used as the credentials for the DataSourceCredentials structure.
        public let copySourceArn: String?
        /// Credential pair. For more information, see CredentialPair.
        public let credentialPair: CredentialPair?

        public init(copySourceArn: String? = nil, credentialPair: CredentialPair? = nil) {
            self.copySourceArn = copySourceArn
            self.credentialPair = credentialPair
        }

        public func validate(name: String) throws {
            try self.validate(self.copySourceArn, name: "copySourceArn", parent: name, pattern: "^arn:[-a-z0-9]*:quicksight:[-a-z0-9]*:[0-9]{12}:datasource/.+")
            try self.credentialPair?.validate(name: "\(name).credentialPair")
        }

        private enum CodingKeys: String, CodingKey {
            case copySourceArn = "CopySourceArn"
            case credentialPair = "CredentialPair"
        }
    }

    public struct DataSourceErrorInfo: AWSDecodableShape {
        /// Error message.
        public let message: String?
        /// Error type.
        public let type: DataSourceErrorInfoType?

        public init(message: String? = nil, type: DataSourceErrorInfoType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct DataSourceParameters: AWSEncodableShape & AWSDecodableShape {
        /// Amazon Elasticsearch Service parameters.
        public let amazonElasticsearchParameters: AmazonElasticsearchParameters?
        /// Amazon Athena parameters.
        public let athenaParameters: AthenaParameters?
        /// Amazon Aurora MySQL parameters.
        public let auroraParameters: AuroraParameters?
        /// Aurora PostgreSQL parameters.
        public let auroraPostgreSqlParameters: AuroraPostgreSqlParameters?
        /// AWS IoT Analytics parameters.
        public let awsIotAnalyticsParameters: AwsIotAnalyticsParameters?
        /// Jira parameters.
        public let jiraParameters: JiraParameters?
        /// MariaDB parameters.
        public let mariaDbParameters: MariaDbParameters?
        /// MySQL parameters.
        public let mySqlParameters: MySqlParameters?
        /// Oracle parameters.
        public let oracleParameters: OracleParameters?
        /// PostgreSQL parameters.
        public let postgreSqlParameters: PostgreSqlParameters?
        /// Presto parameters.
        public let prestoParameters: PrestoParameters?
        /// Amazon RDS parameters.
        public let rdsParameters: RdsParameters?
        /// Amazon Redshift parameters.
        public let redshiftParameters: RedshiftParameters?
        /// S3 parameters.
        public let s3Parameters: S3Parameters?
        /// ServiceNow parameters.
        public let serviceNowParameters: ServiceNowParameters?
        /// Snowflake parameters.
        public let snowflakeParameters: SnowflakeParameters?
        /// Spark parameters.
        public let sparkParameters: SparkParameters?
        /// SQL Server parameters.
        public let sqlServerParameters: SqlServerParameters?
        /// Teradata parameters.
        public let teradataParameters: TeradataParameters?
        /// Twitter parameters.
        public let twitterParameters: TwitterParameters?

        public init(amazonElasticsearchParameters: AmazonElasticsearchParameters? = nil, athenaParameters: AthenaParameters? = nil, auroraParameters: AuroraParameters? = nil, auroraPostgreSqlParameters: AuroraPostgreSqlParameters? = nil, awsIotAnalyticsParameters: AwsIotAnalyticsParameters? = nil, jiraParameters: JiraParameters? = nil, mariaDbParameters: MariaDbParameters? = nil, mySqlParameters: MySqlParameters? = nil, oracleParameters: OracleParameters? = nil, postgreSqlParameters: PostgreSqlParameters? = nil, prestoParameters: PrestoParameters? = nil, rdsParameters: RdsParameters? = nil, redshiftParameters: RedshiftParameters? = nil, s3Parameters: S3Parameters? = nil, serviceNowParameters: ServiceNowParameters? = nil, snowflakeParameters: SnowflakeParameters? = nil, sparkParameters: SparkParameters? = nil, sqlServerParameters: SqlServerParameters? = nil, teradataParameters: TeradataParameters? = nil, twitterParameters: TwitterParameters? = nil) {
            self.amazonElasticsearchParameters = amazonElasticsearchParameters
            self.athenaParameters = athenaParameters
            self.auroraParameters = auroraParameters
            self.auroraPostgreSqlParameters = auroraPostgreSqlParameters
            self.awsIotAnalyticsParameters = awsIotAnalyticsParameters
            self.jiraParameters = jiraParameters
            self.mariaDbParameters = mariaDbParameters
            self.mySqlParameters = mySqlParameters
            self.oracleParameters = oracleParameters
            self.postgreSqlParameters = postgreSqlParameters
            self.prestoParameters = prestoParameters
            self.rdsParameters = rdsParameters
            self.redshiftParameters = redshiftParameters
            self.s3Parameters = s3Parameters
            self.serviceNowParameters = serviceNowParameters
            self.snowflakeParameters = snowflakeParameters
            self.sparkParameters = sparkParameters
            self.sqlServerParameters = sqlServerParameters
            self.teradataParameters = teradataParameters
            self.twitterParameters = twitterParameters
        }

        public func validate(name: String) throws {
            try self.amazonElasticsearchParameters?.validate(name: "\(name).amazonElasticsearchParameters")
            try self.athenaParameters?.validate(name: "\(name).athenaParameters")
            try self.auroraParameters?.validate(name: "\(name).auroraParameters")
            try self.auroraPostgreSqlParameters?.validate(name: "\(name).auroraPostgreSqlParameters")
            try self.awsIotAnalyticsParameters?.validate(name: "\(name).awsIotAnalyticsParameters")
            try self.jiraParameters?.validate(name: "\(name).jiraParameters")
            try self.mariaDbParameters?.validate(name: "\(name).mariaDbParameters")
            try self.mySqlParameters?.validate(name: "\(name).mySqlParameters")
            try self.oracleParameters?.validate(name: "\(name).oracleParameters")
            try self.postgreSqlParameters?.validate(name: "\(name).postgreSqlParameters")
            try self.prestoParameters?.validate(name: "\(name).prestoParameters")
            try self.rdsParameters?.validate(name: "\(name).rdsParameters")
            try self.redshiftParameters?.validate(name: "\(name).redshiftParameters")
            try self.s3Parameters?.validate(name: "\(name).s3Parameters")
            try self.serviceNowParameters?.validate(name: "\(name).serviceNowParameters")
            try self.snowflakeParameters?.validate(name: "\(name).snowflakeParameters")
            try self.sparkParameters?.validate(name: "\(name).sparkParameters")
            try self.sqlServerParameters?.validate(name: "\(name).sqlServerParameters")
            try self.teradataParameters?.validate(name: "\(name).teradataParameters")
            try self.twitterParameters?.validate(name: "\(name).twitterParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonElasticsearchParameters = "AmazonElasticsearchParameters"
            case athenaParameters = "AthenaParameters"
            case auroraParameters = "AuroraParameters"
            case auroraPostgreSqlParameters = "AuroraPostgreSqlParameters"
            case awsIotAnalyticsParameters = "AwsIotAnalyticsParameters"
            case jiraParameters = "JiraParameters"
            case mariaDbParameters = "MariaDbParameters"
            case mySqlParameters = "MySqlParameters"
            case oracleParameters = "OracleParameters"
            case postgreSqlParameters = "PostgreSqlParameters"
            case prestoParameters = "PrestoParameters"
            case rdsParameters = "RdsParameters"
            case redshiftParameters = "RedshiftParameters"
            case s3Parameters = "S3Parameters"
            case serviceNowParameters = "ServiceNowParameters"
            case snowflakeParameters = "SnowflakeParameters"
            case sparkParameters = "SparkParameters"
            case sqlServerParameters = "SqlServerParameters"
            case teradataParameters = "TeradataParameters"
            case twitterParameters = "TwitterParameters"
        }
    }

    public struct DateTimeParameter: AWSEncodableShape {
        /// A display name for the date-time parameter.
        public let name: String
        /// The values for the date-time parameter.
        public let values: [Date]

        public init(name: String, values: [Date]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct DecimalParameter: AWSEncodableShape {
        /// A display name for the decimal parameter.
        public let name: String
        /// The values for the decimal parameter.
        public let values: [Double]

        public init(name: String, values: [Double]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct DeleteAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace"))
        ]

        /// The ID for the AWS account that you want to delete QuickSight customizations from in this AWS Region.
        public let awsAccountId: String
        /// The QuickSight namespace that you're deleting the customizations from.
        public let namespace: String?

        public init(awsAccountId: String, namespace: String? = nil) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "forceDeleteWithoutRecovery", location: .querystring(locationName: "force-delete-without-recovery")),
            AWSMemberEncoding(label: "recoveryWindowInDays", location: .querystring(locationName: "recovery-window-in-days"))
        ]

        /// The ID of the analysis that you're deleting.
        public let analysisId: String
        /// The ID of the AWS account where you want to delete an analysis.
        public let awsAccountId: String
        /// This option defaults to the value NoForceDeleteWithoutRecovery. To immediately delete the analysis, add the ForceDeleteWithoutRecovery option. You can't restore an analysis after it's deleted.
        public let forceDeleteWithoutRecovery: Bool?
        /// A value that specifies the number of days that QuickSight waits before it deletes the analysis. You can't use this parameter with the ForceDeleteWithoutRecovery option in the same API call. The default value is 30.
        public let recoveryWindowInDays: Int64?

        public init(analysisId: String, awsAccountId: String, forceDeleteWithoutRecovery: Bool? = nil, recoveryWindowInDays: Int64? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
            self.recoveryWindowInDays = recoveryWindowInDays
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 2048)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.recoveryWindowInDays, name: "recoveryWindowInDays", parent: name, max: 30)
            try self.validate(self.recoveryWindowInDays, name: "recoveryWindowInDays", parent: name, min: 7)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the deleted analysis.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the deleted analysis.
        public let arn: String?
        /// The date and time that the analysis is scheduled to be deleted.
        public let deletionTime: Date?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, deletionTime: Date? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.deletionTime = deletionTime
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case deletionTime = "DeletionTime"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring(locationName: "version-number"))
        ]

        /// The ID of the AWS account that contains the dashboard that you're deleting.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number of the dashboard. If the version number property is provided, only the specified version of the dashboard is deleted.
        public let versionNumber: Int64?

        public init(awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Secure Socket Layer (SSL) properties that apply for the resource.
        public let arn: String?
        /// The ID of the dashboard.
        public let dashboardId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri(locationName: "DataSourceId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source that you deleted.
        public let arn: String?
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteFolderMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId")),
            AWSMemberEncoding(label: "memberId", location: .uri(locationName: "MemberId")),
            AWSMemberEncoding(label: "memberType", location: .uri(locationName: "MemberType"))
        ]

        /// The AWS Account ID.
        public let awsAccountId: String
        /// The Folder ID.
        public let folderId: String
        /// The ID of the asset (the dashboard, analysis, or dataset) that you want to delete.
        public let memberId: String
        /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET
        public let memberType: MemberType

        public init(awsAccountId: String, folderId: String, memberId: String, memberType: MemberType) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.memberId = memberId
            self.memberType = memberType
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 2048)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderMembershipResponse: AWSDecodableShape {
        /// The request ID.
        public let requestId: String?
        /// The status of deleting the asset. If succeeded, the status is SC_OK (200).
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId"))
        ]

        /// The AWS Account ID for the folder.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name of the deleted folder.
        public let arn: String?
        /// The folder ID.
        public let folderId: String?
        /// The request ID.
        public let requestId: String?
        /// The status of deleting the folder. If succeeded, the status is SC_OK (200).
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteGroupMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri(locationName: "GroupName")),
            AWSMemberEncoding(label: "memberName", location: .uri(locationName: "MemberName")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to delete the user from.
        public let groupName: String
        /// The name of the user that you want to delete from the group membership.
        public let memberName: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupMembershipResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri(locationName: "GroupName")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to delete.
        public let groupName: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assignmentName", location: .uri(locationName: "AssignmentName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The name of the assignment.
        public let assignmentName: String
        /// The AWS account ID where you want to delete the IAM policy assignment.
        public let awsAccountId: String
        /// The namespace that contains the assignment.
        public let namespace: String

        public init(assignmentName: String, awsAccountId: String, namespace: String) {
            self.assignmentName = assignmentName
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the assignment.
        public let assignmentName: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentName: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentName = assignmentName
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that you want to delete the QuickSight namespace from.
        public let awsAccountId: String
        /// The namespace that you want to delete.
        public let namespace: String

        public init(awsAccountId: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNamespaceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The name for the template alias. To delete a specific alias, you delete the version that the alias points to. You can specify the alias name, or specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter.
        public let aliasName: String
        /// The ID of the AWS account that contains the item to delete.
        public let awsAccountId: String
        /// The ID for the template that the specified alias is for.
        public let templateId: String

        public init(aliasName: String, awsAccountId: String, templateId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name for the template alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the template you want to delete.
        public let arn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the template associated with the deletion.
        public let templateId: String?

        public init(aliasName: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
        }
    }

    public struct DeleteTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring(locationName: "version-number"))
        ]

        /// The ID of the AWS account that contains the template that you're deleting.
        public let awsAccountId: String
        /// An ID for the template you want to delete.
        public let templateId: String
        /// Specifies the version of the template that you want to delete. If you don't provide a version number, DeleteTemplate deletes all versions of the template.
        public let versionNumber: Int64?

        public init(awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the template.
        public let templateId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
        }
    }

    public struct DeleteThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The unique name for the theme alias to delete.
        public let aliasName: String
        /// The ID of the AWS account that contains the theme alias to delete.
        public let awsAccountId: String
        /// The ID for the theme that the specified alias is for.
        public let themeId: String

        public init(aliasName: String, awsAccountId: String, themeId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name for the theme alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the theme resource using the deleted alias.
        public let arn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the theme associated with the deletion.
        public let themeId: String?

        public init(aliasName: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
        }
    }

    public struct DeleteThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring(locationName: "version-number"))
        ]

        /// The ID of the AWS account that contains the theme that you're deleting.
        public let awsAccountId: String
        /// An ID for the theme that you want to delete.
        public let themeId: String
        /// The version of the theme that you want to delete.   Note: If you don't provide a version number, you're using this call to DeleteTheme to delete all versions of the theme.
        public let versionNumber: Int64?

        public init(awsAccountId: String, themeId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the theme.
        public let themeId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
        }
    }

    public struct DeleteUserByPrincipalIdRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "principalId", location: .uri(locationName: "PrincipalId"))
        ]

        /// The ID for the AWS account that the user is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The principal ID of the user.
        public let principalId: String

        public init(awsAccountId: String, namespace: String, principalId: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.principalId = principalId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserByPrincipalIdResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "userName", location: .uri(locationName: "UserName"))
        ]

        /// The ID for the AWS account that the user is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The name of the user that you want to delete.
        public let userName: String

        public init(awsAccountId: String, namespace: String, userName: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "[\\u0020-\\u00FF]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "resolved", location: .querystring(locationName: "resolved"))
        ]

        /// The ID for the AWS account that you want to describe QuickSight customizations for.
        public let awsAccountId: String
        /// The QuickSight namespace that you want to describe QuickSight customizations for.
        public let namespace: String?
        /// The Resolved flag works with the other parameters to determine which view of QuickSight customizations is returned. You can add this flag to your command to use the same view that QuickSight uses to identify which customizations to apply to the console. Omit this flag, or set it to no-resolved, to reveal customizations that are configured at different levels.
        public let resolved: Bool?

        public init(awsAccountId: String, namespace: String? = nil, resolved: Bool? = nil) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.resolved = resolved
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The QuickSight customizations that exist in the current AWS Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) of the customization that's associated with this AWS account.
        public let arn: String?
        /// The ID for the AWS account that you're describing.
        public let awsAccountId: String?
        /// The QuickSight namespace that you're describing.
        public let namespace: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAccountSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID for the AWS account that contains the settings that you want to list.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountSettingsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The QuickSight settings for this AWS account. This information includes the edition of Amazon QuickSight that you subscribed to (Standard or Enterprise) and the notification email for the QuickSight subscription. In the QuickSight console, the QuickSight subscription is sometimes referred to as a QuickSight "account" even though it's technically not an account by itself. Instead, it's a subscription to the QuickSight service for your AWS account. The edition that you subscribe to applies to QuickSight in every AWS Region where you use it.
        public let accountSettings: AccountSettings?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountSettings: AccountSettings? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountSettings = accountSettings
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "AccountSettings"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAnalysisPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID of the analysis whose permissions you're describing. The ID is part of the analysis URL.
        public let analysisId: String
        /// The ID of the AWS account that contains the analysis whose permissions you're describing. You must be using the AWS account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 2048)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the analysis whose permissions you're describing.
        public let analysisArn: String?
        /// The ID of the analysis whose permissions you're describing.
        public let analysisId: String?
        /// A structure that describes the principals and the resource-level permissions on an analysis.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisArn: String? = nil, analysisId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisArn = analysisArn
            self.analysisId = analysisId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisArn = "AnalysisArn"
            case analysisId = "AnalysisId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
        public let analysisId: String
        /// The ID of the AWS account that contains the analysis. You must be using the AWS account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 2048)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A metadata structure that contains summary information for the analysis that you're describing.
        public let analysis: Analysis?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysis: Analysis? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysis = analysis
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysis = "Analysis"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDashboardPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId"))
        ]

        /// The ID of the AWS account that contains the dashboard that you're describing permissions for.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the IAM policy.
        public let dashboardId: String

        public init(awsAccountId: String, dashboardId: String) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// A structure that contains the permissions for the dashboard.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring(locationName: "alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring(locationName: "version-number"))
        ]

        /// The alias name.
        public let aliasName: String?
        /// The ID of the AWS account that contains the dashboard that you're describing.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information about the dashboard.
        public let dashboard: Dashboard?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of this request.
        public let status: Int?

        public init(dashboard: Dashboard? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboard = dashboard
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboard = "Dashboard"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSetPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSetPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let dataSetArn: String?
        /// The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String?
        /// A list of resource permissions on the dataset.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetArn: String? = nil, dataSetId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetArn = dataSetArn
            self.dataSetId = dataSetId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetId = "DataSetId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information on the dataset.
        public let dataSet: DataSet?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSet: DataSet? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSet = dataSet
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSet = "DataSet"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSourcePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri(locationName: "DataSourceId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSourcePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String?
        /// A list of resource permissions on the data source.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case dataSourceId = "DataSourceId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri(locationName: "DataSourceId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The information on the data source.
        public let dataSource: DataSource?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSource: DataSource? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSource = dataSource
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeFolderPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId"))
        ]

        /// The AWS Account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the folder.
        public let arn: String?
        /// The folder ID.
        public let folderId: String?
        /// Information about the permissions on the folder.
        public let permissions: [ResourcePermission]?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderResolvedPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderResolvedPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN).
        public let arn: String?
        /// The folder ID.
        public let folderId: String?
        /// Information about the permissions on the dashboard.
        public let permissions: [ResourcePermission]?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information about the folder.
        public let folder: Folder?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK (200).
        public let status: Int?

        public init(folder: Folder? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folder = folder
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folder = "Folder"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri(locationName: "GroupName")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to describe.
        public let groupName: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the group.
        public let group: Group?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assignmentName", location: .uri(locationName: "AssignmentName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The name of the assignment, also called a rule.
        public let assignmentName: String
        /// The ID of the AWS account that contains the assignment that you want to describe.
        public let awsAccountId: String
        /// The namespace that contains the assignment.
        public let namespace: String

        public init(assignmentName: String, awsAccountId: String, namespace: String) {
            self.assignmentName = assignmentName
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information describing the IAM policy assignment.
        public let iAMPolicyAssignment: IAMPolicyAssignment?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(iAMPolicyAssignment: IAMPolicyAssignment? = nil, requestId: String? = nil, status: Int? = nil) {
            self.iAMPolicyAssignment = iAMPolicyAssignment
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case iAMPolicyAssignment = "IAMPolicyAssignment"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeIngestionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "ingestionId", location: .uri(locationName: "IngestionId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String

        public init(awsAccountId: String, dataSetId: String, ingestionId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIngestionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information about the ingestion.
        public let ingestion: Ingestion?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(ingestion: Ingestion? = nil, requestId: String? = nil, status: Int? = nil) {
            self.ingestion = ingestion
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case ingestion = "Ingestion"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that contains the QuickSight namespace that you want to describe.
        public let awsAccountId: String
        /// The namespace that you want to describe.
        public let namespace: String

        public init(awsAccountId: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeNamespaceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The information about the namespace that you're describing. The response includes the namespace ARN, name, AWS Region, creation status, and identity store. DescribeNamespace also works for namespaces that are in the process of being created. For incomplete namespaces, this API operation lists the namespace error types and messages associated with the creation process.
        public let namespace: NamespaceInfoV2?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(namespace: NamespaceInfoV2? = nil, requestId: String? = nil, status: Int? = nil) {
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The name of the template alias that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String
        /// The ID of the AWS account that contains the template alias that you're describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String

        public init(aliasName: String, awsAccountId: String, templateId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct DescribeTemplatePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The ID of the AWS account that contains the template that you're describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, templateId: String) {
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplatePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String?
        /// The ID for the template.
        public let templateId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, templateArn: String? = nil, templateId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case templateArn = "TemplateArn"
            case templateId = "TemplateId"
        }
    }

    public struct DescribeTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring(locationName: "alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring(locationName: "version-number"))
        ]

        /// The alias of the template that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String?
        /// The ID of the AWS account that contains the template that you're describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String
        /// (Optional) The number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the template is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The template structure for the object you want to describe.
        public let template: Template?

        public init(requestId: String? = nil, status: Int? = nil, template: Template? = nil) {
            self.requestId = requestId
            self.status = status
            self.template = template
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case template = "Template"
        }
    }

    public struct DescribeThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The name of the theme alias that you want to describe.
        public let aliasName: String
        /// The ID of the AWS account that contains the theme alias that you're describing.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String

        public init(aliasName: String, awsAccountId: String, themeId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct DescribeThemePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The ID of the AWS account that contains the theme that you're describing.
        public let awsAccountId: String
        /// The ID for the theme that you want to describe permissions for.
        public let themeId: String

        public init(awsAccountId: String, themeId: String) {
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of resource permissions set on the theme.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the theme.
        public let themeArn: String?
        /// The ID for the theme.
        public let themeId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, themeArn: String? = nil, themeId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.themeArn = themeArn
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case themeArn = "ThemeArn"
            case themeId = "ThemeId"
        }
    }

    public struct DescribeThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring(locationName: "alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring(locationName: "version-number"))
        ]

        /// The alias of the theme that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the theme by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to themes.
        public let aliasName: String?
        /// The ID of the AWS account that contains the theme that you're describing.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String
        /// The version number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the theme is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, themeId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^(aws|[0-9]{12})$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The information about the theme that you are describing.
        public let theme: Theme?

        public init(requestId: String? = nil, status: Int? = nil, theme: Theme? = nil) {
            self.requestId = requestId
            self.status = status
            self.theme = theme
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case theme = "Theme"
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "userName", location: .uri(locationName: "UserName"))
        ]

        /// The ID for the AWS account that the user is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The name of the user that you want to describe.
        public let userName: String

        public init(awsAccountId: String, namespace: String, userName: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "[\\u0020-\\u00FF]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The user name.
        public let user: User?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case user = "User"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// Error message.
        public let message: String?
        /// Error type.
        public let type: IngestionErrorType?

        public init(message: String? = nil, type: IngestionErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ExportToCSVOption: AWSEncodableShape {
        /// Availability status.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct FieldFolder: AWSEncodableShape & AWSDecodableShape {
        /// A folder has a list of columns. A column can only be in one folder.
        public let columns: [String]?
        /// The description for a field folder.
        public let description: String?

        public init(columns: [String]? = nil, description: String? = nil) {
            self.columns = columns
            self.description = description
        }

        public func validate(name: String) throws {
            try self.validate(self.columns, name: "columns", parent: name, max: 5000)
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case columns
            case description
        }
    }

    public struct FilterOperation: AWSEncodableShape & AWSDecodableShape {
        /// An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        public let conditionExpression: String

        public init(conditionExpression: String) {
            self.conditionExpression = conditionExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, max: 4096)
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionExpression = "ConditionExpression"
        }
    }

    public struct Folder: AWSDecodableShape {
        /// The folder Amazon Resource Name (ARN).
        public let arn: String?
        /// The time that the folder was created.
        public let createdTime: Date?
        /// The folder ID.
        public let folderId: String?
        /// An array of ancestor folder ARN strings.
        public let folderPath: [String]?
        /// The type of the folder.
        public let folderType: FolderType?
        /// The time that the folder was last updated.
        public let lastUpdatedTime: Date?
        /// A display name for the folder.
        public let name: String?

        public init(arn: String? = nil, createdTime: Date? = nil, folderId: String? = nil, folderPath: [String]? = nil, folderType: FolderType? = nil, lastUpdatedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderPath = folderPath
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case folderId = "FolderId"
            case folderPath = "FolderPath"
            case folderType = "FolderType"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
        }
    }

    public struct FolderMember: AWSDecodableShape {
        /// The ID of the asset.
        public let memberId: String?
        /// The type of the asset.
        public let memberType: MemberType?

        public init(memberId: String? = nil, memberType: MemberType? = nil) {
            self.memberId = memberId
            self.memberType = memberType
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case memberType = "MemberType"
        }
    }

    public struct FolderSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter. For example, "Name": "PARENT_FOLDER_ARN".
        public let name: FolderFilterAttribute?
        /// The comparison operator that you want to use as a filter. For example, "Operator": "StringEquals".
        public let `operator`: FilterOperator?
        /// The value of the named item (in this example, PARENT_FOLDER_ARN), that you want to use as a filter. For example, "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId".
        public let value: String?

        public init(name: FolderFilterAttribute? = nil, operator: FilterOperator? = nil, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct FolderSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN).
        public let arn: String?
        /// The time that the folder was created.
        public let createdTime: Date?
        /// The folder ID.
        public let folderId: String?
        /// The type of folder.
        public let folderType: FolderType?
        /// The time that the folder was last updated.
        public let lastUpdatedTime: Date?
        /// The display name of the folder.
        public let name: String?

        public init(arn: String? = nil, createdTime: Date? = nil, folderId: String? = nil, folderType: FolderType? = nil, lastUpdatedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case folderId = "FolderId"
            case folderType = "FolderType"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
        }
    }

    public struct GeoSpatialColumnGroup: AWSEncodableShape & AWSDecodableShape {
        /// Columns in this hierarchy.
        public let columns: [String]
        /// Country code.
        public let countryCode: GeoSpatialCountryCode
        /// A display name for the hierarchy.
        public let name: String

        public init(columns: [String], countryCode: GeoSpatialCountryCode, name: String) {
            self.columns = columns
            self.countryCode = countryCode
            self.name = name
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try validate($0, name: "columns[]", parent: name, max: 128)
                try validate($0, name: "columns[]", parent: name, min: 1)
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 16)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case countryCode = "CountryCode"
            case name = "Name"
        }
    }

    public struct GetDashboardEmbedUrlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "additionalDashboardIds", location: .querystring(locationName: "additional-dashboard-ids")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId")),
            AWSMemberEncoding(label: "identityType", location: .querystring(locationName: "creds-type")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace")),
            AWSMemberEncoding(label: "resetDisabled", location: .querystring(locationName: "reset-disabled")),
            AWSMemberEncoding(label: "sessionLifetimeInMinutes", location: .querystring(locationName: "session-lifetime")),
            AWSMemberEncoding(label: "statePersistenceEnabled", location: .querystring(locationName: "state-persistence-enabled")),
            AWSMemberEncoding(label: "undoRedoDisabled", location: .querystring(locationName: "undo-redo-disabled")),
            AWSMemberEncoding(label: "userArn", location: .querystring(locationName: "user-arn"))
        ]

        /// A list of one or more dashboard IDs that you want to add to a session that includes anonymous users. The IdentityType parameter must be set to ANONYMOUS for this to work, because other identity types authenticate as QuickSight or IAM users. For example, if you set "--dashboard-id dash_id1 --dashboard-id dash_id2 dash_id3 identity-type ANONYMOUS", the session can access all three dashboards.
        public let additionalDashboardIds: [String]?
        /// The ID for the AWS account that contains the dashboard that you're embedding.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the AWS Identity and Access Management (IAM) policy.
        public let dashboardId: String
        /// The authentication method that the user uses to sign in.
        public let identityType: EmbeddingIdentityType
        /// The QuickSight namespace that contains the dashboard IDs in this request. If you're not using a custom namespace, set this to "default".
        public let namespace: String?
        /// Remove the reset button on the embedded dashboard. The default is FALSE, which enables the reset button.
        public let resetDisabled: Bool?
        /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
        public let sessionLifetimeInMinutes: Int64?
        /// Adds persistence of state for the user session in an embedded dashboard. Persistence applies to the sheet and the parameter settings. These are control settings that the dashboard subscriber (QuickSight reader) chooses while viewing the dashboard. If this is set to TRUE, the settings are the same when the subscriber reopens the same dashboard URL. The state is stored in QuickSight, not in a browser cookie. If this is set to FALSE, the state of the user session is not persisted. The default is FALSE.
        public let statePersistenceEnabled: Bool?
        /// Remove the undo/redo button on the embedded dashboard. The default is FALSE, which enables the undo/redo button.
        public let undoRedoDisabled: Bool?
        /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any Amazon QuickSight users in your account (readers, authors, or admins) authenticated as one of the following:   Active Directory (AD) users or group members   Invited nonfederated users   IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation.   Omit this parameter for users in the third group  IAM users and IAM role-based sessions.
        public let userArn: String?

        public init(additionalDashboardIds: [String]? = nil, awsAccountId: String, dashboardId: String, identityType: EmbeddingIdentityType, namespace: String? = nil, resetDisabled: Bool? = nil, sessionLifetimeInMinutes: Int64? = nil, statePersistenceEnabled: Bool? = nil, undoRedoDisabled: Bool? = nil, userArn: String? = nil) {
            self.additionalDashboardIds = additionalDashboardIds
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.identityType = identityType
            self.namespace = namespace
            self.resetDisabled = resetDisabled
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.statePersistenceEnabled = statePersistenceEnabled
            self.undoRedoDisabled = undoRedoDisabled
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.additionalDashboardIds?.forEach {
                try validate($0, name: "additionalDashboardIds[]", parent: name, max: 2048)
                try validate($0, name: "additionalDashboardIds[]", parent: name, min: 1)
                try validate($0, name: "additionalDashboardIds[]", parent: name, pattern: "[\\w\\-]+")
            }
            try self.validate(self.additionalDashboardIds, name: "additionalDashboardIds", parent: name, max: 20)
            try self.validate(self.additionalDashboardIds, name: "additionalDashboardIds", parent: name, min: 1)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDashboardEmbedUrlResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A single-use URL that you can put into your server-side webpage to embed your dashboard. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
        public let embedUrl: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(embedUrl: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct GetSessionEmbedUrlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "entryPoint", location: .querystring(locationName: "entry-point")),
            AWSMemberEncoding(label: "sessionLifetimeInMinutes", location: .querystring(locationName: "session-lifetime")),
            AWSMemberEncoding(label: "userArn", location: .querystring(locationName: "user-arn"))
        ]

        /// The ID for the AWS account associated with your QuickSight subscription.
        public let awsAccountId: String
        /// The URL you use to access the embedded session. The entry point URL is constrained to the following paths:    /start     /start/analyses     /start/dashboards     /start/favorites     /dashboards/DashboardId  - where DashboardId is the actual ID key from the QuickSight console URL of the dashboard    /analyses/AnalysisId  - where AnalysisId is the actual ID key from the QuickSight console URL of the analysis
        public let entryPoint: String?
        /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
        public let sessionLifetimeInMinutes: Int64?
        /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any type of Amazon QuickSight users in your account (readers, authors, or admins). They need to be authenticated as one of the following:   Active Directory (AD) users or group members   Invited nonfederated users   AWS Identity and Access Management (IAM) users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation   Omit this parameter for users in the third group, IAM users and IAM role-based sessions.
        public let userArn: String?

        public init(awsAccountId: String, entryPoint: String? = nil, sessionLifetimeInMinutes: Int64? = nil, userArn: String? = nil) {
            self.awsAccountId = awsAccountId
            self.entryPoint = entryPoint
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, max: 1000)
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, min: 1)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionEmbedUrlResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A single-use URL that you can put into your server-side web page to embed your QuickSight session. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
        public let embedUrl: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(embedUrl: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct Group: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the group.
        public let arn: String?
        /// The group description.
        public let description: String?
        /// The name of the group.
        public let groupName: String?
        /// The principal ID of the group.
        public let principalId: String?

        public init(arn: String? = nil, description: String? = nil, groupName: String? = nil, principalId: String? = nil) {
            self.arn = arn
            self.description = description
            self.groupName = groupName
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case groupName = "GroupName"
            case principalId = "PrincipalId"
        }
    }

    public struct GroupMember: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the group member (user).
        public let arn: String?
        /// The name of the group member (user).
        public let memberName: String?

        public init(arn: String? = nil, memberName: String? = nil) {
            self.arn = arn
            self.memberName = memberName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case memberName = "MemberName"
        }
    }

    public struct GutterStyle: AWSEncodableShape & AWSDecodableShape {
        /// This Boolean value controls whether to display a gutter space between sheet tiles.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct IAMPolicyAssignment: AWSDecodableShape {
        /// Assignment ID.
        public let assignmentId: String?
        /// Assignment name.
        public let assignmentName: String?
        /// Assignment status.
        public let assignmentStatus: AssignmentStatus?
        /// The AWS account ID.
        public let awsAccountId: String?
        /// Identities.
        public let identities: [String: [String]]?
        /// The Amazon Resource Name (ARN) for the IAM policy.
        public let policyArn: String?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, awsAccountId: String? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.policyArn = policyArn
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case awsAccountId = "AwsAccountId"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct IAMPolicyAssignmentSummary: AWSDecodableShape {
        /// Assignment name.
        public let assignmentName: String?
        /// Assignment status.
        public let assignmentStatus: AssignmentStatus?

        public init(assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
        }
    }

    public struct Ingestion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// The time that this ingestion started.
        public let createdTime: Date
        /// Error information for this ingestion.
        public let errorInfo: ErrorInfo?
        /// Ingestion ID.
        public let ingestionId: String?
        /// The size of the data ingested, in bytes.
        public let ingestionSizeInBytes: Int64?
        /// Ingestion status.
        public let ingestionStatus: IngestionStatus
        /// The time that this ingestion took, measured in seconds.
        public let ingestionTimeInSeconds: Int64?
        public let queueInfo: QueueInfo?
        /// Event source for this ingestion.
        public let requestSource: IngestionRequestSource?
        /// Type of this ingestion.
        public let requestType: IngestionRequestType?
        public let rowInfo: RowInfo?

        public init(arn: String, createdTime: Date, errorInfo: ErrorInfo? = nil, ingestionId: String? = nil, ingestionSizeInBytes: Int64? = nil, ingestionStatus: IngestionStatus, ingestionTimeInSeconds: Int64? = nil, queueInfo: QueueInfo? = nil, requestSource: IngestionRequestSource? = nil, requestType: IngestionRequestType? = nil, rowInfo: RowInfo? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.errorInfo = errorInfo
            self.ingestionId = ingestionId
            self.ingestionSizeInBytes = ingestionSizeInBytes
            self.ingestionStatus = ingestionStatus
            self.ingestionTimeInSeconds = ingestionTimeInSeconds
            self.queueInfo = queueInfo
            self.requestSource = requestSource
            self.requestType = requestType
            self.rowInfo = rowInfo
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case errorInfo = "ErrorInfo"
            case ingestionId = "IngestionId"
            case ingestionSizeInBytes = "IngestionSizeInBytes"
            case ingestionStatus = "IngestionStatus"
            case ingestionTimeInSeconds = "IngestionTimeInSeconds"
            case queueInfo = "QueueInfo"
            case requestSource = "RequestSource"
            case requestType = "RequestType"
            case rowInfo = "RowInfo"
        }
    }

    public struct InputColumn: AWSEncodableShape & AWSDecodableShape {
        /// The name of this column in the underlying data source.
        public let name: String
        /// The data type of the column.
        public let type: InputColumnDataType

        public init(name: String, type: InputColumnDataType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct IntegerParameter: AWSEncodableShape {
        /// The name of the integer parameter.
        public let name: String
        /// The values for the integer parameter.
        public let values: [Int64]

        public init(name: String, values: [Int64]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct JiraParameters: AWSEncodableShape & AWSDecodableShape {
        /// The base URL of the Jira site.
        public let siteBaseUrl: String

        public init(siteBaseUrl: String) {
            self.siteBaseUrl = siteBaseUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, max: 1024)
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case siteBaseUrl = "SiteBaseUrl"
        }
    }

    public struct JoinInstruction: AWSEncodableShape & AWSDecodableShape {
        /// Join key properties of the left operand.
        public let leftJoinKeyProperties: JoinKeyProperties?
        /// The operand on the left side of a join.
        public let leftOperand: String
        /// The join instructions provided in the ON clause of a join.
        public let onClause: String
        /// Join key properties of the right operand.
        public let rightJoinKeyProperties: JoinKeyProperties?
        /// The operand on the right side of a join.
        public let rightOperand: String
        /// The type of join that it is.
        public let type: JoinType

        public init(leftJoinKeyProperties: JoinKeyProperties? = nil, leftOperand: String, onClause: String, rightJoinKeyProperties: JoinKeyProperties? = nil, rightOperand: String, type: JoinType) {
            self.leftJoinKeyProperties = leftJoinKeyProperties
            self.leftOperand = leftOperand
            self.onClause = onClause
            self.rightJoinKeyProperties = rightJoinKeyProperties
            self.rightOperand = rightOperand
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, max: 64)
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, min: 1)
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, pattern: "[0-9a-zA-Z-]*")
            try self.validate(self.onClause, name: "onClause", parent: name, max: 512)
            try self.validate(self.onClause, name: "onClause", parent: name, min: 1)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, max: 64)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, min: 1)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, pattern: "[0-9a-zA-Z-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case leftJoinKeyProperties = "LeftJoinKeyProperties"
            case leftOperand = "LeftOperand"
            case onClause = "OnClause"
            case rightJoinKeyProperties = "RightJoinKeyProperties"
            case rightOperand = "RightOperand"
            case type = "Type"
        }
    }

    public struct JoinKeyProperties: AWSEncodableShape & AWSDecodableShape {
        /// A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by QuickSight to optimize query performance.
        public let uniqueKey: Bool?

        public init(uniqueKey: Bool? = nil) {
            self.uniqueKey = uniqueKey
        }

        private enum CodingKeys: String, CodingKey {
            case uniqueKey = "UniqueKey"
        }
    }

    public struct ListAnalysesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID of the AWS account that contains the analyses.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalysesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Metadata describing each of the analyses that are listed.
        public let analysisSummaryList: [AnalysisSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisSummaryList: [AnalysisSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisSummaryList = analysisSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSummaryList = "AnalysisSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListDashboardVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID of the AWS account that contains the dashboard that you're listing versions for.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, dashboardId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardVersionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains information about each version of the dashboard.
        public let dashboardVersionSummaryList: [DashboardVersionSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardVersionSummaryList: [DashboardVersionSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardVersionSummaryList = dashboardVersionSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardVersionSummaryList = "DashboardVersionSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID of the AWS account that contains the dashboards that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the dashboards in your AWS account. This structure provides basic information about the dashboards.
        public let dashboardSummaryList: [DashboardSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardSummaryList: [DashboardSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardSummaryList = dashboardSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaryList = "DashboardSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListDataSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of dataset summaries.
        public let dataSetSummaries: [DataSetSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetSummaries: [DataSetSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetSummaries = dataSetSummaries
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetSummaries = "DataSetSummaries"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of data sources.
        public let dataSources: [DataSource]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSources: [DataSource]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSources = dataSources
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "DataSources"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListFolderMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, folderId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFolderMembersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the folder members (dashboards, analyses, and datasets) in the folder.
        public let folderMemberList: [MemberIdArnPair]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK
        public let status: Int?

        public init(folderMemberList: [MemberIdArnPair]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderMemberList = folderMemberList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderMemberList = "FolderMemberList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListFoldersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFoldersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the folders in your AWS account. This structure provides basic information about the folders.
        public let folderSummaryList: [FolderSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK
        public let status: Int?

        public init(folderSummaryList: [FolderSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderSummaryList = folderSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderSummaryList = "FolderSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListGroupMembershipsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri(locationName: "GroupName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to see a membership list of.
        public let groupName: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, groupName: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupMembershipsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of the members of the group.
        public let groupMemberList: [GroupMember]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMemberList: [GroupMember]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMemberList = groupMemberList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupMemberList = "GroupMemberList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of the groups.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListIAMPolicyAssignmentsForUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "userName", location: .uri(locationName: "UserName"))
        ]

        /// The ID of the AWS account that contains the assignments.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace of the assignment.
        public let namespace: String
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The name of the user.
        public let userName: String

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "[\\u0020-\\u00FF]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIAMPolicyAssignmentsForUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The active assignments for this user.
        public let activeAssignments: [ActiveIAMPolicyAssignment]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(activeAssignments: [ActiveIAMPolicyAssignment]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.activeAssignments = activeAssignments
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case activeAssignments = "ActiveAssignments"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListIAMPolicyAssignmentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The status of the assignments.
        public let assignmentStatus: AssignmentStatus?
        /// The ID of the AWS account that contains these IAM policy assignments.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace for the assignments.
        public let namespace: String
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(assignmentStatus: AssignmentStatus? = nil, awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentStatus = "AssignmentStatus"
        }
    }

    public struct ListIAMPolicyAssignmentsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information describing the IAM policy assignments.
        public let iAMPolicyAssignments: [IAMPolicyAssignmentSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(iAMPolicyAssignments: [IAMPolicyAssignmentSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.iAMPolicyAssignments = iAMPolicyAssignments
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case iAMPolicyAssignments = "IAMPolicyAssignments"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListIngestionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, dataSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIngestionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of the ingestions.
        public let ingestions: [Ingestion]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(ingestions: [Ingestion]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.ingestions = ingestions
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case ingestions = "Ingestions"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListNamespacesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID for the AWS account that contains the QuickSight namespaces that you want to list.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNamespacesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The information about the namespaces in this AWS account. The response includes the namespace ARN, name, AWS Region, notification email address, creation status, and identity store.
        public let namespaces: [NamespaceInfoV2]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(namespaces: [NamespaceInfoV2]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.namespaces = namespaces
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case namespaces = "Namespaces"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want a list of tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [Tag]?

        public init(requestId: String? = nil, status: Int? = nil, tags: [Tag]? = nil) {
            self.requestId = requestId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct ListTemplateAliasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-result")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The ID of the AWS account that contains the template aliases that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplateAliasesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing the list of the template's aliases.
        public let templateAliasList: [TemplateAlias]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateAliasList: [TemplateAlias]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateAliasList = templateAliasList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case templateAliasList = "TemplateAliasList"
        }
    }

    public struct ListTemplateVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The ID of the AWS account that contains the templates that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplateVersionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing a list of all the versions of the specified template.
        public let templateVersionSummaryList: [TemplateVersionSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateVersionSummaryList: [TemplateVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateVersionSummaryList = templateVersionSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case templateVersionSummaryList = "TemplateVersionSummaryList"
        }
    }

    public struct ListTemplatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-result")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID of the AWS account that contains the templates that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplatesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing information about the templates in the list.
        public let templateSummaryList: [TemplateSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateSummaryList: [TemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateSummaryList = templateSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case templateSummaryList = "TemplateSummaryList"
        }
    }

    public struct ListThemeAliasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-result")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The ID of the AWS account that contains the theme aliases that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemeAliasesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing the list of the theme's aliases.
        public let themeAliasList: [ThemeAlias]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeAliasList: [ThemeAlias]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeAliasList = themeAliasList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case themeAliasList = "ThemeAliasList"
        }
    }

    public struct ListThemeVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The ID of the AWS account that contains the themes that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemeVersionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing a list of all the versions of the specified theme.
        public let themeVersionSummaryList: [ThemeVersionSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeVersionSummaryList: [ThemeVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeVersionSummaryList = themeVersionSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case themeVersionSummaryList = "ThemeVersionSummaryList"
        }
    }

    public struct ListThemesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "type", location: .querystring(locationName: "type"))
        ]

        /// The ID of the AWS account that contains the themes that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The type of themes that you want to list. Valid options include the following:    ALL (default)- Display all existing themes.    CUSTOM - Display only the themes created by people using Amazon QuickSight.    QUICKSIGHT - Display only the starting themes defined by QuickSight.
        public let type: ThemeType?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, type: ThemeType? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the themes in the list.
        public let themeSummaryList: [ThemeSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeSummaryList: [ThemeSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeSummaryList = themeSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case themeSummaryList = "ThemeSummaryList"
        }
    }

    public struct ListUserGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token")),
            AWSMemberEncoding(label: "userName", location: .uri(locationName: "UserName"))
        ]

        /// The AWS account ID that the user is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon QuickSight user name that you want to list group memberships for.
        public let userName: String

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "[\\u0020-\\u00FF]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserGroupsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of groups the user is a member of.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The ID for the AWS account that the user is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The list of users.
        public let userList: [User]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, userList: [User]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.userList = userList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case userList = "UserList"
        }
    }

    public struct LogicalTable: AWSEncodableShape & AWSDecodableShape {
        /// A display name for the logical table.
        public let alias: String
        /// Transform operations that act on this logical table.
        public let dataTransforms: [TransformOperation]?
        /// Source of this logical table.
        public let source: LogicalTableSource

        public init(alias: String, dataTransforms: [TransformOperation]? = nil, source: LogicalTableSource) {
            self.alias = alias
            self.dataTransforms = dataTransforms
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 64)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.dataTransforms?.forEach {
                try $0.validate(name: "\(name).dataTransforms[]")
            }
            try self.validate(self.dataTransforms, name: "dataTransforms", parent: name, max: 2048)
            try self.validate(self.dataTransforms, name: "dataTransforms", parent: name, min: 1)
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case dataTransforms = "DataTransforms"
            case source = "Source"
        }
    }

    public struct LogicalTableSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the result of a join of two logical tables.
        public let joinInstruction: JoinInstruction?
        /// Physical table ID.
        public let physicalTableId: String?

        public init(joinInstruction: JoinInstruction? = nil, physicalTableId: String? = nil) {
            self.joinInstruction = joinInstruction
            self.physicalTableId = physicalTableId
        }

        public func validate(name: String) throws {
            try self.joinInstruction?.validate(name: "\(name).joinInstruction")
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, max: 64)
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, min: 1)
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, pattern: "[0-9a-zA-Z-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case joinInstruction = "JoinInstruction"
            case physicalTableId = "PhysicalTableId"
        }
    }

    public struct ManifestFileLocation: AWSEncodableShape & AWSDecodableShape {
        /// Amazon S3 bucket.
        public let bucket: String
        /// Amazon S3 key that identifies an object.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 1024)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct MarginStyle: AWSEncodableShape & AWSDecodableShape {
        /// This Boolean value controls whether to display sheet margins.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct MariaDbParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct MemberIdArnPair: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the member.
        public let memberArn: String?
        /// The ID of the member.
        public let memberId: String?

        public init(memberArn: String? = nil, memberId: String? = nil) {
            self.memberArn = memberArn
            self.memberId = memberId
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
            case memberId = "MemberId"
        }
    }

    public struct MySqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct NamespaceError: AWSDecodableShape {
        /// The message for the error.
        public let message: String?
        /// The error type.
        public let type: NamespaceErrorType?

        public init(message: String? = nil, type: NamespaceErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct NamespaceInfoV2: AWSDecodableShape {
        /// The namespace ARN.
        public let arn: String?
        /// The namespace AWS Region.
        public let capacityRegion: String?
        /// The creation status of a namespace that is not yet completely created.
        public let creationStatus: NamespaceStatus?
        /// The identity store used for the namespace.
        public let identityStore: IdentityStore?
        /// The name of the error.
        public let name: String?
        /// An error that occurred when the namespace was created.
        public let namespaceError: NamespaceError?

        public init(arn: String? = nil, capacityRegion: String? = nil, creationStatus: NamespaceStatus? = nil, identityStore: IdentityStore? = nil, name: String? = nil, namespaceError: NamespaceError? = nil) {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.namespaceError = namespaceError
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacityRegion = "CapacityRegion"
            case creationStatus = "CreationStatus"
            case identityStore = "IdentityStore"
            case name = "Name"
            case namespaceError = "NamespaceError"
        }
    }

    public struct OracleParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// An Oracle host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct OutputColumn: AWSDecodableShape {
        /// A description for a column.
        public let description: String?
        /// A display name for the dataset.
        public let name: String?
        /// Type.
        public let type: ColumnDataType?

        public init(description: String? = nil, name: String? = nil, type: ColumnDataType? = nil) {
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct Parameters: AWSEncodableShape {
        /// Date-time parameters.
        public let dateTimeParameters: [DateTimeParameter]?
        /// Decimal parameters.
        public let decimalParameters: [DecimalParameter]?
        /// Integer parameters.
        public let integerParameters: [IntegerParameter]?
        /// String parameters.
        public let stringParameters: [StringParameter]?

        public init(dateTimeParameters: [DateTimeParameter]? = nil, decimalParameters: [DecimalParameter]? = nil, integerParameters: [IntegerParameter]? = nil, stringParameters: [StringParameter]? = nil) {
            self.dateTimeParameters = dateTimeParameters
            self.decimalParameters = decimalParameters
            self.integerParameters = integerParameters
            self.stringParameters = stringParameters
        }

        public func validate(name: String) throws {
            try self.dateTimeParameters?.forEach {
                try $0.validate(name: "\(name).dateTimeParameters[]")
            }
            try self.validate(self.dateTimeParameters, name: "dateTimeParameters", parent: name, max: 100)
            try self.decimalParameters?.forEach {
                try $0.validate(name: "\(name).decimalParameters[]")
            }
            try self.validate(self.decimalParameters, name: "decimalParameters", parent: name, max: 100)
            try self.integerParameters?.forEach {
                try $0.validate(name: "\(name).integerParameters[]")
            }
            try self.validate(self.integerParameters, name: "integerParameters", parent: name, max: 100)
            try self.stringParameters?.forEach {
                try $0.validate(name: "\(name).stringParameters[]")
            }
            try self.validate(self.stringParameters, name: "stringParameters", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeParameters = "DateTimeParameters"
            case decimalParameters = "DecimalParameters"
            case integerParameters = "IntegerParameters"
            case stringParameters = "StringParameters"
        }
    }

    public struct PhysicalTable: AWSEncodableShape & AWSDecodableShape {
        /// A physical table type built from the results of the custom SQL query.
        public let customSql: CustomSql?
        /// A physical table type for relational data sources.
        public let relationalTable: RelationalTable?
        /// A physical table type for as S3 data source.
        public let s3Source: S3Source?

        public init(customSql: CustomSql? = nil, relationalTable: RelationalTable? = nil, s3Source: S3Source? = nil) {
            self.customSql = customSql
            self.relationalTable = relationalTable
            self.s3Source = s3Source
        }

        public func validate(name: String) throws {
            try self.customSql?.validate(name: "\(name).customSql")
            try self.relationalTable?.validate(name: "\(name).relationalTable")
            try self.s3Source?.validate(name: "\(name).s3Source")
        }

        private enum CodingKeys: String, CodingKey {
            case customSql = "CustomSql"
            case relationalTable = "RelationalTable"
            case s3Source = "S3Source"
        }
    }

    public struct PostgreSqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct PrestoParameters: AWSEncodableShape & AWSDecodableShape {
        /// Catalog.
        public let catalog: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(catalog: String, host: String, port: Int) {
            self.catalog = catalog
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 128)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct ProjectOperation: AWSEncodableShape & AWSDecodableShape {
        /// Projected columns.
        public let projectedColumns: [String]

        public init(projectedColumns: [String]) {
            self.projectedColumns = projectedColumns
        }

        public func validate(name: String) throws {
            try self.validate(self.projectedColumns, name: "projectedColumns", parent: name, max: 2000)
            try self.validate(self.projectedColumns, name: "projectedColumns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case projectedColumns = "ProjectedColumns"
        }
    }

    public struct QueueInfo: AWSDecodableShape {
        /// The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.
        public let queuedIngestion: String
        /// The ID of the queued ingestion.
        public let waitingOnIngestion: String

        public init(queuedIngestion: String, waitingOnIngestion: String) {
            self.queuedIngestion = queuedIngestion
            self.waitingOnIngestion = waitingOnIngestion
        }

        private enum CodingKeys: String, CodingKey {
            case queuedIngestion = "QueuedIngestion"
            case waitingOnIngestion = "WaitingOnIngestion"
        }
    }

    public struct RdsParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Instance ID.
        public let instanceId: String

        public init(database: String, instanceId: String) {
            self.database = database
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 64)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case instanceId = "InstanceId"
        }
    }

    public struct RedshiftParameters: AWSEncodableShape & AWSDecodableShape {
        /// Cluster ID. This field can be blank if the Host and Port are provided.
        public let clusterId: String?
        /// Database.
        public let database: String
        /// Host. This field can be blank if ClusterId is provided.
        public let host: String?
        /// Port. This field can be blank if the ClusterId is provided.
        public let port: Int?

        public init(clusterId: String? = nil, database: String, host: String? = nil, port: Int? = nil) {
            self.clusterId = clusterId
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 64)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 1)
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct RegisterUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that the user is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into QuickSight with an associated AWS Identity and Access Management (IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
        public let customFederationProviderUrl: String?
        /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:   Create and update data sources   Create and update datasets   Create and update email reports   Subscribe to email reports   To add custom permissions to an existing user, use  UpdateUser  instead. A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a QuickSight user.  QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning QuickSight users to one of the default security cohorts in QuickSight (admin, author, reader). This feature is available only to QuickSight Enterprise edition subscriptions that use SAML 2.0-Based Federation for Single Sign-On (SSO).
        public let customPermissionsName: String?
        /// The email address of the user that you want to register.
        public let email: String
        /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated AWS Identity and Access Management (IAM) role. The type of supported external login provider can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
        public let externalLoginFederationProviderType: String?
        /// The identity ID for a user in the external login provider.
        public let externalLoginId: String?
        /// The ARN of the IAM user or role that you are registering with Amazon QuickSight.
        public let iamArn: String?
        /// Amazon QuickSight supports several ways of managing the identity of users. This parameter accepts two values:    IAM: A user whose identity maps to an existing IAM user or role.     QUICKSIGHT: A user whose identity is owned and managed internally by Amazon QuickSight.
        public let identityType: IdentityType
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// You need to use this parameter only when you register one or more users using an assumed IAM role. You don't need to provide the session name for other scenarios, for example when you are registering an IAM user or an Amazon QuickSight user. You can register multiple users using the same IAM role if each user has a different session name. For more information on assuming IAM roles, see  assume-role  in the AWS CLI Reference.
        public let sessionName: String?
        /// The Amazon QuickSight user name that you want to create for the user you are registering.
        public let userName: String?
        /// The Amazon QuickSight role for the user. The user role can be one of the following:    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.    ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.    RESTRICTED_READER: This role isn't currently available for use.    RESTRICTED_AUTHOR: This role isn't currently available for use.
        public let userRole: UserRole

        public init(awsAccountId: String, customFederationProviderUrl: String? = nil, customPermissionsName: String? = nil, email: String, externalLoginFederationProviderType: String? = nil, externalLoginId: String? = nil, iamArn: String? = nil, identityType: IdentityType, namespace: String, sessionName: String? = nil, userName: String? = nil, userRole: UserRole) {
            self.awsAccountId = awsAccountId
            self.customFederationProviderUrl = customFederationProviderUrl
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginId = externalLoginId
            self.iamArn = iamArn
            self.identityType = identityType
            self.namespace = namespace
            self.sessionName = sessionName
            self.userName = userName
            self.userRole = userRole
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, max: 64)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, min: 1)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, pattern: "^[a-zA-Z0-9+=,.@_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionName, name: "sessionName", parent: name, max: 64)
            try self.validate(self.sessionName, name: "sessionName", parent: name, min: 2)
            try self.validate(self.sessionName, name: "sessionName", parent: name, pattern: "[\\w+=.@-]*")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "[\\u0020-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case customFederationProviderUrl = "CustomFederationProviderUrl"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginId = "ExternalLoginId"
            case iamArn = "IamArn"
            case identityType = "IdentityType"
            case sessionName = "SessionName"
            case userName = "UserName"
            case userRole = "UserRole"
        }
    }

    public struct RegisterUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The user's user name.
        public let user: User?
        /// The URL the user visits to complete registration and provide a password. This is returned only for users with an identity type of QUICKSIGHT.
        public let userInvitationUrl: String?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil, userInvitationUrl: String? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
            self.userInvitationUrl = userInvitationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case user = "User"
            case userInvitationUrl = "UserInvitationUrl"
        }
    }

    public struct RelationalTable: AWSEncodableShape & AWSDecodableShape {
        /// The catalog associated with a table.
        public let catalog: String?
        /// The Amazon Resource Name (ARN) for the data source.
        public let dataSourceArn: String
        /// The column schema of the table.
        public let inputColumns: [InputColumn]
        /// The name of the relational table.
        public let name: String
        /// The schema name. This name applies to certain relational database engines.
        public let schema: String?

        public init(catalog: String? = nil, dataSourceArn: String, inputColumns: [InputColumn], name: String, schema: String? = nil) {
            self.catalog = catalog
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.name = name
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 256)
            try self.inputColumns.forEach {
                try $0.validate(name: "\(name).inputColumns[]")
            }
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, max: 2048)
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.schema, name: "schema", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case dataSourceArn = "DataSourceArn"
            case inputColumns = "InputColumns"
            case name = "Name"
            case schema = "Schema"
        }
    }

    public struct RenameColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column to be renamed.
        public let columnName: String
        /// The new name for the column.
        public let newColumnName: String

        public init(columnName: String, newColumnName: String) {
            self.columnName = columnName
            self.newColumnName = newColumnName
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.newColumnName, name: "newColumnName", parent: name, max: 128)
            try self.validate(self.newColumnName, name: "newColumnName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case newColumnName = "NewColumnName"
        }
    }

    public struct ResourcePermission: AWSEncodableShape & AWSDecodableShape {
        /// The IAM action to grant or revoke permissions on.
        public let actions: [String]
        /// The Amazon Resource Name (ARN) of the principal. This can be one of the following:   The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)   The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)   The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across AWS accounts. (This is less common.)
        public let principal: String

        public init(actions: [String], principal: String) {
            self.actions = actions
            self.principal = principal
        }

        public func validate(name: String) throws {
            try self.validate(self.actions, name: "actions", parent: name, max: 16)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.principal, name: "principal", parent: name, max: 256)
            try self.validate(self.principal, name: "principal", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case principal = "Principal"
        }
    }

    public struct RestoreAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID of the analysis that you're restoring.
        public let analysisId: String
        /// The ID of the AWS account that contains the analysis.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 2048)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RestoreAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the analysis that you're restoring.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the analysis that you're restoring.
        public let arn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct RowInfo: AWSDecodableShape {
        /// The number of rows that were not ingested.
        public let rowsDropped: Int64?
        /// The number of rows that were ingested.
        public let rowsIngested: Int64?

        public init(rowsDropped: Int64? = nil, rowsIngested: Int64? = nil) {
            self.rowsDropped = rowsDropped
            self.rowsIngested = rowsIngested
        }

        private enum CodingKeys: String, CodingKey {
            case rowsDropped = "RowsDropped"
            case rowsIngested = "RowsIngested"
        }
    }

    public struct RowLevelPermissionDataSet: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.
        public let arn: String
        /// The user or group rules associated with the dataset that contains permissions for RLS. By default, FormatVersion is VERSION_1. When FormatVersion is VERSION_1, UserName and GroupName are required. When FormatVersion is VERSION_2, UserARN and GroupARN are required, and Namespace must not exist.
        public let formatVersion: RowLevelPermissionFormatVersion?
        /// The namespace associated with the dataset that contains permissions for RLS.
        public let namespace: String?
        /// The type of permissions to use when interpretting the permissions for RLS. DENY_ACCESS is included for backward compatibility only.
        public let permissionPolicy: RowLevelPermissionPolicy

        public init(arn: String, formatVersion: RowLevelPermissionFormatVersion? = nil, namespace: String? = nil, permissionPolicy: RowLevelPermissionPolicy) {
            self.arn = arn
            self.formatVersion = formatVersion
            self.namespace = namespace
            self.permissionPolicy = permissionPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case formatVersion = "FormatVersion"
            case namespace = "Namespace"
            case permissionPolicy = "PermissionPolicy"
        }
    }

    public struct S3Parameters: AWSEncodableShape & AWSDecodableShape {
        /// Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded in the console.
        public let manifestFileLocation: ManifestFileLocation

        public init(manifestFileLocation: ManifestFileLocation) {
            self.manifestFileLocation = manifestFileLocation
        }

        public func validate(name: String) throws {
            try self.manifestFileLocation.validate(name: "\(name).manifestFileLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case manifestFileLocation = "ManifestFileLocation"
        }
    }

    public struct S3Source: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the data source.
        public let dataSourceArn: String
        /// A physical table type for an S3 data source.  For non-JSON files, only STRING data types are supported in input columns.
        public let inputColumns: [InputColumn]
        /// Information about the format for the S3 source file or files.
        public let uploadSettings: UploadSettings?

        public init(dataSourceArn: String, inputColumns: [InputColumn], uploadSettings: UploadSettings? = nil) {
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.uploadSettings = uploadSettings
        }

        public func validate(name: String) throws {
            try self.inputColumns.forEach {
                try $0.validate(name: "\(name).inputColumns[]")
            }
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, max: 2048)
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, min: 1)
            try self.uploadSettings?.validate(name: "\(name).uploadSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case inputColumns = "InputColumns"
            case uploadSettings = "UploadSettings"
        }
    }

    public struct SearchAnalysesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID of the AWS account that contains the analyses that you're searching for.
        public let awsAccountId: String
        /// The structure for the search filters that you want to apply to your search.
        public let filters: [AnalysisSearchFilter]
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [AnalysisSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchAnalysesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Metadata describing the analyses that you searched for.
        public let analysisSummaryList: [AnalysisSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisSummaryList: [AnalysisSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisSummaryList = analysisSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSummaryList = "AnalysisSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SearchDashboardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID of the AWS account that contains the user whose dashboards you're searching for.
        public let awsAccountId: String
        /// The filters to apply to the search. Currently, you can search only by user name, for example, "Filters": [ { "Name": "QUICKSIGHT_USER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]
        public let filters: [DashboardSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [DashboardSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchDashboardsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of dashboards owned by the user specified in Filters in your request.
        public let dashboardSummaryList: [DashboardSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardSummaryList: [DashboardSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardSummaryList = dashboardSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaryList = "DashboardSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SearchFoldersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The filters to apply to the search. Currently, you can search only by the parent folder ARN. For example, "Filters": [ { "Name": "PARENT_FOLDER_ARN", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId" } ].
        public let filters: [FolderSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [FolderSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchFoldersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the folders in your AWS account. This structure provides basic information about the folders.
        public let folderSummaryList: [FolderSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK.
        public let status: Int?

        public init(folderSummaryList: [FolderSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderSummaryList = folderSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderSummaryList = "FolderSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ServiceNowParameters: AWSEncodableShape & AWSDecodableShape {
        /// URL of the base site.
        public let siteBaseUrl: String

        public init(siteBaseUrl: String) {
            self.siteBaseUrl = siteBaseUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, max: 1024)
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case siteBaseUrl = "SiteBaseUrl"
        }
    }

    public struct Sheet: AWSDecodableShape {
        /// The name of a sheet. This name is displayed on the sheet's tab in the QuickSight console.
        public let name: String?
        /// The unique identifier associated with a sheet.
        public let sheetId: String?

        public init(name: String? = nil, sheetId: String? = nil) {
            self.name = name
            self.sheetId = sheetId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case sheetId = "SheetId"
        }
    }

    public struct SheetControlsOption: AWSEncodableShape {
        /// Visibility state.
        public let visibilityState: DashboardUIState?

        public init(visibilityState: DashboardUIState? = nil) {
            self.visibilityState = visibilityState
        }

        private enum CodingKeys: String, CodingKey {
            case visibilityState = "VisibilityState"
        }
    }

    public struct SheetStyle: AWSEncodableShape & AWSDecodableShape {
        /// The display options for tiles.
        public let tile: TileStyle?
        /// The layout options for tiles.
        public let tileLayout: TileLayoutStyle?

        public init(tile: TileStyle? = nil, tileLayout: TileLayoutStyle? = nil) {
            self.tile = tile
            self.tileLayout = tileLayout
        }

        private enum CodingKeys: String, CodingKey {
            case tile = "Tile"
            case tileLayout = "TileLayout"
        }
    }

    public struct SnowflakeParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Warehouse.
        public let warehouse: String

        public init(database: String, host: String, warehouse: String) {
            self.database = database
            self.host = host
            self.warehouse = warehouse
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.warehouse, name: "warehouse", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case warehouse = "Warehouse"
        }
    }

    public struct SparkParameters: AWSEncodableShape & AWSDecodableShape {
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(host: String, port: Int) {
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case port = "Port"
        }
    }

    public struct SqlServerParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct SslProperties: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean option to control whether SSL should be disabled.
        public let disableSsl: Bool?

        public init(disableSsl: Bool? = nil) {
            self.disableSsl = disableSsl
        }

        private enum CodingKeys: String, CodingKey {
            case disableSsl = "DisableSsl"
        }
    }

    public struct StringParameter: AWSEncodableShape {
        /// A display name for a string parameter.
        public let name: String
        /// The values of a string parameter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Tag key.
        public let key: String
        /// Tag value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The column that this operation acts on.
        public let columnName: String
        /// The dataset column tag, currently only used for geospatial type tagging. .  This is not tags for the AWS tagging feature. .
        public let tags: [ColumnTag]

        public init(columnName: String, tags: [ColumnTag]) {
            self.columnName = columnName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 16)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case tags = "Tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct Template: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the template.
        public let arn: String?
        /// Time when this was created.
        public let createdTime: Date?
        /// Time when this was last updated.
        public let lastUpdatedTime: Date?
        /// The display name of the template.
        public let name: String?
        /// The ID for the template. This is unique per AWS Region for each AWS account.
        public let templateId: String?
        /// A structure describing the versions of the template.
        public let version: TemplateVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, templateId: String? = nil, version: TemplateVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.templateId = templateId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case templateId = "TemplateId"
            case version = "Version"
        }
    }

    public struct TemplateAlias: AWSDecodableShape {
        /// The display name of the template alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the template alias.
        public let arn: String?
        /// The version number of the template alias.
        public let templateVersionNumber: Int64?

        public init(aliasName: String? = nil, arn: String? = nil, templateVersionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.templateVersionNumber = templateVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct TemplateError: AWSDecodableShape {
        /// Description of the error type.
        public let message: String?
        /// Type of error.
        public let type: TemplateErrorType?

        public init(message: String? = nil, type: TemplateErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct TemplateSourceAnalysis: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// A structure containing information about the dataset references used as placeholders in the template.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct TemplateSourceEntity: AWSEncodableShape {
        /// The source analysis, if it is based on an analysis.
        public let sourceAnalysis: TemplateSourceAnalysis?
        /// The source template, if it is based on an template.
        public let sourceTemplate: TemplateSourceTemplate?

        public init(sourceAnalysis: TemplateSourceAnalysis? = nil, sourceTemplate: TemplateSourceTemplate? = nil) {
            self.sourceAnalysis = sourceAnalysis
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceAnalysis?.validate(name: "\(name).sourceAnalysis")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAnalysis = "SourceAnalysis"
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct TemplateSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct TemplateSummary: AWSDecodableShape {
        /// A summary of a template.
        public let arn: String?
        /// The last time that this template was created.
        public let createdTime: Date?
        /// The last time that this template was updated.
        public let lastUpdatedTime: Date?
        /// A structure containing a list of version numbers for the template summary.
        public let latestVersionNumber: Int64?
        /// A display name for the template.
        public let name: String?
        /// The ID of the template. This ID is unique per AWS Region for each AWS account.
        public let templateId: String?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, latestVersionNumber: Int64? = nil, name: String? = nil, templateId: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case latestVersionNumber = "LatestVersionNumber"
            case name = "Name"
            case templateId = "TemplateId"
        }
    }

    public struct TemplateVersion: AWSDecodableShape {
        /// The time that this template version was created.
        public let createdTime: Date?
        /// Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.
        public let dataSetConfigurations: [DataSetConfiguration]?
        /// The description of the template.
        public let description: String?
        /// Errors associated with this template version.
        public let errors: [TemplateError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The ARN of the theme associated with this version of the template.
        public let themeArn: String?
        /// The version number of the template version.
        public let versionNumber: Int64?

        public init(createdTime: Date? = nil, dataSetConfigurations: [DataSetConfiguration]? = nil, description: String? = nil, errors: [TemplateError]? = nil, sheets: [Sheet]? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, themeArn: String? = nil, versionNumber: Int64? = nil) {
            self.createdTime = createdTime
            self.dataSetConfigurations = dataSetConfigurations
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case dataSetConfigurations = "DataSetConfigurations"
            case description = "Description"
            case errors = "Errors"
            case sheets = "Sheets"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case themeArn = "ThemeArn"
            case versionNumber = "VersionNumber"
        }
    }

    public struct TemplateVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the template version.
        public let arn: String?
        /// The time that this template version was created.
        public let createdTime: Date?
        /// The description of the template version.
        public let description: String?
        /// The status of the template version.
        public let status: ResourceStatus?
        /// The version number of the template version.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct TeradataParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct Theme: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the theme.
        public let arn: String?
        /// The date and time that the theme was created.
        public let createdTime: Date?
        /// The date and time that the theme was last updated.
        public let lastUpdatedTime: Date?
        /// The name that the user gives to the theme.
        public let name: String?
        /// The identifier that the user gives to the theme.
        public let themeId: String?
        /// The type of theme, based on how it was created. Valid values include: QUICKSIGHT and CUSTOM.
        public let type: ThemeType?
        public let version: ThemeVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, themeId: String? = nil, type: ThemeType? = nil, version: ThemeVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.themeId = themeId
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case themeId = "ThemeId"
            case type = "Type"
            case version = "Version"
        }
    }

    public struct ThemeAlias: AWSDecodableShape {
        /// The display name of the theme alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the theme alias.
        public let arn: String?
        /// The version number of the theme alias.
        public let themeVersionNumber: Int64?

        public init(aliasName: String? = nil, arn: String? = nil, themeVersionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.themeVersionNumber = themeVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct ThemeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Color properties that apply to chart data colors.
        public let dataColorPalette: DataColorPalette?
        /// Display options related to sheets.
        public let sheet: SheetStyle?
        /// Color properties that apply to the UI and to charts, excluding the colors that apply to data.
        public let uIColorPalette: UIColorPalette?

        public init(dataColorPalette: DataColorPalette? = nil, sheet: SheetStyle? = nil, uIColorPalette: UIColorPalette? = nil) {
            self.dataColorPalette = dataColorPalette
            self.sheet = sheet
            self.uIColorPalette = uIColorPalette
        }

        public func validate(name: String) throws {
            try self.dataColorPalette?.validate(name: "\(name).dataColorPalette")
            try self.uIColorPalette?.validate(name: "\(name).uIColorPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case dataColorPalette = "DataColorPalette"
            case sheet = "Sheet"
            case uIColorPalette = "UIColorPalette"
        }
    }

    public struct ThemeError: AWSDecodableShape {
        /// The error message.
        public let message: String?
        /// The type of error.
        public let type: ThemeErrorType?

        public init(message: String? = nil, type: ThemeErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ThemeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The date and time that this theme was created.
        public let createdTime: Date?
        /// The last date and time that this theme was updated.
        public let lastUpdatedTime: Date?
        /// The latest version number for the theme.
        public let latestVersionNumber: Int64?
        /// the display name for the theme.
        public let name: String?
        /// The ID of the theme. This ID is unique per AWS Region for each AWS account.
        public let themeId: String?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, latestVersionNumber: Int64? = nil, name: String? = nil, themeId: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case latestVersionNumber = "LatestVersionNumber"
            case name = "Name"
            case themeId = "ThemeId"
        }
    }

    public struct ThemeVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default QuickSight theme.
        public let baseThemeId: String?
        /// The theme configuration, which contains all the theme display properties.
        public let configuration: ThemeConfiguration?
        /// The date and time that this theme version was created.
        public let createdTime: Date?
        /// The description of the theme.
        public let description: String?
        /// Errors associated with the theme.
        public let errors: [ThemeError]?
        /// The status of the theme version.
        public let status: ResourceStatus?
        /// The version number of the theme.
        public let versionNumber: Int64?

        public init(arn: String? = nil, baseThemeId: String? = nil, configuration: ThemeConfiguration? = nil, createdTime: Date? = nil, description: String? = nil, errors: [ThemeError]? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.createdTime = createdTime
            self.description = description
            self.errors = errors
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case createdTime = "CreatedTime"
            case description = "Description"
            case errors = "Errors"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ThemeVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the theme version.
        public let arn: String?
        /// The date and time that this theme version was created.
        public let createdTime: Date?
        /// The description of the theme version.
        public let description: String?
        /// The status of the theme version.
        public let status: ResourceStatus?
        /// The version number of the theme version.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct TileLayoutStyle: AWSEncodableShape & AWSDecodableShape {
        /// The gutter settings that apply between tiles.
        public let gutter: GutterStyle?
        /// The margin settings that apply around the outside edge of sheets.
        public let margin: MarginStyle?

        public init(gutter: GutterStyle? = nil, margin: MarginStyle? = nil) {
            self.gutter = gutter
            self.margin = margin
        }

        private enum CodingKeys: String, CodingKey {
            case gutter = "Gutter"
            case margin = "Margin"
        }
    }

    public struct TileStyle: AWSEncodableShape & AWSDecodableShape {
        /// The border around a tile.
        public let border: BorderStyle?

        public init(border: BorderStyle? = nil) {
            self.border = border
        }

        private enum CodingKeys: String, CodingKey {
            case border = "Border"
        }
    }

    public struct TransformOperation: AWSEncodableShape & AWSDecodableShape {
        /// A transform operation that casts a column to a different type.
        public let castColumnTypeOperation: CastColumnTypeOperation?
        /// An operation that creates calculated columns. Columns created in one such operation form a lexical closure.
        public let createColumnsOperation: CreateColumnsOperation?
        /// An operation that filters rows based on some condition.
        public let filterOperation: FilterOperation?
        /// An operation that projects columns. Operations that come after a projection can only refer to projected columns.
        public let projectOperation: ProjectOperation?
        /// An operation that renames a column.
        public let renameColumnOperation: RenameColumnOperation?
        /// An operation that tags a column with additional information.
        public let tagColumnOperation: TagColumnOperation?

        public init(castColumnTypeOperation: CastColumnTypeOperation? = nil, createColumnsOperation: CreateColumnsOperation? = nil, filterOperation: FilterOperation? = nil, projectOperation: ProjectOperation? = nil, renameColumnOperation: RenameColumnOperation? = nil, tagColumnOperation: TagColumnOperation? = nil) {
            self.castColumnTypeOperation = castColumnTypeOperation
            self.createColumnsOperation = createColumnsOperation
            self.filterOperation = filterOperation
            self.projectOperation = projectOperation
            self.renameColumnOperation = renameColumnOperation
            self.tagColumnOperation = tagColumnOperation
        }

        public func validate(name: String) throws {
            try self.castColumnTypeOperation?.validate(name: "\(name).castColumnTypeOperation")
            try self.createColumnsOperation?.validate(name: "\(name).createColumnsOperation")
            try self.filterOperation?.validate(name: "\(name).filterOperation")
            try self.projectOperation?.validate(name: "\(name).projectOperation")
            try self.renameColumnOperation?.validate(name: "\(name).renameColumnOperation")
            try self.tagColumnOperation?.validate(name: "\(name).tagColumnOperation")
        }

        private enum CodingKeys: String, CodingKey {
            case castColumnTypeOperation = "CastColumnTypeOperation"
            case createColumnsOperation = "CreateColumnsOperation"
            case filterOperation = "FilterOperation"
            case projectOperation = "ProjectOperation"
            case renameColumnOperation = "RenameColumnOperation"
            case tagColumnOperation = "TagColumnOperation"
        }
    }

    public struct TwitterParameters: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of rows to query Twitter.
        public let maxRows: Int
        /// Twitter query string.
        public let query: String

        public init(maxRows: Int, query: String) {
            self.maxRows = maxRows
            self.query = query
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRows, name: "maxRows", parent: name, min: 1)
            try self.validate(self.query, name: "query", parent: name, max: 256)
            try self.validate(self.query, name: "query", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRows = "MaxRows"
            case query = "Query"
        }
    }

    public struct UIColorPalette: AWSEncodableShape & AWSDecodableShape {
        /// This color is that applies to selected states and buttons.
        public let accent: String?
        /// The foreground color that applies to any text or other elements that appear over the accent color.
        public let accentForeground: String?
        /// The color that applies to error messages.
        public let danger: String?
        /// The foreground color that applies to any text or other elements that appear over the error color.
        public let dangerForeground: String?
        /// The color that applies to the names of fields that are identified as dimensions.
        public let dimension: String?
        /// The foreground color that applies to any text or other elements that appear over the dimension color.
        public let dimensionForeground: String?
        /// The color that applies to the names of fields that are identified as measures.
        public let measure: String?
        /// The foreground color that applies to any text or other elements that appear over the measure color.
        public let measureForeground: String?
        /// The background color that applies to visuals and other high emphasis UI.
        public let primaryBackground: String?
        /// The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        public let primaryForeground: String?
        /// The background color that applies to the sheet background and sheet controls.
        public let secondaryBackground: String?
        /// The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        public let secondaryForeground: String?
        /// The color that applies to success messages, for example the check mark for a successful download.
        public let success: String?
        /// The foreground color that applies to any text or other elements that appear over the success color.
        public let successForeground: String?
        /// This color that applies to warning and informational messages.
        public let warning: String?
        /// The foreground color that applies to any text or other elements that appear over the warning color.
        public let warningForeground: String?

        public init(accent: String? = nil, accentForeground: String? = nil, danger: String? = nil, dangerForeground: String? = nil, dimension: String? = nil, dimensionForeground: String? = nil, measure: String? = nil, measureForeground: String? = nil, primaryBackground: String? = nil, primaryForeground: String? = nil, secondaryBackground: String? = nil, secondaryForeground: String? = nil, success: String? = nil, successForeground: String? = nil, warning: String? = nil, warningForeground: String? = nil) {
            self.accent = accent
            self.accentForeground = accentForeground
            self.danger = danger
            self.dangerForeground = dangerForeground
            self.dimension = dimension
            self.dimensionForeground = dimensionForeground
            self.measure = measure
            self.measureForeground = measureForeground
            self.primaryBackground = primaryBackground
            self.primaryForeground = primaryForeground
            self.secondaryBackground = secondaryBackground
            self.secondaryForeground = secondaryForeground
            self.success = success
            self.successForeground = successForeground
            self.warning = warning
            self.warningForeground = warningForeground
        }

        public func validate(name: String) throws {
            try self.validate(self.accent, name: "accent", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.accentForeground, name: "accentForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.danger, name: "danger", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dangerForeground, name: "dangerForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dimension, name: "dimension", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dimensionForeground, name: "dimensionForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.measure, name: "measure", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.measureForeground, name: "measureForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.primaryBackground, name: "primaryBackground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.primaryForeground, name: "primaryForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.secondaryBackground, name: "secondaryBackground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.secondaryForeground, name: "secondaryForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.success, name: "success", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.successForeground, name: "successForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.warning, name: "warning", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.warningForeground, name: "warningForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accent = "Accent"
            case accentForeground = "AccentForeground"
            case danger = "Danger"
            case dangerForeground = "DangerForeground"
            case dimension = "Dimension"
            case dimensionForeground = "DimensionForeground"
            case measure = "Measure"
            case measureForeground = "MeasureForeground"
            case primaryBackground = "PrimaryBackground"
            case primaryForeground = "PrimaryForeground"
            case secondaryBackground = "SecondaryBackground"
            case secondaryForeground = "SecondaryForeground"
            case success = "Success"
            case successForeground = "SuccessForeground"
            case warning = "Warning"
            case warningForeground = "WarningForeground"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "keys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The keys of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring(locationName: "namespace"))
        ]

        /// The QuickSight customizations you're updating in the current AWS Region.
        public let accountCustomization: AccountCustomization
        /// The ID for the AWS account that you want to update QuickSight customizations for.
        public let awsAccountId: String
        /// The namespace that you want to update QuickSight customizations for.
        public let namespace: String?

        public init(accountCustomization: AccountCustomization, awsAccountId: String, namespace: String? = nil) {
            self.accountCustomization = accountCustomization
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
        }
    }

    public struct UpdateAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The QuickSight customizations you're updating in the current AWS Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) for the updated customization for this AWS account.
        public let arn: String?
        /// The ID for the AWS account that you want to update QuickSight customizations for.
        public let awsAccountId: String?
        /// The namespace associated with the customization that you're updating.
        public let namespace: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAccountSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID for the AWS account that contains the QuickSight settings that you want to list.
        public let awsAccountId: String
        /// The default namespace for this AWS account. Currently, the default is default. AWS Identity and Access Management (IAM) users that register for the first time with QuickSight provide an email that becomes associated with the default namespace.
        public let defaultNamespace: String
        /// The email address that you want QuickSight to send notifications to regarding your AWS account or QuickSight subscription.
        public let notificationEmail: String?

        public init(awsAccountId: String, defaultNamespace: String, notificationEmail: String? = nil) {
            self.awsAccountId = awsAccountId
            self.defaultNamespace = defaultNamespace
            self.notificationEmail = notificationEmail
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.defaultNamespace, name: "defaultNamespace", parent: name, max: 64)
            try self.validate(self.defaultNamespace, name: "defaultNamespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultNamespace = "DefaultNamespace"
            case notificationEmail = "NotificationEmail"
        }
    }

    public struct UpdateAccountSettingsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAnalysisPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID of the analysis whose permissions you're updating. The ID is part of the analysis URL.
        public let analysisId: String
        /// The ID of the AWS account that contains the analysis whose permissions you're updating. You must be using the AWS account that the analysis is in.
        public let awsAccountId: String
        /// A structure that describes the permissions to add and the principal to add them to.
        public let grantPermissions: [ResourcePermission]?
        /// A structure that describes the permissions to remove and the principal to remove them from.
        public let revokePermissions: [ResourcePermission]?

        public init(analysisId: String, awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 2048)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateAnalysisPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the analysis that you updated.
        public let analysisArn: String?
        /// The ID of the analysis that you updated permissions for.
        public let analysisId: String?
        /// A structure that describes the principals and the resource-level permissions on an analysis.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisArn: String? = nil, analysisId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisArn = analysisArn
            self.analysisId = analysisId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisArn = "AnalysisArn"
            case analysisId = "AnalysisId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri(locationName: "AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId"))
        ]

        /// The ID for the analysis that you're updating. This ID displays in the URL of the analysis.
        public let analysisId: String
        /// The ID of the AWS account that contains the analysis that you're updating.
        public let awsAccountId: String
        /// A descriptive name for the analysis that you're updating. This name displays for the analysis in the QuickSight console.
        public let name: String
        /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A source entity to use for the analysis that you're updating. This metadata structure contains details that describe a source template and one or more datasets.
        public let sourceEntity: AnalysisSourceEntity
        /// The Amazon Resource Name (ARN) for the theme to apply to the analysis that you're creating. To see the theme in the QuickSight console, make sure that you have access to it.
        public let themeArn: String?

        public init(analysisId: String, awsAccountId: String, name: String, parameters: Parameters? = nil, sourceEntity: AnalysisSourceEntity, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.name = name
            self.parameters = parameters
            self.sourceEntity = sourceEntity
            self.themeArn = themeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 2048)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.sourceEntity.validate(name: "\(name).sourceEntity")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parameters = "Parameters"
            case sourceEntity = "SourceEntity"
            case themeArn = "ThemeArn"
        }
    }

    public struct UpdateAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the analysis.
        public let analysisId: String?
        /// The ARN of the analysis that you're updating.
        public let arn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The update status of the last update that was made to the analysis.
        public let updateStatus: ResourceStatus?

        public init(analysisId: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, updateStatus: ResourceStatus? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct UpdateDashboardPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId"))
        ]

        /// The ID of the AWS account that contains the dashboard whose permissions you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The permissions that you want to grant on this resource.
        public let grantPermissions: [ResourcePermission]?
        /// The permissions that you want to revoke from this resource.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dashboardId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDashboardPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// Information about the permissions on the dashboard.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDashboardPublishedVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId")),
            AWSMemberEncoding(label: "versionNumber", location: .uri(locationName: "VersionNumber"))
        ]

        /// The ID of the AWS account that contains the dashboard that you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number of the dashboard.
        public let versionNumber: Int64

        public init(awsAccountId: String, dashboardId: String, versionNumber: Int64) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateDashboardPublishedVersionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "DashboardId"))
        ]

        /// The ID of the AWS account that contains the dashboard that you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// Options for publishing the dashboard when you create it:    AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.     AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.     VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
        public let dashboardPublishOptions: DashboardPublishOptions?
        /// The display name of the dashboard.
        public let name: String
        /// A structure that contains the parameters of the dashboard. These are parameter overrides for a dashboard. A dashboard can have any type of parameters, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// The entity that you are using as a source when you update the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only update a dashboard from a template, so you use a SourceTemplate entity. If you need to update a dashboard from an analysis, first convert the analysis to a template by using the CreateTemplate API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplate ARN can contain any AWS Account and any QuickSight-supported AWS Region.  Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: DashboardSourceEntity
        /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that was originally associated with the entity. The theme ARN must exist in the same AWS account where you create the dashboard.
        public let themeArn: String?
        /// A description for the first version of the dashboard being created.
        public let versionDescription: String?

        public init(awsAccountId: String, dashboardId: String, dashboardPublishOptions: DashboardPublishOptions? = nil, name: String, parameters: Parameters? = nil, sourceEntity: DashboardSourceEntity, themeArn: String? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.dashboardPublishOptions = dashboardPublishOptions
            self.name = name
            self.parameters = parameters
            self.sourceEntity = sourceEntity
            self.themeArn = themeArn
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 2048)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.sourceEntity.validate(name: "\(name).sourceEntity")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardPublishOptions = "DashboardPublishOptions"
            case name = "Name"
            case parameters = "Parameters"
            case sourceEntity = "SourceEntity"
            case themeArn = "ThemeArn"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The creation status of the request.
        public let creationStatus: ResourceStatus?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the dashboard, including the version number.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateDataSetPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID for the dataset whose permissions you want to update. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String
        /// The resource permissions that you want to grant to the dataset.
        public let grantPermissions: [ResourcePermission]?
        /// The resource permissions that you want to revoke from the dataset.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dataSetId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDataSetPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let dataSetArn: String?
        /// The ID for the dataset whose permissions you want to update. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetArn: String? = nil, dataSetId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetArn = dataSetArn
            self.dataSetId = dataSetId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetId = "DataSetId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri(locationName: "DataSetId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// Groupings of columns that work together in certain QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// The ID for the dataset that you want to update. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// Indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// The display name for the dataset.
        public let name: String
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]
        /// The row-level security configuration for the data you want to create.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?

        public init(awsAccountId: String, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, dataSetId: String, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode, logicalTableMap: [String: LogicalTable]? = nil, name: String, physicalTableMap: [String: PhysicalTable], rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil) {
            self.awsAccountId = awsAccountId
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.dataSetId = dataSetId
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.columnGroups?.forEach {
                try $0.validate(name: "\(name).columnGroups[]")
            }
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, max: 8)
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, min: 1)
            try self.columnLevelPermissionRules?.forEach {
                try $0.validate(name: "\(name).columnLevelPermissionRules[]")
            }
            try self.validate(self.columnLevelPermissionRules, name: "columnLevelPermissionRules", parent: name, min: 1)
            try self.fieldFolders?.forEach {
                try validate($0.key, name: "fieldFolders.key", parent: name, max: 1000)
                try validate($0.key, name: "fieldFolders.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).fieldFolders[\"\($0.key)\"]")
            }
            try self.logicalTableMap?.forEach {
                try validate($0.key, name: "logicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "logicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "logicalTableMap.key", parent: name, pattern: "[0-9a-zA-Z-]*")
                try $0.value.validate(name: "\(name).logicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.physicalTableMap.forEach {
                try validate($0.key, name: "physicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "physicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "physicalTableMap.key", parent: name, pattern: "[0-9a-zA-Z-]*")
                try $0.value.validate(name: "\(name).physicalTableMap[\"\($0.key)\"]")
            }
            try self.rowLevelPermissionDataSet?.validate(name: "\(name).rowLevelPermissionDataSet")
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        }
    }

    public struct UpdateDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per AWS Region for each AWS account.
        public let dataSetId: String?
        /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
        public let ingestionArn: String?
        /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
        public let ingestionId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, ingestionArn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.ingestionArn = ingestionArn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case ingestionArn = "IngestionArn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDataSourcePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri(locationName: "DataSourceId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String
        /// A list of resource permissions that you want to grant on the data source.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions that you want to revoke on the data source.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dataSourceId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDataSourcePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri(locationName: "DataSourceId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The credentials that QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
        public let credentials: DataSourceCredentials?
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String
        /// The parameters that QuickSight uses to connect to your underlying source.
        public let dataSourceParameters: DataSourceParameters?
        /// A display name for the data source.
        public let name: String
        /// Secure Socket Layer (SSL) properties that apply when QuickSight connects to your underlying source.
        public let sslProperties: SslProperties?
        /// Use this parameter only when you want QuickSight to use a VPC connection when connecting to your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(awsAccountId: String, credentials: DataSourceCredentials? = nil, dataSourceId: String, dataSourceParameters: DataSourceParameters? = nil, name: String, sslProperties: SslProperties? = nil, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.awsAccountId = awsAccountId
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.name = name
            self.sslProperties = sslProperties
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.credentials?.validate(name: "\(name).credentials")
            try self.dataSourceParameters?.validate(name: "\(name).dataSourceParameters")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case dataSourceParameters = "DataSourceParameters"
            case name = "Name"
            case sslProperties = "SslProperties"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The ID of the data source. This ID is unique per AWS Region for each AWS account.
        public let dataSourceId: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The update status of the data source's last update.
        public let updateStatus: ResourceStatus?

        public init(arn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil, updateStatus: ResourceStatus? = nil) {
            self.arn = arn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct UpdateFolderPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String
        /// The permissions that you want to grant on a resource.
        public let grantPermissions: [ResourcePermission]?
        /// The permissions that you want to revoke from a resource.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, folderId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateFolderPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN).
        public let arn: String?
        /// The folder ID.
        public let folderId: String?
        /// Information about the permissions on the dashboard.
        public let permissions: [ResourcePermission]?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri(locationName: "FolderId"))
        ]

        /// The AWS account ID.
        public let awsAccountId: String
        /// The folder ID.
        public let folderId: String
        /// The name of the folder.
        public let name: String

        public init(awsAccountId: String, folderId: String, name: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN).
        public let arn: String?
        /// The folder ID.
        public let folderId: String?
        /// The request ID.
        public let requestId: String?
        /// The status. If succeeded, the status is SC_OK.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri(locationName: "GroupName")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The ID for the AWS account that the group is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The description for the group that you want to update.
        public let description: String?
        /// The name of the group that you want to update.
        public let groupName: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String

        public init(awsAccountId: String, description: String? = nil, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "[\\u0020-\\u00FF]+")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the group.
        public let group: Group?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assignmentName", location: .uri(locationName: "AssignmentName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace"))
        ]

        /// The name of the assignment, also called a rule. This name must be unique within an AWS account.
        public let assignmentName: String
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
        public let assignmentStatus: AssignmentStatus?
        /// The ID of the AWS account that contains the IAM policy assignment.
        public let awsAccountId: String
        /// The QuickSight users, groups, or both that you want to assign the policy to.
        public let identities: [String: [String]]?
        /// The namespace of the assignment.
        public let namespace: String
        /// The ARN for the IAM policy to apply to the QuickSight users and groups specified in this assignment.
        public let policyArn: String?

        public init(assignmentName: String, assignmentStatus: AssignmentStatus? = nil, awsAccountId: String, identities: [String: [String]]? = nil, namespace: String, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.namespace = namespace
            self.policyArn = policyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct UpdateIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the assignment.
        public let assignmentId: String?
        /// The name of the assignment or rule.
        public let assignmentName: String?
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
        public let assignmentStatus: AssignmentStatus?
        /// The QuickSight users, groups, or both that the IAM policy is assigned to.
        public let identities: [String: [String]]?
        /// The ARN for the IAM policy applied to the QuickSight users and groups specified in this assignment.
        public let policyArn: String?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.identities = identities
            self.policyArn = policyArn
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The alias of the template that you want to update. If you name a specific alias, you update the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String
        /// The ID of the AWS account that contains the template alias that you're updating.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String
        /// The version number of the template.
        public let templateVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, templateId: String, templateVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.templateVersionNumber = templateVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.templateVersionNumber, name: "templateVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct UpdateTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct UpdateTemplatePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The ID of the AWS account that contains the template.
        public let awsAccountId: String
        /// A list of resource permissions to be granted on the template.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions to be revoked from the template.
        public let revokePermissions: [ResourcePermission]?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateTemplatePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String?
        /// The ID for the template.
        public let templateId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, templateArn: String? = nil, templateId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case templateArn = "TemplateArn"
            case templateId = "TemplateId"
        }
    }

    public struct UpdateTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// The ID of the AWS account that contains the template that you're updating.
        public let awsAccountId: String
        /// The name for the template.
        public let name: String?
        /// The entity that you are using as a source when you update the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any AWS Account and any QuickSight-supported AWS Region.  Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: TemplateSourceEntity
        /// The ID for the template.
        public let templateId: String
        /// A description of the current template version that is being updated. Every time you call UpdateTemplate, you create a new version of the template. Each version of the template maintains a description of the version in the VersionDescription field.
        public let versionDescription: String?

        public init(awsAccountId: String, name: String? = nil, sourceEntity: TemplateSourceEntity, templateId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.name = name
            self.sourceEntity = sourceEntity
            self.templateId = templateId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.sourceEntity.validate(name: "\(name).sourceEntity")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 2048)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case sourceEntity = "SourceEntity"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the template.
        public let arn: String?
        /// The creation status of the template.
        public let creationStatus: ResourceStatus?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the template.
        public let templateId: String?
        /// The ARN for the template, including the version information of the first version.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri(locationName: "AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The name of the theme alias that you want to update.
        public let aliasName: String
        /// The ID of the AWS account that contains the theme alias that you're updating.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String
        /// The version number of the theme that the alias should reference.
        public let themeVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, themeId: String, themeVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.themeVersionNumber = themeVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.themeVersionNumber, name: "themeVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct UpdateThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct UpdateThemePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The ID of the AWS account that contains the theme.
        public let awsAccountId: String
        /// A list of resource permissions to be granted for the theme.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions to be revoked from the theme.
        public let revokePermissions: [ResourcePermission]?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateThemePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The resulting list of resource permissions for the theme.
        public let permissions: [ResourcePermission]?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the theme.
        public let themeArn: String?
        /// The ID for the theme.
        public let themeId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, themeArn: String? = nil, themeId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.themeArn = themeArn
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case themeArn = "ThemeArn"
            case themeId = "ThemeId"
        }
    }

    public struct UpdateThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri(locationName: "ThemeId"))
        ]

        /// The ID of the AWS account that contains the theme that you're updating.
        public let awsAccountId: String
        /// The theme ID, defined by Amazon QuickSight, that a custom theme inherits from. All themes initially inherit from a default QuickSight theme.
        public let baseThemeId: String
        /// The theme configuration, which contains the theme display properties.
        public let configuration: ThemeConfiguration?
        /// The name for the theme.
        public let name: String?
        /// The ID for the theme.
        public let themeId: String
        /// A description of the theme version that you're updating Every time that you call UpdateTheme, you create a new version of the theme. Each version of the theme maintains a description of the version in VersionDescription.
        public let versionDescription: String?

        public init(awsAccountId: String, baseThemeId: String, configuration: ThemeConfiguration? = nil, name: String? = nil, themeId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.name = name
            self.themeId = themeId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, max: 2048)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, min: 1)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, pattern: "[\\w\\-]+")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 2048)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "[\\w\\-]+")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case name = "Name"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the theme.
        public let arn: String?
        /// The creation status of the theme.
        public let creationStatus: ResourceStatus?
        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the theme.
        public let themeId: String?
        /// The Amazon Resource Name (ARN) for the new version of the theme.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri(locationName: "AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri(locationName: "Namespace")),
            AWSMemberEncoding(label: "userName", location: .uri(locationName: "UserName"))
        ]

        /// The ID for the AWS account that the user is in. Currently, you use the ID for the AWS account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into QuickSight with an associated AWS Identity and Access Management (IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
        public let customFederationProviderUrl: String?
        /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:   Create and update data sources   Create and update datasets   Create and update email reports   Subscribe to email reports   A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a QuickSight user.  QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning QuickSight users to one of the default security cohorts in QuickSight (admin, author, reader). This feature is available only to QuickSight Enterprise edition subscriptions that use SAML 2.0-Based Federation for Single Sign-On (SSO).
        public let customPermissionsName: String?
        /// The email address of the user that you want to update.
        public let email: String
        /// The type of supported external login provider that provides identity to let a user federate into QuickSight with an associated AWS Identity and Access Management (IAM) role. The type of supported external login provider can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.    NONE: This clears all the previously saved external login information for a user. Use  DescribeUser  API to check the external login information.
        public let externalLoginFederationProviderType: String?
        /// The identity ID for a user in the external login provider.
        public let externalLoginId: String?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The Amazon QuickSight role of the user. The role can be one of the following default security cohorts:    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.    ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.   The name of the QuickSight role is invisible to the user except for the console screens dealing with permissions.
        public let role: UserRole
        /// A flag that you use to indicate that you want to remove all custom permissions from this user. Using this parameter resets the user to the state it was in before a custom permissions profile was applied. This parameter defaults to NULL and it doesn't accept any other value.
        public let unapplyCustomPermissions: Bool?
        /// The Amazon QuickSight user name that you want to update.
        public let userName: String

        public init(awsAccountId: String, customFederationProviderUrl: String? = nil, customPermissionsName: String? = nil, email: String, externalLoginFederationProviderType: String? = nil, externalLoginId: String? = nil, namespace: String, role: UserRole, unapplyCustomPermissions: Bool? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.customFederationProviderUrl = customFederationProviderUrl
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginId = externalLoginId
            self.namespace = namespace
            self.role = role
            self.unapplyCustomPermissions = unapplyCustomPermissions
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, max: 64)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, min: 1)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, pattern: "^[a-zA-Z0-9+=,.@_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "[\\u0020-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case customFederationProviderUrl = "CustomFederationProviderUrl"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginId = "ExternalLoginId"
            case role = "Role"
            case unapplyCustomPermissions = "UnapplyCustomPermissions"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The AWS request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon QuickSight user.
        public let user: User?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case user = "User"
        }
    }

    public struct UploadSettings: AWSEncodableShape & AWSDecodableShape {
        /// Whether the file has a header row, or the files each have a header row.
        public let containsHeader: Bool?
        /// The delimiter between values in the file.
        public let delimiter: String?
        /// File format.
        public let format: FileFormat?
        /// A row number to start reading data from.
        public let startFromRow: Int?
        /// Text qualifier.
        public let textQualifier: TextQualifier?

        public init(containsHeader: Bool? = nil, delimiter: String? = nil, format: FileFormat? = nil, startFromRow: Int? = nil, textQualifier: TextQualifier? = nil) {
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.format = format
            self.startFromRow = startFromRow
            self.textQualifier = textQualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.startFromRow, name: "startFromRow", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case format = "Format"
            case startFromRow = "StartFromRow"
            case textQualifier = "TextQualifier"
        }
    }

    public struct User: AWSDecodableShape {
        /// The active status of user. When you create an Amazon QuickSight user thats not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.
        public let active: Bool?
        /// The Amazon Resource Name (ARN) for the user.
        public let arn: String?
        /// The custom permissions profile associated with this user.
        public let customPermissionsName: String?
        /// The user's email address.
        public let email: String?
        /// The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider.
        public let externalLoginFederationProviderType: String?
        /// The URL of the external login provider.
        public let externalLoginFederationProviderUrl: String?
        /// The identity ID for the user in the external login provider.
        public let externalLoginId: String?
        /// The type of identity authentication used by the user.
        public let identityType: IdentityType?
        /// The principal ID of the user.
        public let principalId: String?
        /// The Amazon QuickSight role for the user. The user role can be one of the following:.    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.    ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.    RESTRICTED_READER: This role isn't currently available for use.    RESTRICTED_AUTHOR: This role isn't currently available for use.
        public let role: UserRole?
        /// The user's user name.
        public let userName: String?

        public init(active: Bool? = nil, arn: String? = nil, customPermissionsName: String? = nil, email: String? = nil, externalLoginFederationProviderType: String? = nil, externalLoginFederationProviderUrl: String? = nil, externalLoginId: String? = nil, identityType: IdentityType? = nil, principalId: String? = nil, role: UserRole? = nil, userName: String? = nil) {
            self.active = active
            self.arn = arn
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginFederationProviderUrl = externalLoginFederationProviderUrl
            self.externalLoginId = externalLoginId
            self.identityType = identityType
            self.principalId = principalId
            self.role = role
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case active = "Active"
            case arn = "Arn"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginFederationProviderUrl = "ExternalLoginFederationProviderUrl"
            case externalLoginId = "ExternalLoginId"
            case identityType = "IdentityType"
            case principalId = "PrincipalId"
            case role = "Role"
            case userName = "UserName"
        }
    }

    public struct VpcConnectionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the VPC connection.
        public let vpcConnectionArn: String

        public init(vpcConnectionArn: String) {
            self.vpcConnectionArn = vpcConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConnectionArn = "VpcConnectionArn"
        }
    }
}
