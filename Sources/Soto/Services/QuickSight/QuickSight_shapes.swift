//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension QuickSight {
    // MARK: Enums

    public enum AnalysisErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case columnGeographicRoleMismatch = "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case columnReplacementMissing = "COLUMN_REPLACEMENT_MISSING"
        case columnTypeMismatch = "COLUMN_TYPE_MISMATCH"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case parameterNotFound = "PARAMETER_NOT_FOUND"
        case parameterTypeInvalid = "PARAMETER_TYPE_INVALID"
        case parameterValueIncompatible = "PARAMETER_VALUE_INCOMPATIBLE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisFilterAttribute: String, CustomStringConvertible, Codable, _SotoSendable {
        case analysisName = "ANALYSIS_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightUser = "QUICKSIGHT_USER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum AnchorOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case now = "NOW"
        public var description: String { return self.rawValue }
    }

    public enum ArcThickness: String, CustomStringConvertible, Codable, _SotoSendable {
        case large = "LARGE"
        case medium = "MEDIUM"
        case small = "SMALL"
        case whole = "WHOLE"
        public var description: String { return self.rawValue }
    }

    public enum ArcThicknessOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case large = "LARGE"
        case medium = "MEDIUM"
        case small = "SMALL"
        public var description: String { return self.rawValue }
    }

    public enum AssignmentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case draft = "DRAFT"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticationMethodOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case activeDirectory = "ACTIVE_DIRECTORY"
        case iamAndQuicksight = "IAM_AND_QUICKSIGHT"
        case iamOnly = "IAM_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum AxisBinding: String, CustomStringConvertible, Codable, _SotoSendable {
        case primaryYaxis = "PRIMARY_YAXIS"
        case secondaryYaxis = "SECONDARY_YAXIS"
        public var description: String { return self.rawValue }
    }

    public enum BarChartOrientation: String, CustomStringConvertible, Codable, _SotoSendable {
        case horizontal = "HORIZONTAL"
        case vertical = "VERTICAL"
        public var description: String { return self.rawValue }
    }

    public enum BarsArrangement: String, CustomStringConvertible, Codable, _SotoSendable {
        case clustered = "CLUSTERED"
        case stacked = "STACKED"
        case stackedPercent = "STACKED_PERCENT"
        public var description: String { return self.rawValue }
    }

    public enum BaseMapStyleType: String, CustomStringConvertible, Codable, _SotoSendable {
        case darkGray = "DARK_GRAY"
        case imagery = "IMAGERY"
        case lightGray = "LIGHT_GRAY"
        case street = "STREET"
        public var description: String { return self.rawValue }
    }

    public enum BoxPlotFillStyle: String, CustomStringConvertible, Codable, _SotoSendable {
        case solid = "SOLID"
        case transparent = "TRANSPARENT"
        public var description: String { return self.rawValue }
    }

    public enum CategoricalAggregationFunction: String, CustomStringConvertible, Codable, _SotoSendable {
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        public var description: String { return self.rawValue }
    }

    public enum CategoryFilterMatchOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case contains = "CONTAINS"
        case doesNotContain = "DOES_NOT_CONTAIN"
        case doesNotEqual = "DOES_NOT_EQUAL"
        case endsWith = "ENDS_WITH"
        case equals = "EQUALS"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum CategoryFilterSelectAllOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case filterAllValues = "FILTER_ALL_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum ColorFillType: String, CustomStringConvertible, Codable, _SotoSendable {
        case discrete = "DISCRETE"
        case gradient = "GRADIENT"
        public var description: String { return self.rawValue }
    }

    public enum ColumnDataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case datetime = "DATETIME"
        case decimal = "DECIMAL"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ColumnRole: String, CustomStringConvertible, Codable, _SotoSendable {
        case dimension = "DIMENSION"
        case measure = "MEASURE"
        public var description: String { return self.rawValue }
    }

    public enum ColumnTagName: String, CustomStringConvertible, Codable, _SotoSendable {
        case columnDescription = "COLUMN_DESCRIPTION"
        case columnGeographicRole = "COLUMN_GEOGRAPHIC_ROLE"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonMethod: String, CustomStringConvertible, Codable, _SotoSendable {
        case difference = "DIFFERENCE"
        case percent = "PERCENT"
        case percentDifference = "PERCENT_DIFFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum ConditionalFormattingIconDisplayOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case iconOnly = "ICON_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum ConditionalFormattingIconSetType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bars = "BARS"
        case caretUpMinusDown = "CARET_UP_MINUS_DOWN"
        case checkX = "CHECK_X"
        case flags = "FLAGS"
        case fourColorArrow = "FOUR_COLOR_ARROW"
        case fourGrayArrow = "FOUR_GRAY_ARROW"
        case plusMinus = "PLUS_MINUS"
        case threeCircle = "THREE_CIRCLE"
        case threeColorArrow = "THREE_COLOR_ARROW"
        case threeGrayArrow = "THREE_GRAY_ARROW"
        case threeShape = "THREE_SHAPE"
        public var description: String { return self.rawValue }
    }

    public enum CrossDatasetTypes: String, CustomStringConvertible, Codable, _SotoSendable {
        case allDatasets = "ALL_DATASETS"
        case singleDataset = "SINGLE_DATASET"
        public var description: String { return self.rawValue }
    }

    public enum CustomContentImageScalingConfiguration: String, CustomStringConvertible, Codable, _SotoSendable {
        case doNotScale = "DO_NOT_SCALE"
        case fitToHeight = "FIT_TO_HEIGHT"
        case fitToWidth = "FIT_TO_WIDTH"
        case scaleToVisual = "SCALE_TO_VISUAL"
        public var description: String { return self.rawValue }
    }

    public enum CustomContentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case image = "IMAGE"
        case otherEmbeddedContent = "OTHER_EMBEDDED_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum DashboardBehavior: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DashboardErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case columnGeographicRoleMismatch = "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case columnReplacementMissing = "COLUMN_REPLACEMENT_MISSING"
        case columnTypeMismatch = "COLUMN_TYPE_MISMATCH"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case parameterNotFound = "PARAMETER_NOT_FOUND"
        case parameterTypeInvalid = "PARAMETER_TYPE_INVALID"
        case parameterValueIncompatible = "PARAMETER_VALUE_INCOMPATIBLE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum DashboardFilterAttribute: String, CustomStringConvertible, Codable, _SotoSendable {
        case dashboardName = "DASHBOARD_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightUser = "QUICKSIGHT_USER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum DashboardUIState: String, CustomStringConvertible, Codable, _SotoSendable {
        case collapsed = "COLLAPSED"
        case expanded = "EXPANDED"
        public var description: String { return self.rawValue }
    }

    public enum DataLabelContent: String, CustomStringConvertible, Codable, _SotoSendable {
        case percent = "PERCENT"
        case value = "VALUE"
        case valueAndPercent = "VALUE_AND_PERCENT"
        public var description: String { return self.rawValue }
    }

    public enum DataLabelOverlap: String, CustomStringConvertible, Codable, _SotoSendable {
        case disableOverlap = "DISABLE_OVERLAP"
        case enableOverlap = "ENABLE_OVERLAP"
        public var description: String { return self.rawValue }
    }

    public enum DataLabelPosition: String, CustomStringConvertible, Codable, _SotoSendable {
        case bottom = "BOTTOM"
        case inside = "INSIDE"
        case left = "LEFT"
        case outside = "OUTSIDE"
        case right = "RIGHT"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum DataSetFilterAttribute: String, CustomStringConvertible, Codable, _SotoSendable {
        case datasetName = "DATASET_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum DataSetImportMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case directQuery = "DIRECT_QUERY"
        case spice = "SPICE"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceErrorInfoType: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case conflict = "CONFLICT"
        case copySourceNotFound = "COPY_SOURCE_NOT_FOUND"
        case engineVersionNotSupported = "ENGINE_VERSION_NOT_SUPPORTED"
        case genericSqlFailure = "GENERIC_SQL_FAILURE"
        case timeout = "TIMEOUT"
        case unknown = "UNKNOWN"
        case unknownHost = "UNKNOWN_HOST"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceFilterAttribute: String, CustomStringConvertible, Codable, _SotoSendable {
        case datasourceName = "DATASOURCE_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case adobeAnalytics = "ADOBE_ANALYTICS"
        case amazonElasticsearch = "AMAZON_ELASTICSEARCH"
        case amazonOpensearch = "AMAZON_OPENSEARCH"
        case athena = "ATHENA"
        case aurora = "AURORA"
        case auroraPostgresql = "AURORA_POSTGRESQL"
        case awsIotAnalytics = "AWS_IOT_ANALYTICS"
        case databricks = "DATABRICKS"
        case exasol = "EXASOL"
        case github = "GITHUB"
        case jira = "JIRA"
        case mariadb = "MARIADB"
        case mysql = "MYSQL"
        case oracle = "ORACLE"
        case postgresql = "POSTGRESQL"
        case presto = "PRESTO"
        case redshift = "REDSHIFT"
        case s3 = "S3"
        case salesforce = "SALESFORCE"
        case servicenow = "SERVICENOW"
        case snowflake = "SNOWFLAKE"
        case spark = "SPARK"
        case sqlserver = "SQLSERVER"
        case teradata = "TERADATA"
        case timestream = "TIMESTREAM"
        case twitter = "TWITTER"
        public var description: String { return self.rawValue }
    }

    public enum DateAggregationFunction: String, CustomStringConvertible, Codable, _SotoSendable {
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case min = "MIN"
        public var description: String { return self.rawValue }
    }

    public enum Edition: String, CustomStringConvertible, Codable, _SotoSendable {
        case enterprise = "ENTERPRISE"
        case enterpriseAndQ = "ENTERPRISE_AND_Q"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum EmbeddingIdentityType: String, CustomStringConvertible, Codable, _SotoSendable {
        case anonymous = "ANONYMOUS"
        case iam = "IAM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum FileFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case clf = "CLF"
        case csv = "CSV"
        case elf = "ELF"
        case json = "JSON"
        case tsv = "TSV"
        case xlsx = "XLSX"
        public var description: String { return self.rawValue }
    }

    public enum FilterNullOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case allValues = "ALL_VALUES"
        case nonNullsOnly = "NON_NULLS_ONLY"
        case nullsOnly = "NULLS_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case stringEquals = "StringEquals"
        case stringLike = "StringLike"
        public var description: String { return self.rawValue }
    }

    public enum FilterVisualScope: String, CustomStringConvertible, Codable, _SotoSendable {
        case allVisuals = "ALL_VISUALS"
        case selectedVisuals = "SELECTED_VISUALS"
        public var description: String { return self.rawValue }
    }

    public enum FolderFilterAttribute: String, CustomStringConvertible, Codable, _SotoSendable {
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case folderName = "FOLDER_NAME"
        case parentFolderArn = "PARENT_FOLDER_ARN"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum FolderType: String, CustomStringConvertible, Codable, _SotoSendable {
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum FontDecoration: String, CustomStringConvertible, Codable, _SotoSendable {
        case none = "NONE"
        case underline = "UNDERLINE"
        public var description: String { return self.rawValue }
    }

    public enum FontStyle: String, CustomStringConvertible, Codable, _SotoSendable {
        case italic = "ITALIC"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum FontWeightName: String, CustomStringConvertible, Codable, _SotoSendable {
        case bold = "BOLD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum ForecastComputationSeasonality: String, CustomStringConvertible, Codable, _SotoSendable {
        case automatic = "AUTOMATIC"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum FunnelChartMeasureDataLabelStyle: String, CustomStringConvertible, Codable, _SotoSendable {
        case percentageByFirstStage = "PERCENTAGE_BY_FIRST_STAGE"
        case percentageByPreviousStage = "PERCENTAGE_BY_PREVIOUS_STAGE"
        case valueAndPercentageByFirstStage = "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE"
        case valueAndPercentageByPreviousStage = "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE"
        case valueOnly = "VALUE_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum GeoSpatialCountryCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case us = "US"
        public var description: String { return self.rawValue }
    }

    public enum GeoSpatialDataRole: String, CustomStringConvertible, Codable, _SotoSendable {
        case city = "CITY"
        case country = "COUNTRY"
        case county = "COUNTY"
        case latitude = "LATITUDE"
        case longitude = "LONGITUDE"
        case postcode = "POSTCODE"
        case state = "STATE"
        public var description: String { return self.rawValue }
    }

    public enum GeospatialSelectedPointStyle: String, CustomStringConvertible, Codable, _SotoSendable {
        case cluster = "CLUSTER"
        case point = "POINT"
        public var description: String { return self.rawValue }
    }

    public enum GroupFilterAttribute: String, CustomStringConvertible, Codable, _SotoSendable {
        case groupName = "GROUP_NAME"
        public var description: String { return self.rawValue }
    }

    public enum GroupFilterOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case startsWith = "StartsWith"
        public var description: String { return self.rawValue }
    }

    public enum HistogramBinType: String, CustomStringConvertible, Codable, _SotoSendable {
        case binCount = "BIN_COUNT"
        case binWidth = "BIN_WIDTH"
        public var description: String { return self.rawValue }
    }

    public enum HorizontalTextAlignment: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "AUTO"
        case center = "CENTER"
        case left = "LEFT"
        case right = "RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum Icon: String, CustomStringConvertible, Codable, _SotoSendable {
        case arrowDown = "ARROW_DOWN"
        case arrowDownLeft = "ARROW_DOWN_LEFT"
        case arrowDownRight = "ARROW_DOWN_RIGHT"
        case arrowLeft = "ARROW_LEFT"
        case arrowRight = "ARROW_RIGHT"
        case arrowUp = "ARROW_UP"
        case arrowUpLeft = "ARROW_UP_LEFT"
        case arrowUpRight = "ARROW_UP_RIGHT"
        case caretDown = "CARET_DOWN"
        case caretUp = "CARET_UP"
        case checkmark = "CHECKMARK"
        case circle = "CIRCLE"
        case faceDown = "FACE_DOWN"
        case faceFlat = "FACE_FLAT"
        case faceUp = "FACE_UP"
        case flag = "FLAG"
        case minus = "MINUS"
        case oneBar = "ONE_BAR"
        case plus = "PLUS"
        case square = "SQUARE"
        case threeBar = "THREE_BAR"
        case thumbsDown = "THUMBS_DOWN"
        case thumbsUp = "THUMBS_UP"
        case triangle = "TRIANGLE"
        case twoBar = "TWO_BAR"
        case x = "X"
        public var description: String { return self.rawValue }
    }

    public enum IdentityStore: String, CustomStringConvertible, Codable, _SotoSendable {
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable, _SotoSendable {
        case iam = "IAM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum IngestionErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case accountCapacityLimitExceeded = "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
        case connectionFailure = "CONNECTION_FAILURE"
        case cursorNotEnabled = "CURSOR_NOT_ENABLED"
        case customerError = "CUSTOMER_ERROR"
        case dataSetDeleted = "DATA_SET_DELETED"
        case dataSetNotSpice = "DATA_SET_NOT_SPICE"
        case dataSetSizeLimitExceeded = "DATA_SET_SIZE_LIMIT_EXCEEDED"
        case dataSourceAuthFailed = "DATA_SOURCE_AUTH_FAILED"
        case dataSourceConnectionFailed = "DATA_SOURCE_CONNECTION_FAILED"
        case dataSourceNotFound = "DATA_SOURCE_NOT_FOUND"
        case dataToleranceException = "DATA_TOLERANCE_EXCEPTION"
        case elasticsearchCursorNotEnabled = "ELASTICSEARCH_CURSOR_NOT_ENABLED"
        case failureToAssumeRole = "FAILURE_TO_ASSUME_ROLE"
        case failureToProcessJsonFile = "FAILURE_TO_PROCESS_JSON_FILE"
        case iamRoleNotAvailable = "IAM_ROLE_NOT_AVAILABLE"
        case ingestionCanceled = "INGESTION_CANCELED"
        case ingestionSuperseded = "INGESTION_SUPERSEDED"
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case invalidDataSourceConfig = "INVALID_DATA_SOURCE_CONFIG"
        case invalidDataprepSyntax = "INVALID_DATAPREP_SYNTAX"
        case invalidDateFormat = "INVALID_DATE_FORMAT"
        case iotDataSetFileEmpty = "IOT_DATA_SET_FILE_EMPTY"
        case iotFileNotFound = "IOT_FILE_NOT_FOUND"
        case oauthTokenFailure = "OAUTH_TOKEN_FAILURE"
        case passwordAuthenticationFailure = "PASSWORD_AUTHENTICATION_FAILURE"
        case permissionDenied = "PERMISSION_DENIED"
        case permissionNotFound = "PERMISSION_NOT_FOUND"
        case queryTimeout = "QUERY_TIMEOUT"
        case refreshSuppressedByEdit = "REFRESH_SUPPRESSED_BY_EDIT"
        case rowSizeLimitExceeded = "ROW_SIZE_LIMIT_EXCEEDED"
        case s3FileInaccessible = "S3_FILE_INACCESSIBLE"
        case s3ManifestError = "S3_MANIFEST_ERROR"
        case s3UploadedFileDeleted = "S3_UPLOADED_FILE_DELETED"
        case sourceApiLimitExceededFailure = "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
        case sourceResourceLimitExceeded = "SOURCE_RESOURCE_LIMIT_EXCEEDED"
        case spiceTableNotFound = "SPICE_TABLE_NOT_FOUND"
        case sqlException = "SQL_EXCEPTION"
        case sqlInvalidParameterValue = "SQL_INVALID_PARAMETER_VALUE"
        case sqlNumericOverflow = "SQL_NUMERIC_OVERFLOW"
        case sqlSchemaMismatchError = "SQL_SCHEMA_MISMATCH_ERROR"
        case sqlTableNotFound = "SQL_TABLE_NOT_FOUND"
        case sslCertificateValidationFailure = "SSL_CERTIFICATE_VALIDATION_FAILURE"
        case unresolvableHost = "UNRESOLVABLE_HOST"
        case unroutableHost = "UNROUTABLE_HOST"
        public var description: String { return self.rawValue }
    }

    public enum IngestionRequestSource: String, CustomStringConvertible, Codable, _SotoSendable {
        case manual = "MANUAL"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum IngestionRequestType: String, CustomStringConvertible, Codable, _SotoSendable {
        case edit = "EDIT"
        case fullRefresh = "FULL_REFRESH"
        case incrementalRefresh = "INCREMENTAL_REFRESH"
        case initialIngestion = "INITIAL_INGESTION"
        public var description: String { return self.rawValue }
    }

    public enum IngestionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case initialized = "INITIALIZED"
        case queued = "QUEUED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum IngestionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case fullRefresh = "FULL_REFRESH"
        case incrementalRefresh = "INCREMENTAL_REFRESH"
        public var description: String { return self.rawValue }
    }

    public enum InputColumnDataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bit = "BIT"
        case boolean = "BOOLEAN"
        case datetime = "DATETIME"
        case decimal = "DECIMAL"
        case integer = "INTEGER"
        case json = "JSON"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum JoinType: String, CustomStringConvertible, Codable, _SotoSendable {
        case inner = "INNER"
        case left = "LEFT"
        case outer = "OUTER"
        case right = "RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum LayoutElementType: String, CustomStringConvertible, Codable, _SotoSendable {
        case filterControl = "FILTER_CONTROL"
        case parameterControl = "PARAMETER_CONTROL"
        case textBox = "TEXT_BOX"
        case visual = "VISUAL"
        public var description: String { return self.rawValue }
    }

    public enum LegendPosition: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "AUTO"
        case bottom = "BOTTOM"
        case right = "RIGHT"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum LineChartLineStyle: String, CustomStringConvertible, Codable, _SotoSendable {
        case dashed = "DASHED"
        case dotted = "DOTTED"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum LineChartMarkerShape: String, CustomStringConvertible, Codable, _SotoSendable {
        case circle = "CIRCLE"
        case diamond = "DIAMOND"
        case roundedSquare = "ROUNDED_SQUARE"
        case square = "SQUARE"
        case triangle = "TRIANGLE"
        public var description: String { return self.rawValue }
    }

    public enum LineChartType: String, CustomStringConvertible, Codable, _SotoSendable {
        case area = "AREA"
        case line = "LINE"
        case stackedArea = "STACKED_AREA"
        public var description: String { return self.rawValue }
    }

    public enum LineInterpolation: String, CustomStringConvertible, Codable, _SotoSendable {
        case linear = "LINEAR"
        case smooth = "SMOOTH"
        case stepped = "STEPPED"
        public var description: String { return self.rawValue }
    }

    public enum MapZoomMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "AUTO"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    public enum MaximumMinimumComputationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        public var description: String { return self.rawValue }
    }

    public enum MemberType: String, CustomStringConvertible, Codable, _SotoSendable {
        case analysis = "ANALYSIS"
        case dashboard = "DASHBOARD"
        case dataset = "DATASET"
        public var description: String { return self.rawValue }
    }

    public enum MissingDataTreatmentOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case interpolate = "INTERPOLATE"
        case showAsBlank = "SHOW_AS_BLANK"
        case showAsZero = "SHOW_AS_ZERO"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case permissionDenied = "PERMISSION_DENIED"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case created = "CREATED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case nonRetryableFailure = "NON_RETRYABLE_FAILURE"
        case retryableFailure = "RETRYABLE_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum NegativeValueDisplayMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case negative = "NEGATIVE"
        case positive = "POSITIVE"
        public var description: String { return self.rawValue }
    }

    public enum NumberScale: String, CustomStringConvertible, Codable, _SotoSendable {
        case auto = "AUTO"
        case billions = "BILLIONS"
        case millions = "MILLIONS"
        case none = "NONE"
        case thousands = "THOUSANDS"
        case trillions = "TRILLIONS"
        public var description: String { return self.rawValue }
    }

    public enum NumericEqualityMatchOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case doesNotEqual = "DOES_NOT_EQUAL"
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum NumericFilterSelectAllOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case filterAllValues = "FILTER_ALL_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum NumericSeparatorSymbol: String, CustomStringConvertible, Codable, _SotoSendable {
        case comma = "COMMA"
        case dot = "DOT"
        case space = "SPACE"
        public var description: String { return self.rawValue }
    }

    public enum OtherCategories: String, CustomStringConvertible, Codable, _SotoSendable {
        case exclude = "EXCLUDE"
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum PanelBorderStyle: String, CustomStringConvertible, Codable, _SotoSendable {
        case dashed = "DASHED"
        case dotted = "DOTTED"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum PaperOrientation: String, CustomStringConvertible, Codable, _SotoSendable {
        case landscape = "LANDSCAPE"
        case portrait = "PORTRAIT"
        public var description: String { return self.rawValue }
    }

    public enum PaperSize: String, CustomStringConvertible, Codable, _SotoSendable {
        case a0 = "A0"
        case a1 = "A1"
        case a2 = "A2"
        case a3 = "A3"
        case a4 = "A4"
        case a5 = "A5"
        case jisB4 = "JIS_B4"
        case jisB5 = "JIS_B5"
        case usLegal = "US_LEGAL"
        case usLetter = "US_LETTER"
        case usTabloidLedger = "US_TABLOID_LEDGER"
        public var description: String { return self.rawValue }
    }

    public enum ParameterValueType: String, CustomStringConvertible, Codable, _SotoSendable {
        case multiValued = "MULTI_VALUED"
        case singleValued = "SINGLE_VALUED"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableConditionalFormattingScopeRole: String, CustomStringConvertible, Codable, _SotoSendable {
        case field = "FIELD"
        case fieldTotal = "FIELD_TOTAL"
        case grandTotal = "GRAND_TOTAL"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableMetricPlacement: String, CustomStringConvertible, Codable, _SotoSendable {
        case column = "COLUMN"
        case row = "ROW"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableSubtotalLevel: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case custom = "CUSTOM"
        case last = "LAST"
        public var description: String { return self.rawValue }
    }

    public enum PrimaryValueDisplayType: String, CustomStringConvertible, Codable, _SotoSendable {
        case actual = "ACTUAL"
        case comparison = "COMPARISON"
        case hidden = "HIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLineLabelHorizontalPosition: String, CustomStringConvertible, Codable, _SotoSendable {
        case center = "CENTER"
        case left = "LEFT"
        case right = "RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLineLabelVerticalPosition: String, CustomStringConvertible, Codable, _SotoSendable {
        case above = "ABOVE"
        case below = "BELOW"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLinePatternType: String, CustomStringConvertible, Codable, _SotoSendable {
        case dashed = "DASHED"
        case dotted = "DOTTED"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLineValueLabelRelativePosition: String, CustomStringConvertible, Codable, _SotoSendable {
        case afterCustomLabel = "AFTER_CUSTOM_LABEL"
        case beforeCustomLabel = "BEFORE_CUSTOM_LABEL"
        public var description: String { return self.rawValue }
    }

    public enum RelativeDateType: String, CustomStringConvertible, Codable, _SotoSendable {
        case last = "LAST"
        case next = "NEXT"
        case now = "NOW"
        case previous = "PREVIOUS"
        case this = "THIS"
        public var description: String { return self.rawValue }
    }

    public enum RelativeFontSize: String, CustomStringConvertible, Codable, _SotoSendable {
        case extraLarge = "EXTRA_LARGE"
        case extraSmall = "EXTRA_SMALL"
        case large = "LARGE"
        case medium = "MEDIUM"
        case small = "SMALL"
        public var description: String { return self.rawValue }
    }

    public enum ResizeOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case fixed = "FIXED"
        case responsive = "RESPONSIVE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case creationSuccessful = "CREATION_SUCCESSFUL"
        case deleted = "DELETED"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum RowLevelPermissionFormatVersion: String, CustomStringConvertible, Codable, _SotoSendable {
        case version1 = "VERSION_1"
        case version2 = "VERSION_2"
        public var description: String { return self.rawValue }
    }

    public enum RowLevelPermissionPolicy: String, CustomStringConvertible, Codable, _SotoSendable {
        case denyAccess = "DENY_ACCESS"
        case grantAccess = "GRANT_ACCESS"
        public var description: String { return self.rawValue }
    }

    public enum SectionPageBreakStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SelectAllValueOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case allValues = "ALL_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum SelectedFieldOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case allFields = "ALL_FIELDS"
        public var description: String { return self.rawValue }
    }

    public enum SelectedTooltipType: String, CustomStringConvertible, Codable, _SotoSendable {
        case basic = "BASIC"
        case detailed = "DETAILED"
        public var description: String { return self.rawValue }
    }

    public enum SheetContentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case interactive = "INTERACTIVE"
        case paginated = "PAGINATED"
        public var description: String { return self.rawValue }
    }

    public enum SheetControlDateTimePickerType: String, CustomStringConvertible, Codable, _SotoSendable {
        case dateRange = "DATE_RANGE"
        case singleValued = "SINGLE_VALUED"
        public var description: String { return self.rawValue }
    }

    public enum SheetControlListType: String, CustomStringConvertible, Codable, _SotoSendable {
        case multiSelect = "MULTI_SELECT"
        case singleSelect = "SINGLE_SELECT"
        public var description: String { return self.rawValue }
    }

    public enum SheetControlSliderType: String, CustomStringConvertible, Codable, _SotoSendable {
        case range = "RANGE"
        case singlePoint = "SINGLE_POINT"
        public var description: String { return self.rawValue }
    }

    public enum SimpleNumericalAggregationFunction: String, CustomStringConvertible, Codable, _SotoSendable {
        case `var` = "VAR"
        case average = "AVERAGE"
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case median = "MEDIAN"
        case min = "MIN"
        case stdev = "STDEV"
        case stdevp = "STDEVP"
        case sum = "SUM"
        case varp = "VARP"
        public var description: String { return self.rawValue }
    }

    public enum SortDirection: String, CustomStringConvertible, Codable, _SotoSendable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum TableBorderStyle: String, CustomStringConvertible, Codable, _SotoSendable {
        case none = "NONE"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum TableCellImageScalingConfiguration: String, CustomStringConvertible, Codable, _SotoSendable {
        case doNotScale = "DO_NOT_SCALE"
        case fitToCellHeight = "FIT_TO_CELL_HEIGHT"
        case fitToCellWidth = "FIT_TO_CELL_WIDTH"
        public var description: String { return self.rawValue }
    }

    public enum TableFieldIconSetType: String, CustomStringConvertible, Codable, _SotoSendable {
        case link = "LINK"
        public var description: String { return self.rawValue }
    }

    public enum TableOrientation: String, CustomStringConvertible, Codable, _SotoSendable {
        case horizontal = "HORIZONTAL"
        case vertical = "VERTICAL"
        public var description: String { return self.rawValue }
    }

    public enum TableTotalsPlacement: String, CustomStringConvertible, Codable, _SotoSendable {
        case end = "END"
        case start = "START"
        public var description: String { return self.rawValue }
    }

    public enum TableTotalsScrollStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case pinned = "PINNED"
        case scrolled = "SCROLLED"
        public var description: String { return self.rawValue }
    }

    public enum TargetVisualOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        case allVisuals = "ALL_VISUALS"
        public var description: String { return self.rawValue }
    }

    public enum TemplateErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum TextQualifier: String, CustomStringConvertible, Codable, _SotoSendable {
        case doubleQuote = "DOUBLE_QUOTE"
        case singleQuote = "SINGLE_QUOTE"
        public var description: String { return self.rawValue }
    }

    public enum TextWrap: String, CustomStringConvertible, Codable, _SotoSendable {
        case none = "NONE"
        case wrap = "WRAP"
        public var description: String { return self.rawValue }
    }

    public enum ThemeErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum ThemeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case custom = "CUSTOM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum TimeGranularity: String, CustomStringConvertible, Codable, _SotoSendable {
        case day = "DAY"
        case hour = "HOUR"
        case millisecond = "MILLISECOND"
        case minute = "MINUTE"
        case month = "MONTH"
        case quarter = "QUARTER"
        case second = "SECOND"
        case week = "WEEK"
        case year = "YEAR"
        public var description: String { return self.rawValue }
    }

    public enum TooltipTitleType: String, CustomStringConvertible, Codable, _SotoSendable {
        case none = "NONE"
        case primaryValue = "PRIMARY_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum TopBottomComputationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bottom = "BOTTOM"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum TopBottomSortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case absoluteDifference = "ABSOLUTE_DIFFERENCE"
        case percentDifference = "PERCENT_DIFFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum URLTargetConfiguration: String, CustomStringConvertible, Codable, _SotoSendable {
        case newTab = "NEW_TAB"
        case newWindow = "NEW_WINDOW"
        case sameTab = "SAME_TAB"
        public var description: String { return self.rawValue }
    }

    public enum UserRole: String, CustomStringConvertible, Codable, _SotoSendable {
        case admin = "ADMIN"
        case author = "AUTHOR"
        case reader = "READER"
        case restrictedAuthor = "RESTRICTED_AUTHOR"
        case restrictedReader = "RESTRICTED_READER"
        public var description: String { return self.rawValue }
    }

    public enum ValueWhenUnsetOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case null = "NULL"
        case recommendedValue = "RECOMMENDED_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum VerticalTextAlignment: String, CustomStringConvertible, Codable, _SotoSendable {
        case bottom = "BOTTOM"
        case middle = "MIDDLE"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum Visibility: String, CustomStringConvertible, Codable, _SotoSendable {
        case hidden = "HIDDEN"
        case visible = "VISIBLE"
        public var description: String { return self.rawValue }
    }

    public enum VisualCustomActionTrigger: String, CustomStringConvertible, Codable, _SotoSendable {
        case dataPointClick = "DATA_POINT_CLICK"
        case dataPointMenu = "DATA_POINT_MENU"
        public var description: String { return self.rawValue }
    }

    public enum WidgetStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudCloudLayout: String, CustomStringConvertible, Codable, _SotoSendable {
        case fluid = "FLUID"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordCasing: String, CustomStringConvertible, Codable, _SotoSendable {
        case existingCase = "EXISTING_CASE"
        case lowerCase = "LOWER_CASE"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordOrientation: String, CustomStringConvertible, Codable, _SotoSendable {
        case horizontal = "HORIZONTAL"
        case horizontalAndVertical = "HORIZONTAL_AND_VERTICAL"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordPadding: String, CustomStringConvertible, Codable, _SotoSendable {
        case large = "LARGE"
        case medium = "MEDIUM"
        case none = "NONE"
        case small = "SMALL"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordScaling: String, CustomStringConvertible, Codable, _SotoSendable {
        case emphasize = "EMPHASIZE"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceParameters: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// The parameters for OpenSearch.
        case amazonElasticsearchParameters(AmazonElasticsearchParameters)
        /// The parameters for OpenSearch.
        case amazonOpenSearchParameters(AmazonOpenSearchParameters)
        /// The parameters for Amazon Athena.
        case athenaParameters(AthenaParameters)
        /// The parameters for Amazon Aurora MySQL.
        case auroraParameters(AuroraParameters)
        /// The parameters for Amazon Aurora.
        case auroraPostgreSqlParameters(AuroraPostgreSqlParameters)
        /// The parameters for IoT Analytics.
        case awsIotAnalyticsParameters(AwsIotAnalyticsParameters)
        /// The required parameters that are needed to connect to a Databricks data source.
        case databricksParameters(DatabricksParameters)
        /// The parameters for Exasol.
        case exasolParameters(ExasolParameters)
        /// The parameters for Jira.
        case jiraParameters(JiraParameters)
        /// The parameters for MariaDB.
        case mariaDbParameters(MariaDbParameters)
        /// The parameters for MySQL.
        case mySqlParameters(MySqlParameters)
        /// The parameters for Oracle.
        case oracleParameters(OracleParameters)
        /// The parameters for PostgreSQL.
        case postgreSqlParameters(PostgreSqlParameters)
        /// The parameters for Presto.
        case prestoParameters(PrestoParameters)
        /// The parameters for Amazon RDS.
        case rdsParameters(RdsParameters)
        /// The parameters for Amazon Redshift.
        case redshiftParameters(RedshiftParameters)
        /// The parameters for S3.
        case s3Parameters(S3Parameters)
        /// The parameters for ServiceNow.
        case serviceNowParameters(ServiceNowParameters)
        /// The parameters for Snowflake.
        case snowflakeParameters(SnowflakeParameters)
        /// The parameters for Spark.
        case sparkParameters(SparkParameters)
        /// The parameters for SQL Server.
        case sqlServerParameters(SqlServerParameters)
        /// The parameters for Teradata.
        case teradataParameters(TeradataParameters)
        /// The parameters for Twitter.
        case twitterParameters(TwitterParameters)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .amazonElasticsearchParameters:
                let value = try container.decode(AmazonElasticsearchParameters.self, forKey: .amazonElasticsearchParameters)
                self = .amazonElasticsearchParameters(value)
            case .amazonOpenSearchParameters:
                let value = try container.decode(AmazonOpenSearchParameters.self, forKey: .amazonOpenSearchParameters)
                self = .amazonOpenSearchParameters(value)
            case .athenaParameters:
                let value = try container.decode(AthenaParameters.self, forKey: .athenaParameters)
                self = .athenaParameters(value)
            case .auroraParameters:
                let value = try container.decode(AuroraParameters.self, forKey: .auroraParameters)
                self = .auroraParameters(value)
            case .auroraPostgreSqlParameters:
                let value = try container.decode(AuroraPostgreSqlParameters.self, forKey: .auroraPostgreSqlParameters)
                self = .auroraPostgreSqlParameters(value)
            case .awsIotAnalyticsParameters:
                let value = try container.decode(AwsIotAnalyticsParameters.self, forKey: .awsIotAnalyticsParameters)
                self = .awsIotAnalyticsParameters(value)
            case .databricksParameters:
                let value = try container.decode(DatabricksParameters.self, forKey: .databricksParameters)
                self = .databricksParameters(value)
            case .exasolParameters:
                let value = try container.decode(ExasolParameters.self, forKey: .exasolParameters)
                self = .exasolParameters(value)
            case .jiraParameters:
                let value = try container.decode(JiraParameters.self, forKey: .jiraParameters)
                self = .jiraParameters(value)
            case .mariaDbParameters:
                let value = try container.decode(MariaDbParameters.self, forKey: .mariaDbParameters)
                self = .mariaDbParameters(value)
            case .mySqlParameters:
                let value = try container.decode(MySqlParameters.self, forKey: .mySqlParameters)
                self = .mySqlParameters(value)
            case .oracleParameters:
                let value = try container.decode(OracleParameters.self, forKey: .oracleParameters)
                self = .oracleParameters(value)
            case .postgreSqlParameters:
                let value = try container.decode(PostgreSqlParameters.self, forKey: .postgreSqlParameters)
                self = .postgreSqlParameters(value)
            case .prestoParameters:
                let value = try container.decode(PrestoParameters.self, forKey: .prestoParameters)
                self = .prestoParameters(value)
            case .rdsParameters:
                let value = try container.decode(RdsParameters.self, forKey: .rdsParameters)
                self = .rdsParameters(value)
            case .redshiftParameters:
                let value = try container.decode(RedshiftParameters.self, forKey: .redshiftParameters)
                self = .redshiftParameters(value)
            case .s3Parameters:
                let value = try container.decode(S3Parameters.self, forKey: .s3Parameters)
                self = .s3Parameters(value)
            case .serviceNowParameters:
                let value = try container.decode(ServiceNowParameters.self, forKey: .serviceNowParameters)
                self = .serviceNowParameters(value)
            case .snowflakeParameters:
                let value = try container.decode(SnowflakeParameters.self, forKey: .snowflakeParameters)
                self = .snowflakeParameters(value)
            case .sparkParameters:
                let value = try container.decode(SparkParameters.self, forKey: .sparkParameters)
                self = .sparkParameters(value)
            case .sqlServerParameters:
                let value = try container.decode(SqlServerParameters.self, forKey: .sqlServerParameters)
                self = .sqlServerParameters(value)
            case .teradataParameters:
                let value = try container.decode(TeradataParameters.self, forKey: .teradataParameters)
                self = .teradataParameters(value)
            case .twitterParameters:
                let value = try container.decode(TwitterParameters.self, forKey: .twitterParameters)
                self = .twitterParameters(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .amazonElasticsearchParameters(let value):
                try container.encode(value, forKey: .amazonElasticsearchParameters)
            case .amazonOpenSearchParameters(let value):
                try container.encode(value, forKey: .amazonOpenSearchParameters)
            case .athenaParameters(let value):
                try container.encode(value, forKey: .athenaParameters)
            case .auroraParameters(let value):
                try container.encode(value, forKey: .auroraParameters)
            case .auroraPostgreSqlParameters(let value):
                try container.encode(value, forKey: .auroraPostgreSqlParameters)
            case .awsIotAnalyticsParameters(let value):
                try container.encode(value, forKey: .awsIotAnalyticsParameters)
            case .databricksParameters(let value):
                try container.encode(value, forKey: .databricksParameters)
            case .exasolParameters(let value):
                try container.encode(value, forKey: .exasolParameters)
            case .jiraParameters(let value):
                try container.encode(value, forKey: .jiraParameters)
            case .mariaDbParameters(let value):
                try container.encode(value, forKey: .mariaDbParameters)
            case .mySqlParameters(let value):
                try container.encode(value, forKey: .mySqlParameters)
            case .oracleParameters(let value):
                try container.encode(value, forKey: .oracleParameters)
            case .postgreSqlParameters(let value):
                try container.encode(value, forKey: .postgreSqlParameters)
            case .prestoParameters(let value):
                try container.encode(value, forKey: .prestoParameters)
            case .rdsParameters(let value):
                try container.encode(value, forKey: .rdsParameters)
            case .redshiftParameters(let value):
                try container.encode(value, forKey: .redshiftParameters)
            case .s3Parameters(let value):
                try container.encode(value, forKey: .s3Parameters)
            case .serviceNowParameters(let value):
                try container.encode(value, forKey: .serviceNowParameters)
            case .snowflakeParameters(let value):
                try container.encode(value, forKey: .snowflakeParameters)
            case .sparkParameters(let value):
                try container.encode(value, forKey: .sparkParameters)
            case .sqlServerParameters(let value):
                try container.encode(value, forKey: .sqlServerParameters)
            case .teradataParameters(let value):
                try container.encode(value, forKey: .teradataParameters)
            case .twitterParameters(let value):
                try container.encode(value, forKey: .twitterParameters)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .amazonElasticsearchParameters(let value):
                try value.validate(name: "\(name).amazonElasticsearchParameters")
            case .amazonOpenSearchParameters(let value):
                try value.validate(name: "\(name).amazonOpenSearchParameters")
            case .athenaParameters(let value):
                try value.validate(name: "\(name).athenaParameters")
            case .auroraParameters(let value):
                try value.validate(name: "\(name).auroraParameters")
            case .auroraPostgreSqlParameters(let value):
                try value.validate(name: "\(name).auroraPostgreSqlParameters")
            case .awsIotAnalyticsParameters(let value):
                try value.validate(name: "\(name).awsIotAnalyticsParameters")
            case .databricksParameters(let value):
                try value.validate(name: "\(name).databricksParameters")
            case .exasolParameters(let value):
                try value.validate(name: "\(name).exasolParameters")
            case .jiraParameters(let value):
                try value.validate(name: "\(name).jiraParameters")
            case .mariaDbParameters(let value):
                try value.validate(name: "\(name).mariaDbParameters")
            case .mySqlParameters(let value):
                try value.validate(name: "\(name).mySqlParameters")
            case .oracleParameters(let value):
                try value.validate(name: "\(name).oracleParameters")
            case .postgreSqlParameters(let value):
                try value.validate(name: "\(name).postgreSqlParameters")
            case .prestoParameters(let value):
                try value.validate(name: "\(name).prestoParameters")
            case .rdsParameters(let value):
                try value.validate(name: "\(name).rdsParameters")
            case .redshiftParameters(let value):
                try value.validate(name: "\(name).redshiftParameters")
            case .s3Parameters(let value):
                try value.validate(name: "\(name).s3Parameters")
            case .serviceNowParameters(let value):
                try value.validate(name: "\(name).serviceNowParameters")
            case .snowflakeParameters(let value):
                try value.validate(name: "\(name).snowflakeParameters")
            case .sparkParameters(let value):
                try value.validate(name: "\(name).sparkParameters")
            case .sqlServerParameters(let value):
                try value.validate(name: "\(name).sqlServerParameters")
            case .teradataParameters(let value):
                try value.validate(name: "\(name).teradataParameters")
            case .twitterParameters(let value):
                try value.validate(name: "\(name).twitterParameters")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case amazonElasticsearchParameters = "AmazonElasticsearchParameters"
            case amazonOpenSearchParameters = "AmazonOpenSearchParameters"
            case athenaParameters = "AthenaParameters"
            case auroraParameters = "AuroraParameters"
            case auroraPostgreSqlParameters = "AuroraPostgreSqlParameters"
            case awsIotAnalyticsParameters = "AwsIotAnalyticsParameters"
            case databricksParameters = "DatabricksParameters"
            case exasolParameters = "ExasolParameters"
            case jiraParameters = "JiraParameters"
            case mariaDbParameters = "MariaDbParameters"
            case mySqlParameters = "MySqlParameters"
            case oracleParameters = "OracleParameters"
            case postgreSqlParameters = "PostgreSqlParameters"
            case prestoParameters = "PrestoParameters"
            case rdsParameters = "RdsParameters"
            case redshiftParameters = "RedshiftParameters"
            case s3Parameters = "S3Parameters"
            case serviceNowParameters = "ServiceNowParameters"
            case snowflakeParameters = "SnowflakeParameters"
            case sparkParameters = "SparkParameters"
            case sqlServerParameters = "SqlServerParameters"
            case teradataParameters = "TeradataParameters"
            case twitterParameters = "TwitterParameters"
        }
    }

    public enum PhysicalTable: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// A physical table type built from the results of the custom SQL query.
        case customSql(CustomSql)
        /// A physical table type for relational data sources.
        case relationalTable(RelationalTable)
        /// A physical table type for as S3 data source.
        case s3Source(S3Source)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customSql:
                let value = try container.decode(CustomSql.self, forKey: .customSql)
                self = .customSql(value)
            case .relationalTable:
                let value = try container.decode(RelationalTable.self, forKey: .relationalTable)
                self = .relationalTable(value)
            case .s3Source:
                let value = try container.decode(S3Source.self, forKey: .s3Source)
                self = .s3Source(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customSql(let value):
                try container.encode(value, forKey: .customSql)
            case .relationalTable(let value):
                try container.encode(value, forKey: .relationalTable)
            case .s3Source(let value):
                try container.encode(value, forKey: .s3Source)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customSql(let value):
                try value.validate(name: "\(name).customSql")
            case .relationalTable(let value):
                try value.validate(name: "\(name).relationalTable")
            case .s3Source(let value):
                try value.validate(name: "\(name).s3Source")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customSql = "CustomSql"
            case relationalTable = "RelationalTable"
            case s3Source = "S3Source"
        }
    }

    public enum TransformOperation: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// A transform operation that casts a column to a different type.
        case castColumnTypeOperation(CastColumnTypeOperation)
        /// An operation that creates calculated columns. Columns created in one such operation form a lexical closure.
        case createColumnsOperation(CreateColumnsOperation)
        /// An operation that filters rows based on some condition.
        case filterOperation(FilterOperation)
        /// An operation that projects columns. Operations that come after a projection can only refer to projected columns.
        case projectOperation(ProjectOperation)
        /// An operation that renames a column.
        case renameColumnOperation(RenameColumnOperation)
        /// An operation that tags a column with additional information.
        case tagColumnOperation(TagColumnOperation)
        case untagColumnOperation(UntagColumnOperation)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .castColumnTypeOperation:
                let value = try container.decode(CastColumnTypeOperation.self, forKey: .castColumnTypeOperation)
                self = .castColumnTypeOperation(value)
            case .createColumnsOperation:
                let value = try container.decode(CreateColumnsOperation.self, forKey: .createColumnsOperation)
                self = .createColumnsOperation(value)
            case .filterOperation:
                let value = try container.decode(FilterOperation.self, forKey: .filterOperation)
                self = .filterOperation(value)
            case .projectOperation:
                let value = try container.decode(ProjectOperation.self, forKey: .projectOperation)
                self = .projectOperation(value)
            case .renameColumnOperation:
                let value = try container.decode(RenameColumnOperation.self, forKey: .renameColumnOperation)
                self = .renameColumnOperation(value)
            case .tagColumnOperation:
                let value = try container.decode(TagColumnOperation.self, forKey: .tagColumnOperation)
                self = .tagColumnOperation(value)
            case .untagColumnOperation:
                let value = try container.decode(UntagColumnOperation.self, forKey: .untagColumnOperation)
                self = .untagColumnOperation(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .castColumnTypeOperation(let value):
                try container.encode(value, forKey: .castColumnTypeOperation)
            case .createColumnsOperation(let value):
                try container.encode(value, forKey: .createColumnsOperation)
            case .filterOperation(let value):
                try container.encode(value, forKey: .filterOperation)
            case .projectOperation(let value):
                try container.encode(value, forKey: .projectOperation)
            case .renameColumnOperation(let value):
                try container.encode(value, forKey: .renameColumnOperation)
            case .tagColumnOperation(let value):
                try container.encode(value, forKey: .tagColumnOperation)
            case .untagColumnOperation(let value):
                try container.encode(value, forKey: .untagColumnOperation)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .castColumnTypeOperation(let value):
                try value.validate(name: "\(name).castColumnTypeOperation")
            case .createColumnsOperation(let value):
                try value.validate(name: "\(name).createColumnsOperation")
            case .filterOperation(let value):
                try value.validate(name: "\(name).filterOperation")
            case .projectOperation(let value):
                try value.validate(name: "\(name).projectOperation")
            case .renameColumnOperation(let value):
                try value.validate(name: "\(name).renameColumnOperation")
            case .tagColumnOperation(let value):
                try value.validate(name: "\(name).tagColumnOperation")
            case .untagColumnOperation(let value):
                try value.validate(name: "\(name).untagColumnOperation")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case castColumnTypeOperation = "CastColumnTypeOperation"
            case createColumnsOperation = "CreateColumnsOperation"
            case filterOperation = "FilterOperation"
            case projectOperation = "ProjectOperation"
            case renameColumnOperation = "RenameColumnOperation"
            case tagColumnOperation = "TagColumnOperation"
            case untagColumnOperation = "UntagColumnOperation"
        }
    }

    // MARK: Shapes

    public struct AccountCustomization: AWSEncodableShape & AWSDecodableShape {
        /// The default email customization template.
        public let defaultEmailCustomizationTemplate: String?
        /// The default theme for this Amazon QuickSight subscription.
        public let defaultTheme: String?

        public init(defaultEmailCustomizationTemplate: String? = nil, defaultTheme: String? = nil) {
            self.defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplate
            self.defaultTheme = defaultTheme
        }

        private enum CodingKeys: String, CodingKey {
            case defaultEmailCustomizationTemplate = "DefaultEmailCustomizationTemplate"
            case defaultTheme = "DefaultTheme"
        }
    }

    public struct AccountInfo: AWSDecodableShape {
        /// The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.
        public let accountName: String?
        /// The status of your account subscription.
        public let accountSubscriptionStatus: String?
        /// The way that your Amazon QuickSight account is authenticated.
        public let authenticationType: String?
        /// The edition of your Amazon QuickSight account.
        public let edition: Edition?
        /// The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.
        public let notificationEmail: String?

        public init(accountName: String? = nil, accountSubscriptionStatus: String? = nil, authenticationType: String? = nil, edition: Edition? = nil, notificationEmail: String? = nil) {
            self.accountName = accountName
            self.accountSubscriptionStatus = accountSubscriptionStatus
            self.authenticationType = authenticationType
            self.edition = edition
            self.notificationEmail = notificationEmail
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "AccountName"
            case accountSubscriptionStatus = "AccountSubscriptionStatus"
            case authenticationType = "AuthenticationType"
            case edition = "Edition"
            case notificationEmail = "NotificationEmail"
        }
    }

    public struct AccountSettings: AWSDecodableShape {
        /// The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.
        public let accountName: String?
        /// The default Amazon QuickSight namespace for your Amazon Web Services account.
        public let defaultNamespace: String?
        /// The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.
        public let edition: Edition?
        /// The main notification email for your Amazon QuickSight subscription.
        public let notificationEmail: String?
        /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see UpdatePublicSharingSettings.
        public let publicSharingEnabled: Bool?
        /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubsctiption request. A False value will allow the ccount to be deleted.
        public let terminationProtectionEnabled: Bool?

        public init(accountName: String? = nil, defaultNamespace: String? = nil, edition: Edition? = nil, notificationEmail: String? = nil, publicSharingEnabled: Bool? = nil, terminationProtectionEnabled: Bool? = nil) {
            self.accountName = accountName
            self.defaultNamespace = defaultNamespace
            self.edition = edition
            self.notificationEmail = notificationEmail
            self.publicSharingEnabled = publicSharingEnabled
            self.terminationProtectionEnabled = terminationProtectionEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "AccountName"
            case defaultNamespace = "DefaultNamespace"
            case edition = "Edition"
            case notificationEmail = "NotificationEmail"
            case publicSharingEnabled = "PublicSharingEnabled"
            case terminationProtectionEnabled = "TerminationProtectionEnabled"
        }
    }

    public struct ActiveIAMPolicyAssignment: AWSDecodableShape {
        /// A name for the IAM policy assignment.
        public let assignmentName: String?
        /// The Amazon Resource Name (ARN) of the resource.
        public let policyArn: String?

        public init(assignmentName: String? = nil, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.policyArn = policyArn
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case policyArn = "PolicyArn"
        }
    }

    public struct AdHocFilteringOption: AWSEncodableShape {
        /// Availability status.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct AggregationFunction: AWSEncodableShape & AWSDecodableShape {
        /// Aggregation for categorical values.    COUNT: Aggregate by the total number of values, including duplicates.    DISTINCT_COUNT: Aggregate by the total number of distinct values.
        public let categoricalAggregationFunction: CategoricalAggregationFunction?
        /// Aggregation for date values.    COUNT: Aggregate by the total number of values, including duplicates.    DISTINCT_COUNT: Aggregate by the total number of distinct values.    MIN: Select the smallest date value.    MAX: Select the largest date value.
        public let dateAggregationFunction: DateAggregationFunction?
        /// Aggregation for numerical values.
        public let numericalAggregationFunction: NumericalAggregationFunction?

        public init(categoricalAggregationFunction: CategoricalAggregationFunction? = nil, dateAggregationFunction: DateAggregationFunction? = nil, numericalAggregationFunction: NumericalAggregationFunction? = nil) {
            self.categoricalAggregationFunction = categoricalAggregationFunction
            self.dateAggregationFunction = dateAggregationFunction
            self.numericalAggregationFunction = numericalAggregationFunction
        }

        public func validate(name: String) throws {
            try self.numericalAggregationFunction?.validate(name: "\(name).numericalAggregationFunction")
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalAggregationFunction = "CategoricalAggregationFunction"
            case dateAggregationFunction = "DateAggregationFunction"
            case numericalAggregationFunction = "NumericalAggregationFunction"
        }
    }

    public struct AggregationSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The function that aggregates the values in Column.
        public let aggregationFunction: AggregationFunction
        /// The column that determines the sort order of aggregated values.
        public let column: ColumnIdentifier
        /// The sort direction of values.    ASC: Sort in ascending order.    DESC: Sort in descending order.
        public let sortDirection: SortDirection

        public init(aggregationFunction: AggregationFunction, column: ColumnIdentifier, sortDirection: SortDirection) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.sortDirection = sortDirection
        }

        public func validate(name: String) throws {
            try self.aggregationFunction.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case sortDirection = "SortDirection"
        }
    }

    public struct AmazonElasticsearchParameters: AWSEncodableShape & AWSDecodableShape {
        /// The OpenSearch domain.
        public let domain: String

        public init(domain: String) {
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 64)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
        }
    }

    public struct AmazonOpenSearchParameters: AWSEncodableShape & AWSDecodableShape {
        /// The OpenSearch domain.
        public let domain: String

        public init(domain: String) {
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 64)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
        }
    }

    public struct Analysis: AWSDecodableShape {
        /// The ID of the analysis.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the analysis.
        public let arn: String?
        /// The time that the analysis was created.
        public let createdTime: Date?
        /// The ARNs of the datasets of the analysis.
        public let dataSetArns: [String]?
        /// Errors associated with the analysis.
        public let errors: [AnalysisError]?
        /// The time that the analysis was last updated.
        public let lastUpdatedTime: Date?
        /// The descriptive name of the analysis.
        public let name: String?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// Status associated with the analysis.
        public let status: ResourceStatus?
        /// The ARN of the theme of the analysis.
        public let themeArn: String?

        public init(analysisId: String? = nil, arn: String? = nil, createdTime: Date? = nil, dataSetArns: [String]? = nil, errors: [AnalysisError]? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, sheets: [Sheet]? = nil, status: ResourceStatus? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.errors = errors
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sheets = sheets
            self.status = status
            self.themeArn = themeArn
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSetArns = "DataSetArns"
            case errors = "Errors"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case sheets = "Sheets"
            case status = "Status"
            case themeArn = "ThemeArn"
        }
    }

    public struct AnalysisDefaults: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for default new sheet settings.
        public let defaultNewSheetConfiguration: DefaultNewSheetConfiguration

        public init(defaultNewSheetConfiguration: DefaultNewSheetConfiguration) {
            self.defaultNewSheetConfiguration = defaultNewSheetConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case defaultNewSheetConfiguration = "DefaultNewSheetConfiguration"
        }
    }

    public struct AnalysisDefinition: AWSEncodableShape & AWSDecodableShape {
        public let analysisDefaults: AnalysisDefaults?
        /// An array of calculated field definitions for the analysis.
        public let calculatedFields: [CalculatedField]?
        ///  An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis.
        public let columnConfigurations: [ColumnConfiguration]?
        /// An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.
        public let dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration]
        /// Filter definitions for an analysis. For more information, see Filtering Data in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let filterGroups: [FilterGroup]?
        /// An array of parameter declarations for an analysis. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see Parameters in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterDeclarations: [ParameterDeclaration]?
        /// An array of sheet definitions for an analysis. Each SheetDefinition provides detailed information about a sheet within this analysis.
        public let sheets: [SheetDefinition]?

        public init(analysisDefaults: AnalysisDefaults? = nil, calculatedFields: [CalculatedField]? = nil, columnConfigurations: [ColumnConfiguration]? = nil, dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration], filterGroups: [FilterGroup]? = nil, parameterDeclarations: [ParameterDeclaration]? = nil, sheets: [SheetDefinition]? = nil) {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }

        public func validate(name: String) throws {
            try self.calculatedFields?.forEach {
                try $0.validate(name: "\(name).calculatedFields[]")
            }
            try self.validate(self.calculatedFields, name: "calculatedFields", parent: name, max: 100)
            try self.columnConfigurations?.forEach {
                try $0.validate(name: "\(name).columnConfigurations[]")
            }
            try self.validate(self.columnConfigurations, name: "columnConfigurations", parent: name, max: 200)
            try self.dataSetIdentifierDeclarations.forEach {
                try $0.validate(name: "\(name).dataSetIdentifierDeclarations[]")
            }
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, max: 50)
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, min: 1)
            try self.filterGroups?.forEach {
                try $0.validate(name: "\(name).filterGroups[]")
            }
            try self.validate(self.filterGroups, name: "filterGroups", parent: name, max: 2000)
            try self.parameterDeclarations?.forEach {
                try $0.validate(name: "\(name).parameterDeclarations[]")
            }
            try self.validate(self.parameterDeclarations, name: "parameterDeclarations", parent: name, max: 200)
            try self.sheets?.forEach {
                try $0.validate(name: "\(name).sheets[]")
            }
            try self.validate(self.sheets, name: "sheets", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisDefaults = "AnalysisDefaults"
            case calculatedFields = "CalculatedFields"
            case columnConfigurations = "ColumnConfigurations"
            case dataSetIdentifierDeclarations = "DataSetIdentifierDeclarations"
            case filterGroups = "FilterGroups"
            case parameterDeclarations = "ParameterDeclarations"
            case sheets = "Sheets"
        }
    }

    public struct AnalysisError: AWSDecodableShape {
        /// The message associated with the analysis error.
        public let message: String?
        /// The type of the analysis error.
        public let type: AnalysisErrorType?
        public let violatedEntities: [Entity]?

        public init(message: String? = nil, type: AnalysisErrorType? = nil, violatedEntities: [Entity]? = nil) {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
            case violatedEntities = "ViolatedEntities"
        }
    }

    public struct AnalysisSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered.     QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered.     ANALYSIS_NAME: Any analyses whose names have a substring match to this value will be returned.
        public let name: AnalysisFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example  "Operator": "StringEquals". Valid values are  "StringEquals"  and  "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example,  "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value ANALYSIS_NAME.
        public let `operator`: FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example "Value". An example is "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String?

        public init(name: AnalysisFilterAttribute? = nil, operator: FilterOperator? = nil, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct AnalysisSourceEntity: AWSEncodableShape {
        /// The source template for the source entity of the analysis.
        public let sourceTemplate: AnalysisSourceTemplate?

        public init(sourceTemplate: AnalysisSourceTemplate? = nil) {
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceTemplate?.validate(name: "\(name).sourceTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct AnalysisSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the source template of an analysis.
        public let arn: String
        /// The dataset references of the source template of an analysis.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct AnalysisSummary: AWSDecodableShape {
        /// The ID of the analysis. This ID displays in the URL.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) for the analysis.
        public let arn: String?
        /// The time that the analysis was created.
        public let createdTime: Date?
        /// The time that the analysis was last updated.
        public let lastUpdatedTime: Date?
        /// The name of the analysis. This name is displayed in the Amazon QuickSight console.
        public let name: String?
        /// The last known status for the analysis.
        public let status: ResourceStatus?

        public init(analysisId: String? = nil, arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, status: ResourceStatus? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct AnchorDateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options for the date configuration. Choose one of the options below:    NOW
        public let anchorOption: AnchorOption?
        /// The name of the parameter that is used for the anchor date configuration.
        public let parameterName: String?

        public init(anchorOption: AnchorOption? = nil, parameterName: String? = nil) {
            self.anchorOption = anchorOption
            self.parameterName = parameterName
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anchorOption = "AnchorOption"
            case parameterName = "ParameterName"
        }
    }

    public struct AnonymousUserDashboardEmbeddingConfiguration: AWSEncodableShape {
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard. The Amazon Resource Name (ARN) of this dashboard must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialDashboardId: String

        public init(initialDashboardId: String) {
            self.initialDashboardId = initialDashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, max: 512)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, min: 1)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initialDashboardId = "InitialDashboardId"
        }
    }

    public struct AnonymousUserDashboardVisualEmbeddingConfiguration: AWSEncodableShape {
        /// The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialDashboardVisualId: DashboardVisualId

        public init(initialDashboardVisualId: DashboardVisualId) {
            self.initialDashboardVisualId = initialDashboardVisualId
        }

        public func validate(name: String) throws {
            try self.initialDashboardVisualId.validate(name: "\(name).initialDashboardVisualId")
        }

        private enum CodingKeys: String, CodingKey {
            case initialDashboardVisualId = "InitialDashboardVisualId"
        }
    }

    public struct AnonymousUserEmbeddingExperienceConfiguration: AWSEncodableShape {
        /// The type of embedding experience. In this case, Amazon QuickSight dashboards.
        public let dashboard: AnonymousUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public let dashboardVisual: AnonymousUserDashboardVisualEmbeddingConfiguration?
        /// The Q search bar that you want to use for anonymous user embedding.
        public let qSearchBar: AnonymousUserQSearchBarEmbeddingConfiguration?

        public init(dashboard: AnonymousUserDashboardEmbeddingConfiguration? = nil, dashboardVisual: AnonymousUserDashboardVisualEmbeddingConfiguration? = nil, qSearchBar: AnonymousUserQSearchBarEmbeddingConfiguration? = nil) {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.qSearchBar = qSearchBar
        }

        public func validate(name: String) throws {
            try self.dashboard?.validate(name: "\(name).dashboard")
            try self.dashboardVisual?.validate(name: "\(name).dashboardVisual")
            try self.qSearchBar?.validate(name: "\(name).qSearchBar")
        }

        private enum CodingKeys: String, CodingKey {
            case dashboard = "Dashboard"
            case dashboardVisual = "DashboardVisual"
            case qSearchBar = "QSearchBar"
        }
    }

    public struct AnonymousUserQSearchBarEmbeddingConfiguration: AWSEncodableShape {
        /// The QuickSight Q topic ID of the topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this topic pre-selected. The Amazon Resource Name (ARN) of this Q topic must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialTopicId: String

        public init(initialTopicId: String) {
            self.initialTopicId = initialTopicId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, max: 2048)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, min: 1)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initialTopicId = "InitialTopicId"
        }
    }

    public struct ArcAxisConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The arc axis range of a GaugeChartVisual.
        public let range: ArcAxisDisplayRange?
        /// The reserved range of the arc axis.
        public let reserveRange: Int?

        public init(range: ArcAxisDisplayRange? = nil, reserveRange: Int? = nil) {
            self.range = range
            self.reserveRange = reserveRange
        }

        private enum CodingKeys: String, CodingKey {
            case range = "Range"
            case reserveRange = "ReserveRange"
        }
    }

    public struct ArcAxisDisplayRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum value of the arc axis range.
        public let max: Double?
        /// The minimum value of the arc axis range.
        public let min: Double?

        public init(max: Double? = nil, min: Double? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct ArcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the arc angle of a GaugeChartVisual.
        public let arcAngle: Double?
        /// The options that determine the arc thickness of a GaugeChartVisual.
        public let arcThickness: ArcThicknessOptions?

        public init(arcAngle: Double? = nil, arcThickness: ArcThicknessOptions? = nil) {
            self.arcAngle = arcAngle
            self.arcThickness = arcThickness
        }

        private enum CodingKeys: String, CodingKey {
            case arcAngle = "ArcAngle"
            case arcThickness = "ArcThickness"
        }
    }

    public struct ArcOptions: AWSEncodableShape & AWSDecodableShape {
        /// The arc thickness of a GaugeChartVisual.
        public let arcThickness: ArcThickness?

        public init(arcThickness: ArcThickness? = nil) {
            self.arcThickness = arcThickness
        }

        private enum CodingKeys: String, CodingKey {
            case arcThickness = "ArcThickness"
        }
    }

    public struct AthenaParameters: AWSEncodableShape & AWSDecodableShape {
        /// Use the RoleArn structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use RoleArn to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.
        public let roleArn: String?
        /// The workgroup that Amazon Athena uses.
        public let workGroup: String?

        public init(roleArn: String? = nil, workGroup: String? = nil) {
            self.roleArn = roleArn
            self.workGroup = workGroup
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.workGroup, name: "workGroup", parent: name, max: 128)
            try self.validate(self.workGroup, name: "workGroup", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case workGroup = "WorkGroup"
        }
    }

    public struct AuroraParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct AuroraPostgreSqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Aurora PostgreSQL database to connect to.
        public let database: String
        /// The Amazon Aurora PostgreSQL-Compatible host to connect to.
        public let host: String
        /// The port that Amazon Aurora PostgreSQL is listening on.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct AwsIotAnalyticsParameters: AWSEncodableShape & AWSDecodableShape {
        /// Dataset name.
        public let dataSetName: String

        public init(dataSetName: String) {
            self.dataSetName = dataSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, max: 128)
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetName = "DataSetName"
        }
    }

    public struct AxisDataOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options for an axis with a date field.
        public let dateAxisOptions: DateAxisOptions?
        /// The options for an axis with a numeric field.
        public let numericAxisOptions: NumericAxisOptions?

        public init(dateAxisOptions: DateAxisOptions? = nil, numericAxisOptions: NumericAxisOptions? = nil) {
            self.dateAxisOptions = dateAxisOptions
            self.numericAxisOptions = numericAxisOptions
        }

        private enum CodingKeys: String, CodingKey {
            case dateAxisOptions = "DateAxisOptions"
            case numericAxisOptions = "NumericAxisOptions"
        }
    }

    public struct AxisDisplayDataDrivenRange: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AxisDisplayMinMaxRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum setup for an axis display range.
        public let maximum: Double?
        /// The minimum setup for an axis display range.
        public let minimum: Double?

        public init(maximum: Double? = nil, minimum: Double? = nil) {
            self.maximum = maximum
            self.minimum = minimum
        }

        private enum CodingKeys: String, CodingKey {
            case maximum = "Maximum"
            case minimum = "Minimum"
        }
    }

    public struct AxisDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not the axis line is visible.
        public let axisLineVisibility: Visibility?
        /// The offset value that determines the starting placement of the axis within a visual's bounds.
        public let axisOffset: String?
        /// The data options for an axis.
        public let dataOptions: AxisDataOptions?
        /// Determines whether or not the grid line is visible.
        public let gridLineVisibility: Visibility?
        /// The scroll bar options for an axis.
        public let scrollbarOptions: ScrollBarOptions?
        /// The tick label options of an axis.
        public let tickLabelOptions: AxisTickLabelOptions?

        public init(axisLineVisibility: Visibility? = nil, axisOffset: String? = nil, dataOptions: AxisDataOptions? = nil, gridLineVisibility: Visibility? = nil, scrollbarOptions: ScrollBarOptions? = nil, tickLabelOptions: AxisTickLabelOptions? = nil) {
            self.axisLineVisibility = axisLineVisibility
            self.axisOffset = axisOffset
            self.dataOptions = dataOptions
            self.gridLineVisibility = gridLineVisibility
            self.scrollbarOptions = scrollbarOptions
            self.tickLabelOptions = tickLabelOptions
        }

        public func validate(name: String) throws {
            try self.scrollbarOptions?.validate(name: "\(name).scrollbarOptions")
            try self.tickLabelOptions?.validate(name: "\(name).tickLabelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case axisLineVisibility = "AxisLineVisibility"
            case axisOffset = "AxisOffset"
            case dataOptions = "DataOptions"
            case gridLineVisibility = "GridLineVisibility"
            case scrollbarOptions = "ScrollbarOptions"
            case tickLabelOptions = "TickLabelOptions"
        }
    }

    public struct AxisDisplayRange: AWSEncodableShape & AWSDecodableShape {
        /// The data-driven setup of an axis display range.
        public let dataDriven: AxisDisplayDataDrivenRange?
        /// The minimum and maximum setup of an axis display range.
        public let minMax: AxisDisplayMinMaxRange?

        public init(dataDriven: AxisDisplayDataDrivenRange? = nil, minMax: AxisDisplayMinMaxRange? = nil) {
            self.dataDriven = dataDriven
            self.minMax = minMax
        }

        private enum CodingKeys: String, CodingKey {
            case dataDriven = "DataDriven"
            case minMax = "MinMax"
        }
    }

    public struct AxisLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that indicate which field the label belongs to.
        public let applyTo: AxisLabelReferenceOptions?
        /// The text for the axis label.
        public let customLabel: String?
        /// The font configuration of the axis label.
        public let fontConfiguration: FontConfiguration?

        public init(applyTo: AxisLabelReferenceOptions? = nil, customLabel: String? = nil, fontConfiguration: FontConfiguration? = nil) {
            self.applyTo = applyTo
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
        }

        public func validate(name: String) throws {
            try self.applyTo?.validate(name: "\(name).applyTo")
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applyTo = "ApplyTo"
            case customLabel = "CustomLabel"
            case fontConfiguration = "FontConfiguration"
        }
    }

    public struct AxisLabelReferenceOptions: AWSEncodableShape & AWSDecodableShape {
        /// The column that the axis label is targeted to.
        public let column: ColumnIdentifier
        /// The field that the axis label is targeted to.
        public let fieldId: String

        public init(column: ColumnIdentifier, fieldId: String) {
            self.column = column
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
        }
    }

    public struct AxisLinearScale: AWSEncodableShape & AWSDecodableShape {
        /// The step count setup of a linear axis.
        public let stepCount: Int?
        /// The step size setup of a linear axis.
        public let stepSize: Double?

        public init(stepCount: Int? = nil, stepSize: Double? = nil) {
            self.stepCount = stepCount
            self.stepSize = stepSize
        }

        private enum CodingKeys: String, CodingKey {
            case stepCount = "StepCount"
            case stepSize = "StepSize"
        }
    }

    public struct AxisLogarithmicScale: AWSEncodableShape & AWSDecodableShape {
        /// The base setup of a logarithmic axis scale.
        public let base: Double?

        public init(base: Double? = nil) {
            self.base = base
        }

        private enum CodingKeys: String, CodingKey {
            case base = "Base"
        }
    }

    public struct AxisScale: AWSEncodableShape & AWSDecodableShape {
        /// The linear axis scale setup.
        public let linear: AxisLinearScale?
        /// The logarithmic axis scale setup.
        public let logarithmic: AxisLogarithmicScale?

        public init(linear: AxisLinearScale? = nil, logarithmic: AxisLogarithmicScale? = nil) {
            self.linear = linear
            self.logarithmic = logarithmic
        }

        private enum CodingKeys: String, CodingKey {
            case linear = "Linear"
            case logarithmic = "Logarithmic"
        }
    }

    public struct AxisTickLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not the axis ticks are visible.
        public let labelOptions: LabelOptions?
        /// The rotation angle of the axis tick labels.
        public let rotationAngle: Double?

        public init(labelOptions: LabelOptions? = nil, rotationAngle: Double? = nil) {
            self.labelOptions = labelOptions
            self.rotationAngle = rotationAngle
        }

        public func validate(name: String) throws {
            try self.labelOptions?.validate(name: "\(name).labelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case labelOptions = "LabelOptions"
            case rotationAngle = "RotationAngle"
        }
    }

    public struct BarChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category (y-axis) field well of a bar chart.
        public let category: [DimensionField]?
        /// The color (group/color) field well of a bar chart.
        public let colors: [DimensionField]?
        /// The small multiples field well of a bar chart.
        public let smallMultiples: [DimensionField]?
        /// The value field wells of a bar chart. Values are aggregated by category.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, colors: [DimensionField]? = nil, smallMultiples: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.smallMultiples?.forEach {
                try $0.validate(name: "\(name).smallMultiples[]")
            }
            try self.validate(self.smallMultiples, name: "smallMultiples", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case colors = "Colors"
            case smallMultiples = "SmallMultiples"
            case values = "Values"
        }
    }

    public struct BarChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.
        public let barsArrangement: BarsArrangement?
        /// The label display options (grid line, range, scale, axis step) for bar chart category.
        public let categoryAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.
        public let colorLabelOptions: ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public let contributionAnalysisDefaults: [ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: BarChartFieldWells?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The orientation of the bars in a bar chart visual. There are two valid values in this structure:    HORIZONTAL: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.    VERTICAL: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.
        public let orientation: BarChartOrientation?
        /// The reference line setup of the visual.
        public let referenceLines: [ReferenceLine]?
        /// The small multiples setup for the visual.
        public let smallMultiplesOptions: SmallMultiplesOptions?
        /// The sort configuration of a BarChartVisual.
        public let sortConfiguration: BarChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The label display options (grid line, range, scale, axis step) for a bar chart value.
        public let valueAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart value.
        public let valueLabelOptions: ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(barsArrangement: BarsArrangement? = nil, categoryAxis: AxisDisplayOptions? = nil, categoryLabelOptions: ChartAxisLabelOptions? = nil, colorLabelOptions: ChartAxisLabelOptions? = nil, contributionAnalysisDefaults: [ContributionAnalysisDefault]? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: BarChartFieldWells? = nil, legend: LegendOptions? = nil, orientation: BarChartOrientation? = nil, referenceLines: [ReferenceLine]? = nil, smallMultiplesOptions: SmallMultiplesOptions? = nil, sortConfiguration: BarChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, valueAxis: AxisDisplayOptions? = nil, valueLabelOptions: ChartAxisLabelOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.orientation = orientation
            self.referenceLines = referenceLines
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueAxis = valueAxis
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryAxis?.validate(name: "\(name).categoryAxis")
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.colorLabelOptions?.validate(name: "\(name).colorLabelOptions")
            try self.contributionAnalysisDefaults?.forEach {
                try $0.validate(name: "\(name).contributionAnalysisDefaults[]")
            }
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, max: 200)
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, min: 1)
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.smallMultiplesOptions?.validate(name: "\(name).smallMultiplesOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.valueAxis?.validate(name: "\(name).valueAxis")
            try self.valueLabelOptions?.validate(name: "\(name).valueLabelOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case barsArrangement = "BarsArrangement"
            case categoryAxis = "CategoryAxis"
            case categoryLabelOptions = "CategoryLabelOptions"
            case colorLabelOptions = "ColorLabelOptions"
            case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case orientation = "Orientation"
            case referenceLines = "ReferenceLines"
            case smallMultiplesOptions = "SmallMultiplesOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case valueAxis = "ValueAxis"
            case valueLabelOptions = "ValueLabelOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct BarChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a bar chart.
        public let barChartAggregatedFieldWells: BarChartAggregatedFieldWells?

        public init(barChartAggregatedFieldWells: BarChartAggregatedFieldWells? = nil) {
            self.barChartAggregatedFieldWells = barChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.barChartAggregatedFieldWells?.validate(name: "\(name).barChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case barChartAggregatedFieldWells = "BarChartAggregatedFieldWells"
        }
    }

    public struct BarChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories displayed in a bar chart.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of category fields.
        public let categorySort: [FieldSortOptions]?
        /// The limit on the number of values displayed in a bar chart.
        public let colorItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of color fields in a bar chart.
        public let colorSort: [FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public let smallMultiplesLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public let smallMultiplesSort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, colorItemsLimit: ItemsLimitConfiguration? = nil, colorSort: [FieldSortOptions]? = nil, smallMultiplesLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.colorSort?.forEach {
                try $0.validate(name: "\(name).colorSort[]")
            }
            try self.validate(self.colorSort, name: "colorSort", parent: name, max: 100)
            try self.smallMultiplesSort?.forEach {
                try $0.validate(name: "\(name).smallMultiplesSort[]")
            }
            try self.validate(self.smallMultiplesSort, name: "smallMultiplesSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
            case colorItemsLimit = "ColorItemsLimit"
            case colorSort = "ColorSort"
            case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
            case smallMultiplesSort = "SmallMultiplesSort"
        }
    }

    public struct BarChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: BarChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: BarChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct BinCountOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the bin count value.
        public let value: Int?

        public init(value: Int? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct BinWidthOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the bin count limit.
        public let binCountLimit: Int64?
        /// The options that determine the bin width value.
        public let value: Double?

        public init(binCountLimit: Int64? = nil, value: Double? = nil) {
            self.binCountLimit = binCountLimit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.binCountLimit, name: "binCountLimit", parent: name, max: 1000)
            try self.validate(self.binCountLimit, name: "binCountLimit", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case binCountLimit = "BinCountLimit"
            case value = "Value"
        }
    }

    public struct BodySectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of content in a body section.
        public let content: BodySectionContent
        /// The configuration of a page break for a section.
        public let pageBreakConfiguration: SectionPageBreakConfiguration?
        /// The unique identifier of a body section.
        public let sectionId: String
        /// The style options of a body section.
        public let style: SectionStyle?

        public init(content: BodySectionContent, pageBreakConfiguration: SectionPageBreakConfiguration? = nil, sectionId: String, style: SectionStyle? = nil) {
            self.content = content
            self.pageBreakConfiguration = pageBreakConfiguration
            self.sectionId = sectionId
            self.style = style
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
            try self.validate(self.sectionId, name: "sectionId", parent: name, max: 512)
            try self.validate(self.sectionId, name: "sectionId", parent: name, min: 1)
            try self.validate(self.sectionId, name: "sectionId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case pageBreakConfiguration = "PageBreakConfiguration"
            case sectionId = "SectionId"
            case style = "Style"
        }
    }

    public struct BodySectionContent: AWSEncodableShape & AWSDecodableShape {
        /// The layout configuration of a body section.
        public let layout: SectionLayoutConfiguration?

        public init(layout: SectionLayoutConfiguration? = nil) {
            self.layout = layout
        }

        public func validate(name: String) throws {
            try self.layout?.validate(name: "\(name).layout")
        }

        private enum CodingKeys: String, CodingKey {
            case layout = "Layout"
        }
    }

    public struct BorderStyle: AWSEncodableShape & AWSDecodableShape {
        /// The option to enable display of borders for visuals.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct BoxPlotAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The group by field well of a box plot chart. Values are grouped based on group by fields.
        public let groupBy: [DimensionField]?
        /// The value field well of a box plot chart. Values are aggregated based on group by fields.
        public let values: [MeasureField]?

        public init(groupBy: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.groupBy = groupBy
            self.values = values
        }

        public func validate(name: String) throws {
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case values = "Values"
        }
    }

    public struct BoxPlotChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The box plot chart options for a box plot visual
        public let boxPlotOptions: BoxPlotOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public let categoryAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort Icon visibility) of a box plot category.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: BoxPlotFieldWells?
        public let legend: LegendOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public let primaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) of a box plot value.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public let referenceLines: [ReferenceLine]?
        /// The sort configuration of a BoxPlotVisual.
        public let sortConfiguration: BoxPlotSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(boxPlotOptions: BoxPlotOptions? = nil, categoryAxis: AxisDisplayOptions? = nil, categoryLabelOptions: ChartAxisLabelOptions? = nil, fieldWells: BoxPlotFieldWells? = nil, legend: LegendOptions? = nil, primaryYAxisDisplayOptions: AxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, referenceLines: [ReferenceLine]? = nil, sortConfiguration: BoxPlotSortConfiguration? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.boxPlotOptions = boxPlotOptions
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryAxis?.validate(name: "\(name).categoryAxis")
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case boxPlotOptions = "BoxPlotOptions"
            case categoryAxis = "CategoryAxis"
            case categoryLabelOptions = "CategoryLabelOptions"
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case referenceLines = "ReferenceLines"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
        }
    }

    public struct BoxPlotFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a box plot.
        public let boxPlotAggregatedFieldWells: BoxPlotAggregatedFieldWells?

        public init(boxPlotAggregatedFieldWells: BoxPlotAggregatedFieldWells? = nil) {
            self.boxPlotAggregatedFieldWells = boxPlotAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.boxPlotAggregatedFieldWells?.validate(name: "\(name).boxPlotAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case boxPlotAggregatedFieldWells = "BoxPlotAggregatedFieldWells"
        }
    }

    public struct BoxPlotOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of all data points of the box plot.
        public let allDataPointsVisibility: Visibility?
        /// Determines the visibility of the outlier in a box plot.
        public let outlierVisibility: Visibility?
        /// The style options of the box plot.
        public let styleOptions: BoxPlotStyleOptions?

        public init(allDataPointsVisibility: Visibility? = nil, outlierVisibility: Visibility? = nil, styleOptions: BoxPlotStyleOptions? = nil) {
            self.allDataPointsVisibility = allDataPointsVisibility
            self.outlierVisibility = outlierVisibility
            self.styleOptions = styleOptions
        }

        private enum CodingKeys: String, CodingKey {
            case allDataPointsVisibility = "AllDataPointsVisibility"
            case outlierVisibility = "OutlierVisibility"
            case styleOptions = "StyleOptions"
        }
    }

    public struct BoxPlotSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration of a group by fields.
        public let categorySort: [FieldSortOptions]?
        /// The pagination configuration of a table visual or box plot.
        public let paginationConfiguration: PaginationConfiguration?

        public init(categorySort: [FieldSortOptions]? = nil, paginationConfiguration: PaginationConfiguration? = nil) {
            self.categorySort = categorySort
            self.paginationConfiguration = paginationConfiguration
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.paginationConfiguration?.validate(name: "\(name).paginationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case categorySort = "CategorySort"
            case paginationConfiguration = "PaginationConfiguration"
        }
    }

    public struct BoxPlotStyleOptions: AWSEncodableShape & AWSDecodableShape {
        /// The fill styles (solid, transparent) of the box plot.
        public let fillStyle: BoxPlotFillStyle?

        public init(fillStyle: BoxPlotFillStyle? = nil) {
            self.fillStyle = fillStyle
        }

        private enum CodingKeys: String, CodingKey {
            case fillStyle = "FillStyle"
        }
    }

    public struct BoxPlotVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: BoxPlotChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: BoxPlotChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct CalculatedColumn: AWSEncodableShape & AWSDecodableShape {
        /// A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        public let columnId: String
        /// Column name.
        public let columnName: String
        /// An expression that defines the calculated column.
        public let expression: String

        public init(columnId: String, columnName: String, expression: String) {
            self.columnId = columnId
            self.columnName = columnName
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.columnId, name: "columnId", parent: name, max: 64)
            try self.validate(self.columnId, name: "columnId", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnId = "ColumnId"
            case columnName = "ColumnName"
            case expression = "Expression"
        }
    }

    public struct CalculatedField: AWSEncodableShape & AWSDecodableShape {
        /// The data set that is used in this calculated field.
        public let dataSetIdentifier: String
        /// The expression of the calculated field.
        public let expression: String
        /// The name of the calculated field.
        public let name: String

        public init(dataSetIdentifier: String, expression: String, name: String) {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIdentifier = "DataSetIdentifier"
            case expression = "Expression"
            case name = "Name"
        }
    }

    public struct CalculatedMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The expression in the table calculation.
        public let expression: String
        /// The custom field ID.
        public let fieldId: String

        public init(expression: String, fieldId: String) {
            self.expression = expression
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case fieldId = "FieldId"
        }
    }

    public struct CancelIngestionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId")),
            AWSMemberEncoding(label: "ingestionId", location: .uri("IngestionId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String

        public init(awsAccountId: String, dataSetId: String, ingestionId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelIngestionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the data ingestion.
        public let arn: String?
        /// An ID for the ingestion.
        public let ingestionId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CascadingControlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of source controls that determine the values that are used in the current control.
        public let sourceControls: [CascadingControlSource]?

        public init(sourceControls: [CascadingControlSource]? = nil) {
            self.sourceControls = sourceControls
        }

        public func validate(name: String) throws {
            try self.sourceControls?.forEach {
                try $0.validate(name: "\(name).sourceControls[]")
            }
            try self.validate(self.sourceControls, name: "sourceControls", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceControls = "SourceControls"
        }
    }

    public struct CascadingControlSource: AWSEncodableShape & AWSDecodableShape {
        /// The column identifier that determines which column to look up for the source sheet control.
        public let columnToMatch: ColumnIdentifier?
        /// The source sheet control ID of a CascadingControlSource.
        public let sourceSheetControlId: String?

        public init(columnToMatch: ColumnIdentifier? = nil, sourceSheetControlId: String? = nil) {
            self.columnToMatch = columnToMatch
            self.sourceSheetControlId = sourceSheetControlId
        }

        public func validate(name: String) throws {
            try self.columnToMatch?.validate(name: "\(name).columnToMatch")
        }

        private enum CodingKeys: String, CodingKey {
            case columnToMatch = "ColumnToMatch"
            case sourceSheetControlId = "SourceSheetControlId"
        }
    }

    public struct CastColumnTypeOperation: AWSEncodableShape & AWSDecodableShape {
        /// Column name.
        public let columnName: String
        /// When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        public let format: String?
        /// New column data type.
        public let newColumnType: ColumnDataType

        public init(columnName: String, format: String? = nil, newColumnType: ColumnDataType) {
            self.columnName = columnName
            self.format = format
            self.newColumnType = newColumnType
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.format, name: "format", parent: name, max: 32)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case format = "Format"
            case newColumnType = "NewColumnType"
        }
    }

    public struct CategoricalDimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the CategoricalDimensionField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: StringFormatConfiguration?
        /// The custom hierarchy ID.
        public let hierarchyId: String?

        public init(column: ColumnIdentifier, fieldId: String, formatConfiguration: StringFormatConfiguration? = nil, hierarchyId: String? = nil) {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct CategoricalMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the measure field.
        public let aggregationFunction: CategoricalAggregationFunction?
        /// The column that is used in the CategoricalMeasureField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: StringFormatConfiguration?

        public init(aggregationFunction: CategoricalAggregationFunction? = nil, column: ColumnIdentifier, fieldId: String, formatConfiguration: StringFormatConfiguration? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct CategoryDrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// A list of the string inputs that are the values of the category drill down filter.
        public let categoryValues: [String]
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier

        public init(categoryValues: [String], column: ColumnIdentifier) {
            self.categoryValues = categoryValues
            self.column = column
        }

        public func validate(name: String) throws {
            try self.categoryValues.forEach {
                try validate($0, name: "categoryValues[]", parent: name, max: 512)
            }
            try self.validate(self.categoryValues, name: "categoryValues", parent: name, max: 100_000)
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValues = "CategoryValues"
            case column = "Column"
        }
    }

    public struct CategoryFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The configuration for a CategoryFilter.
        public let configuration: CategoryFilterConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String

        public init(column: ColumnIdentifier, configuration: CategoryFilterConfiguration? = nil, filterId: String) {
            self.column = column
            self.configuration = configuration
            self.filterId = filterId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case configuration = "Configuration"
            case filterId = "FilterId"
        }
    }

    public struct CategoryFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom filter that filters based on a single value. This filter can be partially matched.
        public let customFilterConfiguration: CustomFilterConfiguration?
        /// A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.
        public let customFilterListConfiguration: CustomFilterListConfiguration?
        /// A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.
        public let filterListConfiguration: FilterListConfiguration?

        public init(customFilterConfiguration: CustomFilterConfiguration? = nil, customFilterListConfiguration: CustomFilterListConfiguration? = nil, filterListConfiguration: FilterListConfiguration? = nil) {
            self.customFilterConfiguration = customFilterConfiguration
            self.customFilterListConfiguration = customFilterListConfiguration
            self.filterListConfiguration = filterListConfiguration
        }

        public func validate(name: String) throws {
            try self.customFilterConfiguration?.validate(name: "\(name).customFilterConfiguration")
            try self.customFilterListConfiguration?.validate(name: "\(name).customFilterListConfiguration")
            try self.filterListConfiguration?.validate(name: "\(name).filterListConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customFilterConfiguration = "CustomFilterConfiguration"
            case customFilterListConfiguration = "CustomFilterListConfiguration"
            case filterListConfiguration = "FilterListConfiguration"
        }
    }

    public struct ChartAxisLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The label options for a chart axis.
        public let axisLabelOptions: [AxisLabelOptions]?
        /// The visibility configuration of the sort icon on a chart's axis label.
        public let sortIconVisibility: Visibility?
        /// The visibility of an axis label on a chart. Choose one of the following options:    VISIBLE: Shows the axis.    HIDDEN: Hides the axis.
        public let visibility: Visibility?

        public init(axisLabelOptions: [AxisLabelOptions]? = nil, sortIconVisibility: Visibility? = nil, visibility: Visibility? = nil) {
            self.axisLabelOptions = axisLabelOptions
            self.sortIconVisibility = sortIconVisibility
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.axisLabelOptions?.forEach {
                try $0.validate(name: "\(name).axisLabelOptions[]")
            }
            try self.validate(self.axisLabelOptions, name: "axisLabelOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case axisLabelOptions = "AxisLabelOptions"
            case sortIconVisibility = "SortIconVisibility"
            case visibility = "Visibility"
        }
    }

    public struct ClusterMarker: AWSEncodableShape & AWSDecodableShape {
        /// The simple cluster marker of the cluster marker.
        public let simpleClusterMarker: SimpleClusterMarker?

        public init(simpleClusterMarker: SimpleClusterMarker? = nil) {
            self.simpleClusterMarker = simpleClusterMarker
        }

        public func validate(name: String) throws {
            try self.simpleClusterMarker?.validate(name: "\(name).simpleClusterMarker")
        }

        private enum CodingKeys: String, CodingKey {
            case simpleClusterMarker = "SimpleClusterMarker"
        }
    }

    public struct ClusterMarkerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The cluster marker that is a part of the cluster marker configuration
        public let clusterMarker: ClusterMarker?

        public init(clusterMarker: ClusterMarker? = nil) {
            self.clusterMarker = clusterMarker
        }

        public func validate(name: String) throws {
            try self.clusterMarker?.validate(name: "\(name).clusterMarker")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterMarker = "ClusterMarker"
        }
    }

    public struct ColorScale: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color fill type.
        public let colorFillType: ColorFillType
        /// Determines the list of colors that are applied to the visual.
        public let colors: [DataColor]
        /// Determines the color that is applied to null values.
        public let nullValueColor: DataColor?

        public init(colorFillType: ColorFillType, colors: [DataColor], nullValueColor: DataColor? = nil) {
            self.colorFillType = colorFillType
            self.colors = colors
            self.nullValueColor = nullValueColor
        }

        public func validate(name: String) throws {
            try self.colors.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 3)
            try self.validate(self.colors, name: "colors", parent: name, min: 2)
            try self.nullValueColor?.validate(name: "\(name).nullValueColor")
        }

        private enum CodingKeys: String, CodingKey {
            case colorFillType = "ColorFillType"
            case colors = "Colors"
            case nullValueColor = "NullValueColor"
        }
    }

    public struct ColumnConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The column.
        public let column: ColumnIdentifier
        /// The format configuration of a column.
        public let formatConfiguration: FormatConfiguration?
        /// The role of the column.
        public let role: ColumnRole?

        public init(column: ColumnIdentifier, formatConfiguration: FormatConfiguration? = nil, role: ColumnRole? = nil) {
            self.column = column
            self.formatConfiguration = formatConfiguration
            self.role = role
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case formatConfiguration = "FormatConfiguration"
            case role = "Role"
        }
    }

    public struct ColumnDescription: AWSEncodableShape & AWSDecodableShape {
        /// The text of a description for a column.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct ColumnGroup: AWSEncodableShape & AWSDecodableShape {
        /// Geospatial column group that denotes a hierarchy.
        public let geoSpatialColumnGroup: GeoSpatialColumnGroup?

        public init(geoSpatialColumnGroup: GeoSpatialColumnGroup? = nil) {
            self.geoSpatialColumnGroup = geoSpatialColumnGroup
        }

        public func validate(name: String) throws {
            try self.geoSpatialColumnGroup?.validate(name: "\(name).geoSpatialColumnGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case geoSpatialColumnGroup = "GeoSpatialColumnGroup"
        }
    }

    public struct ColumnGroupColumnSchema: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column group's column schema.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ColumnGroupSchema: AWSEncodableShape & AWSDecodableShape {
        /// A structure containing the list of schemas for column group columns.
        public let columnGroupColumnSchemaList: [ColumnGroupColumnSchema]?
        /// The name of the column group schema.
        public let name: String?

        public init(columnGroupColumnSchemaList: [ColumnGroupColumnSchema]? = nil, name: String? = nil) {
            self.columnGroupColumnSchemaList = columnGroupColumnSchemaList
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.columnGroupColumnSchemaList, name: "columnGroupColumnSchemaList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroupColumnSchemaList = "ColumnGroupColumnSchemaList"
            case name = "Name"
        }
    }

    public struct ColumnHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the hierarchy of any DateTime fields.
        public let dateTimeHierarchy: DateTimeHierarchy?
        /// The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.
        public let explicitHierarchy: ExplicitHierarchy?
        /// The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.
        public let predefinedHierarchy: PredefinedHierarchy?

        public init(dateTimeHierarchy: DateTimeHierarchy? = nil, explicitHierarchy: ExplicitHierarchy? = nil, predefinedHierarchy: PredefinedHierarchy? = nil) {
            self.dateTimeHierarchy = dateTimeHierarchy
            self.explicitHierarchy = explicitHierarchy
            self.predefinedHierarchy = predefinedHierarchy
        }

        public func validate(name: String) throws {
            try self.dateTimeHierarchy?.validate(name: "\(name).dateTimeHierarchy")
            try self.explicitHierarchy?.validate(name: "\(name).explicitHierarchy")
            try self.predefinedHierarchy?.validate(name: "\(name).predefinedHierarchy")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeHierarchy = "DateTimeHierarchy"
            case explicitHierarchy = "ExplicitHierarchy"
            case predefinedHierarchy = "PredefinedHierarchy"
        }
    }

    public struct ColumnIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The data set that the column belongs to.
        public let dataSetIdentifier: String

        public init(columnName: String, dataSetIdentifier: String) {
            self.columnName = columnName
            self.dataSetIdentifier = dataSetIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case dataSetIdentifier = "DataSetIdentifier"
        }
    }

    public struct ColumnLevelPermissionRule: AWSEncodableShape & AWSDecodableShape {
        /// An array of column names.
        public let columnNames: [String]?
        /// An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.
        public let principals: [String]?

        public init(columnNames: [String]? = nil, principals: [String]? = nil) {
            self.columnNames = columnNames
            self.principals = principals
        }

        public func validate(name: String) throws {
            try self.validate(self.columnNames, name: "columnNames", parent: name, min: 1)
            try self.validate(self.principals, name: "principals", parent: name, max: 100)
            try self.validate(self.principals, name: "principals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "ColumnNames"
            case principals = "Principals"
        }
    }

    public struct ColumnSchema: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the column schema.
        public let dataType: String?
        /// The geographic role of the column schema.
        public let geographicRole: String?
        /// The name of the column schema.
        public let name: String?

        public init(dataType: String? = nil, geographicRole: String? = nil, name: String? = nil) {
            self.dataType = dataType
            self.geographicRole = geographicRole
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "DataType"
            case geographicRole = "GeographicRole"
            case name = "Name"
        }
    }

    public struct ColumnSort: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function that is defined in the column sort.
        public let aggregationFunction: AggregationFunction?
        /// The sort direction.
        public let direction: SortDirection
        public let sortBy: ColumnIdentifier

        public init(aggregationFunction: AggregationFunction? = nil, direction: SortDirection, sortBy: ColumnIdentifier) {
            self.aggregationFunction = aggregationFunction
            self.direction = direction
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.sortBy.validate(name: "\(name).sortBy")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case direction = "Direction"
            case sortBy = "SortBy"
        }
    }

    public struct ColumnTag: AWSEncodableShape & AWSDecodableShape {
        /// A description for a column.
        public let columnDescription: ColumnDescription?
        /// A geospatial role for a column.
        public let columnGeographicRole: GeoSpatialDataRole?

        public init(columnDescription: ColumnDescription? = nil, columnGeographicRole: GeoSpatialDataRole? = nil) {
            self.columnDescription = columnDescription
            self.columnGeographicRole = columnGeographicRole
        }

        public func validate(name: String) throws {
            try self.columnDescription?.validate(name: "\(name).columnDescription")
        }

        private enum CodingKeys: String, CodingKey {
            case columnDescription = "ColumnDescription"
            case columnGeographicRole = "ColumnGeographicRole"
        }
    }

    public struct ColumnTooltipItem: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the column tooltip item.
        public let aggregation: AggregationFunction?
        /// The target column of the tooltip item.
        public let column: ColumnIdentifier
        /// The label of the tooltip item.
        public let label: String?
        /// The visibility of the tooltip item.
        public let visibility: Visibility?

        public init(aggregation: AggregationFunction? = nil, column: ColumnIdentifier, label: String? = nil, visibility: Visibility? = nil) {
            self.aggregation = aggregation
            self.column = column
            self.label = label
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.aggregation?.validate(name: "\(name).aggregation")
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "Aggregation"
            case column = "Column"
            case label = "Label"
            case visibility = "Visibility"
        }
    }

    public struct ComboChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated BarValues field well of a combo chart.
        public let barValues: [MeasureField]?
        /// The aggregated category field wells of a combo chart.
        public let category: [DimensionField]?
        /// The aggregated colors field well of a combo chart.
        public let colors: [DimensionField]?
        /// The aggregated LineValues field well of a combo chart.
        public let lineValues: [MeasureField]?

        public init(barValues: [MeasureField]? = nil, category: [DimensionField]? = nil, colors: [DimensionField]? = nil, lineValues: [MeasureField]? = nil) {
            self.barValues = barValues
            self.category = category
            self.colors = colors
            self.lineValues = lineValues
        }

        public func validate(name: String) throws {
            try self.barValues?.forEach {
                try $0.validate(name: "\(name).barValues[]")
            }
            try self.validate(self.barValues, name: "barValues", parent: name, max: 200)
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.lineValues?.forEach {
                try $0.validate(name: "\(name).lineValues[]")
            }
            try self.validate(self.lineValues, name: "lineValues", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case barValues = "BarValues"
            case category = "Category"
            case colors = "Colors"
            case lineValues = "LineValues"
        }
    }

    public struct ComboChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine if visual data labels are displayed. The data label options for a bar in a combo chart.
        public let barDataLabels: DataLabelOptions?
        /// Determines the bar arrangement in a combo chart. The following are valid values in this structure:    CLUSTERED: For clustered bar combo charts.    STACKED: For stacked bar combo charts.    STACKED_PERCENT: Do not use. If you use this value, the operation returns a validation error.
        public let barsArrangement: BarsArrangement?
        /// The category axis of a combo chart.
        public let categoryAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.
        public let colorLabelOptions: ChartAxisLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: ComboChartFieldWells?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The options that determine if visual data labels are displayed. The data label options for a line in a combo chart.
        public let lineDataLabels: DataLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.
        public let primaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public let referenceLines: [ReferenceLine]?
        /// The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.
        public let secondaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.
        public let secondaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The sort configuration of a ComboChartVisual.
        public let sortConfiguration: ComboChartSortConfiguration?
        /// The legend display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(barDataLabels: DataLabelOptions? = nil, barsArrangement: BarsArrangement? = nil, categoryAxis: AxisDisplayOptions? = nil, categoryLabelOptions: ChartAxisLabelOptions? = nil, colorLabelOptions: ChartAxisLabelOptions? = nil, fieldWells: ComboChartFieldWells? = nil, legend: LegendOptions? = nil, lineDataLabels: DataLabelOptions? = nil, primaryYAxisDisplayOptions: AxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, referenceLines: [ReferenceLine]? = nil, secondaryYAxisDisplayOptions: AxisDisplayOptions? = nil, secondaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, sortConfiguration: ComboChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.barDataLabels = barDataLabels
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.fieldWells = fieldWells
            self.legend = legend
            self.lineDataLabels = lineDataLabels
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.barDataLabels?.validate(name: "\(name).barDataLabels")
            try self.categoryAxis?.validate(name: "\(name).categoryAxis")
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.colorLabelOptions?.validate(name: "\(name).colorLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.lineDataLabels?.validate(name: "\(name).lineDataLabels")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.secondaryYAxisDisplayOptions?.validate(name: "\(name).secondaryYAxisDisplayOptions")
            try self.secondaryYAxisLabelOptions?.validate(name: "\(name).secondaryYAxisLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case barDataLabels = "BarDataLabels"
            case barsArrangement = "BarsArrangement"
            case categoryAxis = "CategoryAxis"
            case categoryLabelOptions = "CategoryLabelOptions"
            case colorLabelOptions = "ColorLabelOptions"
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case lineDataLabels = "LineDataLabels"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case referenceLines = "ReferenceLines"
            case secondaryYAxisDisplayOptions = "SecondaryYAxisDisplayOptions"
            case secondaryYAxisLabelOptions = "SecondaryYAxisLabelOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
        }
    }

    public struct ComboChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.
        public let comboChartAggregatedFieldWells: ComboChartAggregatedFieldWells?

        public init(comboChartAggregatedFieldWells: ComboChartAggregatedFieldWells? = nil) {
            self.comboChartAggregatedFieldWells = comboChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.comboChartAggregatedFieldWells?.validate(name: "\(name).comboChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case comboChartAggregatedFieldWells = "ComboChartAggregatedFieldWells"
        }
    }

    public struct ComboChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The item limit configuration for the category field well of a combo chart.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category field well in a combo chart.
        public let categorySort: [FieldSortOptions]?
        /// The item limit configuration of the color field well in a combo chart.
        public let colorItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the color field well in a combo chart.
        public let colorSort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, colorItemsLimit: ItemsLimitConfiguration? = nil, colorSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.colorSort?.forEach {
                try $0.validate(name: "\(name).colorSort[]")
            }
            try self.validate(self.colorSort, name: "colorSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
            case colorItemsLimit = "ColorItemsLimit"
            case colorSort = "ColorSort"
        }
    }

    public struct ComboChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: ComboChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: ComboChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct ComparisonConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The format of the comparison.
        public let comparisonFormat: ComparisonFormatConfiguration?
        /// The method of the comparison. Choose from the following options:    DIFFERENCE     PERCENT_DIFFERENCE     PERCENT
        public let comparisonMethod: ComparisonMethod?

        public init(comparisonFormat: ComparisonFormatConfiguration? = nil, comparisonMethod: ComparisonMethod? = nil) {
            self.comparisonFormat = comparisonFormat
            self.comparisonMethod = comparisonMethod
        }

        public func validate(name: String) throws {
            try self.comparisonFormat?.validate(name: "\(name).comparisonFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonFormat = "ComparisonFormat"
            case comparisonMethod = "ComparisonMethod"
        }
    }

    public struct ComparisonFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number display format.
        public let numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration?
        /// The percentage display format.
        public let percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration?

        public init(numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration? = nil, percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration? = nil) {
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.numberDisplayFormatConfiguration?.validate(name: "\(name).numberDisplayFormatConfiguration")
            try self.percentageDisplayFormatConfiguration?.validate(name: "\(name).percentageDisplayFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case numberDisplayFormatConfiguration = "NumberDisplayFormatConfiguration"
            case percentageDisplayFormatConfiguration = "PercentageDisplayFormatConfiguration"
        }
    }

    public struct Computation: AWSEncodableShape & AWSDecodableShape {
        /// The forecast computation configuration.
        public let forecast: ForecastComputation?
        /// The growth rate computation configuration.
        public let growthRate: GrowthRateComputation?
        /// The maximum and minimum computation configuration.
        public let maximumMinimum: MaximumMinimumComputation?
        /// The metric comparison computation configuration.
        public let metricComparison: MetricComparisonComputation?
        /// The period over period computation configuration.
        public let periodOverPeriod: PeriodOverPeriodComputation?
        /// The period to DataSetIdentifier computation configuration.
        public let periodToDate: PeriodToDateComputation?
        /// The top movers and bottom movers computation configuration.
        public let topBottomMovers: TopBottomMoversComputation?
        /// The top ranked and bottom ranked computation configuration.
        public let topBottomRanked: TopBottomRankedComputation?
        /// The total aggregation computation configuration.
        public let totalAggregation: TotalAggregationComputation?
        /// The unique values computation configuration.
        public let uniqueValues: UniqueValuesComputation?

        public init(forecast: ForecastComputation? = nil, growthRate: GrowthRateComputation? = nil, maximumMinimum: MaximumMinimumComputation? = nil, metricComparison: MetricComparisonComputation? = nil, periodOverPeriod: PeriodOverPeriodComputation? = nil, periodToDate: PeriodToDateComputation? = nil, topBottomMovers: TopBottomMoversComputation? = nil, topBottomRanked: TopBottomRankedComputation? = nil, totalAggregation: TotalAggregationComputation? = nil, uniqueValues: UniqueValuesComputation? = nil) {
            self.forecast = forecast
            self.growthRate = growthRate
            self.maximumMinimum = maximumMinimum
            self.metricComparison = metricComparison
            self.periodOverPeriod = periodOverPeriod
            self.periodToDate = periodToDate
            self.topBottomMovers = topBottomMovers
            self.topBottomRanked = topBottomRanked
            self.totalAggregation = totalAggregation
            self.uniqueValues = uniqueValues
        }

        public func validate(name: String) throws {
            try self.forecast?.validate(name: "\(name).forecast")
            try self.growthRate?.validate(name: "\(name).growthRate")
            try self.maximumMinimum?.validate(name: "\(name).maximumMinimum")
            try self.metricComparison?.validate(name: "\(name).metricComparison")
            try self.periodOverPeriod?.validate(name: "\(name).periodOverPeriod")
            try self.periodToDate?.validate(name: "\(name).periodToDate")
            try self.topBottomMovers?.validate(name: "\(name).topBottomMovers")
            try self.topBottomRanked?.validate(name: "\(name).topBottomRanked")
            try self.totalAggregation?.validate(name: "\(name).totalAggregation")
            try self.uniqueValues?.validate(name: "\(name).uniqueValues")
        }

        private enum CodingKeys: String, CodingKey {
            case forecast = "Forecast"
            case growthRate = "GrowthRate"
            case maximumMinimum = "MaximumMinimum"
            case metricComparison = "MetricComparison"
            case periodOverPeriod = "PeriodOverPeriod"
            case periodToDate = "PeriodToDate"
            case topBottomMovers = "TopBottomMovers"
            case topBottomRanked = "TopBottomRanked"
            case totalAggregation = "TotalAggregation"
            case uniqueValues = "UniqueValues"
        }
    }

    public struct ConditionalFormattingColor: AWSEncodableShape & AWSDecodableShape {
        /// Formatting configuration for gradient color.
        public let gradient: ConditionalFormattingGradientColor?
        /// Formatting configuration for solid color.
        public let solid: ConditionalFormattingSolidColor?

        public init(gradient: ConditionalFormattingGradientColor? = nil, solid: ConditionalFormattingSolidColor? = nil) {
            self.gradient = gradient
            self.solid = solid
        }

        public func validate(name: String) throws {
            try self.gradient?.validate(name: "\(name).gradient")
            try self.solid?.validate(name: "\(name).solid")
        }

        private enum CodingKeys: String, CodingKey {
            case gradient = "Gradient"
            case solid = "Solid"
        }
    }

    public struct ConditionalFormattingCustomIconCondition: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color of the icon.
        public let color: String?
        /// Determines the icon display configuration.
        public let displayConfiguration: ConditionalFormattingIconDisplayConfiguration?
        /// The expression that determines the condition of the icon set.
        public let expression: String
        /// Custom icon options for an icon set.
        public let iconOptions: ConditionalFormattingCustomIconOptions

        public init(color: String? = nil, displayConfiguration: ConditionalFormattingIconDisplayConfiguration? = nil, expression: String, iconOptions: ConditionalFormattingCustomIconOptions) {
            self.color = color
            self.displayConfiguration = displayConfiguration
            self.expression = expression
            self.iconOptions = iconOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.iconOptions.validate(name: "\(name).iconOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case displayConfiguration = "DisplayConfiguration"
            case expression = "Expression"
            case iconOptions = "IconOptions"
        }
    }

    public struct ConditionalFormattingCustomIconOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the type of icon.
        public let icon: Icon?
        /// Determines the Unicode icon type.
        public let unicodeIcon: String?

        public init(icon: Icon? = nil, unicodeIcon: String? = nil) {
            self.icon = icon
            self.unicodeIcon = unicodeIcon
        }

        public func validate(name: String) throws {
            try self.validate(self.unicodeIcon, name: "unicodeIcon", parent: name, pattern: "^[^\\u0000-\\u00FF]$")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case unicodeIcon = "UnicodeIcon"
        }
    }

    public struct ConditionalFormattingGradientColor: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color.
        public let color: GradientColor
        /// The expression that determines the formatting configuration for gradient color.
        public let expression: String

        public init(color: GradientColor, expression: String) {
            self.color = color
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.color.validate(name: "\(name).color")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case expression = "Expression"
        }
    }

    public struct ConditionalFormattingIcon: AWSEncodableShape & AWSDecodableShape {
        /// Determines the custom condition for an icon set.
        public let customCondition: ConditionalFormattingCustomIconCondition?
        /// Formatting configuration for icon set.
        public let iconSet: ConditionalFormattingIconSet?

        public init(customCondition: ConditionalFormattingCustomIconCondition? = nil, iconSet: ConditionalFormattingIconSet? = nil) {
            self.customCondition = customCondition
            self.iconSet = iconSet
        }

        public func validate(name: String) throws {
            try self.customCondition?.validate(name: "\(name).customCondition")
            try self.iconSet?.validate(name: "\(name).iconSet")
        }

        private enum CodingKeys: String, CodingKey {
            case customCondition = "CustomCondition"
            case iconSet = "IconSet"
        }
    }

    public struct ConditionalFormattingIconDisplayConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the icon display configuration.
        public let iconDisplayOption: ConditionalFormattingIconDisplayOption?

        public init(iconDisplayOption: ConditionalFormattingIconDisplayOption? = nil) {
            self.iconDisplayOption = iconDisplayOption
        }

        private enum CodingKeys: String, CodingKey {
            case iconDisplayOption = "IconDisplayOption"
        }
    }

    public struct ConditionalFormattingIconSet: AWSEncodableShape & AWSDecodableShape {
        /// The expression that determines the formatting configuration for the icon set.
        public let expression: String
        /// Determines the icon set type.
        public let iconSetType: ConditionalFormattingIconSetType?

        public init(expression: String, iconSetType: ConditionalFormattingIconSetType? = nil) {
            self.expression = expression
            self.iconSetType = iconSetType
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case iconSetType = "IconSetType"
        }
    }

    public struct ConditionalFormattingSolidColor: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color.
        public let color: String?
        /// The expression that determines the formatting configuration for solid color.
        public let expression: String

        public init(color: String? = nil, expression: String) {
            self.color = color
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case expression = "Expression"
        }
    }

    public struct ContributionAnalysisDefault: AWSEncodableShape & AWSDecodableShape {
        /// The dimensions columns that are used in the contribution analysis, usually a list of ColumnIdentifiers.
        public let contributorDimensions: [ColumnIdentifier]
        /// The measure field that is used in the contribution analysis.
        public let measureFieldId: String

        public init(contributorDimensions: [ColumnIdentifier], measureFieldId: String) {
            self.contributorDimensions = contributorDimensions
            self.measureFieldId = measureFieldId
        }

        public func validate(name: String) throws {
            try self.contributorDimensions.forEach {
                try $0.validate(name: "\(name).contributorDimensions[]")
            }
            try self.validate(self.contributorDimensions, name: "contributorDimensions", parent: name, max: 4)
            try self.validate(self.contributorDimensions, name: "contributorDimensions", parent: name, min: 1)
            try self.validate(self.measureFieldId, name: "measureFieldId", parent: name, max: 512)
            try self.validate(self.measureFieldId, name: "measureFieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contributorDimensions = "ContributorDimensions"
            case measureFieldId = "MeasureFieldId"
        }
    }

    public struct CreateAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring("namespace"))
        ]

        /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region. You can add these to an Amazon Web Services account and a QuickSight namespace.  For example, you can add a default theme by setting AccountCustomization to the midnight theme: "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight::aws:theme/MIDNIGHT" }. Or, you can add a custom theme by specifying "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639" }.
        public let accountCustomization: AccountCustomization
        /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
        public let awsAccountId: String
        /// The Amazon QuickSight namespace that you want to add customizations to.
        public let namespace: String?
        /// A list of the tags that you want to attach to this resource.
        public let tags: [Tag]?

        public init(accountCustomization: AccountCustomization, awsAccountId: String, namespace: String? = nil, tags: [Tag]? = nil) {
            self.accountCustomization = accountCustomization
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case tags = "Tags"
        }
    }

    public struct CreateAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) for the customization that you created for this Amazon Web Services account.
        public let arn: String?
        /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
        public let awsAccountId: String?
        /// The namespace associated with the customization you're creating.
        public let namespace: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateAccountSubscriptionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The name of your Amazon QuickSight account. This name is unique over all of Amazon Web Services, and it appears only when users sign in. You can't change AccountName value after the Amazon QuickSight account is created.
        public let accountName: String
        /// The name of your Active Directory. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
        public let activeDirectoryName: String?
        /// The admin group associated with your Active Directory. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account. For more information about using Active Directory in Amazon QuickSight, see Using Active Directory with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide.
        public let adminGroup: [String]?
        /// The method that you want to use to authenticate your Amazon QuickSight account. Currently, the valid values for this parameter are IAM_AND_QUICKSIGHT, IAM_ONLY, and ACTIVE_DIRECTORY. If you choose ACTIVE_DIRECTORY, provide an ActiveDirectoryName and an AdminGroup associated with your Active Directory.
        public let authenticationMethod: AuthenticationMethodOption
        /// The author group associated with your Active Directory. For more information about using Active Directory in Amazon QuickSight, see Using Active Directory with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide.
        public let authorGroup: [String]?
        /// The Amazon Web Services account ID of the account that you're using to create your Amazon QuickSight account.
        public let awsAccountId: String
        /// A 10-digit phone number for the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let contactNumber: String?
        /// The ID of the Active Directory that is associated with your Amazon QuickSight account.
        public let directoryId: String?
        /// The edition of Amazon QuickSight that you want your account to have. Currently, you can choose from ENTERPRISE or ENTERPRISE_AND_Q. If you choose ENTERPRISE_AND_Q, the following parameters are required:    FirstName     LastName     EmailAddress     ContactNumber
        public let edition: Edition
        /// The email address of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let emailAddress: String?
        /// The first name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let firstName: String?
        /// The last name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let lastName: String?
        /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon QuickSight account or Amazon QuickSight subscription.
        public let notificationEmail: String
        /// The reader group associated with your Active Direcrtory. For more information about using Active Directory in Amazon QuickSight, see Using Active Directory with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide.
        public let readerGroup: [String]?
        /// The realm of the Active Directory that is associated with your Amazon QuickSight account. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
        public let realm: String?

        public init(accountName: String, activeDirectoryName: String? = nil, adminGroup: [String]? = nil, authenticationMethod: AuthenticationMethodOption, authorGroup: [String]? = nil, awsAccountId: String, contactNumber: String? = nil, directoryId: String? = nil, edition: Edition, emailAddress: String? = nil, firstName: String? = nil, lastName: String? = nil, notificationEmail: String, readerGroup: [String]? = nil, realm: String? = nil) {
            self.accountName = accountName
            self.activeDirectoryName = activeDirectoryName
            self.adminGroup = adminGroup
            self.authenticationMethod = authenticationMethod
            self.authorGroup = authorGroup
            self.awsAccountId = awsAccountId
            self.contactNumber = contactNumber
            self.directoryId = directoryId
            self.edition = edition
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
            self.notificationEmail = notificationEmail
            self.readerGroup = readerGroup
            self.realm = realm
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "AccountName"
            case activeDirectoryName = "ActiveDirectoryName"
            case adminGroup = "AdminGroup"
            case authenticationMethod = "AuthenticationMethod"
            case authorGroup = "AuthorGroup"
            case contactNumber = "ContactNumber"
            case directoryId = "DirectoryId"
            case edition = "Edition"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case lastName = "LastName"
            case notificationEmail = "NotificationEmail"
            case readerGroup = "ReaderGroup"
            case realm = "Realm"
        }
    }

    public struct CreateAccountSubscriptionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// A SignupResponse object that returns information about a newly created Amazon QuickSight account.
        public let signupResponse: SignupResponse?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, signupResponse: SignupResponse? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.signupResponse = signupResponse
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case signupResponse = "SignupResponse"
            case status = "Status"
        }
    }

    public struct CreateAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID for the analysis that you're creating. This ID displays in the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account where you are creating an analysis.
        public let awsAccountId: String
        /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: AnalysisDefinition?
        /// A descriptive name for the analysis that you're creating. This name displays for the analysis in the Amazon QuickSight console.
        public let name: String
        /// The parameter names and override values that you want to use. An analysis can have  any parameter type, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A structure that describes the principals and the resource-level permissions on an analysis. You can use the Permissions structure to grant permissions by providing a list of Identity and Access Management (IAM) action information for each principal listed by Amazon Resource Name (ARN).  To specify no permissions, omit Permissions.
        public let permissions: [ResourcePermission]?
        /// A source entity to use for the analysis that you're creating. This metadata structure contains details that describe a source template and one or more datasets.
        public let sourceEntity: AnalysisSourceEntity?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the analysis.
        public let tags: [Tag]?
        /// The ARN for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
        public let themeArn: String?

        public init(analysisId: String, awsAccountId: String, definition: AnalysisDefinition? = nil, name: String, parameters: Parameters? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: AnalysisSourceEntity? = nil, tags: [Tag]? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.name = name
            self.parameters = parameters
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.themeArn = themeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case name = "Name"
            case parameters = "Parameters"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case themeArn = "ThemeArn"
        }
    }

    public struct CreateAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the analysis.
        public let analysisId: String?
        /// The ARN for the analysis.
        public let arn: String?
        /// The status of the creation of the analysis.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateColumnsOperation: AWSEncodableShape & AWSDecodableShape {
        /// Calculated columns to create.
        public let columns: [CalculatedColumn]

        public init(columns: [CalculatedColumn]) {
            self.columns = columns
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 128)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId"))
        ]

        /// The ID of the Amazon Web Services account where you want to create the dashboard.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the IAM policy.
        public let dashboardId: String
        /// Options for publishing the dashboard when you create it:    AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.     AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.     VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
        public let dashboardPublishOptions: DashboardPublishOptions?
        /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: DashboardVersionDefinition?
        /// The display name of the dashboard.
        public let name: String
        /// The parameters for the creation of the dashboard, which you want to use to override the default settings. A dashboard can have any type of parameters, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A structure that contains the permissions of the dashboard. You can use this structure for granting permissions by providing a list of IAM action information for each principal ARN.  To specify no permissions, omit the permissions list.
        public let permissions: [ResourcePermission]?
        /// The entity that you are using as a source when you create the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only create a dashboard from a template, so you use a SourceTemplate entity. If you need to create a dashboard from an analysis, first convert the analysis to a template by using the  CreateTemplate  API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplateARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region.  Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: DashboardSourceEntity?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dashboard.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that is used in the source entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
        public let themeArn: String?
        /// A description for the first version of the dashboard being created.
        public let versionDescription: String?

        public init(awsAccountId: String, dashboardId: String, dashboardPublishOptions: DashboardPublishOptions? = nil, definition: DashboardVersionDefinition? = nil, name: String, parameters: Parameters? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: DashboardSourceEntity? = nil, tags: [Tag]? = nil, themeArn: String? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.dashboardPublishOptions = dashboardPublishOptions
            self.definition = definition
            self.name = name
            self.parameters = parameters
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.themeArn = themeArn
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardPublishOptions = "DashboardPublishOptions"
            case definition = "Definition"
            case name = "Name"
            case parameters = "Parameters"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case themeArn = "ThemeArn"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ARN of the dashboard.
        public let arn: String?
        /// The status of the dashboard creation request.
        public let creationStatus: ResourceStatus?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the dashboard, including the version number of the first version that is created.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
            case versionArn = "VersionArn"
        }
    }

    public struct CreateDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// An ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String
        public let dataSetUsageConfiguration: DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// Indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// The display name for the dataset.
        public let name: String
        /// A list of resource permissions on the dataset.
        public let permissions: [ResourcePermission]?
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]
        /// The row-level security configuration for the data that you want to create.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
        public let rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.
        public let tags: [Tag]?

        public init(awsAccountId: String, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, dataSetId: String, dataSetUsageConfiguration: DataSetUsageConfiguration? = nil, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode, logicalTableMap: [String: LogicalTable]? = nil, name: String, permissions: [ResourcePermission]? = nil, physicalTableMap: [String: PhysicalTable], rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration? = nil, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.dataSetId = dataSetId
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.permissions = permissions
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.columnGroups?.forEach {
                try $0.validate(name: "\(name).columnGroups[]")
            }
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, max: 8)
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, min: 1)
            try self.columnLevelPermissionRules?.forEach {
                try $0.validate(name: "\(name).columnLevelPermissionRules[]")
            }
            try self.validate(self.columnLevelPermissionRules, name: "columnLevelPermissionRules", parent: name, min: 1)
            try self.fieldFolders?.forEach {
                try validate($0.key, name: "fieldFolders.key", parent: name, max: 1000)
                try validate($0.key, name: "fieldFolders.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).fieldFolders[\"\($0.key)\"]")
            }
            try self.logicalTableMap?.forEach {
                try validate($0.key, name: "logicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "logicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "logicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).logicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, max: 64)
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.physicalTableMap.forEach {
                try validate($0.key, name: "physicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "physicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "physicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).physicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.physicalTableMap, name: "physicalTableMap", parent: name, max: 32)
            try self.rowLevelPermissionDataSet?.validate(name: "\(name).rowLevelPermissionDataSet")
            try self.rowLevelPermissionTagConfiguration?.validate(name: "\(name).rowLevelPermissionTagConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case dataSetId = "DataSetId"
            case dataSetUsageConfiguration = "DataSetUsageConfiguration"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case permissions = "Permissions"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionArn: String?
        /// The ID of the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, ingestionArn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.ingestionArn = ingestionArn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case ingestionArn = "IngestionArn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The credentials Amazon QuickSight that uses to connect to your underlying source. Currently, only
        /// 			credentials based on user name and password are supported.
        public let credentials: DataSourceCredentials?
        /// An ID for the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String
        /// The parameters that Amazon QuickSight uses to connect to your underlying source.
        public let dataSourceParameters: DataSourceParameters?
        /// A display name for the data source.
        public let name: String
        /// A list of resource permissions on the data source.
        public let permissions: [ResourcePermission]?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
        public let sslProperties: SslProperties?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.
        public let tags: [Tag]?
        /// The type of the data source. To return a
        /// 			list of all data sources, use ListDataSources. Use AMAZON_ELASTICSEARCH for Amazon OpenSearch Service.
        public let type: DataSourceType
        /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to
        /// 			your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(awsAccountId: String, credentials: DataSourceCredentials? = nil, dataSourceId: String, dataSourceParameters: DataSourceParameters? = nil, name: String, permissions: [ResourcePermission]? = nil, sslProperties: SslProperties? = nil, tags: [Tag]? = nil, type: DataSourceType, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.awsAccountId = awsAccountId
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.name = name
            self.permissions = permissions
            self.sslProperties = sslProperties
            self.tags = tags
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.credentials?.validate(name: "\(name).credentials")
            try self.dataSourceParameters?.validate(name: "\(name).dataSourceParameters")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case dataSourceId = "DataSourceId"
            case dataSourceParameters = "DataSourceParameters"
            case name = "Name"
            case permissions = "Permissions"
            case sslProperties = "SslProperties"
            case tags = "Tags"
            case type = "Type"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The status of creating the data source.
        public let creationStatus: ResourceStatus?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateFolderMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId")),
            AWSMemberEncoding(label: "memberId", location: .uri("MemberId")),
            AWSMemberEncoding(label: "memberType", location: .uri("MemberType"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The ID of the asset (the dashboard, analysis, or dataset).
        public let memberId: String
        /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET.
        public let memberType: MemberType

        public init(awsAccountId: String, folderId: String, memberId: String, memberType: MemberType) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.memberId = memberId
            self.memberType = memberType
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 2048)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateFolderMembershipResponse: AWSDecodableShape {
        /// Information about the member in the folder.
        public let folderMember: FolderMember?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderMember: FolderMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderMember = folderMember
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderMember = "FolderMember"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId"))
        ]

        /// The ID for the Amazon Web Services account where you want to create the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The type of folder. By default, folderType is SHARED.
        public let folderType: FolderType?
        /// The name of the folder.
        public let name: String?
        /// The Amazon Resource Name (ARN) for the parent folder.  ParentFolderArn can be null. An empty parentFolderArn creates a root-level folder.
        public let parentFolderArn: String?
        /// A structure that describes the principals and the resource-level permissions of a folder. To specify no permissions, omit Permissions.
        public let permissions: [ResourcePermission]?
        /// Tags for the folder.
        public let tags: [Tag]?

        public init(awsAccountId: String, folderId: String, folderType: FolderType? = nil, name: String? = nil, parentFolderArn: String? = nil, permissions: [ResourcePermission]? = nil, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.folderType = folderType
            self.name = name
            self.parentFolderArn = parentFolderArn
            self.permissions = permissions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case folderType = "FolderType"
            case name = "Name"
            case parentFolderArn = "ParentFolderArn"
            case permissions = "Permissions"
            case tags = "Tags"
        }
    }

    public struct CreateFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the newly created folder.
        public let arn: String?
        /// The folder ID for the newly created folder.
        public let folderId: String?
        /// The request ID for the newly created folder.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateGroupMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri("GroupName")),
            AWSMemberEncoding(label: "memberName", location: .uri("MemberName")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to add the user to.
        public let groupName: String
        /// The name of the user that you want to add to the group membership.
        public let memberName: String
        /// The namespace that you want the user to be a part of.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateGroupMembershipResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The group member.
        public let groupMember: GroupMember?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMember: GroupMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMember = groupMember
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupMember = "GroupMember"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// A description for the group that you want to create.
        public let description: String?
        /// A name for the group that you want to create.
        public let groupName: String
        /// The namespace that you want the group to be a part of.
        public let namespace: String

        public init(awsAccountId: String, description: String? = nil, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case groupName = "GroupName"
        }
    }

    public struct CreateGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the group.
        public let group: Group?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The name of the assignment, also called a rule. It must be unique within an Amazon Web Services account.
        public let assignmentName: String
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data
        /// 					source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the
        /// 					data source.
        public let assignmentStatus: AssignmentStatus
        /// The ID of the Amazon Web Services account where you want to assign an IAM policy to Amazon QuickSight users or
        /// 			groups.
        public let awsAccountId: String
        /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
        public let identities: [String: [String]]?
        /// The namespace that contains the assignment.
        public let namespace: String
        /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups
        /// 			specified in this assignment.
        public let policyArn: String?

        public init(assignmentName: String, assignmentStatus: AssignmentStatus, awsAccountId: String, identities: [String: [String]]? = nil, namespace: String, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.namespace = namespace
            self.policyArn = policyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct CreateIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID for the assignment.
        public let assignmentId: String?
        /// The name of the assignment. This name must be unique within the Amazon Web Services account.
        public let assignmentName: String?
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data
        /// 				source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the
        /// 				data source.
        public let assignmentStatus: AssignmentStatus?
        /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
        public let identities: [String: [String]]?
        /// The ARN for the IAM policy that is applied to the Amazon QuickSight users and groups specified in this assignment.
        public let policyArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.identities = identities
            self.policyArn = policyArn
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateIngestionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId")),
            AWSMemberEncoding(label: "ingestionId", location: .uri("IngestionId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String
        /// The type of ingestion that you want to create.
        public let ingestionType: IngestionType?

        public init(awsAccountId: String, dataSetId: String, ingestionId: String, ingestionType: IngestionType? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
            self.ingestionType = ingestionType
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionType = "IngestionType"
        }
    }

    public struct CreateIngestionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the data ingestion.
        public let arn: String?
        /// An ID for the ingestion.
        public let ingestionId: String?
        /// The ingestion status.
        public let ingestionStatus: IngestionStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, ingestionId: String? = nil, ingestionStatus: IngestionStatus? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.ingestionId = ingestionId
            self.ingestionStatus = ingestionStatus
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case ingestionId = "IngestionId"
            case ingestionStatus = "IngestionStatus"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID for the Amazon Web Services account that you want to create the Amazon QuickSight namespace in.
        public let awsAccountId: String
        /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
        public let identityStore: IdentityStore
        /// The name that you want to use to describe the new namespace.
        public let namespace: String
        /// The tags that you want to associate with the namespace that you're creating.
        public let tags: [Tag]?

        public init(awsAccountId: String, identityStore: IdentityStore, namespace: String, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.identityStore = identityStore
            self.namespace = namespace
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStore = "IdentityStore"
            case namespace = "Namespace"
            case tags = "Tags"
        }
    }

    public struct CreateNamespaceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ARN of the Amazon QuickSight namespace you created.
        public let arn: String?
        /// The Amazon Web Services Region; that you want to use for the free SPICE capacity for the new namespace. This is set to the region that you run CreateNamespace in.
        public let capacityRegion: String?
        /// The status of the creation of the namespace. This is an asynchronous process. A status of CREATED means that your namespace is ready to use. If an error occurs, it indicates if the process is retryable or non-retryable. In the case of a non-retryable error, refer to the error message for follow-up tasks.
        public let creationStatus: NamespaceStatus?
        /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
        public let identityStore: IdentityStore?
        /// The name of the new namespace that you created.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, capacityRegion: String? = nil, creationStatus: NamespaceStatus? = nil, identityStore: IdentityStore? = nil, name: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacityRegion = "CapacityRegion"
            case creationStatus = "CreationStatus"
            case identityStore = "IdentityStore"
            case name = "Name"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The name that you want to give to the template alias that you're creating. Don't start the
        /// 			alias name with the $ character. Alias names that start with $
        /// 			are reserved by Amazon QuickSight.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the template that you creating an alias for.
        public let awsAccountId: String
        /// An ID for the template.
        public let templateId: String
        /// The version number of the template.
        public let templateVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, templateId: String, templateVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.templateVersionNumber = templateVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.templateVersionNumber, name: "templateVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct CreateTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct CreateTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. You use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: TemplateVersionDefinition?
        /// A display name for the template.
        public let name: String?
        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The entity that you are using as a source when you create the template. In
        /// 			SourceEntity, you specify the type of object you're using as source:
        /// 			SourceTemplate for a template or SourceAnalysis for an
        /// 			analysis. Both of these require an Amazon Resource Name (ARN). For
        /// 			SourceTemplate, specify the ARN of the source template. For
        /// 			SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate
        /// 			ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region.  Use the DataSetReferences entity within SourceTemplate or
        /// 			SourceAnalysis to list the replacement datasets for the placeholders listed
        /// 			in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: TemplateSourceEntity?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [Tag]?
        /// An ID for the template that you want to create. This template is unique per Amazon Web Services Region; in
        /// 			each Amazon Web Services account.
        public let templateId: String
        /// A description of the current template version being created. This API operation creates the
        /// 			first version of the template. Every time UpdateTemplate is called, a new
        /// 			version is created. Each version of the template maintains a description of the version
        /// 			in the VersionDescription field.
        public let versionDescription: String?

        public init(awsAccountId: String, definition: TemplateVersionDefinition? = nil, name: String? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: TemplateSourceEntity? = nil, tags: [Tag]? = nil, templateId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.name = name
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.templateId = templateId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case name = "Name"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ARN for the template.
        public let arn: String?
        /// The template creation status.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the template.
        public let templateId: String?
        /// The ARN for the template, including the version information of
        /// 			the first version.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
            case versionArn = "VersionArn"
        }
    }

    public struct CreateThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The name that you want to give to the theme alias that you are creating. The
        /// 			alias name can't begin with a $. Alias names that start with $
        /// 			are reserved by Amazon QuickSight.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme for the new theme alias.
        public let awsAccountId: String
        /// An ID for the theme alias.
        public let themeId: String
        /// The version number of the theme.
        public let themeVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, themeId: String, themeVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.themeVersionNumber = themeVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.themeVersionNumber, name: "themeVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct CreateThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct CreateThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The ID of the Amazon Web Services account where you want to store the new theme.
        public let awsAccountId: String
        /// The ID of the theme that a custom theme will inherit from. All themes inherit from one of
        /// 			the starting themes defined by Amazon QuickSight. For a list of the starting themes, use
        /// 				ListThemes or choose Themes from
        /// 			within an analysis.
        public let baseThemeId: String
        /// The theme configuration, which contains the theme display properties.
        public let configuration: ThemeConfiguration
        /// A display name for the theme.
        public let name: String
        /// A valid grouping of resource permissions to apply to the new theme.
        ///
        public let permissions: [ResourcePermission]?
        /// A map of the key-value pairs for the resource tag or tags that you want to add to the
        /// 			resource.
        public let tags: [Tag]?
        /// An ID for the theme that you want to create. The theme ID is unique per Amazon Web Services Region in
        /// 			each Amazon Web Services account.
        public let themeId: String
        /// A description of the first version of the theme that you're creating. Every time
        /// 				UpdateTheme is called, a new version is created. Each version of the
        /// 			theme has a description of the version in the VersionDescription
        /// 			field.
        public let versionDescription: String?

        public init(awsAccountId: String, baseThemeId: String, configuration: ThemeConfiguration, name: String, permissions: [ResourcePermission]? = nil, tags: [Tag]? = nil, themeId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.name = name
            self.permissions = permissions
            self.tags = tags
            self.themeId = themeId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, max: 512)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, min: 1)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case name = "Name"
            case permissions = "Permissions"
            case tags = "Tags"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the theme.
        public let arn: String?
        /// The theme creation status.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the theme.
        public let themeId: String?
        /// The Amazon Resource Name (ARN) for the new theme.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
            case versionArn = "VersionArn"
        }
    }

    public struct CredentialPair: AWSEncodableShape {
        /// A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the AlternateDataSourceParameters list is null, the DataSourceParameters originally used with these Credentials is automatically allowed.
        public let alternateDataSourceParameters: [DataSourceParameters]?
        /// Password.
        public let password: String
        /// User name.
        public let username: String

        public init(alternateDataSourceParameters: [DataSourceParameters]? = nil, password: String, username: String) {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.alternateDataSourceParameters?.forEach {
                try $0.validate(name: "\(name).alternateDataSourceParameters[]")
            }
            try self.validate(self.alternateDataSourceParameters, name: "alternateDataSourceParameters", parent: name, max: 50)
            try self.validate(self.alternateDataSourceParameters, name: "alternateDataSourceParameters", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, max: 1024)
            try self.validate(self.password, name: "password", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 64)
            try self.validate(self.username, name: "username", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case alternateDataSourceParameters = "AlternateDataSourceParameters"
            case password = "Password"
            case username = "Username"
        }
    }

    public struct CurrencyDisplayFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the decimal places configuration.
        public let decimalPlacesConfiguration: DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public let negativeValueConfiguration: NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// Determines the number scale value for the currency format.
        public let numberScale: NumberScale?
        /// Determines the prefix value of the currency format.
        public let prefix: String?
        /// The options that determine the numeric separator configuration.
        public let separatorConfiguration: NumericSeparatorConfiguration?
        /// Determines the suffix value of the currency format.
        public let suffix: String?
        /// Determines the symbol for the currency format.
        public let symbol: String?

        public init(decimalPlacesConfiguration: DecimalPlacesConfiguration? = nil, negativeValueConfiguration: NegativeValueConfiguration? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numberScale: NumberScale? = nil, prefix: String? = nil, separatorConfiguration: NumericSeparatorConfiguration? = nil, suffix: String? = nil, symbol: String? = nil) {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.prefix = prefix
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
            self.symbol = symbol
        }

        public func validate(name: String) throws {
            try self.decimalPlacesConfiguration?.validate(name: "\(name).decimalPlacesConfiguration")
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 128)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
            try self.validate(self.symbol, name: "symbol", parent: name, pattern: "^[A-Z]{3}$")
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
            case negativeValueConfiguration = "NegativeValueConfiguration"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numberScale = "NumberScale"
            case prefix = "Prefix"
            case separatorConfiguration = "SeparatorConfiguration"
            case suffix = "Suffix"
            case symbol = "Symbol"
        }
    }

    public struct CustomActionFilterOperation: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that chooses the fields to be filtered.
        public let selectedFieldsConfiguration: FilterOperationSelectedFieldsConfiguration
        /// The configuration that chooses the target visuals to be filtered.
        public let targetVisualsConfiguration: FilterOperationTargetVisualsConfiguration

        public init(selectedFieldsConfiguration: FilterOperationSelectedFieldsConfiguration, targetVisualsConfiguration: FilterOperationTargetVisualsConfiguration) {
            self.selectedFieldsConfiguration = selectedFieldsConfiguration
            self.targetVisualsConfiguration = targetVisualsConfiguration
        }

        public func validate(name: String) throws {
            try self.selectedFieldsConfiguration.validate(name: "\(name).selectedFieldsConfiguration")
            try self.targetVisualsConfiguration.validate(name: "\(name).targetVisualsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case selectedFieldsConfiguration = "SelectedFieldsConfiguration"
            case targetVisualsConfiguration = "TargetVisualsConfiguration"
        }
    }

    public struct CustomActionNavigationOperation: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that chooses the navigation target.
        public let localNavigationConfiguration: LocalNavigationConfiguration?

        public init(localNavigationConfiguration: LocalNavigationConfiguration? = nil) {
            self.localNavigationConfiguration = localNavigationConfiguration
        }

        public func validate(name: String) throws {
            try self.localNavigationConfiguration?.validate(name: "\(name).localNavigationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case localNavigationConfiguration = "LocalNavigationConfiguration"
        }
    }

    public struct CustomActionSetParametersOperation: AWSEncodableShape & AWSDecodableShape {
        /// The parameter that determines the value configuration.
        public let parameterValueConfigurations: [SetParameterValueConfiguration]

        public init(parameterValueConfigurations: [SetParameterValueConfiguration]) {
            self.parameterValueConfigurations = parameterValueConfigurations
        }

        public func validate(name: String) throws {
            try self.parameterValueConfigurations.forEach {
                try $0.validate(name: "\(name).parameterValueConfigurations[]")
            }
            try self.validate(self.parameterValueConfigurations, name: "parameterValueConfigurations", parent: name, max: 200)
            try self.validate(self.parameterValueConfigurations, name: "parameterValueConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parameterValueConfigurations = "ParameterValueConfigurations"
        }
    }

    public struct CustomActionURLOperation: AWSEncodableShape & AWSDecodableShape {
        /// The target of the CustomActionURLOperation. Valid values are defined as follows:    NEW_TAB: Opens the target URL in a new browser tab.    NEW_WINDOW: Opens the target URL in a new browser window.    SAME_TAB: Opens the target URL in the same browser tab.
        public let urlTarget: URLTargetConfiguration
        /// THe URL link of the CustomActionURLOperation.
        public let urlTemplate: String

        public init(urlTarget: URLTargetConfiguration, urlTemplate: String) {
            self.urlTarget = urlTarget
            self.urlTemplate = urlTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.urlTemplate, name: "urlTemplate", parent: name, max: 2048)
            try self.validate(self.urlTemplate, name: "urlTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case urlTarget = "URLTarget"
            case urlTemplate = "URLTemplate"
        }
    }

    public struct CustomContentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The content type of the custom content visual. You can use this to have the visual render as an image.
        public let contentType: CustomContentType?
        /// The input URL that links to the custom content that you want in the custom visual.
        public let contentUrl: String?
        /// The sizing options for the size of the custom content visual. This structure is required when the ContentType of the visual is 'IMAGE'.
        public let imageScaling: CustomContentImageScalingConfiguration?

        public init(contentType: CustomContentType? = nil, contentUrl: String? = nil, imageScaling: CustomContentImageScalingConfiguration? = nil) {
            self.contentType = contentType
            self.contentUrl = contentUrl
            self.imageScaling = imageScaling
        }

        public func validate(name: String) throws {
            try self.validate(self.contentUrl, name: "contentUrl", parent: name, max: 2048)
            try self.validate(self.contentUrl, name: "contentUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case contentUrl = "ContentUrl"
            case imageScaling = "ImageScaling"
        }
    }

    public struct CustomContentVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a CustomContentVisual.
        public let chartConfiguration: CustomContentConfiguration?
        /// The dataset that is used to create the custom content visual. You can't create a visual without a dataset.
        public let dataSetIdentifier: String
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: CustomContentConfiguration? = nil, dataSetIdentifier: String, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.dataSetIdentifier = dataSetIdentifier
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case dataSetIdentifier = "DataSetIdentifier"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct CustomFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The category value for the filter. This field is mutually exclusive to ParameterName.
        public let categoryValue: String?
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: CategoryFilterMatchOperator
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to CategoryValue.
        public let parameterName: String?
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: CategoryFilterSelectAllOptions?

        public init(categoryValue: String? = nil, matchOperator: CategoryFilterMatchOperator, nullOption: FilterNullOption, parameterName: String? = nil, selectAllOptions: CategoryFilterSelectAllOptions? = nil) {
            self.categoryValue = categoryValue
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.categoryValue, name: "categoryValue", parent: name, max: 512)
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValue = "CategoryValue"
            case matchOperator = "MatchOperator"
            case nullOption = "NullOption"
            case parameterName = "ParameterName"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct CustomFilterListConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The list of category values for the filter.
        public let categoryValues: [String]?
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: CategoryFilterMatchOperator
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: CategoryFilterSelectAllOptions?

        public init(categoryValues: [String]? = nil, matchOperator: CategoryFilterMatchOperator, nullOption: FilterNullOption, selectAllOptions: CategoryFilterSelectAllOptions? = nil) {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.categoryValues?.forEach {
                try validate($0, name: "categoryValues[]", parent: name, max: 512)
            }
            try self.validate(self.categoryValues, name: "categoryValues", parent: name, max: 100_000)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValues = "CategoryValues"
            case matchOperator = "MatchOperator"
            case nullOption = "NullOption"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct CustomNarrativeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The string input of custom narrative.
        public let narrative: String

        public init(narrative: String) {
            self.narrative = narrative
        }

        public func validate(name: String) throws {
            try self.validate(self.narrative, name: "narrative", parent: name, max: 150_000)
        }

        private enum CodingKeys: String, CodingKey {
            case narrative = "Narrative"
        }
    }

    public struct CustomParameterValues: AWSEncodableShape & AWSDecodableShape {
        /// A list of datetime-type parameter values.
        public let dateTimeValues: [Date]?
        /// A list of decimal-type parameter values.
        public let decimalValues: [Double]?
        /// A list of integer-type parameter values.
        public let integerValues: [Int64]?
        /// A list of string-type parameter values.
        public let stringValues: [String]?

        public init(dateTimeValues: [Date]? = nil, decimalValues: [Double]? = nil, integerValues: [Int64]? = nil, stringValues: [String]? = nil) {
            self.dateTimeValues = dateTimeValues
            self.decimalValues = decimalValues
            self.integerValues = integerValues
            self.stringValues = stringValues
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeValues, name: "dateTimeValues", parent: name, max: 50000)
            try self.validate(self.decimalValues, name: "decimalValues", parent: name, max: 50000)
            try self.validate(self.integerValues, name: "integerValues", parent: name, max: 50000)
            try self.validate(self.stringValues, name: "stringValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeValues = "DateTimeValues"
            case decimalValues = "DecimalValues"
            case integerValues = "IntegerValues"
            case stringValues = "StringValues"
        }
    }

    public struct CustomSql: AWSEncodableShape & AWSDecodableShape {
        /// The column schema from the SQL query result set.
        public let columns: [InputColumn]?
        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String
        /// A display name for the SQL query result.
        public let name: String
        /// The SQL query.
        public let sqlQuery: String

        public init(columns: [InputColumn]? = nil, dataSourceArn: String, name: String, sqlQuery: String) {
            self.columns = columns
            self.dataSourceArn = dataSourceArn
            self.name = name
            self.sqlQuery = sqlQuery
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 2048)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sqlQuery, name: "sqlQuery", parent: name, max: 65536)
            try self.validate(self.sqlQuery, name: "sqlQuery", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case dataSourceArn = "DataSourceArn"
            case name = "Name"
            case sqlQuery = "SqlQuery"
        }
    }

    public struct CustomValuesConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let customValues: CustomParameterValues
        /// Includes the null value in custom action parameter values.
        public let includeNullValue: Bool?

        public init(customValues: CustomParameterValues, includeNullValue: Bool? = nil) {
            self.customValues = customValues
            self.includeNullValue = includeNullValue
        }

        public func validate(name: String) throws {
            try self.customValues.validate(name: "\(name).customValues")
        }

        private enum CodingKeys: String, CodingKey {
            case customValues = "CustomValues"
            case includeNullValue = "IncludeNullValue"
        }
    }

    public struct Dashboard: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard was created.
        public let createdTime: Date?
        /// Dashboard ID.
        public let dashboardId: String?
        /// The last time that this dashboard was published.
        public let lastPublishedTime: Date?
        /// The last time that this dashboard was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dashboard.
        public let name: String?
        /// Version.
        public let version: DashboardVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, dashboardId: String? = nil, lastPublishedTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, version: DashboardVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dashboardId = "DashboardId"
            case lastPublishedTime = "LastPublishedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct DashboardError: AWSDecodableShape {
        /// Message.
        public let message: String?
        /// Type.
        public let type: DashboardErrorType?
        public let violatedEntities: [Entity]?

        public init(message: String? = nil, type: DashboardErrorType? = nil, violatedEntities: [Entity]? = nil) {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
            case violatedEntities = "ViolatedEntities"
        }
    }

    public struct DashboardPublishOptions: AWSEncodableShape {
        /// Ad hoc (one-time) filtering option.
        public let adHocFilteringOption: AdHocFilteringOption?
        /// Export to .csv option.
        public let exportToCSVOption: ExportToCSVOption?
        /// Sheet controls option.
        public let sheetControlsOption: SheetControlsOption?
        public let visualPublishOptions: DashboardVisualPublishOptions?

        public init(adHocFilteringOption: AdHocFilteringOption? = nil, exportToCSVOption: ExportToCSVOption? = nil, sheetControlsOption: SheetControlsOption? = nil, visualPublishOptions: DashboardVisualPublishOptions? = nil) {
            self.adHocFilteringOption = adHocFilteringOption
            self.exportToCSVOption = exportToCSVOption
            self.sheetControlsOption = sheetControlsOption
            self.visualPublishOptions = visualPublishOptions
        }

        private enum CodingKeys: String, CodingKey {
            case adHocFilteringOption = "AdHocFilteringOption"
            case exportToCSVOption = "ExportToCSVOption"
            case sheetControlsOption = "SheetControlsOption"
            case visualPublishOptions = "VisualPublishOptions"
        }
    }

    public struct DashboardSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.    QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.    DASHBOARD_NAME: Any dashboards whose names have a substring match to this value will be returned.
        public let name: DashboardFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example  "Operator": "StringEquals". Valid values are "StringEquals" and  "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example,  "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DASHBOARD_NAME.
        public let `operator`: FilterOperator
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String?

        public init(name: DashboardFilterAttribute? = nil, operator: FilterOperator, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct DashboardSourceEntity: AWSEncodableShape {
        /// Source template.
        public let sourceTemplate: DashboardSourceTemplate?

        public init(sourceTemplate: DashboardSourceTemplate? = nil) {
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceTemplate?.validate(name: "\(name).sourceTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct DashboardSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// Dataset references.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct DashboardSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard was created.
        public let createdTime: Date?
        /// Dashboard ID.
        public let dashboardId: String?
        /// The last time that this dashboard was published.
        public let lastPublishedTime: Date?
        /// The last time that this dashboard was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dashboard.
        public let name: String?
        /// Published version number.
        public let publishedVersionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, dashboardId: String? = nil, lastPublishedTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, publishedVersionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishedVersionNumber = publishedVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dashboardId = "DashboardId"
            case lastPublishedTime = "LastPublishedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case publishedVersionNumber = "PublishedVersionNumber"
        }
    }

    public struct DashboardVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard version was created.
        public let createdTime: Date?
        /// The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.
        public let dataSetArns: [String]?
        /// Description.
        public let description: String?
        /// Errors associated with this dashboard version.
        public let errors: [DashboardError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// Source entity ARN.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The ARN of the theme associated with a version of the dashboard.
        public let themeArn: String?
        /// Version number for this version of the dashboard.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, dataSetArns: [String]? = nil, description: String? = nil, errors: [DashboardError]? = nil, sheets: [Sheet]? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, themeArn: String? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSetArns = "DataSetArns"
            case description = "Description"
            case errors = "Errors"
            case sheets = "Sheets"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case themeArn = "ThemeArn"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DashboardVersionDefinition: AWSEncodableShape & AWSDecodableShape {
        public let analysisDefaults: AnalysisDefaults?
        /// An array of calculated field definitions for the dashboard.
        public let calculatedFields: [CalculatedField]?
        /// An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard.
        public let columnConfigurations: [ColumnConfiguration]?
        /// An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.
        public let dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration]
        /// The filter definitions for a dashboard. For more information, see Filtering Data in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let filterGroups: [FilterGroup]?
        /// The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see Parameters in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterDeclarations: [ParameterDeclaration]?
        /// An array of sheet definitions for a dashboard.
        public let sheets: [SheetDefinition]?

        public init(analysisDefaults: AnalysisDefaults? = nil, calculatedFields: [CalculatedField]? = nil, columnConfigurations: [ColumnConfiguration]? = nil, dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration], filterGroups: [FilterGroup]? = nil, parameterDeclarations: [ParameterDeclaration]? = nil, sheets: [SheetDefinition]? = nil) {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }

        public func validate(name: String) throws {
            try self.calculatedFields?.forEach {
                try $0.validate(name: "\(name).calculatedFields[]")
            }
            try self.validate(self.calculatedFields, name: "calculatedFields", parent: name, max: 100)
            try self.columnConfigurations?.forEach {
                try $0.validate(name: "\(name).columnConfigurations[]")
            }
            try self.validate(self.columnConfigurations, name: "columnConfigurations", parent: name, max: 200)
            try self.dataSetIdentifierDeclarations.forEach {
                try $0.validate(name: "\(name).dataSetIdentifierDeclarations[]")
            }
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, max: 50)
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, min: 1)
            try self.filterGroups?.forEach {
                try $0.validate(name: "\(name).filterGroups[]")
            }
            try self.validate(self.filterGroups, name: "filterGroups", parent: name, max: 2000)
            try self.parameterDeclarations?.forEach {
                try $0.validate(name: "\(name).parameterDeclarations[]")
            }
            try self.validate(self.parameterDeclarations, name: "parameterDeclarations", parent: name, max: 200)
            try self.sheets?.forEach {
                try $0.validate(name: "\(name).sheets[]")
            }
            try self.validate(self.sheets, name: "sheets", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisDefaults = "AnalysisDefaults"
            case calculatedFields = "CalculatedFields"
            case columnConfigurations = "ColumnConfigurations"
            case dataSetIdentifierDeclarations = "DataSetIdentifierDeclarations"
            case filterGroups = "FilterGroups"
            case parameterDeclarations = "ParameterDeclarations"
            case sheets = "Sheets"
        }
    }

    public struct DashboardVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard version was created.
        public let createdTime: Date?
        /// Description.
        public let description: String?
        /// Source entity ARN.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// Version number.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DashboardVisualId: AWSEncodableShape {
        /// The ID of the dashboard that has the visual that you want to embed. The DashboardId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the DashboardId with a ListDashboards API operation.
        public let dashboardId: String
        /// The ID of the sheet that the has visual that you want to embed. The SheetId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        public let sheetId: String
        /// The ID of the visual that you want to embed. The VisualID can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        public let visualId: String

        public init(dashboardId: String, sheetId: String, visualId: String) {
            self.dashboardId = dashboardId
            self.sheetId = sheetId
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sheetId, name: "sheetId", parent: name, max: 512)
            try self.validate(self.sheetId, name: "sheetId", parent: name, min: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardId = "DashboardId"
            case sheetId = "SheetId"
            case visualId = "VisualId"
        }
    }

    public struct DashboardVisualPublishOptions: AWSEncodableShape {
        public let exportHiddenFieldsOption: ExportHiddenFieldsOption?

        public init(exportHiddenFieldsOption: ExportHiddenFieldsOption? = nil) {
            self.exportHiddenFieldsOption = exportHiddenFieldsOption
        }

        private enum CodingKeys: String, CodingKey {
            case exportHiddenFieldsOption = "ExportHiddenFieldsOption"
        }
    }

    public struct DataColor: AWSEncodableShape & AWSDecodableShape {
        /// The color that is applied to the data value.
        public let color: String?
        /// The data value that the color is applied to.
        public let dataValue: Double?

        public init(color: String? = nil, dataValue: Double? = nil) {
            self.color = color
            self.dataValue = dataValue
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case dataValue = "DataValue"
        }
    }

    public struct DataColorPalette: AWSEncodableShape & AWSDecodableShape {
        /// The hexadecimal codes for the colors.
        public let colors: [String]?
        /// The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        public let emptyFillColor: String?
        /// The minimum and maximum hexadecimal codes that describe a color gradient.
        public let minMaxGradient: [String]?

        public init(colors: [String]? = nil, emptyFillColor: String? = nil, minMaxGradient: [String]? = nil) {
            self.colors = colors
            self.emptyFillColor = emptyFillColor
            self.minMaxGradient = minMaxGradient
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try validate($0, name: "colors[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 100)
            try self.validate(self.emptyFillColor, name: "emptyFillColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.minMaxGradient?.forEach {
                try validate($0, name: "minMaxGradient[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.minMaxGradient, name: "minMaxGradient", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
            case emptyFillColor = "EmptyFillColor"
            case minMaxGradient = "MinMaxGradient"
        }
    }

    public struct DataFieldSeriesItem: AWSEncodableShape & AWSDecodableShape {
        /// The axis that you are binding the field to.
        public let axisBinding: AxisBinding
        /// The field ID of the field that you are setting the axis binding to.
        public let fieldId: String
        /// The field value of the field that you are setting the axis binding to.
        public let fieldValue: String?
        /// The options that determine the presentation of line series associated to the field.
        public let settings: LineChartSeriesSettings?

        public init(axisBinding: AxisBinding, fieldId: String, fieldValue: String? = nil, settings: LineChartSeriesSettings? = nil) {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.settings = settings
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.settings?.validate(name: "\(name).settings")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case fieldId = "FieldId"
            case fieldValue = "FieldValue"
            case settings = "Settings"
        }
    }

    public struct DataLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of the category field labels.
        public let categoryLabelVisibility: Visibility?
        /// The option that determines the data label type.
        public let dataLabelTypes: [DataLabelType]?
        /// Determines the color of the data labels.
        public let labelColor: String?
        /// Determines the content of the data labels.
        public let labelContent: DataLabelContent?
        /// Determines the font configuration of the data labels.
        public let labelFontConfiguration: FontConfiguration?
        /// Determines the visibility of the measure field labels.
        public let measureLabelVisibility: Visibility?
        /// Determines whether overlap is enabled or disabled for the data labels.
        public let overlap: DataLabelOverlap?
        /// Determines the position of the data labels.
        public let position: DataLabelPosition?
        /// Determines the visibility of the data labels.
        public let visibility: Visibility?

        public init(categoryLabelVisibility: Visibility? = nil, dataLabelTypes: [DataLabelType]? = nil, labelColor: String? = nil, labelContent: DataLabelContent? = nil, labelFontConfiguration: FontConfiguration? = nil, measureLabelVisibility: Visibility? = nil, overlap: DataLabelOverlap? = nil, position: DataLabelPosition? = nil, visibility: Visibility? = nil) {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.dataLabelTypes = dataLabelTypes
            self.labelColor = labelColor
            self.labelContent = labelContent
            self.labelFontConfiguration = labelFontConfiguration
            self.measureLabelVisibility = measureLabelVisibility
            self.overlap = overlap
            self.position = position
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.dataLabelTypes?.forEach {
                try $0.validate(name: "\(name).dataLabelTypes[]")
            }
            try self.validate(self.dataLabelTypes, name: "dataLabelTypes", parent: name, max: 100)
            try self.validate(self.labelColor, name: "labelColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.labelFontConfiguration?.validate(name: "\(name).labelFontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelVisibility = "CategoryLabelVisibility"
            case dataLabelTypes = "DataLabelTypes"
            case labelColor = "LabelColor"
            case labelContent = "LabelContent"
            case labelFontConfiguration = "LabelFontConfiguration"
            case measureLabelVisibility = "MeasureLabelVisibility"
            case overlap = "Overlap"
            case position = "Position"
            case visibility = "Visibility"
        }
    }

    public struct DataLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The option that specifies individual data values for labels.
        public let dataPathLabelType: DataPathLabelType?
        /// Determines the label configuration for the entire field.
        public let fieldLabelType: FieldLabelType?
        /// Determines the label configuration for the maximum value in a visual.
        public let maximumLabelType: MaximumLabelType?
        /// Determines the label configuration for the minimum value in a visual.
        public let minimumLabelType: MinimumLabelType?
        /// Determines the label configuration for range end value in a visual.
        public let rangeEndsLabelType: RangeEndsLabelType?

        public init(dataPathLabelType: DataPathLabelType? = nil, fieldLabelType: FieldLabelType? = nil, maximumLabelType: MaximumLabelType? = nil, minimumLabelType: MinimumLabelType? = nil, rangeEndsLabelType: RangeEndsLabelType? = nil) {
            self.dataPathLabelType = dataPathLabelType
            self.fieldLabelType = fieldLabelType
            self.maximumLabelType = maximumLabelType
            self.minimumLabelType = minimumLabelType
            self.rangeEndsLabelType = rangeEndsLabelType
        }

        public func validate(name: String) throws {
            try self.dataPathLabelType?.validate(name: "\(name).dataPathLabelType")
            try self.fieldLabelType?.validate(name: "\(name).fieldLabelType")
        }

        private enum CodingKeys: String, CodingKey {
            case dataPathLabelType = "DataPathLabelType"
            case fieldLabelType = "FieldLabelType"
            case maximumLabelType = "MaximumLabelType"
            case minimumLabelType = "MinimumLabelType"
            case rangeEndsLabelType = "RangeEndsLabelType"
        }
    }

    public struct DataPathColor: AWSEncodableShape & AWSDecodableShape {
        /// The color that needs to be applied to the element.
        public let color: String
        /// The element that the color needs to be applied to.
        public let element: DataPathValue
        /// The time granularity of the field that the color needs to be applied to.
        public let timeGranularity: TimeGranularity?

        public init(color: String, element: DataPathValue, timeGranularity: TimeGranularity? = nil) {
            self.color = color
            self.element = element
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.element.validate(name: "\(name).element")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case element = "Element"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct DataPathLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the field that the data label needs to be applied to.
        public let fieldId: String?
        /// The actual value of the field that is labeled.
        public let fieldValue: String?
        /// The visibility of the data label.
        public let visibility: Visibility?

        public init(fieldId: String? = nil, fieldValue: String? = nil, visibility: Visibility? = nil) {
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.fieldValue, name: "fieldValue", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case fieldValue = "FieldValue"
            case visibility = "Visibility"
        }
    }

    public struct DataPathSort: AWSEncodableShape & AWSDecodableShape {
        /// Determines the sort direction.
        public let direction: SortDirection
        /// The list of data paths that need to be sorted.
        public let sortPaths: [DataPathValue]

        public init(direction: SortDirection, sortPaths: [DataPathValue]) {
            self.direction = direction
            self.sortPaths = sortPaths
        }

        public func validate(name: String) throws {
            try self.sortPaths.forEach {
                try $0.validate(name: "\(name).sortPaths[]")
            }
            try self.validate(self.sortPaths, name: "sortPaths", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "Direction"
            case sortPaths = "SortPaths"
        }
    }

    public struct DataPathValue: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the field that needs to be sorted.
        public let fieldId: String
        /// The actual value of the field that needs to be sorted.
        public let fieldValue: String

        public init(fieldId: String, fieldValue: String) {
            self.fieldId = fieldId
            self.fieldValue = fieldValue
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.fieldValue, name: "fieldValue", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case fieldValue = "FieldValue"
        }
    }

    public struct DataSet: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.
        public let consumedSpiceCapacityInBytes: Int64?
        /// The time that this dataset was created.
        public let createdTime: Date?
        /// The ID of the dataset.
        public let dataSetId: String?
        /// The usage configuration to apply to child datasets that reference this dataset as a source.
        public let dataSetUsageConfiguration: DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// A value that indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode?
        /// The last time that this dataset was updated.
        public let lastUpdatedTime: Date?
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// A display name for the dataset.
        public let name: String?
        /// The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.
        public let outputColumns: [OutputColumn]?
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]?
        /// The row-level security configuration for the dataset.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// The element you can use to define tags for row-level security.
        public let rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration?

        public init(arn: String? = nil, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, consumedSpiceCapacityInBytes: Int64? = nil, createdTime: Date? = nil, dataSetId: String? = nil, dataSetUsageConfiguration: DataSetUsageConfiguration? = nil, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode? = nil, lastUpdatedTime: Date? = nil, logicalTableMap: [String: LogicalTable]? = nil, name: String? = nil, outputColumns: [OutputColumn]? = nil, physicalTableMap: [String: PhysicalTable]? = nil, rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration? = nil) {
            self.arn = arn
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytes
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.outputColumns = outputColumns
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case consumedSpiceCapacityInBytes = "ConsumedSpiceCapacityInBytes"
            case createdTime = "CreatedTime"
            case dataSetId = "DataSetId"
            case dataSetUsageConfiguration = "DataSetUsageConfiguration"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case lastUpdatedTime = "LastUpdatedTime"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case outputColumns = "OutputColumns"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        }
    }

    public struct DataSetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A structure containing the list of column group schemas.
        public let columnGroupSchemaList: [ColumnGroupSchema]?
        /// Dataset schema.
        public let dataSetSchema: DataSetSchema?
        /// Placeholder.
        public let placeholder: String?

        public init(columnGroupSchemaList: [ColumnGroupSchema]? = nil, dataSetSchema: DataSetSchema? = nil, placeholder: String? = nil) {
            self.columnGroupSchemaList = columnGroupSchemaList
            self.dataSetSchema = dataSetSchema
            self.placeholder = placeholder
        }

        public func validate(name: String) throws {
            try self.columnGroupSchemaList?.forEach {
                try $0.validate(name: "\(name).columnGroupSchemaList[]")
            }
            try self.validate(self.columnGroupSchemaList, name: "columnGroupSchemaList", parent: name, max: 500)
            try self.dataSetSchema?.validate(name: "\(name).dataSetSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroupSchemaList = "ColumnGroupSchemaList"
            case dataSetSchema = "DataSetSchema"
            case placeholder = "Placeholder"
        }
    }

    public struct DataSetIdentifierDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data set.
        public let dataSetArn: String
        /// The identifier of the data set, typically the data set's name.
        public let identifier: String

        public init(dataSetArn: String, identifier: String) {
            self.dataSetArn = dataSetArn
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 2048)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case identifier = "Identifier"
        }
    }

    public struct DataSetReference: AWSEncodableShape {
        /// Dataset Amazon Resource Name (ARN).
        public let dataSetArn: String
        /// Dataset placeholder.
        public let dataSetPlaceholder: String

        public init(dataSetArn: String, dataSetPlaceholder: String) {
            self.dataSetArn = dataSetArn
            self.dataSetPlaceholder = dataSetPlaceholder
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetPlaceholder, name: "dataSetPlaceholder", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetPlaceholder = "DataSetPlaceholder"
        }
    }

    public struct DataSetSchema: AWSEncodableShape & AWSDecodableShape {
        /// A structure containing the list of column schemas.
        public let columnSchemaList: [ColumnSchema]?

        public init(columnSchemaList: [ColumnSchema]? = nil) {
            self.columnSchemaList = columnSchemaList
        }

        public func validate(name: String) throws {
            try self.validate(self.columnSchemaList, name: "columnSchemaList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case columnSchemaList = "ColumnSchemaList"
        }
    }

    public struct DataSetSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.    QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.    DATASET_NAME: Any datasets whose names have a substring match to this value will be returned.
        public let name: DataSetFilterAttribute
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose datasets you want to search in the "Value" field. For example, "Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the datasets you are searching for. For example, "Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASET_NAME.
        public let `operator`: FilterOperator
        /// The value of the named item, in this case QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String

        public init(name: DataSetFilterAttribute, operator: FilterOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct DataSetSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// A value that indicates if the dataset has column level permission configured.
        public let columnLevelPermissionRulesApplied: Bool?
        /// The time that this dataset was created.
        public let createdTime: Date?
        /// The ID of the dataset.
        public let dataSetId: String?
        /// A value that indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode?
        /// The last time that this dataset was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dataset.
        public let name: String?
        /// The row-level security configuration for the dataset.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// Whether or not the row level permission tags are applied.
        public let rowLevelPermissionTagConfigurationApplied: Bool?

        public init(arn: String? = nil, columnLevelPermissionRulesApplied: Bool? = nil, createdTime: Date? = nil, dataSetId: String? = nil, importMode: DataSetImportMode? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfigurationApplied: Bool? = nil) {
            self.arn = arn
            self.columnLevelPermissionRulesApplied = columnLevelPermissionRulesApplied
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfigurationApplied = rowLevelPermissionTagConfigurationApplied
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case columnLevelPermissionRulesApplied = "ColumnLevelPermissionRulesApplied"
            case createdTime = "CreatedTime"
            case dataSetId = "DataSetId"
            case importMode = "ImportMode"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfigurationApplied = "RowLevelPermissionTagConfigurationApplied"
        }
    }

    public struct DataSetUsageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An option that controls whether a child dataset of a direct query can use this dataset as a source.
        public let disableUseAsDirectQuerySource: Bool?
        /// An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        public let disableUseAsImportedSource: Bool?

        public init(disableUseAsDirectQuerySource: Bool? = nil, disableUseAsImportedSource: Bool? = nil) {
            self.disableUseAsDirectQuerySource = disableUseAsDirectQuerySource
            self.disableUseAsImportedSource = disableUseAsImportedSource
        }

        private enum CodingKeys: String, CodingKey {
            case disableUseAsDirectQuerySource = "DisableUseAsDirectQuerySource"
            case disableUseAsImportedSource = "DisableUseAsImportedSource"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the AlternateDataSourceParameters list is null, the Credentials originally used with this DataSourceParameters are automatically allowed.
        public let alternateDataSourceParameters: [DataSourceParameters]?
        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The time that this data source was created.
        public let createdTime: Date?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
        public let dataSourceParameters: DataSourceParameters?
        /// Error information from the last update or the creation of the data source.
        public let errorInfo: DataSourceErrorInfo?
        /// The last time that this data source was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the data source.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public let secretArn: String?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
        public let sslProperties: SslProperties?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The type of the data source. This type indicates which database engine the data source connects to.
        public let type: DataSourceType?
        /// The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(alternateDataSourceParameters: [DataSourceParameters]? = nil, arn: String? = nil, createdTime: Date? = nil, dataSourceId: String? = nil, dataSourceParameters: DataSourceParameters? = nil, errorInfo: DataSourceErrorInfo? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, secretArn: String? = nil, sslProperties: SslProperties? = nil, status: ResourceStatus? = nil, type: DataSourceType? = nil, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.errorInfo = errorInfo
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.secretArn = secretArn
            self.sslProperties = sslProperties
            self.status = status
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        private enum CodingKeys: String, CodingKey {
            case alternateDataSourceParameters = "AlternateDataSourceParameters"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSourceId = "DataSourceId"
            case dataSourceParameters = "DataSourceParameters"
            case errorInfo = "ErrorInfo"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case secretArn = "SecretArn"
            case sslProperties = "SslProperties"
            case status = "Status"
            case type = "Type"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct DataSourceCredentials: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When CopySourceArn is not null, the credential pair from the data source in the ARN is used as the credentials for the DataSourceCredentials structure.
        public let copySourceArn: String?
        /// Credential pair. For more information, see  CredentialPair .
        public let credentialPair: CredentialPair?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public let secretArn: String?

        public init(copySourceArn: String? = nil, credentialPair: CredentialPair? = nil, secretArn: String? = nil) {
            self.copySourceArn = copySourceArn
            self.credentialPair = credentialPair
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.copySourceArn, name: "copySourceArn", parent: name, pattern: "^arn:[-a-z0-9]*:quicksight:[-a-z0-9]*:[0-9]{12}:datasource/.+$")
            try self.credentialPair?.validate(name: "\(name).credentialPair")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 2048)
            try self.validate(self.secretArn, name: "secretArn", parent: name, min: 1)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[-a-z0-9]*:secretsmanager:[-a-z0-9]*:[0-9]{12}:secret:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case copySourceArn = "CopySourceArn"
            case credentialPair = "CredentialPair"
            case secretArn = "SecretArn"
        }
    }

    public struct DataSourceErrorInfo: AWSDecodableShape {
        /// Error message.
        public let message: String?
        /// Error type.
        public let type: DataSourceErrorInfoType?

        public init(message: String? = nil, type: DataSourceErrorInfoType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct DataSourceSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example, "Name": "DIRECT_QUICKSIGHT_OWNER". Valid values are defined as follows:    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.    DATASOURCE_NAME: Any data sources whose names have a substring match to the provided value are returned.
        public let name: DataSourceFilterAttribute
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose data sources you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the data sources you are searching for. For example, "Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASOURCE_NAME.
        public let `operator`: FilterOperator
        /// The value of the named item, for example DIRECT_QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String

        public init(name: DataSourceFilterAttribute, operator: FilterOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct DataSourceSummary: AWSDecodableShape {
        /// The arn of the datasource.
        public let arn: String?
        /// The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public let createdTime: Date?
        /// The unique ID of the data source.
        public let dataSourceId: String?
        /// The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public let lastUpdatedTime: Date?
        /// The name of the data source.
        public let name: String?
        /// The type of the data source.
        public let type: DataSourceType?

        public init(arn: String? = nil, createdTime: Date? = nil, dataSourceId: String? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, type: DataSourceType? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSourceId = "DataSourceId"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct DatabricksParameters: AWSEncodableShape & AWSDecodableShape {
        /// The host name of the Databricks data source.
        public let host: String
        /// The port for the Databricks data source.
        public let port: Int
        /// The HTTP path of the Databricks data source.
        public let sqlEndpointPath: String

        public init(host: String, port: Int, sqlEndpointPath: String) {
            self.host = host
            self.port = port
            self.sqlEndpointPath = sqlEndpointPath
        }

        public func validate(name: String) throws {
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.sqlEndpointPath, name: "sqlEndpointPath", parent: name, max: 4096)
            try self.validate(self.sqlEndpointPath, name: "sqlEndpointPath", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case port = "Port"
            case sqlEndpointPath = "SqlEndpointPath"
        }
    }

    public struct DateAxisOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not missing dates are displayed.
        public let missingDateVisibility: Visibility?

        public init(missingDateVisibility: Visibility? = nil) {
            self.missingDateVisibility = missingDateVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case missingDateVisibility = "MissingDateVisibility"
        }
    }

    public struct DateDimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the DateDimensionField.
        public let column: ColumnIdentifier
        /// The date granularity of the DateDimensionField. Choose one of the following options:    YEAR     QUARTER     MONTH     WEEK     DAY     HOUR     MINUTE     SECOND     MILLISECOND
        public let dateGranularity: TimeGranularity?
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: DateTimeFormatConfiguration?
        /// The custom hierarchy ID.
        public let hierarchyId: String?

        public init(column: ColumnIdentifier, dateGranularity: TimeGranularity? = nil, fieldId: String, formatConfiguration: DateTimeFormatConfiguration? = nil, hierarchyId: String? = nil) {
            self.column = column
            self.dateGranularity = dateGranularity
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case dateGranularity = "DateGranularity"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct DateMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the measure field.
        public let aggregationFunction: DateAggregationFunction?
        /// The column that is used in the DateMeasureField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: DateTimeFormatConfiguration?

        public init(aggregationFunction: DateAggregationFunction? = nil, column: ColumnIdentifier, fieldId: String, formatConfiguration: DateTimeFormatConfiguration? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct DateTimeDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the  DataTimeDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The rolling date of the DataTimeDefaultValues. The date is determined from the dataset based on input expression.
        public let rollingDate: RollingDateConfiguration?
        /// The static values of the DataTimeDefaultValues.
        public let staticValues: [Date]?

        public init(dynamicValue: DynamicDefaultValue? = nil, rollingDate: RollingDateConfiguration? = nil, staticValues: [Date]? = nil) {
            self.dynamicValue = dynamicValue
            self.rollingDate = rollingDate
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.rollingDate?.validate(name: "\(name).rollingDate")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case rollingDate = "RollingDate"
            case staticValues = "StaticValues"
        }
    }

    public struct DateTimeFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the DateTime format.
        public let dateTimeFormat: String?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// The formatting configuration for numeric DateTime fields.
        public let numericFormatConfiguration: NumericFormatConfiguration?

        public init(dateTimeFormat: String? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numericFormatConfiguration: NumericFormatConfiguration? = nil) {
            self.dateTimeFormat = dateTimeFormat
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, max: 128)
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, min: 1)
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.numericFormatConfiguration?.validate(name: "\(name).numericFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormat = "DateTimeFormat"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numericFormatConfiguration = "NumericFormatConfiguration"
        }
    }

    public struct DateTimeHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the drill down filters for the DateTime hierarchy.
        public let drillDownFilters: [DrillDownFilter]?
        /// The hierarchy ID of the DateTime hierarchy.
        public let hierarchyId: String

        public init(drillDownFilters: [DrillDownFilter]? = nil, hierarchyId: String) {
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.drillDownFilters?.forEach {
                try $0.validate(name: "\(name).drillDownFilters[]")
            }
            try self.validate(self.drillDownFilters, name: "drillDownFilters", parent: name, max: 10)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case drillDownFilters = "DrillDownFilters"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct DateTimeParameter: AWSEncodableShape {
        /// A display name for the date-time parameter.
        public let name: String
        /// The values for the date-time parameter.
        public let values: [Date]

        public init(name: String, values: [Date]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct DateTimeParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: DateTimeDefaultValues?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?
        /// The configuration that defines the default value of a DateTime parameter when a value has not been set.
        public let valueWhenUnset: DateTimeValueWhenUnsetConfiguration?

        public init(defaultValues: DateTimeDefaultValues? = nil, name: String, timeGranularity: TimeGranularity? = nil, valueWhenUnset: DateTimeValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.name = name
            self.timeGranularity = timeGranularity
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case name = "Name"
            case timeGranularity = "TimeGranularity"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct DateTimePickerControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// Customize how dates are formatted in controls.
        public let dateTimeFormat: String?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(dateTimeFormat: String? = nil, titleOptions: LabelOptions? = nil) {
            self.dateTimeFormat = dateTimeFormat
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, max: 128)
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, min: 1)
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormat = "DateTimeFormat"
            case titleOptions = "TitleOptions"
        }
    }

    public struct DateTimeValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: Date?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: Date? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct DecimalDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the DecimalDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public let staticValues: [Double]?

        public init(dynamicValue: DynamicDefaultValue? = nil, staticValues: [Double]? = nil) {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case staticValues = "StaticValues"
        }
    }

    public struct DecimalParameter: AWSEncodableShape {
        /// A display name for the decimal parameter.
        public let name: String
        /// The values for the decimal parameter.
        public let values: [Double]

        public init(name: String, values: [Double]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct DecimalParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: DecimalDefaultValues?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        public let parameterValueType: ParameterValueType
        /// The configuration that defines the default value of a Decimal parameter when a value has not been set.
        public let valueWhenUnset: DecimalValueWhenUnsetConfiguration?

        public init(defaultValues: DecimalDefaultValues? = nil, name: String, parameterValueType: ParameterValueType, valueWhenUnset: DecimalValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case name = "Name"
            case parameterValueType = "ParameterValueType"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct DecimalPlacesConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The values of the decimal places.
        public let decimalPlaces: Int64

        public init(decimalPlaces: Int64) {
            self.decimalPlaces = decimalPlaces
        }

        public func validate(name: String) throws {
            try self.validate(self.decimalPlaces, name: "decimalPlaces", parent: name, max: 20)
            try self.validate(self.decimalPlaces, name: "decimalPlaces", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlaces = "DecimalPlaces"
        }
    }

    public struct DecimalValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: Double?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: Double? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct DefaultFreeFormLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the screen canvas size options for a free-form layout.
        public let canvasSizeOptions: FreeFormLayoutCanvasSizeOptions

        public init(canvasSizeOptions: FreeFormLayoutCanvasSizeOptions) {
            self.canvasSizeOptions = canvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
        }
    }

    public struct DefaultGridLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the screen canvas size options for a grid layout.
        public let canvasSizeOptions: GridLayoutCanvasSizeOptions

        public init(canvasSizeOptions: GridLayoutCanvasSizeOptions) {
            self.canvasSizeOptions = canvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
        }
    }

    public struct DefaultInteractiveLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the default settings of a free-form layout configuration.
        public let freeForm: DefaultFreeFormLayoutConfiguration?
        /// The options that determine the default settings for a grid layout configuration.
        public let grid: DefaultGridLayoutConfiguration?

        public init(freeForm: DefaultFreeFormLayoutConfiguration? = nil, grid: DefaultGridLayoutConfiguration? = nil) {
            self.freeForm = freeForm
            self.grid = grid
        }

        private enum CodingKeys: String, CodingKey {
            case freeForm = "FreeForm"
            case grid = "Grid"
        }
    }

    public struct DefaultNewSheetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the default settings for interactive layout configuration.
        public let interactiveLayoutConfiguration: DefaultInteractiveLayoutConfiguration?
        /// The options that determine the default settings for a paginated layout configuration.
        public let paginatedLayoutConfiguration: DefaultPaginatedLayoutConfiguration?
        /// The option that determines the sheet content type.
        public let sheetContentType: SheetContentType?

        public init(interactiveLayoutConfiguration: DefaultInteractiveLayoutConfiguration? = nil, paginatedLayoutConfiguration: DefaultPaginatedLayoutConfiguration? = nil, sheetContentType: SheetContentType? = nil) {
            self.interactiveLayoutConfiguration = interactiveLayoutConfiguration
            self.paginatedLayoutConfiguration = paginatedLayoutConfiguration
            self.sheetContentType = sheetContentType
        }

        private enum CodingKeys: String, CodingKey {
            case interactiveLayoutConfiguration = "InteractiveLayoutConfiguration"
            case paginatedLayoutConfiguration = "PaginatedLayoutConfiguration"
            case sheetContentType = "SheetContentType"
        }
    }

    public struct DefaultPaginatedLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the default settings for a section-based layout configuration.
        public let sectionBased: DefaultSectionBasedLayoutConfiguration?

        public init(sectionBased: DefaultSectionBasedLayoutConfiguration? = nil) {
            self.sectionBased = sectionBased
        }

        private enum CodingKeys: String, CodingKey {
            case sectionBased = "SectionBased"
        }
    }

    public struct DefaultSectionBasedLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the screen canvas size options for a section-based layout.
        public let canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions

        public init(canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions) {
            self.canvasSizeOptions = canvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
        }
    }

    public struct DeleteAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring("namespace"))
        ]

        /// The ID for the Amazon Web Services account that you want to delete Amazon QuickSight customizations from in this Amazon Web Services Region.
        public let awsAccountId: String
        /// The Amazon QuickSight namespace that you're deleting the customizations from.
        public let namespace: String?

        public init(awsAccountId: String, namespace: String? = nil) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteAccountSubscriptionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The Amazon Web Services account ID of the account that you want to delete.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccountSubscriptionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "forceDeleteWithoutRecovery", location: .querystring("force-delete-without-recovery")),
            AWSMemberEncoding(label: "recoveryWindowInDays", location: .querystring("recovery-window-in-days"))
        ]

        /// The ID of the analysis that you're deleting.
        public let analysisId: String
        /// The ID of the Amazon Web Services account where you want to delete an analysis.
        public let awsAccountId: String
        /// This option defaults to the value NoForceDeleteWithoutRecovery. To immediately delete the analysis, add the ForceDeleteWithoutRecovery option. You can't restore an analysis after it's deleted.
        public let forceDeleteWithoutRecovery: Bool?
        /// A value that specifies the number of days that Amazon QuickSight waits before it deletes the analysis. You can't use this parameter with the ForceDeleteWithoutRecovery option in the same API call. The default value is 30.
        public let recoveryWindowInDays: Int64?

        public init(analysisId: String, awsAccountId: String, forceDeleteWithoutRecovery: Bool? = nil, recoveryWindowInDays: Int64? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
            self.recoveryWindowInDays = recoveryWindowInDays
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.recoveryWindowInDays, name: "recoveryWindowInDays", parent: name, max: 30)
            try self.validate(self.recoveryWindowInDays, name: "recoveryWindowInDays", parent: name, min: 7)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the deleted analysis.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the deleted analysis.
        public let arn: String?
        /// The date and time that the analysis is scheduled to be deleted.
        public let deletionTime: Date?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, deletionTime: Date? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.deletionTime = deletionTime
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case deletionTime = "DeletionTime"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The ID of the Amazon Web Services account that contains the dashboard that you're deleting.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number of the dashboard. If the version number property is provided, only the specified version of the dashboard is deleted.
        public let versionNumber: Int64?

        public init(awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Secure Socket Layer (SSL) properties that apply for the resource.
        public let arn: String?
        /// The ID of the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri("DataSourceId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source that you deleted.
        public let arn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteFolderMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId")),
            AWSMemberEncoding(label: "memberId", location: .uri("MemberId")),
            AWSMemberEncoding(label: "memberType", location: .uri("MemberType"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The Folder ID.
        public let folderId: String
        /// The ID of the asset (the dashboard, analysis, or dataset) that you want to delete.
        public let memberId: String
        /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET
        public let memberType: MemberType

        public init(awsAccountId: String, folderId: String, memberId: String, memberType: MemberType) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.memberId = memberId
            self.memberType = memberType
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 2048)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderMembershipResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name of the deleted folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteGroupMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri("GroupName")),
            AWSMemberEncoding(label: "memberName", location: .uri("MemberName")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to delete the user from.
        public let groupName: String
        /// The name of the user that you want to delete from the group membership.
        public let memberName: String
        /// The namespace of the group that you want to remove a user from.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupMembershipResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri("GroupName")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to delete.
        public let groupName: String
        /// The namespace of the group that you want to delete.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assignmentName", location: .uri("AssignmentName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The name of the assignment.
        public let assignmentName: String
        /// The Amazon Web Services account ID where you want to delete the IAM policy assignment.
        public let awsAccountId: String
        /// The namespace that contains the assignment.
        public let namespace: String

        public init(assignmentName: String, awsAccountId: String, namespace: String) {
            self.assignmentName = assignmentName
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the assignment.
        public let assignmentName: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentName: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentName = assignmentName
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that you want to delete the Amazon QuickSight namespace from.
        public let awsAccountId: String
        /// The namespace that you want to delete.
        public let namespace: String

        public init(awsAccountId: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNamespaceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The name for the template alias. To delete a specific alias, you delete the version that the
        /// 			alias points to. You can specify the alias name, or specify the latest version of the
        /// 			template by providing the keyword $LATEST in the AliasName
        /// 			parameter.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the item to delete.
        public let awsAccountId: String
        /// The ID for the template that the specified alias is for.
        public let templateId: String

        public init(aliasName: String, awsAccountId: String, templateId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name for the template alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the template you want to delete.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the template associated with the deletion.
        public let templateId: String?

        public init(aliasName: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
        }
    }

    public struct DeleteTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The ID of the Amazon Web Services account that contains the template that you're deleting.
        public let awsAccountId: String
        /// An ID for the template you want to delete.
        public let templateId: String
        /// Specifies the version of the template that you want to delete.
        /// 			If you don't provide a version number, DeleteTemplate deletes all versions of the template.
        ///
        public let versionNumber: Int64?

        public init(awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the template.
        public let templateId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
        }
    }

    public struct DeleteThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The unique name for the theme alias to delete.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme alias to delete.
        public let awsAccountId: String
        /// The ID for the theme that the specified alias is for.
        public let themeId: String

        public init(aliasName: String, awsAccountId: String, themeId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name for the theme alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the theme resource using the deleted alias.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the theme associated with the deletion.
        public let themeId: String?

        public init(aliasName: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
        }
    }

    public struct DeleteThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The ID of the Amazon Web Services account that contains the theme that you're deleting.
        public let awsAccountId: String
        /// An ID for the theme that you want to delete.
        public let themeId: String
        /// The version of the theme that you want to delete.   Note: If you don't provide a version number, you're
        /// 			using this call to DeleteTheme to delete all versions of the theme.
        public let versionNumber: Int64?

        public init(awsAccountId: String, themeId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the theme.
        public let themeId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
        }
    }

    public struct DeleteUserByPrincipalIdRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "principalId", location: .uri("PrincipalId"))
        ]

        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The principal ID of the user.
        public let principalId: String

        public init(awsAccountId: String, namespace: String, principalId: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.principalId = principalId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserByPrincipalIdResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "userName", location: .uri("UserName"))
        ]

        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The name of the user that you want to delete.
        public let userName: String

        public init(awsAccountId: String, namespace: String, userName: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring("namespace")),
            AWSMemberEncoding(label: "resolved", location: .querystring("resolved"))
        ]

        /// The ID for the Amazon Web Services account that you want to describe Amazon QuickSight customizations for.
        public let awsAccountId: String
        /// The Amazon QuickSight namespace that you want to describe Amazon QuickSight customizations for.
        public let namespace: String?
        /// The Resolved flag works with the other parameters to determine which view of Amazon QuickSight customizations is returned. You can add this flag to your command to use the same view that Amazon QuickSight uses to identify which customizations to apply to the console. Omit this flag, or set it to no-resolved, to reveal customizations that are configured at different levels.
        public let resolved: Bool?

        public init(awsAccountId: String, namespace: String? = nil, resolved: Bool? = nil) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.resolved = resolved
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon QuickSight customizations that exist in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) of the customization that's associated with this Amazon Web Services account.
        public let arn: String?
        /// The ID for the Amazon Web Services account that you're describing.
        public let awsAccountId: String?
        /// The Amazon QuickSight namespace that you're describing.
        public let namespace: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAccountSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID for the Amazon Web Services account that contains the settings that you want to list.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountSettingsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon QuickSight settings for this Amazon Web Services account. This information includes the edition of Amazon Amazon QuickSight that you subscribed to (Standard or Enterprise) and the notification email for the Amazon QuickSight subscription.  In the QuickSight console, the Amazon QuickSight subscription is sometimes referred to as a QuickSight "account" even though it's technically not an account by itself. Instead, it's a subscription to the Amazon QuickSight service for your Amazon Web Services account. The edition that you subscribe to applies to Amazon QuickSight in every Amazon Web Services Region where you use it.
        public let accountSettings: AccountSettings?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountSettings: AccountSettings? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountSettings = accountSettings
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "AccountSettings"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAccountSubscriptionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The Amazon Web Services account ID associated with your Amazon QuickSight account.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountSubscriptionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains the following elements:   Your Amazon QuickSight account name.   The edition of Amazon QuickSight that your account is using.   The notification email address that is associated with the Amazon QuickSight account.    The authentication type of the Amazon QuickSight account.   The status of the Amazon QuickSight account's subscription.
        public let accountInfo: AccountInfo?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountInfo: AccountInfo? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountInfo = accountInfo
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountInfo = "AccountInfo"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAnalysisDefinitionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis. You must be using the Amazon Web Services account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisDefinitionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the analysis described.
        public let analysisId: String?
        /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: AnalysisDefinition?
        /// Errors associated with the analysis.
        public let errors: [AnalysisError]?
        /// The descriptive name of the analysis.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// Status associated with the analysis.    CREATION_IN_PROGRESS     CREATION_SUCCESSFUL     CREATION_FAILED     UPDATE_IN_PROGRESS     UPDATE_SUCCESSFUL     UPDATE_FAILED     DELETED
        public let resourceStatus: ResourceStatus?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the theme of the analysis.
        public let themeArn: String?

        public init(analysisId: String? = nil, definition: AnalysisDefinition? = nil, errors: [AnalysisError]? = nil, name: String? = nil, requestId: String? = nil, resourceStatus: ResourceStatus? = nil, status: Int? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.definition = definition
            self.errors = errors
            self.name = name
            self.requestId = requestId
            self.resourceStatus = resourceStatus
            self.status = status
            self.themeArn = themeArn
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case definition = "Definition"
            case errors = "Errors"
            case name = "Name"
            case requestId = "RequestId"
            case resourceStatus = "ResourceStatus"
            case status = "Status"
            case themeArn = "ThemeArn"
        }
    }

    public struct DescribeAnalysisPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the analysis whose permissions you're describing. The ID is part of the analysis URL.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're describing. You must be using the Amazon Web Services account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the analysis whose permissions you're describing.
        public let analysisArn: String?
        /// The ID of the analysis whose permissions you're describing.
        public let analysisId: String?
        /// A structure that describes the principals and the resource-level permissions on an analysis.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisArn: String? = nil, analysisId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisArn = analysisArn
            self.analysisId = analysisId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisArn = "AnalysisArn"
            case analysisId = "AnalysisId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis. You must be using the  Amazon Web Services account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A metadata structure that contains summary information for the analysis that you're describing.
        public let analysis: Analysis?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysis: Analysis? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysis = analysis
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysis = "Analysis"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDashboardDefinitionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring("alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The alias name.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardDefinitionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the dashboard described.
        public let dashboardId: String?
        /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: DashboardVersionDefinition?
        /// Errors associated with this dashboard version.
        public let errors: [DashboardError]?
        /// The display name of the dashboard.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// Status associated with the dashboard version.    CREATION_IN_PROGRESS     CREATION_SUCCESSFUL     CREATION_FAILED     UPDATE_IN_PROGRESS     UPDATE_SUCCESSFUL     UPDATE_FAILED     DELETED
        public let resourceStatus: ResourceStatus?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the theme of the dashboard.
        public let themeArn: String?

        public init(dashboardId: String? = nil, definition: DashboardVersionDefinition? = nil, errors: [DashboardError]? = nil, name: String? = nil, requestId: String? = nil, resourceStatus: ResourceStatus? = nil, status: Int? = nil, themeArn: String? = nil) {
            self.dashboardId = dashboardId
            self.definition = definition
            self.errors = errors
            self.name = name
            self.requestId = requestId
            self.resourceStatus = resourceStatus
            self.status = status
            self.themeArn = themeArn
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardId = "DashboardId"
            case definition = "Definition"
            case errors = "Errors"
            case name = "Name"
            case requestId = "RequestId"
            case resourceStatus = "ResourceStatus"
            case status = "Status"
            case themeArn = "ThemeArn"
        }
    }

    public struct DescribeDashboardPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId"))
        ]

        /// The ID of the Amazon Web Services account that contains the dashboard that you're describing permissions for.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the IAM policy.
        public let dashboardId: String

        public init(awsAccountId: String, dashboardId: String) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// A structure that contains the configuration of a shareable link that grants access to the dashboard. Your users can use the link to view and interact with the dashboard, if the dashboard has been shared with them. For more information about sharing dashboards, see Sharing Dashboards.
        public let linkSharingConfiguration: LinkSharingConfiguration?
        /// A structure that contains the permissions for the dashboard.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, linkSharingConfiguration: LinkSharingConfiguration? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.linkSharingConfiguration = linkSharingConfiguration
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case linkSharingConfiguration = "LinkSharingConfiguration"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring("alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The alias name.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information about the dashboard.
        public let dashboard: Dashboard?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of this request.
        public let status: Int?

        public init(dashboard: Dashboard? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboard = dashboard
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboard = "Dashboard"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSetPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSetPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let dataSetArn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// A list of resource permissions on the dataset.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetArn: String? = nil, dataSetId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetArn = dataSetArn
            self.dataSetId = dataSetId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetId = "DataSetId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information on the dataset.
        public let dataSet: DataSet?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSet: DataSet? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSet = dataSet
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSet = "DataSet"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSourcePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri("DataSourceId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSourcePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// A list of resource permissions on the data source.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case dataSourceId = "DataSourceId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri("DataSourceId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The information on the data source.
        public let dataSource: DataSource?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSource: DataSource? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSource = dataSource
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeFolderPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// Information about the permissions on the folder.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderResolvedPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderResolvedPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// Information about the permissions for the folder.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information about the folder.
        public let folder: Folder?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folder: Folder? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folder = folder
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folder = "Folder"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeGroupMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri("GroupName")),
            AWSMemberEncoding(label: "memberName", location: .uri("MemberName")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the  Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to search.
        public let groupName: String
        /// The user name of the user that you want to search for.
        public let memberName: String
        /// The namespace that includes the group you are searching within.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGroupMembershipResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        public let groupMember: GroupMember?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMember: GroupMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMember = groupMember
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupMember = "GroupMember"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri("GroupName")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to describe.
        public let groupName: String
        /// The namespace of the group that you want described.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the group.
        public let group: Group?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assignmentName", location: .uri("AssignmentName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The name of the assignment, also called a rule.
        public let assignmentName: String
        /// The ID of the Amazon Web Services account that contains the assignment that you want to describe.
        public let awsAccountId: String
        /// The namespace that contains the assignment.
        public let namespace: String

        public init(assignmentName: String, awsAccountId: String, namespace: String) {
            self.assignmentName = assignmentName
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information describing the IAM policy assignment.
        public let iamPolicyAssignment: IAMPolicyAssignment?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(iamPolicyAssignment: IAMPolicyAssignment? = nil, requestId: String? = nil, status: Int? = nil) {
            self.iamPolicyAssignment = iamPolicyAssignment
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case iamPolicyAssignment = "IAMPolicyAssignment"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeIngestionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId")),
            AWSMemberEncoding(label: "ingestionId", location: .uri("IngestionId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String

        public init(awsAccountId: String, dataSetId: String, ingestionId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIngestionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information about the ingestion.
        public let ingestion: Ingestion?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(ingestion: Ingestion? = nil, requestId: String? = nil, status: Int? = nil) {
            self.ingestion = ingestion
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case ingestion = "Ingestion"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeIpRestrictionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIpRestrictionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String?
        /// A value that specifies whether IP rules are turned on.
        public let enabled: Bool?
        /// A map that describes the IP rules with CIDR range and description.
        public let ipRestrictionRuleMap: [String: String]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(awsAccountId: String? = nil, enabled: Bool? = nil, ipRestrictionRuleMap: [String: String]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.awsAccountId = awsAccountId
            self.enabled = enabled
            self.ipRestrictionRuleMap = ipRestrictionRuleMap
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case enabled = "Enabled"
            case ipRestrictionRuleMap = "IpRestrictionRuleMap"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespace that you want to describe.
        public let awsAccountId: String
        /// The namespace that you want to describe.
        public let namespace: String

        public init(awsAccountId: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeNamespaceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The information about the namespace that you're describing. The response includes  the namespace ARN, name, Amazon Web Services Region, creation status, and identity store. DescribeNamespace also works for namespaces that are in the process of being created. For incomplete namespaces, this API operation lists the namespace error types and messages associated with the creation process.
        public let namespace: NamespaceInfoV2?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(namespace: NamespaceInfoV2? = nil, requestId: String? = nil, status: Int? = nil) {
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The name of the template alias that you want to describe. If you name a specific alias, you
        /// 			describe the version that the alias points to. You can specify the latest version of the
        /// 			template by providing the keyword $LATEST in the AliasName
        /// 			parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the template alias that you're
        /// 			describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String

        public init(aliasName: String, awsAccountId: String, templateId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct DescribeTemplateDefinitionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring("alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The alias of the template that you want to describe. If you name a specific alias, you
        /// 			 describe the version that the alias points to. You can specify the latest version of the
        /// 			 template by providing the keyword $LATEST in the AliasName
        /// 			 parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the template. You must be using the
        /// 			 Amazon Web Services account that the template is in.
        public let awsAccountId: String
        /// The ID of the template that you're describing.
        public let templateId: String
        /// The version number of the template.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateDefinitionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The definition of the template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: TemplateVersionDefinition?
        /// Errors associated with the template version.
        public let errors: [TemplateError]?
        /// The descriptive name of the template.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// Status associated with the template.    CREATION_IN_PROGRESS     CREATION_SUCCESSFUL     CREATION_FAILED     UPDATE_IN_PROGRESS     UPDATE_SUCCESSFUL     UPDATE_FAILED     DELETED
        public let resourceStatus: ResourceStatus?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the template described.
        public let templateId: String?
        /// The ARN of the theme of the template.
        public let themeArn: String?

        public init(definition: TemplateVersionDefinition? = nil, errors: [TemplateError]? = nil, name: String? = nil, requestId: String? = nil, resourceStatus: ResourceStatus? = nil, status: Int? = nil, templateId: String? = nil, themeArn: String? = nil) {
            self.definition = definition
            self.errors = errors
            self.name = name
            self.requestId = requestId
            self.resourceStatus = resourceStatus
            self.status = status
            self.templateId = templateId
            self.themeArn = themeArn
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case errors = "Errors"
            case name = "Name"
            case requestId = "RequestId"
            case resourceStatus = "ResourceStatus"
            case status = "Status"
            case templateId = "TemplateId"
            case themeArn = "ThemeArn"
        }
    }

    public struct DescribeTemplatePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The ID of the Amazon Web Services account that contains the template that you're describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, templateId: String) {
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplatePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String?
        /// The ID for the template.
        public let templateId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, templateArn: String? = nil, templateId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case templateArn = "TemplateArn"
            case templateId = "TemplateId"
        }
    }

    public struct DescribeTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring("alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The alias of the template that you want to describe. If you name a specific alias, you
        /// 			describe the version that the alias points to. You can specify the latest version of the
        /// 			template by providing the keyword $LATEST in the AliasName
        /// 			parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the template that you're describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String
        /// (Optional) The number for the version to describe. If a VersionNumber parameter
        /// 			value isn't provided, the latest version of the template is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The template structure for the object you want to describe.
        public let template: Template?

        public init(requestId: String? = nil, status: Int? = nil, template: Template? = nil) {
            self.requestId = requestId
            self.status = status
            self.template = template
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case template = "Template"
        }
    }

    public struct DescribeThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The name of the theme alias that you want to describe.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme alias that you're
        /// 			describing.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String

        public init(aliasName: String, awsAccountId: String, themeId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct DescribeThemePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The ID of the Amazon Web Services account that contains the theme that you're describing.
        public let awsAccountId: String
        /// The ID for the theme that you want to describe permissions for.
        public let themeId: String

        public init(awsAccountId: String, themeId: String) {
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of resource permissions set on the theme.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the theme.
        public let themeArn: String?
        /// The ID for the theme.
        public let themeId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, themeArn: String? = nil, themeId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.themeArn = themeArn
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case themeArn = "ThemeArn"
            case themeId = "ThemeId"
        }
    }

    public struct DescribeThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .querystring("alias-name")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId")),
            AWSMemberEncoding(label: "versionNumber", location: .querystring("version-number"))
        ]

        /// The alias of the theme that you want to describe. If you name a specific alias, you
        /// 			describe the version that the alias points to. You can specify the latest version of the
        /// 			theme by providing the keyword $LATEST in the AliasName
        /// 			parameter. The keyword $PUBLISHED doesn't apply to themes.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the theme that you're describing.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String
        /// The version number for the version to describe. If a VersionNumber parameter
        /// 			value isn't provided, the latest version of the theme is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, themeId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^(aws|[0-9]{12})$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The information about the theme that you are describing.
        public let theme: Theme?

        public init(requestId: String? = nil, status: Int? = nil, theme: Theme? = nil) {
            self.requestId = requestId
            self.status = status
            self.theme = theme
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case theme = "Theme"
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "userName", location: .uri("UserName"))
        ]

        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The name of the user that you want to describe.
        public let userName: String

        public init(awsAccountId: String, namespace: String, userName: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The user name.
        public let user: User?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case user = "User"
        }
    }

    public struct DestinationParameterValueConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of custom values for destination parameter in DestinationParameterValueConfiguration.
        public let customValuesConfiguration: CustomValuesConfiguration?
        /// The configuration that selects all options.
        public let selectAllValueOptions: SelectAllValueOptions?
        /// The source field ID of the destination parameter.
        public let sourceField: String?
        /// The source parameter name of the destination parameter.
        public let sourceParameterName: String?

        public init(customValuesConfiguration: CustomValuesConfiguration? = nil, selectAllValueOptions: SelectAllValueOptions? = nil, sourceField: String? = nil, sourceParameterName: String? = nil) {
            self.customValuesConfiguration = customValuesConfiguration
            self.selectAllValueOptions = selectAllValueOptions
            self.sourceField = sourceField
            self.sourceParameterName = sourceParameterName
        }

        public func validate(name: String) throws {
            try self.customValuesConfiguration?.validate(name: "\(name).customValuesConfiguration")
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 512)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customValuesConfiguration = "CustomValuesConfiguration"
            case selectAllValueOptions = "SelectAllValueOptions"
            case sourceField = "SourceField"
            case sourceParameterName = "SourceParameterName"
        }
    }

    public struct DimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The dimension type field with categorical type columns.
        public let categoricalDimensionField: CategoricalDimensionField?
        /// The dimension type field with date type columns.
        public let dateDimensionField: DateDimensionField?
        /// The dimension type field with numerical type columns.
        public let numericalDimensionField: NumericalDimensionField?

        public init(categoricalDimensionField: CategoricalDimensionField? = nil, dateDimensionField: DateDimensionField? = nil, numericalDimensionField: NumericalDimensionField? = nil) {
            self.categoricalDimensionField = categoricalDimensionField
            self.dateDimensionField = dateDimensionField
            self.numericalDimensionField = numericalDimensionField
        }

        public func validate(name: String) throws {
            try self.categoricalDimensionField?.validate(name: "\(name).categoricalDimensionField")
            try self.dateDimensionField?.validate(name: "\(name).dateDimensionField")
            try self.numericalDimensionField?.validate(name: "\(name).numericalDimensionField")
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalDimensionField = "CategoricalDimensionField"
            case dateDimensionField = "DateDimensionField"
            case numericalDimensionField = "NumericalDimensionField"
        }
    }

    public struct DonutCenterOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called 'Show total'.
        public let labelVisibility: Visibility?

        public init(labelVisibility: Visibility? = nil) {
            self.labelVisibility = labelVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case labelVisibility = "LabelVisibility"
        }
    }

    public struct DonutOptions: AWSEncodableShape & AWSDecodableShape {
        /// The option for define the arc of the chart shape. Valid values are as follows:    WHOLE - A pie chart    SMALL- A small-sized donut chart    MEDIUM- A medium-sized donut chart    LARGE- A large-sized donut chart
        public let arcOptions: ArcOptions?
        /// The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.
        public let donutCenterOptions: DonutCenterOptions?

        public init(arcOptions: ArcOptions? = nil, donutCenterOptions: DonutCenterOptions? = nil) {
            self.arcOptions = arcOptions
            self.donutCenterOptions = donutCenterOptions
        }

        private enum CodingKeys: String, CodingKey {
            case arcOptions = "ArcOptions"
            case donutCenterOptions = "DonutCenterOptions"
        }
    }

    public struct DrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// The category type drill down filter. This filter is used for string type columns.
        public let categoryFilter: CategoryDrillDownFilter?
        /// The numeric equality type drill down filter. This filter is used for number type columns.
        public let numericEqualityFilter: NumericEqualityDrillDownFilter?
        /// The time range drill down filter. This filter is used for date time columns.
        public let timeRangeFilter: TimeRangeDrillDownFilter?

        public init(categoryFilter: CategoryDrillDownFilter? = nil, numericEqualityFilter: NumericEqualityDrillDownFilter? = nil, timeRangeFilter: TimeRangeDrillDownFilter? = nil) {
            self.categoryFilter = categoryFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.timeRangeFilter = timeRangeFilter
        }

        public func validate(name: String) throws {
            try self.categoryFilter?.validate(name: "\(name).categoryFilter")
            try self.numericEqualityFilter?.validate(name: "\(name).numericEqualityFilter")
            try self.timeRangeFilter?.validate(name: "\(name).timeRangeFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryFilter = "CategoryFilter"
            case numericEqualityFilter = "NumericEqualityFilter"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct DropDownControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the Select all options in a dropdown control.
        public let selectAllOptions: ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(selectAllOptions: ListControlSelectAllOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case selectAllOptions = "SelectAllOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct DynamicDefaultValue: AWSEncodableShape & AWSDecodableShape {
        /// The column that contains the default value of each user or group.
        public let defaultValueColumn: ColumnIdentifier
        /// The column that contains the group name.
        public let groupNameColumn: ColumnIdentifier?
        /// The column that contains the username.
        public let userNameColumn: ColumnIdentifier?

        public init(defaultValueColumn: ColumnIdentifier, groupNameColumn: ColumnIdentifier? = nil, userNameColumn: ColumnIdentifier? = nil) {
            self.defaultValueColumn = defaultValueColumn
            self.groupNameColumn = groupNameColumn
            self.userNameColumn = userNameColumn
        }

        public func validate(name: String) throws {
            try self.defaultValueColumn.validate(name: "\(name).defaultValueColumn")
            try self.groupNameColumn?.validate(name: "\(name).groupNameColumn")
            try self.userNameColumn?.validate(name: "\(name).userNameColumn")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValueColumn = "DefaultValueColumn"
            case groupNameColumn = "GroupNameColumn"
            case userNameColumn = "UserNameColumn"
        }
    }

    public struct EmptyVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The data set that is used in the empty visual. Every visual requires a dataset to render.
        public let dataSetIdentifier: String
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, dataSetIdentifier: String, visualId: String) {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case dataSetIdentifier = "DataSetIdentifier"
            case visualId = "VisualId"
        }
    }

    public struct Entity: AWSDecodableShape {
        /// The hierarchical path of the entity within the analysis, template, or dashboard definition tree.
        public let path: String?

        public init(path: String? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// Error message.
        public let message: String?
        /// Error type.
        public let type: IngestionErrorType?

        public init(message: String? = nil, type: IngestionErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ExasolParameters: AWSEncodableShape & AWSDecodableShape {
        /// The hostname or IP address of the Exasol data source.
        public let host: String
        /// The port for the Exasol data source.
        public let port: Int

        public init(host: String, port: Int) {
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case port = "Port"
        }
    }

    public struct ExcludePeriodConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The amount or number of the exclude period.
        public let amount: Int
        /// The granularity or unit (day, month, year) of the exclude period.
        public let granularity: TimeGranularity
        /// The status of the exclude period. Choose from the following options:    ENABLED     DISABLED
        public let status: WidgetStatus?

        public init(amount: Int, granularity: TimeGranularity, status: WidgetStatus? = nil) {
            self.amount = amount
            self.granularity = granularity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "Amount"
            case granularity = "Granularity"
            case status = "Status"
        }
    }

    public struct ExplicitHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The list of columns that define the explicit hierarchy.
        public let columns: [ColumnIdentifier]
        /// The option that determines the drill down filters for the explicit hierarchy.
        public let drillDownFilters: [DrillDownFilter]?
        /// The hierarchy ID of the explicit hierarchy.
        public let hierarchyId: String

        public init(columns: [ColumnIdentifier], drillDownFilters: [DrillDownFilter]? = nil, hierarchyId: String) {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 10)
            try self.validate(self.columns, name: "columns", parent: name, min: 2)
            try self.drillDownFilters?.forEach {
                try $0.validate(name: "\(name).drillDownFilters[]")
            }
            try self.validate(self.drillDownFilters, name: "drillDownFilters", parent: name, max: 10)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case drillDownFilters = "DrillDownFilters"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct ExportHiddenFieldsOption: AWSEncodableShape {
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct ExportToCSVOption: AWSEncodableShape {
        /// Availability status.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct FieldBasedTooltip: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of Show aggregations.
        public let aggregationVisibility: Visibility?
        /// The fields configuration in the tooltip.
        public let tooltipFields: [TooltipItem]?
        /// The type for the >tooltip title. Choose one of the following options:    NONE: Doesn't use the primary value as the title.    PRIMARY_VALUE: Uses primary value as the title.
        public let tooltipTitleType: TooltipTitleType?

        public init(aggregationVisibility: Visibility? = nil, tooltipFields: [TooltipItem]? = nil, tooltipTitleType: TooltipTitleType? = nil) {
            self.aggregationVisibility = aggregationVisibility
            self.tooltipFields = tooltipFields
            self.tooltipTitleType = tooltipTitleType
        }

        public func validate(name: String) throws {
            try self.tooltipFields?.forEach {
                try $0.validate(name: "\(name).tooltipFields[]")
            }
            try self.validate(self.tooltipFields, name: "tooltipFields", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationVisibility = "AggregationVisibility"
            case tooltipFields = "TooltipFields"
            case tooltipTitleType = "TooltipTitleType"
        }
    }

    public struct FieldFolder: AWSEncodableShape & AWSDecodableShape {
        /// A folder has a list of columns. A column can only be in one folder.
        public let columns: [String]?
        /// The description for a field folder.
        public let description: String?

        public init(columns: [String]? = nil, description: String? = nil) {
            self.columns = columns
            self.description = description
        }

        public func validate(name: String) throws {
            try self.validate(self.columns, name: "columns", parent: name, max: 5000)
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case columns
            case description
        }
    }

    public struct FieldLabelType: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the field that is targeted by the field label.
        public let fieldId: String?
        /// The visibility of the field label.
        public let visibility: Visibility?

        public init(fieldId: String? = nil, visibility: Visibility? = nil) {
            self.fieldId = fieldId
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case visibility = "Visibility"
        }
    }

    public struct FieldSeriesItem: AWSEncodableShape & AWSDecodableShape {
        /// The axis that you are binding the field to.
        public let axisBinding: AxisBinding
        /// The field ID of the field for which you are setting the axis binding.
        public let fieldId: String
        /// The options that determine the presentation of line series associated to the field.
        public let settings: LineChartSeriesSettings?

        public init(axisBinding: AxisBinding, fieldId: String, settings: LineChartSeriesSettings? = nil) {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.settings = settings
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.settings?.validate(name: "\(name).settings")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case fieldId = "FieldId"
            case settings = "Settings"
        }
    }

    public struct FieldSort: AWSEncodableShape & AWSDecodableShape {
        /// The sort direction. Choose one of the following options:    ASC: Ascending    DESC: Descending
        public let direction: SortDirection
        /// The sort configuration target field.
        public let fieldId: String

        public init(direction: SortDirection, fieldId: String) {
            self.direction = direction
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "Direction"
            case fieldId = "FieldId"
        }
    }

    public struct FieldSortOptions: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration for a column that is not used in a field well.
        public let columnSort: ColumnSort?
        /// The sort configuration for a field in a field well.
        public let fieldSort: FieldSort?

        public init(columnSort: ColumnSort? = nil, fieldSort: FieldSort? = nil) {
            self.columnSort = columnSort
            self.fieldSort = fieldSort
        }

        public func validate(name: String) throws {
            try self.columnSort?.validate(name: "\(name).columnSort")
            try self.fieldSort?.validate(name: "\(name).fieldSort")
        }

        private enum CodingKeys: String, CodingKey {
            case columnSort = "ColumnSort"
            case fieldSort = "FieldSort"
        }
    }

    public struct FieldTooltipItem: AWSEncodableShape & AWSDecodableShape {
        /// The unique ID of the field that is targeted by the tooltip.
        public let fieldId: String
        /// The label of the tooltip item.
        public let label: String?
        /// The visibility of the tooltip item.
        public let visibility: Visibility?

        public init(fieldId: String, label: String? = nil, visibility: Visibility? = nil) {
            self.fieldId = fieldId
            self.label = label
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case label = "Label"
            case visibility = "Visibility"
        }
    }

    public struct FilledMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated location field well of the filled map. Values are grouped by location fields.
        public let geospatial: [DimensionField]?
        /// The aggregated color field well of a filled map. Values are aggregated based on location fields.
        public let values: [MeasureField]?

        public init(geospatial: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.geospatial = geospatial
            self.values = values
        }

        public func validate(name: String) throws {
            try self.geospatial?.forEach {
                try $0.validate(name: "\(name).geospatial[]")
            }
            try self.validate(self.geospatial, name: "geospatial", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case geospatial = "Geospatial"
            case values = "Values"
        }
    }

    public struct FilledMapConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options of a FilledMapVisual.
        public let conditionalFormattingOptions: [FilledMapConditionalFormattingOption]

        public init(conditionalFormattingOptions: [FilledMapConditionalFormattingOption]) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct FilledMapConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting that determines the shape of the filled map.
        public let shape: FilledMapShapeConditionalFormatting

        public init(shape: FilledMapShapeConditionalFormatting) {
            self.shape = shape
        }

        public func validate(name: String) throws {
            try self.shape.validate(name: "\(name).shape")
        }

        private enum CodingKeys: String, CodingKey {
            case shape = "Shape"
        }
    }

    public struct FilledMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field wells of the visual.
        public let fieldWells: FilledMapFieldWells?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The map style options of the filled map visual.
        public let mapStyleOptions: GeospatialMapStyleOptions?
        /// The sort configuration of a FilledMapVisual.
        public let sortConfiguration: FilledMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The window options of the filled map visual.
        public let windowOptions: GeospatialWindowOptions?

        public init(fieldWells: FilledMapFieldWells? = nil, legend: LegendOptions? = nil, mapStyleOptions: GeospatialMapStyleOptions? = nil, sortConfiguration: FilledMapSortConfiguration? = nil, tooltip: TooltipOptions? = nil, windowOptions: GeospatialWindowOptions? = nil) {
            self.fieldWells = fieldWells
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.windowOptions = windowOptions
        }

        public func validate(name: String) throws {
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.windowOptions?.validate(name: "\(name).windowOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case mapStyleOptions = "MapStyleOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case windowOptions = "WindowOptions"
        }
    }

    public struct FilledMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well of the filled map.
        public let filledMapAggregatedFieldWells: FilledMapAggregatedFieldWells?

        public init(filledMapAggregatedFieldWells: FilledMapAggregatedFieldWells? = nil) {
            self.filledMapAggregatedFieldWells = filledMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.filledMapAggregatedFieldWells?.validate(name: "\(name).filledMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case filledMapAggregatedFieldWells = "FilledMapAggregatedFieldWells"
        }
    }

    public struct FilledMapShapeConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the filled map shape.
        public let fieldId: String
        /// The conditional formatting that determines the background color of a filled map's shape.
        public let format: ShapeConditionalFormat?

        public init(fieldId: String, format: ShapeConditionalFormat? = nil) {
            self.fieldId = fieldId
            self.format = format
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.format?.validate(name: "\(name).format")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case format = "Format"
        }
    }

    public struct FilledMapSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration of the location fields.
        public let categorySort: [FieldSortOptions]?

        public init(categorySort: [FieldSortOptions]? = nil) {
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categorySort = "CategorySort"
        }
    }

    public struct FilledMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: FilledMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The conditional formatting of a FilledMapVisual.
        public let conditionalFormatting: FilledMapConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: FilledMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, conditionalFormatting: FilledMapConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        /// A CategoryFilter filters text values. For more information, see Adding text filters in the Amazon QuickSight User Guide.
        public let categoryFilter: CategoryFilter?
        /// A NumericEqualityFilter filters numeric values that equal or do not equal a given numeric value.
        public let numericEqualityFilter: NumericEqualityFilter?
        /// A NumericRangeFilter filters numeric values that are either inside or outside a given numeric range.
        public let numericRangeFilter: NumericRangeFilter?
        /// A RelativeDatesFilter filters date values that are relative to a given date.
        public let relativeDatesFilter: RelativeDatesFilter?
        /// A TimeEqualityFilter filters date-time values that equal or do not equal a given date/time value.
        public let timeEqualityFilter: TimeEqualityFilter?
        /// A TimeRangeFilter filters date-time values that are either inside or outside a given date/time range.
        public let timeRangeFilter: TimeRangeFilter?
        /// A TopBottomFilter filters data to the top or bottom values for a given column.
        public let topBottomFilter: TopBottomFilter?

        public init(categoryFilter: CategoryFilter? = nil, numericEqualityFilter: NumericEqualityFilter? = nil, numericRangeFilter: NumericRangeFilter? = nil, relativeDatesFilter: RelativeDatesFilter? = nil, timeEqualityFilter: TimeEqualityFilter? = nil, timeRangeFilter: TimeRangeFilter? = nil, topBottomFilter: TopBottomFilter? = nil) {
            self.categoryFilter = categoryFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.numericRangeFilter = numericRangeFilter
            self.relativeDatesFilter = relativeDatesFilter
            self.timeEqualityFilter = timeEqualityFilter
            self.timeRangeFilter = timeRangeFilter
            self.topBottomFilter = topBottomFilter
        }

        public func validate(name: String) throws {
            try self.categoryFilter?.validate(name: "\(name).categoryFilter")
            try self.numericEqualityFilter?.validate(name: "\(name).numericEqualityFilter")
            try self.numericRangeFilter?.validate(name: "\(name).numericRangeFilter")
            try self.relativeDatesFilter?.validate(name: "\(name).relativeDatesFilter")
            try self.timeEqualityFilter?.validate(name: "\(name).timeEqualityFilter")
            try self.timeRangeFilter?.validate(name: "\(name).timeRangeFilter")
            try self.topBottomFilter?.validate(name: "\(name).topBottomFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryFilter = "CategoryFilter"
            case numericEqualityFilter = "NumericEqualityFilter"
            case numericRangeFilter = "NumericRangeFilter"
            case relativeDatesFilter = "RelativeDatesFilter"
            case timeEqualityFilter = "TimeEqualityFilter"
            case timeRangeFilter = "TimeRangeFilter"
            case topBottomFilter = "TopBottomFilter"
        }
    }

    public struct FilterControl: AWSEncodableShape & AWSDecodableShape {
        /// A control from a date filter that is used to specify date and time.
        public let dateTimePicker: FilterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public let dropdown: FilterDropDownControl?
        /// A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.
        public let list: FilterListControl?
        /// A control from a date filter that is used to specify the relative date.
        public let relativeDateTime: FilterRelativeDateTimeControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public let slider: FilterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public let textArea: FilterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public let textField: FilterTextFieldControl?

        public init(dateTimePicker: FilterDateTimePickerControl? = nil, dropdown: FilterDropDownControl? = nil, list: FilterListControl? = nil, relativeDateTime: FilterRelativeDateTimeControl? = nil, slider: FilterSliderControl? = nil, textArea: FilterTextAreaControl? = nil, textField: FilterTextFieldControl? = nil) {
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.relativeDateTime = relativeDateTime
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.dateTimePicker?.validate(name: "\(name).dateTimePicker")
            try self.dropdown?.validate(name: "\(name).dropdown")
            try self.list?.validate(name: "\(name).list")
            try self.relativeDateTime?.validate(name: "\(name).relativeDateTime")
            try self.slider?.validate(name: "\(name).slider")
            try self.textArea?.validate(name: "\(name).textArea")
            try self.textField?.validate(name: "\(name).textField")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimePicker = "DateTimePicker"
            case dropdown = "Dropdown"
            case list = "List"
            case relativeDateTime = "RelativeDateTime"
            case slider = "Slider"
            case textArea = "TextArea"
            case textField = "TextField"
        }
    }

    public struct FilterDateTimePickerControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: DateTimePickerControlDisplayOptions?
        /// The ID of the FilterDateTimePickerControl.
        public let filterControlId: String
        /// The source filter ID of the FilterDateTimePickerControl.
        public let sourceFilterId: String
        /// The title of the FilterDateTimePickerControl.
        public let title: String
        /// The date time picker type of a FilterDateTimePickerControl. Choose one of the following options:    SINGLE_VALUED: The filter condition is a fixed date.    DATE_RANGE: The filter condition is a date time range.
        public let type: SheetControlDateTimePickerType?

        public init(displayOptions: DateTimePickerControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String, type: SheetControlDateTimePickerType? = nil) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterDropDownControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of the FilterDropDownControl.
        public let displayOptions: DropDownControlDisplayOptions?
        /// The ID of the FilterDropDownControl.
        public let filterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: FilterSelectableValues?
        /// The source filter ID of the FilterDropDownControl.
        public let sourceFilterId: String
        /// The title of the FilterDropDownControl.
        public let title: String
        /// The type of the FilterDropDownControl. Choose one of the following options:    MULTI_SELECT: The user can select multiple entries from a dropdown menu.    SINGLE_SELECT: The user can select a single entry from a dropdown menu.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: DropDownControlDisplayOptions? = nil, filterControlId: String, selectableValues: FilterSelectableValues? = nil, sourceFilterId: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case selectableValues = "SelectableValues"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterGroup: AWSEncodableShape & AWSDecodableShape {
        /// The filter new feature which can apply filter group to all data sets. Choose one of the following options:    ALL_DATASETS     SINGLE_DATASET
        public let crossDataset: CrossDatasetTypes
        /// The value that uniquely identifies a FilterGroup within a dashboard, template, or analysis.
        public let filterGroupId: String
        /// The list of filters that are present in a FilterGroup.
        public let filters: [Filter]
        /// The configuration that specifies what scope to apply to a FilterGroup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        public let scopeConfiguration: FilterScopeConfiguration
        /// The status of the FilterGroup.
        public let status: WidgetStatus?

        public init(crossDataset: CrossDatasetTypes, filterGroupId: String, filters: [Filter], scopeConfiguration: FilterScopeConfiguration, status: WidgetStatus? = nil) {
            self.crossDataset = crossDataset
            self.filterGroupId = filterGroupId
            self.filters = filters
            self.scopeConfiguration = scopeConfiguration
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.filterGroupId, name: "filterGroupId", parent: name, max: 512)
            try self.validate(self.filterGroupId, name: "filterGroupId", parent: name, min: 1)
            try self.validate(self.filterGroupId, name: "filterGroupId", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.scopeConfiguration.validate(name: "\(name).scopeConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crossDataset = "CrossDataset"
            case filterGroupId = "FilterGroupId"
            case filters = "Filters"
            case scopeConfiguration = "ScopeConfiguration"
            case status = "Status"
        }
    }

    public struct FilterListConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The list of category values for the filter.
        public let categoryValues: [String]?
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: CategoryFilterMatchOperator
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: CategoryFilterSelectAllOptions?

        public init(categoryValues: [String]? = nil, matchOperator: CategoryFilterMatchOperator, selectAllOptions: CategoryFilterSelectAllOptions? = nil) {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.categoryValues?.forEach {
                try validate($0, name: "categoryValues[]", parent: name, max: 512)
            }
            try self.validate(self.categoryValues, name: "categoryValues", parent: name, max: 100_000)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValues = "CategoryValues"
            case matchOperator = "MatchOperator"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct FilterListControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of a control.
        public let displayOptions: ListControlDisplayOptions?
        /// The ID of the FilterListControl.
        public let filterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: FilterSelectableValues?
        /// The source filter ID of the FilterListControl.
        public let sourceFilterId: String
        /// The title of the FilterListControl.
        public let title: String
        /// The type of FilterListControl. Choose one of the following options:    MULTI_SELECT: The user can select multiple entries from the list.    SINGLE_SELECT: The user can select a single entry from the list.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: ListControlDisplayOptions? = nil, filterControlId: String, selectableValues: FilterSelectableValues? = nil, sourceFilterId: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case selectableValues = "SelectableValues"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterOperation: AWSEncodableShape & AWSDecodableShape {
        /// An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        public let conditionExpression: String

        public init(conditionExpression: String) {
            self.conditionExpression = conditionExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, max: 4096)
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionExpression = "ConditionExpression"
        }
    }

    public struct FilterOperationSelectedFieldsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains the options that choose which fields are filtered in the CustomActionFilterOperation. Valid values are defined as follows:    ALL_FIELDS: Applies the filter operation to all fields.
        public let selectedFieldOptions: SelectedFieldOptions?
        /// Chooses the fields that are filtered in CustomActionFilterOperation.
        public let selectedFields: [String]?

        public init(selectedFieldOptions: SelectedFieldOptions? = nil, selectedFields: [String]? = nil) {
            self.selectedFieldOptions = selectedFieldOptions
            self.selectedFields = selectedFields
        }

        public func validate(name: String) throws {
            try self.selectedFields?.forEach {
                try validate($0, name: "selectedFields[]", parent: name, max: 512)
                try validate($0, name: "selectedFields[]", parent: name, min: 1)
            }
            try self.validate(self.selectedFields, name: "selectedFields", parent: name, max: 20)
            try self.validate(self.selectedFields, name: "selectedFields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case selectedFieldOptions = "SelectedFieldOptions"
            case selectedFields = "SelectedFields"
        }
    }

    public struct FilterOperationTargetVisualsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the same-sheet target visuals that you want to be filtered.
        public let sameSheetTargetVisualConfiguration: SameSheetTargetVisualConfiguration?

        public init(sameSheetTargetVisualConfiguration: SameSheetTargetVisualConfiguration? = nil) {
            self.sameSheetTargetVisualConfiguration = sameSheetTargetVisualConfiguration
        }

        public func validate(name: String) throws {
            try self.sameSheetTargetVisualConfiguration?.validate(name: "\(name).sameSheetTargetVisualConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case sameSheetTargetVisualConfiguration = "SameSheetTargetVisualConfiguration"
        }
    }

    public struct FilterRelativeDateTimeControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: RelativeDateTimeControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        public let filterControlId: String
        /// The source filter ID of the FilterTextAreaControl.
        public let sourceFilterId: String
        /// The title of the FilterTextAreaControl.
        public let title: String

        public init(displayOptions: RelativeDateTimeControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
        }
    }

    public struct FilterScopeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for applying a filter to specific sheets.
        public let selectedSheets: SelectedSheetsFilterScopeConfiguration?

        public init(selectedSheets: SelectedSheetsFilterScopeConfiguration? = nil) {
            self.selectedSheets = selectedSheets
        }

        public func validate(name: String) throws {
            try self.selectedSheets?.validate(name: "\(name).selectedSheets")
        }

        private enum CodingKeys: String, CodingKey {
            case selectedSheets = "SelectedSheets"
        }
    }

    public struct FilterSelectableValues: AWSEncodableShape & AWSDecodableShape {
        /// The values that are used in the FilterSelectableValues.
        public let values: [String]?

        public init(values: [String]? = nil) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct FilterSliderControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: SliderControlDisplayOptions?
        /// The ID of the FilterSliderControl.
        public let filterControlId: String
        /// The smaller value that is displayed at the left of the slider.
        public let maximumValue: Double
        /// The larger value that is displayed at the right of the slider.
        public let minimumValue: Double
        /// The source filter ID of the FilterSliderControl.
        public let sourceFilterId: String
        /// The number of increments that the slider bar is divided into.
        public let stepSize: Double
        /// The title of the FilterSliderControl.
        public let title: String
        /// The type of FilterSliderControl. Choose one of the following options:    SINGLE_POINT: Filter against(equals) a single data point.    RANGE: Filter data that is in a specified range.
        public let type: SheetControlSliderType?

        public init(displayOptions: SliderControlDisplayOptions? = nil, filterControlId: String, maximumValue: Double, minimumValue: Double, sourceFilterId: String, stepSize: Double, title: String, type: SheetControlSliderType? = nil) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.sourceFilterId = sourceFilterId
            self.stepSize = stepSize
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case sourceFilterId = "SourceFilterId"
            case stepSize = "StepSize"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterTextAreaControl: AWSEncodableShape & AWSDecodableShape {
        /// The delimiter that is used to separate the lines in text.
        public let delimiter: String?
        /// The display options of a control.
        public let displayOptions: TextAreaControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        public let filterControlId: String
        /// The source filter ID of the FilterTextAreaControl.
        public let sourceFilterId: String
        /// The title of the FilterTextAreaControl.
        public let title: String

        public init(delimiter: String? = nil, displayOptions: TextAreaControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String) {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 2048)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
        }
    }

    public struct FilterTextFieldControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: TextFieldControlDisplayOptions?
        /// The ID of the FilterTextFieldControl.
        public let filterControlId: String
        /// The source filter ID of the FilterTextFieldControl.
        public let sourceFilterId: String
        /// The title of the FilterTextFieldControl.
        public let title: String

        public init(displayOptions: TextFieldControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
        }
    }

    public struct Folder: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the folder.
        public let arn: String?
        /// The time that the folder was created.
        public let createdTime: Date?
        /// The ID of the folder.
        public let folderId: String?
        /// An array of ancestor ARN strings for the folder.
        public let folderPath: [String]?
        /// The type of folder it is.
        public let folderType: FolderType?
        /// The time that the folder was last updated.
        public let lastUpdatedTime: Date?
        /// A display name for the folder.
        public let name: String?

        public init(arn: String? = nil, createdTime: Date? = nil, folderId: String? = nil, folderPath: [String]? = nil, folderType: FolderType? = nil, lastUpdatedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderPath = folderPath
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case folderId = "FolderId"
            case folderPath = "FolderPath"
            case folderType = "FolderType"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
        }
    }

    public struct FolderMember: AWSDecodableShape {
        /// The ID of an asset in the folder.
        public let memberId: String?
        /// The type of asset that it is.
        public let memberType: MemberType?

        public init(memberId: String? = nil, memberType: MemberType? = nil) {
            self.memberId = memberId
            self.memberType = memberType
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case memberType = "MemberType"
        }
    }

    public struct FolderSearchFilter: AWSEncodableShape {
        /// The name of a value that you want to use in the filter. For example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.    QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered.     FOLDER_NAME: Any folders whose names have a substring match to this value will be returned.    PARENT_FOLDER_ARN: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned.
        public let name: FolderFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example  "Operator": "StringEquals". Valid values are  "StringEquals"  and  "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example,  "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value FOLDER_NAME.
        public let `operator`: FilterOperator?
        /// The value of the named item (in this example, PARENT_FOLDER_ARN), that you want to use as a filter. For example, "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId".
        public let value: String?

        public init(name: FolderFilterAttribute? = nil, operator: FilterOperator? = nil, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct FolderSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The time that the folder was created.
        public let createdTime: Date?
        /// The ID of the folder.
        public let folderId: String?
        /// The type of folder.
        public let folderType: FolderType?
        /// The time that the folder was last updated.
        public let lastUpdatedTime: Date?
        /// The display name of the folder.
        public let name: String?

        public init(arn: String? = nil, createdTime: Date? = nil, folderId: String? = nil, folderType: FolderType? = nil, lastUpdatedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case folderId = "FolderId"
            case folderType = "FolderType"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
        }
    }

    public struct Font: AWSEncodableShape & AWSDecodableShape {
        /// Determines the font family settings.
        public let fontFamily: String?

        public init(fontFamily: String? = nil) {
            self.fontFamily = fontFamily
        }

        private enum CodingKeys: String, CodingKey {
            case fontFamily = "FontFamily"
        }
    }

    public struct FontConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color of the text.
        public let fontColor: String?
        /// Determines the appearance of decorative lines on the text.
        public let fontDecoration: FontDecoration?
        /// The option that determines the text display size.
        public let fontSize: FontSize?
        /// Determines the text display face that is inherited by the given font family.
        public let fontStyle: FontStyle?
        /// The option that determines the text display weight, or boldness.
        public let fontWeight: FontWeight?

        public init(fontColor: String? = nil, fontDecoration: FontDecoration? = nil, fontSize: FontSize? = nil, fontStyle: FontStyle? = nil, fontWeight: FontWeight? = nil) {
            self.fontColor = fontColor
            self.fontDecoration = fontDecoration
            self.fontSize = fontSize
            self.fontStyle = fontStyle
            self.fontWeight = fontWeight
        }

        public func validate(name: String) throws {
            try self.validate(self.fontColor, name: "fontColor", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fontColor = "FontColor"
            case fontDecoration = "FontDecoration"
            case fontSize = "FontSize"
            case fontStyle = "FontStyle"
            case fontWeight = "FontWeight"
        }
    }

    public struct FontSize: AWSEncodableShape & AWSDecodableShape {
        /// The lexical name for the text size, proportional to its surrounding context.
        public let relative: RelativeFontSize?

        public init(relative: RelativeFontSize? = nil) {
            self.relative = relative
        }

        private enum CodingKeys: String, CodingKey {
            case relative = "Relative"
        }
    }

    public struct FontWeight: AWSEncodableShape & AWSDecodableShape {
        /// The lexical name for the level of boldness of the text display.
        public let name: FontWeightName?

        public init(name: FontWeightName? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ForecastComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The custom seasonality value setup of a forecast computation.
        public let customSeasonalityValue: Int?
        /// The lower boundary setup of a forecast computation.
        public let lowerBoundary: Double?
        /// The name of a computation.
        public let name: String?
        /// The periods backward setup of a forecast computation.
        public let periodsBackward: Int?
        /// The periods forward setup of a forecast computation.
        public let periodsForward: Int?
        /// The prediction interval setup of a forecast computation.
        public let predictionInterval: Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:    AUTOMATIC     CUSTOM: Checks the custom seasonality value.
        public let seasonality: ForecastComputationSeasonality?
        /// The time field that is used in a computation.
        public let time: DimensionField
        /// The upper boundary setup of a forecast computation.
        public let upperBoundary: Double?
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, customSeasonalityValue: Int? = nil, lowerBoundary: Double? = nil, name: String? = nil, periodsBackward: Int? = nil, periodsForward: Int? = nil, predictionInterval: Int? = nil, seasonality: ForecastComputationSeasonality? = nil, time: DimensionField, upperBoundary: Double? = nil, value: MeasureField? = nil) {
            self.computationId = computationId
            self.customSeasonalityValue = customSeasonalityValue
            self.lowerBoundary = lowerBoundary
            self.name = name
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.time = time
            self.upperBoundary = upperBoundary
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.customSeasonalityValue, name: "customSeasonalityValue", parent: name, max: 180)
            try self.validate(self.customSeasonalityValue, name: "customSeasonalityValue", parent: name, min: 1)
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, max: 1000)
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, min: 0)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, max: 1000)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, min: 1)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, max: 95)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, min: 50)
            try self.time.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case customSeasonalityValue = "CustomSeasonalityValue"
            case lowerBoundary = "LowerBoundary"
            case name = "Name"
            case periodsBackward = "PeriodsBackward"
            case periodsForward = "PeriodsForward"
            case predictionInterval = "PredictionInterval"
            case seasonality = "Seasonality"
            case time = "Time"
            case upperBoundary = "UpperBoundary"
            case value = "Value"
        }
    }

    public struct ForecastConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The forecast properties setup of a forecast in the line chart.
        public let forecastProperties: TimeBasedForecastProperties?
        /// The forecast scenario of a forecast in the line chart.
        public let scenario: ForecastScenario?

        public init(forecastProperties: TimeBasedForecastProperties? = nil, scenario: ForecastScenario? = nil) {
            self.forecastProperties = forecastProperties
            self.scenario = scenario
        }

        public func validate(name: String) throws {
            try self.forecastProperties?.validate(name: "\(name).forecastProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastProperties = "ForecastProperties"
            case scenario = "Scenario"
        }
    }

    public struct ForecastScenario: AWSEncodableShape & AWSDecodableShape {
        /// The what-if analysis forecast setup with the target date.
        public let whatIfPointScenario: WhatIfPointScenario?
        /// The what-if analysis forecast setup with the date range.
        public let whatIfRangeScenario: WhatIfRangeScenario?

        public init(whatIfPointScenario: WhatIfPointScenario? = nil, whatIfRangeScenario: WhatIfRangeScenario? = nil) {
            self.whatIfPointScenario = whatIfPointScenario
            self.whatIfRangeScenario = whatIfRangeScenario
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfPointScenario = "WhatIfPointScenario"
            case whatIfRangeScenario = "WhatIfRangeScenario"
        }
    }

    public struct FormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Formatting configuration for DateTime fields.
        public let dateTimeFormatConfiguration: DateTimeFormatConfiguration?
        /// Formatting configuration for number fields.
        public let numberFormatConfiguration: NumberFormatConfiguration?
        /// Formatting configuration for string fields.
        public let stringFormatConfiguration: StringFormatConfiguration?

        public init(dateTimeFormatConfiguration: DateTimeFormatConfiguration? = nil, numberFormatConfiguration: NumberFormatConfiguration? = nil, stringFormatConfiguration: StringFormatConfiguration? = nil) {
            self.dateTimeFormatConfiguration = dateTimeFormatConfiguration
            self.numberFormatConfiguration = numberFormatConfiguration
            self.stringFormatConfiguration = stringFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.dateTimeFormatConfiguration?.validate(name: "\(name).dateTimeFormatConfiguration")
            try self.numberFormatConfiguration?.validate(name: "\(name).numberFormatConfiguration")
            try self.stringFormatConfiguration?.validate(name: "\(name).stringFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormatConfiguration = "DateTimeFormatConfiguration"
            case numberFormatConfiguration = "NumberFormatConfiguration"
            case stringFormatConfiguration = "StringFormatConfiguration"
        }
    }

    public struct FreeFormLayoutCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the sizing of the canvas used in a free-form layout.
        public let screenCanvasSizeOptions: FreeFormLayoutScreenCanvasSizeOptions?

        public init(screenCanvasSizeOptions: FreeFormLayoutScreenCanvasSizeOptions? = nil) {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case screenCanvasSizeOptions = "ScreenCanvasSizeOptions"
        }
    }

    public struct FreeFormLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let canvasSizeOptions: FreeFormLayoutCanvasSizeOptions?
        /// The elements that are included in a free-form layout.
        public let elements: [FreeFormLayoutElement]

        public init(canvasSizeOptions: FreeFormLayoutCanvasSizeOptions? = nil, elements: [FreeFormLayoutElement]) {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }

        public func validate(name: String) throws {
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 430)
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
            case elements = "Elements"
        }
    }

    public struct FreeFormLayoutElement: AWSEncodableShape & AWSDecodableShape {
        /// The background style configuration of a free-form layout element.
        public let backgroundStyle: FreeFormLayoutElementBackgroundStyle?
        /// The border style configuration of a free-form layout element.
        public let borderStyle: FreeFormLayoutElementBorderStyle?
        /// A unique identifier for an element within a free-form layout.
        public let elementId: String
        /// The type of element.
        public let elementType: LayoutElementType
        /// The height of an element within a free-form layout.
        public let height: String
        /// The loading animation configuration of a free-form layout element.
        public let loadingAnimation: LoadingAnimation?
        /// The rendering rules that determine when an element should be displayed within a free-form layout.
        public let renderingRules: [SheetElementRenderingRule]?
        /// The border style configuration of a free-form layout element. This border style is used when the element is selected.
        public let selectedBorderStyle: FreeFormLayoutElementBorderStyle?
        /// The visibility of an element within a free-form layout.
        public let visibility: Visibility?
        /// The width of an element within a free-form layout.
        public let width: String
        /// The x-axis coordinate of the element.
        public let xAxisLocation: String
        /// The y-axis coordinate of the element.
        public let yAxisLocation: String

        public init(backgroundStyle: FreeFormLayoutElementBackgroundStyle? = nil, borderStyle: FreeFormLayoutElementBorderStyle? = nil, elementId: String, elementType: LayoutElementType, height: String, loadingAnimation: LoadingAnimation? = nil, renderingRules: [SheetElementRenderingRule]? = nil, selectedBorderStyle: FreeFormLayoutElementBorderStyle? = nil, visibility: Visibility? = nil, width: String, xAxisLocation: String, yAxisLocation: String) {
            self.backgroundStyle = backgroundStyle
            self.borderStyle = borderStyle
            self.elementId = elementId
            self.elementType = elementType
            self.height = height
            self.loadingAnimation = loadingAnimation
            self.renderingRules = renderingRules
            self.selectedBorderStyle = selectedBorderStyle
            self.visibility = visibility
            self.width = width
            self.xAxisLocation = xAxisLocation
            self.yAxisLocation = yAxisLocation
        }

        public func validate(name: String) throws {
            try self.backgroundStyle?.validate(name: "\(name).backgroundStyle")
            try self.borderStyle?.validate(name: "\(name).borderStyle")
            try self.validate(self.elementId, name: "elementId", parent: name, max: 512)
            try self.validate(self.elementId, name: "elementId", parent: name, min: 1)
            try self.validate(self.elementId, name: "elementId", parent: name, pattern: "^[\\w\\-]+$")
            try self.renderingRules?.forEach {
                try $0.validate(name: "\(name).renderingRules[]")
            }
            try self.validate(self.renderingRules, name: "renderingRules", parent: name, max: 10000)
            try self.selectedBorderStyle?.validate(name: "\(name).selectedBorderStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundStyle = "BackgroundStyle"
            case borderStyle = "BorderStyle"
            case elementId = "ElementId"
            case elementType = "ElementType"
            case height = "Height"
            case loadingAnimation = "LoadingAnimation"
            case renderingRules = "RenderingRules"
            case selectedBorderStyle = "SelectedBorderStyle"
            case visibility = "Visibility"
            case width = "Width"
            case xAxisLocation = "XAxisLocation"
            case yAxisLocation = "YAxisLocation"
        }
    }

    public struct FreeFormLayoutElementBackgroundStyle: AWSEncodableShape & AWSDecodableShape {
        /// The background color of a free-form layout element.
        public let color: String?
        /// The background visibility of a free-form layout element.
        public let visibility: Visibility?

        public init(color: String? = nil, visibility: Visibility? = nil) {
            self.color = color
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case visibility = "Visibility"
        }
    }

    public struct FreeFormLayoutElementBorderStyle: AWSEncodableShape & AWSDecodableShape {
        /// The border color of a free-form layout element.
        public let color: String?
        /// The border visibility of a free-form layout element.
        public let visibility: Visibility?

        public init(color: String? = nil, visibility: Visibility? = nil) {
            self.color = color
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case visibility = "Visibility"
        }
    }

    public struct FreeFormLayoutScreenCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The width that the view port will be optimized for when the layout renders.
        public let optimizedViewPortWidth: String

        public init(optimizedViewPortWidth: String) {
            self.optimizedViewPortWidth = optimizedViewPortWidth
        }

        private enum CodingKeys: String, CodingKey {
            case optimizedViewPortWidth = "OptimizedViewPortWidth"
        }
    }

    public struct FreeFormSectionLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The elements that are included in the free-form layout.
        public let elements: [FreeFormLayoutElement]

        public init(elements: [FreeFormLayoutElement]) {
            self.elements = elements
        }

        public func validate(name: String) throws {
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 430)
        }

        private enum CodingKeys: String, CodingKey {
            case elements = "Elements"
        }
    }

    public struct FunnelChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category field wells of a funnel chart. Values are grouped by category fields.
        public let category: [DimensionField]?
        /// The value field wells of a funnel chart. Values are aggregated based on categories.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case values = "Values"
        }
    }

    public struct FunnelChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options of the categories that are displayed in a FunnelChartVisual.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The options that determine the presentation of the data labels.
        public let dataLabelOptions: FunnelChartDataLabelOptions?
        /// The field well configuration of a FunnelChartVisual.
        public let fieldWells: FunnelChartFieldWells?
        /// The sort configuration of a FunnelChartVisual.
        public let sortConfiguration: FunnelChartSortConfiguration?
        /// The tooltip configuration of a FunnelChartVisual.
        public let tooltip: TooltipOptions?
        /// The label options for the values that are displayed in a FunnelChartVisual.
        public let valueLabelOptions: ChartAxisLabelOptions?
        /// The visual palette configuration of a FunnelChartVisual.
        public let visualPalette: VisualPalette?

        public init(categoryLabelOptions: ChartAxisLabelOptions? = nil, dataLabelOptions: FunnelChartDataLabelOptions? = nil, fieldWells: FunnelChartFieldWells? = nil, sortConfiguration: FunnelChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, valueLabelOptions: ChartAxisLabelOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.categoryLabelOptions = categoryLabelOptions
            self.dataLabelOptions = dataLabelOptions
            self.fieldWells = fieldWells
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.dataLabelOptions?.validate(name: "\(name).dataLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.valueLabelOptions?.validate(name: "\(name).valueLabelOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelOptions = "CategoryLabelOptions"
            case dataLabelOptions = "DataLabelOptions"
            case fieldWells = "FieldWells"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case valueLabelOptions = "ValueLabelOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct FunnelChartDataLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the category labels within the data labels.
        public let categoryLabelVisibility: Visibility?
        /// The color of the data label text.
        public let labelColor: String?
        /// The font configuration for the data labels. Only the FontSize attribute of the font configuration is used for data labels.
        public let labelFontConfiguration: FontConfiguration?
        /// Determines the style of the metric labels.
        public let measureDataLabelStyle: FunnelChartMeasureDataLabelStyle?
        /// The visibility of the measure labels within the data labels.
        public let measureLabelVisibility: Visibility?
        /// Determines the positioning of the data label relative to a section of the funnel.
        public let position: DataLabelPosition?
        /// The visibility option that determines if data labels are displayed.
        public let visibility: Visibility?

        public init(categoryLabelVisibility: Visibility? = nil, labelColor: String? = nil, labelFontConfiguration: FontConfiguration? = nil, measureDataLabelStyle: FunnelChartMeasureDataLabelStyle? = nil, measureLabelVisibility: Visibility? = nil, position: DataLabelPosition? = nil, visibility: Visibility? = nil) {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.labelColor = labelColor
            self.labelFontConfiguration = labelFontConfiguration
            self.measureDataLabelStyle = measureDataLabelStyle
            self.measureLabelVisibility = measureLabelVisibility
            self.position = position
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.labelColor, name: "labelColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.labelFontConfiguration?.validate(name: "\(name).labelFontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelVisibility = "CategoryLabelVisibility"
            case labelColor = "LabelColor"
            case labelFontConfiguration = "LabelFontConfiguration"
            case measureDataLabelStyle = "MeasureDataLabelStyle"
            case measureLabelVisibility = "MeasureLabelVisibility"
            case position = "Position"
            case visibility = "Visibility"
        }
    }

    public struct FunnelChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a FunnelChartVisual.
        public let funnelChartAggregatedFieldWells: FunnelChartAggregatedFieldWells?

        public init(funnelChartAggregatedFieldWells: FunnelChartAggregatedFieldWells? = nil) {
            self.funnelChartAggregatedFieldWells = funnelChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.funnelChartAggregatedFieldWells?.validate(name: "\(name).funnelChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case funnelChartAggregatedFieldWells = "FunnelChartAggregatedFieldWells"
        }
    }

    public struct FunnelChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories displayed.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
        }
    }

    public struct FunnelChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a FunnelChartVisual.
        public let chartConfiguration: FunnelChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: FunnelChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct GaugeChartArcConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the arc foreground color.
        public let foregroundColor: ConditionalFormattingColor?

        public init(foregroundColor: ConditionalFormattingColor? = nil) {
            self.foregroundColor = foregroundColor
        }

        public func validate(name: String) throws {
            try self.foregroundColor?.validate(name: "\(name).foregroundColor")
        }

        private enum CodingKeys: String, CodingKey {
            case foregroundColor = "ForegroundColor"
        }
    }

    public struct GaugeChartConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options of a GaugeChartVisual.
        public let conditionalFormattingOptions: [GaugeChartConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [GaugeChartConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct GaugeChartConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of the arc of a GaugeChartVisual.
        public let arc: GaugeChartArcConditionalFormatting?
        /// The conditional formatting for the primary value of a GaugeChartVisual.
        public let primaryValue: GaugeChartPrimaryValueConditionalFormatting?

        public init(arc: GaugeChartArcConditionalFormatting? = nil, primaryValue: GaugeChartPrimaryValueConditionalFormatting? = nil) {
            self.arc = arc
            self.primaryValue = primaryValue
        }

        public func validate(name: String) throws {
            try self.arc?.validate(name: "\(name).arc")
            try self.primaryValue?.validate(name: "\(name).primaryValue")
        }

        private enum CodingKeys: String, CodingKey {
            case arc = "Arc"
            case primaryValue = "PrimaryValue"
        }
    }

    public struct GaugeChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data label configuration of a GaugeChartVisual.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a GaugeChartVisual.
        public let fieldWells: GaugeChartFieldWells?
        /// The options that determine the presentation of the GaugeChartVisual.
        public let gaugeChartOptions: GaugeChartOptions?
        /// The tooltip configuration of a GaugeChartVisual.
        public let tooltipOptions: TooltipOptions?
        /// The visual palette configuration of a GaugeChartVisual.
        public let visualPalette: VisualPalette?

        public init(dataLabels: DataLabelOptions? = nil, fieldWells: GaugeChartFieldWells? = nil, gaugeChartOptions: GaugeChartOptions? = nil, tooltipOptions: TooltipOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.gaugeChartOptions = gaugeChartOptions
            self.tooltipOptions = tooltipOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.gaugeChartOptions?.validate(name: "\(name).gaugeChartOptions")
            try self.tooltipOptions?.validate(name: "\(name).tooltipOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case gaugeChartOptions = "GaugeChartOptions"
            case tooltipOptions = "TooltipOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct GaugeChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The target value field wells of a GaugeChartVisual.
        public let targetValues: [MeasureField]?
        /// The value field wells of a GaugeChartVisual.
        public let values: [MeasureField]?

        public init(targetValues: [MeasureField]? = nil, values: [MeasureField]? = nil) {
            self.targetValues = targetValues
            self.values = values
        }

        public func validate(name: String) throws {
            try self.targetValues?.forEach {
                try $0.validate(name: "\(name).targetValues[]")
            }
            try self.validate(self.targetValues, name: "targetValues", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case targetValues = "TargetValues"
            case values = "Values"
        }
    }

    public struct GaugeChartOptions: AWSEncodableShape & AWSDecodableShape {
        /// The arc configuration of a GaugeChartVisual.
        public let arc: ArcConfiguration?
        /// The arc axis configuration of a GaugeChartVisual.
        public let arcAxis: ArcAxisConfiguration?
        /// The comparison configuration of a GaugeChartVisual.
        public let comparison: ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public let primaryValueDisplayType: PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public let primaryValueFontConfiguration: FontConfiguration?

        public init(arc: ArcConfiguration? = nil, arcAxis: ArcAxisConfiguration? = nil, comparison: ComparisonConfiguration? = nil, primaryValueDisplayType: PrimaryValueDisplayType? = nil, primaryValueFontConfiguration: FontConfiguration? = nil) {
            self.arc = arc
            self.arcAxis = arcAxis
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
        }

        public func validate(name: String) throws {
            try self.comparison?.validate(name: "\(name).comparison")
            try self.primaryValueFontConfiguration?.validate(name: "\(name).primaryValueFontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case arc = "Arc"
            case arcAxis = "ArcAxis"
            case comparison = "Comparison"
            case primaryValueDisplayType = "PrimaryValueDisplayType"
            case primaryValueFontConfiguration = "PrimaryValueFontConfiguration"
        }
    }

    public struct GaugeChartPrimaryValueConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the primary value icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting of the primary value text color.
        public let textColor: ConditionalFormattingColor?

        public init(icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct GaugeChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a GaugeChartVisual.
        public let chartConfiguration: GaugeChartConfiguration?
        /// The conditional formatting of a GaugeChartVisual.
        public let conditionalFormatting: GaugeChartConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: GaugeChartConfiguration? = nil, conditionalFormatting: GaugeChartConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct GenerateEmbedUrlForAnonymousUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The domains that you want to add to the allow list for access to the generated URL that is then embedded. This optional parameter overrides the static domains that are configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it allows only the domains that you include in this parameter. You can list up to three domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
        public let allowedDomains: [String]?
        /// The Amazon Resource Names (ARNs) for the Amazon QuickSight resources that the user is authorized to access during the lifetime of the session. If you choose Dashboard embedding experience, pass the list of dashboard ARNs in the account that you want the user to be able to view. Currently, you can pass up to 25 dashboard ARNs in each API call.
        public let authorizedResourceArns: [String]
        /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
        public let awsAccountId: String
        /// The configuration of the experience that you are embedding.
        public let experienceConfiguration: AnonymousUserEmbeddingExperienceConfiguration
        /// The Amazon QuickSight namespace that the anonymous user virtually belongs to. If you are not using an Amazon QuickSight custom namespace, set this to default.
        public let namespace: String
        /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
        public let sessionLifetimeInMinutes: Int64?
        /// The session tags used for row-level security. Before you use this parameter, make sure that you have configured the relevant datasets using the DataSet$RowLevelPermissionTagConfiguration parameter so that session tags can be used to provide row-level security. These are not the tags used for the Amazon Web Services resource tagging feature. For more information, see Using Row-Level Security (RLS) with Tagsin the Amazon QuickSight User Guide.
        public let sessionTags: [SessionTag]?

        public init(allowedDomains: [String]? = nil, authorizedResourceArns: [String], awsAccountId: String, experienceConfiguration: AnonymousUserEmbeddingExperienceConfiguration, namespace: String, sessionLifetimeInMinutes: Int64? = nil, sessionTags: [SessionTag]? = nil) {
            self.allowedDomains = allowedDomains
            self.authorizedResourceArns = authorizedResourceArns
            self.awsAccountId = awsAccountId
            self.experienceConfiguration = experienceConfiguration
            self.namespace = namespace
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.sessionTags = sessionTags
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.experienceConfiguration.validate(name: "\(name).experienceConfiguration")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
            try self.sessionTags?.forEach {
                try $0.validate(name: "\(name).sessionTags[]")
            }
            try self.validate(self.sessionTags, name: "sessionTags", parent: name, max: 50)
            try self.validate(self.sessionTags, name: "sessionTags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedDomains = "AllowedDomains"
            case authorizedResourceArns = "AuthorizedResourceArns"
            case experienceConfiguration = "ExperienceConfiguration"
            case namespace = "Namespace"
            case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
            case sessionTags = "SessionTags"
        }
    }

    public struct GenerateEmbedUrlForAnonymousUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) to use for the anonymous Amazon QuickSight user.
        public let anonymousUserArn: String
        /// The embed URL for the dashboard.
        public let embedUrl: String
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String
        /// The HTTP status of the request.
        public let status: Int

        public init(anonymousUserArn: String, embedUrl: String, requestId: String, status: Int) {
            self.anonymousUserArn = anonymousUserArn
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case anonymousUserArn = "AnonymousUserArn"
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct GenerateEmbedUrlForRegisteredUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The domains that you want to add to the allow list for access to the generated URL that  is then embedded. This optional parameter overrides the static domains that are  configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it  allows only the domains that you include in this parameter. You can list up to three  domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
        public let allowedDomains: [String]?
        /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
        public let awsAccountId: String
        /// The experience you are embedding. For registered users, you can embed Amazon QuickSight dashboards, Amazon QuickSight visuals, the Amazon QuickSight Q search bar, or the entire Amazon QuickSight console.
        public let experienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration
        /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
        public let sessionLifetimeInMinutes: Int64?
        /// The Amazon Resource Name for the registered user.
        public let userArn: String

        public init(allowedDomains: [String]? = nil, awsAccountId: String, experienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration, sessionLifetimeInMinutes: Int64? = nil, userArn: String) {
            self.allowedDomains = allowedDomains
            self.awsAccountId = awsAccountId
            self.experienceConfiguration = experienceConfiguration
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.experienceConfiguration.validate(name: "\(name).experienceConfiguration")
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedDomains = "AllowedDomains"
            case experienceConfiguration = "ExperienceConfiguration"
            case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
            case userArn = "UserArn"
        }
    }

    public struct GenerateEmbedUrlForRegisteredUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The embed URL for the Amazon QuickSight dashboard, visual, Q search bar, or console.
        public let embedUrl: String
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String
        /// The HTTP status of the request.
        public let status: Int

        public init(embedUrl: String, requestId: String, status: Int) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct GeoSpatialColumnGroup: AWSEncodableShape & AWSDecodableShape {
        /// Columns in this hierarchy.
        public let columns: [String]
        /// Country code.
        public let countryCode: GeoSpatialCountryCode?
        /// A display name for the hierarchy.
        public let name: String

        public init(columns: [String], countryCode: GeoSpatialCountryCode? = nil, name: String) {
            self.columns = columns
            self.countryCode = countryCode
            self.name = name
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try validate($0, name: "columns[]", parent: name, max: 128)
                try validate($0, name: "columns[]", parent: name, min: 1)
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 16)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case countryCode = "CountryCode"
            case name = "Name"
        }
    }

    public struct GeospatialCoordinateBounds: AWSEncodableShape & AWSDecodableShape {
        /// The longitude of the east bound of the geospatial coordinate bounds.
        public let east: Double
        /// The latitude of the north bound of the geospatial coordinate bounds.
        public let north: Double
        /// The latitude of the south bound of the geospatial coordinate bounds.
        public let south: Double
        /// The longitude of the west bound of the geospatial coordinate bounds.
        public let west: Double

        public init(east: Double, north: Double, south: Double, west: Double) {
            self.east = east
            self.north = north
            self.south = south
            self.west = west
        }

        public func validate(name: String) throws {
            try self.validate(self.east, name: "east", parent: name, max: 1800.0)
            try self.validate(self.east, name: "east", parent: name, min: -1800.0)
            try self.validate(self.north, name: "north", parent: name, max: 90.0)
            try self.validate(self.north, name: "north", parent: name, min: -90.0)
            try self.validate(self.south, name: "south", parent: name, max: 90.0)
            try self.validate(self.south, name: "south", parent: name, min: -90.0)
            try self.validate(self.west, name: "west", parent: name, max: 1800.0)
            try self.validate(self.west, name: "west", parent: name, min: -1800.0)
        }

        private enum CodingKeys: String, CodingKey {
            case east = "East"
            case north = "North"
            case south = "South"
            case west = "West"
        }
    }

    public struct GeospatialMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The color field wells of a geospatial map.
        public let colors: [DimensionField]?
        /// The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.
        public let geospatial: [DimensionField]?
        /// The size field wells of a geospatial map. Values are aggregated based on geospatial fields.
        public let values: [MeasureField]?

        public init(colors: [DimensionField]? = nil, geospatial: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.colors = colors
            self.geospatial = geospatial
            self.values = values
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.geospatial?.forEach {
                try $0.validate(name: "\(name).geospatial[]")
            }
            try self.validate(self.geospatial, name: "geospatial", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
            case geospatial = "Geospatial"
            case values = "Values"
        }
    }

    public struct GeospatialMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field wells of the visual.
        public let fieldWells: GeospatialMapFieldWells?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The map style options of the geospatial map.
        public let mapStyleOptions: GeospatialMapStyleOptions?
        /// The point style options of the geospatial map.
        public let pointStyleOptions: GeospatialPointStyleOptions?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        public let visualPalette: VisualPalette?
        /// The window options of the geospatial map.
        public let windowOptions: GeospatialWindowOptions?

        public init(fieldWells: GeospatialMapFieldWells? = nil, legend: LegendOptions? = nil, mapStyleOptions: GeospatialMapStyleOptions? = nil, pointStyleOptions: GeospatialPointStyleOptions? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil, windowOptions: GeospatialWindowOptions? = nil) {
            self.fieldWells = fieldWells
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.pointStyleOptions = pointStyleOptions
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.windowOptions = windowOptions
        }

        public func validate(name: String) throws {
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.pointStyleOptions?.validate(name: "\(name).pointStyleOptions")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.windowOptions?.validate(name: "\(name).windowOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case mapStyleOptions = "MapStyleOptions"
            case pointStyleOptions = "PointStyleOptions"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
            case windowOptions = "WindowOptions"
        }
    }

    public struct GeospatialMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well for a geospatial map.
        public let geospatialMapAggregatedFieldWells: GeospatialMapAggregatedFieldWells?

        public init(geospatialMapAggregatedFieldWells: GeospatialMapAggregatedFieldWells? = nil) {
            self.geospatialMapAggregatedFieldWells = geospatialMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.geospatialMapAggregatedFieldWells?.validate(name: "\(name).geospatialMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case geospatialMapAggregatedFieldWells = "GeospatialMapAggregatedFieldWells"
        }
    }

    public struct GeospatialMapStyleOptions: AWSEncodableShape & AWSDecodableShape {
        /// The base map style of the geospatial map.
        public let baseMapStyle: BaseMapStyleType?

        public init(baseMapStyle: BaseMapStyleType? = nil) {
            self.baseMapStyle = baseMapStyle
        }

        private enum CodingKeys: String, CodingKey {
            case baseMapStyle = "BaseMapStyle"
        }
    }

    public struct GeospatialMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: GeospatialMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: GeospatialMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct GeospatialPointStyleOptions: AWSEncodableShape & AWSDecodableShape {
        /// The cluster marker configuration of the geospatial point style.
        public let clusterMarkerConfiguration: ClusterMarkerConfiguration?
        /// The selected point styles (point, cluster) of the geospatial map.
        public let selectedPointStyle: GeospatialSelectedPointStyle?

        public init(clusterMarkerConfiguration: ClusterMarkerConfiguration? = nil, selectedPointStyle: GeospatialSelectedPointStyle? = nil) {
            self.clusterMarkerConfiguration = clusterMarkerConfiguration
            self.selectedPointStyle = selectedPointStyle
        }

        public func validate(name: String) throws {
            try self.clusterMarkerConfiguration?.validate(name: "\(name).clusterMarkerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterMarkerConfiguration = "ClusterMarkerConfiguration"
            case selectedPointStyle = "SelectedPointStyle"
        }
    }

    public struct GeospatialWindowOptions: AWSEncodableShape & AWSDecodableShape {
        /// The bounds options (north, south, west, east) of the geospatial window options.
        public let bounds: GeospatialCoordinateBounds?
        /// The map zoom modes (manual, auto) of the geospatial window options.
        public let mapZoomMode: MapZoomMode?

        public init(bounds: GeospatialCoordinateBounds? = nil, mapZoomMode: MapZoomMode? = nil) {
            self.bounds = bounds
            self.mapZoomMode = mapZoomMode
        }

        public func validate(name: String) throws {
            try self.bounds?.validate(name: "\(name).bounds")
        }

        private enum CodingKeys: String, CodingKey {
            case bounds = "Bounds"
            case mapZoomMode = "MapZoomMode"
        }
    }

    public struct GetDashboardEmbedUrlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "additionalDashboardIds", location: .querystring("additional-dashboard-ids")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId")),
            AWSMemberEncoding(label: "identityType", location: .querystring("creds-type")),
            AWSMemberEncoding(label: "namespace", location: .querystring("namespace")),
            AWSMemberEncoding(label: "resetDisabled", location: .querystring("reset-disabled")),
            AWSMemberEncoding(label: "sessionLifetimeInMinutes", location: .querystring("session-lifetime")),
            AWSMemberEncoding(label: "statePersistenceEnabled", location: .querystring("state-persistence-enabled")),
            AWSMemberEncoding(label: "undoRedoDisabled", location: .querystring("undo-redo-disabled")),
            AWSMemberEncoding(label: "userArn", location: .querystring("user-arn"))
        ]

        /// A list of one or more dashboard IDs that you want anonymous users to have tempporary access to. Currently, the IdentityType parameter must be set to ANONYMOUS because other identity types authenticate as Amazon QuickSight or IAM users. For example, if you set "--dashboard-id dash_id1 --dashboard-id dash_id2 dash_id3 identity-type ANONYMOUS", the session can access all three dashboards.
        public let additionalDashboardIds: [String]?
        /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the Identity and Access Management (IAM) policy.
        public let dashboardId: String
        /// The authentication method that the user uses to sign in.
        public let identityType: EmbeddingIdentityType
        /// The Amazon QuickSight namespace that contains the dashboard IDs in this request. 	   If you're not using a custom namespace, set Namespace = default.
        public let namespace: String?
        /// Remove the reset button on the embedded dashboard. The default is FALSE, which enables the
        /// 			reset button.
        public let resetDisabled: Bool?
        /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
        public let sessionLifetimeInMinutes: Int64?
        /// Adds persistence of state for the user session in an embedded dashboard. Persistence applies to the sheet and the parameter settings. These are control settings that the dashboard subscriber (Amazon QuickSight reader) chooses while viewing the dashboard. If this is set to TRUE, the settings are the same when the subscriber reopens the same dashboard URL. The state is stored in Amazon QuickSight, not in a browser cookie. If this is set to FALSE, the state of the user session is not persisted. The default is FALSE.
        public let statePersistenceEnabled: Bool?
        /// Remove the undo/redo button on the embedded dashboard. The default is FALSE, which enables
        /// 			the undo/redo button.
        public let undoRedoDisabled: Bool?
        /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type.
        /// 			You can use this for any Amazon QuickSight users in your account (readers, authors, or
        /// 			admins) authenticated as one of the following:   Active Directory (AD) users or group members   Invited nonfederated users   IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using
        /// 					SAML, OpenID Connect, or IAM federation.   Omit this parameter for users in the third group  IAM users and IAM role-based sessions.
        public let userArn: String?

        public init(additionalDashboardIds: [String]? = nil, awsAccountId: String, dashboardId: String, identityType: EmbeddingIdentityType, namespace: String? = nil, resetDisabled: Bool? = nil, sessionLifetimeInMinutes: Int64? = nil, statePersistenceEnabled: Bool? = nil, undoRedoDisabled: Bool? = nil, userArn: String? = nil) {
            self.additionalDashboardIds = additionalDashboardIds
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.identityType = identityType
            self.namespace = namespace
            self.resetDisabled = resetDisabled
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.statePersistenceEnabled = statePersistenceEnabled
            self.undoRedoDisabled = undoRedoDisabled
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.additionalDashboardIds?.forEach {
                try validate($0, name: "additionalDashboardIds[]", parent: name, max: 512)
                try validate($0, name: "additionalDashboardIds[]", parent: name, min: 1)
                try validate($0, name: "additionalDashboardIds[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.additionalDashboardIds, name: "additionalDashboardIds", parent: name, max: 20)
            try self.validate(self.additionalDashboardIds, name: "additionalDashboardIds", parent: name, min: 1)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDashboardEmbedUrlResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A single-use URL that you can put into your server-side webpage to embed your
        /// 			dashboard. This URL is valid for 5 minutes. The API operation provides the URL with an
        /// 			auth_code value that enables one (and only one) sign-on to a user session
        /// 			that is valid for 10 hours.
        public let embedUrl: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(embedUrl: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct GetSessionEmbedUrlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "entryPoint", location: .querystring("entry-point")),
            AWSMemberEncoding(label: "sessionLifetimeInMinutes", location: .querystring("session-lifetime")),
            AWSMemberEncoding(label: "userArn", location: .querystring("user-arn"))
        ]

        /// The ID for the Amazon Web Services account associated with your Amazon QuickSight subscription.
        public let awsAccountId: String
        /// The URL you use to access the embedded session. The entry point URL is constrained to the following paths:    /start     /start/analyses     /start/dashboards     /start/favorites     /dashboards/DashboardId - where DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard    /analyses/AnalysisId - where AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis
        public let entryPoint: String?
        /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
        public let sessionLifetimeInMinutes: Int64?
        /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type.
        /// 			You can use this for any type of Amazon QuickSight users in your account (readers, authors, or
        /// 			admins). They need to be authenticated as one of the following:   Active Directory (AD) users or group members   Invited nonfederated users   Identity and Access Management (IAM) users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation   Omit this parameter for users in the third group, IAM users and IAM role-based sessions.
        public let userArn: String?

        public init(awsAccountId: String, entryPoint: String? = nil, sessionLifetimeInMinutes: Int64? = nil, userArn: String? = nil) {
            self.awsAccountId = awsAccountId
            self.entryPoint = entryPoint
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, max: 1000)
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, min: 1)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionEmbedUrlResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A single-use URL that you can put into your server-side web page to embed your
        /// 			Amazon QuickSight session. This URL is valid for 5 minutes. The API operation provides the URL with an
        /// 			auth_code value that enables one (and only one) sign-on to a user session
        /// 			that is valid for 10 hours.
        public let embedUrl: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(embedUrl: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct GlobalTableBorderOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the options for side specific border.
        public let sideSpecificBorder: TableSideBorderOptions?
        /// Determines the options for uniform border.
        public let uniformBorder: TableBorderOptions?

        public init(sideSpecificBorder: TableSideBorderOptions? = nil, uniformBorder: TableBorderOptions? = nil) {
            self.sideSpecificBorder = sideSpecificBorder
            self.uniformBorder = uniformBorder
        }

        public func validate(name: String) throws {
            try self.sideSpecificBorder?.validate(name: "\(name).sideSpecificBorder")
            try self.uniformBorder?.validate(name: "\(name).uniformBorder")
        }

        private enum CodingKeys: String, CodingKey {
            case sideSpecificBorder = "SideSpecificBorder"
            case uniformBorder = "UniformBorder"
        }
    }

    public struct GradientColor: AWSEncodableShape & AWSDecodableShape {
        /// The list of gradient color stops.
        public let stops: [GradientStop]?

        public init(stops: [GradientStop]? = nil) {
            self.stops = stops
        }

        public func validate(name: String) throws {
            try self.stops?.forEach {
                try $0.validate(name: "\(name).stops[]")
            }
            try self.validate(self.stops, name: "stops", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case stops = "Stops"
        }
    }

    public struct GradientStop: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color.
        public let color: String?
        /// Determines the data value.
        public let dataValue: Double?
        /// Determines gradient offset value.
        public let gradientOffset: Double

        public init(color: String? = nil, dataValue: Double? = nil, gradientOffset: Double) {
            self.color = color
            self.dataValue = dataValue
            self.gradientOffset = gradientOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case dataValue = "DataValue"
            case gradientOffset = "GradientOffset"
        }
    }

    public struct GridLayoutCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the sizing of the canvas used in a grid layout.
        public let screenCanvasSizeOptions: GridLayoutScreenCanvasSizeOptions?

        public init(screenCanvasSizeOptions: GridLayoutScreenCanvasSizeOptions? = nil) {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case screenCanvasSizeOptions = "ScreenCanvasSizeOptions"
        }
    }

    public struct GridLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let canvasSizeOptions: GridLayoutCanvasSizeOptions?
        /// The elements that are included in a grid layout.
        public let elements: [GridLayoutElement]

        public init(canvasSizeOptions: GridLayoutCanvasSizeOptions? = nil, elements: [GridLayoutElement]) {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }

        public func validate(name: String) throws {
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 430)
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
            case elements = "Elements"
        }
    }

    public struct GridLayoutElement: AWSEncodableShape & AWSDecodableShape {
        /// The column index for the upper left corner of an element.
        public let columnIndex: Int?
        /// The width of a grid element expressed as a number of grid columns.
        public let columnSpan: Int
        /// A unique identifier for an element within a grid layout.
        public let elementId: String
        /// The type of element.
        public let elementType: LayoutElementType
        /// The row index for the upper left corner of an element.
        public let rowIndex: Int?
        /// The height of a grid element expressed as a number of grid rows.
        public let rowSpan: Int

        public init(columnIndex: Int? = nil, columnSpan: Int, elementId: String, elementType: LayoutElementType, rowIndex: Int? = nil, rowSpan: Int) {
            self.columnIndex = columnIndex
            self.columnSpan = columnSpan
            self.elementId = elementId
            self.elementType = elementType
            self.rowIndex = rowIndex
            self.rowSpan = rowSpan
        }

        public func validate(name: String) throws {
            try self.validate(self.columnIndex, name: "columnIndex", parent: name, max: 35)
            try self.validate(self.columnIndex, name: "columnIndex", parent: name, min: 0)
            try self.validate(self.columnSpan, name: "columnSpan", parent: name, max: 36)
            try self.validate(self.columnSpan, name: "columnSpan", parent: name, min: 1)
            try self.validate(self.elementId, name: "elementId", parent: name, max: 512)
            try self.validate(self.elementId, name: "elementId", parent: name, min: 1)
            try self.validate(self.elementId, name: "elementId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.rowIndex, name: "rowIndex", parent: name, max: 9009)
            try self.validate(self.rowIndex, name: "rowIndex", parent: name, min: 0)
            try self.validate(self.rowSpan, name: "rowSpan", parent: name, max: 21)
            try self.validate(self.rowSpan, name: "rowSpan", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnIndex = "ColumnIndex"
            case columnSpan = "ColumnSpan"
            case elementId = "ElementId"
            case elementType = "ElementType"
            case rowIndex = "RowIndex"
            case rowSpan = "RowSpan"
        }
    }

    public struct GridLayoutScreenCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The width that the view port will be optimized for when the layout renders.
        public let optimizedViewPortWidth: String?
        /// This value determines the layout behavior when the viewport is resized.    FIXED: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called Classic.    RESPONSIVE: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called Tiled.
        public let resizeOption: ResizeOption

        public init(optimizedViewPortWidth: String? = nil, resizeOption: ResizeOption) {
            self.optimizedViewPortWidth = optimizedViewPortWidth
            self.resizeOption = resizeOption
        }

        private enum CodingKeys: String, CodingKey {
            case optimizedViewPortWidth = "OptimizedViewPortWidth"
            case resizeOption = "ResizeOption"
        }
    }

    public struct Group: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the group.
        public let arn: String?
        /// The group description.
        public let description: String?
        /// The name of the group.
        public let groupName: String?
        /// The principal ID of the group.
        public let principalId: String?

        public init(arn: String? = nil, description: String? = nil, groupName: String? = nil, principalId: String? = nil) {
            self.arn = arn
            self.description = description
            self.groupName = groupName
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case groupName = "GroupName"
            case principalId = "PrincipalId"
        }
    }

    public struct GroupMember: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the group member (user).
        public let arn: String?
        /// The name of the group member (user).
        public let memberName: String?

        public init(arn: String? = nil, memberName: String? = nil) {
            self.arn = arn
            self.memberName = memberName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case memberName = "MemberName"
        }
    }

    public struct GroupSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example "Name": "GROUP_NAME". Currently, the only supported name is GROUP_NAME.
        public let name: GroupFilterAttribute
        /// The comparison operator that you want to use as a filter, for example "Operator": "StartsWith". Currently, the only supported operator is StartsWith.
        public let `operator`: GroupFilterOperator
        /// The value of the named item, in this case GROUP_NAME, that you want to use as a filter.
        public let value: String

        public init(name: GroupFilterAttribute, operator: GroupFilterOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct GrowthRateComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The period size setup of a growth rate computation.
        public let periodSize: Int?
        /// The time field that is used in a computation.
        public let time: DimensionField
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, periodSize: Int? = nil, time: DimensionField, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.periodSize = periodSize
            self.time = time
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.periodSize, name: "periodSize", parent: name, max: 52)
            try self.validate(self.periodSize, name: "periodSize", parent: name, min: 2)
            try self.time.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case periodSize = "PeriodSize"
            case time = "Time"
            case value = "Value"
        }
    }

    public struct GutterStyle: AWSEncodableShape & AWSDecodableShape {
        /// This Boolean value controls whether to display a gutter space between sheet tiles.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct HeaderFooterSectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The layout configuration of the header or footer section.
        public let layout: SectionLayoutConfiguration
        /// The unique identifier of the header or footer section.
        public let sectionId: String
        /// The style options of a header or footer section.
        public let style: SectionStyle?

        public init(layout: SectionLayoutConfiguration, sectionId: String, style: SectionStyle? = nil) {
            self.layout = layout
            self.sectionId = sectionId
            self.style = style
        }

        public func validate(name: String) throws {
            try self.layout.validate(name: "\(name).layout")
            try self.validate(self.sectionId, name: "sectionId", parent: name, max: 512)
            try self.validate(self.sectionId, name: "sectionId", parent: name, min: 1)
            try self.validate(self.sectionId, name: "sectionId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case layout = "Layout"
            case sectionId = "SectionId"
            case style = "Style"
        }
    }

    public struct HeatMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The columns field well of a heat map.
        public let columns: [DimensionField]?
        /// The rows field well of a heat map.
        public let rows: [DimensionField]?
        /// The values field well of a heat map.
        public let values: [MeasureField]?

        public init(columns: [DimensionField]? = nil, rows: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.columns = columns
            self.rows = rows
            self.values = values
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 1)
            try self.rows?.forEach {
                try $0.validate(name: "\(name).rows[]")
            }
            try self.validate(self.rows, name: "rows", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case rows = "Rows"
            case values = "Values"
        }
    }

    public struct HeatMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The color options (gradient color, point of divergence) in a heat map.
        public let colorScale: ColorScale?
        /// The label options of the column that is displayed in a heat map.
        public let columnLabelOptions: ChartAxisLabelOptions?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: HeatMapFieldWells?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The label options of the row that is displayed in a heat map.
        public let rowLabelOptions: ChartAxisLabelOptions?
        /// The sort configuration of a heat map.
        public let sortConfiguration: HeatMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?

        public init(colorScale: ColorScale? = nil, columnLabelOptions: ChartAxisLabelOptions? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: HeatMapFieldWells? = nil, legend: LegendOptions? = nil, rowLabelOptions: ChartAxisLabelOptions? = nil, sortConfiguration: HeatMapSortConfiguration? = nil, tooltip: TooltipOptions? = nil) {
            self.colorScale = colorScale
            self.columnLabelOptions = columnLabelOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.rowLabelOptions = rowLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }

        public func validate(name: String) throws {
            try self.colorScale?.validate(name: "\(name).colorScale")
            try self.columnLabelOptions?.validate(name: "\(name).columnLabelOptions")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.rowLabelOptions?.validate(name: "\(name).rowLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
        }

        private enum CodingKeys: String, CodingKey {
            case colorScale = "ColorScale"
            case columnLabelOptions = "ColumnLabelOptions"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case rowLabelOptions = "RowLabelOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
        }
    }

    public struct HeatMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a heat map.
        public let heatMapAggregatedFieldWells: HeatMapAggregatedFieldWells?

        public init(heatMapAggregatedFieldWells: HeatMapAggregatedFieldWells? = nil) {
            self.heatMapAggregatedFieldWells = heatMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.heatMapAggregatedFieldWells?.validate(name: "\(name).heatMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case heatMapAggregatedFieldWells = "HeatMapAggregatedFieldWells"
        }
    }

    public struct HeatMapSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of columns that are displayed in a heat map.
        public let heatMapColumnItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The column sort configuration for heat map for columns that aren't a part of a field well.
        public let heatMapColumnSort: [FieldSortOptions]?
        /// The limit on the number of rows that are displayed in a heat map.
        public let heatMapRowItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The field sort configuration of the rows fields.
        public let heatMapRowSort: [FieldSortOptions]?

        public init(heatMapColumnItemsLimitConfiguration: ItemsLimitConfiguration? = nil, heatMapColumnSort: [FieldSortOptions]? = nil, heatMapRowItemsLimitConfiguration: ItemsLimitConfiguration? = nil, heatMapRowSort: [FieldSortOptions]? = nil) {
            self.heatMapColumnItemsLimitConfiguration = heatMapColumnItemsLimitConfiguration
            self.heatMapColumnSort = heatMapColumnSort
            self.heatMapRowItemsLimitConfiguration = heatMapRowItemsLimitConfiguration
            self.heatMapRowSort = heatMapRowSort
        }

        public func validate(name: String) throws {
            try self.heatMapColumnSort?.forEach {
                try $0.validate(name: "\(name).heatMapColumnSort[]")
            }
            try self.validate(self.heatMapColumnSort, name: "heatMapColumnSort", parent: name, max: 100)
            try self.heatMapRowSort?.forEach {
                try $0.validate(name: "\(name).heatMapRowSort[]")
            }
            try self.validate(self.heatMapRowSort, name: "heatMapRowSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case heatMapColumnItemsLimitConfiguration = "HeatMapColumnItemsLimitConfiguration"
            case heatMapColumnSort = "HeatMapColumnSort"
            case heatMapRowItemsLimitConfiguration = "HeatMapRowItemsLimitConfiguration"
            case heatMapRowSort = "HeatMapRowSort"
        }
    }

    public struct HeatMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a heat map.
        public let chartConfiguration: HeatMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: HeatMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct HistogramAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The value field wells of a histogram. Values are aggregated by COUNT or DISTINCT_COUNT.
        public let values: [MeasureField]?

        public init(values: [MeasureField]? = nil) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct HistogramBinOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the bin count of a histogram.
        public let binCount: BinCountOptions?
        /// The options that determine the bin width of a histogram.
        public let binWidth: BinWidthOptions?
        /// The options that determine the selected bin type.
        public let selectedBinType: HistogramBinType?
        /// The options that determine the bin start value.
        public let startValue: Double?

        public init(binCount: BinCountOptions? = nil, binWidth: BinWidthOptions? = nil, selectedBinType: HistogramBinType? = nil, startValue: Double? = nil) {
            self.binCount = binCount
            self.binWidth = binWidth
            self.selectedBinType = selectedBinType
            self.startValue = startValue
        }

        public func validate(name: String) throws {
            try self.binCount?.validate(name: "\(name).binCount")
            try self.binWidth?.validate(name: "\(name).binWidth")
        }

        private enum CodingKeys: String, CodingKey {
            case binCount = "BinCount"
            case binWidth = "BinWidth"
            case selectedBinType = "SelectedBinType"
            case startValue = "StartValue"
        }
    }

    public struct HistogramConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of histogram bins.
        public let binOptions: HistogramBinOptions?
        /// The data label configuration of a histogram.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a histogram.
        public let fieldWells: HistogramFieldWells?
        /// The tooltip configuration of a histogram.
        public let tooltip: TooltipOptions?
        /// The visual palette configuration of a histogram.
        public let visualPalette: VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public let xAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public let xAxisLabelOptions: ChartAxisLabelOptions?
        /// The options that determine the presentation of the y-axis.
        public let yAxisDisplayOptions: AxisDisplayOptions?

        public init(binOptions: HistogramBinOptions? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: HistogramFieldWells? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil, xAxisDisplayOptions: AxisDisplayOptions? = nil, xAxisLabelOptions: ChartAxisLabelOptions? = nil, yAxisDisplayOptions: AxisDisplayOptions? = nil) {
            self.binOptions = binOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
        }

        public func validate(name: String) throws {
            try self.binOptions?.validate(name: "\(name).binOptions")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.xAxisDisplayOptions?.validate(name: "\(name).xAxisDisplayOptions")
            try self.xAxisLabelOptions?.validate(name: "\(name).xAxisLabelOptions")
            try self.yAxisDisplayOptions?.validate(name: "\(name).yAxisDisplayOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case binOptions = "BinOptions"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
            case xAxisDisplayOptions = "XAxisDisplayOptions"
            case xAxisLabelOptions = "XAxisLabelOptions"
            case yAxisDisplayOptions = "YAxisDisplayOptions"
        }
    }

    public struct HistogramFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a histogram.
        public let histogramAggregatedFieldWells: HistogramAggregatedFieldWells?

        public init(histogramAggregatedFieldWells: HistogramAggregatedFieldWells? = nil) {
            self.histogramAggregatedFieldWells = histogramAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.histogramAggregatedFieldWells?.validate(name: "\(name).histogramAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case histogramAggregatedFieldWells = "HistogramAggregatedFieldWells"
        }
    }

    public struct HistogramVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration for a HistogramVisual.
        public let chartConfiguration: HistogramConfiguration?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: HistogramConfiguration? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct IAMPolicyAssignment: AWSDecodableShape {
        /// Assignment ID.
        public let assignmentId: String?
        /// Assignment name.
        public let assignmentName: String?
        /// Assignment status.
        public let assignmentStatus: AssignmentStatus?
        /// The Amazon Web Services account ID.
        public let awsAccountId: String?
        /// Identities.
        public let identities: [String: [String]]?
        /// The Amazon Resource Name (ARN) for the IAM policy.
        public let policyArn: String?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, awsAccountId: String? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.policyArn = policyArn
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case awsAccountId = "AwsAccountId"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct IAMPolicyAssignmentSummary: AWSDecodableShape {
        /// Assignment name.
        public let assignmentName: String?
        /// Assignment status.
        public let assignmentStatus: AssignmentStatus?

        public init(assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
        }
    }

    public struct Ingestion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// The time that this ingestion started.
        public let createdTime: Date
        /// Error information for this ingestion.
        public let errorInfo: ErrorInfo?
        /// Ingestion ID.
        public let ingestionId: String?
        /// The size of the data ingested, in bytes.
        public let ingestionSizeInBytes: Int64?
        /// Ingestion status.
        public let ingestionStatus: IngestionStatus
        /// The time that this ingestion took, measured in seconds.
        public let ingestionTimeInSeconds: Int64?
        public let queueInfo: QueueInfo?
        /// Event source for this ingestion.
        public let requestSource: IngestionRequestSource?
        /// Type of this ingestion.
        public let requestType: IngestionRequestType?
        public let rowInfo: RowInfo?

        public init(arn: String, createdTime: Date, errorInfo: ErrorInfo? = nil, ingestionId: String? = nil, ingestionSizeInBytes: Int64? = nil, ingestionStatus: IngestionStatus, ingestionTimeInSeconds: Int64? = nil, queueInfo: QueueInfo? = nil, requestSource: IngestionRequestSource? = nil, requestType: IngestionRequestType? = nil, rowInfo: RowInfo? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.errorInfo = errorInfo
            self.ingestionId = ingestionId
            self.ingestionSizeInBytes = ingestionSizeInBytes
            self.ingestionStatus = ingestionStatus
            self.ingestionTimeInSeconds = ingestionTimeInSeconds
            self.queueInfo = queueInfo
            self.requestSource = requestSource
            self.requestType = requestType
            self.rowInfo = rowInfo
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case errorInfo = "ErrorInfo"
            case ingestionId = "IngestionId"
            case ingestionSizeInBytes = "IngestionSizeInBytes"
            case ingestionStatus = "IngestionStatus"
            case ingestionTimeInSeconds = "IngestionTimeInSeconds"
            case queueInfo = "QueueInfo"
            case requestSource = "RequestSource"
            case requestType = "RequestType"
            case rowInfo = "RowInfo"
        }
    }

    public struct InputColumn: AWSEncodableShape & AWSDecodableShape {
        /// The name of this column in the underlying data source.
        public let name: String
        /// The data type of the column.
        public let type: InputColumnDataType

        public init(name: String, type: InputColumnDataType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct InsightConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The computations configurations of the insight visual
        public let computations: [Computation]?
        /// The custom narrative of the insight visual.
        public let customNarrative: CustomNarrativeOptions?

        public init(computations: [Computation]? = nil, customNarrative: CustomNarrativeOptions? = nil) {
            self.computations = computations
            self.customNarrative = customNarrative
        }

        public func validate(name: String) throws {
            try self.computations?.forEach {
                try $0.validate(name: "\(name).computations[]")
            }
            try self.validate(self.computations, name: "computations", parent: name, max: 100)
            try self.customNarrative?.validate(name: "\(name).customNarrative")
        }

        private enum CodingKeys: String, CodingKey {
            case computations = "Computations"
            case customNarrative = "CustomNarrative"
        }
    }

    public struct InsightVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The dataset that is used in the insight visual.
        public let dataSetIdentifier: String
        /// The configuration of an insight visual.
        public let insightConfiguration: InsightConfiguration?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, dataSetIdentifier: String, insightConfiguration: InsightConfiguration? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.insightConfiguration = insightConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.insightConfiguration?.validate(name: "\(name).insightConfiguration")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case dataSetIdentifier = "DataSetIdentifier"
            case insightConfiguration = "InsightConfiguration"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct IntegerDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the IntegerDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The static values of the IntegerDefaultValues.
        public let staticValues: [Int64]?

        public init(dynamicValue: DynamicDefaultValue? = nil, staticValues: [Int64]? = nil) {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case staticValues = "StaticValues"
        }
    }

    public struct IntegerParameter: AWSEncodableShape {
        /// The name of the integer parameter.
        public let name: String
        /// The values for the integer parameter.
        public let values: [Int64]

        public init(name: String, values: [Int64]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct IntegerParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: IntegerDefaultValues?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        public let parameterValueType: ParameterValueType
        /// A parameter declaration for the Integer data type.
        public let valueWhenUnset: IntegerValueWhenUnsetConfiguration?

        public init(defaultValues: IntegerDefaultValues? = nil, name: String, parameterValueType: ParameterValueType, valueWhenUnset: IntegerValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case name = "Name"
            case parameterValueType = "ParameterValueType"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct IntegerValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: Int64?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: Int64? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct ItemsLimitConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.
        public let itemsLimit: Int64?
        /// The Show other of an axis in the chart. Choose one of the following options:    INCLUDE     EXCLUDE
        public let otherCategories: OtherCategories?

        public init(itemsLimit: Int64? = nil, otherCategories: OtherCategories? = nil) {
            self.itemsLimit = itemsLimit
            self.otherCategories = otherCategories
        }

        private enum CodingKeys: String, CodingKey {
            case itemsLimit = "ItemsLimit"
            case otherCategories = "OtherCategories"
        }
    }

    public struct JiraParameters: AWSEncodableShape & AWSDecodableShape {
        /// The base URL of the Jira site.
        public let siteBaseUrl: String

        public init(siteBaseUrl: String) {
            self.siteBaseUrl = siteBaseUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, max: 1024)
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case siteBaseUrl = "SiteBaseUrl"
        }
    }

    public struct JoinInstruction: AWSEncodableShape & AWSDecodableShape {
        /// Join key properties of the left operand.
        public let leftJoinKeyProperties: JoinKeyProperties?
        /// The operand on the left side of a join.
        public let leftOperand: String
        /// The join instructions provided in the ON clause of a join.
        public let onClause: String
        /// Join key properties of the right operand.
        public let rightJoinKeyProperties: JoinKeyProperties?
        /// The operand on the right side of a join.
        public let rightOperand: String
        /// The type of join that it is.
        public let type: JoinType

        public init(leftJoinKeyProperties: JoinKeyProperties? = nil, leftOperand: String, onClause: String, rightJoinKeyProperties: JoinKeyProperties? = nil, rightOperand: String, type: JoinType) {
            self.leftJoinKeyProperties = leftJoinKeyProperties
            self.leftOperand = leftOperand
            self.onClause = onClause
            self.rightJoinKeyProperties = rightJoinKeyProperties
            self.rightOperand = rightOperand
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, max: 64)
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, min: 1)
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, pattern: "^[0-9a-zA-Z-]*$")
            try self.validate(self.onClause, name: "onClause", parent: name, max: 512)
            try self.validate(self.onClause, name: "onClause", parent: name, min: 1)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, max: 64)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, min: 1)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, pattern: "^[0-9a-zA-Z-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case leftJoinKeyProperties = "LeftJoinKeyProperties"
            case leftOperand = "LeftOperand"
            case onClause = "OnClause"
            case rightJoinKeyProperties = "RightJoinKeyProperties"
            case rightOperand = "RightOperand"
            case type = "Type"
        }
    }

    public struct JoinKeyProperties: AWSEncodableShape & AWSDecodableShape {
        /// A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        public let uniqueKey: Bool?

        public init(uniqueKey: Bool? = nil) {
            self.uniqueKey = uniqueKey
        }

        private enum CodingKeys: String, CodingKey {
            case uniqueKey = "UniqueKey"
        }
    }

    public struct KPIConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting options of a KPI visual.
        public let conditionalFormattingOptions: [KPIConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [KPIConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct KPIConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting for the primary value of a KPI visual.
        public let primaryValue: KPIPrimaryValueConditionalFormatting?
        /// The conditional formatting for the progress bar of a KPI visual.
        public let progressBar: KPIProgressBarConditionalFormatting?

        public init(primaryValue: KPIPrimaryValueConditionalFormatting? = nil, progressBar: KPIProgressBarConditionalFormatting? = nil) {
            self.primaryValue = primaryValue
            self.progressBar = progressBar
        }

        public func validate(name: String) throws {
            try self.primaryValue?.validate(name: "\(name).primaryValue")
            try self.progressBar?.validate(name: "\(name).progressBar")
        }

        private enum CodingKeys: String, CodingKey {
            case primaryValue = "PrimaryValue"
            case progressBar = "ProgressBar"
        }
    }

    public struct KPIConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a KPI visual.
        public let fieldWells: KPIFieldWells?
        /// The options that determine the presentation of a KPI visual.
        public let kpiOptions: KPIOptions?
        /// The sort configuration of a KPI visual.
        public let sortConfiguration: KPISortConfiguration?

        public init(fieldWells: KPIFieldWells? = nil, kpiOptions: KPIOptions? = nil, sortConfiguration: KPISortConfiguration? = nil) {
            self.fieldWells = fieldWells
            self.kpiOptions = kpiOptions
            self.sortConfiguration = sortConfiguration
        }

        public func validate(name: String) throws {
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.kpiOptions?.validate(name: "\(name).kpiOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldWells = "FieldWells"
            case kpiOptions = "KPIOptions"
            case sortConfiguration = "SortConfiguration"
        }
    }

    public struct KPIFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The target value field wells of a KPI visual.
        public let targetValues: [MeasureField]?
        /// The trend group field wells of a KPI visual.
        public let trendGroups: [DimensionField]?
        /// The value field wells of a KPI visual.
        public let values: [MeasureField]?

        public init(targetValues: [MeasureField]? = nil, trendGroups: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.targetValues = targetValues
            self.trendGroups = trendGroups
            self.values = values
        }

        public func validate(name: String) throws {
            try self.targetValues?.forEach {
                try $0.validate(name: "\(name).targetValues[]")
            }
            try self.validate(self.targetValues, name: "targetValues", parent: name, max: 200)
            try self.trendGroups?.forEach {
                try $0.validate(name: "\(name).trendGroups[]")
            }
            try self.validate(self.trendGroups, name: "trendGroups", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case targetValues = "TargetValues"
            case trendGroups = "TrendGroups"
            case values = "Values"
        }
    }

    public struct KPIOptions: AWSEncodableShape & AWSDecodableShape {
        /// The comparison configuration of a KPI visual.
        public let comparison: ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public let primaryValueDisplayType: PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public let primaryValueFontConfiguration: FontConfiguration?
        /// The options that determine the presentation of the progress bar of a KPI visual.
        public let progressBar: ProgressBarOptions?
        /// The options that determine the presentation of the secondary value of a KPI visual.
        public let secondaryValue: SecondaryValueOptions?
        /// The options that determine the secondary value font configuration.
        public let secondaryValueFontConfiguration: FontConfiguration?
        /// The options that determine the presentation of trend arrows in a KPI visual.
        public let trendArrows: TrendArrowOptions?

        public init(comparison: ComparisonConfiguration? = nil, primaryValueDisplayType: PrimaryValueDisplayType? = nil, primaryValueFontConfiguration: FontConfiguration? = nil, progressBar: ProgressBarOptions? = nil, secondaryValue: SecondaryValueOptions? = nil, secondaryValueFontConfiguration: FontConfiguration? = nil, trendArrows: TrendArrowOptions? = nil) {
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
            self.progressBar = progressBar
            self.secondaryValue = secondaryValue
            self.secondaryValueFontConfiguration = secondaryValueFontConfiguration
            self.trendArrows = trendArrows
        }

        public func validate(name: String) throws {
            try self.comparison?.validate(name: "\(name).comparison")
            try self.primaryValueFontConfiguration?.validate(name: "\(name).primaryValueFontConfiguration")
            try self.secondaryValueFontConfiguration?.validate(name: "\(name).secondaryValueFontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case primaryValueDisplayType = "PrimaryValueDisplayType"
            case primaryValueFontConfiguration = "PrimaryValueFontConfiguration"
            case progressBar = "ProgressBar"
            case secondaryValue = "SecondaryValue"
            case secondaryValueFontConfiguration = "SecondaryValueFontConfiguration"
            case trendArrows = "TrendArrows"
        }
    }

    public struct KPIPrimaryValueConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the primary value's icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting of the  primary value's text color.
        public let textColor: ConditionalFormattingColor?

        public init(icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct KPIProgressBarConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the progress bar's foreground color.
        public let foregroundColor: ConditionalFormattingColor?

        public init(foregroundColor: ConditionalFormattingColor? = nil) {
            self.foregroundColor = foregroundColor
        }

        public func validate(name: String) throws {
            try self.foregroundColor?.validate(name: "\(name).foregroundColor")
        }

        private enum CodingKeys: String, CodingKey {
            case foregroundColor = "ForegroundColor"
        }
    }

    public struct KPISortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration of the trend group fields.
        public let trendGroupSort: [FieldSortOptions]?

        public init(trendGroupSort: [FieldSortOptions]? = nil) {
            self.trendGroupSort = trendGroupSort
        }

        public func validate(name: String) throws {
            try self.trendGroupSort?.forEach {
                try $0.validate(name: "\(name).trendGroupSort[]")
            }
            try self.validate(self.trendGroupSort, name: "trendGroupSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case trendGroupSort = "TrendGroupSort"
        }
    }

    public struct KPIVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a KPI visual.
        public let chartConfiguration: KPIConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The conditional formatting of a KPI visual.
        public let conditionalFormatting: KPIConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: KPIConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, conditionalFormatting: KPIConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct LabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The text for the label.
        public let customLabel: String?
        /// The font configuration of the label.
        public let fontConfiguration: FontConfiguration?
        /// Determines whether or not the label is visible.
        public let visibility: Visibility?

        public init(customLabel: String? = nil, fontConfiguration: FontConfiguration? = nil, visibility: Visibility? = nil) {
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fontConfiguration = "FontConfiguration"
            case visibility = "Visibility"
        }
    }

    public struct Layout: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that determines what the type of layout for a sheet.
        public let configuration: LayoutConfiguration

        public init(configuration: LayoutConfiguration) {
            self.configuration = configuration
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct LayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.
        public let freeFormLayout: FreeFormLayoutConfiguration?
        /// A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: FIXED or RESPONSIVE.
        public let gridLayout: GridLayoutConfiguration?
        /// A section based layout organizes visuals into multiple sections and has customized header, footer and page break.
        public let sectionBasedLayout: SectionBasedLayoutConfiguration?

        public init(freeFormLayout: FreeFormLayoutConfiguration? = nil, gridLayout: GridLayoutConfiguration? = nil, sectionBasedLayout: SectionBasedLayoutConfiguration? = nil) {
            self.freeFormLayout = freeFormLayout
            self.gridLayout = gridLayout
            self.sectionBasedLayout = sectionBasedLayout
        }

        public func validate(name: String) throws {
            try self.freeFormLayout?.validate(name: "\(name).freeFormLayout")
            try self.gridLayout?.validate(name: "\(name).gridLayout")
            try self.sectionBasedLayout?.validate(name: "\(name).sectionBasedLayout")
        }

        private enum CodingKeys: String, CodingKey {
            case freeFormLayout = "FreeFormLayout"
            case gridLayout = "GridLayout"
            case sectionBasedLayout = "SectionBasedLayout"
        }
    }

    public struct LegendOptions: AWSEncodableShape & AWSDecodableShape {
        /// The height of the legend. If this value is omitted, a default height is used when rendering.
        public let height: String?
        /// The positions for the legend. Choose one of the following options:    AUTO     RIGHT     BOTTOM     LEFT
        public let position: LegendPosition?
        /// The custom title for the legend.
        public let title: LabelOptions?
        /// Determines whether or not the legend is visible.
        public let visibility: Visibility?
        /// The width of the legend. If this value is omitted, a default width is used when rendering.
        public let width: String?

        public init(height: String? = nil, position: LegendPosition? = nil, title: LabelOptions? = nil, visibility: Visibility? = nil, width: String? = nil) {
            self.height = height
            self.position = position
            self.title = title
            self.visibility = visibility
            self.width = width
        }

        public func validate(name: String) throws {
            try self.title?.validate(name: "\(name).title")
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case position = "Position"
            case title = "Title"
            case visibility = "Visibility"
            case width = "Width"
        }
    }

    public struct LineChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category field wells of a line chart. Values are grouped by category fields.
        public let category: [DimensionField]?
        /// The color field wells of a line chart. Values are grouped by category fields.
        public let colors: [DimensionField]?
        /// The small multiples field well of a line chart.
        public let smallMultiples: [DimensionField]?
        /// The value field wells of a line chart. Values are aggregated based on categories.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, colors: [DimensionField]? = nil, smallMultiples: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.smallMultiples?.forEach {
                try $0.validate(name: "\(name).smallMultiples[]")
            }
            try self.validate(self.smallMultiples, name: "smallMultiples", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case colors = "Colors"
            case smallMultiples = "SmallMultiples"
            case values = "Values"
        }
    }

    public struct LineChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The default configuration of a line chart's contribution analysis.
        public let contributionAnalysisDefaults: [ContributionAnalysisDefault]?
        /// The data label configuration of a line chart.
        public let dataLabels: DataLabelOptions?
        /// The options that determine the default presentation of all line series in LineChartVisual.
        public let defaultSeriesSettings: LineChartDefaultSeriesSettings?
        /// The field well configuration of a line chart.
        public let fieldWells: LineChartFieldWells?
        /// The forecast configuration of a line chart.
        public let forecastConfigurations: [ForecastConfiguration]?
        /// The legend configuration of a line chart.
        public let legend: LegendOptions?
        /// The series axis configuration of a line chart.
        public let primaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The reference lines configuration of a line chart.
        public let referenceLines: [ReferenceLine]?
        /// The series axis configuration of a line chart.
        public let secondaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the secondary y-axis label.
        public let secondaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The series item configuration of a line chart.
        public let series: [SeriesItem]?
        /// The small multiples setup for the visual.
        public let smallMultiplesOptions: SmallMultiplesOptions?
        /// The sort configuration of a line chart.
        public let sortConfiguration: LineChartSortConfiguration?
        /// The tooltip configuration of a line chart.
        public let tooltip: TooltipOptions?
        /// Determines the type of the line chart.
        public let type: LineChartType?
        /// The visual palette configuration of a line chart.
        public let visualPalette: VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public let xAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public let xAxisLabelOptions: ChartAxisLabelOptions?

        public init(contributionAnalysisDefaults: [ContributionAnalysisDefault]? = nil, dataLabels: DataLabelOptions? = nil, defaultSeriesSettings: LineChartDefaultSeriesSettings? = nil, fieldWells: LineChartFieldWells? = nil, forecastConfigurations: [ForecastConfiguration]? = nil, legend: LegendOptions? = nil, primaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, referenceLines: [ReferenceLine]? = nil, secondaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions? = nil, secondaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, series: [SeriesItem]? = nil, smallMultiplesOptions: SmallMultiplesOptions? = nil, sortConfiguration: LineChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, type: LineChartType? = nil, visualPalette: VisualPalette? = nil, xAxisDisplayOptions: AxisDisplayOptions? = nil, xAxisLabelOptions: ChartAxisLabelOptions? = nil) {
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.defaultSeriesSettings = defaultSeriesSettings
            self.fieldWells = fieldWells
            self.forecastConfigurations = forecastConfigurations
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.series = series
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.type = type
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
        }

        public func validate(name: String) throws {
            try self.contributionAnalysisDefaults?.forEach {
                try $0.validate(name: "\(name).contributionAnalysisDefaults[]")
            }
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, max: 200)
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, min: 1)
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.defaultSeriesSettings?.validate(name: "\(name).defaultSeriesSettings")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.forecastConfigurations?.forEach {
                try $0.validate(name: "\(name).forecastConfigurations[]")
            }
            try self.validate(self.forecastConfigurations, name: "forecastConfigurations", parent: name, max: 10)
            try self.legend?.validate(name: "\(name).legend")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.secondaryYAxisDisplayOptions?.validate(name: "\(name).secondaryYAxisDisplayOptions")
            try self.secondaryYAxisLabelOptions?.validate(name: "\(name).secondaryYAxisLabelOptions")
            try self.series?.forEach {
                try $0.validate(name: "\(name).series[]")
            }
            try self.validate(self.series, name: "series", parent: name, max: 10)
            try self.smallMultiplesOptions?.validate(name: "\(name).smallMultiplesOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.xAxisDisplayOptions?.validate(name: "\(name).xAxisDisplayOptions")
            try self.xAxisLabelOptions?.validate(name: "\(name).xAxisLabelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
            case dataLabels = "DataLabels"
            case defaultSeriesSettings = "DefaultSeriesSettings"
            case fieldWells = "FieldWells"
            case forecastConfigurations = "ForecastConfigurations"
            case legend = "Legend"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case referenceLines = "ReferenceLines"
            case secondaryYAxisDisplayOptions = "SecondaryYAxisDisplayOptions"
            case secondaryYAxisLabelOptions = "SecondaryYAxisLabelOptions"
            case series = "Series"
            case smallMultiplesOptions = "SmallMultiplesOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case type = "Type"
            case visualPalette = "VisualPalette"
            case xAxisDisplayOptions = "XAxisDisplayOptions"
            case xAxisLabelOptions = "XAxisLabelOptions"
        }
    }

    public struct LineChartDefaultSeriesSettings: AWSEncodableShape & AWSDecodableShape {
        /// The axis to which you are binding all line series to.
        public let axisBinding: AxisBinding?
        /// Line styles options for all line series in the visual.
        public let lineStyleSettings: LineChartLineStyleSettings?
        /// Marker styles options for all line series in the visual.
        public let markerStyleSettings: LineChartMarkerStyleSettings?

        public init(axisBinding: AxisBinding? = nil, lineStyleSettings: LineChartLineStyleSettings? = nil, markerStyleSettings: LineChartMarkerStyleSettings? = nil) {
            self.axisBinding = axisBinding
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }

        public func validate(name: String) throws {
            try self.markerStyleSettings?.validate(name: "\(name).markerStyleSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case lineStyleSettings = "LineStyleSettings"
            case markerStyleSettings = "MarkerStyleSettings"
        }
    }

    public struct LineChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a line chart.
        public let lineChartAggregatedFieldWells: LineChartAggregatedFieldWells?

        public init(lineChartAggregatedFieldWells: LineChartAggregatedFieldWells? = nil) {
            self.lineChartAggregatedFieldWells = lineChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.lineChartAggregatedFieldWells?.validate(name: "\(name).lineChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case lineChartAggregatedFieldWells = "LineChartAggregatedFieldWells"
        }
    }

    public struct LineChartLineStyleSettings: AWSEncodableShape & AWSDecodableShape {
        /// Interpolation style for line series.    LINEAR: Show as default, linear style.    SMOOTH: Show as a smooth curve.    STEPPED: Show steps in line.
        public let lineInterpolation: LineInterpolation?
        /// Line style for line series.    SOLID: Show as a solid line.    DOTTED: Show as a dotted line.    DASHED: Show as a dashed line.
        public let lineStyle: LineChartLineStyle?
        /// Configuration option that determines whether to show the line for the series.
        public let lineVisibility: Visibility?
        /// Width that determines the line thickness.
        public let lineWidth: String?

        public init(lineInterpolation: LineInterpolation? = nil, lineStyle: LineChartLineStyle? = nil, lineVisibility: Visibility? = nil, lineWidth: String? = nil) {
            self.lineInterpolation = lineInterpolation
            self.lineStyle = lineStyle
            self.lineVisibility = lineVisibility
            self.lineWidth = lineWidth
        }

        private enum CodingKeys: String, CodingKey {
            case lineInterpolation = "LineInterpolation"
            case lineStyle = "LineStyle"
            case lineVisibility = "LineVisibility"
            case lineWidth = "LineWidth"
        }
    }

    public struct LineChartMarkerStyleSettings: AWSEncodableShape & AWSDecodableShape {
        /// Color of marker in the series.
        public let markerColor: String?
        /// Shape option for markers in the series.    CIRCLE: Show marker as a circle.    TRIANGLE: Show marker as a triangle.    SQUARE: Show marker as a square.    DIAMOND: Show marker as a diamond.    ROUNDED_SQUARE: Show marker as a rounded square.
        public let markerShape: LineChartMarkerShape?
        /// Size of marker in the series.
        public let markerSize: String?
        /// Configuration option that determines whether to show the markers in the series.
        public let markerVisibility: Visibility?

        public init(markerColor: String? = nil, markerShape: LineChartMarkerShape? = nil, markerSize: String? = nil, markerVisibility: Visibility? = nil) {
            self.markerColor = markerColor
            self.markerShape = markerShape
            self.markerSize = markerSize
            self.markerVisibility = markerVisibility
        }

        public func validate(name: String) throws {
            try self.validate(self.markerColor, name: "markerColor", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case markerColor = "MarkerColor"
            case markerShape = "MarkerShape"
            case markerSize = "MarkerSize"
            case markerVisibility = "MarkerVisibility"
        }
    }

    public struct LineChartSeriesSettings: AWSEncodableShape & AWSDecodableShape {
        /// Line styles options for a line series in LineChartVisual.
        public let lineStyleSettings: LineChartLineStyleSettings?
        /// Marker styles options for a line series in LineChartVisual.
        public let markerStyleSettings: LineChartMarkerStyleSettings?

        public init(lineStyleSettings: LineChartLineStyleSettings? = nil, markerStyleSettings: LineChartMarkerStyleSettings? = nil) {
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }

        public func validate(name: String) throws {
            try self.markerStyleSettings?.validate(name: "\(name).markerStyleSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case lineStyleSettings = "LineStyleSettings"
            case markerStyleSettings = "MarkerStyleSettings"
        }
    }

    public struct LineChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories that are displayed in a line chart.
        public let categoryItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?
        /// The limit on the number of lines that are displayed in a line chart.
        public let colorItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The limit on the number of small multiples panels that are displayed.
        public let smallMultiplesLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public let smallMultiplesSort: [FieldSortOptions]?

        public init(categoryItemsLimitConfiguration: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, colorItemsLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimitConfiguration = categoryItemsLimitConfiguration
            self.categorySort = categorySort
            self.colorItemsLimitConfiguration = colorItemsLimitConfiguration
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.smallMultiplesSort?.forEach {
                try $0.validate(name: "\(name).smallMultiplesSort[]")
            }
            try self.validate(self.smallMultiplesSort, name: "smallMultiplesSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimitConfiguration = "CategoryItemsLimitConfiguration"
            case categorySort = "CategorySort"
            case colorItemsLimitConfiguration = "ColorItemsLimitConfiguration"
            case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
            case smallMultiplesSort = "SmallMultiplesSort"
        }
    }

    public struct LineChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a line chart.
        public let chartConfiguration: LineChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: LineChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct LineSeriesAxisDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of the line series axis.
        public let axisOptions: AxisDisplayOptions?
        /// The configuration options that determine how missing data is treated during the rendering of a line chart.
        public let missingDataConfigurations: [MissingDataConfiguration]?

        public init(axisOptions: AxisDisplayOptions? = nil, missingDataConfigurations: [MissingDataConfiguration]? = nil) {
            self.axisOptions = axisOptions
            self.missingDataConfigurations = missingDataConfigurations
        }

        public func validate(name: String) throws {
            try self.axisOptions?.validate(name: "\(name).axisOptions")
            try self.validate(self.missingDataConfigurations, name: "missingDataConfigurations", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case axisOptions = "AxisOptions"
            case missingDataConfigurations = "MissingDataConfigurations"
        }
    }

    public struct LinkSharingConfiguration: AWSDecodableShape {
        /// A structure that contains the permissions of a shareable link.
        public let permissions: [ResourcePermission]?

        public init(permissions: [ResourcePermission]? = nil) {
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
        }
    }

    public struct ListAnalysesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID of the Amazon Web Services account that contains the analyses.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalysesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Metadata describing each of the analyses that are listed.
        public let analysisSummaryList: [AnalysisSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisSummaryList: [AnalysisSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisSummaryList = analysisSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSummaryList = "AnalysisSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the search options in a list control.
        public let searchOptions: ListControlSearchOptions?
        /// The configuration of the Select all options in a list control.
        public let selectAllOptions: ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(searchOptions: ListControlSearchOptions? = nil, selectAllOptions: ListControlSelectAllOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.searchOptions = searchOptions
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case searchOptions = "SearchOptions"
            case selectAllOptions = "SelectAllOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct ListControlSearchOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of the search options in a list control.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct ListControlSelectAllOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of the Select all options in a list control.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct ListDashboardVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID of the Amazon Web Services account that contains the dashboard that you're listing versions for.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, dashboardId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardVersionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains information about each version of the dashboard.
        public let dashboardVersionSummaryList: [DashboardVersionSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardVersionSummaryList: [DashboardVersionSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardVersionSummaryList = dashboardVersionSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardVersionSummaryList = "DashboardVersionSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID of the Amazon Web Services account that contains the dashboards that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the dashboards in your Amazon Web Services account. This structure provides basic information about the dashboards.
        public let dashboardSummaryList: [DashboardSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardSummaryList: [DashboardSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardSummaryList = dashboardSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaryList = "DashboardSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListDataSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of dataset summaries.
        public let dataSetSummaries: [DataSetSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetSummaries: [DataSetSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetSummaries = dataSetSummaries
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetSummaries = "DataSetSummaries"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of data sources.
        public let dataSources: [DataSource]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSources: [DataSource]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSources = dataSources
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "DataSources"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListFolderMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, folderId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFolderMembersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the folder members (dashboards, analyses, and datasets) in the folder.
        public let folderMemberList: [MemberIdArnPair]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderMemberList: [MemberIdArnPair]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderMemberList = folderMemberList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderMemberList = "FolderMemberList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListFoldersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFoldersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
        public let folderSummaryList: [FolderSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderSummaryList: [FolderSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderSummaryList = folderSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderSummaryList = "FolderSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListGroupMembershipsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri("GroupName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to see a membership list of.
        public let groupName: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace of the group that you want a list of users from.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, groupName: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupMembershipsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of the members of the group.
        public let groupMemberList: [GroupMember]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMemberList: [GroupMember]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMemberList = groupMemberList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupMemberList = "GroupMemberList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The namespace that you want a list of groups from.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of the groups.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListIAMPolicyAssignmentsForUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "userName", location: .uri("UserName"))
        ]

        /// The ID of the Amazon Web Services account that contains the assignments.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace of the assignment.
        public let namespace: String
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The name of the user.
        public let userName: String

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIAMPolicyAssignmentsForUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The active assignments for this user.
        public let activeAssignments: [ActiveIAMPolicyAssignment]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(activeAssignments: [ActiveIAMPolicyAssignment]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.activeAssignments = activeAssignments
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case activeAssignments = "ActiveAssignments"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListIAMPolicyAssignmentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The status of the assignments.
        public let assignmentStatus: AssignmentStatus?
        /// The ID of the Amazon Web Services account that contains these IAM policy assignments.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace for the assignments.
        public let namespace: String
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(assignmentStatus: AssignmentStatus? = nil, awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentStatus = "AssignmentStatus"
        }
    }

    public struct ListIAMPolicyAssignmentsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Information describing the IAM policy assignments.
        public let iamPolicyAssignments: [IAMPolicyAssignmentSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(iamPolicyAssignments: [IAMPolicyAssignmentSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.iamPolicyAssignments = iamPolicyAssignments
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case iamPolicyAssignments = "IAMPolicyAssignments"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListIngestionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, dataSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIngestionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of the ingestions.
        public let ingestions: [Ingestion]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(ingestions: [Ingestion]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.ingestions = ingestions
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case ingestions = "Ingestions"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListNamespacesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespaces that you want to list.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A unique pagination token that can be used in a subsequent request. You will receive a pagination token in the response body of a previous ListNameSpaces API call if there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNamespacesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The information about the namespaces in this Amazon Web Services account. The response includes  the namespace ARN, name, Amazon Web Services Region, notification email address, creation status, and  identity store.
        public let namespaces: [NamespaceInfoV2]?
        /// A unique pagination token that can be used in a subsequent request. Receiving NextToken in your response inticates that there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(namespaces: [NamespaceInfoV2]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.namespaces = namespaces
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case namespaces = "Namespaces"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want a list of tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the
        /// 			resource.
        public let tags: [Tag]?

        public init(requestId: String? = nil, status: Int? = nil, tags: [Tag]? = nil) {
            self.requestId = requestId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct ListTemplateAliasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-result")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The ID of the Amazon Web Services account that contains the template aliases that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplateAliasesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing the list of the template's aliases.
        public let templateAliasList: [TemplateAlias]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateAliasList: [TemplateAlias]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateAliasList = templateAliasList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case templateAliasList = "TemplateAliasList"
        }
    }

    public struct ListTemplateVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The ID of the Amazon Web Services account that contains the templates that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplateVersionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing a list of all the versions of the specified template.
        public let templateVersionSummaryList: [TemplateVersionSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateVersionSummaryList: [TemplateVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateVersionSummaryList = templateVersionSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case templateVersionSummaryList = "TemplateVersionSummaryList"
        }
    }

    public struct ListTemplatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-result")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID of the Amazon Web Services account that contains the templates that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplatesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing information about the templates in the list.
        public let templateSummaryList: [TemplateSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateSummaryList: [TemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateSummaryList = templateSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case templateSummaryList = "TemplateSummaryList"
        }
    }

    public struct ListThemeAliasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-result")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The ID of the Amazon Web Services account that contains the theme aliases that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemeAliasesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing the list of the theme's aliases.
        public let themeAliasList: [ThemeAlias]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeAliasList: [ThemeAlias]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeAliasList = themeAliasList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case themeAliasList = "ThemeAliasList"
        }
    }

    public struct ListThemeVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The ID of the Amazon Web Services account that contains the themes that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemeVersionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing a list of all the versions of the specified theme.
        public let themeVersionSummaryList: [ThemeVersionSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeVersionSummaryList: [ThemeVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeVersionSummaryList = themeVersionSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case themeVersionSummaryList = "ThemeVersionSummaryList"
        }
    }

    public struct ListThemesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "type", location: .querystring("type"))
        ]

        /// The ID of the Amazon Web Services account that contains the themes that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The type of themes that you want to list. Valid options include the following:    ALL (default)- Display all existing themes.    CUSTOM - Display only the themes created by people using Amazon QuickSight.    QUICKSIGHT - Display only the starting themes defined by Amazon QuickSight.
        public let type: ThemeType?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, type: ThemeType? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the themes in the list.
        public let themeSummaryList: [ThemeSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeSummaryList: [ThemeSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeSummaryList = themeSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case themeSummaryList = "ThemeSummaryList"
        }
    }

    public struct ListUserGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "userName", location: .uri("UserName"))
        ]

        /// The Amazon Web Services account ID that the user is in. Currently, you use the ID for the Amazon Web Services account
        /// 			that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon QuickSight user name that you want to list group memberships for.
        public let userName: String

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserGroupsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of groups the user is a member of.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The list of users.
        public let userList: [User]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, userList: [User]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.userList = userList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
            case userList = "UserList"
        }
    }

    public struct LoadingAnimation: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of LoadingAnimation.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct LocalNavigationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sheet that is targeted for navigation in the same analysis.
        public let targetSheetId: String

        public init(targetSheetId: String) {
            self.targetSheetId = targetSheetId
        }

        public func validate(name: String) throws {
            try self.validate(self.targetSheetId, name: "targetSheetId", parent: name, max: 512)
            try self.validate(self.targetSheetId, name: "targetSheetId", parent: name, min: 1)
            try self.validate(self.targetSheetId, name: "targetSheetId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetSheetId = "TargetSheetId"
        }
    }

    public struct LogicalTable: AWSEncodableShape & AWSDecodableShape {
        /// A display name for the logical table.
        public let alias: String
        /// Transform operations that act on this logical table.
        public let dataTransforms: [TransformOperation]?
        /// Source of this logical table.
        public let source: LogicalTableSource

        public init(alias: String, dataTransforms: [TransformOperation]? = nil, source: LogicalTableSource) {
            self.alias = alias
            self.dataTransforms = dataTransforms
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 64)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.dataTransforms?.forEach {
                try $0.validate(name: "\(name).dataTransforms[]")
            }
            try self.validate(self.dataTransforms, name: "dataTransforms", parent: name, max: 2048)
            try self.validate(self.dataTransforms, name: "dataTransforms", parent: name, min: 1)
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case dataTransforms = "DataTransforms"
            case source = "Source"
        }
    }

    public struct LogicalTableSource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the parent dataset.
        public let dataSetArn: String?
        /// Specifies the result of a join of two logical tables.
        public let joinInstruction: JoinInstruction?
        /// Physical table ID.
        public let physicalTableId: String?

        public init(dataSetArn: String? = nil, joinInstruction: JoinInstruction? = nil, physicalTableId: String? = nil) {
            self.dataSetArn = dataSetArn
            self.joinInstruction = joinInstruction
            self.physicalTableId = physicalTableId
        }

        public func validate(name: String) throws {
            try self.joinInstruction?.validate(name: "\(name).joinInstruction")
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, max: 64)
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, min: 1)
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, pattern: "^[0-9a-zA-Z-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case joinInstruction = "JoinInstruction"
            case physicalTableId = "PhysicalTableId"
        }
    }

    public struct LongFormatText: AWSEncodableShape & AWSDecodableShape {
        /// Plain text format.
        public let plainText: String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public let richText: String?

        public init(plainText: String? = nil, richText: String? = nil) {
            self.plainText = plainText
            self.richText = richText
        }

        public func validate(name: String) throws {
            try self.validate(self.plainText, name: "plainText", parent: name, max: 1024)
            try self.validate(self.plainText, name: "plainText", parent: name, min: 1)
            try self.validate(self.richText, name: "richText", parent: name, max: 2048)
            try self.validate(self.richText, name: "richText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case plainText = "PlainText"
            case richText = "RichText"
        }
    }

    public struct ManifestFileLocation: AWSEncodableShape & AWSDecodableShape {
        /// Amazon S3 bucket.
        public let bucket: String
        /// Amazon S3 key that identifies an object.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 1024)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct MarginStyle: AWSEncodableShape & AWSDecodableShape {
        /// This Boolean value controls whether to display sheet margins.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct MariaDbParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct MaximumLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the maximum label.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct MaximumMinimumComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The time field that is used in a computation.
        public let time: DimensionField
        /// The type of computation. Choose one of the following options:   MAXIMUM: A maximum computation.   MINIMUM: A minimum computation.
        public let type: MaximumMinimumComputationType
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, time: DimensionField, type: MaximumMinimumComputationType, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.time.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case time = "Time"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct MeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The calculated measure field only used in pivot tables.
        public let calculatedMeasureField: CalculatedMeasureField?
        /// The measure type field with categorical type columns.
        public let categoricalMeasureField: CategoricalMeasureField?
        /// The measure type field with date type columns.
        public let dateMeasureField: DateMeasureField?
        /// The measure type field with numerical type columns.
        public let numericalMeasureField: NumericalMeasureField?

        public init(calculatedMeasureField: CalculatedMeasureField? = nil, categoricalMeasureField: CategoricalMeasureField? = nil, dateMeasureField: DateMeasureField? = nil, numericalMeasureField: NumericalMeasureField? = nil) {
            self.calculatedMeasureField = calculatedMeasureField
            self.categoricalMeasureField = categoricalMeasureField
            self.dateMeasureField = dateMeasureField
            self.numericalMeasureField = numericalMeasureField
        }

        public func validate(name: String) throws {
            try self.calculatedMeasureField?.validate(name: "\(name).calculatedMeasureField")
            try self.categoricalMeasureField?.validate(name: "\(name).categoricalMeasureField")
            try self.dateMeasureField?.validate(name: "\(name).dateMeasureField")
            try self.numericalMeasureField?.validate(name: "\(name).numericalMeasureField")
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedMeasureField = "CalculatedMeasureField"
            case categoricalMeasureField = "CategoricalMeasureField"
            case dateMeasureField = "DateMeasureField"
            case numericalMeasureField = "NumericalMeasureField"
        }
    }

    public struct MemberIdArnPair: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the member.
        public let memberArn: String?
        /// The ID of the member.
        public let memberId: String?

        public init(memberArn: String? = nil, memberId: String? = nil) {
            self.memberArn = memberArn
            self.memberId = memberId
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
            case memberId = "MemberId"
        }
    }

    public struct MetricComparisonComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The field that is used in a metric comparison from value setup.
        public let fromValue: MeasureField
        /// The name of a computation.
        public let name: String?
        /// The field that is used in a metric comparison to value setup.
        public let targetValue: MeasureField
        /// The time field that is used in a computation.
        public let time: DimensionField

        public init(computationId: String, fromValue: MeasureField, name: String? = nil, targetValue: MeasureField, time: DimensionField) {
            self.computationId = computationId
            self.fromValue = fromValue
            self.name = name
            self.targetValue = targetValue
            self.time = time
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.fromValue.validate(name: "\(name).fromValue")
            try self.targetValue.validate(name: "\(name).targetValue")
            try self.time.validate(name: "\(name).time")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case fromValue = "FromValue"
            case name = "Name"
            case targetValue = "TargetValue"
            case time = "Time"
        }
    }

    public struct MinimumLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the minimum label.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct MissingDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The treatment option that determines how missing data should be rendered. Choose from the following options:    INTERPOLATE: Interpolate missing values between the prior and the next known value.    SHOW_AS_ZERO: Show missing values as the value 0.    SHOW_AS_BLANK: Display a blank space when rendering missing data.
        public let treatmentOption: MissingDataTreatmentOption?

        public init(treatmentOption: MissingDataTreatmentOption? = nil) {
            self.treatmentOption = treatmentOption
        }

        private enum CodingKeys: String, CodingKey {
            case treatmentOption = "TreatmentOption"
        }
    }

    public struct MySqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct NamespaceError: AWSDecodableShape {
        /// The message for the error.
        public let message: String?
        /// The error type.
        public let type: NamespaceErrorType?

        public init(message: String? = nil, type: NamespaceErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct NamespaceInfoV2: AWSDecodableShape {
        /// The namespace ARN.
        public let arn: String?
        /// The namespace Amazon Web Services Region.
        public let capacityRegion: String?
        /// The creation status of a namespace that is not yet completely created.
        public let creationStatus: NamespaceStatus?
        /// The identity store used for the namespace.
        public let identityStore: IdentityStore?
        /// The name of the error.
        public let name: String?
        /// An error that occurred when the namespace was created.
        public let namespaceError: NamespaceError?

        public init(arn: String? = nil, capacityRegion: String? = nil, creationStatus: NamespaceStatus? = nil, identityStore: IdentityStore? = nil, name: String? = nil, namespaceError: NamespaceError? = nil) {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.namespaceError = namespaceError
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacityRegion = "CapacityRegion"
            case creationStatus = "CreationStatus"
            case identityStore = "IdentityStore"
            case name = "Name"
            case namespaceError = "NamespaceError"
        }
    }

    public struct NegativeValueConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the display mode of the negative value configuration.
        public let displayMode: NegativeValueDisplayMode

        public init(displayMode: NegativeValueDisplayMode) {
            self.displayMode = displayMode
        }

        private enum CodingKeys: String, CodingKey {
            case displayMode = "DisplayMode"
        }
    }

    public struct NullValueFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the null string of null values.
        public let nullString: String

        public init(nullString: String) {
            self.nullString = nullString
        }

        public func validate(name: String) throws {
            try self.validate(self.nullString, name: "nullString", parent: name, max: 128)
            try self.validate(self.nullString, name: "nullString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nullString = "NullString"
        }
    }

    public struct NumberDisplayFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the decimal places configuration.
        public let decimalPlacesConfiguration: DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public let negativeValueConfiguration: NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// Determines the number scale value of the number format.
        public let numberScale: NumberScale?
        /// Determines the prefix value of the number format.
        public let prefix: String?
        /// The options that determine the numeric separator configuration.
        public let separatorConfiguration: NumericSeparatorConfiguration?
        /// Determines the suffix value of the number format.
        public let suffix: String?

        public init(decimalPlacesConfiguration: DecimalPlacesConfiguration? = nil, negativeValueConfiguration: NegativeValueConfiguration? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numberScale: NumberScale? = nil, prefix: String? = nil, separatorConfiguration: NumericSeparatorConfiguration? = nil, suffix: String? = nil) {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.prefix = prefix
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.decimalPlacesConfiguration?.validate(name: "\(name).decimalPlacesConfiguration")
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 128)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
            case negativeValueConfiguration = "NegativeValueConfiguration"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numberScale = "NumberScale"
            case prefix = "Prefix"
            case separatorConfiguration = "SeparatorConfiguration"
            case suffix = "Suffix"
        }
    }

    public struct NumberFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the numeric format configuration.
        public let formatConfiguration: NumericFormatConfiguration?

        public init(formatConfiguration: NumericFormatConfiguration? = nil) {
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct NumericAxisOptions: AWSEncodableShape & AWSDecodableShape {
        /// The range setup of a numeric axis.
        public let range: AxisDisplayRange?
        /// The scale setup of a numeric axis.
        public let scale: AxisScale?

        public init(range: AxisDisplayRange? = nil, scale: AxisScale? = nil) {
            self.range = range
            self.scale = scale
        }

        private enum CodingKeys: String, CodingKey {
            case range = "Range"
            case scale = "Scale"
        }
    }

    public struct NumericEqualityDrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The value of the double input numeric drill down filter.
        public let value: Double

        public init(column: ColumnIdentifier, value: Double) {
            self.column = column
            self.value = value
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case value = "Value"
        }
    }

    public struct NumericEqualityFilter: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the filter.
        public let aggregationFunction: AggregationFunction?
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: NumericEqualityMatchOperator
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The parameter whose value should be used for the filter value.
        public let parameterName: String?
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: NumericFilterSelectAllOptions?
        /// The input value.
        public let value: Double?

        public init(aggregationFunction: AggregationFunction? = nil, column: ColumnIdentifier, filterId: String, matchOperator: NumericEqualityMatchOperator, nullOption: FilterNullOption, parameterName: String? = nil, selectAllOptions: NumericFilterSelectAllOptions? = nil, value: Double? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.filterId = filterId
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
            self.value = value
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case filterId = "FilterId"
            case matchOperator = "MatchOperator"
            case nullOption = "NullOption"
            case parameterName = "ParameterName"
            case selectAllOptions = "SelectAllOptions"
            case value = "Value"
        }
    }

    public struct NumericFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the currency display format configuration.
        public let currencyDisplayFormatConfiguration: CurrencyDisplayFormatConfiguration?
        /// The options that determine the number display format configuration.
        public let numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration?
        /// The options that determine the percentage display format configuration.
        public let percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration?

        public init(currencyDisplayFormatConfiguration: CurrencyDisplayFormatConfiguration? = nil, numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration? = nil, percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration? = nil) {
            self.currencyDisplayFormatConfiguration = currencyDisplayFormatConfiguration
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.currencyDisplayFormatConfiguration?.validate(name: "\(name).currencyDisplayFormatConfiguration")
            try self.numberDisplayFormatConfiguration?.validate(name: "\(name).numberDisplayFormatConfiguration")
            try self.percentageDisplayFormatConfiguration?.validate(name: "\(name).percentageDisplayFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case currencyDisplayFormatConfiguration = "CurrencyDisplayFormatConfiguration"
            case numberDisplayFormatConfiguration = "NumberDisplayFormatConfiguration"
            case percentageDisplayFormatConfiguration = "PercentageDisplayFormatConfiguration"
        }
    }

    public struct NumericRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the filter.
        public let aggregationFunction: AggregationFunction?
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public let includeMaximum: Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public let includeMinimum: Bool?
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The maximum value for the filter value range.
        public let rangeMaximum: NumericRangeFilterValue?
        /// The minimum value for the filter value range.
        public let rangeMinimum: NumericRangeFilterValue?
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: NumericFilterSelectAllOptions?

        public init(aggregationFunction: AggregationFunction? = nil, column: ColumnIdentifier, filterId: String, includeMaximum: Bool? = nil, includeMinimum: Bool? = nil, nullOption: FilterNullOption, rangeMaximum: NumericRangeFilterValue? = nil, rangeMinimum: NumericRangeFilterValue? = nil, selectAllOptions: NumericFilterSelectAllOptions? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.rangeMaximum?.validate(name: "\(name).rangeMaximum")
            try self.rangeMinimum?.validate(name: "\(name).rangeMinimum")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case filterId = "FilterId"
            case includeMaximum = "IncludeMaximum"
            case includeMinimum = "IncludeMinimum"
            case nullOption = "NullOption"
            case rangeMaximum = "RangeMaximum"
            case rangeMinimum = "RangeMinimum"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct NumericRangeFilterValue: AWSEncodableShape & AWSDecodableShape {
        /// The parameter that is used in the numeric range.
        public let parameter: String?
        /// The static value of the numeric range filter.
        public let staticValue: Double?

        public init(parameter: String? = nil, staticValue: Double? = nil) {
            self.parameter = parameter
            self.staticValue = staticValue
        }

        public func validate(name: String) throws {
            try self.validate(self.parameter, name: "parameter", parent: name, max: 2048)
            try self.validate(self.parameter, name: "parameter", parent: name, min: 1)
            try self.validate(self.parameter, name: "parameter", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parameter = "Parameter"
            case staticValue = "StaticValue"
        }
    }

    public struct NumericSeparatorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the decimal separator.
        public let decimalSeparator: NumericSeparatorSymbol?
        /// The options that determine the thousands separator configuration.
        public let thousandsSeparator: ThousandSeparatorOptions?

        public init(decimalSeparator: NumericSeparatorSymbol? = nil, thousandsSeparator: ThousandSeparatorOptions? = nil) {
            self.decimalSeparator = decimalSeparator
            self.thousandsSeparator = thousandsSeparator
        }

        private enum CodingKeys: String, CodingKey {
            case decimalSeparator = "DecimalSeparator"
            case thousandsSeparator = "ThousandsSeparator"
        }
    }

    public struct NumericalAggregationFunction: AWSEncodableShape & AWSDecodableShape {
        /// An aggregation based on the percentile of values in a dimension or measure.
        public let percentileAggregation: PercentileAggregation?
        /// Built-in aggregation functions for numerical values.    SUM: The sum of a dimension or measure.     AVERAGE: The average of a dimension or measure.    MIN: The minimum value of a dimension or measure.    MAX: The maximum value of a dimension or measure.    COUNT: The count of a dimension or measure.    DISTINCT_COUNT: The count of distinct values in a dimension or measure.    VAR: The variance of a dimension or measure.    VARP: The partitioned variance of a dimension or measure.    STDEV: The standard deviation of a dimension or measure.    STDEVP: The partitioned standard deviation of a dimension or measure.    MEDIAN: The median value of a dimension or measure.
        public let simpleNumericalAggregation: SimpleNumericalAggregationFunction?

        public init(percentileAggregation: PercentileAggregation? = nil, simpleNumericalAggregation: SimpleNumericalAggregationFunction? = nil) {
            self.percentileAggregation = percentileAggregation
            self.simpleNumericalAggregation = simpleNumericalAggregation
        }

        public func validate(name: String) throws {
            try self.percentileAggregation?.validate(name: "\(name).percentileAggregation")
        }

        private enum CodingKeys: String, CodingKey {
            case percentileAggregation = "PercentileAggregation"
            case simpleNumericalAggregation = "SimpleNumericalAggregation"
        }
    }

    public struct NumericalDimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the NumericalDimensionField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: NumberFormatConfiguration?
        /// The custom hierarchy ID.
        public let hierarchyId: String?

        public init(column: ColumnIdentifier, fieldId: String, formatConfiguration: NumberFormatConfiguration? = nil, hierarchyId: String? = nil) {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct NumericalMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the measure field.
        public let aggregationFunction: NumericalAggregationFunction?
        /// The column that is used in the NumericalMeasureField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: NumberFormatConfiguration?

        public init(aggregationFunction: NumericalAggregationFunction? = nil, column: ColumnIdentifier, fieldId: String, formatConfiguration: NumberFormatConfiguration? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct OracleParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// An Oracle host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct OutputColumn: AWSDecodableShape {
        /// A description for a column.
        public let description: String?
        /// A display name for the dataset.
        public let name: String?
        /// Type.
        public let type: ColumnDataType?

        public init(description: String? = nil, name: String? = nil, type: ColumnDataType? = nil) {
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct PaginationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the page number.
        public let pageNumber: Int64
        /// Indicates how many items render in one page.
        public let pageSize: Int64

        public init(pageNumber: Int64, pageSize: Int64) {
            self.pageNumber = pageNumber
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.pageNumber, name: "pageNumber", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "PageNumber"
            case pageSize = "PageSize"
        }
    }

    public struct PanelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Sets the background color for each panel.
        public let backgroundColor: String?
        /// Determines whether or not a background for each small multiples panel is rendered.
        public let backgroundVisibility: Visibility?
        /// Sets the line color of panel borders.
        public let borderColor: String?
        /// Sets the line style of panel borders.
        public let borderStyle: PanelBorderStyle?
        /// Sets the line thickness of panel borders.
        public let borderThickness: String?
        /// Determines whether or not each panel displays a border.
        public let borderVisibility: Visibility?
        /// Sets the total amount of negative space to display between sibling panels.
        public let gutterSpacing: String?
        /// Determines whether or not negative space between sibling panels is rendered.
        public let gutterVisibility: Visibility?
        /// Configures the title display within each small multiples panel.
        public let title: PanelTitleOptions?

        public init(backgroundColor: String? = nil, backgroundVisibility: Visibility? = nil, borderColor: String? = nil, borderStyle: PanelBorderStyle? = nil, borderThickness: String? = nil, borderVisibility: Visibility? = nil, gutterSpacing: String? = nil, gutterVisibility: Visibility? = nil, title: PanelTitleOptions? = nil) {
            self.backgroundColor = backgroundColor
            self.backgroundVisibility = backgroundVisibility
            self.borderColor = borderColor
            self.borderStyle = borderStyle
            self.borderThickness = borderThickness
            self.borderVisibility = borderVisibility
            self.gutterSpacing = gutterSpacing
            self.gutterVisibility = gutterVisibility
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.backgroundColor, name: "backgroundColor", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
            try self.validate(self.borderColor, name: "borderColor", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
            try self.title?.validate(name: "\(name).title")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case backgroundVisibility = "BackgroundVisibility"
            case borderColor = "BorderColor"
            case borderStyle = "BorderStyle"
            case borderThickness = "BorderThickness"
            case borderVisibility = "BorderVisibility"
            case gutterSpacing = "GutterSpacing"
            case gutterVisibility = "GutterVisibility"
            case title = "Title"
        }
    }

    public struct PanelTitleOptions: AWSEncodableShape & AWSDecodableShape {
        public let fontConfiguration: FontConfiguration?
        /// Sets the horizontal text alignment of the title within each panel.
        public let horizontalTextAlignment: HorizontalTextAlignment?
        /// Determines whether or not panel titles are displayed.
        public let visibility: Visibility?

        public init(fontConfiguration: FontConfiguration? = nil, horizontalTextAlignment: HorizontalTextAlignment? = nil, visibility: Visibility? = nil) {
            self.fontConfiguration = fontConfiguration
            self.horizontalTextAlignment = horizontalTextAlignment
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case fontConfiguration = "FontConfiguration"
            case horizontalTextAlignment = "HorizontalTextAlignment"
            case visibility = "Visibility"
        }
    }

    public struct ParameterControl: AWSEncodableShape & AWSDecodableShape {
        /// A control from a date parameter that specifies date and time.
        public let dateTimePicker: ParameterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public let dropdown: ParameterDropDownControl?
        /// A control to display a list with buttons or boxes that are used to select either a single value or multiple values.
        public let list: ParameterListControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public let slider: ParameterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public let textArea: ParameterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public let textField: ParameterTextFieldControl?

        public init(dateTimePicker: ParameterDateTimePickerControl? = nil, dropdown: ParameterDropDownControl? = nil, list: ParameterListControl? = nil, slider: ParameterSliderControl? = nil, textArea: ParameterTextAreaControl? = nil, textField: ParameterTextFieldControl? = nil) {
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.dateTimePicker?.validate(name: "\(name).dateTimePicker")
            try self.dropdown?.validate(name: "\(name).dropdown")
            try self.list?.validate(name: "\(name).list")
            try self.slider?.validate(name: "\(name).slider")
            try self.textArea?.validate(name: "\(name).textArea")
            try self.textField?.validate(name: "\(name).textField")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimePicker = "DateTimePicker"
            case dropdown = "Dropdown"
            case list = "List"
            case slider = "Slider"
            case textArea = "TextArea"
            case textField = "TextField"
        }
    }

    public struct ParameterDateTimePickerControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: DateTimePickerControlDisplayOptions?
        /// The ID of the ParameterDateTimePickerControl.
        public let parameterControlId: String
        /// The name of the ParameterDateTimePickerControl.
        public let sourceParameterName: String
        /// The title of the ParameterDateTimePickerControl.
        public let title: String

        public init(displayOptions: DateTimePickerControlDisplayOptions? = nil, parameterControlId: String, sourceParameterName: String, title: String) {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
        }
    }

    public struct ParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// A parameter declaration for the DateTime data type.
        public let dateTimeParameterDeclaration: DateTimeParameterDeclaration?
        /// A parameter declaration for the Decimal data type.
        public let decimalParameterDeclaration: DecimalParameterDeclaration?
        /// A parameter declaration for the Integer data type.
        public let integerParameterDeclaration: IntegerParameterDeclaration?
        /// A parameter declaration for the String data type.
        public let stringParameterDeclaration: StringParameterDeclaration?

        public init(dateTimeParameterDeclaration: DateTimeParameterDeclaration? = nil, decimalParameterDeclaration: DecimalParameterDeclaration? = nil, integerParameterDeclaration: IntegerParameterDeclaration? = nil, stringParameterDeclaration: StringParameterDeclaration? = nil) {
            self.dateTimeParameterDeclaration = dateTimeParameterDeclaration
            self.decimalParameterDeclaration = decimalParameterDeclaration
            self.integerParameterDeclaration = integerParameterDeclaration
            self.stringParameterDeclaration = stringParameterDeclaration
        }

        public func validate(name: String) throws {
            try self.dateTimeParameterDeclaration?.validate(name: "\(name).dateTimeParameterDeclaration")
            try self.decimalParameterDeclaration?.validate(name: "\(name).decimalParameterDeclaration")
            try self.integerParameterDeclaration?.validate(name: "\(name).integerParameterDeclaration")
            try self.stringParameterDeclaration?.validate(name: "\(name).stringParameterDeclaration")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeParameterDeclaration = "DateTimeParameterDeclaration"
            case decimalParameterDeclaration = "DecimalParameterDeclaration"
            case integerParameterDeclaration = "IntegerParameterDeclaration"
            case stringParameterDeclaration = "StringParameterDeclaration"
        }
    }

    public struct ParameterDropDownControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of a control.
        public let displayOptions: DropDownControlDisplayOptions?
        /// The ID of the ParameterDropDownControl.
        public let parameterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: ParameterSelectableValues?
        /// The source parameter name of the ParameterDropDownControl.
        public let sourceParameterName: String
        /// The title of the ParameterDropDownControl.
        public let title: String
        /// The type parameter name of the ParameterDropDownControl.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: DropDownControlDisplayOptions? = nil, parameterControlId: String, selectableValues: ParameterSelectableValues? = nil, sourceParameterName: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case selectableValues = "SelectableValues"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct ParameterListControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of a control.
        public let displayOptions: ListControlDisplayOptions?
        /// The ID of the ParameterListControl.
        public let parameterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: ParameterSelectableValues?
        /// The source parameter name of the ParameterListControl.
        public let sourceParameterName: String
        /// The title of the ParameterListControl.
        public let title: String
        /// The type of ParameterListControl.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: ListControlDisplayOptions? = nil, parameterControlId: String, selectableValues: ParameterSelectableValues? = nil, sourceParameterName: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case selectableValues = "SelectableValues"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct ParameterSelectableValues: AWSEncodableShape & AWSDecodableShape {
        /// The column identifier that fetches values from the data set.
        public let linkToDataSetColumn: ColumnIdentifier?
        /// The values that are used in ParameterSelectableValues.
        public let values: [String]?

        public init(linkToDataSetColumn: ColumnIdentifier? = nil, values: [String]? = nil) {
            self.linkToDataSetColumn = linkToDataSetColumn
            self.values = values
        }

        public func validate(name: String) throws {
            try self.linkToDataSetColumn?.validate(name: "\(name).linkToDataSetColumn")
            try self.validate(self.values, name: "values", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case linkToDataSetColumn = "LinkToDataSetColumn"
            case values = "Values"
        }
    }

    public struct ParameterSliderControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: SliderControlDisplayOptions?
        /// The smaller value that is displayed at the left of the slider.
        public let maximumValue: Double
        /// The larger value that is displayed at the right of the slider.
        public let minimumValue: Double
        /// The ID of the ParameterSliderControl.
        public let parameterControlId: String
        /// The source parameter name of the ParameterSliderControl.
        public let sourceParameterName: String
        /// The number of increments that the slider bar is divided into.
        public let stepSize: Double
        /// The title of the ParameterSliderControl.
        public let title: String

        public init(displayOptions: SliderControlDisplayOptions? = nil, maximumValue: Double, minimumValue: Double, parameterControlId: String, sourceParameterName: String, stepSize: Double, title: String) {
            self.displayOptions = displayOptions
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.stepSize = stepSize
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case stepSize = "StepSize"
            case title = "Title"
        }
    }

    public struct ParameterTextAreaControl: AWSEncodableShape & AWSDecodableShape {
        /// The delimiter that is used to separate the lines in text.
        public let delimiter: String?
        /// The display options of a control.
        public let displayOptions: TextAreaControlDisplayOptions?
        /// The ID of the ParameterTextAreaControl.
        public let parameterControlId: String
        /// The source parameter name of the ParameterTextAreaControl.
        public let sourceParameterName: String
        /// The title of the ParameterTextAreaControl.
        public let title: String

        public init(delimiter: String? = nil, displayOptions: TextAreaControlDisplayOptions? = nil, parameterControlId: String, sourceParameterName: String, title: String) {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 2048)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
        }
    }

    public struct ParameterTextFieldControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: TextFieldControlDisplayOptions?
        /// The ID of the ParameterTextFieldControl.
        public let parameterControlId: String
        /// The source parameter name of the ParameterTextFieldControl.
        public let sourceParameterName: String
        /// The title of the ParameterTextFieldControl.
        public let title: String

        public init(displayOptions: TextFieldControlDisplayOptions? = nil, parameterControlId: String, sourceParameterName: String, title: String) {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
        }
    }

    public struct Parameters: AWSEncodableShape {
        /// The parameters that have a data type of date-time.
        public let dateTimeParameters: [DateTimeParameter]?
        /// The parameters that have a data type of decimal.
        public let decimalParameters: [DecimalParameter]?
        /// The parameters that have a data type of integer.
        public let integerParameters: [IntegerParameter]?
        /// The parameters that have a data type of string.
        public let stringParameters: [StringParameter]?

        public init(dateTimeParameters: [DateTimeParameter]? = nil, decimalParameters: [DecimalParameter]? = nil, integerParameters: [IntegerParameter]? = nil, stringParameters: [StringParameter]? = nil) {
            self.dateTimeParameters = dateTimeParameters
            self.decimalParameters = decimalParameters
            self.integerParameters = integerParameters
            self.stringParameters = stringParameters
        }

        public func validate(name: String) throws {
            try self.dateTimeParameters?.forEach {
                try $0.validate(name: "\(name).dateTimeParameters[]")
            }
            try self.validate(self.dateTimeParameters, name: "dateTimeParameters", parent: name, max: 100)
            try self.decimalParameters?.forEach {
                try $0.validate(name: "\(name).decimalParameters[]")
            }
            try self.validate(self.decimalParameters, name: "decimalParameters", parent: name, max: 100)
            try self.integerParameters?.forEach {
                try $0.validate(name: "\(name).integerParameters[]")
            }
            try self.validate(self.integerParameters, name: "integerParameters", parent: name, max: 100)
            try self.stringParameters?.forEach {
                try $0.validate(name: "\(name).stringParameters[]")
            }
            try self.validate(self.stringParameters, name: "stringParameters", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeParameters = "DateTimeParameters"
            case decimalParameters = "DecimalParameters"
            case integerParameters = "IntegerParameters"
            case stringParameters = "StringParameters"
        }
    }

    public struct PercentVisibleRange: AWSEncodableShape & AWSDecodableShape {
        /// The lower bound of the range.
        public let from: Double?
        /// The top bound of the range.
        public let to: Double?

        public init(from: Double? = nil, to: Double? = nil) {
            self.from = from
            self.to = to
        }

        public func validate(name: String) throws {
            try self.validate(self.from, name: "from", parent: name, max: 100.0)
            try self.validate(self.from, name: "from", parent: name, min: 0.0)
            try self.validate(self.to, name: "to", parent: name, max: 100.0)
            try self.validate(self.to, name: "to", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct PercentageDisplayFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the decimal places configuration.
        public let decimalPlacesConfiguration: DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public let negativeValueConfiguration: NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// Determines the prefix value of the percentage format.
        public let prefix: String?
        /// The options that determine the numeric separator configuration.
        public let separatorConfiguration: NumericSeparatorConfiguration?
        /// Determines the suffix value of the percentage format.
        public let suffix: String?

        public init(decimalPlacesConfiguration: DecimalPlacesConfiguration? = nil, negativeValueConfiguration: NegativeValueConfiguration? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, prefix: String? = nil, separatorConfiguration: NumericSeparatorConfiguration? = nil, suffix: String? = nil) {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.prefix = prefix
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.decimalPlacesConfiguration?.validate(name: "\(name).decimalPlacesConfiguration")
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 128)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
            case negativeValueConfiguration = "NegativeValueConfiguration"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case prefix = "Prefix"
            case separatorConfiguration = "SeparatorConfiguration"
            case suffix = "Suffix"
        }
    }

    public struct PercentileAggregation: AWSEncodableShape & AWSDecodableShape {
        /// The percentile value. This value can be any numeric constant 0100. A percentile value of 50 computes the median value of the measure.
        public let percentileValue: Double?

        public init(percentileValue: Double? = nil) {
            self.percentileValue = percentileValue
        }

        public func validate(name: String) throws {
            try self.validate(self.percentileValue, name: "percentileValue", parent: name, max: 100.0)
            try self.validate(self.percentileValue, name: "percentileValue", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case percentileValue = "PercentileValue"
        }
    }

    public struct PeriodOverPeriodComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The time field that is used in a computation.
        public let time: DimensionField
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, time: DimensionField, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.time.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case time = "Time"
            case value = "Value"
        }
    }

    public struct PeriodToDateComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The time granularity setup of period to date computation. Choose from the following options:   YEAR: Year to date.   MONTH: Month to date.
        public let periodTimeGranularity: TimeGranularity?
        /// The time field that is used in a computation.
        public let time: DimensionField
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, periodTimeGranularity: TimeGranularity? = nil, time: DimensionField, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.periodTimeGranularity = periodTimeGranularity
            self.time = time
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.time.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case periodTimeGranularity = "PeriodTimeGranularity"
            case time = "Time"
            case value = "Value"
        }
    }

    public struct PieChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category (group/color) field wells of a pie chart.
        public let category: [DimensionField]?
        /// The small multiples field well of a pie chart.
        public let smallMultiples: [DimensionField]?
        /// The value field wells of a pie chart. Values are aggregated based on categories.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, smallMultiples: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.smallMultiples = smallMultiples
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.smallMultiples?.forEach {
                try $0.validate(name: "\(name).smallMultiples[]")
            }
            try self.validate(self.smallMultiples, name: "smallMultiples", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case smallMultiples = "SmallMultiples"
            case values = "Values"
        }
    }

    public struct PieChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options of the group/color that is displayed in a pie chart.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public let contributionAnalysisDefaults: [ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.
        public let donutOptions: DonutOptions?
        /// The field wells of the visual.
        public let fieldWells: PieChartFieldWells?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The small multiples setup for the visual.
        public let smallMultiplesOptions: SmallMultiplesOptions?
        /// The sort configuration of a pie chart.
        public let sortConfiguration: PieChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The label options for the value that is displayed in a pie chart.
        public let valueLabelOptions: ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(categoryLabelOptions: ChartAxisLabelOptions? = nil, contributionAnalysisDefaults: [ContributionAnalysisDefault]? = nil, dataLabels: DataLabelOptions? = nil, donutOptions: DonutOptions? = nil, fieldWells: PieChartFieldWells? = nil, legend: LegendOptions? = nil, smallMultiplesOptions: SmallMultiplesOptions? = nil, sortConfiguration: PieChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, valueLabelOptions: ChartAxisLabelOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.categoryLabelOptions = categoryLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.donutOptions = donutOptions
            self.fieldWells = fieldWells
            self.legend = legend
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.contributionAnalysisDefaults?.forEach {
                try $0.validate(name: "\(name).contributionAnalysisDefaults[]")
            }
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, max: 200)
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, min: 1)
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.smallMultiplesOptions?.validate(name: "\(name).smallMultiplesOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.valueLabelOptions?.validate(name: "\(name).valueLabelOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelOptions = "CategoryLabelOptions"
            case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
            case dataLabels = "DataLabels"
            case donutOptions = "DonutOptions"
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case smallMultiplesOptions = "SmallMultiplesOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case valueLabelOptions = "ValueLabelOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct PieChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a pie chart.
        public let pieChartAggregatedFieldWells: PieChartAggregatedFieldWells?

        public init(pieChartAggregatedFieldWells: PieChartAggregatedFieldWells? = nil) {
            self.pieChartAggregatedFieldWells = pieChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.pieChartAggregatedFieldWells?.validate(name: "\(name).pieChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case pieChartAggregatedFieldWells = "PieChartAggregatedFieldWells"
        }
    }

    public struct PieChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories that are displayed in a pie chart.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public let smallMultiplesLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public let smallMultiplesSort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, smallMultiplesLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.smallMultiplesSort?.forEach {
                try $0.validate(name: "\(name).smallMultiplesSort[]")
            }
            try self.validate(self.smallMultiplesSort, name: "smallMultiplesSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
            case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
            case smallMultiplesSort = "SmallMultiplesSort"
        }
    }

    public struct PieChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a pie chart.
        public let chartConfiguration: PieChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: PieChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct PivotFieldSortOptions: AWSEncodableShape & AWSDecodableShape {
        /// The field ID for the field sort options.
        public let fieldId: String
        /// The sort by field for the field sort options.
        public let sortBy: PivotTableSortBy

        public init(fieldId: String, sortBy: PivotTableSortBy) {
            self.fieldId = fieldId
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.sortBy.validate(name: "\(name).sortBy")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case sortBy = "SortBy"
        }
    }

    public struct PivotTableAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The columns field well for a pivot table. Values are grouped by columns fields.
        public let columns: [DimensionField]?
        /// The rows field well for a pivot table. Values are grouped by rows fields.
        public let rows: [DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on rows and columns fields.
        public let values: [MeasureField]?

        public init(columns: [DimensionField]? = nil, rows: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.columns = columns
            self.rows = rows
            self.values = values
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 20)
            try self.rows?.forEach {
                try $0.validate(name: "\(name).rows[]")
            }
            try self.validate(self.rows, name: "rows", parent: name, max: 20)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case rows = "Rows"
            case values = "Values"
        }
    }

    public struct PivotTableCellConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the cell for conditional formatting.
        public let fieldId: String
        /// The scope of the cell for conditional formatting.
        public let scope: PivotTableConditionalFormattingScope?
        /// The text format of the cell for conditional formatting.
        public let textFormat: TextConditionalFormat?

        public init(fieldId: String, scope: PivotTableConditionalFormattingScope? = nil, textFormat: TextConditionalFormat? = nil) {
            self.fieldId = fieldId
            self.scope = scope
            self.textFormat = textFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.textFormat?.validate(name: "\(name).textFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case scope = "Scope"
            case textFormat = "TextFormat"
        }
    }

    public struct PivotTableConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options for a PivotTableVisual.
        public let conditionalFormattingOptions: [PivotTableConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [PivotTableConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct PivotTableConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The cell conditional formatting option for a pivot table.
        public let cell: PivotTableCellConditionalFormatting?

        public init(cell: PivotTableCellConditionalFormatting? = nil) {
            self.cell = cell
        }

        public func validate(name: String) throws {
            try self.cell?.validate(name: "\(name).cell")
        }

        private enum CodingKeys: String, CodingKey {
            case cell = "Cell"
        }
    }

    public struct PivotTableConditionalFormattingScope: AWSEncodableShape & AWSDecodableShape {
        /// The role (field, field total, grand total) of the cell for conditional formatting.
        public let role: PivotTableConditionalFormattingScopeRole?

        public init(role: PivotTableConditionalFormattingScopeRole? = nil) {
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case role = "Role"
        }
    }

    public struct PivotTableConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field options for a pivot table visual.
        public let fieldOptions: PivotTableFieldOptions?
        /// The field wells of the visual.
        public let fieldWells: PivotTableFieldWells?
        /// The paginated report options for a pivot table visual.
        public let paginatedReportOptions: PivotTablePaginatedReportOptions?
        /// The sort configuration for a PivotTableVisual.
        public let sortConfiguration: PivotTableSortConfiguration?
        /// The table options for a pivot table visual.
        public let tableOptions: PivotTableOptions?
        /// The total options for a pivot table visual.
        public let totalOptions: PivotTableTotalOptions?

        public init(fieldOptions: PivotTableFieldOptions? = nil, fieldWells: PivotTableFieldWells? = nil, paginatedReportOptions: PivotTablePaginatedReportOptions? = nil, sortConfiguration: PivotTableSortConfiguration? = nil, tableOptions: PivotTableOptions? = nil, totalOptions: PivotTableTotalOptions? = nil) {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }

        public func validate(name: String) throws {
            try self.fieldOptions?.validate(name: "\(name).fieldOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tableOptions?.validate(name: "\(name).tableOptions")
            try self.totalOptions?.validate(name: "\(name).totalOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldOptions = "FieldOptions"
            case fieldWells = "FieldWells"
            case paginatedReportOptions = "PaginatedReportOptions"
            case sortConfiguration = "SortConfiguration"
            case tableOptions = "TableOptions"
            case totalOptions = "TotalOptions"
        }
    }

    public struct PivotTableDataPathOption: AWSEncodableShape & AWSDecodableShape {
        /// The list of data path values for the data path options.
        public let dataPathList: [DataPathValue]
        /// The width of the data path option.
        public let width: String?

        public init(dataPathList: [DataPathValue], width: String? = nil) {
            self.dataPathList = dataPathList
            self.width = width
        }

        public func validate(name: String) throws {
            try self.dataPathList.forEach {
                try $0.validate(name: "\(name).dataPathList[]")
            }
            try self.validate(self.dataPathList, name: "dataPathList", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case dataPathList = "DataPathList"
            case width = "Width"
        }
    }

    public struct PivotTableFieldOption: AWSEncodableShape & AWSDecodableShape {
        /// The custom label of the pivot table field.
        public let customLabel: String?
        /// The field ID of the pivot table field.
        public let fieldId: String
        /// The visibility of the pivot table field.
        public let visibility: Visibility?

        public init(customLabel: String? = nil, fieldId: String, visibility: Visibility? = nil) {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.customLabel, name: "customLabel", parent: name, max: 2048)
            try self.validate(self.customLabel, name: "customLabel", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fieldId = "FieldId"
            case visibility = "Visibility"
        }
    }

    public struct PivotTableFieldOptions: AWSEncodableShape & AWSDecodableShape {
        /// The data path options for the pivot table field options.
        public let dataPathOptions: [PivotTableDataPathOption]?
        /// The selected field options for the pivot table field options.
        public let selectedFieldOptions: [PivotTableFieldOption]?

        public init(dataPathOptions: [PivotTableDataPathOption]? = nil, selectedFieldOptions: [PivotTableFieldOption]? = nil) {
            self.dataPathOptions = dataPathOptions
            self.selectedFieldOptions = selectedFieldOptions
        }

        public func validate(name: String) throws {
            try self.dataPathOptions?.forEach {
                try $0.validate(name: "\(name).dataPathOptions[]")
            }
            try self.validate(self.dataPathOptions, name: "dataPathOptions", parent: name, max: 100)
            try self.selectedFieldOptions?.forEach {
                try $0.validate(name: "\(name).selectedFieldOptions[]")
            }
            try self.validate(self.selectedFieldOptions, name: "selectedFieldOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case dataPathOptions = "DataPathOptions"
            case selectedFieldOptions = "SelectedFieldOptions"
        }
    }

    public struct PivotTableFieldSubtotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the subtotal options.
        public let fieldId: String?

        public init(fieldId: String? = nil) {
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
        }
    }

    public struct PivotTableFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well for the pivot table.
        public let pivotTableAggregatedFieldWells: PivotTableAggregatedFieldWells?

        public init(pivotTableAggregatedFieldWells: PivotTableAggregatedFieldWells? = nil) {
            self.pivotTableAggregatedFieldWells = pivotTableAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.pivotTableAggregatedFieldWells?.validate(name: "\(name).pivotTableAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case pivotTableAggregatedFieldWells = "PivotTableAggregatedFieldWells"
        }
    }

    public struct PivotTableOptions: AWSEncodableShape & AWSDecodableShape {
        /// The table cell style of cells.
        public let cellStyle: TableCellStyle?
        /// The table cell style of the column header.
        public let columnHeaderStyle: TableCellStyle?
        /// The visibility of the column names.
        public let columnNamesVisibility: Visibility?
        /// The metric placement (row, column) options.
        public let metricPlacement: PivotTableMetricPlacement?
        /// The row alternate color options (widget status, row alternate colors).
        public let rowAlternateColorOptions: RowAlternateColorOptions?
        /// The table cell style of row field names.
        public let rowFieldNamesStyle: TableCellStyle?
        /// The table cell style of the row headers.
        public let rowHeaderStyle: TableCellStyle?
        /// The visibility of the single metric options.
        public let singleMetricVisibility: Visibility?
        /// Determines the visibility of the pivot table.
        public let toggleButtonsVisibility: Visibility?

        public init(cellStyle: TableCellStyle? = nil, columnHeaderStyle: TableCellStyle? = nil, columnNamesVisibility: Visibility? = nil, metricPlacement: PivotTableMetricPlacement? = nil, rowAlternateColorOptions: RowAlternateColorOptions? = nil, rowFieldNamesStyle: TableCellStyle? = nil, rowHeaderStyle: TableCellStyle? = nil, singleMetricVisibility: Visibility? = nil, toggleButtonsVisibility: Visibility? = nil) {
            self.cellStyle = cellStyle
            self.columnHeaderStyle = columnHeaderStyle
            self.columnNamesVisibility = columnNamesVisibility
            self.metricPlacement = metricPlacement
            self.rowAlternateColorOptions = rowAlternateColorOptions
            self.rowFieldNamesStyle = rowFieldNamesStyle
            self.rowHeaderStyle = rowHeaderStyle
            self.singleMetricVisibility = singleMetricVisibility
            self.toggleButtonsVisibility = toggleButtonsVisibility
        }

        public func validate(name: String) throws {
            try self.cellStyle?.validate(name: "\(name).cellStyle")
            try self.columnHeaderStyle?.validate(name: "\(name).columnHeaderStyle")
            try self.rowAlternateColorOptions?.validate(name: "\(name).rowAlternateColorOptions")
            try self.rowFieldNamesStyle?.validate(name: "\(name).rowFieldNamesStyle")
            try self.rowHeaderStyle?.validate(name: "\(name).rowHeaderStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case cellStyle = "CellStyle"
            case columnHeaderStyle = "ColumnHeaderStyle"
            case columnNamesVisibility = "ColumnNamesVisibility"
            case metricPlacement = "MetricPlacement"
            case rowAlternateColorOptions = "RowAlternateColorOptions"
            case rowFieldNamesStyle = "RowFieldNamesStyle"
            case rowHeaderStyle = "RowHeaderStyle"
            case singleMetricVisibility = "SingleMetricVisibility"
            case toggleButtonsVisibility = "ToggleButtonsVisibility"
        }
    }

    public struct PivotTablePaginatedReportOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the repeating header rows on each page.
        public let overflowColumnHeaderVisibility: Visibility?
        /// The visibility of the printing table overflow across pages.
        public let verticalOverflowVisibility: Visibility?

        public init(overflowColumnHeaderVisibility: Visibility? = nil, verticalOverflowVisibility: Visibility? = nil) {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case overflowColumnHeaderVisibility = "OverflowColumnHeaderVisibility"
            case verticalOverflowVisibility = "VerticalOverflowVisibility"
        }
    }

    public struct PivotTableSortBy: AWSEncodableShape & AWSDecodableShape {
        /// The column sort (field id, direction) for the pivot table sort by options.
        public let column: ColumnSort?
        /// The data path sort (data path value, direction) for the pivot table sort by options.
        public let dataPath: DataPathSort?
        /// The field sort (field id, direction) for the pivot table sort by options.
        public let field: FieldSort?

        public init(column: ColumnSort? = nil, dataPath: DataPathSort? = nil, field: FieldSort? = nil) {
            self.column = column
            self.dataPath = dataPath
            self.field = field
        }

        public func validate(name: String) throws {
            try self.column?.validate(name: "\(name).column")
            try self.dataPath?.validate(name: "\(name).dataPath")
            try self.field?.validate(name: "\(name).field")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case dataPath = "DataPath"
            case field = "Field"
        }
    }

    public struct PivotTableSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field sort options for a pivot table sort configuration.
        public let fieldSortOptions: [PivotFieldSortOptions]?

        public init(fieldSortOptions: [PivotFieldSortOptions]? = nil) {
            self.fieldSortOptions = fieldSortOptions
        }

        public func validate(name: String) throws {
            try self.fieldSortOptions?.forEach {
                try $0.validate(name: "\(name).fieldSortOptions[]")
            }
            try self.validate(self.fieldSortOptions, name: "fieldSortOptions", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldSortOptions = "FieldSortOptions"
        }
    }

    public struct PivotTableTotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The column subtotal options.
        public let columnSubtotalOptions: SubtotalOptions?
        /// The column total options.
        public let columnTotalOptions: PivotTotalOptions?
        /// The row subtotal options.
        public let rowSubtotalOptions: SubtotalOptions?
        /// The row total options.
        public let rowTotalOptions: PivotTotalOptions?

        public init(columnSubtotalOptions: SubtotalOptions? = nil, columnTotalOptions: PivotTotalOptions? = nil, rowSubtotalOptions: SubtotalOptions? = nil, rowTotalOptions: PivotTotalOptions? = nil) {
            self.columnSubtotalOptions = columnSubtotalOptions
            self.columnTotalOptions = columnTotalOptions
            self.rowSubtotalOptions = rowSubtotalOptions
            self.rowTotalOptions = rowTotalOptions
        }

        public func validate(name: String) throws {
            try self.columnSubtotalOptions?.validate(name: "\(name).columnSubtotalOptions")
            try self.columnTotalOptions?.validate(name: "\(name).columnTotalOptions")
            try self.rowSubtotalOptions?.validate(name: "\(name).rowSubtotalOptions")
            try self.rowTotalOptions?.validate(name: "\(name).rowTotalOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case columnSubtotalOptions = "ColumnSubtotalOptions"
            case columnTotalOptions = "ColumnTotalOptions"
            case rowSubtotalOptions = "RowSubtotalOptions"
            case rowTotalOptions = "RowTotalOptions"
        }
    }

    public struct PivotTableVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: PivotTableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public let conditionalFormatting: PivotTableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: PivotTableConfiguration? = nil, conditionalFormatting: PivotTableConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct PivotTotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The custom label string for the total cells.
        public let customLabel: String?
        /// The cell styling options for the total of header cells.
        public let metricHeaderCellStyle: TableCellStyle?
        /// The placement (start, end) for the total cells.
        public let placement: TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public let scrollStatus: TableTotalsScrollStatus?
        /// The cell styling options for the total cells.
        public let totalCellStyle: TableCellStyle?
        /// The visibility configuration for the total cells.
        public let totalsVisibility: Visibility?
        /// The cell styling options for the totals of value cells.
        public let valueCellStyle: TableCellStyle?

        public init(customLabel: String? = nil, metricHeaderCellStyle: TableCellStyle? = nil, placement: TableTotalsPlacement? = nil, scrollStatus: TableTotalsScrollStatus? = nil, totalCellStyle: TableCellStyle? = nil, totalsVisibility: Visibility? = nil, valueCellStyle: TableCellStyle? = nil) {
            self.customLabel = customLabel
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }

        public func validate(name: String) throws {
            try self.metricHeaderCellStyle?.validate(name: "\(name).metricHeaderCellStyle")
            try self.totalCellStyle?.validate(name: "\(name).totalCellStyle")
            try self.valueCellStyle?.validate(name: "\(name).valueCellStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case metricHeaderCellStyle = "MetricHeaderCellStyle"
            case placement = "Placement"
            case scrollStatus = "ScrollStatus"
            case totalCellStyle = "TotalCellStyle"
            case totalsVisibility = "TotalsVisibility"
            case valueCellStyle = "ValueCellStyle"
        }
    }

    public struct PostgreSqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct PredefinedHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The list of columns that define the predefined hierarchy.
        public let columns: [ColumnIdentifier]
        /// The option that determines the drill down filters for the predefined hierarchy.
        public let drillDownFilters: [DrillDownFilter]?
        /// The hierarchy ID of the predefined hierarchy.
        public let hierarchyId: String

        public init(columns: [ColumnIdentifier], drillDownFilters: [DrillDownFilter]? = nil, hierarchyId: String) {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 10)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.drillDownFilters?.forEach {
                try $0.validate(name: "\(name).drillDownFilters[]")
            }
            try self.validate(self.drillDownFilters, name: "drillDownFilters", parent: name, max: 10)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case drillDownFilters = "DrillDownFilters"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct PrestoParameters: AWSEncodableShape & AWSDecodableShape {
        /// Catalog.
        public let catalog: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(catalog: String, host: String, port: Int) {
            self.catalog = catalog
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 128)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct ProgressBarOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the progress bar.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct ProjectOperation: AWSEncodableShape & AWSDecodableShape {
        /// Projected columns.
        public let projectedColumns: [String]

        public init(projectedColumns: [String]) {
            self.projectedColumns = projectedColumns
        }

        public func validate(name: String) throws {
            try self.validate(self.projectedColumns, name: "projectedColumns", parent: name, max: 2000)
            try self.validate(self.projectedColumns, name: "projectedColumns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case projectedColumns = "ProjectedColumns"
        }
    }

    public struct QueueInfo: AWSDecodableShape {
        /// The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.
        public let queuedIngestion: String
        /// The ID of the queued ingestion.
        public let waitingOnIngestion: String

        public init(queuedIngestion: String, waitingOnIngestion: String) {
            self.queuedIngestion = queuedIngestion
            self.waitingOnIngestion = waitingOnIngestion
        }

        private enum CodingKeys: String, CodingKey {
            case queuedIngestion = "QueuedIngestion"
            case waitingOnIngestion = "WaitingOnIngestion"
        }
    }

    public struct RangeEndsLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the range ends label.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct RdsParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Instance ID.
        public let instanceId: String

        public init(database: String, instanceId: String) {
            self.database = database
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 64)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case instanceId = "InstanceId"
        }
    }

    public struct RedshiftParameters: AWSEncodableShape & AWSDecodableShape {
        /// Cluster ID. This field can be blank if the Host and Port are provided.
        public let clusterId: String?
        /// Database.
        public let database: String
        /// Host. This field can be blank if ClusterId is provided.
        public let host: String?
        /// Port. This field can be blank if the ClusterId is provided.
        public let port: Int?

        public init(clusterId: String? = nil, database: String, host: String? = nil, port: Int? = nil) {
            self.clusterId = clusterId
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 64)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 1)
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct ReferenceLine: AWSEncodableShape & AWSDecodableShape {
        /// The data configuration of the reference line.
        public let dataConfiguration: ReferenceLineDataConfiguration
        /// The label configuration of the reference line.
        public let labelConfiguration: ReferenceLineLabelConfiguration?
        /// The status of the reference line. Choose one of the following options:    ENABLE     DISABLE
        public let status: WidgetStatus?
        /// The style configuration of the reference line.
        public let styleConfiguration: ReferenceLineStyleConfiguration?

        public init(dataConfiguration: ReferenceLineDataConfiguration, labelConfiguration: ReferenceLineLabelConfiguration? = nil, status: WidgetStatus? = nil, styleConfiguration: ReferenceLineStyleConfiguration? = nil) {
            self.dataConfiguration = dataConfiguration
            self.labelConfiguration = labelConfiguration
            self.status = status
            self.styleConfiguration = styleConfiguration
        }

        public func validate(name: String) throws {
            try self.dataConfiguration.validate(name: "\(name).dataConfiguration")
            try self.labelConfiguration?.validate(name: "\(name).labelConfiguration")
            try self.styleConfiguration?.validate(name: "\(name).styleConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataConfiguration = "DataConfiguration"
            case labelConfiguration = "LabelConfiguration"
            case status = "Status"
            case styleConfiguration = "StyleConfiguration"
        }
    }

    public struct ReferenceLineCustomLabelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The string text of the custom label.
        public let customLabel: String

        public init(customLabel: String) {
            self.customLabel = customLabel
        }

        public func validate(name: String) throws {
            try self.validate(self.customLabel, name: "customLabel", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
        }
    }

    public struct ReferenceLineDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The axis binding type of the reference line. Choose one of the following options:   PrimaryY   SecondaryY
        public let axisBinding: AxisBinding?
        /// The dynamic configuration of the reference line data configuration.
        public let dynamicConfiguration: ReferenceLineDynamicDataConfiguration?
        /// The static data configuration of the reference line data configuration.
        public let staticConfiguration: ReferenceLineStaticDataConfiguration?

        public init(axisBinding: AxisBinding? = nil, dynamicConfiguration: ReferenceLineDynamicDataConfiguration? = nil, staticConfiguration: ReferenceLineStaticDataConfiguration? = nil) {
            self.axisBinding = axisBinding
            self.dynamicConfiguration = dynamicConfiguration
            self.staticConfiguration = staticConfiguration
        }

        public func validate(name: String) throws {
            try self.dynamicConfiguration?.validate(name: "\(name).dynamicConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case dynamicConfiguration = "DynamicConfiguration"
            case staticConfiguration = "StaticConfiguration"
        }
    }

    public struct ReferenceLineDynamicDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The calculation that is used in the dynamic data.
        public let calculation: NumericalAggregationFunction
        /// The column that the dynamic data targets.
        public let column: ColumnIdentifier
        /// The aggregation function that is used in the dynamic data.
        public let measureAggregationFunction: AggregationFunction

        public init(calculation: NumericalAggregationFunction, column: ColumnIdentifier, measureAggregationFunction: AggregationFunction) {
            self.calculation = calculation
            self.column = column
            self.measureAggregationFunction = measureAggregationFunction
        }

        public func validate(name: String) throws {
            try self.calculation.validate(name: "\(name).calculation")
            try self.column.validate(name: "\(name).column")
            try self.measureAggregationFunction.validate(name: "\(name).measureAggregationFunction")
        }

        private enum CodingKeys: String, CodingKey {
            case calculation = "Calculation"
            case column = "Column"
            case measureAggregationFunction = "MeasureAggregationFunction"
        }
    }

    public struct ReferenceLineLabelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The custom label configuration of the label in a reference line.
        public let customLabelConfiguration: ReferenceLineCustomLabelConfiguration?
        /// The font color configuration of the label in a reference line.
        public let fontColor: String?
        /// The font configuration of the label in a reference line.
        public let fontConfiguration: FontConfiguration?
        /// The horizontal position configuration of the label in a reference line. Choose one of the following options:    LEFT     CENTER     RIGHT
        public let horizontalPosition: ReferenceLineLabelHorizontalPosition?
        /// The value label configuration of the label in a reference line.
        public let valueLabelConfiguration: ReferenceLineValueLabelConfiguration?
        /// The vertical position configuration of the label in a reference line. Choose one of the following options:    ABOVE     BELOW
        public let verticalPosition: ReferenceLineLabelVerticalPosition?

        public init(customLabelConfiguration: ReferenceLineCustomLabelConfiguration? = nil, fontColor: String? = nil, fontConfiguration: FontConfiguration? = nil, horizontalPosition: ReferenceLineLabelHorizontalPosition? = nil, valueLabelConfiguration: ReferenceLineValueLabelConfiguration? = nil, verticalPosition: ReferenceLineLabelVerticalPosition? = nil) {
            self.customLabelConfiguration = customLabelConfiguration
            self.fontColor = fontColor
            self.fontConfiguration = fontConfiguration
            self.horizontalPosition = horizontalPosition
            self.valueLabelConfiguration = valueLabelConfiguration
            self.verticalPosition = verticalPosition
        }

        public func validate(name: String) throws {
            try self.customLabelConfiguration?.validate(name: "\(name).customLabelConfiguration")
            try self.validate(self.fontColor, name: "fontColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
            try self.valueLabelConfiguration?.validate(name: "\(name).valueLabelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabelConfiguration = "CustomLabelConfiguration"
            case fontColor = "FontColor"
            case fontConfiguration = "FontConfiguration"
            case horizontalPosition = "HorizontalPosition"
            case valueLabelConfiguration = "ValueLabelConfiguration"
            case verticalPosition = "VerticalPosition"
        }
    }

    public struct ReferenceLineStaticDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The double input of the static data.
        public let value: Double

        public init(value: Double) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct ReferenceLineStyleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The hex color of the reference line.
        public let color: String?
        /// The pattern type of the line style. Choose one of the following options:    SOLID     DASHED     DOTTED
        public let pattern: ReferenceLinePatternType?

        public init(color: String? = nil, pattern: ReferenceLinePatternType? = nil) {
            self.color = color
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case pattern = "Pattern"
        }
    }

    public struct ReferenceLineValueLabelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The format configuration of the value label.
        public let formatConfiguration: NumericFormatConfiguration?
        /// The relative position of the value label. Choose one of the following options:    BEFORE_CUSTOM_LABEL     AFTER_CUSTOM_LABEL
        public let relativePosition: ReferenceLineValueLabelRelativePosition?

        public init(formatConfiguration: NumericFormatConfiguration? = nil, relativePosition: ReferenceLineValueLabelRelativePosition? = nil) {
            self.formatConfiguration = formatConfiguration
            self.relativePosition = relativePosition
        }

        public func validate(name: String) throws {
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case formatConfiguration = "FormatConfiguration"
            case relativePosition = "RelativePosition"
        }
    }

    public struct RegisterUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
        public let customFederationProviderUrl: String?
        /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:   Create and update data sources   Create and update datasets   Create and update email reports   Subscribe to email reports   To add custom permissions to an existing user, use  UpdateUser instead. A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user.  Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
        public let customPermissionsName: String?
        /// The email address of the user that you want to register.
        public let email: String
        /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
        public let externalLoginFederationProviderType: String?
        /// The identity ID for a user in the external login provider.
        public let externalLoginId: String?
        /// The ARN of the IAM user or role that you are registering with Amazon QuickSight.
        public let iamArn: String?
        /// Amazon QuickSight supports several ways of managing the identity of users. This
        /// 			parameter accepts two values:    IAM: A user whose identity maps to an existing IAM user or role.
        /// 				    QUICKSIGHT: A user whose identity is owned and managed internally by
        /// 					Amazon QuickSight.
        public let identityType: IdentityType
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// You need to use this parameter only when you register one or more users using an assumed
        /// 			IAM role. You don't need to provide the session name for other scenarios, for example when
        /// 			you are registering an IAM user or an Amazon QuickSight user. You can register multiple
        /// 			users using the same IAM role if each user has a different session name. For more
        /// 			information on assuming IAM roles, see  assume-role in the CLI Reference.
        public let sessionName: String?
        /// The Amazon QuickSight user name that you want to create for the user you are
        /// 			registering.
        public let userName: String?
        /// The Amazon QuickSight role for the user. The user role can be one of the
        /// 			following:    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and
        /// 					dashboards.    ADMIN: A user who is an author, who can also manage Amazon QuickSight
        /// 					settings.    RESTRICTED_READER: This role isn't currently available for
        /// 					use.    RESTRICTED_AUTHOR: This role isn't currently available for
        /// 					use.
        public let userRole: UserRole

        public init(awsAccountId: String, customFederationProviderUrl: String? = nil, customPermissionsName: String? = nil, email: String, externalLoginFederationProviderType: String? = nil, externalLoginId: String? = nil, iamArn: String? = nil, identityType: IdentityType, namespace: String, sessionName: String? = nil, userName: String? = nil, userRole: UserRole) {
            self.awsAccountId = awsAccountId
            self.customFederationProviderUrl = customFederationProviderUrl
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginId = externalLoginId
            self.iamArn = iamArn
            self.identityType = identityType
            self.namespace = namespace
            self.sessionName = sessionName
            self.userName = userName
            self.userRole = userRole
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, max: 64)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, min: 1)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, pattern: "^[a-zA-Z0-9+=,.@_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionName, name: "sessionName", parent: name, max: 64)
            try self.validate(self.sessionName, name: "sessionName", parent: name, min: 2)
            try self.validate(self.sessionName, name: "sessionName", parent: name, pattern: "^[\\w+=.@-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customFederationProviderUrl = "CustomFederationProviderUrl"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginId = "ExternalLoginId"
            case iamArn = "IamArn"
            case identityType = "IdentityType"
            case sessionName = "SessionName"
            case userName = "UserName"
            case userRole = "UserRole"
        }
    }

    public struct RegisterUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The user's user name.
        public let user: User?
        /// The URL the user visits to complete registration and provide a password. This is
        /// 			returned only for users with an identity type of QUICKSIGHT.
        public let userInvitationUrl: String?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil, userInvitationUrl: String? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
            self.userInvitationUrl = userInvitationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case user = "User"
            case userInvitationUrl = "UserInvitationUrl"
        }
    }

    public struct RegisteredUserDashboardEmbeddingConfiguration: AWSEncodableShape {
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it. If the user does not have permission to view this dashboard, they see a permissions error message.
        public let initialDashboardId: String

        public init(initialDashboardId: String) {
            self.initialDashboardId = initialDashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, max: 512)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, min: 1)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initialDashboardId = "InitialDashboardId"
        }
    }

    public struct RegisteredUserDashboardVisualEmbeddingConfiguration: AWSEncodableShape {
        /// The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialDashboardVisualId: DashboardVisualId

        public init(initialDashboardVisualId: DashboardVisualId) {
            self.initialDashboardVisualId = initialDashboardVisualId
        }

        public func validate(name: String) throws {
            try self.initialDashboardVisualId.validate(name: "\(name).initialDashboardVisualId")
        }

        private enum CodingKeys: String, CodingKey {
            case initialDashboardVisualId = "InitialDashboardVisualId"
        }
    }

    public struct RegisteredUserEmbeddingExperienceConfiguration: AWSEncodableShape {
        /// The configuration details for providing a dashboard embedding experience.
        public let dashboard: RegisteredUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public let dashboardVisual: RegisteredUserDashboardVisualEmbeddingConfiguration?
        /// The configuration details for embedding the Q search bar. For more information about embedding the Q search bar, see Embedding Overview in the Amazon QuickSight User Guide.
        public let qSearchBar: RegisteredUserQSearchBarEmbeddingConfiguration?
        /// The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see Customizing Access to the Amazon QuickSight Console in the Amazon QuickSight User Guide. Use  GenerateEmbedUrlForRegisteredUser  where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the  UpdateUser API operation. Use the  RegisterUser API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the Amazon QuickSight User Guide:    Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users     Customizing Access to the Amazon QuickSight Console    For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the Amazon QuickSight Developer Portal.
        public let quickSightConsole: RegisteredUserQuickSightConsoleEmbeddingConfiguration?

        public init(dashboard: RegisteredUserDashboardEmbeddingConfiguration? = nil, dashboardVisual: RegisteredUserDashboardVisualEmbeddingConfiguration? = nil, qSearchBar: RegisteredUserQSearchBarEmbeddingConfiguration? = nil, quickSightConsole: RegisteredUserQuickSightConsoleEmbeddingConfiguration? = nil) {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.qSearchBar = qSearchBar
            self.quickSightConsole = quickSightConsole
        }

        public func validate(name: String) throws {
            try self.dashboard?.validate(name: "\(name).dashboard")
            try self.dashboardVisual?.validate(name: "\(name).dashboardVisual")
            try self.qSearchBar?.validate(name: "\(name).qSearchBar")
            try self.quickSightConsole?.validate(name: "\(name).quickSightConsole")
        }

        private enum CodingKeys: String, CodingKey {
            case dashboard = "Dashboard"
            case dashboardVisual = "DashboardVisual"
            case qSearchBar = "QSearchBar"
            case quickSightConsole = "QuickSightConsole"
        }
    }

    public struct RegisteredUserQSearchBarEmbeddingConfiguration: AWSEncodableShape {
        /// The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open. If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.
        public let initialTopicId: String?

        public init(initialTopicId: String? = nil) {
            self.initialTopicId = initialTopicId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, max: 2048)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, min: 1)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initialTopicId = "InitialTopicId"
        }
    }

    public struct RegisteredUserQuickSightConsoleEmbeddingConfiguration: AWSEncodableShape {
        /// The initial URL path for the Amazon QuickSight console. InitialPath is required. The entry point URL is constrained to the following paths:    /start     /start/analyses     /start/dashboards     /start/favorites     /dashboards/DashboardId. DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard.    /analyses/AnalysisId. AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis.
        public let initialPath: String?

        public init(initialPath: String? = nil) {
            self.initialPath = initialPath
        }

        public func validate(name: String) throws {
            try self.validate(self.initialPath, name: "initialPath", parent: name, max: 1000)
            try self.validate(self.initialPath, name: "initialPath", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case initialPath = "InitialPath"
        }
    }

    public struct RelationalTable: AWSEncodableShape & AWSDecodableShape {
        /// The catalog associated with a table.
        public let catalog: String?
        /// The Amazon Resource Name (ARN) for the data source.
        public let dataSourceArn: String
        /// The column schema of the table.
        public let inputColumns: [InputColumn]
        /// The name of the relational table.
        public let name: String
        /// The schema name. This name applies to certain relational database engines.
        public let schema: String?

        public init(catalog: String? = nil, dataSourceArn: String, inputColumns: [InputColumn], name: String, schema: String? = nil) {
            self.catalog = catalog
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.name = name
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 256)
            try self.inputColumns.forEach {
                try $0.validate(name: "\(name).inputColumns[]")
            }
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, max: 2048)
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.schema, name: "schema", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case dataSourceArn = "DataSourceArn"
            case inputColumns = "InputColumns"
            case name = "Name"
            case schema = "Schema"
        }
    }

    public struct RelativeDateTimeControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// Customize how dates are formatted in controls.
        public let dateTimeFormat: String?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(dateTimeFormat: String? = nil, titleOptions: LabelOptions? = nil) {
            self.dateTimeFormat = dateTimeFormat
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, max: 128)
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, min: 1)
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormat = "DateTimeFormat"
            case titleOptions = "TitleOptions"
        }
    }

    public struct RelativeDatesFilter: AWSEncodableShape & AWSDecodableShape {
        /// The date configuration of the filter.
        public let anchorDateConfiguration: AnchorDateConfiguration
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The configuration for the exclude period of the filter.
        public let excludePeriodConfiguration: ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The minimum granularity (period granularity) of the relative dates filter.
        public let minimumGranularity: TimeGranularity?
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The parameter whose value should be used for the filter value.
        public let parameterName: String?
        /// The range date type of the filter. Choose one of the options below:    PREVIOUS     THIS     LAST     NOW     NEXT
        public let relativeDateType: RelativeDateType
        /// The date value of the filter.
        public let relativeDateValue: Int?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity

        public init(anchorDateConfiguration: AnchorDateConfiguration, column: ColumnIdentifier, excludePeriodConfiguration: ExcludePeriodConfiguration? = nil, filterId: String, minimumGranularity: TimeGranularity? = nil, nullOption: FilterNullOption, parameterName: String? = nil, relativeDateType: RelativeDateType, relativeDateValue: Int? = nil, timeGranularity: TimeGranularity) {
            self.anchorDateConfiguration = anchorDateConfiguration
            self.column = column
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.minimumGranularity = minimumGranularity
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.relativeDateType = relativeDateType
            self.relativeDateValue = relativeDateValue
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.anchorDateConfiguration.validate(name: "\(name).anchorDateConfiguration")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anchorDateConfiguration = "AnchorDateConfiguration"
            case column = "Column"
            case excludePeriodConfiguration = "ExcludePeriodConfiguration"
            case filterId = "FilterId"
            case minimumGranularity = "MinimumGranularity"
            case nullOption = "NullOption"
            case parameterName = "ParameterName"
            case relativeDateType = "RelativeDateType"
            case relativeDateValue = "RelativeDateValue"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct RenameColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column to be renamed.
        public let columnName: String
        /// The new name for the column.
        public let newColumnName: String

        public init(columnName: String, newColumnName: String) {
            self.columnName = columnName
            self.newColumnName = newColumnName
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.newColumnName, name: "newColumnName", parent: name, max: 128)
            try self.validate(self.newColumnName, name: "newColumnName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case newColumnName = "NewColumnName"
        }
    }

    public struct ResourcePermission: AWSEncodableShape & AWSDecodableShape {
        /// The IAM action to grant or revoke permissions on.
        public let actions: [String]
        /// The Amazon Resource Name (ARN) of the principal. This can be one of the following:   The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)   The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)   The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.)
        public let principal: String

        public init(actions: [String], principal: String) {
            self.actions = actions
            self.principal = principal
        }

        public func validate(name: String) throws {
            try self.validate(self.actions, name: "actions", parent: name, max: 16)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.principal, name: "principal", parent: name, max: 256)
            try self.validate(self.principal, name: "principal", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case principal = "Principal"
        }
    }

    public struct RestoreAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the analysis that you're restoring.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RestoreAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the analysis that you're restoring.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the analysis that you're restoring.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct RollingDateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data set that is used in the rolling date configuration.
        public let dataSetIdentifier: String?
        /// The expression of the rolling date configuration.
        public let expression: String

        public init(dataSetIdentifier: String? = nil, expression: String) {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIdentifier = "DataSetIdentifier"
            case expression = "Expression"
        }
    }

    public struct RowAlternateColorOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the list of row alternate colors.
        public let rowAlternateColors: [String]?
        /// Determines the widget status.
        public let status: WidgetStatus?

        public init(rowAlternateColors: [String]? = nil, status: WidgetStatus? = nil) {
            self.rowAlternateColors = rowAlternateColors
            self.status = status
        }

        public func validate(name: String) throws {
            try self.rowAlternateColors?.forEach {
                try validate($0, name: "rowAlternateColors[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.rowAlternateColors, name: "rowAlternateColors", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rowAlternateColors = "RowAlternateColors"
            case status = "Status"
        }
    }

    public struct RowInfo: AWSDecodableShape {
        /// The number of rows that were not ingested.
        public let rowsDropped: Int64?
        /// The number of rows that were ingested.
        public let rowsIngested: Int64?
        /// The total number of rows in the dataset.
        public let totalRowsInDataset: Int64?

        public init(rowsDropped: Int64? = nil, rowsIngested: Int64? = nil, totalRowsInDataset: Int64? = nil) {
            self.rowsDropped = rowsDropped
            self.rowsIngested = rowsIngested
            self.totalRowsInDataset = totalRowsInDataset
        }

        private enum CodingKeys: String, CodingKey {
            case rowsDropped = "RowsDropped"
            case rowsIngested = "RowsIngested"
            case totalRowsInDataset = "TotalRowsInDataset"
        }
    }

    public struct RowLevelPermissionDataSet: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.
        public let arn: String
        /// The user or group rules associated with the dataset that contains permissions for RLS. By default, FormatVersion is VERSION_1. When FormatVersion is VERSION_1, UserName and GroupName are required. When FormatVersion is VERSION_2, UserARN and GroupARN are required, and Namespace must not exist.
        public let formatVersion: RowLevelPermissionFormatVersion?
        /// The namespace associated with the dataset that contains permissions for RLS.
        public let namespace: String?
        /// The type of permissions to use when interpreting the permissions for RLS. DENY_ACCESS is included for backward compatibility only.
        public let permissionPolicy: RowLevelPermissionPolicy
        /// The status of the row-level security permission dataset. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public let status: Status?

        public init(arn: String, formatVersion: RowLevelPermissionFormatVersion? = nil, namespace: String? = nil, permissionPolicy: RowLevelPermissionPolicy, status: Status? = nil) {
            self.arn = arn
            self.formatVersion = formatVersion
            self.namespace = namespace
            self.permissionPolicy = permissionPolicy
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case formatVersion = "FormatVersion"
            case namespace = "Namespace"
            case permissionPolicy = "PermissionPolicy"
            case status = "Status"
        }
    }

    public struct RowLevelPermissionTagConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The status of row-level security tags. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public let status: Status?
        /// A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.
        public let tagRules: [RowLevelPermissionTagRule]

        public init(status: Status? = nil, tagRules: [RowLevelPermissionTagRule]) {
            self.status = status
            self.tagRules = tagRules
        }

        public func validate(name: String) throws {
            try self.tagRules.forEach {
                try $0.validate(name: "\(name).tagRules[]")
            }
            try self.validate(self.tagRules, name: "tagRules", parent: name, max: 50)
            try self.validate(self.tagRules, name: "tagRules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case tagRules = "TagRules"
        }
    }

    public struct RowLevelPermissionTagRule: AWSEncodableShape & AWSDecodableShape {
        /// The column name that a tag key is assigned to.
        public let columnName: String
        /// A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one. For example, you can use an asterisk as your match all value.
        public let matchAllValue: String?
        /// The unique key for a tag.
        public let tagKey: String
        /// A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.
        public let tagMultiValueDelimiter: String?

        public init(columnName: String, matchAllValue: String? = nil, tagKey: String, tagMultiValueDelimiter: String? = nil) {
            self.columnName = columnName
            self.matchAllValue = matchAllValue
            self.tagKey = tagKey
            self.tagMultiValueDelimiter = tagMultiValueDelimiter
        }

        public func validate(name: String) throws {
            try self.validate(self.matchAllValue, name: "matchAllValue", parent: name, max: 256)
            try self.validate(self.matchAllValue, name: "matchAllValue", parent: name, min: 1)
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 128)
            try self.validate(self.tagKey, name: "tagKey", parent: name, min: 1)
            try self.validate(self.tagMultiValueDelimiter, name: "tagMultiValueDelimiter", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case matchAllValue = "MatchAllValue"
            case tagKey = "TagKey"
            case tagMultiValueDelimiter = "TagMultiValueDelimiter"
        }
    }

    public struct S3Parameters: AWSEncodableShape & AWSDecodableShape {
        /// Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.
        public let manifestFileLocation: ManifestFileLocation

        public init(manifestFileLocation: ManifestFileLocation) {
            self.manifestFileLocation = manifestFileLocation
        }

        public func validate(name: String) throws {
            try self.manifestFileLocation.validate(name: "\(name).manifestFileLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case manifestFileLocation = "ManifestFileLocation"
        }
    }

    public struct S3Source: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the data source.
        public let dataSourceArn: String
        /// A physical table type for an S3 data source.  For files that aren't JSON, only STRING data types are supported in input columns.
        public let inputColumns: [InputColumn]
        /// Information about the format for the S3 source file or files.
        public let uploadSettings: UploadSettings?

        public init(dataSourceArn: String, inputColumns: [InputColumn], uploadSettings: UploadSettings? = nil) {
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.uploadSettings = uploadSettings
        }

        public func validate(name: String) throws {
            try self.inputColumns.forEach {
                try $0.validate(name: "\(name).inputColumns[]")
            }
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, max: 2048)
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, min: 1)
            try self.uploadSettings?.validate(name: "\(name).uploadSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case inputColumns = "InputColumns"
            case uploadSettings = "UploadSettings"
        }
    }

    public struct SameSheetTargetVisualConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that choose the target visual in the same sheet. Valid values are defined as follows:    ALL_VISUALS: Applies the filter operation to all visuals in the same sheet.
        public let targetVisualOptions: TargetVisualOptions?
        /// A list of the target visual IDs that are located in the same sheet of the analysis.
        public let targetVisuals: [String]?

        public init(targetVisualOptions: TargetVisualOptions? = nil, targetVisuals: [String]? = nil) {
            self.targetVisualOptions = targetVisualOptions
            self.targetVisuals = targetVisuals
        }

        public func validate(name: String) throws {
            try self.targetVisuals?.forEach {
                try validate($0, name: "targetVisuals[]", parent: name, max: 512)
                try validate($0, name: "targetVisuals[]", parent: name, min: 1)
                try validate($0, name: "targetVisuals[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.targetVisuals, name: "targetVisuals", parent: name, max: 30)
            try self.validate(self.targetVisuals, name: "targetVisuals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetVisualOptions = "TargetVisualOptions"
            case targetVisuals = "TargetVisuals"
        }
    }

    public struct SankeyDiagramAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The destination field wells of a sankey diagram.
        public let destination: [DimensionField]?
        /// The source field wells of a sankey diagram.
        public let source: [DimensionField]?
        /// The weight field wells of a sankey diagram.
        public let weight: [MeasureField]?

        public init(destination: [DimensionField]? = nil, source: [DimensionField]? = nil, weight: [MeasureField]? = nil) {
            self.destination = destination
            self.source = source
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.destination?.forEach {
                try $0.validate(name: "\(name).destination[]")
            }
            try self.validate(self.destination, name: "destination", parent: name, max: 200)
            try self.source?.forEach {
                try $0.validate(name: "\(name).source[]")
            }
            try self.validate(self.source, name: "source", parent: name, max: 200)
            try self.weight?.forEach {
                try $0.validate(name: "\(name).weight[]")
            }
            try self.validate(self.weight, name: "weight", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case source = "Source"
            case weight = "Weight"
        }
    }

    public struct SankeyDiagramChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data label configuration of a sankey diagram.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a sankey diagram.
        public let fieldWells: SankeyDiagramFieldWells?
        /// The sort configuration of a sankey diagram.
        public let sortConfiguration: SankeyDiagramSortConfiguration?

        public init(dataLabels: DataLabelOptions? = nil, fieldWells: SankeyDiagramFieldWells? = nil, sortConfiguration: SankeyDiagramSortConfiguration? = nil) {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.sortConfiguration = sortConfiguration
        }

        public func validate(name: String) throws {
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case sortConfiguration = "SortConfiguration"
        }
    }

    public struct SankeyDiagramFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a sankey diagram.
        public let sankeyDiagramAggregatedFieldWells: SankeyDiagramAggregatedFieldWells?

        public init(sankeyDiagramAggregatedFieldWells: SankeyDiagramAggregatedFieldWells? = nil) {
            self.sankeyDiagramAggregatedFieldWells = sankeyDiagramAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.sankeyDiagramAggregatedFieldWells?.validate(name: "\(name).sankeyDiagramAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case sankeyDiagramAggregatedFieldWells = "SankeyDiagramAggregatedFieldWells"
        }
    }

    public struct SankeyDiagramSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of destination nodes that are displayed in a sankey diagram.
        public let destinationItemsLimit: ItemsLimitConfiguration?
        /// The limit on the number of source nodes that are displayed in a sankey diagram.
        public let sourceItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the weight fields.
        public let weightSort: [FieldSortOptions]?

        public init(destinationItemsLimit: ItemsLimitConfiguration? = nil, sourceItemsLimit: ItemsLimitConfiguration? = nil, weightSort: [FieldSortOptions]? = nil) {
            self.destinationItemsLimit = destinationItemsLimit
            self.sourceItemsLimit = sourceItemsLimit
            self.weightSort = weightSort
        }

        public func validate(name: String) throws {
            try self.weightSort?.forEach {
                try $0.validate(name: "\(name).weightSort[]")
            }
            try self.validate(self.weightSort, name: "weightSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationItemsLimit = "DestinationItemsLimit"
            case sourceItemsLimit = "SourceItemsLimit"
            case weightSort = "WeightSort"
        }
    }

    public struct SankeyDiagramVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a sankey diagram.
        public let chartConfiguration: SankeyDiagramChartConfiguration?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: SankeyDiagramChartConfiguration? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct ScatterPlotCategoricallyAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category field well of a scatter plot.
        public let category: [DimensionField]?
        /// The size field well of a scatter plot.
        public let size: [MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is aggregated by category.
        public let xAxis: [MeasureField]?
        /// The y-axis field well of a scatter plot. The y-axis is aggregated by category.
        public let yAxis: [MeasureField]?

        public init(category: [DimensionField]? = nil, size: [MeasureField]? = nil, xAxis: [MeasureField]? = nil, yAxis: [MeasureField]? = nil) {
            self.category = category
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.size?.forEach {
                try $0.validate(name: "\(name).size[]")
            }
            try self.validate(self.size, name: "size", parent: name, max: 200)
            try self.xAxis?.forEach {
                try $0.validate(name: "\(name).xAxis[]")
            }
            try self.validate(self.xAxis, name: "xAxis", parent: name, max: 200)
            try self.yAxis?.forEach {
                try $0.validate(name: "\(name).yAxis[]")
            }
            try self.validate(self.yAxis, name: "yAxis", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case size = "Size"
            case xAxis = "XAxis"
            case yAxis = "YAxis"
        }
    }

    public struct ScatterPlotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: ScatterPlotFieldWells?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The legend display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.
        public let xAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.
        public let xAxisLabelOptions: ChartAxisLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.
        public let yAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.
        public let yAxisLabelOptions: ChartAxisLabelOptions?

        public init(dataLabels: DataLabelOptions? = nil, fieldWells: ScatterPlotFieldWells? = nil, legend: LegendOptions? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil, xAxisDisplayOptions: AxisDisplayOptions? = nil, xAxisLabelOptions: ChartAxisLabelOptions? = nil, yAxisDisplayOptions: AxisDisplayOptions? = nil, yAxisLabelOptions: ChartAxisLabelOptions? = nil) {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
            self.yAxisLabelOptions = yAxisLabelOptions
        }

        public func validate(name: String) throws {
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.xAxisDisplayOptions?.validate(name: "\(name).xAxisDisplayOptions")
            try self.xAxisLabelOptions?.validate(name: "\(name).xAxisLabelOptions")
            try self.yAxisDisplayOptions?.validate(name: "\(name).yAxisDisplayOptions")
            try self.yAxisLabelOptions?.validate(name: "\(name).yAxisLabelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
            case xAxisDisplayOptions = "XAxisDisplayOptions"
            case xAxisLabelOptions = "XAxisLabelOptions"
            case yAxisDisplayOptions = "YAxisDisplayOptions"
            case yAxisLabelOptions = "YAxisLabelOptions"
        }
    }

    public struct ScatterPlotFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a scatter plot. Scatter plots that have a field in the category (group/color) field will have aggregated field wells. The x and y-axes of these scatter plots are aggregated by category.
        public let scatterPlotCategoricallyAggregatedFieldWells: ScatterPlotCategoricallyAggregatedFieldWells?
        /// The unaggregated field wells of a scatter plot. Scatter plots without a category field well have unaggregated field wells. The x and y-axes of these scatter plots are unaggregated.
        public let scatterPlotUnaggregatedFieldWells: ScatterPlotUnaggregatedFieldWells?

        public init(scatterPlotCategoricallyAggregatedFieldWells: ScatterPlotCategoricallyAggregatedFieldWells? = nil, scatterPlotUnaggregatedFieldWells: ScatterPlotUnaggregatedFieldWells? = nil) {
            self.scatterPlotCategoricallyAggregatedFieldWells = scatterPlotCategoricallyAggregatedFieldWells
            self.scatterPlotUnaggregatedFieldWells = scatterPlotUnaggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.scatterPlotCategoricallyAggregatedFieldWells?.validate(name: "\(name).scatterPlotCategoricallyAggregatedFieldWells")
            try self.scatterPlotUnaggregatedFieldWells?.validate(name: "\(name).scatterPlotUnaggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case scatterPlotCategoricallyAggregatedFieldWells = "ScatterPlotCategoricallyAggregatedFieldWells"
            case scatterPlotUnaggregatedFieldWells = "ScatterPlotUnaggregatedFieldWells"
        }
    }

    public struct ScatterPlotUnaggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The size field well of a scatter plot.
        public let size: [MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is a dimension field and cannot be aggregated.
        public let xAxis: [DimensionField]?
        /// The y-axis field well of a scatter plot. The y-axis is a dimension field and cannot be aggregated.
        public let yAxis: [DimensionField]?

        public init(size: [MeasureField]? = nil, xAxis: [DimensionField]? = nil, yAxis: [DimensionField]? = nil) {
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }

        public func validate(name: String) throws {
            try self.size?.forEach {
                try $0.validate(name: "\(name).size[]")
            }
            try self.validate(self.size, name: "size", parent: name, max: 200)
            try self.xAxis?.forEach {
                try $0.validate(name: "\(name).xAxis[]")
            }
            try self.validate(self.xAxis, name: "xAxis", parent: name, max: 200)
            try self.yAxis?.forEach {
                try $0.validate(name: "\(name).yAxis[]")
            }
            try self.validate(self.yAxis, name: "yAxis", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case size = "Size"
            case xAxis = "XAxis"
            case yAxis = "YAxis"
        }
    }

    public struct ScatterPlotVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: ScatterPlotConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: ScatterPlotConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct ScrollBarOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the data zoom scroll bar.
        public let visibility: Visibility?
        /// The visibility range for the data zoom scroll bar.
        public let visibleRange: VisibleRangeOptions?

        public init(visibility: Visibility? = nil, visibleRange: VisibleRangeOptions? = nil) {
            self.visibility = visibility
            self.visibleRange = visibleRange
        }

        public func validate(name: String) throws {
            try self.visibleRange?.validate(name: "\(name).visibleRange")
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
            case visibleRange = "VisibleRange"
        }
    }

    public struct SearchAnalysesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the Amazon Web Services account that contains the analyses that you're searching for.
        public let awsAccountId: String
        /// The structure for the search filters that you want to apply to your search.
        public let filters: [AnalysisSearchFilter]
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [AnalysisSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchAnalysesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// Metadata describing the analyses that you searched for.
        public let analysisSummaryList: [AnalysisSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisSummaryList: [AnalysisSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisSummaryList = analysisSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSummaryList = "AnalysisSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SearchDashboardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the Amazon Web Services account that contains the user whose dashboards you're searching for.
        public let awsAccountId: String
        /// The filters to apply to the search. Currently, you can search only by user name, for example, "Filters": [ { "Name": "QUICKSIGHT_USER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]
        public let filters: [DashboardSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [DashboardSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchDashboardsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The list of dashboards owned by the user specified in Filters in your request.
        public let dashboardSummaryList: [DashboardSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardSummaryList: [DashboardSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardSummaryList = dashboardSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaryList = "DashboardSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SearchDataSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The filters to apply to the search.
        public let filters: [DataSetSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [DataSetSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchDataSetsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A DataSetSummaries object that returns a summary of a dataset.
        public let dataSetSummaries: [DataSetSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetSummaries: [DataSetSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetSummaries = dataSetSummaries
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetSummaries = "DataSetSummaries"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SearchDataSourcesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The filters to apply to the search.
        public let filters: [DataSourceSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [DataSourceSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchDataSourcesResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A DataSourceSummaries object that returns a summary of a data source.
        public let dataSourceSummaries: [DataSourceSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceSummaries: [DataSourceSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceSummaries = dataSourceSummaries
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSummaries = "DataSourceSummaries"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SearchFoldersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The filters to apply to the search. Currently, you can search only by the parent folder ARN. For example, "Filters": [ { "Name": "PARENT_FOLDER_ARN", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId" } ].
        public let filters: [FolderSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [FolderSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchFoldersResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
        public let folderSummaryList: [FolderSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderSummaryList: [FolderSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderSummaryList = folderSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderSummaryList = "FolderSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SearchGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The structure for the search filters that you want to apply to your search.
        public let filters: [GroupSearchFilter]
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace that you want to search.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [GroupSearchFilter], maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
        }
    }

    public struct SearchGroupsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of groups in a specified namespace that match the filters you set in your SearchGroups request.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct SecondaryValueOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of the secondary value.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct SectionAfterPageBreak: AWSEncodableShape & AWSDecodableShape {
        /// The option that enables or disables a page break at the end of a section.
        public let status: SectionPageBreakStatus?

        public init(status: SectionPageBreakStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct SectionBasedLayoutCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options for a paper canvas of a section-based layout.
        public let paperCanvasSizeOptions: SectionBasedLayoutPaperCanvasSizeOptions?

        public init(paperCanvasSizeOptions: SectionBasedLayoutPaperCanvasSizeOptions? = nil) {
            self.paperCanvasSizeOptions = paperCanvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case paperCanvasSizeOptions = "PaperCanvasSizeOptions"
        }
    }

    public struct SectionBasedLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of body section configurations.
        public let bodySections: [BodySectionConfiguration]
        /// The options for the canvas of a section-based layout.
        public let canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions
        /// A list of footer section configurations.
        public let footerSections: [HeaderFooterSectionConfiguration]
        /// A list of header section configurations.
        public let headerSections: [HeaderFooterSectionConfiguration]

        public init(bodySections: [BodySectionConfiguration], canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions, footerSections: [HeaderFooterSectionConfiguration], headerSections: [HeaderFooterSectionConfiguration]) {
            self.bodySections = bodySections
            self.canvasSizeOptions = canvasSizeOptions
            self.footerSections = footerSections
            self.headerSections = headerSections
        }

        public func validate(name: String) throws {
            try self.bodySections.forEach {
                try $0.validate(name: "\(name).bodySections[]")
            }
            try self.validate(self.bodySections, name: "bodySections", parent: name, max: 28)
            try self.footerSections.forEach {
                try $0.validate(name: "\(name).footerSections[]")
            }
            try self.validate(self.footerSections, name: "footerSections", parent: name, max: 1)
            try self.headerSections.forEach {
                try $0.validate(name: "\(name).headerSections[]")
            }
            try self.validate(self.headerSections, name: "headerSections", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bodySections = "BodySections"
            case canvasSizeOptions = "CanvasSizeOptions"
            case footerSections = "FooterSections"
            case headerSections = "HeaderSections"
        }
    }

    public struct SectionBasedLayoutPaperCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// Defines the spacing between the canvas content and the top, bottom, left, and right edges.
        public let paperMargin: Spacing?
        /// The paper orientation that is used to define canvas dimensions. Choose one of the following options:   PORTRAIT   LANDSCAPE
        public let paperOrientation: PaperOrientation?
        /// The paper size that is used to define canvas dimensions.
        public let paperSize: PaperSize?

        public init(paperMargin: Spacing? = nil, paperOrientation: PaperOrientation? = nil, paperSize: PaperSize? = nil) {
            self.paperMargin = paperMargin
            self.paperOrientation = paperOrientation
            self.paperSize = paperSize
        }

        private enum CodingKeys: String, CodingKey {
            case paperMargin = "PaperMargin"
            case paperOrientation = "PaperOrientation"
            case paperSize = "PaperSize"
        }
    }

    public struct SectionLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The free-form layout configuration of a section.
        public let freeFormLayout: FreeFormSectionLayoutConfiguration

        public init(freeFormLayout: FreeFormSectionLayoutConfiguration) {
            self.freeFormLayout = freeFormLayout
        }

        public func validate(name: String) throws {
            try self.freeFormLayout.validate(name: "\(name).freeFormLayout")
        }

        private enum CodingKeys: String, CodingKey {
            case freeFormLayout = "FreeFormLayout"
        }
    }

    public struct SectionPageBreakConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of a page break after a section.
        public let after: SectionAfterPageBreak?

        public init(after: SectionAfterPageBreak? = nil) {
            self.after = after
        }

        private enum CodingKeys: String, CodingKey {
            case after = "After"
        }
    }

    public struct SectionStyle: AWSEncodableShape & AWSDecodableShape {
        /// The height of a section. Heights can only be defined for header and footer sections. The default height margin is 0.5 inches.
        public let height: String?
        /// The spacing between section content and its top, bottom, left, and right edges. There is no padding by default.
        public let padding: Spacing?

        public init(height: String? = nil, padding: Spacing? = nil) {
            self.height = height
            self.padding = padding
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case padding = "Padding"
        }
    }

    public struct SelectedSheetsFilterScopeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.
        public let sheetVisualScopingConfigurations: [SheetVisualScopingConfiguration]?

        public init(sheetVisualScopingConfigurations: [SheetVisualScopingConfiguration]? = nil) {
            self.sheetVisualScopingConfigurations = sheetVisualScopingConfigurations
        }

        public func validate(name: String) throws {
            try self.sheetVisualScopingConfigurations?.forEach {
                try $0.validate(name: "\(name).sheetVisualScopingConfigurations[]")
            }
            try self.validate(self.sheetVisualScopingConfigurations, name: "sheetVisualScopingConfigurations", parent: name, max: 50)
            try self.validate(self.sheetVisualScopingConfigurations, name: "sheetVisualScopingConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sheetVisualScopingConfigurations = "SheetVisualScopingConfigurations"
        }
    }

    public struct SeriesItem: AWSEncodableShape & AWSDecodableShape {
        /// The data field series item configuration of a line chart.
        public let dataFieldSeriesItem: DataFieldSeriesItem?
        /// The field series item configuration of a line chart.
        public let fieldSeriesItem: FieldSeriesItem?

        public init(dataFieldSeriesItem: DataFieldSeriesItem? = nil, fieldSeriesItem: FieldSeriesItem? = nil) {
            self.dataFieldSeriesItem = dataFieldSeriesItem
            self.fieldSeriesItem = fieldSeriesItem
        }

        public func validate(name: String) throws {
            try self.dataFieldSeriesItem?.validate(name: "\(name).dataFieldSeriesItem")
            try self.fieldSeriesItem?.validate(name: "\(name).fieldSeriesItem")
        }

        private enum CodingKeys: String, CodingKey {
            case dataFieldSeriesItem = "DataFieldSeriesItem"
            case fieldSeriesItem = "FieldSeriesItem"
        }
    }

    public struct ServiceNowParameters: AWSEncodableShape & AWSDecodableShape {
        /// URL of the base site.
        public let siteBaseUrl: String

        public init(siteBaseUrl: String) {
            self.siteBaseUrl = siteBaseUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, max: 1024)
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case siteBaseUrl = "SiteBaseUrl"
        }
    }

    public struct SessionTag: AWSEncodableShape {
        /// The key for the tag.
        public let key: String
        /// The value that you want to assign the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct SetParameterValueConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The destination parameter name of the SetParameterValueConfiguration.
        public let destinationParameterName: String
        public let value: DestinationParameterValueConfiguration

        public init(destinationParameterName: String, value: DestinationParameterValueConfiguration) {
            self.destinationParameterName = destinationParameterName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationParameterName, name: "destinationParameterName", parent: name, max: 2048)
            try self.validate(self.destinationParameterName, name: "destinationParameterName", parent: name, min: 1)
            try self.validate(self.destinationParameterName, name: "destinationParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationParameterName = "DestinationParameterName"
            case value = "Value"
        }
    }

    public struct ShapeConditionalFormat: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting for the shape background color of a filled map visual.
        public let backgroundColor: ConditionalFormattingColor

        public init(backgroundColor: ConditionalFormattingColor) {
            self.backgroundColor = backgroundColor
        }

        public func validate(name: String) throws {
            try self.backgroundColor.validate(name: "\(name).backgroundColor")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
        }
    }

    public struct Sheet: AWSDecodableShape {
        /// The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public let name: String?
        /// The unique identifier associated with a sheet.
        public let sheetId: String?

        public init(name: String? = nil, sheetId: String? = nil) {
            self.name = name
            self.sheetId = sheetId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case sheetId = "SheetId"
        }
    }

    public struct SheetControlLayout: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that determines the elements and canvas size options of sheet control.
        public let configuration: SheetControlLayoutConfiguration

        public init(configuration: SheetControlLayoutConfiguration) {
            self.configuration = configuration
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct SheetControlLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that determines the elements and canvas size options of sheet control.
        public let gridLayout: GridLayoutConfiguration?

        public init(gridLayout: GridLayoutConfiguration? = nil) {
            self.gridLayout = gridLayout
        }

        public func validate(name: String) throws {
            try self.gridLayout?.validate(name: "\(name).gridLayout")
        }

        private enum CodingKeys: String, CodingKey {
            case gridLayout = "GridLayout"
        }
    }

    public struct SheetControlsOption: AWSEncodableShape {
        /// Visibility state.
        public let visibilityState: DashboardUIState?

        public init(visibilityState: DashboardUIState? = nil) {
            self.visibilityState = visibilityState
        }

        private enum CodingKeys: String, CodingKey {
            case visibilityState = "VisibilityState"
        }
    }

    public struct SheetDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The layout content type of the sheet. Choose one of the following options:    PAGINATED: Creates a sheet for a paginated report.    INTERACTIVE: Creates a sheet for an interactive dashboard.
        public let contentType: SheetContentType?
        /// A description of the sheet.
        public let description: String?
        /// The list of filter controls that are on a sheet. For more information, see Adding filter controls to analysis sheets in the Amazon QuickSight User Guide.
        public let filterControls: [FilterControl]?
        /// Layouts define how the components of a sheet are arranged. For more information, see Types of layout in the Amazon QuickSight User Guide.
        public let layouts: [Layout]?
        /// The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public let name: String?
        /// The list of parameter controls that are on a sheet. For more information, see Using a Control with a Parameter in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterControls: [ParameterControl]?
        /// The control layouts of the sheet.
        public let sheetControlLayouts: [SheetControlLayout]?
        /// The unique identifier of a sheet.
        public let sheetId: String
        /// The text boxes that are on a sheet.
        public let textBoxes: [SheetTextBox]?
        /// The title of the sheet.
        public let title: String?
        /// A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.
        public let visuals: [Visual]?

        public init(contentType: SheetContentType? = nil, description: String? = nil, filterControls: [FilterControl]? = nil, layouts: [Layout]? = nil, name: String? = nil, parameterControls: [ParameterControl]? = nil, sheetControlLayouts: [SheetControlLayout]? = nil, sheetId: String, textBoxes: [SheetTextBox]? = nil, title: String? = nil, visuals: [Visual]? = nil) {
            self.contentType = contentType
            self.description = description
            self.filterControls = filterControls
            self.layouts = layouts
            self.name = name
            self.parameterControls = parameterControls
            self.sheetControlLayouts = sheetControlLayouts
            self.sheetId = sheetId
            self.textBoxes = textBoxes
            self.title = title
            self.visuals = visuals
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.filterControls?.forEach {
                try $0.validate(name: "\(name).filterControls[]")
            }
            try self.validate(self.filterControls, name: "filterControls", parent: name, max: 200)
            try self.layouts?.forEach {
                try $0.validate(name: "\(name).layouts[]")
            }
            try self.validate(self.layouts, name: "layouts", parent: name, max: 1)
            try self.validate(self.layouts, name: "layouts", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameterControls?.forEach {
                try $0.validate(name: "\(name).parameterControls[]")
            }
            try self.validate(self.parameterControls, name: "parameterControls", parent: name, max: 200)
            try self.sheetControlLayouts?.forEach {
                try $0.validate(name: "\(name).sheetControlLayouts[]")
            }
            try self.validate(self.sheetControlLayouts, name: "sheetControlLayouts", parent: name, max: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, max: 512)
            try self.validate(self.sheetId, name: "sheetId", parent: name, min: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, pattern: "^[\\w\\-]+$")
            try self.textBoxes?.forEach {
                try $0.validate(name: "\(name).textBoxes[]")
            }
            try self.validate(self.textBoxes, name: "textBoxes", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, max: 1024)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.visuals?.forEach {
                try $0.validate(name: "\(name).visuals[]")
            }
            try self.validate(self.visuals, name: "visuals", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case description = "Description"
            case filterControls = "FilterControls"
            case layouts = "Layouts"
            case name = "Name"
            case parameterControls = "ParameterControls"
            case sheetControlLayouts = "SheetControlLayouts"
            case sheetId = "SheetId"
            case textBoxes = "TextBoxes"
            case title = "Title"
            case visuals = "Visuals"
        }
    }

    public struct SheetElementConfigurationOverrides: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not the overrides are visible. Choose one of the following options:    VISIBLE     HIDDEN
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct SheetElementRenderingRule: AWSEncodableShape & AWSDecodableShape {
        /// The override configuration of the rendering rules of a sheet.
        public let configurationOverrides: SheetElementConfigurationOverrides
        /// The expression of the rendering rules of a sheet.
        public let expression: String

        public init(configurationOverrides: SheetElementConfigurationOverrides, expression: String) {
            self.configurationOverrides = configurationOverrides
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationOverrides = "ConfigurationOverrides"
            case expression = "Expression"
        }
    }

    public struct SheetStyle: AWSEncodableShape & AWSDecodableShape {
        /// The display options for tiles.
        public let tile: TileStyle?
        /// The layout options for tiles.
        public let tileLayout: TileLayoutStyle?

        public init(tile: TileStyle? = nil, tileLayout: TileLayoutStyle? = nil) {
            self.tile = tile
            self.tileLayout = tileLayout
        }

        private enum CodingKeys: String, CodingKey {
            case tile = "Tile"
            case tileLayout = "TileLayout"
        }
    }

    public struct SheetTextBox: AWSEncodableShape & AWSDecodableShape {
        /// The content that is displayed in the text box.
        public let content: String?
        /// The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.
        public let sheetTextBoxId: String

        public init(content: String? = nil, sheetTextBoxId: String) {
            self.content = content
            self.sheetTextBoxId = sheetTextBoxId
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 150_000)
            try self.validate(self.sheetTextBoxId, name: "sheetTextBoxId", parent: name, max: 512)
            try self.validate(self.sheetTextBoxId, name: "sheetTextBoxId", parent: name, min: 1)
            try self.validate(self.sheetTextBoxId, name: "sheetTextBoxId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case sheetTextBoxId = "SheetTextBoxId"
        }
    }

    public struct SheetVisualScopingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The scope of the applied entities. Choose one of the following options:    ALL_VISUALS     SELECTED_VISUALS
        public let scope: FilterVisualScope
        /// The selected sheet that the filter is applied to.
        public let sheetId: String
        /// The selected visuals that the filter is applied to.
        public let visualIds: [String]?

        public init(scope: FilterVisualScope, sheetId: String, visualIds: [String]? = nil) {
            self.scope = scope
            self.sheetId = sheetId
            self.visualIds = visualIds
        }

        public func validate(name: String) throws {
            try self.validate(self.sheetId, name: "sheetId", parent: name, max: 512)
            try self.validate(self.sheetId, name: "sheetId", parent: name, min: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, pattern: "^[\\w\\-]+$")
            try self.visualIds?.forEach {
                try validate($0, name: "visualIds[]", parent: name, max: 512)
                try validate($0, name: "visualIds[]", parent: name, min: 1)
                try validate($0, name: "visualIds[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.visualIds, name: "visualIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case scope = "Scope"
            case sheetId = "SheetId"
            case visualIds = "VisualIds"
        }
    }

    public struct ShortFormatText: AWSEncodableShape & AWSDecodableShape {
        /// Plain text format.
        public let plainText: String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public let richText: String?

        public init(plainText: String? = nil, richText: String? = nil) {
            self.plainText = plainText
            self.richText = richText
        }

        public func validate(name: String) throws {
            try self.validate(self.plainText, name: "plainText", parent: name, max: 512)
            try self.validate(self.plainText, name: "plainText", parent: name, min: 1)
            try self.validate(self.richText, name: "richText", parent: name, max: 1024)
            try self.validate(self.richText, name: "richText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case plainText = "PlainText"
            case richText = "RichText"
        }
    }

    public struct SignupResponse: AWSDecodableShape {
        /// The name of your Amazon QuickSight account.
        public let accountName: String?
        /// The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are SIMPLE_AD, AD_CONNECTOR, and MICROSOFT_AD.
        public let directoryType: String?
        /// A Boolean that is TRUE if the Amazon QuickSight uses IAM as an authentication method.
        public let iamUser: Bool?
        /// The user login name for your Amazon QuickSight account.
        public let userLoginName: String?

        public init(accountName: String? = nil, directoryType: String? = nil, iamUser: Bool? = nil, userLoginName: String? = nil) {
            self.accountName = accountName
            self.directoryType = directoryType
            self.iamUser = iamUser
            self.userLoginName = userLoginName
        }

        private enum CodingKeys: String, CodingKey {
            case accountName
            case directoryType
            case iamUser = "IAMUser"
            case userLoginName
        }
    }

    public struct SimpleClusterMarker: AWSEncodableShape & AWSDecodableShape {
        /// The color of the simple cluster marker.
        public let color: String?

        public init(color: String? = nil) {
            self.color = color
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
        }
    }

    public struct SliderControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(titleOptions: LabelOptions? = nil) {
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case titleOptions = "TitleOptions"
        }
    }

    public struct SmallMultiplesOptions: AWSEncodableShape & AWSDecodableShape {
        /// Sets the maximum number of visible columns to display in the grid of small multiples panels. The default is Auto, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.
        public let maxVisibleColumns: Int64?
        /// Sets the maximum number of visible rows to display in the grid of small multiples panels. The default value is Auto, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.
        public let maxVisibleRows: Int64?
        /// Configures the display options for each small multiples panel.
        public let panelConfiguration: PanelConfiguration?

        public init(maxVisibleColumns: Int64? = nil, maxVisibleRows: Int64? = nil, panelConfiguration: PanelConfiguration? = nil) {
            self.maxVisibleColumns = maxVisibleColumns
            self.maxVisibleRows = maxVisibleRows
            self.panelConfiguration = panelConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.maxVisibleColumns, name: "maxVisibleColumns", parent: name, max: 10)
            try self.validate(self.maxVisibleColumns, name: "maxVisibleColumns", parent: name, min: 1)
            try self.validate(self.maxVisibleRows, name: "maxVisibleRows", parent: name, max: 10)
            try self.validate(self.maxVisibleRows, name: "maxVisibleRows", parent: name, min: 1)
            try self.panelConfiguration?.validate(name: "\(name).panelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case maxVisibleColumns = "MaxVisibleColumns"
            case maxVisibleRows = "MaxVisibleRows"
            case panelConfiguration = "PanelConfiguration"
        }
    }

    public struct SnowflakeParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Warehouse.
        public let warehouse: String

        public init(database: String, host: String, warehouse: String) {
            self.database = database
            self.host = host
            self.warehouse = warehouse
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.warehouse, name: "warehouse", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case warehouse = "Warehouse"
        }
    }

    public struct Spacing: AWSEncodableShape & AWSDecodableShape {
        /// Define the bottom spacing.
        public let bottom: String?
        /// Define the left spacing.
        public let left: String?
        /// Define the right spacing.
        public let right: String?
        /// Define the top spacing.
        public let top: String?

        public init(bottom: String? = nil, left: String? = nil, right: String? = nil, top: String? = nil) {
            self.bottom = bottom
            self.left = left
            self.right = right
            self.top = top
        }

        private enum CodingKeys: String, CodingKey {
            case bottom = "Bottom"
            case left = "Left"
            case right = "Right"
            case top = "Top"
        }
    }

    public struct SparkParameters: AWSEncodableShape & AWSDecodableShape {
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(host: String, port: Int) {
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case port = "Port"
        }
    }

    public struct SqlServerParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct SslProperties: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean option to control whether SSL should be disabled.
        public let disableSsl: Bool?

        public init(disableSsl: Bool? = nil) {
            self.disableSsl = disableSsl
        }

        private enum CodingKeys: String, CodingKey {
            case disableSsl = "DisableSsl"
        }
    }

    public struct StringDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the StringDefaultValues. Different defaults displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public let staticValues: [String]?

        public init(dynamicValue: DynamicDefaultValue? = nil, staticValues: [String]? = nil) {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case staticValues = "StaticValues"
        }
    }

    public struct StringFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// The formatting configuration for numeric strings.
        public let numericFormatConfiguration: NumericFormatConfiguration?

        public init(nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numericFormatConfiguration: NumericFormatConfiguration? = nil) {
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.numericFormatConfiguration?.validate(name: "\(name).numericFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numericFormatConfiguration = "NumericFormatConfiguration"
        }
    }

    public struct StringParameter: AWSEncodableShape {
        /// A display name for a string parameter.
        public let name: String
        /// The values of a string parameter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct StringParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: StringDefaultValues?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        public let parameterValueType: ParameterValueType
        /// The configuration that defines the default value of a String parameter when a value has not been set.
        public let valueWhenUnset: StringValueWhenUnsetConfiguration?

        public init(defaultValues: StringDefaultValues? = nil, name: String, parameterValueType: ParameterValueType, valueWhenUnset: StringValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case name = "Name"
            case parameterValueType = "ParameterValueType"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct StringValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: String?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: String? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct SubtotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The custom label string for the subtotal cells.
        public let customLabel: String?
        /// The field level (all, custom, last) for the subtotal cells.
        public let fieldLevel: PivotTableSubtotalLevel?
        /// The optional configuration of subtotal cells.
        public let fieldLevelOptions: [PivotTableFieldSubtotalOptions]?
        /// The cell styling options for the subtotals of header cells.
        public let metricHeaderCellStyle: TableCellStyle?
        /// The cell styling options for the subtotal cells.
        public let totalCellStyle: TableCellStyle?
        /// The visibility configuration for the subtotal cells.
        public let totalsVisibility: Visibility?
        /// The cell styling options for the subtotals of value cells.
        public let valueCellStyle: TableCellStyle?

        public init(customLabel: String? = nil, fieldLevel: PivotTableSubtotalLevel? = nil, fieldLevelOptions: [PivotTableFieldSubtotalOptions]? = nil, metricHeaderCellStyle: TableCellStyle? = nil, totalCellStyle: TableCellStyle? = nil, totalsVisibility: Visibility? = nil, valueCellStyle: TableCellStyle? = nil) {
            self.customLabel = customLabel
            self.fieldLevel = fieldLevel
            self.fieldLevelOptions = fieldLevelOptions
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }

        public func validate(name: String) throws {
            try self.fieldLevelOptions?.forEach {
                try $0.validate(name: "\(name).fieldLevelOptions[]")
            }
            try self.validate(self.fieldLevelOptions, name: "fieldLevelOptions", parent: name, max: 100)
            try self.metricHeaderCellStyle?.validate(name: "\(name).metricHeaderCellStyle")
            try self.totalCellStyle?.validate(name: "\(name).totalCellStyle")
            try self.valueCellStyle?.validate(name: "\(name).valueCellStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fieldLevel = "FieldLevel"
            case fieldLevelOptions = "FieldLevelOptions"
            case metricHeaderCellStyle = "MetricHeaderCellStyle"
            case totalCellStyle = "TotalCellStyle"
            case totalsVisibility = "TotalsVisibility"
            case valueCellStyle = "ValueCellStyle"
        }
    }

    public struct TableAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The group by field well for a pivot table. Values are grouped by group by fields.
        public let groupBy: [DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on group by fields.
        public let values: [MeasureField]?

        public init(groupBy: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.groupBy = groupBy
            self.values = values
        }

        public func validate(name: String) throws {
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case values = "Values"
        }
    }

    public struct TableBorderOptions: AWSEncodableShape & AWSDecodableShape {
        /// The color of a table border.
        public let color: String?
        /// The style (none, solid) of a table border.
        public let style: TableBorderStyle?
        /// The thickness of a table border.
        public let thickness: Int?

        public init(color: String? = nil, style: TableBorderStyle? = nil, thickness: Int? = nil) {
            self.color = color
            self.style = style
            self.thickness = thickness
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.thickness, name: "thickness", parent: name, max: 4)
            try self.validate(self.thickness, name: "thickness", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case style = "Style"
            case thickness = "Thickness"
        }
    }

    public struct TableCellConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the cell for conditional formatting.
        public let fieldId: String
        /// The text format of the cell for conditional formatting.
        public let textFormat: TextConditionalFormat?

        public init(fieldId: String, textFormat: TextConditionalFormat? = nil) {
            self.fieldId = fieldId
            self.textFormat = textFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.textFormat?.validate(name: "\(name).textFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case textFormat = "TextFormat"
        }
    }

    public struct TableCellImageSizingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The cell scaling configuration of the sizing options for the table image configuration.
        public let tableCellImageScalingConfiguration: TableCellImageScalingConfiguration?

        public init(tableCellImageScalingConfiguration: TableCellImageScalingConfiguration? = nil) {
            self.tableCellImageScalingConfiguration = tableCellImageScalingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case tableCellImageScalingConfiguration = "TableCellImageScalingConfiguration"
        }
    }

    public struct TableCellStyle: AWSEncodableShape & AWSDecodableShape {
        /// The background color for the table cells.
        public let backgroundColor: String?
        /// The borders for the table cells.
        public let border: GlobalTableBorderOptions?
        /// The font configuration of the table cells.
        public let fontConfiguration: FontConfiguration?
        /// The height color for the table cells.
        public let height: Int?
        /// The horizontal text alignment (left, center, right, auto) for the table cells.
        public let horizontalTextAlignment: HorizontalTextAlignment?
        /// The text wrap (none, wrap) for the table cells.
        public let textWrap: TextWrap?
        /// The vertical text alignment (top, middle, bottom) for the table cells.
        public let verticalTextAlignment: VerticalTextAlignment?
        /// The visibility of the table cells.
        public let visibility: Visibility?

        public init(backgroundColor: String? = nil, border: GlobalTableBorderOptions? = nil, fontConfiguration: FontConfiguration? = nil, height: Int? = nil, horizontalTextAlignment: HorizontalTextAlignment? = nil, textWrap: TextWrap? = nil, verticalTextAlignment: VerticalTextAlignment? = nil, visibility: Visibility? = nil) {
            self.backgroundColor = backgroundColor
            self.border = border
            self.fontConfiguration = fontConfiguration
            self.height = height
            self.horizontalTextAlignment = horizontalTextAlignment
            self.textWrap = textWrap
            self.verticalTextAlignment = verticalTextAlignment
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.backgroundColor, name: "backgroundColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.border?.validate(name: "\(name).border")
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
            try self.validate(self.height, name: "height", parent: name, max: 500)
            try self.validate(self.height, name: "height", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case border = "Border"
            case fontConfiguration = "FontConfiguration"
            case height = "Height"
            case horizontalTextAlignment = "HorizontalTextAlignment"
            case textWrap = "TextWrap"
            case verticalTextAlignment = "VerticalTextAlignment"
            case visibility = "Visibility"
        }
    }

    public struct TableConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options for a PivotTableVisual.
        public let conditionalFormattingOptions: [TableConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [TableConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct TableConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The cell conditional formatting option for a table.
        public let cell: TableCellConditionalFormatting?
        /// The row conditional formatting option for a table.
        public let row: TableRowConditionalFormatting?

        public init(cell: TableCellConditionalFormatting? = nil, row: TableRowConditionalFormatting? = nil) {
            self.cell = cell
            self.row = row
        }

        public func validate(name: String) throws {
            try self.cell?.validate(name: "\(name).cell")
            try self.row?.validate(name: "\(name).row")
        }

        private enum CodingKeys: String, CodingKey {
            case cell = "Cell"
            case row = "Row"
        }
    }

    public struct TableConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field options for a table visual.
        public let fieldOptions: TableFieldOptions?
        /// The field wells of the visual.
        public let fieldWells: TableFieldWells?
        /// The paginated report options for a table visual.
        public let paginatedReportOptions: TablePaginatedReportOptions?
        /// The sort configuration for a TableVisual.
        public let sortConfiguration: TableSortConfiguration?
        /// The table options for a table visual.
        public let tableOptions: TableOptions?
        /// The total options for a table visual.
        public let totalOptions: TotalOptions?

        public init(fieldOptions: TableFieldOptions? = nil, fieldWells: TableFieldWells? = nil, paginatedReportOptions: TablePaginatedReportOptions? = nil, sortConfiguration: TableSortConfiguration? = nil, tableOptions: TableOptions? = nil, totalOptions: TotalOptions? = nil) {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }

        public func validate(name: String) throws {
            try self.fieldOptions?.validate(name: "\(name).fieldOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tableOptions?.validate(name: "\(name).tableOptions")
            try self.totalOptions?.validate(name: "\(name).totalOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldOptions = "FieldOptions"
            case fieldWells = "FieldWells"
            case paginatedReportOptions = "PaginatedReportOptions"
            case sortConfiguration = "SortConfiguration"
            case tableOptions = "TableOptions"
            case totalOptions = "TotalOptions"
        }
    }

    public struct TableFieldCustomIconContent: AWSEncodableShape & AWSDecodableShape {
        /// The icon set type (link) of the custom icon content for table URL link content.
        public let icon: TableFieldIconSetType?

        public init(icon: TableFieldIconSetType? = nil) {
            self.icon = icon
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
        }
    }

    public struct TableFieldCustomTextContent: AWSEncodableShape & AWSDecodableShape {
        /// The font configuration of the custom text content for the table URL link content.
        public let fontConfiguration: FontConfiguration
        /// The string value of the custom text content for the table URL link content.
        public let value: String?

        public init(fontConfiguration: FontConfiguration, value: String? = nil) {
            self.fontConfiguration = fontConfiguration
            self.value = value
        }

        public func validate(name: String) throws {
            try self.fontConfiguration.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case fontConfiguration = "FontConfiguration"
            case value = "Value"
        }
    }

    public struct TableFieldImageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sizing options for the table image configuration.
        public let sizingOptions: TableCellImageSizingConfiguration?

        public init(sizingOptions: TableCellImageSizingConfiguration? = nil) {
            self.sizingOptions = sizingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case sizingOptions = "SizingOptions"
        }
    }

    public struct TableFieldLinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The URL content (text, icon) for the table link configuration.
        public let content: TableFieldLinkContentConfiguration
        /// The URL target (new tab, new window, same tab) for the table link configuration.
        public let target: URLTargetConfiguration

        public init(content: TableFieldLinkContentConfiguration, target: URLTargetConfiguration) {
            self.content = content
            self.target = target
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case target = "Target"
        }
    }

    public struct TableFieldLinkContentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The custom icon content for the table link content configuration.
        public let customIconContent: TableFieldCustomIconContent?
        /// The custom text content (value, font configuration) for the table link content configuration.
        public let customTextContent: TableFieldCustomTextContent?

        public init(customIconContent: TableFieldCustomIconContent? = nil, customTextContent: TableFieldCustomTextContent? = nil) {
            self.customIconContent = customIconContent
            self.customTextContent = customTextContent
        }

        public func validate(name: String) throws {
            try self.customTextContent?.validate(name: "\(name).customTextContent")
        }

        private enum CodingKeys: String, CodingKey {
            case customIconContent = "CustomIconContent"
            case customTextContent = "CustomTextContent"
        }
    }

    public struct TableFieldOption: AWSEncodableShape & AWSDecodableShape {
        /// The custom label for a table field.
        public let customLabel: String?
        /// The field ID for a table field.
        public let fieldId: String
        /// The URL configuration for a table field.
        public let urlStyling: TableFieldURLConfiguration?
        /// The visibility of a table field.
        public let visibility: Visibility?
        /// The width for a table field.
        public let width: String?

        public init(customLabel: String? = nil, fieldId: String, urlStyling: TableFieldURLConfiguration? = nil, visibility: Visibility? = nil, width: String? = nil) {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.urlStyling = urlStyling
            self.visibility = visibility
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.customLabel, name: "customLabel", parent: name, max: 2048)
            try self.validate(self.customLabel, name: "customLabel", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.urlStyling?.validate(name: "\(name).urlStyling")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fieldId = "FieldId"
            case urlStyling = "URLStyling"
            case visibility = "Visibility"
            case width = "Width"
        }
    }

    public struct TableFieldOptions: AWSEncodableShape & AWSDecodableShape {
        /// The order of field IDs of the field options for a table visual.
        public let order: [String]?
        /// The selected field options for the table field options.
        public let selectedFieldOptions: [TableFieldOption]?

        public init(order: [String]? = nil, selectedFieldOptions: [TableFieldOption]? = nil) {
            self.order = order
            self.selectedFieldOptions = selectedFieldOptions
        }

        public func validate(name: String) throws {
            try self.order?.forEach {
                try validate($0, name: "order[]", parent: name, max: 512)
                try validate($0, name: "order[]", parent: name, min: 1)
            }
            try self.validate(self.order, name: "order", parent: name, max: 100)
            try self.selectedFieldOptions?.forEach {
                try $0.validate(name: "\(name).selectedFieldOptions[]")
            }
            try self.validate(self.selectedFieldOptions, name: "selectedFieldOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case order = "Order"
            case selectedFieldOptions = "SelectedFieldOptions"
        }
    }

    public struct TableFieldURLConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The image configuration of a table field URL.
        public let imageConfiguration: TableFieldImageConfiguration?
        /// The link configuration of a table field URL.
        public let linkConfiguration: TableFieldLinkConfiguration?

        public init(imageConfiguration: TableFieldImageConfiguration? = nil, linkConfiguration: TableFieldLinkConfiguration? = nil) {
            self.imageConfiguration = imageConfiguration
            self.linkConfiguration = linkConfiguration
        }

        public func validate(name: String) throws {
            try self.linkConfiguration?.validate(name: "\(name).linkConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case imageConfiguration = "ImageConfiguration"
            case linkConfiguration = "LinkConfiguration"
        }
    }

    public struct TableFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well for the table.
        public let tableAggregatedFieldWells: TableAggregatedFieldWells?
        /// The unaggregated field well for the table.
        public let tableUnaggregatedFieldWells: TableUnaggregatedFieldWells?

        public init(tableAggregatedFieldWells: TableAggregatedFieldWells? = nil, tableUnaggregatedFieldWells: TableUnaggregatedFieldWells? = nil) {
            self.tableAggregatedFieldWells = tableAggregatedFieldWells
            self.tableUnaggregatedFieldWells = tableUnaggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.tableAggregatedFieldWells?.validate(name: "\(name).tableAggregatedFieldWells")
            try self.tableUnaggregatedFieldWells?.validate(name: "\(name).tableUnaggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case tableAggregatedFieldWells = "TableAggregatedFieldWells"
            case tableUnaggregatedFieldWells = "TableUnaggregatedFieldWells"
        }
    }

    public struct TableOptions: AWSEncodableShape & AWSDecodableShape {
        /// The table cell style of table cells.
        public let cellStyle: TableCellStyle?
        /// The table cell style of a table header.
        public let headerStyle: TableCellStyle?
        /// The orientation (vertical, horizontal) for a table.
        public let orientation: TableOrientation?
        /// The row alternate color options (widget status, row alternate colors) for a table.
        public let rowAlternateColorOptions: RowAlternateColorOptions?

        public init(cellStyle: TableCellStyle? = nil, headerStyle: TableCellStyle? = nil, orientation: TableOrientation? = nil, rowAlternateColorOptions: RowAlternateColorOptions? = nil) {
            self.cellStyle = cellStyle
            self.headerStyle = headerStyle
            self.orientation = orientation
            self.rowAlternateColorOptions = rowAlternateColorOptions
        }

        public func validate(name: String) throws {
            try self.cellStyle?.validate(name: "\(name).cellStyle")
            try self.headerStyle?.validate(name: "\(name).headerStyle")
            try self.rowAlternateColorOptions?.validate(name: "\(name).rowAlternateColorOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case cellStyle = "CellStyle"
            case headerStyle = "HeaderStyle"
            case orientation = "Orientation"
            case rowAlternateColorOptions = "RowAlternateColorOptions"
        }
    }

    public struct TablePaginatedReportOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of repeating header rows on each page.
        public let overflowColumnHeaderVisibility: Visibility?
        /// The visibility of printing table overflow across pages.
        public let verticalOverflowVisibility: Visibility?

        public init(overflowColumnHeaderVisibility: Visibility? = nil, verticalOverflowVisibility: Visibility? = nil) {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case overflowColumnHeaderVisibility = "OverflowColumnHeaderVisibility"
            case verticalOverflowVisibility = "VerticalOverflowVisibility"
        }
    }

    public struct TableRowConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting color (solid, gradient) of the background for a table row.
        public let backgroundColor: ConditionalFormattingColor?
        /// The conditional formatting color (solid, gradient) of the text for a table row.
        public let textColor: ConditionalFormattingColor?

        public init(backgroundColor: ConditionalFormattingColor? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.backgroundColor = backgroundColor
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.backgroundColor?.validate(name: "\(name).backgroundColor")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case textColor = "TextColor"
        }
    }

    public struct TableSideBorderOptions: AWSEncodableShape & AWSDecodableShape {
        /// The table border options of the bottom border.
        public let bottom: TableBorderOptions?
        /// The table border options of the inner horizontal border.
        public let innerHorizontal: TableBorderOptions?
        /// The table border options of the inner vertical border.
        public let innerVertical: TableBorderOptions?
        /// The table border options of the left border.
        public let left: TableBorderOptions?
        /// The table border options of the right border.
        public let right: TableBorderOptions?
        /// The table border options of the top border.
        public let top: TableBorderOptions?

        public init(bottom: TableBorderOptions? = nil, innerHorizontal: TableBorderOptions? = nil, innerVertical: TableBorderOptions? = nil, left: TableBorderOptions? = nil, right: TableBorderOptions? = nil, top: TableBorderOptions? = nil) {
            self.bottom = bottom
            self.innerHorizontal = innerHorizontal
            self.innerVertical = innerVertical
            self.left = left
            self.right = right
            self.top = top
        }

        public func validate(name: String) throws {
            try self.bottom?.validate(name: "\(name).bottom")
            try self.innerHorizontal?.validate(name: "\(name).innerHorizontal")
            try self.innerVertical?.validate(name: "\(name).innerVertical")
            try self.left?.validate(name: "\(name).left")
            try self.right?.validate(name: "\(name).right")
            try self.top?.validate(name: "\(name).top")
        }

        private enum CodingKeys: String, CodingKey {
            case bottom = "Bottom"
            case innerHorizontal = "InnerHorizontal"
            case innerVertical = "InnerVertical"
            case left = "Left"
            case right = "Right"
            case top = "Top"
        }
    }

    public struct TableSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The pagination configuration (page size, page number) for the table.
        public let paginationConfiguration: PaginationConfiguration?
        /// The field sort options for rows in the table.
        public let rowSort: [FieldSortOptions]?

        public init(paginationConfiguration: PaginationConfiguration? = nil, rowSort: [FieldSortOptions]? = nil) {
            self.paginationConfiguration = paginationConfiguration
            self.rowSort = rowSort
        }

        public func validate(name: String) throws {
            try self.paginationConfiguration?.validate(name: "\(name).paginationConfiguration")
            try self.rowSort?.forEach {
                try $0.validate(name: "\(name).rowSort[]")
            }
            try self.validate(self.rowSort, name: "rowSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case paginationConfiguration = "PaginationConfiguration"
            case rowSort = "RowSort"
        }
    }

    public struct TableUnaggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The values field well for a pivot table. Values are unaggregated for an unaggregated table.
        public let values: [UnaggregatedField]?

        public init(values: [UnaggregatedField]? = nil) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct TableVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: TableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public let conditionalFormatting: TableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: TableConfiguration? = nil, conditionalFormatting: TableConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Tag key.
        public let key: String
        /// Tag value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The column that this operation acts on.
        public let columnName: String
        /// The dataset column tag, currently only used for geospatial type tagging.  This is not tags for the Amazon Web Services tagging feature.
        public let tags: [ColumnTag]

        public init(columnName: String, tags: [ColumnTag]) {
            self.columnName = columnName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 16)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case tags = "Tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct Template: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the template.
        public let arn: String?
        /// Time when this was created.
        public let createdTime: Date?
        /// Time when this was last updated.
        public let lastUpdatedTime: Date?
        /// The display name of the template.
        public let name: String?
        /// The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let templateId: String?
        /// A structure describing the versions of the template.
        public let version: TemplateVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, templateId: String? = nil, version: TemplateVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.templateId = templateId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case templateId = "TemplateId"
            case version = "Version"
        }
    }

    public struct TemplateAlias: AWSDecodableShape {
        /// The display name of the template alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the template alias.
        public let arn: String?
        /// The version number of the template alias.
        public let templateVersionNumber: Int64?

        public init(aliasName: String? = nil, arn: String? = nil, templateVersionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.templateVersionNumber = templateVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct TemplateError: AWSDecodableShape {
        /// Description of the error type.
        public let message: String?
        /// Type of error.
        public let type: TemplateErrorType?
        public let violatedEntities: [Entity]?

        public init(message: String? = nil, type: TemplateErrorType? = nil, violatedEntities: [Entity]? = nil) {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
            case violatedEntities = "ViolatedEntities"
        }
    }

    public struct TemplateSourceAnalysis: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// A structure containing information about the dataset references used as placeholders in the template.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct TemplateSourceEntity: AWSEncodableShape {
        /// The source analysis, if it is based on an analysis.
        public let sourceAnalysis: TemplateSourceAnalysis?
        /// The source template, if it is based on an template.
        public let sourceTemplate: TemplateSourceTemplate?

        public init(sourceAnalysis: TemplateSourceAnalysis? = nil, sourceTemplate: TemplateSourceTemplate? = nil) {
            self.sourceAnalysis = sourceAnalysis
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceAnalysis?.validate(name: "\(name).sourceAnalysis")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAnalysis = "SourceAnalysis"
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct TemplateSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct TemplateSummary: AWSDecodableShape {
        /// A summary of a template.
        public let arn: String?
        /// The last time that this template was created.
        public let createdTime: Date?
        /// The last time that this template was updated.
        public let lastUpdatedTime: Date?
        /// A structure containing a list of version numbers for the template summary.
        public let latestVersionNumber: Int64?
        /// A display name for the template.
        public let name: String?
        /// The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let templateId: String?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, latestVersionNumber: Int64? = nil, name: String? = nil, templateId: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case latestVersionNumber = "LatestVersionNumber"
            case name = "Name"
            case templateId = "TemplateId"
        }
    }

    public struct TemplateVersion: AWSDecodableShape {
        /// The time that this template version was created.
        public let createdTime: Date?
        /// Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.
        public let dataSetConfigurations: [DataSetConfiguration]?
        /// The description of the template.
        public let description: String?
        /// Errors associated with this template version.
        public let errors: [TemplateError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The ARN of the theme associated with this version of the template.
        public let themeArn: String?
        /// The version number of the template version.
        public let versionNumber: Int64?

        public init(createdTime: Date? = nil, dataSetConfigurations: [DataSetConfiguration]? = nil, description: String? = nil, errors: [TemplateError]? = nil, sheets: [Sheet]? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, themeArn: String? = nil, versionNumber: Int64? = nil) {
            self.createdTime = createdTime
            self.dataSetConfigurations = dataSetConfigurations
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case dataSetConfigurations = "DataSetConfigurations"
            case description = "Description"
            case errors = "Errors"
            case sheets = "Sheets"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case themeArn = "ThemeArn"
            case versionNumber = "VersionNumber"
        }
    }

    public struct TemplateVersionDefinition: AWSEncodableShape & AWSDecodableShape {
        public let analysisDefaults: AnalysisDefaults?
        /// An array of calculated field definitions for the template.
        public let calculatedFields: [CalculatedField]?
        ///  An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template.
        public let columnConfigurations: [ColumnConfiguration]?
        /// An array of dataset configurations. These configurations define the required columns for each dataset used within a template.
        public let dataSetConfigurations: [DataSetConfiguration]
        /// Filter definitions for a template. For more information, see Filtering Data in the Amazon QuickSight User Guide.
        public let filterGroups: [FilterGroup]?
        /// An array of parameter declarations for a template.  Parameters are named variables that can transfer a value for use by an action or an object. For more information, see Parameters in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterDeclarations: [ParameterDeclaration]?
        /// An array of sheet definitions for a template.
        public let sheets: [SheetDefinition]?

        public init(analysisDefaults: AnalysisDefaults? = nil, calculatedFields: [CalculatedField]? = nil, columnConfigurations: [ColumnConfiguration]? = nil, dataSetConfigurations: [DataSetConfiguration], filterGroups: [FilterGroup]? = nil, parameterDeclarations: [ParameterDeclaration]? = nil, sheets: [SheetDefinition]? = nil) {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetConfigurations = dataSetConfigurations
            self.filterGroups = filterGroups
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }

        public func validate(name: String) throws {
            try self.calculatedFields?.forEach {
                try $0.validate(name: "\(name).calculatedFields[]")
            }
            try self.validate(self.calculatedFields, name: "calculatedFields", parent: name, max: 100)
            try self.columnConfigurations?.forEach {
                try $0.validate(name: "\(name).columnConfigurations[]")
            }
            try self.validate(self.columnConfigurations, name: "columnConfigurations", parent: name, max: 200)
            try self.dataSetConfigurations.forEach {
                try $0.validate(name: "\(name).dataSetConfigurations[]")
            }
            try self.validate(self.dataSetConfigurations, name: "dataSetConfigurations", parent: name, max: 30)
            try self.filterGroups?.forEach {
                try $0.validate(name: "\(name).filterGroups[]")
            }
            try self.validate(self.filterGroups, name: "filterGroups", parent: name, max: 2000)
            try self.parameterDeclarations?.forEach {
                try $0.validate(name: "\(name).parameterDeclarations[]")
            }
            try self.validate(self.parameterDeclarations, name: "parameterDeclarations", parent: name, max: 200)
            try self.sheets?.forEach {
                try $0.validate(name: "\(name).sheets[]")
            }
            try self.validate(self.sheets, name: "sheets", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisDefaults = "AnalysisDefaults"
            case calculatedFields = "CalculatedFields"
            case columnConfigurations = "ColumnConfigurations"
            case dataSetConfigurations = "DataSetConfigurations"
            case filterGroups = "FilterGroups"
            case parameterDeclarations = "ParameterDeclarations"
            case sheets = "Sheets"
        }
    }

    public struct TemplateVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the template version.
        public let arn: String?
        /// The time that this template version was created.
        public let createdTime: Date?
        /// The description of the template version.
        public let description: String?
        /// The status of the template version.
        public let status: ResourceStatus?
        /// The version number of the template version.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct TeradataParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct TextAreaControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the placeholder options in a text area control.
        public let placeholderOptions: TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(placeholderOptions: TextControlPlaceholderOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case placeholderOptions = "PlaceholderOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct TextConditionalFormat: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting for the text background color.
        public let backgroundColor: ConditionalFormattingColor?
        /// The conditional formatting for the icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting for the text color.
        public let textColor: ConditionalFormattingColor?

        public init(backgroundColor: ConditionalFormattingColor? = nil, icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.backgroundColor = backgroundColor
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.backgroundColor?.validate(name: "\(name).backgroundColor")
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct TextControlPlaceholderOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of the placeholder options in a text control.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct TextFieldControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the placeholder options in a text field control.
        public let placeholderOptions: TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(placeholderOptions: TextControlPlaceholderOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case placeholderOptions = "PlaceholderOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct Theme: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the theme.
        public let arn: String?
        /// The date and time that the theme was created.
        public let createdTime: Date?
        /// The date and time that the theme was last updated.
        public let lastUpdatedTime: Date?
        /// The name that the user gives to the theme.
        public let name: String?
        /// The identifier that the user gives to the theme.
        public let themeId: String?
        /// The type of theme, based on how it was created. Valid values include: QUICKSIGHT and CUSTOM.
        public let type: ThemeType?
        public let version: ThemeVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, themeId: String? = nil, type: ThemeType? = nil, version: ThemeVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.themeId = themeId
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case themeId = "ThemeId"
            case type = "Type"
            case version = "Version"
        }
    }

    public struct ThemeAlias: AWSDecodableShape {
        /// The display name of the theme alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the theme alias.
        public let arn: String?
        /// The version number of the theme alias.
        public let themeVersionNumber: Int64?

        public init(aliasName: String? = nil, arn: String? = nil, themeVersionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.themeVersionNumber = themeVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct ThemeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Color properties that apply to chart data colors.
        public let dataColorPalette: DataColorPalette?
        /// Display options related to sheets.
        public let sheet: SheetStyle?
        public let typography: Typography?
        /// Color properties that apply to the UI and to charts, excluding the colors that apply to data.
        public let uiColorPalette: UIColorPalette?

        public init(dataColorPalette: DataColorPalette? = nil, sheet: SheetStyle? = nil, typography: Typography? = nil, uiColorPalette: UIColorPalette? = nil) {
            self.dataColorPalette = dataColorPalette
            self.sheet = sheet
            self.typography = typography
            self.uiColorPalette = uiColorPalette
        }

        public func validate(name: String) throws {
            try self.dataColorPalette?.validate(name: "\(name).dataColorPalette")
            try self.typography?.validate(name: "\(name).typography")
            try self.uiColorPalette?.validate(name: "\(name).uiColorPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case dataColorPalette = "DataColorPalette"
            case sheet = "Sheet"
            case typography = "Typography"
            case uiColorPalette = "UIColorPalette"
        }
    }

    public struct ThemeError: AWSDecodableShape {
        /// The error message.
        public let message: String?
        /// The type of error.
        public let type: ThemeErrorType?

        public init(message: String? = nil, type: ThemeErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ThemeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The date and time that this theme was created.
        public let createdTime: Date?
        /// The last date and time that this theme was updated.
        public let lastUpdatedTime: Date?
        /// The latest version number for the theme.
        public let latestVersionNumber: Int64?
        /// the display name for the theme.
        public let name: String?
        /// The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let themeId: String?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, latestVersionNumber: Int64? = nil, name: String? = nil, themeId: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case latestVersionNumber = "LatestVersionNumber"
            case name = "Name"
            case themeId = "ThemeId"
        }
    }

    public struct ThemeVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
        public let baseThemeId: String?
        /// The theme configuration, which contains all the theme display properties.
        public let configuration: ThemeConfiguration?
        /// The date and time that this theme version was created.
        public let createdTime: Date?
        /// The description of the theme.
        public let description: String?
        /// Errors associated with the theme.
        public let errors: [ThemeError]?
        /// The status of the theme version.
        public let status: ResourceStatus?
        /// The version number of the theme.
        public let versionNumber: Int64?

        public init(arn: String? = nil, baseThemeId: String? = nil, configuration: ThemeConfiguration? = nil, createdTime: Date? = nil, description: String? = nil, errors: [ThemeError]? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.createdTime = createdTime
            self.description = description
            self.errors = errors
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case createdTime = "CreatedTime"
            case description = "Description"
            case errors = "Errors"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ThemeVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the theme version.
        public let arn: String?
        /// The date and time that this theme version was created.
        public let createdTime: Date?
        /// The description of the theme version.
        public let description: String?
        /// The status of the theme version.
        public let status: ResourceStatus?
        /// The version number of the theme version.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ThousandSeparatorOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the thousands separator symbol.
        public let symbol: NumericSeparatorSymbol?
        /// Determines the visibility of the thousands separator.
        public let visibility: Visibility?

        public init(symbol: NumericSeparatorSymbol? = nil, visibility: Visibility? = nil) {
            self.symbol = symbol
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case symbol = "Symbol"
            case visibility = "Visibility"
        }
    }

    public struct TileLayoutStyle: AWSEncodableShape & AWSDecodableShape {
        /// The gutter settings that apply between tiles.
        public let gutter: GutterStyle?
        /// The margin settings that apply around the outside edge of sheets.
        public let margin: MarginStyle?

        public init(gutter: GutterStyle? = nil, margin: MarginStyle? = nil) {
            self.gutter = gutter
            self.margin = margin
        }

        private enum CodingKeys: String, CodingKey {
            case gutter = "Gutter"
            case margin = "Margin"
        }
    }

    public struct TileStyle: AWSEncodableShape & AWSDecodableShape {
        /// The border around a tile.
        public let border: BorderStyle?

        public init(border: BorderStyle? = nil) {
            self.border = border
        }

        private enum CodingKeys: String, CodingKey {
            case border = "Border"
        }
    }

    public struct TimeBasedForecastProperties: AWSEncodableShape & AWSDecodableShape {
        /// The lower boundary setup of a forecast computation.
        public let lowerBoundary: Double?
        /// The periods backward setup of a forecast computation.
        public let periodsBackward: Int?
        /// The periods forward setup of a forecast computation.
        public let periodsForward: Int?
        /// The prediction interval setup of a forecast computation.
        public let predictionInterval: Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:    NULL: The input is set to NULL.    NON_NULL: The input is set to a custom value.
        public let seasonality: Int?
        /// The upper boundary setup of a forecast computation.
        public let upperBoundary: Double?

        public init(lowerBoundary: Double? = nil, periodsBackward: Int? = nil, periodsForward: Int? = nil, predictionInterval: Int? = nil, seasonality: Int? = nil, upperBoundary: Double? = nil) {
            self.lowerBoundary = lowerBoundary
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.upperBoundary = upperBoundary
        }

        public func validate(name: String) throws {
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, max: 1000)
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, min: 0)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, max: 1000)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, min: 1)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, max: 95)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, min: 50)
            try self.validate(self.seasonality, name: "seasonality", parent: name, max: 180)
            try self.validate(self.seasonality, name: "seasonality", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBoundary = "LowerBoundary"
            case periodsBackward = "PeriodsBackward"
            case periodsForward = "PeriodsForward"
            case predictionInterval = "PredictionInterval"
            case seasonality = "Seasonality"
            case upperBoundary = "UpperBoundary"
        }
    }

    public struct TimeEqualityFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to Value.
        public let parameterName: String?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?
        /// The value of a TimeEquality filter. This field is mutually exclusive to ParameterName.
        public let value: Date?

        public init(column: ColumnIdentifier, filterId: String, parameterName: String? = nil, timeGranularity: TimeGranularity? = nil, value: Date? = nil) {
            self.column = column
            self.filterId = filterId
            self.parameterName = parameterName
            self.timeGranularity = timeGranularity
            self.value = value
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case filterId = "FilterId"
            case parameterName = "ParameterName"
            case timeGranularity = "TimeGranularity"
            case value = "Value"
        }
    }

    public struct TimeRangeDrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The maximum value for the filter value range.
        public let rangeMaximum: Date
        /// The minimum value for the filter value range.
        public let rangeMinimum: Date
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity

        public init(column: ColumnIdentifier, rangeMaximum: Date, rangeMinimum: Date, timeGranularity: TimeGranularity) {
            self.column = column
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case rangeMaximum = "RangeMaximum"
            case rangeMinimum = "RangeMinimum"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TimeRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The exclude period of the time range filter.
        public let excludePeriodConfiguration: ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public let includeMaximum: Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public let includeMinimum: Bool?
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The maximum value for the filter value range.
        public let rangeMaximumValue: TimeRangeFilterValue?
        /// The minimum value for the filter value range.
        public let rangeMinimumValue: TimeRangeFilterValue?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?

        public init(column: ColumnIdentifier, excludePeriodConfiguration: ExcludePeriodConfiguration? = nil, filterId: String, includeMaximum: Bool? = nil, includeMinimum: Bool? = nil, nullOption: FilterNullOption, rangeMaximumValue: TimeRangeFilterValue? = nil, rangeMinimumValue: TimeRangeFilterValue? = nil, timeGranularity: TimeGranularity? = nil) {
            self.column = column
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximumValue = rangeMaximumValue
            self.rangeMinimumValue = rangeMinimumValue
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.rangeMaximumValue?.validate(name: "\(name).rangeMaximumValue")
            try self.rangeMinimumValue?.validate(name: "\(name).rangeMinimumValue")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case excludePeriodConfiguration = "ExcludePeriodConfiguration"
            case filterId = "FilterId"
            case includeMaximum = "IncludeMaximum"
            case includeMinimum = "IncludeMinimum"
            case nullOption = "NullOption"
            case rangeMaximumValue = "RangeMaximumValue"
            case rangeMinimumValue = "RangeMinimumValue"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TimeRangeFilterValue: AWSEncodableShape & AWSDecodableShape {
        /// The parameter type input value.
        public let parameter: String?
        /// The rolling date input value.
        public let rollingDate: RollingDateConfiguration?
        /// The static input value.
        public let staticValue: Date?

        public init(parameter: String? = nil, rollingDate: RollingDateConfiguration? = nil, staticValue: Date? = nil) {
            self.parameter = parameter
            self.rollingDate = rollingDate
            self.staticValue = staticValue
        }

        public func validate(name: String) throws {
            try self.validate(self.parameter, name: "parameter", parent: name, max: 2048)
            try self.validate(self.parameter, name: "parameter", parent: name, min: 1)
            try self.validate(self.parameter, name: "parameter", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.rollingDate?.validate(name: "\(name).rollingDate")
        }

        private enum CodingKeys: String, CodingKey {
            case parameter = "Parameter"
            case rollingDate = "RollingDate"
            case staticValue = "StaticValue"
        }
    }

    public struct TooltipItem: AWSEncodableShape & AWSDecodableShape {
        /// The tooltip item for the columns that are not part of a field well.
        public let columnTooltipItem: ColumnTooltipItem?
        /// The tooltip item for the fields.
        public let fieldTooltipItem: FieldTooltipItem?

        public init(columnTooltipItem: ColumnTooltipItem? = nil, fieldTooltipItem: FieldTooltipItem? = nil) {
            self.columnTooltipItem = columnTooltipItem
            self.fieldTooltipItem = fieldTooltipItem
        }

        public func validate(name: String) throws {
            try self.columnTooltipItem?.validate(name: "\(name).columnTooltipItem")
            try self.fieldTooltipItem?.validate(name: "\(name).fieldTooltipItem")
        }

        private enum CodingKeys: String, CodingKey {
            case columnTooltipItem = "ColumnTooltipItem"
            case fieldTooltipItem = "FieldTooltipItem"
        }
    }

    public struct TooltipOptions: AWSEncodableShape & AWSDecodableShape {
        /// The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.
        public let fieldBasedTooltip: FieldBasedTooltip?
        /// The selected type for the tooltip. Choose one of the following options:    BASIC: A basic tooltip.    DETAILED: A detailed tooltip.
        public let selectedTooltipType: SelectedTooltipType?
        /// Determines whether or not the tooltip is visible.
        public let tooltipVisibility: Visibility?

        public init(fieldBasedTooltip: FieldBasedTooltip? = nil, selectedTooltipType: SelectedTooltipType? = nil, tooltipVisibility: Visibility? = nil) {
            self.fieldBasedTooltip = fieldBasedTooltip
            self.selectedTooltipType = selectedTooltipType
            self.tooltipVisibility = tooltipVisibility
        }

        public func validate(name: String) throws {
            try self.fieldBasedTooltip?.validate(name: "\(name).fieldBasedTooltip")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldBasedTooltip = "FieldBasedTooltip"
            case selectedTooltipType = "SelectedTooltipType"
            case tooltipVisibility = "TooltipVisibility"
        }
    }

    public struct TopBottomFilter: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation and sort configuration of the top bottom filter.
        public let aggregationSortConfigurations: [AggregationSortConfiguration]
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The number of items to include in the top bottom filter results.
        public let limit: Int?
        /// The parameter whose value should be used for the filter value.
        public let parameterName: String?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?

        public init(aggregationSortConfigurations: [AggregationSortConfiguration], column: ColumnIdentifier, filterId: String, limit: Int? = nil, parameterName: String? = nil, timeGranularity: TimeGranularity? = nil) {
            self.aggregationSortConfigurations = aggregationSortConfigurations
            self.column = column
            self.filterId = filterId
            self.limit = limit
            self.parameterName = parameterName
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.aggregationSortConfigurations.forEach {
                try $0.validate(name: "\(name).aggregationSortConfigurations[]")
            }
            try self.validate(self.aggregationSortConfigurations, name: "aggregationSortConfigurations", parent: name, max: 100)
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationSortConfigurations = "AggregationSortConfigurations"
            case column = "Column"
            case filterId = "FilterId"
            case limit = "Limit"
            case parameterName = "ParameterName"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TopBottomMoversComputation: AWSEncodableShape & AWSDecodableShape {
        /// The category field that is used in a computation.
        public let category: DimensionField
        /// The ID for a computation.
        public let computationId: String
        /// The mover size setup of the top and bottom movers computation.
        public let moverSize: Int?
        /// The name of a computation.
        public let name: String?
        /// The sort order setup of the top and bottom movers computation.
        public let sortOrder: TopBottomSortOrder?
        /// The time field that is used in a computation.
        public let time: DimensionField
        /// The computation type. Choose from the following options:   TOP: Top movers computation.   BOTTOM: Bottom movers computation.
        public let type: TopBottomComputationType
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(category: DimensionField, computationId: String, moverSize: Int? = nil, name: String? = nil, sortOrder: TopBottomSortOrder? = nil, time: DimensionField, type: TopBottomComputationType, value: MeasureField? = nil) {
            self.category = category
            self.computationId = computationId
            self.moverSize = moverSize
            self.name = name
            self.sortOrder = sortOrder
            self.time = time
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.category.validate(name: "\(name).category")
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.moverSize, name: "moverSize", parent: name, max: 20)
            try self.validate(self.moverSize, name: "moverSize", parent: name, min: 1)
            try self.time.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case computationId = "ComputationId"
            case moverSize = "MoverSize"
            case name = "Name"
            case sortOrder = "SortOrder"
            case time = "Time"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct TopBottomRankedComputation: AWSEncodableShape & AWSDecodableShape {
        /// The category field that is used in a computation.
        public let category: DimensionField
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The result size of a top and bottom ranked computation.
        public let resultSize: Int?
        /// The computation type. Choose one of the following options:   TOP: A top ranked computation.   BOTTOM: A bottom ranked computation.
        public let type: TopBottomComputationType
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(category: DimensionField, computationId: String, name: String? = nil, resultSize: Int? = nil, type: TopBottomComputationType, value: MeasureField? = nil) {
            self.category = category
            self.computationId = computationId
            self.name = name
            self.resultSize = resultSize
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.category.validate(name: "\(name).category")
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.resultSize, name: "resultSize", parent: name, max: 20)
            try self.validate(self.resultSize, name: "resultSize", parent: name, min: 1)
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case computationId = "ComputationId"
            case name = "Name"
            case resultSize = "ResultSize"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct TotalAggregationComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The value field that is used in a computation.
        public let value: MeasureField

        public init(computationId: String, name: String? = nil, value: MeasureField) {
            self.computationId = computationId
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case value = "Value"
        }
    }

    public struct TotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The custom label string for the total cells.
        public let customLabel: String?
        /// The placement (start, end) for the total cells.
        public let placement: TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public let scrollStatus: TableTotalsScrollStatus?
        /// Cell styling options for the total cells.
        public let totalCellStyle: TableCellStyle?
        /// The visibility configuration for the total cells.
        public let totalsVisibility: Visibility?

        public init(customLabel: String? = nil, placement: TableTotalsPlacement? = nil, scrollStatus: TableTotalsScrollStatus? = nil, totalCellStyle: TableCellStyle? = nil, totalsVisibility: Visibility? = nil) {
            self.customLabel = customLabel
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
        }

        public func validate(name: String) throws {
            try self.totalCellStyle?.validate(name: "\(name).totalCellStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case placement = "Placement"
            case scrollStatus = "ScrollStatus"
            case totalCellStyle = "TotalCellStyle"
            case totalsVisibility = "TotalsVisibility"
        }
    }

    public struct TreeMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The color field well of a tree map. Values are grouped by aggregations based on group by fields.
        public let colors: [MeasureField]?
        /// The group by field well of a tree map. Values are grouped based on group by fields.
        public let groups: [DimensionField]?
        /// The size field well of a tree map. Values are aggregated based on group by fields.
        public let sizes: [MeasureField]?

        public init(colors: [MeasureField]? = nil, groups: [DimensionField]? = nil, sizes: [MeasureField]? = nil) {
            self.colors = colors
            self.groups = groups
            self.sizes = sizes
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 1)
            try self.groups?.forEach {
                try $0.validate(name: "\(name).groups[]")
            }
            try self.validate(self.groups, name: "groups", parent: name, max: 1)
            try self.sizes?.forEach {
                try $0.validate(name: "\(name).sizes[]")
            }
            try self.validate(self.sizes, name: "sizes", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
            case groups = "Groups"
            case sizes = "Sizes"
        }
    }

    public struct TreeMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options (label text, label visibility) for the colors displayed in a tree map.
        public let colorLabelOptions: ChartAxisLabelOptions?
        /// The color options (gradient color, point of divergence) of a tree map.
        public let colorScale: ColorScale?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: TreeMapFieldWells?
        /// The label options (label text, label visibility) of the groups that are displayed in a tree map.
        public let groupLabelOptions: ChartAxisLabelOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The label options (label text, label visibility) of the sizes that are displayed in a tree map.
        public let sizeLabelOptions: ChartAxisLabelOptions?
        /// The sort configuration of a tree map.
        public let sortConfiguration: TreeMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?

        public init(colorLabelOptions: ChartAxisLabelOptions? = nil, colorScale: ColorScale? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: TreeMapFieldWells? = nil, groupLabelOptions: ChartAxisLabelOptions? = nil, legend: LegendOptions? = nil, sizeLabelOptions: ChartAxisLabelOptions? = nil, sortConfiguration: TreeMapSortConfiguration? = nil, tooltip: TooltipOptions? = nil) {
            self.colorLabelOptions = colorLabelOptions
            self.colorScale = colorScale
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.groupLabelOptions = groupLabelOptions
            self.legend = legend
            self.sizeLabelOptions = sizeLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }

        public func validate(name: String) throws {
            try self.colorLabelOptions?.validate(name: "\(name).colorLabelOptions")
            try self.colorScale?.validate(name: "\(name).colorScale")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.groupLabelOptions?.validate(name: "\(name).groupLabelOptions")
            try self.legend?.validate(name: "\(name).legend")
            try self.sizeLabelOptions?.validate(name: "\(name).sizeLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
        }

        private enum CodingKeys: String, CodingKey {
            case colorLabelOptions = "ColorLabelOptions"
            case colorScale = "ColorScale"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case groupLabelOptions = "GroupLabelOptions"
            case legend = "Legend"
            case sizeLabelOptions = "SizeLabelOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
        }
    }

    public struct TreeMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a tree map.
        public let treeMapAggregatedFieldWells: TreeMapAggregatedFieldWells?

        public init(treeMapAggregatedFieldWells: TreeMapAggregatedFieldWells? = nil) {
            self.treeMapAggregatedFieldWells = treeMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.treeMapAggregatedFieldWells?.validate(name: "\(name).treeMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case treeMapAggregatedFieldWells = "TreeMapAggregatedFieldWells"
        }
    }

    public struct TreeMapSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of groups that are displayed.
        public let treeMapGroupItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public let treeMapSort: [FieldSortOptions]?

        public init(treeMapGroupItemsLimitConfiguration: ItemsLimitConfiguration? = nil, treeMapSort: [FieldSortOptions]? = nil) {
            self.treeMapGroupItemsLimitConfiguration = treeMapGroupItemsLimitConfiguration
            self.treeMapSort = treeMapSort
        }

        public func validate(name: String) throws {
            try self.treeMapSort?.forEach {
                try $0.validate(name: "\(name).treeMapSort[]")
            }
            try self.validate(self.treeMapSort, name: "treeMapSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case treeMapGroupItemsLimitConfiguration = "TreeMapGroupItemsLimitConfiguration"
            case treeMapSort = "TreeMapSort"
        }
    }

    public struct TreeMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: TreeMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: TreeMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct TrendArrowOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the trend arrows.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct TwitterParameters: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of rows to query Twitter.
        public let maxRows: Int
        /// Twitter query string.
        public let query: String

        public init(maxRows: Int, query: String) {
            self.maxRows = maxRows
            self.query = query
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRows, name: "maxRows", parent: name, min: 1)
            try self.validate(self.query, name: "query", parent: name, max: 256)
            try self.validate(self.query, name: "query", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRows = "MaxRows"
            case query = "Query"
        }
    }

    public struct Typography: AWSEncodableShape & AWSDecodableShape {
        /// Determines the list of font families.
        public let fontFamilies: [Font]?

        public init(fontFamilies: [Font]? = nil) {
            self.fontFamilies = fontFamilies
        }

        public func validate(name: String) throws {
            try self.validate(self.fontFamilies, name: "fontFamilies", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case fontFamilies = "FontFamilies"
        }
    }

    public struct UIColorPalette: AWSEncodableShape & AWSDecodableShape {
        /// This color is that applies to selected states and buttons.
        public let accent: String?
        /// The foreground color that applies to any text or other elements that appear over the accent color.
        public let accentForeground: String?
        /// The color that applies to error messages.
        public let danger: String?
        /// The foreground color that applies to any text or other elements that appear over the error color.
        public let dangerForeground: String?
        /// The color that applies to the names of fields that are identified as dimensions.
        public let dimension: String?
        /// The foreground color that applies to any text or other elements that appear over the dimension color.
        public let dimensionForeground: String?
        /// The color that applies to the names of fields that are identified as measures.
        public let measure: String?
        /// The foreground color that applies to any text or other elements that appear over the measure color.
        public let measureForeground: String?
        /// The background color that applies to visuals and other high emphasis UI.
        public let primaryBackground: String?
        /// The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        public let primaryForeground: String?
        /// The background color that applies to the sheet background and sheet controls.
        public let secondaryBackground: String?
        /// The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        public let secondaryForeground: String?
        /// The color that applies to success messages, for example the check mark for a successful download.
        public let success: String?
        /// The foreground color that applies to any text or other elements that appear over the success color.
        public let successForeground: String?
        /// This color that applies to warning and informational messages.
        public let warning: String?
        /// The foreground color that applies to any text or other elements that appear over the warning color.
        public let warningForeground: String?

        public init(accent: String? = nil, accentForeground: String? = nil, danger: String? = nil, dangerForeground: String? = nil, dimension: String? = nil, dimensionForeground: String? = nil, measure: String? = nil, measureForeground: String? = nil, primaryBackground: String? = nil, primaryForeground: String? = nil, secondaryBackground: String? = nil, secondaryForeground: String? = nil, success: String? = nil, successForeground: String? = nil, warning: String? = nil, warningForeground: String? = nil) {
            self.accent = accent
            self.accentForeground = accentForeground
            self.danger = danger
            self.dangerForeground = dangerForeground
            self.dimension = dimension
            self.dimensionForeground = dimensionForeground
            self.measure = measure
            self.measureForeground = measureForeground
            self.primaryBackground = primaryBackground
            self.primaryForeground = primaryForeground
            self.secondaryBackground = secondaryBackground
            self.secondaryForeground = secondaryForeground
            self.success = success
            self.successForeground = successForeground
            self.warning = warning
            self.warningForeground = warningForeground
        }

        public func validate(name: String) throws {
            try self.validate(self.accent, name: "accent", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.accentForeground, name: "accentForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.danger, name: "danger", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dangerForeground, name: "dangerForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dimension, name: "dimension", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dimensionForeground, name: "dimensionForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.measure, name: "measure", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.measureForeground, name: "measureForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.primaryBackground, name: "primaryBackground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.primaryForeground, name: "primaryForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.secondaryBackground, name: "secondaryBackground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.secondaryForeground, name: "secondaryForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.success, name: "success", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.successForeground, name: "successForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.warning, name: "warning", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.warningForeground, name: "warningForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accent = "Accent"
            case accentForeground = "AccentForeground"
            case danger = "Danger"
            case dangerForeground = "DangerForeground"
            case dimension = "Dimension"
            case dimensionForeground = "DimensionForeground"
            case measure = "Measure"
            case measureForeground = "MeasureForeground"
            case primaryBackground = "PrimaryBackground"
            case primaryForeground = "PrimaryForeground"
            case secondaryBackground = "SecondaryBackground"
            case secondaryForeground = "SecondaryForeground"
            case success = "Success"
            case successForeground = "SuccessForeground"
            case warning = "Warning"
            case warningForeground = "WarningForeground"
        }
    }

    public struct UnaggregatedField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the UnaggregatedField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: FormatConfiguration?

        public init(column: ColumnIdentifier, fieldId: String, formatConfiguration: FormatConfiguration? = nil) {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct UniqueValuesComputation: AWSEncodableShape & AWSDecodableShape {
        /// The category field that is used in a computation.
        public let category: DimensionField
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?

        public init(category: DimensionField, computationId: String, name: String? = nil) {
            self.category = category
            self.computationId = computationId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.category.validate(name: "\(name).category")
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case computationId = "ComputationId"
            case name = "Name"
        }
    }

    public struct UntagColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The column that this operation acts on.
        public let columnName: String
        /// The column tags to remove from this column.
        public let tagNames: [ColumnTagName]

        public init(columnName: String, tagNames: [ColumnTagName]) {
            self.columnName = columnName
            self.tagNames = tagNames
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case tagNames = "TagNames"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("keys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The keys of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAccountCustomizationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .querystring("namespace"))
        ]

        /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization
        /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
        public let awsAccountId: String
        /// The namespace that you want to update Amazon QuickSight customizations for.
        public let namespace: String?

        public init(accountCustomization: AccountCustomization, awsAccountId: String, namespace: String? = nil) {
            self.accountCustomization = accountCustomization
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
        }
    }

    public struct UpdateAccountCustomizationResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) for the updated customization for this Amazon Web Services account.
        public let arn: String?
        /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
        public let awsAccountId: String?
        /// The namespace associated with the customization that you're updating.
        public let namespace: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAccountSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID for the Amazon Web Services account that contains the Amazon QuickSight settings that you want to list.
        public let awsAccountId: String
        /// The default namespace for this Amazon Web Services account. Currently, the default is default. Identity and Access Management (IAM) users that register for the first time with Amazon QuickSight provide an email address that becomes associated with the default namespace.
        public let defaultNamespace: String
        /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon Web Services account or Amazon QuickSight subscription.
        public let notificationEmail: String?
        /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubscription request. A False value will allow the account to be deleted.
        public let terminationProtectionEnabled: Bool?

        public init(awsAccountId: String, defaultNamespace: String, notificationEmail: String? = nil, terminationProtectionEnabled: Bool? = nil) {
            self.awsAccountId = awsAccountId
            self.defaultNamespace = defaultNamespace
            self.notificationEmail = notificationEmail
            self.terminationProtectionEnabled = terminationProtectionEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.defaultNamespace, name: "defaultNamespace", parent: name, max: 64)
            try self.validate(self.defaultNamespace, name: "defaultNamespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultNamespace = "DefaultNamespace"
            case notificationEmail = "NotificationEmail"
            case terminationProtectionEnabled = "TerminationProtectionEnabled"
        }
    }

    public struct UpdateAccountSettingsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAnalysisPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the analysis whose permissions you're updating. The ID is part of the analysis URL.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're updating. You must be using the Amazon Web Services account that the analysis is in.
        public let awsAccountId: String
        /// A structure that describes the permissions to add and the principal to add them to.
        public let grantPermissions: [ResourcePermission]?
        /// A structure that describes the permissions to remove and the principal to remove them from.
        public let revokePermissions: [ResourcePermission]?

        public init(analysisId: String, awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateAnalysisPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the analysis that you updated.
        public let analysisArn: String?
        /// The ID of the analysis that you updated permissions for.
        public let analysisId: String?
        /// A structure that describes the principals and the resource-level permissions on an analysis.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisArn: String? = nil, analysisId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisArn = analysisArn
            self.analysisId = analysisId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisArn = "AnalysisArn"
            case analysisId = "AnalysisId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateAnalysisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "analysisId", location: .uri("AnalysisId")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID for the analysis that you're updating. This ID displays in the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis that you're updating.
        public let awsAccountId: String
        /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: AnalysisDefinition?
        /// A descriptive name for the analysis that you're updating. This name displays for the analysis in the Amazon QuickSight console.
        public let name: String
        /// The parameter names and override values that you want to use. An analysis can have  any parameter type, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A source entity to use for the analysis that you're updating. This metadata structure contains details that describe a source template and one or more datasets.
        public let sourceEntity: AnalysisSourceEntity?
        /// The Amazon Resource Name (ARN) for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
        public let themeArn: String?

        public init(analysisId: String, awsAccountId: String, definition: AnalysisDefinition? = nil, name: String, parameters: Parameters? = nil, sourceEntity: AnalysisSourceEntity? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.name = name
            self.parameters = parameters
            self.sourceEntity = sourceEntity
            self.themeArn = themeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case name = "Name"
            case parameters = "Parameters"
            case sourceEntity = "SourceEntity"
            case themeArn = "ThemeArn"
        }
    }

    public struct UpdateAnalysisResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the analysis.
        public let analysisId: String?
        /// The ARN of the analysis that you're updating.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The update status of the last update that was made to the analysis.
        public let updateStatus: ResourceStatus?

        public init(analysisId: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, updateStatus: ResourceStatus? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case requestId = "RequestId"
            case status = "Status"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct UpdateDashboardPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId"))
        ]

        /// The ID of the Amazon Web Services account that contains the dashboard whose permissions you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// Grants link permissions to all users in a defined namespace.
        public let grantLinkPermissions: [ResourcePermission]?
        /// The permissions that you want to grant on this resource.
        public let grantPermissions: [ResourcePermission]?
        /// Revokes link permissions from all users in a defined namespace.
        public let revokeLinkPermissions: [ResourcePermission]?
        /// The permissions that you want to revoke from this resource.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dashboardId: String, grantLinkPermissions: [ResourcePermission]? = nil, grantPermissions: [ResourcePermission]? = nil, revokeLinkPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.grantLinkPermissions = grantLinkPermissions
            self.grantPermissions = grantPermissions
            self.revokeLinkPermissions = revokeLinkPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.grantLinkPermissions?.forEach {
                try $0.validate(name: "\(name).grantLinkPermissions[]")
            }
            try self.validate(self.grantLinkPermissions, name: "grantLinkPermissions", parent: name, max: 2)
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokeLinkPermissions?.forEach {
                try $0.validate(name: "\(name).revokeLinkPermissions[]")
            }
            try self.validate(self.revokeLinkPermissions, name: "revokeLinkPermissions", parent: name, max: 2)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case grantLinkPermissions = "GrantLinkPermissions"
            case grantPermissions = "GrantPermissions"
            case revokeLinkPermissions = "RevokeLinkPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDashboardPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// Updates the permissions of a shared link to an Amazon QuickSight dashboard.
        public let linkSharingConfiguration: LinkSharingConfiguration?
        /// Information about the permissions on the dashboard.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, linkSharingConfiguration: LinkSharingConfiguration? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.linkSharingConfiguration = linkSharingConfiguration
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case linkSharingConfiguration = "LinkSharingConfiguration"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDashboardPublishedVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId")),
            AWSMemberEncoding(label: "versionNumber", location: .uri("VersionNumber"))
        ]

        /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number of the dashboard.
        public let versionNumber: Int64

        public init(awsAccountId: String, dashboardId: String, versionNumber: Int64) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateDashboardPublishedVersionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dashboardId", location: .uri("DashboardId"))
        ]

        /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// Options for publishing the dashboard when you create it:    AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.     AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.     VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
        public let dashboardPublishOptions: DashboardPublishOptions?
        /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: DashboardVersionDefinition?
        /// The display name of the dashboard.
        public let name: String
        /// A structure that contains the parameters of the dashboard. These are parameter overrides for a dashboard. A dashboard can have any type of parameters, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// The entity that you are using as a source when you update the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only update a dashboard from a template, so you use a SourceTemplate entity. If you need to update a dashboard from an analysis, first convert the analysis to a template by using the  CreateTemplate API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region.  Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: DashboardSourceEntity?
        /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that was originally associated with the entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
        public let themeArn: String?
        /// A description for the first version of the dashboard being created.
        public let versionDescription: String?

        public init(awsAccountId: String, dashboardId: String, dashboardPublishOptions: DashboardPublishOptions? = nil, definition: DashboardVersionDefinition? = nil, name: String, parameters: Parameters? = nil, sourceEntity: DashboardSourceEntity? = nil, themeArn: String? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.dashboardPublishOptions = dashboardPublishOptions
            self.definition = definition
            self.name = name
            self.parameters = parameters
            self.sourceEntity = sourceEntity
            self.themeArn = themeArn
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardPublishOptions = "DashboardPublishOptions"
            case definition = "Definition"
            case name = "Name"
            case parameters = "Parameters"
            case sourceEntity = "SourceEntity"
            case themeArn = "ThemeArn"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The creation status of the request.
        public let creationStatus: ResourceStatus?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the dashboard, including the version number.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateDataSetPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset whose permissions you want to update. This ID is unique per
        /// 			Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String
        /// The resource permissions that you want to grant to the dataset.
        public let grantPermissions: [ResourcePermission]?
        /// The resource permissions that you want to revoke from the dataset.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dataSetId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDataSetPermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let dataSetArn: String?
        /// The ID for the dataset whose permissions you want to update. This ID is unique per
        /// 			Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetArn: String? = nil, dataSetId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetArn = dataSetArn
            self.dataSetId = dataSetId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetId = "DataSetId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDataSetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSetId", location: .uri("DataSetId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// The ID for the dataset that you want to update. This ID is unique per Amazon Web Services Region for each
        /// 			Amazon Web Services account.
        public let dataSetId: String
        public let dataSetUsageConfiguration: DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// Indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// The display name for the dataset.
        public let name: String
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]
        /// The row-level security configuration for the data you want to create.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
        public let rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration?

        public init(awsAccountId: String, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, dataSetId: String, dataSetUsageConfiguration: DataSetUsageConfiguration? = nil, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode, logicalTableMap: [String: LogicalTable]? = nil, name: String, physicalTableMap: [String: PhysicalTable], rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration? = nil) {
            self.awsAccountId = awsAccountId
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.dataSetId = dataSetId
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.columnGroups?.forEach {
                try $0.validate(name: "\(name).columnGroups[]")
            }
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, max: 8)
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, min: 1)
            try self.columnLevelPermissionRules?.forEach {
                try $0.validate(name: "\(name).columnLevelPermissionRules[]")
            }
            try self.validate(self.columnLevelPermissionRules, name: "columnLevelPermissionRules", parent: name, min: 1)
            try self.fieldFolders?.forEach {
                try validate($0.key, name: "fieldFolders.key", parent: name, max: 1000)
                try validate($0.key, name: "fieldFolders.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).fieldFolders[\"\($0.key)\"]")
            }
            try self.logicalTableMap?.forEach {
                try validate($0.key, name: "logicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "logicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "logicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).logicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, max: 64)
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.physicalTableMap.forEach {
                try validate($0.key, name: "physicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "physicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "physicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).physicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.physicalTableMap, name: "physicalTableMap", parent: name, max: 32)
            try self.rowLevelPermissionDataSet?.validate(name: "\(name).rowLevelPermissionDataSet")
            try self.rowLevelPermissionTagConfiguration?.validate(name: "\(name).rowLevelPermissionTagConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case dataSetUsageConfiguration = "DataSetUsageConfiguration"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        }
    }

    public struct UpdateDataSetResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionArn: String?
        /// The ID of the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, ingestionArn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.ingestionArn = ingestionArn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case ingestionArn = "IngestionArn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDataSourcePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri("DataSourceId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String
        /// A list of resource permissions that you want to grant on the data source.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions that you want to revoke on the data source.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dataSourceId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDataSourcePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "dataSourceId", location: .uri("DataSourceId"))
        ]

        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The credentials that Amazon QuickSight that uses to connect to your underlying source. Currently,
        /// 			only credentials based on user name and password are supported.
        public let credentials: DataSourceCredentials?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String
        /// The parameters that Amazon QuickSight uses to connect to your underlying source.
        public let dataSourceParameters: DataSourceParameters?
        /// A display name for the data source.
        public let name: String
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying
        /// 			source.
        public let sslProperties: SslProperties?
        /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to
        /// 			your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(awsAccountId: String, credentials: DataSourceCredentials? = nil, dataSourceId: String, dataSourceParameters: DataSourceParameters? = nil, name: String, sslProperties: SslProperties? = nil, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.awsAccountId = awsAccountId
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.name = name
            self.sslProperties = sslProperties
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.credentials?.validate(name: "\(name).credentials")
            try self.dataSourceParameters?.validate(name: "\(name).dataSourceParameters")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case dataSourceParameters = "DataSourceParameters"
            case name = "Name"
            case sslProperties = "SslProperties"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The update status of the data source's last update.
        public let updateStatus: ResourceStatus?

        public init(arn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil, updateStatus: ResourceStatus? = nil) {
            self.arn = arn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case status = "Status"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct UpdateFolderPermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder to update.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The permissions that you want to grant on a resource.
        public let grantPermissions: [ResourcePermission]?
        /// The permissions that you want to revoke from a resource.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, folderId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateFolderPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// Information about the permissions for the folder.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateFolderRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "folderId", location: .uri("FolderId"))
        ]

        /// The ID for the Amazon Web Services account that contains the folder to update.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The name of the folder.
        public let name: String

        public init(awsAccountId: String, folderId: String, name: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateFolderResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "groupName", location: .uri("GroupName")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The description for the group that you want to update.
        public let description: String?
        /// The name of the group that you want to update.
        public let groupName: String
        /// The namespace of the group that you want to update.
        public let namespace: String

        public init(awsAccountId: String, description: String? = nil, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.groupName = groupName
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The name of the group.
        public let group: Group?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateIAMPolicyAssignmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assignmentName", location: .uri("AssignmentName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The name of the assignment, also called a rule. This name must be unique within an Amazon Web Services account.
        public let assignmentName: String
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data
        /// 				source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the
        /// 				data source.
        public let assignmentStatus: AssignmentStatus?
        /// The ID of the Amazon Web Services account that contains the IAM policy assignment.
        public let awsAccountId: String
        /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
        public let identities: [String: [String]]?
        /// The namespace of the assignment.
        public let namespace: String
        /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups
        /// 			specified in this assignment.
        public let policyArn: String?

        public init(assignmentName: String, assignmentStatus: AssignmentStatus? = nil, awsAccountId: String, identities: [String: [String]]? = nil, namespace: String, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.namespace = namespace
            self.policyArn = policyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct UpdateIAMPolicyAssignmentResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the assignment.
        public let assignmentId: String?
        /// The name of the assignment or rule.
        public let assignmentName: String?
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when creating the data
        /// 				source.    DISABLED - This assignment isn't used when creating the data source.    DRAFT - This assignment is an unfinished draft and isn't used when creating the
        /// 				data source.
        public let assignmentStatus: AssignmentStatus?
        /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
        public let identities: [String: [String]]?
        /// The ARN for the IAM policy applied to the Amazon QuickSight users and groups specified in this
        /// 			assignment.
        public let policyArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.identities = identities
            self.policyArn = policyArn
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateIpRestrictionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String
        /// A value that specifies whether IP rules are turned on.
        public let enabled: Bool?
        /// A map that describes the updated IP rules with CIDR ranges and descriptions.
        public let ipRestrictionRuleMap: [String: String]?

        public init(awsAccountId: String, enabled: Bool? = nil, ipRestrictionRuleMap: [String: String]? = nil) {
            self.awsAccountId = awsAccountId
            self.enabled = enabled
            self.ipRestrictionRuleMap = ipRestrictionRuleMap
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.ipRestrictionRuleMap?.forEach {
                try validate($0.key, name: "ipRestrictionRuleMap.key", parent: name, pattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[1-9]))$")
                try validate($0.value, name: "ipRestrictionRuleMap[\"\($0.key)\"]", parent: name, max: 150)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case ipRestrictionRuleMap = "IpRestrictionRuleMap"
        }
    }

    public struct UpdateIpRestrictionResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(awsAccountId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.awsAccountId = awsAccountId
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdatePublicSharingSettingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId"))
        ]

        /// The Amazon Web Services account ID associated with your Amazon QuickSight subscription.
        public let awsAccountId: String
        /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account.
        public let publicSharingEnabled: Bool?

        public init(awsAccountId: String, publicSharingEnabled: Bool? = nil) {
            self.awsAccountId = awsAccountId
            self.publicSharingEnabled = publicSharingEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case publicSharingEnabled = "PublicSharingEnabled"
        }
    }

    public struct UpdatePublicSharingSettingsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateTemplateAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The alias of the template that you want to update. If you name a specific alias, you update
        /// 			the version that the alias points to. You can specify the latest version of the template
        /// 			by providing the keyword $LATEST in the AliasName parameter.
        /// 			The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the template alias that you're updating.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String
        /// The version number of the template.
        public let templateVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, templateId: String, templateVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.templateVersionNumber = templateVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.templateVersionNumber, name: "templateVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct UpdateTemplateAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct UpdateTemplatePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The ID of the Amazon Web Services account that contains the template.
        public let awsAccountId: String
        /// A list of resource permissions to be granted on the template.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions to be revoked from the template.
        public let revokePermissions: [ResourcePermission]?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateTemplatePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String?
        /// The ID for the template.
        public let templateId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, templateArn: String? = nil, templateId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case templateArn = "TemplateArn"
            case templateId = "TemplateId"
        }
    }

    public struct UpdateTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "templateId", location: .uri("TemplateId"))
        ]

        /// The ID of the Amazon Web Services account that contains the template that you're updating.
        public let awsAccountId: String
        /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: TemplateVersionDefinition?
        /// The name for the template.
        public let name: String?
        /// The entity that you are using as a source when you update the template. In
        /// 			SourceEntity, you specify the type of object you're using as source:
        /// 			SourceTemplate for a template or SourceAnalysis for an
        /// 			analysis. Both of these require an Amazon Resource Name (ARN). For
        /// 			SourceTemplate, specify the ARN of the source template. For
        /// 			SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate
        /// 			ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region;.  Use the DataSetReferences entity within SourceTemplate or
        /// 			SourceAnalysis to list the replacement datasets for the placeholders listed
        /// 			in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: TemplateSourceEntity?
        /// The ID for the template.
        public let templateId: String
        /// A description of the current template version that is being updated. Every time you call
        /// 				UpdateTemplate, you create a new version of the template. Each version
        /// 			of the template maintains a description of the version in the
        /// 				VersionDescription field.
        public let versionDescription: String?

        public init(awsAccountId: String, definition: TemplateVersionDefinition? = nil, name: String? = nil, sourceEntity: TemplateSourceEntity? = nil, templateId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.name = name
            self.sourceEntity = sourceEntity
            self.templateId = templateId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case name = "Name"
            case sourceEntity = "SourceEntity"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateTemplateResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the template.
        public let arn: String?
        /// The creation status of the template.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the template.
        public let templateId: String?
        /// The ARN for the template, including the version information of the first version.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case templateId = "TemplateId"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateThemeAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aliasName", location: .uri("AliasName")),
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The name of the theme alias that you want to update.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme alias that you're updating.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String
        /// The version number of the theme that the alias should reference.
        public let themeVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, themeId: String, themeVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.themeVersionNumber = themeVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.themeVersionNumber, name: "themeVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct UpdateThemeAliasResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct UpdateThemePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The ID of the Amazon Web Services account that contains the theme.
        public let awsAccountId: String
        /// A list of resource permissions to be granted for the theme.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions to be revoked from the theme.
        public let revokePermissions: [ResourcePermission]?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateThemePermissionsResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The resulting list of resource permissions for the theme.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the theme.
        public let themeArn: String?
        /// The ID for the theme.
        public let themeId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, themeArn: String? = nil, themeId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.themeArn = themeArn
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
            case themeArn = "ThemeArn"
            case themeId = "ThemeId"
        }
    }

    public struct UpdateThemeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "themeId", location: .uri("ThemeId"))
        ]

        /// The ID of the Amazon Web Services account that contains the theme that you're updating.
        public let awsAccountId: String
        /// The theme ID, defined by Amazon QuickSight, that a custom theme inherits from.
        /// 		All themes initially inherit from a default Amazon QuickSight theme.
        public let baseThemeId: String
        /// The theme configuration, which contains the theme display properties.
        public let configuration: ThemeConfiguration?
        /// The name for the theme.
        public let name: String?
        /// The ID for the theme.
        public let themeId: String
        /// A description of the theme version that you're updating Every time that you call
        /// 				UpdateTheme, you create a new version of the theme. Each version of the
        /// 			theme maintains a description of the version in VersionDescription.
        public let versionDescription: String?

        public init(awsAccountId: String, baseThemeId: String, configuration: ThemeConfiguration? = nil, name: String? = nil, themeId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.name = name
            self.themeId = themeId
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, max: 512)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, min: 1)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case name = "Name"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateThemeResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Resource Name (ARN) for the theme.
        public let arn: String?
        /// The creation status of the theme.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the theme.
        public let themeId: String?
        /// The Amazon Resource Name (ARN) for the new version of the theme.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case status = "Status"
            case themeId = "ThemeId"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "awsAccountId", location: .uri("AwsAccountId")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "userName", location: .uri("UserName"))
        ]

        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
        public let customFederationProviderUrl: String?
        /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:   Create and update data sources   Create and update datasets   Create and update email reports   Subscribe to email reports   A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user.  Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
        public let customPermissionsName: String?
        /// The email address of the user that you want to update.
        public let email: String
        /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.    NONE: This clears all the previously saved external login information for a user. Use the  DescribeUser  API operation to check the external login information.
        public let externalLoginFederationProviderType: String?
        /// The identity ID for a user in the external login provider.
        public let externalLoginId: String?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The Amazon QuickSight role of the user. The role can be one of the
        /// 			following default security cohorts:    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and
        /// 					dashboards.    ADMIN: A user who is an author, who can also manage Amazon QuickSight
        /// 					settings.   The name of the Amazon QuickSight role is invisible to the user except for the console
        /// 	        screens dealing with permissions.
        public let role: UserRole
        /// A flag that you use to indicate that you want to remove all custom permissions from this user. Using this parameter resets the user to the state it was in before a custom permissions profile was applied. This parameter defaults to NULL and it doesn't accept any other value.
        public let unapplyCustomPermissions: Bool?
        /// The Amazon QuickSight user name that you want to update.
        public let userName: String

        public init(awsAccountId: String, customFederationProviderUrl: String? = nil, customPermissionsName: String? = nil, email: String, externalLoginFederationProviderType: String? = nil, externalLoginId: String? = nil, namespace: String, role: UserRole, unapplyCustomPermissions: Bool? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.customFederationProviderUrl = customFederationProviderUrl
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginId = externalLoginId
            self.namespace = namespace
            self.role = role
            self.unapplyCustomPermissions = unapplyCustomPermissions
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, max: 64)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, min: 1)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, pattern: "^[a-zA-Z0-9+=,.@_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customFederationProviderUrl = "CustomFederationProviderUrl"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginId = "ExternalLoginId"
            case role = "Role"
            case unapplyCustomPermissions = "UnapplyCustomPermissions"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "status", location: .statusCode)
        ]

        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon QuickSight user.
        public let user: User?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case user = "User"
        }
    }

    public struct UploadSettings: AWSEncodableShape & AWSDecodableShape {
        /// Whether the file has a header row, or the files each have a header row.
        public let containsHeader: Bool?
        /// The delimiter between values in the file.
        public let delimiter: String?
        /// File format.
        public let format: FileFormat?
        /// A row number to start reading data from.
        public let startFromRow: Int?
        /// Text qualifier.
        public let textQualifier: TextQualifier?

        public init(containsHeader: Bool? = nil, delimiter: String? = nil, format: FileFormat? = nil, startFromRow: Int? = nil, textQualifier: TextQualifier? = nil) {
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.format = format
            self.startFromRow = startFromRow
            self.textQualifier = textQualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.startFromRow, name: "startFromRow", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case format = "Format"
            case startFromRow = "StartFromRow"
            case textQualifier = "TextQualifier"
        }
    }

    public struct User: AWSDecodableShape {
        /// The active status of user. When you create an Amazon QuickSight user thats not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.
        public let active: Bool?
        /// The Amazon Resource Name (ARN) for the user.
        public let arn: String?
        /// The custom permissions profile associated with this user.
        public let customPermissionsName: String?
        /// The user's email address.
        public let email: String?
        /// The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider.
        public let externalLoginFederationProviderType: String?
        /// The URL of the external login provider.
        public let externalLoginFederationProviderUrl: String?
        /// The identity ID for the user in the external login provider.
        public let externalLoginId: String?
        /// The type of identity authentication used by the user.
        public let identityType: IdentityType?
        /// The principal ID of the user.
        public let principalId: String?
        /// The Amazon QuickSight role for the user. The user role can be one of the following:.    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.    ADMIN: A user who is an author, who can also manage Amazon Amazon QuickSight settings.    RESTRICTED_READER: This role isn't currently available for use.    RESTRICTED_AUTHOR: This role isn't currently available for use.
        public let role: UserRole?
        /// The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for UserName is N/A when the value for IdentityType is IAM and the corresponding IAM user is deleted.
        public let userName: String?

        public init(active: Bool? = nil, arn: String? = nil, customPermissionsName: String? = nil, email: String? = nil, externalLoginFederationProviderType: String? = nil, externalLoginFederationProviderUrl: String? = nil, externalLoginId: String? = nil, identityType: IdentityType? = nil, principalId: String? = nil, role: UserRole? = nil, userName: String? = nil) {
            self.active = active
            self.arn = arn
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginFederationProviderUrl = externalLoginFederationProviderUrl
            self.externalLoginId = externalLoginId
            self.identityType = identityType
            self.principalId = principalId
            self.role = role
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case active = "Active"
            case arn = "Arn"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginFederationProviderUrl = "ExternalLoginFederationProviderUrl"
            case externalLoginId = "ExternalLoginId"
            case identityType = "IdentityType"
            case principalId = "PrincipalId"
            case role = "Role"
            case userName = "UserName"
        }
    }

    public struct VisibleRangeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The percent range in the visible range.
        public let percentRange: PercentVisibleRange?

        public init(percentRange: PercentVisibleRange? = nil) {
            self.percentRange = percentRange
        }

        public func validate(name: String) throws {
            try self.percentRange?.validate(name: "\(name).percentRange")
        }

        private enum CodingKeys: String, CodingKey {
            case percentRange = "PercentRange"
        }
    }

    public struct Visual: AWSEncodableShape & AWSDecodableShape {
        /// A bar chart. For more information, see Using bar charts in the Amazon QuickSight User Guide.
        public let barChartVisual: BarChartVisual?
        /// A box plot. For more information, see Using box plots in the Amazon QuickSight User Guide.
        public let boxPlotVisual: BoxPlotVisual?
        /// A combo chart. For more information, see Using combo charts in the Amazon QuickSight User Guide.
        public let comboChartVisual: ComboChartVisual?
        /// A visual that contains custom content. For more information, see Using custom visual content in the Amazon QuickSight User Guide.
        public let customContentVisual: CustomContentVisual?
        /// An empty visual.
        public let emptyVisual: EmptyVisual?
        /// A filled map. For more information, see Creating filled maps in the Amazon QuickSight User Guide.
        public let filledMapVisual: FilledMapVisual?
        /// A funnel chart. For more information, see Using funnel charts in the Amazon QuickSight User Guide.
        public let funnelChartVisual: FunnelChartVisual?
        /// A gauge chart. For more information, see Using gauge charts in the Amazon QuickSight User Guide.
        public let gaugeChartVisual: GaugeChartVisual?
        /// A geospatial map or a points on map visual. For more information, see Creating point maps in the Amazon QuickSight User Guide.
        public let geospatialMapVisual: GeospatialMapVisual?
        /// A heat map. For more information, see Using heat maps in the Amazon QuickSight User Guide.
        public let heatMapVisual: HeatMapVisual?
        /// A histogram. For more information, see Using histograms in the Amazon QuickSight User Guide.
        public let histogramVisual: HistogramVisual?
        /// An insight visual. For more information, see Working with insights in the Amazon QuickSight User Guide.
        public let insightVisual: InsightVisual?
        /// A key performance indicator (KPI). For more information, see Using KPIs in the Amazon QuickSight User Guide.
        public let kpiVisual: KPIVisual?
        /// A line chart. For more information, see Using line charts in the Amazon QuickSight User Guide.
        public let lineChartVisual: LineChartVisual?
        /// A pie or donut chart. For more information, see Using pie charts in the Amazon QuickSight User Guide.
        public let pieChartVisual: PieChartVisual?
        /// A pivot table. For more information, see Using pivot tables in the Amazon QuickSight User Guide.
        public let pivotTableVisual: PivotTableVisual?
        /// A sankey diagram. For more information, see Using Sankey diagrams in the Amazon QuickSight User Guide.
        public let sankeyDiagramVisual: SankeyDiagramVisual?
        /// A scatter plot. For more information, see Using scatter plots in the Amazon QuickSight User Guide.
        public let scatterPlotVisual: ScatterPlotVisual?
        /// A table visual. For more information, see Using tables as visuals in the Amazon QuickSight User Guide.
        public let tableVisual: TableVisual?
        /// A tree map. For more information, see Using tree maps in the Amazon QuickSight User Guide.
        public let treeMapVisual: TreeMapVisual?
        /// A waterfall chart. For more information, see Using waterfall charts in the Amazon QuickSight User Guide.
        public let waterfallVisual: WaterfallVisual?
        /// A word cloud. For more information, see Using word clouds in the Amazon QuickSight User Guide.
        public let wordCloudVisual: WordCloudVisual?

        public init(barChartVisual: BarChartVisual? = nil, boxPlotVisual: BoxPlotVisual? = nil, comboChartVisual: ComboChartVisual? = nil, customContentVisual: CustomContentVisual? = nil, emptyVisual: EmptyVisual? = nil, filledMapVisual: FilledMapVisual? = nil, funnelChartVisual: FunnelChartVisual? = nil, gaugeChartVisual: GaugeChartVisual? = nil, geospatialMapVisual: GeospatialMapVisual? = nil, heatMapVisual: HeatMapVisual? = nil, histogramVisual: HistogramVisual? = nil, insightVisual: InsightVisual? = nil, kpiVisual: KPIVisual? = nil, lineChartVisual: LineChartVisual? = nil, pieChartVisual: PieChartVisual? = nil, pivotTableVisual: PivotTableVisual? = nil, sankeyDiagramVisual: SankeyDiagramVisual? = nil, scatterPlotVisual: ScatterPlotVisual? = nil, tableVisual: TableVisual? = nil, treeMapVisual: TreeMapVisual? = nil, waterfallVisual: WaterfallVisual? = nil, wordCloudVisual: WordCloudVisual? = nil) {
            self.barChartVisual = barChartVisual
            self.boxPlotVisual = boxPlotVisual
            self.comboChartVisual = comboChartVisual
            self.customContentVisual = customContentVisual
            self.emptyVisual = emptyVisual
            self.filledMapVisual = filledMapVisual
            self.funnelChartVisual = funnelChartVisual
            self.gaugeChartVisual = gaugeChartVisual
            self.geospatialMapVisual = geospatialMapVisual
            self.heatMapVisual = heatMapVisual
            self.histogramVisual = histogramVisual
            self.insightVisual = insightVisual
            self.kpiVisual = kpiVisual
            self.lineChartVisual = lineChartVisual
            self.pieChartVisual = pieChartVisual
            self.pivotTableVisual = pivotTableVisual
            self.sankeyDiagramVisual = sankeyDiagramVisual
            self.scatterPlotVisual = scatterPlotVisual
            self.tableVisual = tableVisual
            self.treeMapVisual = treeMapVisual
            self.waterfallVisual = waterfallVisual
            self.wordCloudVisual = wordCloudVisual
        }

        public func validate(name: String) throws {
            try self.barChartVisual?.validate(name: "\(name).barChartVisual")
            try self.boxPlotVisual?.validate(name: "\(name).boxPlotVisual")
            try self.comboChartVisual?.validate(name: "\(name).comboChartVisual")
            try self.customContentVisual?.validate(name: "\(name).customContentVisual")
            try self.emptyVisual?.validate(name: "\(name).emptyVisual")
            try self.filledMapVisual?.validate(name: "\(name).filledMapVisual")
            try self.funnelChartVisual?.validate(name: "\(name).funnelChartVisual")
            try self.gaugeChartVisual?.validate(name: "\(name).gaugeChartVisual")
            try self.geospatialMapVisual?.validate(name: "\(name).geospatialMapVisual")
            try self.heatMapVisual?.validate(name: "\(name).heatMapVisual")
            try self.histogramVisual?.validate(name: "\(name).histogramVisual")
            try self.insightVisual?.validate(name: "\(name).insightVisual")
            try self.kpiVisual?.validate(name: "\(name).kpiVisual")
            try self.lineChartVisual?.validate(name: "\(name).lineChartVisual")
            try self.pieChartVisual?.validate(name: "\(name).pieChartVisual")
            try self.pivotTableVisual?.validate(name: "\(name).pivotTableVisual")
            try self.sankeyDiagramVisual?.validate(name: "\(name).sankeyDiagramVisual")
            try self.scatterPlotVisual?.validate(name: "\(name).scatterPlotVisual")
            try self.tableVisual?.validate(name: "\(name).tableVisual")
            try self.treeMapVisual?.validate(name: "\(name).treeMapVisual")
            try self.waterfallVisual?.validate(name: "\(name).waterfallVisual")
            try self.wordCloudVisual?.validate(name: "\(name).wordCloudVisual")
        }

        private enum CodingKeys: String, CodingKey {
            case barChartVisual = "BarChartVisual"
            case boxPlotVisual = "BoxPlotVisual"
            case comboChartVisual = "ComboChartVisual"
            case customContentVisual = "CustomContentVisual"
            case emptyVisual = "EmptyVisual"
            case filledMapVisual = "FilledMapVisual"
            case funnelChartVisual = "FunnelChartVisual"
            case gaugeChartVisual = "GaugeChartVisual"
            case geospatialMapVisual = "GeospatialMapVisual"
            case heatMapVisual = "HeatMapVisual"
            case histogramVisual = "HistogramVisual"
            case insightVisual = "InsightVisual"
            case kpiVisual = "KPIVisual"
            case lineChartVisual = "LineChartVisual"
            case pieChartVisual = "PieChartVisual"
            case pivotTableVisual = "PivotTableVisual"
            case sankeyDiagramVisual = "SankeyDiagramVisual"
            case scatterPlotVisual = "ScatterPlotVisual"
            case tableVisual = "TableVisual"
            case treeMapVisual = "TreeMapVisual"
            case waterfallVisual = "WaterfallVisual"
            case wordCloudVisual = "WordCloudVisual"
        }
    }

    public struct VisualCustomAction: AWSEncodableShape & AWSDecodableShape {
        /// A list of VisualCustomActionOperations. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        public let actionOperations: [VisualCustomActionOperation]
        /// The ID of the VisualCustomAction.
        public let customActionId: String
        /// The name of the VisualCustomAction.
        public let name: String
        /// The status of the VisualCustomAction.
        public let status: WidgetStatus?
        /// The trigger of the VisualCustomAction. Valid values are defined as follows:    DATA_POINT_CLICK: Initiates a custom action by a left pointer click on a data point.    DATA_POINT_MENU: Initiates a custom action by right pointer click from the menu.
        public let trigger: VisualCustomActionTrigger

        public init(actionOperations: [VisualCustomActionOperation], customActionId: String, name: String, status: WidgetStatus? = nil, trigger: VisualCustomActionTrigger) {
            self.actionOperations = actionOperations
            self.customActionId = customActionId
            self.name = name
            self.status = status
            self.trigger = trigger
        }

        public func validate(name: String) throws {
            try self.actionOperations.forEach {
                try $0.validate(name: "\(name).actionOperations[]")
            }
            try self.validate(self.actionOperations, name: "actionOperations", parent: name, max: 2)
            try self.validate(self.actionOperations, name: "actionOperations", parent: name, min: 1)
            try self.validate(self.customActionId, name: "customActionId", parent: name, max: 512)
            try self.validate(self.customActionId, name: "customActionId", parent: name, min: 1)
            try self.validate(self.customActionId, name: "customActionId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionOperations = "ActionOperations"
            case customActionId = "CustomActionId"
            case name = "Name"
            case status = "Status"
            case trigger = "Trigger"
        }
    }

    public struct VisualCustomActionOperation: AWSEncodableShape & AWSDecodableShape {
        /// The filter operation that filters data included in a visual or in an entire sheet.
        public let filterOperation: CustomActionFilterOperation?
        /// The navigation operation that navigates between different sheets in the same analysis.
        public let navigationOperation: CustomActionNavigationOperation?
        /// The set parameter operation that sets parameters in custom action.
        public let setParametersOperation: CustomActionSetParametersOperation?
        /// The URL operation that opens a link to another webpage.
        public let urlOperation: CustomActionURLOperation?

        public init(filterOperation: CustomActionFilterOperation? = nil, navigationOperation: CustomActionNavigationOperation? = nil, setParametersOperation: CustomActionSetParametersOperation? = nil, urlOperation: CustomActionURLOperation? = nil) {
            self.filterOperation = filterOperation
            self.navigationOperation = navigationOperation
            self.setParametersOperation = setParametersOperation
            self.urlOperation = urlOperation
        }

        public func validate(name: String) throws {
            try self.filterOperation?.validate(name: "\(name).filterOperation")
            try self.navigationOperation?.validate(name: "\(name).navigationOperation")
            try self.setParametersOperation?.validate(name: "\(name).setParametersOperation")
            try self.urlOperation?.validate(name: "\(name).urlOperation")
        }

        private enum CodingKeys: String, CodingKey {
            case filterOperation = "FilterOperation"
            case navigationOperation = "NavigationOperation"
            case setParametersOperation = "SetParametersOperation"
            case urlOperation = "URLOperation"
        }
    }

    public struct VisualPalette: AWSEncodableShape & AWSDecodableShape {
        /// The chart color options for the visual palette.
        public let chartColor: String?
        /// The color map options for the visual palette.
        public let colorMap: [DataPathColor]?

        public init(chartColor: String? = nil, colorMap: [DataPathColor]? = nil) {
            self.chartColor = chartColor
            self.colorMap = colorMap
        }

        public func validate(name: String) throws {
            try self.validate(self.chartColor, name: "chartColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.colorMap?.forEach {
                try $0.validate(name: "\(name).colorMap[]")
            }
            try self.validate(self.colorMap, name: "colorMap", parent: name, max: 5000)
        }

        private enum CodingKeys: String, CodingKey {
            case chartColor = "ChartColor"
            case colorMap = "ColorMap"
        }
    }

    public struct VisualSubtitleLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The long text format of the subtitle label, such as plain text or rich text.
        public let formatText: LongFormatText?
        /// The visibility of the subtitle label.
        public let visibility: Visibility?

        public init(formatText: LongFormatText? = nil, visibility: Visibility? = nil) {
            self.formatText = formatText
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.formatText?.validate(name: "\(name).formatText")
        }

        private enum CodingKeys: String, CodingKey {
            case formatText = "FormatText"
            case visibility = "Visibility"
        }
    }

    public struct VisualTitleLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The short text format of the title label, such as plain text or rich text.
        public let formatText: ShortFormatText?
        /// The visibility of the title label.
        public let visibility: Visibility?

        public init(formatText: ShortFormatText? = nil, visibility: Visibility? = nil) {
            self.formatText = formatText
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.formatText?.validate(name: "\(name).formatText")
        }

        private enum CodingKeys: String, CodingKey {
            case formatText = "FormatText"
            case visibility = "Visibility"
        }
    }

    public struct VpcConnectionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the VPC connection.
        public let vpcConnectionArn: String

        public init(vpcConnectionArn: String) {
            self.vpcConnectionArn = vpcConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConnectionArn = "VpcConnectionArn"
        }
    }

    public struct WaterfallChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The breakdown field wells of a waterfall visual.
        public let breakdowns: [DimensionField]?
        /// The category field wells of a waterfall visual.
        public let categories: [DimensionField]?
        /// The value field wells of a waterfall visual.
        public let values: [MeasureField]?

        public init(breakdowns: [DimensionField]? = nil, categories: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.breakdowns = breakdowns
            self.categories = categories
            self.values = values
        }

        public func validate(name: String) throws {
            try self.breakdowns?.forEach {
                try $0.validate(name: "\(name).breakdowns[]")
            }
            try self.validate(self.breakdowns, name: "breakdowns", parent: name, max: 200)
            try self.categories?.forEach {
                try $0.validate(name: "\(name).categories[]")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case breakdowns = "Breakdowns"
            case categories = "Categories"
            case values = "Values"
        }
    }

    public struct WaterfallChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of the category axis.
        public let categoryAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the category axis label.
        public let categoryAxisLabelOptions: ChartAxisLabelOptions?
        /// The data label configuration of a waterfall visual.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a waterfall visual.
        public let fieldWells: WaterfallChartFieldWells?
        /// The legend configuration of a waterfall visual.
        public let legend: LegendOptions?
        /// The options that determine the presentation of the y-axis.
        public let primaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The sort configuration of a waterfall visual.
        public let sortConfiguration: WaterfallChartSortConfiguration?
        /// The visual palette configuration of a waterfall visual.
        public let visualPalette: VisualPalette?
        /// The options that determine the presentation of a waterfall visual.
        public let waterfallChartOptions: WaterfallChartOptions?

        public init(categoryAxisDisplayOptions: AxisDisplayOptions? = nil, categoryAxisLabelOptions: ChartAxisLabelOptions? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: WaterfallChartFieldWells? = nil, legend: LegendOptions? = nil, primaryYAxisDisplayOptions: AxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, sortConfiguration: WaterfallChartSortConfiguration? = nil, visualPalette: VisualPalette? = nil, waterfallChartOptions: WaterfallChartOptions? = nil) {
            self.categoryAxisDisplayOptions = categoryAxisDisplayOptions
            self.categoryAxisLabelOptions = categoryAxisLabelOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.sortConfiguration = sortConfiguration
            self.visualPalette = visualPalette
            self.waterfallChartOptions = waterfallChartOptions
        }

        public func validate(name: String) throws {
            try self.categoryAxisDisplayOptions?.validate(name: "\(name).categoryAxisDisplayOptions")
            try self.categoryAxisLabelOptions?.validate(name: "\(name).categoryAxisLabelOptions")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryAxisDisplayOptions = "CategoryAxisDisplayOptions"
            case categoryAxisLabelOptions = "CategoryAxisLabelOptions"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case legend = "Legend"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case sortConfiguration = "SortConfiguration"
            case visualPalette = "VisualPalette"
            case waterfallChartOptions = "WaterfallChartOptions"
        }
    }

    public struct WaterfallChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a waterfall visual.
        public let waterfallChartAggregatedFieldWells: WaterfallChartAggregatedFieldWells?

        public init(waterfallChartAggregatedFieldWells: WaterfallChartAggregatedFieldWells? = nil) {
            self.waterfallChartAggregatedFieldWells = waterfallChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.waterfallChartAggregatedFieldWells?.validate(name: "\(name).waterfallChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case waterfallChartAggregatedFieldWells = "WaterfallChartAggregatedFieldWells"
        }
    }

    public struct WaterfallChartOptions: AWSEncodableShape & AWSDecodableShape {
        /// This option determines the total bar label of a waterfall visual.
        public let totalBarLabel: String?

        public init(totalBarLabel: String? = nil) {
            self.totalBarLabel = totalBarLabel
        }

        private enum CodingKeys: String, CodingKey {
            case totalBarLabel = "TotalBarLabel"
        }
    }

    public struct WaterfallChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of bar groups that are displayed.
        public let breakdownItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?

        public init(breakdownItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil) {
            self.breakdownItemsLimit = breakdownItemsLimit
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case breakdownItemsLimit = "BreakdownItemsLimit"
            case categorySort = "CategorySort"
        }
    }

    public struct WaterfallVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration for a waterfall visual.
        public let chartConfiguration: WaterfallChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: WaterfallChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct WhatIfPointScenario: AWSEncodableShape & AWSDecodableShape {
        /// The date that you need the forecast results for.
        public let date: Date
        /// The target value that you want to meet for the provided date.
        public let value: Double

        public init(date: Date, value: Double) {
            self.date = date
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case value = "Value"
        }
    }

    public struct WhatIfRangeScenario: AWSEncodableShape & AWSDecodableShape {
        /// The end date in the date range that you need the forecast results for.
        public let endDate: Date
        /// The start date in the date range that you need the forecast results for.
        public let startDate: Date
        /// The target value that you want to meet for the provided date range.
        public let value: Double

        public init(endDate: Date, startDate: Date, value: Double) {
            self.endDate = endDate
            self.startDate = startDate
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case startDate = "StartDate"
            case value = "Value"
        }
    }

    public struct WordCloudAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The group by field well of a word cloud. Values are grouped by group by fields.
        public let groupBy: [DimensionField]?
        /// The size field well of a word cloud. Values are aggregated based on group by fields.
        public let size: [MeasureField]?

        public init(groupBy: [DimensionField]? = nil, size: [MeasureField]? = nil) {
            self.groupBy = groupBy
            self.size = size
        }

        public func validate(name: String) throws {
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 10)
            try self.size?.forEach {
                try $0.validate(name: "\(name).size[]")
            }
            try self.validate(self.size, name: "size", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case size = "Size"
        }
    }

    public struct WordCloudChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options (label text, label visibility, and sort icon visibility) for the word cloud category.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: WordCloudFieldWells?
        /// The sort configuration of a word cloud visual.
        public let sortConfiguration: WordCloudSortConfiguration?
        /// The options for a word cloud visual.
        public let wordCloudOptions: WordCloudOptions?

        public init(categoryLabelOptions: ChartAxisLabelOptions? = nil, fieldWells: WordCloudFieldWells? = nil, sortConfiguration: WordCloudSortConfiguration? = nil, wordCloudOptions: WordCloudOptions? = nil) {
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.sortConfiguration = sortConfiguration
            self.wordCloudOptions = wordCloudOptions
        }

        public func validate(name: String) throws {
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.wordCloudOptions?.validate(name: "\(name).wordCloudOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelOptions = "CategoryLabelOptions"
            case fieldWells = "FieldWells"
            case sortConfiguration = "SortConfiguration"
            case wordCloudOptions = "WordCloudOptions"
        }
    }

    public struct WordCloudFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a word cloud.
        public let wordCloudAggregatedFieldWells: WordCloudAggregatedFieldWells?

        public init(wordCloudAggregatedFieldWells: WordCloudAggregatedFieldWells? = nil) {
            self.wordCloudAggregatedFieldWells = wordCloudAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.wordCloudAggregatedFieldWells?.validate(name: "\(name).wordCloudAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case wordCloudAggregatedFieldWells = "WordCloudAggregatedFieldWells"
        }
    }

    public struct WordCloudOptions: AWSEncodableShape & AWSDecodableShape {
        /// The cloud layout options (fluid, normal) of a word cloud.
        public let cloudLayout: WordCloudCloudLayout?
        /// The length limit of each word from 1-100.
        public let maximumStringLength: Int?
        /// The word casing options (lower_case, existing_case) for the words in a word cloud.
        public let wordCasing: WordCloudWordCasing?
        /// The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.
        public let wordOrientation: WordCloudWordOrientation?
        /// The word padding options (none, small, medium, large) for the words in a word cloud.
        public let wordPadding: WordCloudWordPadding?
        /// The word scaling options (emphasize, normal) for the words in a word cloud.
        public let wordScaling: WordCloudWordScaling?

        public init(cloudLayout: WordCloudCloudLayout? = nil, maximumStringLength: Int? = nil, wordCasing: WordCloudWordCasing? = nil, wordOrientation: WordCloudWordOrientation? = nil, wordPadding: WordCloudWordPadding? = nil, wordScaling: WordCloudWordScaling? = nil) {
            self.cloudLayout = cloudLayout
            self.maximumStringLength = maximumStringLength
            self.wordCasing = wordCasing
            self.wordOrientation = wordOrientation
            self.wordPadding = wordPadding
            self.wordScaling = wordScaling
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumStringLength, name: "maximumStringLength", parent: name, max: 100)
            try self.validate(self.maximumStringLength, name: "maximumStringLength", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudLayout = "CloudLayout"
            case maximumStringLength = "MaximumStringLength"
            case wordCasing = "WordCasing"
            case wordOrientation = "WordOrientation"
            case wordPadding = "WordPadding"
            case wordScaling = "WordScaling"
        }
    }

    public struct WordCloudSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of groups that are displayed in a word cloud.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public let categorySort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
        }
    }

    public struct WordCloudVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: WordCloudChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: WordCloudChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }
}

// MARK: - Errors

/// Error enum for QuickSight
public struct QuickSightErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case concurrentUpdatingException = "ConcurrentUpdatingException"
        case conflictException = "ConflictException"
        case domainNotWhitelistedException = "DomainNotWhitelistedException"
        case identityTypeNotSupportedException = "IdentityTypeNotSupportedException"
        case internalFailureException = "InternalFailureException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case preconditionNotMetException = "PreconditionNotMetException"
        case quickSightUserNotFoundException = "QuickSightUserNotFoundException"
        case resourceExistsException = "ResourceExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceUnavailableException = "ResourceUnavailableException"
        case sessionLifetimeInMinutesInvalidException = "SessionLifetimeInMinutesInvalidException"
        case throttlingException = "ThrottlingException"
        case unsupportedPricingPlanException = "UnsupportedPricingPlanException"
        case unsupportedUserEditionException = "UnsupportedUserEditionException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QuickSight
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don&#39;t have access to this item. The provided credentials couldn&#39;t be
    /// 			validated. You might not be authorized to carry out the request. Make sure that your
    /// 			account is authorized to use the Amazon QuickSight service, that your policies have the
    /// 			correct permissions, and that you are using the correct access keys.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A resource is already in a state that indicates an operation is happening that must complete
    /// 			before a new update can be applied.
    public static var concurrentUpdatingException: Self { .init(.concurrentUpdatingException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// The domain specified isn&#39;t on the allow list. All domains for embedded dashboards must be
    /// 			added to the approved list by an Amazon QuickSight admin.
    public static var domainNotWhitelistedException: Self { .init(.domainNotWhitelistedException) }
    /// The identity type specified isn&#39;t supported. Supported identity types include
    /// 				IAM and QUICKSIGHT.
    public static var identityTypeNotSupportedException: Self { .init(.identityTypeNotSupportedException) }
    /// An internal failure occurred.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// The NextToken value isn&#39;t valid.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// One or more parameters has a value that isn&#39;t valid.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// You don&#39;t have this feature activated for your account. To fix this issue, contact Amazon Web Services support.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// A limit is exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// One or more preconditions aren&#39;t met.
    public static var preconditionNotMetException: Self { .init(.preconditionNotMetException) }
    /// The user with the provided name isn&#39;t found. This error can happen in any operation
    /// 			that requires finding a user based on a provided user name, such as
    /// 				DeleteUser, DescribeUser, and so on.
    public static var quickSightUserNotFoundException: Self { .init(.quickSightUserNotFoundException) }
    /// The resource specified already exists.
    public static var resourceExistsException: Self { .init(.resourceExistsException) }
    /// One or more resources can&#39;t be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This resource is currently unavailable.
    public static var resourceUnavailableException: Self { .init(.resourceUnavailableException) }
    /// The number of minutes specified for the lifetime of a session isn&#39;t valid. The session
    /// 			lifetime must be 15-600 minutes.
    public static var sessionLifetimeInMinutesInvalidException: Self { .init(.sessionLifetimeInMinutesInvalidException) }
    /// Access is throttled.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This error indicates that you are calling an embedding operation in Amazon QuickSight
    /// 			without the required pricing plan on your Amazon Web Services account. Before you can use embedding
    /// 			for anonymous users, a QuickSight administrator needs to add capacity pricing to Amazon QuickSight. You
    /// 		    can do this on the Manage Amazon QuickSight page.  After capacity pricing is added, you can use the   GetDashboardEmbedUrl API operation with the  --identity-type ANONYMOUS option.
    public static var unsupportedPricingPlanException: Self { .init(.unsupportedPricingPlanException) }
    /// This error indicates that you are calling an operation on an Amazon QuickSight
    /// 			subscription where the edition doesn&#39;t include support for that operation. Amazon
    /// 			Amazon QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and
    /// 			capability is available in every edition.
    public static var unsupportedUserEditionException: Self { .init(.unsupportedUserEditionException) }
}

extension QuickSightErrorType: Equatable {
    public static func == (lhs: QuickSightErrorType, rhs: QuickSightErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QuickSightErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
