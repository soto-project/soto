//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension QuickSight {
    // MARK: Enums

    public enum AnalysisErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case columnGeographicRoleMismatch = "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case columnReplacementMissing = "COLUMN_REPLACEMENT_MISSING"
        case columnTypeMismatch = "COLUMN_TYPE_MISMATCH"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case parameterNotFound = "PARAMETER_NOT_FOUND"
        case parameterTypeInvalid = "PARAMETER_TYPE_INVALID"
        case parameterValueIncompatible = "PARAMETER_VALUE_INCOMPATIBLE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysisName = "ANALYSIS_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightUser = "QUICKSIGHT_USER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum AnchorOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case now = "NOW"
        public var description: String { return self.rawValue }
    }

    public enum ArcThickness: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "LARGE"
        case medium = "MEDIUM"
        case small = "SMALL"
        case whole = "WHOLE"
        public var description: String { return self.rawValue }
    }

    public enum ArcThicknessOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "LARGE"
        case medium = "MEDIUM"
        case small = "SMALL"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudformationJson = "CLOUDFORMATION_JSON"
        case quicksightJson = "QUICKSIGHT_JSON"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobAnalysisPropertyToOverride: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobDashboardPropertyToOverride: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobDataSetPropertyToOverride: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobDataSourcePropertyToOverride: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case catalog = "Catalog"
        case clusterId = "ClusterId"
        case dataSetName = "DataSetName"
        case database = "Database"
        case disableSsl = "DisableSsl"
        case domain = "Domain"
        case host = "Host"
        case instanceId = "InstanceId"
        case manifestFileLocation = "ManifestFileLocation"
        case name = "Name"
        case password = "Password"
        case port = "Port"
        case roleArn = "RoleArn"
        case secretArn = "SecretArn"
        case username = "Username"
        case warehouse = "Warehouse"
        case workGroup = "WorkGroup"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobRefreshSchedulePropertyToOverride: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case startAfterDateTime = "StartAfterDateTime"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queuedForImmediateExecution = "QUEUED_FOR_IMMEDIATE_EXECUTION"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobThemePropertyToOverride: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "Name"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleExportJobVPCConnectionPropertyToOverride: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dnsResolvers = "DnsResolvers"
        case name = "Name"
        case roleArn = "RoleArn"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleImportFailureAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case doNothing = "DO_NOTHING"
        case rollback = "ROLLBACK"
        public var description: String { return self.rawValue }
    }

    public enum AssetBundleImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case failedRollbackCompleted = "FAILED_ROLLBACK_COMPLETED"
        case failedRollbackError = "FAILED_ROLLBACK_ERROR"
        case failedRollbackInProgress = "FAILED_ROLLBACK_IN_PROGRESS"
        case inProgress = "IN_PROGRESS"
        case queuedForImmediateExecution = "QUEUED_FOR_IMMEDIATE_EXECUTION"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum AssignmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case draft = "DRAFT"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticationMethodOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activeDirectory = "ACTIVE_DIRECTORY"
        case iamAndQuicksight = "IAM_AND_QUICKSIGHT"
        case iamIdentityCenter = "IAM_IDENTITY_CENTER"
        case iamOnly = "IAM_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum AuthorSpecifiedAggregation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `var` = "VAR"
        case average = "AVERAGE"
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case median = "MEDIAN"
        case min = "MIN"
        case percentile = "PERCENTILE"
        case stdev = "STDEV"
        case stdevp = "STDEVP"
        case sum = "SUM"
        case varp = "VARP"
        public var description: String { return self.rawValue }
    }

    public enum AxisBinding: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case primaryYaxis = "PRIMARY_YAXIS"
        case secondaryYaxis = "SECONDARY_YAXIS"
        public var description: String { return self.rawValue }
    }

    public enum BarChartOrientation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case horizontal = "HORIZONTAL"
        case vertical = "VERTICAL"
        public var description: String { return self.rawValue }
    }

    public enum BarsArrangement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clustered = "CLUSTERED"
        case stacked = "STACKED"
        case stackedPercent = "STACKED_PERCENT"
        public var description: String { return self.rawValue }
    }

    public enum BaseMapStyleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case darkGray = "DARK_GRAY"
        case imagery = "IMAGERY"
        case lightGray = "LIGHT_GRAY"
        case street = "STREET"
        public var description: String { return self.rawValue }
    }

    public enum BoxPlotFillStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case solid = "SOLID"
        case transparent = "TRANSPARENT"
        public var description: String { return self.rawValue }
    }

    public enum CategoricalAggregationFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        public var description: String { return self.rawValue }
    }

    public enum CategoryFilterFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case exact = "EXACT"
        public var description: String { return self.rawValue }
    }

    public enum CategoryFilterMatchOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case doesNotContain = "DOES_NOT_CONTAIN"
        case doesNotEqual = "DOES_NOT_EQUAL"
        case endsWith = "ENDS_WITH"
        case equals = "EQUALS"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum CategoryFilterSelectAllOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case filterAllValues = "FILTER_ALL_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum CategoryFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customFilter = "CUSTOM_FILTER"
        case customFilterList = "CUSTOM_FILTER_LIST"
        case filterList = "FILTER_LIST"
        public var description: String { return self.rawValue }
    }

    public enum ColorFillType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case discrete = "DISCRETE"
        case gradient = "GRADIENT"
        public var description: String { return self.rawValue }
    }

    public enum ColumnDataRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dimension = "DIMENSION"
        case measure = "MEASURE"
        public var description: String { return self.rawValue }
    }

    public enum ColumnDataSubType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixed = "FIXED"
        case float = "FLOAT"
        public var description: String { return self.rawValue }
    }

    public enum ColumnDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datetime = "DATETIME"
        case decimal = "DECIMAL"
        case integer = "INTEGER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ColumnOrderingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case greaterIsBetter = "GREATER_IS_BETTER"
        case lesserIsBetter = "LESSER_IS_BETTER"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum ColumnRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dimension = "DIMENSION"
        case measure = "MEASURE"
        public var description: String { return self.rawValue }
    }

    public enum ColumnTagName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case columnDescription = "COLUMN_DESCRIPTION"
        case columnGeographicRole = "COLUMN_GEOGRAPHIC_ROLE"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case difference = "DIFFERENCE"
        case percent = "PERCENT"
        case percentDifference = "PERCENT_DIFFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum ConditionalFormattingIconDisplayOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iconOnly = "ICON_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum ConditionalFormattingIconSetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bars = "BARS"
        case caretUpMinusDown = "CARET_UP_MINUS_DOWN"
        case checkX = "CHECK_X"
        case flags = "FLAGS"
        case fourColorArrow = "FOUR_COLOR_ARROW"
        case fourGrayArrow = "FOUR_GRAY_ARROW"
        case plusMinus = "PLUS_MINUS"
        case threeCircle = "THREE_CIRCLE"
        case threeColorArrow = "THREE_COLOR_ARROW"
        case threeGrayArrow = "THREE_GRAY_ARROW"
        case threeShape = "THREE_SHAPE"
        public var description: String { return self.rawValue }
    }

    public enum ConstantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case collective = "COLLECTIVE"
        case range = "RANGE"
        case singular = "SINGULAR"
        public var description: String { return self.rawValue }
    }

    public enum CrossDatasetTypes: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allDatasets = "ALL_DATASETS"
        case singleDataset = "SINGLE_DATASET"
        public var description: String { return self.rawValue }
    }

    public enum CustomContentImageScalingConfiguration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case doNotScale = "DO_NOT_SCALE"
        case fitToHeight = "FIT_TO_HEIGHT"
        case fitToWidth = "FIT_TO_WIDTH"
        case scaleToVisual = "SCALE_TO_VISUAL"
        public var description: String { return self.rawValue }
    }

    public enum CustomContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case image = "IMAGE"
        case otherEmbeddedContent = "OTHER_EMBEDDED_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum DashboardBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DashboardErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case columnGeographicRoleMismatch = "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
        case columnReplacementMissing = "COLUMN_REPLACEMENT_MISSING"
        case columnTypeMismatch = "COLUMN_TYPE_MISMATCH"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case parameterNotFound = "PARAMETER_NOT_FOUND"
        case parameterTypeInvalid = "PARAMETER_TYPE_INVALID"
        case parameterValueIncompatible = "PARAMETER_VALUE_INCOMPATIBLE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum DashboardFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dashboardName = "DASHBOARD_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightUser = "QUICKSIGHT_USER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum DashboardUIState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case collapsed = "COLLAPSED"
        case expanded = "EXPANDED"
        public var description: String { return self.rawValue }
    }

    public enum DataLabelContent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case percent = "PERCENT"
        case value = "VALUE"
        case valueAndPercent = "VALUE_AND_PERCENT"
        public var description: String { return self.rawValue }
    }

    public enum DataLabelOverlap: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disableOverlap = "DISABLE_OVERLAP"
        case enableOverlap = "ENABLE_OVERLAP"
        public var description: String { return self.rawValue }
    }

    public enum DataLabelPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottom = "BOTTOM"
        case inside = "INSIDE"
        case left = "LEFT"
        case outside = "OUTSIDE"
        case right = "RIGHT"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum DataSetFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datasetName = "DATASET_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum DataSetImportMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directQuery = "DIRECT_QUERY"
        case spice = "SPICE"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceErrorInfoType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case conflict = "CONFLICT"
        case copySourceNotFound = "COPY_SOURCE_NOT_FOUND"
        case engineVersionNotSupported = "ENGINE_VERSION_NOT_SUPPORTED"
        case genericSqlFailure = "GENERIC_SQL_FAILURE"
        case timeout = "TIMEOUT"
        case unknown = "UNKNOWN"
        case unknownHost = "UNKNOWN_HOST"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datasourceName = "DATASOURCE_NAME"
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case adobeAnalytics = "ADOBE_ANALYTICS"
        case amazonElasticsearch = "AMAZON_ELASTICSEARCH"
        case amazonOpensearch = "AMAZON_OPENSEARCH"
        case athena = "ATHENA"
        case aurora = "AURORA"
        case auroraPostgresql = "AURORA_POSTGRESQL"
        case awsIotAnalytics = "AWS_IOT_ANALYTICS"
        case bigquery = "BIGQUERY"
        case databricks = "DATABRICKS"
        case exasol = "EXASOL"
        case github = "GITHUB"
        case jira = "JIRA"
        case mariadb = "MARIADB"
        case mysql = "MYSQL"
        case oracle = "ORACLE"
        case postgresql = "POSTGRESQL"
        case presto = "PRESTO"
        case redshift = "REDSHIFT"
        case s3 = "S3"
        case salesforce = "SALESFORCE"
        case servicenow = "SERVICENOW"
        case snowflake = "SNOWFLAKE"
        case spark = "SPARK"
        case sqlserver = "SQLSERVER"
        case starburst = "STARBURST"
        case teradata = "TERADATA"
        case timestream = "TIMESTREAM"
        case trino = "TRINO"
        case twitter = "TWITTER"
        public var description: String { return self.rawValue }
    }

    public enum DatasetParameterValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiValued = "MULTI_VALUED"
        case singleValued = "SINGLE_VALUED"
        public var description: String { return self.rawValue }
    }

    public enum DateAggregationFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case min = "MIN"
        public var description: String { return self.rawValue }
    }

    public enum DayOfTheWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum DefaultAggregation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `var` = "VAR"
        case average = "AVERAGE"
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case median = "MEDIAN"
        case min = "MIN"
        case stdev = "STDEV"
        case stdevp = "STDEVP"
        case sum = "SUM"
        case varp = "VARP"
        public var description: String { return self.rawValue }
    }

    public enum DisplayFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case currency = "CURRENCY"
        case date = "DATE"
        case number = "NUMBER"
        case percent = "PERCENT"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum Edition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enterprise = "ENTERPRISE"
        case enterpriseAndQ = "ENTERPRISE_AND_Q"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum EmbeddingIdentityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anonymous = "ANONYMOUS"
        case iam = "IAM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum FileFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clf = "CLF"
        case csv = "CSV"
        case elf = "ELF"
        case json = "JSON"
        case tsv = "TSV"
        case xlsx = "XLSX"
        public var description: String { return self.rawValue }
    }

    public enum FilterClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditionalValueFilter = "CONDITIONAL_VALUE_FILTER"
        case enforcedValueFilter = "ENFORCED_VALUE_FILTER"
        case namedValueFilter = "NAMED_VALUE_FILTER"
        public var description: String { return self.rawValue }
    }

    public enum FilterNullOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allValues = "ALL_VALUES"
        case nonNullsOnly = "NON_NULLS_ONLY"
        case nullsOnly = "NULLS_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case stringEquals = "StringEquals"
        case stringLike = "StringLike"
        public var description: String { return self.rawValue }
    }

    public enum FilterVisualScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allVisuals = "ALL_VISUALS"
        case selectedVisuals = "SELECTED_VISUALS"
        public var description: String { return self.rawValue }
    }

    public enum FolderFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directQuicksightOwner = "DIRECT_QUICKSIGHT_OWNER"
        case directQuicksightSoleOwner = "DIRECT_QUICKSIGHT_SOLE_OWNER"
        case directQuicksightViewerOrOwner = "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
        case folderName = "FOLDER_NAME"
        case parentFolderArn = "PARENT_FOLDER_ARN"
        case quicksightOwner = "QUICKSIGHT_OWNER"
        case quicksightViewerOrOwner = "QUICKSIGHT_VIEWER_OR_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum FolderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case restricted = "RESTRICTED"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum FontDecoration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case underline = "UNDERLINE"
        public var description: String { return self.rawValue }
    }

    public enum FontStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case italic = "ITALIC"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum FontWeightName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bold = "BOLD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum ForecastComputationSeasonality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automatic = "AUTOMATIC"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum FunnelChartMeasureDataLabelStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case percentageByFirstStage = "PERCENTAGE_BY_FIRST_STAGE"
        case percentageByPreviousStage = "PERCENTAGE_BY_PREVIOUS_STAGE"
        case valueAndPercentageByFirstStage = "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE"
        case valueAndPercentageByPreviousStage = "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE"
        case valueOnly = "VALUE_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum GeoSpatialCountryCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case us = "US"
        public var description: String { return self.rawValue }
    }

    public enum GeoSpatialDataRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case city = "CITY"
        case country = "COUNTRY"
        case county = "COUNTY"
        case latitude = "LATITUDE"
        case longitude = "LONGITUDE"
        case postcode = "POSTCODE"
        case state = "STATE"
        public var description: String { return self.rawValue }
    }

    public enum GeospatialSelectedPointStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cluster = "CLUSTER"
        case heatmap = "HEATMAP"
        case point = "POINT"
        public var description: String { return self.rawValue }
    }

    public enum GroupFilterAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case groupName = "GROUP_NAME"
        public var description: String { return self.rawValue }
    }

    public enum GroupFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case startsWith = "StartsWith"
        public var description: String { return self.rawValue }
    }

    public enum HistogramBinType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binCount = "BIN_COUNT"
        case binWidth = "BIN_WIDTH"
        public var description: String { return self.rawValue }
    }

    public enum HorizontalTextAlignment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case center = "CENTER"
        case left = "LEFT"
        case right = "RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum Icon: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arrowDown = "ARROW_DOWN"
        case arrowDownLeft = "ARROW_DOWN_LEFT"
        case arrowDownRight = "ARROW_DOWN_RIGHT"
        case arrowLeft = "ARROW_LEFT"
        case arrowRight = "ARROW_RIGHT"
        case arrowUp = "ARROW_UP"
        case arrowUpLeft = "ARROW_UP_LEFT"
        case arrowUpRight = "ARROW_UP_RIGHT"
        case caretDown = "CARET_DOWN"
        case caretUp = "CARET_UP"
        case checkmark = "CHECKMARK"
        case circle = "CIRCLE"
        case faceDown = "FACE_DOWN"
        case faceFlat = "FACE_FLAT"
        case faceUp = "FACE_UP"
        case flag = "FLAG"
        case minus = "MINUS"
        case oneBar = "ONE_BAR"
        case plus = "PLUS"
        case square = "SQUARE"
        case threeBar = "THREE_BAR"
        case thumbsDown = "THUMBS_DOWN"
        case thumbsUp = "THUMBS_UP"
        case triangle = "TRIANGLE"
        case twoBar = "TWO_BAR"
        case x = "X"
        public var description: String { return self.rawValue }
    }

    public enum IdentityStore: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case iamIdentityCenter = "IAM_IDENTITY_CENTER"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum IngestionErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountCapacityLimitExceeded = "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
        case connectionFailure = "CONNECTION_FAILURE"
        case cursorNotEnabled = "CURSOR_NOT_ENABLED"
        case customerError = "CUSTOMER_ERROR"
        case dataSetDeleted = "DATA_SET_DELETED"
        case dataSetNotSpice = "DATA_SET_NOT_SPICE"
        case dataSetSizeLimitExceeded = "DATA_SET_SIZE_LIMIT_EXCEEDED"
        case dataSourceAuthFailed = "DATA_SOURCE_AUTH_FAILED"
        case dataSourceConnectionFailed = "DATA_SOURCE_CONNECTION_FAILED"
        case dataSourceNotFound = "DATA_SOURCE_NOT_FOUND"
        case dataToleranceException = "DATA_TOLERANCE_EXCEPTION"
        case duplicateColumnNamesFound = "DUPLICATE_COLUMN_NAMES_FOUND"
        case elasticsearchCursorNotEnabled = "ELASTICSEARCH_CURSOR_NOT_ENABLED"
        case failureToAssumeRole = "FAILURE_TO_ASSUME_ROLE"
        case failureToProcessJsonFile = "FAILURE_TO_PROCESS_JSON_FILE"
        case iamRoleNotAvailable = "IAM_ROLE_NOT_AVAILABLE"
        case ingestionCanceled = "INGESTION_CANCELED"
        case ingestionSuperseded = "INGESTION_SUPERSEDED"
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case invalidDataSourceConfig = "INVALID_DATA_SOURCE_CONFIG"
        case invalidDataprepSyntax = "INVALID_DATAPREP_SYNTAX"
        case invalidDateFormat = "INVALID_DATE_FORMAT"
        case iotDataSetFileEmpty = "IOT_DATA_SET_FILE_EMPTY"
        case iotFileNotFound = "IOT_FILE_NOT_FOUND"
        case oauthTokenFailure = "OAUTH_TOKEN_FAILURE"
        case passwordAuthenticationFailure = "PASSWORD_AUTHENTICATION_FAILURE"
        case permissionDenied = "PERMISSION_DENIED"
        case permissionNotFound = "PERMISSION_NOT_FOUND"
        case queryTimeout = "QUERY_TIMEOUT"
        case refreshSuppressedByEdit = "REFRESH_SUPPRESSED_BY_EDIT"
        case rowSizeLimitExceeded = "ROW_SIZE_LIMIT_EXCEEDED"
        case s3FileInaccessible = "S3_FILE_INACCESSIBLE"
        case s3ManifestError = "S3_MANIFEST_ERROR"
        case s3UploadedFileDeleted = "S3_UPLOADED_FILE_DELETED"
        case sourceApiLimitExceededFailure = "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
        case sourceResourceLimitExceeded = "SOURCE_RESOURCE_LIMIT_EXCEEDED"
        case spiceTableNotFound = "SPICE_TABLE_NOT_FOUND"
        case sqlException = "SQL_EXCEPTION"
        case sqlInvalidParameterValue = "SQL_INVALID_PARAMETER_VALUE"
        case sqlNumericOverflow = "SQL_NUMERIC_OVERFLOW"
        case sqlSchemaMismatchError = "SQL_SCHEMA_MISMATCH_ERROR"
        case sqlTableNotFound = "SQL_TABLE_NOT_FOUND"
        case sslCertificateValidationFailure = "SSL_CERTIFICATE_VALIDATION_FAILURE"
        case unresolvableHost = "UNRESOLVABLE_HOST"
        case unroutableHost = "UNROUTABLE_HOST"
        public var description: String { return self.rawValue }
    }

    public enum IngestionRequestSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case manual = "MANUAL"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum IngestionRequestType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edit = "EDIT"
        case fullRefresh = "FULL_REFRESH"
        case incrementalRefresh = "INCREMENTAL_REFRESH"
        case initialIngestion = "INITIAL_INGESTION"
        public var description: String { return self.rawValue }
    }

    public enum IngestionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case initialized = "INITIALIZED"
        case queued = "QUEUED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum IngestionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullRefresh = "FULL_REFRESH"
        case incrementalRefresh = "INCREMENTAL_REFRESH"
        public var description: String { return self.rawValue }
    }

    public enum InputColumnDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bit = "BIT"
        case boolean = "BOOLEAN"
        case datetime = "DATETIME"
        case decimal = "DECIMAL"
        case integer = "INTEGER"
        case json = "JSON"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum JoinType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inner = "INNER"
        case left = "LEFT"
        case outer = "OUTER"
        case right = "RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum KPISparklineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case area = "AREA"
        case line = "LINE"
        public var description: String { return self.rawValue }
    }

    public enum KPIVisualStandardLayoutType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case classic = "CLASSIC"
        case vertical = "VERTICAL"
        public var description: String { return self.rawValue }
    }

    public enum LayoutElementType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case filterControl = "FILTER_CONTROL"
        case parameterControl = "PARAMETER_CONTROL"
        case textBox = "TEXT_BOX"
        case visual = "VISUAL"
        public var description: String { return self.rawValue }
    }

    public enum LegendPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case bottom = "BOTTOM"
        case right = "RIGHT"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum LineChartLineStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dashed = "DASHED"
        case dotted = "DOTTED"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum LineChartMarkerShape: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case circle = "CIRCLE"
        case diamond = "DIAMOND"
        case roundedSquare = "ROUNDED_SQUARE"
        case square = "SQUARE"
        case triangle = "TRIANGLE"
        public var description: String { return self.rawValue }
    }

    public enum LineChartType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case area = "AREA"
        case line = "LINE"
        case stackedArea = "STACKED_AREA"
        public var description: String { return self.rawValue }
    }

    public enum LineInterpolation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linear = "LINEAR"
        case smooth = "SMOOTH"
        case stepped = "STEPPED"
        public var description: String { return self.rawValue }
    }

    public enum LookbackWindowSizeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        case hour = "HOUR"
        case week = "WEEK"
        public var description: String { return self.rawValue }
    }

    public enum MapZoomMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    public enum MaximumMinimumComputationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        public var description: String { return self.rawValue }
    }

    public enum MemberType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysis = "ANALYSIS"
        case dashboard = "DASHBOARD"
        case dataset = "DATASET"
        case datasource = "DATASOURCE"
        case topic = "TOPIC"
        public var description: String { return self.rawValue }
    }

    public enum MissingDataTreatmentOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case interpolate = "INTERPOLATE"
        case showAsBlank = "SHOW_AS_BLANK"
        case showAsZero = "SHOW_AS_ZERO"
        public var description: String { return self.rawValue }
    }

    public enum NamedEntityAggType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `var` = "VAR"
        case average = "AVERAGE"
        case count = "COUNT"
        case custom = "CUSTOM"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case median = "MEDIAN"
        case min = "MIN"
        case percentile = "PERCENTILE"
        case stdev = "STDEV"
        case stdevp = "STDEVP"
        case sum = "SUM"
        case varp = "VARP"
        public var description: String { return self.rawValue }
    }

    public enum NamedFilterAggType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `var` = "VAR"
        case average = "AVERAGE"
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case median = "MEDIAN"
        case min = "MIN"
        case noAggregation = "NO_AGGREGATION"
        case stdev = "STDEV"
        case stdevp = "STDEVP"
        case sum = "SUM"
        case varp = "VARP"
        public var description: String { return self.rawValue }
    }

    public enum NamedFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case categoryFilter = "CATEGORY_FILTER"
        case dateRangeFilter = "DATE_RANGE_FILTER"
        case numericEqualityFilter = "NUMERIC_EQUALITY_FILTER"
        case numericRangeFilter = "NUMERIC_RANGE_FILTER"
        case relativeDateFilter = "RELATIVE_DATE_FILTER"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case permissionDenied = "PERMISSION_DENIED"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case creating = "CREATING"
        case deleting = "DELETING"
        case nonRetryableFailure = "NON_RETRYABLE_FAILURE"
        case retryableFailure = "RETRYABLE_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum NegativeValueDisplayMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case negative = "NEGATIVE"
        case positive = "POSITIVE"
        public var description: String { return self.rawValue }
    }

    public enum NetworkInterfaceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachmentFailedRollbackFailed = "ATTACHMENT_FAILED_ROLLBACK_FAILED"
        case available = "AVAILABLE"
        case creating = "CREATING"
        case creationFailed = "CREATION_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case deletionFailed = "DELETION_FAILED"
        case deletionScheduled = "DELETION_SCHEDULED"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum NumberScale: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case billions = "BILLIONS"
        case millions = "MILLIONS"
        case none = "NONE"
        case thousands = "THOUSANDS"
        case trillions = "TRILLIONS"
        public var description: String { return self.rawValue }
    }

    public enum NumericEqualityMatchOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case doesNotEqual = "DOES_NOT_EQUAL"
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum NumericFilterSelectAllOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case filterAllValues = "FILTER_ALL_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum NumericSeparatorSymbol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comma = "COMMA"
        case dot = "DOT"
        case space = "SPACE"
        public var description: String { return self.rawValue }
    }

    public enum OtherCategories: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exclude = "EXCLUDE"
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum PanelBorderStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dashed = "DASHED"
        case dotted = "DOTTED"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum PaperOrientation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case landscape = "LANDSCAPE"
        case portrait = "PORTRAIT"
        public var description: String { return self.rawValue }
    }

    public enum PaperSize: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case a0 = "A0"
        case a1 = "A1"
        case a2 = "A2"
        case a3 = "A3"
        case a4 = "A4"
        case a5 = "A5"
        case jisB4 = "JIS_B4"
        case jisB5 = "JIS_B5"
        case usLegal = "US_LEGAL"
        case usLetter = "US_LETTER"
        case usTabloidLedger = "US_TABLOID_LEDGER"
        public var description: String { return self.rawValue }
    }

    public enum ParameterValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiValued = "MULTI_VALUED"
        case singleValued = "SINGLE_VALUED"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableConditionalFormattingScopeRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case field = "FIELD"
        case fieldTotal = "FIELD_TOTAL"
        case grandTotal = "GRAND_TOTAL"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableDataPathType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case countMetricColumn = "COUNT_METRIC_COLUMN"
        case emptyColumnHeader = "EMPTY_COLUMN_HEADER"
        case hierarchyRowsLayoutColumn = "HIERARCHY_ROWS_LAYOUT_COLUMN"
        case multipleRowMetricsColumn = "MULTIPLE_ROW_METRICS_COLUMN"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableFieldCollapseState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case collapsed = "COLLAPSED"
        case expanded = "EXPANDED"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableMetricPlacement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case column = "COLUMN"
        case row = "ROW"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableRowsLayout: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hierarchy = "HIERARCHY"
        case tabular = "TABULAR"
        public var description: String { return self.rawValue }
    }

    public enum PivotTableSubtotalLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case custom = "CUSTOM"
        case last = "LAST"
        public var description: String { return self.rawValue }
    }

    public enum PrimaryValueDisplayType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actual = "ACTUAL"
        case comparison = "COMPARISON"
        case hidden = "HIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum PropertyRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case id = "ID"
        case primary = "PRIMARY"
        public var description: String { return self.rawValue }
    }

    public enum PropertyUsage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dimension = "DIMENSION"
        case inherit = "INHERIT"
        case measure = "MEASURE"
        public var description: String { return self.rawValue }
    }

    public enum RadarChartAxesRangeScale: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case independent = "INDEPENDENT"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum RadarChartShape: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case circle = "CIRCLE"
        case polygon = "POLYGON"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLineLabelHorizontalPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case center = "CENTER"
        case left = "LEFT"
        case right = "RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLineLabelVerticalPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case above = "ABOVE"
        case below = "BELOW"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLinePatternType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dashed = "DASHED"
        case dotted = "DOTTED"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLineSeriesType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bar = "BAR"
        case line = "LINE"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceLineValueLabelRelativePosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterCustomLabel = "AFTER_CUSTOM_LABEL"
        case beforeCustomLabel = "BEFORE_CUSTOM_LABEL"
        public var description: String { return self.rawValue }
    }

    public enum RefreshInterval: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daily = "DAILY"
        case hourly = "HOURLY"
        case minute15 = "MINUTE15"
        case minute30 = "MINUTE30"
        case monthly = "MONTHLY"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum RelativeDateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case last = "LAST"
        case next = "NEXT"
        case now = "NOW"
        case previous = "PREVIOUS"
        case this = "THIS"
        public var description: String { return self.rawValue }
    }

    public enum RelativeFontSize: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case extraLarge = "EXTRA_LARGE"
        case extraSmall = "EXTRA_SMALL"
        case large = "LARGE"
        case medium = "MEDIUM"
        case small = "SMALL"
        public var description: String { return self.rawValue }
    }

    public enum ResizeOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixed = "FIXED"
        case responsive = "RESPONSIVE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case creationSuccessful = "CREATION_SUCCESSFUL"
        case deleted = "DELETED"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum Role: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case admin = "ADMIN"
        case author = "AUTHOR"
        case reader = "READER"
        public var description: String { return self.rawValue }
    }

    public enum RowLevelPermissionFormatVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case version1 = "VERSION_1"
        case version2 = "VERSION_2"
        public var description: String { return self.rawValue }
    }

    public enum RowLevelPermissionPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case denyAccess = "DENY_ACCESS"
        case grantAccess = "GRANT_ACCESS"
        public var description: String { return self.rawValue }
    }

    public enum SectionPageBreakStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SelectAllValueOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allValues = "ALL_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum SelectedFieldOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allFields = "ALL_FIELDS"
        public var description: String { return self.rawValue }
    }

    public enum SelectedTooltipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case detailed = "DETAILED"
        public var description: String { return self.rawValue }
    }

    public enum ServiceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case redshift = "REDSHIFT"
        public var description: String { return self.rawValue }
    }

    public enum SharingModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case namespace = "NAMESPACE"
        public var description: String { return self.rawValue }
    }

    public enum SheetContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case interactive = "INTERACTIVE"
        case paginated = "PAGINATED"
        public var description: String { return self.rawValue }
    }

    public enum SheetControlDateTimePickerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dateRange = "DATE_RANGE"
        case singleValued = "SINGLE_VALUED"
        public var description: String { return self.rawValue }
    }

    public enum SheetControlListType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiSelect = "MULTI_SELECT"
        case singleSelect = "SINGLE_SELECT"
        public var description: String { return self.rawValue }
    }

    public enum SheetControlSliderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case range = "RANGE"
        case singlePoint = "SINGLE_POINT"
        public var description: String { return self.rawValue }
    }

    public enum SimpleAttributeAggregationFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case uniqueValue = "UNIQUE_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum SimpleNumericalAggregationFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `var` = "VAR"
        case average = "AVERAGE"
        case count = "COUNT"
        case distinctCount = "DISTINCT_COUNT"
        case max = "MAX"
        case median = "MEDIAN"
        case min = "MIN"
        case stdev = "STDEV"
        case stdevp = "STDEVP"
        case sum = "SUM"
        case varp = "VARP"
        public var description: String { return self.rawValue }
    }

    public enum SimpleTotalAggregationFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case average = "AVERAGE"
        case max = "MAX"
        case min = "MIN"
        case none = "NONE"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum SingleYAxisOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case primaryYAxis = "PRIMARY_Y_AXIS"
        public var description: String { return self.rawValue }
    }

    public enum SmallMultiplesAxisPlacement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inside = "INSIDE"
        case outside = "OUTSIDE"
        public var description: String { return self.rawValue }
    }

    public enum SmallMultiplesAxisScale: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case independent = "INDEPENDENT"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotFileFormatType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case excel = "EXCEL"
        case pdf = "PDF"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotFileSheetSelectionScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allVisuals = "ALL_VISUALS"
        case selectedVisuals = "SELECTED_VISUALS"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum SortDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum SpecialValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case empty = "EMPTY"
        case null = "NULL"
        case other = "OTHER"
        public var description: String { return self.rawValue }
    }

    public enum StarburstProductType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enterprise = "ENTERPRISE"
        case galaxy = "GALAXY"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StyledCellType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case metricHeader = "METRIC_HEADER"
        case total = "TOTAL"
        case value = "VALUE"
        public var description: String { return self.rawValue }
    }

    public enum TableBorderStyle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case solid = "SOLID"
        public var description: String { return self.rawValue }
    }

    public enum TableCellImageScalingConfiguration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case doNotScale = "DO_NOT_SCALE"
        case fitToCellHeight = "FIT_TO_CELL_HEIGHT"
        case fitToCellWidth = "FIT_TO_CELL_WIDTH"
        public var description: String { return self.rawValue }
    }

    public enum TableFieldIconSetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case link = "LINK"
        public var description: String { return self.rawValue }
    }

    public enum TableOrientation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case horizontal = "HORIZONTAL"
        case vertical = "VERTICAL"
        public var description: String { return self.rawValue }
    }

    public enum TableTotalsPlacement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case end = "END"
        case start = "START"
        public var description: String { return self.rawValue }
    }

    public enum TableTotalsScrollStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pinned = "PINNED"
        case scrolled = "SCROLLED"
        public var description: String { return self.rawValue }
    }

    public enum TargetVisualOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allVisuals = "ALL_VISUALS"
        public var description: String { return self.rawValue }
    }

    public enum TemplateErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case dataSetNotFound = "DATA_SET_NOT_FOUND"
        case internalFailure = "INTERNAL_FAILURE"
        case sourceNotFound = "SOURCE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum TextQualifier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case doubleQuote = "DOUBLE_QUOTE"
        case singleQuote = "SINGLE_QUOTE"
        public var description: String { return self.rawValue }
    }

    public enum TextWrap: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case wrap = "WRAP"
        public var description: String { return self.rawValue }
    }

    public enum ThemeErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum ThemeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case custom = "CUSTOM"
        case quicksight = "QUICKSIGHT"
        public var description: String { return self.rawValue }
    }

    public enum TimeGranularity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        case hour = "HOUR"
        case millisecond = "MILLISECOND"
        case minute = "MINUTE"
        case month = "MONTH"
        case quarter = "QUARTER"
        case second = "SECOND"
        case week = "WEEK"
        case year = "YEAR"
        public var description: String { return self.rawValue }
    }

    public enum TooltipTarget: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bar = "BAR"
        case both = "BOTH"
        case line = "LINE"
        public var description: String { return self.rawValue }
    }

    public enum TooltipTitleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case primaryValue = "PRIMARY_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum TopBottomComputationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottom = "BOTTOM"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum TopBottomSortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case absoluteDifference = "ABSOLUTE_DIFFERENCE"
        case percentDifference = "PERCENT_DIFFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum TopicNumericSeparatorSymbol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comma = "COMMA"
        case dot = "DOT"
        public var description: String { return self.rawValue }
    }

    public enum TopicRefreshStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case initialized = "INITIALIZED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum TopicRelativeDateFilterFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case last = "LAST"
        case next = "NEXT"
        case now = "NOW"
        case previous = "PREVIOUS"
        case this = "THIS"
        public var description: String { return self.rawValue }
    }

    public enum TopicScheduleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daily = "DAILY"
        case hourly = "HOURLY"
        case monthly = "MONTHLY"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum TopicTimeGranularity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        case hour = "HOUR"
        case minute = "MINUTE"
        case month = "MONTH"
        case quarter = "QUARTER"
        case second = "SECOND"
        case week = "WEEK"
        case year = "YEAR"
        public var description: String { return self.rawValue }
    }

    public enum TopicUserExperienceVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case legacy = "LEGACY"
        case newReaderExperience = "NEW_READER_EXPERIENCE"
        public var description: String { return self.rawValue }
    }

    public enum URLTargetConfiguration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case newTab = "NEW_TAB"
        case newWindow = "NEW_WINDOW"
        case sameTab = "SAME_TAB"
        public var description: String { return self.rawValue }
    }

    public enum UndefinedSpecifiedValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case least = "LEAST"
        case most = "MOST"
        public var description: String { return self.rawValue }
    }

    public enum UserRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case admin = "ADMIN"
        case author = "AUTHOR"
        case reader = "READER"
        case restrictedAuthor = "RESTRICTED_AUTHOR"
        case restrictedReader = "RESTRICTED_READER"
        public var description: String { return self.rawValue }
    }

    public enum VPCConnectionAvailabilityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case partiallyAvailable = "PARTIALLY_AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum VPCConnectionResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case creationSuccessful = "CREATION_SUCCESSFUL"
        case deleted = "DELETED"
        case deletionFailed = "DELETION_FAILED"
        case deletionInProgress = "DELETION_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSuccessful = "UPDATE_SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum ValidationStrategyMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lenient = "LENIENT"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum ValueWhenUnsetOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case null = "NULL"
        case recommendedValue = "RECOMMENDED_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum VerticalTextAlignment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case bottom = "BOTTOM"
        case middle = "MIDDLE"
        case top = "TOP"
        public var description: String { return self.rawValue }
    }

    public enum Visibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hidden = "HIDDEN"
        case visible = "VISIBLE"
        public var description: String { return self.rawValue }
    }

    public enum VisualCustomActionTrigger: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataPointClick = "DATA_POINT_CLICK"
        case dataPointMenu = "DATA_POINT_MENU"
        public var description: String { return self.rawValue }
    }

    public enum WidgetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudCloudLayout: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fluid = "FLUID"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordCasing: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case existingCase = "EXISTING_CASE"
        case lowerCase = "LOWER_CASE"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordOrientation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case horizontal = "HORIZONTAL"
        case horizontalAndVertical = "HORIZONTAL_AND_VERTICAL"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordPadding: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "LARGE"
        case medium = "MEDIUM"
        case none = "NONE"
        case small = "SMALL"
        public var description: String { return self.rawValue }
    }

    public enum WordCloudWordScaling: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case emphasize = "EMPHASIZE"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceParameters: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The parameters for OpenSearch.
        case amazonElasticsearchParameters(AmazonElasticsearchParameters)
        /// The parameters for OpenSearch.
        case amazonOpenSearchParameters(AmazonOpenSearchParameters)
        /// The parameters for Amazon Athena.
        case athenaParameters(AthenaParameters)
        /// The parameters for Amazon Aurora MySQL.
        case auroraParameters(AuroraParameters)
        /// The parameters for Amazon Aurora.
        case auroraPostgreSqlParameters(AuroraPostgreSqlParameters)
        /// The parameters for IoT Analytics.
        case awsIotAnalyticsParameters(AwsIotAnalyticsParameters)
        /// The parameters that are required to connect to a Google BigQuery data source.
        case bigQueryParameters(BigQueryParameters)
        /// The parameters that are required to connect to a Databricks data source.
        case databricksParameters(DatabricksParameters)
        /// The parameters for Exasol.
        case exasolParameters(ExasolParameters)
        /// The parameters for Jira.
        case jiraParameters(JiraParameters)
        /// The parameters for MariaDB.
        case mariaDbParameters(MariaDbParameters)
        /// The parameters for MySQL.
        case mySqlParameters(MySqlParameters)
        /// The parameters for Oracle.
        case oracleParameters(OracleParameters)
        /// The parameters for PostgreSQL.
        case postgreSqlParameters(PostgreSqlParameters)
        /// The parameters for Presto.
        case prestoParameters(PrestoParameters)
        /// The parameters for Amazon RDS.
        case rdsParameters(RdsParameters)
        /// The parameters for Amazon Redshift.
        case redshiftParameters(RedshiftParameters)
        /// The parameters for S3.
        case s3Parameters(S3Parameters)
        /// The parameters for ServiceNow.
        case serviceNowParameters(ServiceNowParameters)
        /// The parameters for Snowflake.
        case snowflakeParameters(SnowflakeParameters)
        /// The parameters for Spark.
        case sparkParameters(SparkParameters)
        /// The parameters for SQL Server.
        case sqlServerParameters(SqlServerParameters)
        /// The parameters that are required to connect to a Starburst data source.
        case starburstParameters(StarburstParameters)
        /// The parameters for Teradata.
        case teradataParameters(TeradataParameters)
        /// The parameters that are required to connect to a Trino data source.
        case trinoParameters(TrinoParameters)
        /// The parameters for Twitter.
        case twitterParameters(TwitterParameters)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .amazonElasticsearchParameters:
                let value = try container.decode(AmazonElasticsearchParameters.self, forKey: .amazonElasticsearchParameters)
                self = .amazonElasticsearchParameters(value)
            case .amazonOpenSearchParameters:
                let value = try container.decode(AmazonOpenSearchParameters.self, forKey: .amazonOpenSearchParameters)
                self = .amazonOpenSearchParameters(value)
            case .athenaParameters:
                let value = try container.decode(AthenaParameters.self, forKey: .athenaParameters)
                self = .athenaParameters(value)
            case .auroraParameters:
                let value = try container.decode(AuroraParameters.self, forKey: .auroraParameters)
                self = .auroraParameters(value)
            case .auroraPostgreSqlParameters:
                let value = try container.decode(AuroraPostgreSqlParameters.self, forKey: .auroraPostgreSqlParameters)
                self = .auroraPostgreSqlParameters(value)
            case .awsIotAnalyticsParameters:
                let value = try container.decode(AwsIotAnalyticsParameters.self, forKey: .awsIotAnalyticsParameters)
                self = .awsIotAnalyticsParameters(value)
            case .bigQueryParameters:
                let value = try container.decode(BigQueryParameters.self, forKey: .bigQueryParameters)
                self = .bigQueryParameters(value)
            case .databricksParameters:
                let value = try container.decode(DatabricksParameters.self, forKey: .databricksParameters)
                self = .databricksParameters(value)
            case .exasolParameters:
                let value = try container.decode(ExasolParameters.self, forKey: .exasolParameters)
                self = .exasolParameters(value)
            case .jiraParameters:
                let value = try container.decode(JiraParameters.self, forKey: .jiraParameters)
                self = .jiraParameters(value)
            case .mariaDbParameters:
                let value = try container.decode(MariaDbParameters.self, forKey: .mariaDbParameters)
                self = .mariaDbParameters(value)
            case .mySqlParameters:
                let value = try container.decode(MySqlParameters.self, forKey: .mySqlParameters)
                self = .mySqlParameters(value)
            case .oracleParameters:
                let value = try container.decode(OracleParameters.self, forKey: .oracleParameters)
                self = .oracleParameters(value)
            case .postgreSqlParameters:
                let value = try container.decode(PostgreSqlParameters.self, forKey: .postgreSqlParameters)
                self = .postgreSqlParameters(value)
            case .prestoParameters:
                let value = try container.decode(PrestoParameters.self, forKey: .prestoParameters)
                self = .prestoParameters(value)
            case .rdsParameters:
                let value = try container.decode(RdsParameters.self, forKey: .rdsParameters)
                self = .rdsParameters(value)
            case .redshiftParameters:
                let value = try container.decode(RedshiftParameters.self, forKey: .redshiftParameters)
                self = .redshiftParameters(value)
            case .s3Parameters:
                let value = try container.decode(S3Parameters.self, forKey: .s3Parameters)
                self = .s3Parameters(value)
            case .serviceNowParameters:
                let value = try container.decode(ServiceNowParameters.self, forKey: .serviceNowParameters)
                self = .serviceNowParameters(value)
            case .snowflakeParameters:
                let value = try container.decode(SnowflakeParameters.self, forKey: .snowflakeParameters)
                self = .snowflakeParameters(value)
            case .sparkParameters:
                let value = try container.decode(SparkParameters.self, forKey: .sparkParameters)
                self = .sparkParameters(value)
            case .sqlServerParameters:
                let value = try container.decode(SqlServerParameters.self, forKey: .sqlServerParameters)
                self = .sqlServerParameters(value)
            case .starburstParameters:
                let value = try container.decode(StarburstParameters.self, forKey: .starburstParameters)
                self = .starburstParameters(value)
            case .teradataParameters:
                let value = try container.decode(TeradataParameters.self, forKey: .teradataParameters)
                self = .teradataParameters(value)
            case .trinoParameters:
                let value = try container.decode(TrinoParameters.self, forKey: .trinoParameters)
                self = .trinoParameters(value)
            case .twitterParameters:
                let value = try container.decode(TwitterParameters.self, forKey: .twitterParameters)
                self = .twitterParameters(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .amazonElasticsearchParameters(let value):
                try container.encode(value, forKey: .amazonElasticsearchParameters)
            case .amazonOpenSearchParameters(let value):
                try container.encode(value, forKey: .amazonOpenSearchParameters)
            case .athenaParameters(let value):
                try container.encode(value, forKey: .athenaParameters)
            case .auroraParameters(let value):
                try container.encode(value, forKey: .auroraParameters)
            case .auroraPostgreSqlParameters(let value):
                try container.encode(value, forKey: .auroraPostgreSqlParameters)
            case .awsIotAnalyticsParameters(let value):
                try container.encode(value, forKey: .awsIotAnalyticsParameters)
            case .bigQueryParameters(let value):
                try container.encode(value, forKey: .bigQueryParameters)
            case .databricksParameters(let value):
                try container.encode(value, forKey: .databricksParameters)
            case .exasolParameters(let value):
                try container.encode(value, forKey: .exasolParameters)
            case .jiraParameters(let value):
                try container.encode(value, forKey: .jiraParameters)
            case .mariaDbParameters(let value):
                try container.encode(value, forKey: .mariaDbParameters)
            case .mySqlParameters(let value):
                try container.encode(value, forKey: .mySqlParameters)
            case .oracleParameters(let value):
                try container.encode(value, forKey: .oracleParameters)
            case .postgreSqlParameters(let value):
                try container.encode(value, forKey: .postgreSqlParameters)
            case .prestoParameters(let value):
                try container.encode(value, forKey: .prestoParameters)
            case .rdsParameters(let value):
                try container.encode(value, forKey: .rdsParameters)
            case .redshiftParameters(let value):
                try container.encode(value, forKey: .redshiftParameters)
            case .s3Parameters(let value):
                try container.encode(value, forKey: .s3Parameters)
            case .serviceNowParameters(let value):
                try container.encode(value, forKey: .serviceNowParameters)
            case .snowflakeParameters(let value):
                try container.encode(value, forKey: .snowflakeParameters)
            case .sparkParameters(let value):
                try container.encode(value, forKey: .sparkParameters)
            case .sqlServerParameters(let value):
                try container.encode(value, forKey: .sqlServerParameters)
            case .starburstParameters(let value):
                try container.encode(value, forKey: .starburstParameters)
            case .teradataParameters(let value):
                try container.encode(value, forKey: .teradataParameters)
            case .trinoParameters(let value):
                try container.encode(value, forKey: .trinoParameters)
            case .twitterParameters(let value):
                try container.encode(value, forKey: .twitterParameters)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .amazonElasticsearchParameters(let value):
                try value.validate(name: "\(name).amazonElasticsearchParameters")
            case .amazonOpenSearchParameters(let value):
                try value.validate(name: "\(name).amazonOpenSearchParameters")
            case .athenaParameters(let value):
                try value.validate(name: "\(name).athenaParameters")
            case .auroraParameters(let value):
                try value.validate(name: "\(name).auroraParameters")
            case .auroraPostgreSqlParameters(let value):
                try value.validate(name: "\(name).auroraPostgreSqlParameters")
            case .awsIotAnalyticsParameters(let value):
                try value.validate(name: "\(name).awsIotAnalyticsParameters")
            case .bigQueryParameters(let value):
                try value.validate(name: "\(name).bigQueryParameters")
            case .databricksParameters(let value):
                try value.validate(name: "\(name).databricksParameters")
            case .exasolParameters(let value):
                try value.validate(name: "\(name).exasolParameters")
            case .jiraParameters(let value):
                try value.validate(name: "\(name).jiraParameters")
            case .mariaDbParameters(let value):
                try value.validate(name: "\(name).mariaDbParameters")
            case .mySqlParameters(let value):
                try value.validate(name: "\(name).mySqlParameters")
            case .oracleParameters(let value):
                try value.validate(name: "\(name).oracleParameters")
            case .postgreSqlParameters(let value):
                try value.validate(name: "\(name).postgreSqlParameters")
            case .prestoParameters(let value):
                try value.validate(name: "\(name).prestoParameters")
            case .rdsParameters(let value):
                try value.validate(name: "\(name).rdsParameters")
            case .redshiftParameters(let value):
                try value.validate(name: "\(name).redshiftParameters")
            case .s3Parameters(let value):
                try value.validate(name: "\(name).s3Parameters")
            case .serviceNowParameters(let value):
                try value.validate(name: "\(name).serviceNowParameters")
            case .snowflakeParameters(let value):
                try value.validate(name: "\(name).snowflakeParameters")
            case .sparkParameters(let value):
                try value.validate(name: "\(name).sparkParameters")
            case .sqlServerParameters(let value):
                try value.validate(name: "\(name).sqlServerParameters")
            case .starburstParameters(let value):
                try value.validate(name: "\(name).starburstParameters")
            case .teradataParameters(let value):
                try value.validate(name: "\(name).teradataParameters")
            case .trinoParameters(let value):
                try value.validate(name: "\(name).trinoParameters")
            case .twitterParameters(let value):
                try value.validate(name: "\(name).twitterParameters")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case amazonElasticsearchParameters = "AmazonElasticsearchParameters"
            case amazonOpenSearchParameters = "AmazonOpenSearchParameters"
            case athenaParameters = "AthenaParameters"
            case auroraParameters = "AuroraParameters"
            case auroraPostgreSqlParameters = "AuroraPostgreSqlParameters"
            case awsIotAnalyticsParameters = "AwsIotAnalyticsParameters"
            case bigQueryParameters = "BigQueryParameters"
            case databricksParameters = "DatabricksParameters"
            case exasolParameters = "ExasolParameters"
            case jiraParameters = "JiraParameters"
            case mariaDbParameters = "MariaDbParameters"
            case mySqlParameters = "MySqlParameters"
            case oracleParameters = "OracleParameters"
            case postgreSqlParameters = "PostgreSqlParameters"
            case prestoParameters = "PrestoParameters"
            case rdsParameters = "RdsParameters"
            case redshiftParameters = "RedshiftParameters"
            case s3Parameters = "S3Parameters"
            case serviceNowParameters = "ServiceNowParameters"
            case snowflakeParameters = "SnowflakeParameters"
            case sparkParameters = "SparkParameters"
            case sqlServerParameters = "SqlServerParameters"
            case starburstParameters = "StarburstParameters"
            case teradataParameters = "TeradataParameters"
            case trinoParameters = "TrinoParameters"
            case twitterParameters = "TwitterParameters"
        }
    }

    public enum PhysicalTable: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A physical table type built from the results of the custom SQL query.
        case customSql(CustomSql)
        /// A physical table type for relational data sources.
        case relationalTable(RelationalTable)
        /// A physical table type for as S3 data source.
        case s3Source(S3Source)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customSql:
                let value = try container.decode(CustomSql.self, forKey: .customSql)
                self = .customSql(value)
            case .relationalTable:
                let value = try container.decode(RelationalTable.self, forKey: .relationalTable)
                self = .relationalTable(value)
            case .s3Source:
                let value = try container.decode(S3Source.self, forKey: .s3Source)
                self = .s3Source(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customSql(let value):
                try container.encode(value, forKey: .customSql)
            case .relationalTable(let value):
                try container.encode(value, forKey: .relationalTable)
            case .s3Source(let value):
                try container.encode(value, forKey: .s3Source)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customSql(let value):
                try value.validate(name: "\(name).customSql")
            case .relationalTable(let value):
                try value.validate(name: "\(name).relationalTable")
            case .s3Source(let value):
                try value.validate(name: "\(name).s3Source")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customSql = "CustomSql"
            case relationalTable = "RelationalTable"
            case s3Source = "S3Source"
        }
    }

    public enum TransformOperation: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A transform operation that casts a column to a different type.
        case castColumnTypeOperation(CastColumnTypeOperation)
        /// An operation that creates calculated columns. Columns created in one such operation form a lexical closure.
        case createColumnsOperation(CreateColumnsOperation)
        /// An operation that filters rows based on some condition.
        case filterOperation(FilterOperation)
        case overrideDatasetParameterOperation(OverrideDatasetParameterOperation)
        /// An operation that projects columns. Operations that come after a projection can only refer to projected columns.
        case projectOperation(ProjectOperation)
        /// An operation that renames a column.
        case renameColumnOperation(RenameColumnOperation)
        /// An operation that tags a column with additional information.
        case tagColumnOperation(TagColumnOperation)
        case untagColumnOperation(UntagColumnOperation)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .castColumnTypeOperation:
                let value = try container.decode(CastColumnTypeOperation.self, forKey: .castColumnTypeOperation)
                self = .castColumnTypeOperation(value)
            case .createColumnsOperation:
                let value = try container.decode(CreateColumnsOperation.self, forKey: .createColumnsOperation)
                self = .createColumnsOperation(value)
            case .filterOperation:
                let value = try container.decode(FilterOperation.self, forKey: .filterOperation)
                self = .filterOperation(value)
            case .overrideDatasetParameterOperation:
                let value = try container.decode(OverrideDatasetParameterOperation.self, forKey: .overrideDatasetParameterOperation)
                self = .overrideDatasetParameterOperation(value)
            case .projectOperation:
                let value = try container.decode(ProjectOperation.self, forKey: .projectOperation)
                self = .projectOperation(value)
            case .renameColumnOperation:
                let value = try container.decode(RenameColumnOperation.self, forKey: .renameColumnOperation)
                self = .renameColumnOperation(value)
            case .tagColumnOperation:
                let value = try container.decode(TagColumnOperation.self, forKey: .tagColumnOperation)
                self = .tagColumnOperation(value)
            case .untagColumnOperation:
                let value = try container.decode(UntagColumnOperation.self, forKey: .untagColumnOperation)
                self = .untagColumnOperation(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .castColumnTypeOperation(let value):
                try container.encode(value, forKey: .castColumnTypeOperation)
            case .createColumnsOperation(let value):
                try container.encode(value, forKey: .createColumnsOperation)
            case .filterOperation(let value):
                try container.encode(value, forKey: .filterOperation)
            case .overrideDatasetParameterOperation(let value):
                try container.encode(value, forKey: .overrideDatasetParameterOperation)
            case .projectOperation(let value):
                try container.encode(value, forKey: .projectOperation)
            case .renameColumnOperation(let value):
                try container.encode(value, forKey: .renameColumnOperation)
            case .tagColumnOperation(let value):
                try container.encode(value, forKey: .tagColumnOperation)
            case .untagColumnOperation(let value):
                try container.encode(value, forKey: .untagColumnOperation)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .castColumnTypeOperation(let value):
                try value.validate(name: "\(name).castColumnTypeOperation")
            case .createColumnsOperation(let value):
                try value.validate(name: "\(name).createColumnsOperation")
            case .filterOperation(let value):
                try value.validate(name: "\(name).filterOperation")
            case .overrideDatasetParameterOperation(let value):
                try value.validate(name: "\(name).overrideDatasetParameterOperation")
            case .projectOperation(let value):
                try value.validate(name: "\(name).projectOperation")
            case .renameColumnOperation(let value):
                try value.validate(name: "\(name).renameColumnOperation")
            case .tagColumnOperation(let value):
                try value.validate(name: "\(name).tagColumnOperation")
            case .untagColumnOperation(let value):
                try value.validate(name: "\(name).untagColumnOperation")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case castColumnTypeOperation = "CastColumnTypeOperation"
            case createColumnsOperation = "CreateColumnsOperation"
            case filterOperation = "FilterOperation"
            case overrideDatasetParameterOperation = "OverrideDatasetParameterOperation"
            case projectOperation = "ProjectOperation"
            case renameColumnOperation = "RenameColumnOperation"
            case tagColumnOperation = "TagColumnOperation"
            case untagColumnOperation = "UntagColumnOperation"
        }
    }

    // MARK: Shapes

    public struct AccountCustomization: AWSEncodableShape & AWSDecodableShape {
        /// The default email customization template.
        public let defaultEmailCustomizationTemplate: String?
        /// The default theme for this Amazon QuickSight subscription.
        public let defaultTheme: String?

        public init(defaultEmailCustomizationTemplate: String? = nil, defaultTheme: String? = nil) {
            self.defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplate
            self.defaultTheme = defaultTheme
        }

        private enum CodingKeys: String, CodingKey {
            case defaultEmailCustomizationTemplate = "DefaultEmailCustomizationTemplate"
            case defaultTheme = "DefaultTheme"
        }
    }

    public struct AccountInfo: AWSDecodableShape {
        /// The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.
        public let accountName: String?
        /// The status of your account subscription.
        public let accountSubscriptionStatus: String?
        /// The way that your Amazon QuickSight account is authenticated.
        public let authenticationType: String?
        /// The edition of your Amazon QuickSight account.
        public let edition: Edition?
        /// The Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public let iamIdentityCenterInstanceArn: String?
        /// The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.
        public let notificationEmail: String?

        public init(accountName: String? = nil, accountSubscriptionStatus: String? = nil, authenticationType: String? = nil, edition: Edition? = nil, iamIdentityCenterInstanceArn: String? = nil, notificationEmail: String? = nil) {
            self.accountName = accountName
            self.accountSubscriptionStatus = accountSubscriptionStatus
            self.authenticationType = authenticationType
            self.edition = edition
            self.iamIdentityCenterInstanceArn = iamIdentityCenterInstanceArn
            self.notificationEmail = notificationEmail
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "AccountName"
            case accountSubscriptionStatus = "AccountSubscriptionStatus"
            case authenticationType = "AuthenticationType"
            case edition = "Edition"
            case iamIdentityCenterInstanceArn = "IAMIdentityCenterInstanceArn"
            case notificationEmail = "NotificationEmail"
        }
    }

    public struct AccountSettings: AWSDecodableShape {
        /// The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.
        public let accountName: String?
        /// The default Amazon QuickSight namespace for your Amazon Web Services account.
        public let defaultNamespace: String?
        /// The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.
        public let edition: Edition?
        /// The main notification email for your Amazon QuickSight subscription.
        public let notificationEmail: String?
        /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see UpdatePublicSharingSettings.
        public let publicSharingEnabled: Bool?
        /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubsctiption request. A False value will allow the ccount to be deleted.
        public let terminationProtectionEnabled: Bool?

        public init(accountName: String? = nil, defaultNamespace: String? = nil, edition: Edition? = nil, notificationEmail: String? = nil, publicSharingEnabled: Bool? = nil, terminationProtectionEnabled: Bool? = nil) {
            self.accountName = accountName
            self.defaultNamespace = defaultNamespace
            self.edition = edition
            self.notificationEmail = notificationEmail
            self.publicSharingEnabled = publicSharingEnabled
            self.terminationProtectionEnabled = terminationProtectionEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "AccountName"
            case defaultNamespace = "DefaultNamespace"
            case edition = "Edition"
            case notificationEmail = "NotificationEmail"
            case publicSharingEnabled = "PublicSharingEnabled"
            case terminationProtectionEnabled = "TerminationProtectionEnabled"
        }
    }

    public struct ActiveIAMPolicyAssignment: AWSDecodableShape {
        /// A name for the IAM policy assignment.
        public let assignmentName: String?
        /// The Amazon Resource Name (ARN) of the resource.
        public let policyArn: String?

        public init(assignmentName: String? = nil, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.policyArn = policyArn
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case policyArn = "PolicyArn"
        }
    }

    public struct AdHocFilteringOption: AWSEncodableShape & AWSDecodableShape {
        /// Availability status.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct AggregationFunction: AWSEncodableShape & AWSDecodableShape {
        /// Aggregation for attributes.
        public let attributeAggregationFunction: AttributeAggregationFunction?
        /// Aggregation for categorical values.    COUNT: Aggregate by the total number of values, including duplicates.    DISTINCT_COUNT: Aggregate by the total number of distinct values.
        public let categoricalAggregationFunction: CategoricalAggregationFunction?
        /// Aggregation for date values.    COUNT: Aggregate by the total number of values, including duplicates.    DISTINCT_COUNT: Aggregate by the total number of distinct values.    MIN: Select the smallest date value.    MAX: Select the largest date value.
        public let dateAggregationFunction: DateAggregationFunction?
        /// Aggregation for numerical values.
        public let numericalAggregationFunction: NumericalAggregationFunction?

        public init(attributeAggregationFunction: AttributeAggregationFunction? = nil, categoricalAggregationFunction: CategoricalAggregationFunction? = nil, dateAggregationFunction: DateAggregationFunction? = nil, numericalAggregationFunction: NumericalAggregationFunction? = nil) {
            self.attributeAggregationFunction = attributeAggregationFunction
            self.categoricalAggregationFunction = categoricalAggregationFunction
            self.dateAggregationFunction = dateAggregationFunction
            self.numericalAggregationFunction = numericalAggregationFunction
        }

        public func validate(name: String) throws {
            try self.numericalAggregationFunction?.validate(name: "\(name).numericalAggregationFunction")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeAggregationFunction = "AttributeAggregationFunction"
            case categoricalAggregationFunction = "CategoricalAggregationFunction"
            case dateAggregationFunction = "DateAggregationFunction"
            case numericalAggregationFunction = "NumericalAggregationFunction"
        }
    }

    public struct AggregationSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The function that aggregates the values in Column.
        public let aggregationFunction: AggregationFunction?
        /// The column that determines the sort order of aggregated values.
        public let column: ColumnIdentifier
        /// The sort direction of values.    ASC: Sort in ascending order.    DESC: Sort in descending order.
        public let sortDirection: SortDirection

        public init(aggregationFunction: AggregationFunction? = nil, column: ColumnIdentifier, sortDirection: SortDirection) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.sortDirection = sortDirection
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case sortDirection = "SortDirection"
        }
    }

    public struct AllSheetsFilterScopeConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AmazonElasticsearchParameters: AWSEncodableShape & AWSDecodableShape {
        /// The OpenSearch domain.
        public let domain: String

        public init(domain: String) {
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 64)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
        }
    }

    public struct AmazonOpenSearchParameters: AWSEncodableShape & AWSDecodableShape {
        /// The OpenSearch domain.
        public let domain: String

        public init(domain: String) {
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 64)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
        }
    }

    public struct Analysis: AWSDecodableShape {
        /// The ID of the analysis.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the analysis.
        public let arn: String?
        /// The time that the analysis was created.
        public let createdTime: Date?
        /// The ARNs of the datasets of the analysis.
        public let dataSetArns: [String]?
        /// Errors associated with the analysis.
        public let errors: [AnalysisError]?
        /// The time that the analysis was last updated.
        public let lastUpdatedTime: Date?
        /// The descriptive name of the analysis.
        public let name: String?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// Status associated with the analysis.
        public let status: ResourceStatus?
        /// The ARN of the theme of the analysis.
        public let themeArn: String?

        public init(analysisId: String? = nil, arn: String? = nil, createdTime: Date? = nil, dataSetArns: [String]? = nil, errors: [AnalysisError]? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, sheets: [Sheet]? = nil, status: ResourceStatus? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.errors = errors
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sheets = sheets
            self.status = status
            self.themeArn = themeArn
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSetArns = "DataSetArns"
            case errors = "Errors"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case sheets = "Sheets"
            case status = "Status"
            case themeArn = "ThemeArn"
        }
    }

    public struct AnalysisDefaults: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for default new sheet settings.
        public let defaultNewSheetConfiguration: DefaultNewSheetConfiguration

        public init(defaultNewSheetConfiguration: DefaultNewSheetConfiguration) {
            self.defaultNewSheetConfiguration = defaultNewSheetConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case defaultNewSheetConfiguration = "DefaultNewSheetConfiguration"
        }
    }

    public struct AnalysisDefinition: AWSEncodableShape & AWSDecodableShape {
        public let analysisDefaults: AnalysisDefaults?
        /// An array of calculated field definitions for the analysis.
        public let calculatedFields: [CalculatedField]?
        ///  An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis.
        public let columnConfigurations: [ColumnConfiguration]?
        /// An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.
        public let dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration]
        /// Filter definitions for an analysis. For more information, see Filtering Data in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let filterGroups: [FilterGroup]?
        /// An array of option definitions for an analysis.
        public let options: AssetOptions?
        /// An array of parameter declarations for an analysis. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see Parameters in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterDeclarations: [ParameterDeclaration]?
        /// An array of sheet definitions for an analysis. Each SheetDefinition provides detailed information about a sheet within this analysis.
        public let sheets: [SheetDefinition]?

        public init(analysisDefaults: AnalysisDefaults? = nil, calculatedFields: [CalculatedField]? = nil, columnConfigurations: [ColumnConfiguration]? = nil, dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration], filterGroups: [FilterGroup]? = nil, options: AssetOptions? = nil, parameterDeclarations: [ParameterDeclaration]? = nil, sheets: [SheetDefinition]? = nil) {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.options = options
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }

        public func validate(name: String) throws {
            try self.calculatedFields?.forEach {
                try $0.validate(name: "\(name).calculatedFields[]")
            }
            try self.validate(self.calculatedFields, name: "calculatedFields", parent: name, max: 500)
            try self.columnConfigurations?.forEach {
                try $0.validate(name: "\(name).columnConfigurations[]")
            }
            try self.validate(self.columnConfigurations, name: "columnConfigurations", parent: name, max: 2000)
            try self.dataSetIdentifierDeclarations.forEach {
                try $0.validate(name: "\(name).dataSetIdentifierDeclarations[]")
            }
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, max: 50)
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, min: 1)
            try self.filterGroups?.forEach {
                try $0.validate(name: "\(name).filterGroups[]")
            }
            try self.validate(self.filterGroups, name: "filterGroups", parent: name, max: 2000)
            try self.parameterDeclarations?.forEach {
                try $0.validate(name: "\(name).parameterDeclarations[]")
            }
            try self.validate(self.parameterDeclarations, name: "parameterDeclarations", parent: name, max: 200)
            try self.sheets?.forEach {
                try $0.validate(name: "\(name).sheets[]")
            }
            try self.validate(self.sheets, name: "sheets", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisDefaults = "AnalysisDefaults"
            case calculatedFields = "CalculatedFields"
            case columnConfigurations = "ColumnConfigurations"
            case dataSetIdentifierDeclarations = "DataSetIdentifierDeclarations"
            case filterGroups = "FilterGroups"
            case options = "Options"
            case parameterDeclarations = "ParameterDeclarations"
            case sheets = "Sheets"
        }
    }

    public struct AnalysisError: AWSDecodableShape {
        /// The message associated with the analysis error.
        public let message: String?
        /// The type of the analysis error.
        public let type: AnalysisErrorType?
        /// Lists the violated entities that caused the analysis error
        public let violatedEntities: [Entity]?

        public init(message: String? = nil, type: AnalysisErrorType? = nil, violatedEntities: [Entity]? = nil) {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
            case violatedEntities = "ViolatedEntities"
        }
    }

    public struct AnalysisSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered.     QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered.     ANALYSIS_NAME: Any analyses whose names have a substring match to this value will be returned.
        public let name: AnalysisFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example  "Operator": "StringEquals". Valid values are  "StringEquals"  and  "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example,  "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value ANALYSIS_NAME.
        public let `operator`: FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example "Value". An example is "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String?

        public init(name: AnalysisFilterAttribute? = nil, operator: FilterOperator? = nil, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct AnalysisSourceEntity: AWSEncodableShape {
        /// The source template for the source entity of the analysis.
        public let sourceTemplate: AnalysisSourceTemplate?

        public init(sourceTemplate: AnalysisSourceTemplate? = nil) {
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceTemplate?.validate(name: "\(name).sourceTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct AnalysisSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the source template of an analysis.
        public let arn: String
        /// The dataset references of the source template of an analysis.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct AnalysisSummary: AWSDecodableShape {
        /// The ID of the analysis. This ID displays in the URL.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) for the analysis.
        public let arn: String?
        /// The time that the analysis was created.
        public let createdTime: Date?
        /// The time that the analysis was last updated.
        public let lastUpdatedTime: Date?
        /// The name of the analysis. This name is displayed in the Amazon QuickSight console.
        public let name: String?
        /// The last known status for the analysis.
        public let status: ResourceStatus?

        public init(analysisId: String? = nil, arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, status: ResourceStatus? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct AnchorDateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options for the date configuration. Choose one of the options below:    NOW
        public let anchorOption: AnchorOption?
        /// The name of the parameter that is used for the anchor date configuration.
        public let parameterName: String?

        public init(anchorOption: AnchorOption? = nil, parameterName: String? = nil) {
            self.anchorOption = anchorOption
            self.parameterName = parameterName
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anchorOption = "AnchorOption"
            case parameterName = "ParameterName"
        }
    }

    public struct AnonymousUserDashboardEmbeddingConfiguration: AWSEncodableShape {
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard. The Amazon Resource Name (ARN) of this dashboard must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialDashboardId: String

        public init(initialDashboardId: String) {
            self.initialDashboardId = initialDashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, max: 512)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, min: 1)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initialDashboardId = "InitialDashboardId"
        }
    }

    public struct AnonymousUserDashboardVisualEmbeddingConfiguration: AWSEncodableShape {
        /// The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialDashboardVisualId: DashboardVisualId

        public init(initialDashboardVisualId: DashboardVisualId) {
            self.initialDashboardVisualId = initialDashboardVisualId
        }

        public func validate(name: String) throws {
            try self.initialDashboardVisualId.validate(name: "\(name).initialDashboardVisualId")
        }

        private enum CodingKeys: String, CodingKey {
            case initialDashboardVisualId = "InitialDashboardVisualId"
        }
    }

    public struct AnonymousUserEmbeddingExperienceConfiguration: AWSEncodableShape {
        /// The type of embedding experience. In this case, Amazon QuickSight dashboards.
        public let dashboard: AnonymousUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public let dashboardVisual: AnonymousUserDashboardVisualEmbeddingConfiguration?
        /// The Q search bar that you want to use for anonymous user embedding.
        public let qSearchBar: AnonymousUserQSearchBarEmbeddingConfiguration?

        public init(dashboard: AnonymousUserDashboardEmbeddingConfiguration? = nil, dashboardVisual: AnonymousUserDashboardVisualEmbeddingConfiguration? = nil, qSearchBar: AnonymousUserQSearchBarEmbeddingConfiguration? = nil) {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.qSearchBar = qSearchBar
        }

        public func validate(name: String) throws {
            try self.dashboard?.validate(name: "\(name).dashboard")
            try self.dashboardVisual?.validate(name: "\(name).dashboardVisual")
            try self.qSearchBar?.validate(name: "\(name).qSearchBar")
        }

        private enum CodingKeys: String, CodingKey {
            case dashboard = "Dashboard"
            case dashboardVisual = "DashboardVisual"
            case qSearchBar = "QSearchBar"
        }
    }

    public struct AnonymousUserQSearchBarEmbeddingConfiguration: AWSEncodableShape {
        /// The QuickSight Q topic ID of the topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this topic pre-selected. The Amazon Resource Name (ARN) of this Q topic must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialTopicId: String

        public init(initialTopicId: String) {
            self.initialTopicId = initialTopicId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, max: 2048)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, min: 1)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initialTopicId = "InitialTopicId"
        }
    }

    public struct AnonymousUserSnapshotJobResult: AWSDecodableShape {
        /// A list of SnapshotJobResultFileGroup objects that contain information on the files that are requested during a StartDashboardSnapshotJob API call. If the job succeeds, these objects contain the location where the snapshot artifacts are stored. If the job fails, the objects contain information about the error that caused the job to fail.
        public let fileGroups: [SnapshotJobResultFileGroup]?

        public init(fileGroups: [SnapshotJobResultFileGroup]? = nil) {
            self.fileGroups = fileGroups
        }

        private enum CodingKeys: String, CodingKey {
            case fileGroups = "FileGroups"
        }
    }

    public struct ArcAxisConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The arc axis range of a GaugeChartVisual.
        public let range: ArcAxisDisplayRange?
        /// The reserved range of the arc axis.
        public let reserveRange: Int?

        public init(range: ArcAxisDisplayRange? = nil, reserveRange: Int? = nil) {
            self.range = range
            self.reserveRange = reserveRange
        }

        private enum CodingKeys: String, CodingKey {
            case range = "Range"
            case reserveRange = "ReserveRange"
        }
    }

    public struct ArcAxisDisplayRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum value of the arc axis range.
        public let max: Double?
        /// The minimum value of the arc axis range.
        public let min: Double?

        public init(max: Double? = nil, min: Double? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct ArcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the arc angle of a GaugeChartVisual.
        public let arcAngle: Double?
        /// The options that determine the arc thickness of a GaugeChartVisual.
        public let arcThickness: ArcThicknessOptions?

        public init(arcAngle: Double? = nil, arcThickness: ArcThicknessOptions? = nil) {
            self.arcAngle = arcAngle
            self.arcThickness = arcThickness
        }

        private enum CodingKeys: String, CodingKey {
            case arcAngle = "ArcAngle"
            case arcThickness = "ArcThickness"
        }
    }

    public struct ArcOptions: AWSEncodableShape & AWSDecodableShape {
        /// The arc thickness of a GaugeChartVisual.
        public let arcThickness: ArcThickness?

        public init(arcThickness: ArcThickness? = nil) {
            self.arcThickness = arcThickness
        }

        private enum CodingKeys: String, CodingKey {
            case arcThickness = "ArcThickness"
        }
    }

    public struct AssetBundleCloudFormationOverridePropertyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An optional list of structures that control how Analysis resources are parameterized in the returned CloudFormation template.
        public let analyses: [AssetBundleExportJobAnalysisOverrideProperties]?
        /// An optional list of structures that control how Dashboard resources are parameterized in the returned CloudFormation template.
        public let dashboards: [AssetBundleExportJobDashboardOverrideProperties]?
        /// An optional list of structures that control how DataSet resources are parameterized in the returned CloudFormation template.
        public let dataSets: [AssetBundleExportJobDataSetOverrideProperties]?
        /// An optional list of structures that control how DataSource resources are parameterized in the returned CloudFormation template.
        public let dataSources: [AssetBundleExportJobDataSourceOverrideProperties]?
        /// An optional list of structures that control how RefreshSchedule resources are parameterized in the returned CloudFormation template.
        public let refreshSchedules: [AssetBundleExportJobRefreshScheduleOverrideProperties]?
        /// An optional list of structures that control how resource IDs are parameterized in the returned CloudFormation template.
        public let resourceIdOverrideConfiguration: AssetBundleExportJobResourceIdOverrideConfiguration?
        /// An optional list of structures that control how Theme resources are parameterized in the returned CloudFormation template.
        public let themes: [AssetBundleExportJobThemeOverrideProperties]?
        /// An optional list of structures that control how VPCConnection resources are parameterized in the returned CloudFormation template.
        public let vpcConnections: [AssetBundleExportJobVPCConnectionOverrideProperties]?

        public init(analyses: [AssetBundleExportJobAnalysisOverrideProperties]? = nil, dashboards: [AssetBundleExportJobDashboardOverrideProperties]? = nil, dataSets: [AssetBundleExportJobDataSetOverrideProperties]? = nil, dataSources: [AssetBundleExportJobDataSourceOverrideProperties]? = nil, refreshSchedules: [AssetBundleExportJobRefreshScheduleOverrideProperties]? = nil, resourceIdOverrideConfiguration: AssetBundleExportJobResourceIdOverrideConfiguration? = nil, themes: [AssetBundleExportJobThemeOverrideProperties]? = nil, vpcConnections: [AssetBundleExportJobVPCConnectionOverrideProperties]? = nil) {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.refreshSchedules = refreshSchedules
            self.resourceIdOverrideConfiguration = resourceIdOverrideConfiguration
            self.themes = themes
            self.vpcConnections = vpcConnections
        }

        public func validate(name: String) throws {
            try self.analyses?.forEach {
                try $0.validate(name: "\(name).analyses[]")
            }
            try self.validate(self.analyses, name: "analyses", parent: name, max: 50)
            try self.validate(self.analyses, name: "analyses", parent: name, min: 1)
            try self.dashboards?.forEach {
                try $0.validate(name: "\(name).dashboards[]")
            }
            try self.validate(self.dashboards, name: "dashboards", parent: name, max: 50)
            try self.validate(self.dashboards, name: "dashboards", parent: name, min: 1)
            try self.dataSets?.forEach {
                try $0.validate(name: "\(name).dataSets[]")
            }
            try self.validate(self.dataSets, name: "dataSets", parent: name, max: 50)
            try self.validate(self.dataSets, name: "dataSets", parent: name, min: 1)
            try self.dataSources?.forEach {
                try $0.validate(name: "\(name).dataSources[]")
            }
            try self.validate(self.dataSources, name: "dataSources", parent: name, max: 50)
            try self.validate(self.dataSources, name: "dataSources", parent: name, min: 1)
            try self.refreshSchedules?.forEach {
                try $0.validate(name: "\(name).refreshSchedules[]")
            }
            try self.validate(self.refreshSchedules, name: "refreshSchedules", parent: name, max: 50)
            try self.validate(self.refreshSchedules, name: "refreshSchedules", parent: name, min: 1)
            try self.themes?.forEach {
                try $0.validate(name: "\(name).themes[]")
            }
            try self.validate(self.themes, name: "themes", parent: name, max: 50)
            try self.validate(self.themes, name: "themes", parent: name, min: 1)
            try self.vpcConnections?.forEach {
                try $0.validate(name: "\(name).vpcConnections[]")
            }
            try self.validate(self.vpcConnections, name: "vpcConnections", parent: name, max: 50)
            try self.validate(self.vpcConnections, name: "vpcConnections", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case analyses = "Analyses"
            case dashboards = "Dashboards"
            case dataSets = "DataSets"
            case dataSources = "DataSources"
            case refreshSchedules = "RefreshSchedules"
            case resourceIdOverrideConfiguration = "ResourceIdOverrideConfiguration"
            case themes = "Themes"
            case vpcConnections = "VPCConnections"
        }
    }

    public struct AssetBundleExportJobAnalysisOverrideProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the specific Analysis resource whose override properties are configured in this structure.
        public let arn: String
        /// A list of Analysis resource properties to generate variables for in the returned CloudFormation template.
        public let properties: [AssetBundleExportJobAnalysisPropertyToOverride]

        public init(arn: String, properties: [AssetBundleExportJobAnalysisPropertyToOverride]) {
            self.arn = arn
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.properties, name: "properties", parent: name, max: 10)
            try self.validate(self.properties, name: "properties", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case properties = "Properties"
        }
    }

    public struct AssetBundleExportJobDashboardOverrideProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the specific Dashboard resource whose override properties are configured in this structure.
        public let arn: String
        /// A list of Dashboard resource properties to generate variables for in the returned CloudFormation template.
        public let properties: [AssetBundleExportJobDashboardPropertyToOverride]

        public init(arn: String, properties: [AssetBundleExportJobDashboardPropertyToOverride]) {
            self.arn = arn
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.properties, name: "properties", parent: name, max: 10)
            try self.validate(self.properties, name: "properties", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case properties = "Properties"
        }
    }

    public struct AssetBundleExportJobDataSetOverrideProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the specific DataSet resource whose override properties are configured in this structure.
        public let arn: String
        /// A list of DataSet resource properties to generate variables for in the returned CloudFormation template.
        public let properties: [AssetBundleExportJobDataSetPropertyToOverride]

        public init(arn: String, properties: [AssetBundleExportJobDataSetPropertyToOverride]) {
            self.arn = arn
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.properties, name: "properties", parent: name, max: 10)
            try self.validate(self.properties, name: "properties", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case properties = "Properties"
        }
    }

    public struct AssetBundleExportJobDataSourceOverrideProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the specific DataSource resource whose override properties are configured in this structure.
        public let arn: String
        /// A list of DataSource resource properties to generate variables for in the returned CloudFormation template.
        public let properties: [AssetBundleExportJobDataSourcePropertyToOverride]

        public init(arn: String, properties: [AssetBundleExportJobDataSourcePropertyToOverride]) {
            self.arn = arn
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.properties, name: "properties", parent: name, max: 10)
            try self.validate(self.properties, name: "properties", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case properties = "Properties"
        }
    }

    public struct AssetBundleExportJobError: AWSDecodableShape {
        /// The ARN of the resource whose processing caused an error.
        public let arn: String?
        /// A description of the error.
        public let message: String?
        /// The specific error type of the error that occurred.
        public let type: String?

        public init(arn: String? = nil, message: String? = nil, type: String? = nil) {
            self.arn = arn
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct AssetBundleExportJobRefreshScheduleOverrideProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the specific RefreshSchedule resource whose override properties are configured in this structure.
        public let arn: String
        /// A list of RefreshSchedule resource properties to generate variables for in the returned CloudFormation template.
        public let properties: [AssetBundleExportJobRefreshSchedulePropertyToOverride]

        public init(arn: String, properties: [AssetBundleExportJobRefreshSchedulePropertyToOverride]) {
            self.arn = arn
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.properties, name: "properties", parent: name, max: 10)
            try self.validate(self.properties, name: "properties", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case properties = "Properties"
        }
    }

    public struct AssetBundleExportJobResourceIdOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An option to request a CloudFormation variable for a prefix to be prepended to each resource's ID before import. The prefix is only added to the asset IDs and does not change the name of the asset.
        public let prefixForAllResources: Bool?

        public init(prefixForAllResources: Bool? = nil) {
            self.prefixForAllResources = prefixForAllResources
        }

        private enum CodingKeys: String, CodingKey {
            case prefixForAllResources = "PrefixForAllResources"
        }
    }

    public struct AssetBundleExportJobSummary: AWSDecodableShape {
        /// The ARN of the export job.
        public let arn: String?
        /// The ID of the export job.
        public let assetBundleExportJobId: String?
        /// The time that the export job was created.
        public let createdTime: Date?
        /// The format for the export job.
        public let exportFormat: AssetBundleExportFormat?
        /// The flag that determines the inclusion of resource dependencies in the returned asset bundle.
        public let includeAllDependencies: Bool?
        /// The flag that determines the inclusion of permissions associated with each resource ARN.
        public let includePermissions: Bool?
        /// The flag that determines the inclusion of tags associated with each resource ARN.
        public let includeTags: Bool?
        /// The current status of the export job.
        public let jobStatus: AssetBundleExportJobStatus?

        public init(arn: String? = nil, assetBundleExportJobId: String? = nil, createdTime: Date? = nil, exportFormat: AssetBundleExportFormat? = nil, includeAllDependencies: Bool? = nil, includePermissions: Bool? = nil, includeTags: Bool? = nil, jobStatus: AssetBundleExportJobStatus? = nil) {
            self.arn = arn
            self.assetBundleExportJobId = assetBundleExportJobId
            self.createdTime = createdTime
            self.exportFormat = exportFormat
            self.includeAllDependencies = includeAllDependencies
            self.includePermissions = includePermissions
            self.includeTags = includeTags
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetBundleExportJobId = "AssetBundleExportJobId"
            case createdTime = "CreatedTime"
            case exportFormat = "ExportFormat"
            case includeAllDependencies = "IncludeAllDependencies"
            case includePermissions = "IncludePermissions"
            case includeTags = "IncludeTags"
            case jobStatus = "JobStatus"
        }
    }

    public struct AssetBundleExportJobThemeOverrideProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the specific Theme resource whose override properties are configured in this structure.
        public let arn: String
        /// A list of Theme resource properties to generate variables for in the returned CloudFormation template.
        public let properties: [AssetBundleExportJobThemePropertyToOverride]

        public init(arn: String, properties: [AssetBundleExportJobThemePropertyToOverride]) {
            self.arn = arn
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.properties, name: "properties", parent: name, max: 10)
            try self.validate(self.properties, name: "properties", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case properties = "Properties"
        }
    }

    public struct AssetBundleExportJobVPCConnectionOverrideProperties: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the specific VPCConnection resource whose override properties are configured in this structure.
        public let arn: String
        /// A list of VPCConnection resource properties to generate variables for in the returned CloudFormation template.
        public let properties: [AssetBundleExportJobVPCConnectionPropertyToOverride]

        public init(arn: String, properties: [AssetBundleExportJobVPCConnectionPropertyToOverride]) {
            self.arn = arn
            self.properties = properties
        }

        public func validate(name: String) throws {
            try self.validate(self.properties, name: "properties", parent: name, max: 10)
            try self.validate(self.properties, name: "properties", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case properties = "Properties"
        }
    }

    public struct AssetBundleExportJobValidationStrategy: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value that indicates whether to export resources under strict or lenient mode.
        public let strictModeForAllResources: Bool?

        public init(strictModeForAllResources: Bool? = nil) {
            self.strictModeForAllResources = strictModeForAllResources
        }

        private enum CodingKeys: String, CodingKey {
            case strictModeForAllResources = "StrictModeForAllResources"
        }
    }

    public struct AssetBundleExportJobWarning: AWSDecodableShape {
        /// The ARN of the resource whose processing caused a warning.
        public let arn: String?
        /// A description of the warning.
        public let message: String?

        public init(arn: String? = nil, message: String? = nil) {
            self.arn = arn
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case message = "Message"
        }
    }

    public struct AssetBundleImportJobAnalysisOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the analysis that you ant to apply overrides to.
        public let analysisId: String
        /// A new name for the analysis.
        public let name: String?

        public init(analysisId: String, name: String? = nil) {
            self.analysisId = analysisId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case name = "Name"
        }
    }

    public struct AssetBundleImportJobAnalysisOverridePermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of analysis IDs that you want to apply overrides to. You can use * to override all analyses in this asset bundle.
        public let analysisIds: [String]
        /// A list of permissions for the analyses that you want to apply overrides to.
        public let permissions: AssetBundleResourcePermissions

        public init(analysisIds: [String], permissions: AssetBundleResourcePermissions) {
            self.analysisIds = analysisIds
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.analysisIds.forEach {
                try validate($0, name: "analysisIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.analysisIds, name: "analysisIds", parent: name, max: 50)
            try self.validate(self.analysisIds, name: "analysisIds", parent: name, min: 1)
            try self.permissions.validate(name: "\(name).permissions")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisIds = "AnalysisIds"
            case permissions = "Permissions"
        }
    }

    public struct AssetBundleImportJobAnalysisOverrideTags: AWSEncodableShape & AWSDecodableShape {
        /// A list of analysis IDs that you want to apply overrides to. You can use * to override all analyses in this asset bundle.
        public let analysisIds: [String]
        /// A list of tags for the analyses that you want to apply overrides to.
        public let tags: [Tag]

        public init(analysisIds: [String], tags: [Tag]) {
            self.analysisIds = analysisIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.analysisIds.forEach {
                try validate($0, name: "analysisIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.analysisIds, name: "analysisIds", parent: name, max: 50)
            try self.validate(self.analysisIds, name: "analysisIds", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisIds = "AnalysisIds"
            case tags = "Tags"
        }
    }

    public struct AssetBundleImportJobDashboardOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the dashboard that you want to apply overrides to.
        public let dashboardId: String
        /// A new name for the dashboard.
        public let name: String?

        public init(dashboardId: String, name: String? = nil) {
            self.dashboardId = dashboardId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardId = "DashboardId"
            case name = "Name"
        }
    }

    public struct AssetBundleImportJobDashboardOverridePermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of dashboard IDs that you want to apply overrides to. You can use * to override all dashboards in this asset bundle.
        public let dashboardIds: [String]
        /// A structure that contains the link sharing configurations that you want to apply overrides to.
        public let linkSharingConfiguration: AssetBundleResourceLinkSharingConfiguration?
        /// A list of permissions for the dashboards that you want to apply overrides to.
        public let permissions: AssetBundleResourcePermissions?

        public init(dashboardIds: [String], linkSharingConfiguration: AssetBundleResourceLinkSharingConfiguration? = nil, permissions: AssetBundleResourcePermissions? = nil) {
            self.dashboardIds = dashboardIds
            self.linkSharingConfiguration = linkSharingConfiguration
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.dashboardIds.forEach {
                try validate($0, name: "dashboardIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.dashboardIds, name: "dashboardIds", parent: name, max: 50)
            try self.validate(self.dashboardIds, name: "dashboardIds", parent: name, min: 1)
            try self.linkSharingConfiguration?.validate(name: "\(name).linkSharingConfiguration")
            try self.permissions?.validate(name: "\(name).permissions")
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardIds = "DashboardIds"
            case linkSharingConfiguration = "LinkSharingConfiguration"
            case permissions = "Permissions"
        }
    }

    public struct AssetBundleImportJobDashboardOverrideTags: AWSEncodableShape & AWSDecodableShape {
        /// A list of dashboard IDs that you want to apply overrides to. You can use * to override all dashboards in this asset bundle.
        public let dashboardIds: [String]
        /// A list of tags for the dashboards that you want to apply overrides to.
        public let tags: [Tag]

        public init(dashboardIds: [String], tags: [Tag]) {
            self.dashboardIds = dashboardIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.dashboardIds.forEach {
                try validate($0, name: "dashboardIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.dashboardIds, name: "dashboardIds", parent: name, max: 50)
            try self.validate(self.dashboardIds, name: "dashboardIds", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardIds = "DashboardIds"
            case tags = "Tags"
        }
    }

    public struct AssetBundleImportJobDataSetOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the dataset to apply overrides to.
        public let dataSetId: String
        /// A new name for the dataset.
        public let name: String?

        public init(dataSetId: String, name: String? = nil) {
            self.dataSetId = dataSetId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case name = "Name"
        }
    }

    public struct AssetBundleImportJobDataSetOverridePermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of dataset IDs that you want to apply overrides to. You can use * to override all datasets in this asset bundle.
        public let dataSetIds: [String]
        /// A list of permissions for the datasets that you want to apply overrides to.
        public let permissions: AssetBundleResourcePermissions

        public init(dataSetIds: [String], permissions: AssetBundleResourcePermissions) {
            self.dataSetIds = dataSetIds
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.dataSetIds.forEach {
                try validate($0, name: "dataSetIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.dataSetIds, name: "dataSetIds", parent: name, max: 50)
            try self.validate(self.dataSetIds, name: "dataSetIds", parent: name, min: 1)
            try self.permissions.validate(name: "\(name).permissions")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIds = "DataSetIds"
            case permissions = "Permissions"
        }
    }

    public struct AssetBundleImportJobDataSetOverrideTags: AWSEncodableShape & AWSDecodableShape {
        /// A list of dataset IDs that you want to apply overrides to. You can use * to override all datasets in this asset bundle.
        public let dataSetIds: [String]
        /// A list of tags for the datasets that you want to apply overrides to.
        public let tags: [Tag]

        public init(dataSetIds: [String], tags: [Tag]) {
            self.dataSetIds = dataSetIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.dataSetIds.forEach {
                try validate($0, name: "dataSetIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.dataSetIds, name: "dataSetIds", parent: name, max: 50)
            try self.validate(self.dataSetIds, name: "dataSetIds", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIds = "DataSetIds"
            case tags = "Tags"
        }
    }

    public struct AssetBundleImportJobDataSourceCredentialPair: AWSEncodableShape & AWSDecodableShape {
        /// The password for the data source connection.
        public let password: String
        /// The username for the data source connection.
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 1024)
            try self.validate(self.password, name: "password", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 64)
            try self.validate(self.username, name: "username", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case password = "Password"
            case username = "Username"
        }
    }

    public struct AssetBundleImportJobDataSourceCredentials: AWSEncodableShape & AWSDecodableShape {
        /// A username and password credential pair to be used to create the imported data source. Keep this field blank if you are using a Secrets Manager secret to provide credentials.
        public let credentialPair: AssetBundleImportJobDataSourceCredentialPair?
        /// The ARN of the Secrets Manager secret that's used to create the imported data source. Keep this field blank, unless you are using a secret in place of a credential pair.
        public let secretArn: String?

        public init(credentialPair: AssetBundleImportJobDataSourceCredentialPair? = nil, secretArn: String? = nil) {
            self.credentialPair = credentialPair
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.credentialPair?.validate(name: "\(name).credentialPair")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 2048)
            try self.validate(self.secretArn, name: "secretArn", parent: name, min: 1)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[-a-z0-9]*:secretsmanager:[-a-z0-9]*:[0-9]{12}:secret:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialPair = "CredentialPair"
            case secretArn = "SecretArn"
        }
    }

    public struct AssetBundleImportJobDataSourceOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// An optional structure that provides the credentials to be used to create the imported data source.
        public let credentials: AssetBundleImportJobDataSourceCredentials?
        /// The ID of the data source to apply overrides to.
        public let dataSourceId: String
        public let dataSourceParameters: DataSourceParameters?
        /// A new name for the data source.
        public let name: String?
        public let sslProperties: SslProperties?
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(credentials: AssetBundleImportJobDataSourceCredentials? = nil, dataSourceId: String, dataSourceParameters: DataSourceParameters? = nil, name: String? = nil, sslProperties: SslProperties? = nil, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.name = name
            self.sslProperties = sslProperties
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        public func validate(name: String) throws {
            try self.credentials?.validate(name: "\(name).credentials")
            try self.dataSourceParameters?.validate(name: "\(name).dataSourceParameters")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case dataSourceId = "DataSourceId"
            case dataSourceParameters = "DataSourceParameters"
            case name = "Name"
            case sslProperties = "SslProperties"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct AssetBundleImportJobDataSourceOverridePermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of data source IDs that you want to apply overrides to. You can use * to override all data sources in this asset bundle.
        public let dataSourceIds: [String]
        /// A list of permissions for the data source that you want to apply overrides to.
        public let permissions: AssetBundleResourcePermissions

        public init(dataSourceIds: [String], permissions: AssetBundleResourcePermissions) {
            self.dataSourceIds = dataSourceIds
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.dataSourceIds.forEach {
                try validate($0, name: "dataSourceIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, max: 50)
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, min: 1)
            try self.permissions.validate(name: "\(name).permissions")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceIds = "DataSourceIds"
            case permissions = "Permissions"
        }
    }

    public struct AssetBundleImportJobDataSourceOverrideTags: AWSEncodableShape & AWSDecodableShape {
        /// A list of data source IDs that you want to apply overrides to. You can use * to override all data sources in this asset bundle.
        public let dataSourceIds: [String]
        /// A list of tags for the data source that you want to apply overrides to.
        public let tags: [Tag]

        public init(dataSourceIds: [String], tags: [Tag]) {
            self.dataSourceIds = dataSourceIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.dataSourceIds.forEach {
                try validate($0, name: "dataSourceIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, max: 50)
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceIds = "DataSourceIds"
            case tags = "Tags"
        }
    }

    public struct AssetBundleImportJobError: AWSDecodableShape {
        /// The ARN of the resource whose processing caused an error.
        public let arn: String?
        /// A description of the error.
        public let message: String?
        /// The specific error type or the error that occurred.
        public let type: String?

        public init(arn: String? = nil, message: String? = nil, type: String? = nil) {
            self.arn = arn
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case message = "Message"
            case type = "Type"
        }
    }

    public struct AssetBundleImportJobOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// A list of overrides for any Analysis resources that are present in the asset bundle that is imported.
        public let analyses: [AssetBundleImportJobAnalysisOverrideParameters]?
        /// A list of overrides for any Dashboard resources that are present in the asset bundle that is imported.
        public let dashboards: [AssetBundleImportJobDashboardOverrideParameters]?
        /// A list of overrides for any DataSet resources that are present in the asset bundle that is imported.
        public let dataSets: [AssetBundleImportJobDataSetOverrideParameters]?
        ///  A list of overrides for any DataSource resources that are present in the asset bundle that is imported.
        public let dataSources: [AssetBundleImportJobDataSourceOverrideParameters]?
        /// A list of overrides for any RefreshSchedule resources that are present in the asset bundle that is imported.
        public let refreshSchedules: [AssetBundleImportJobRefreshScheduleOverrideParameters]?
        /// An optional structure that configures resource ID overrides to be applied within the import job.
        public let resourceIdOverrideConfiguration: AssetBundleImportJobResourceIdOverrideConfiguration?
        /// A list of overrides for any Theme resources that are present in the asset bundle that is imported.
        public let themes: [AssetBundleImportJobThemeOverrideParameters]?
        /// A list of overrides for any VPCConnection resources that are present in the asset bundle that is imported.
        public let vpcConnections: [AssetBundleImportJobVPCConnectionOverrideParameters]?

        public init(analyses: [AssetBundleImportJobAnalysisOverrideParameters]? = nil, dashboards: [AssetBundleImportJobDashboardOverrideParameters]? = nil, dataSets: [AssetBundleImportJobDataSetOverrideParameters]? = nil, dataSources: [AssetBundleImportJobDataSourceOverrideParameters]? = nil, refreshSchedules: [AssetBundleImportJobRefreshScheduleOverrideParameters]? = nil, resourceIdOverrideConfiguration: AssetBundleImportJobResourceIdOverrideConfiguration? = nil, themes: [AssetBundleImportJobThemeOverrideParameters]? = nil, vpcConnections: [AssetBundleImportJobVPCConnectionOverrideParameters]? = nil) {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.refreshSchedules = refreshSchedules
            self.resourceIdOverrideConfiguration = resourceIdOverrideConfiguration
            self.themes = themes
            self.vpcConnections = vpcConnections
        }

        public func validate(name: String) throws {
            try self.analyses?.forEach {
                try $0.validate(name: "\(name).analyses[]")
            }
            try self.validate(self.analyses, name: "analyses", parent: name, max: 50)
            try self.validate(self.analyses, name: "analyses", parent: name, min: 1)
            try self.dashboards?.forEach {
                try $0.validate(name: "\(name).dashboards[]")
            }
            try self.validate(self.dashboards, name: "dashboards", parent: name, max: 50)
            try self.validate(self.dashboards, name: "dashboards", parent: name, min: 1)
            try self.dataSets?.forEach {
                try $0.validate(name: "\(name).dataSets[]")
            }
            try self.validate(self.dataSets, name: "dataSets", parent: name, max: 50)
            try self.validate(self.dataSets, name: "dataSets", parent: name, min: 1)
            try self.dataSources?.forEach {
                try $0.validate(name: "\(name).dataSources[]")
            }
            try self.validate(self.dataSources, name: "dataSources", parent: name, max: 50)
            try self.validate(self.dataSources, name: "dataSources", parent: name, min: 1)
            try self.validate(self.refreshSchedules, name: "refreshSchedules", parent: name, max: 50)
            try self.validate(self.refreshSchedules, name: "refreshSchedules", parent: name, min: 1)
            try self.themes?.forEach {
                try $0.validate(name: "\(name).themes[]")
            }
            try self.validate(self.themes, name: "themes", parent: name, max: 50)
            try self.validate(self.themes, name: "themes", parent: name, min: 1)
            try self.vpcConnections?.forEach {
                try $0.validate(name: "\(name).vpcConnections[]")
            }
            try self.validate(self.vpcConnections, name: "vpcConnections", parent: name, max: 50)
            try self.validate(self.vpcConnections, name: "vpcConnections", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case analyses = "Analyses"
            case dashboards = "Dashboards"
            case dataSets = "DataSets"
            case dataSources = "DataSources"
            case refreshSchedules = "RefreshSchedules"
            case resourceIdOverrideConfiguration = "ResourceIdOverrideConfiguration"
            case themes = "Themes"
            case vpcConnections = "VPCConnections"
        }
    }

    public struct AssetBundleImportJobOverridePermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of permissions overrides for any Analysis resources that are present in the asset bundle that is imported.
        public let analyses: [AssetBundleImportJobAnalysisOverridePermissions]?
        /// A list of permissions overrides for any Dashboard resources that are present in the asset bundle that is imported.
        public let dashboards: [AssetBundleImportJobDashboardOverridePermissions]?
        /// A list of permissions overrides for any DataSet resources that are present in the asset bundle that is imported.
        public let dataSets: [AssetBundleImportJobDataSetOverridePermissions]?
        /// A list of permissions overrides for any DataSource resources that are present in the asset bundle that is imported.
        public let dataSources: [AssetBundleImportJobDataSourceOverridePermissions]?
        /// A list of permissions overrides for any Theme resources that are present in the asset bundle that is imported.
        public let themes: [AssetBundleImportJobThemeOverridePermissions]?

        public init(analyses: [AssetBundleImportJobAnalysisOverridePermissions]? = nil, dashboards: [AssetBundleImportJobDashboardOverridePermissions]? = nil, dataSets: [AssetBundleImportJobDataSetOverridePermissions]? = nil, dataSources: [AssetBundleImportJobDataSourceOverridePermissions]? = nil, themes: [AssetBundleImportJobThemeOverridePermissions]? = nil) {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.themes = themes
        }

        public func validate(name: String) throws {
            try self.analyses?.forEach {
                try $0.validate(name: "\(name).analyses[]")
            }
            try self.validate(self.analyses, name: "analyses", parent: name, max: 1)
            try self.validate(self.analyses, name: "analyses", parent: name, min: 1)
            try self.dashboards?.forEach {
                try $0.validate(name: "\(name).dashboards[]")
            }
            try self.validate(self.dashboards, name: "dashboards", parent: name, max: 2)
            try self.validate(self.dashboards, name: "dashboards", parent: name, min: 1)
            try self.dataSets?.forEach {
                try $0.validate(name: "\(name).dataSets[]")
            }
            try self.validate(self.dataSets, name: "dataSets", parent: name, max: 2)
            try self.validate(self.dataSets, name: "dataSets", parent: name, min: 1)
            try self.dataSources?.forEach {
                try $0.validate(name: "\(name).dataSources[]")
            }
            try self.validate(self.dataSources, name: "dataSources", parent: name, max: 2)
            try self.validate(self.dataSources, name: "dataSources", parent: name, min: 1)
            try self.themes?.forEach {
                try $0.validate(name: "\(name).themes[]")
            }
            try self.validate(self.themes, name: "themes", parent: name, max: 2)
            try self.validate(self.themes, name: "themes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case analyses = "Analyses"
            case dashboards = "Dashboards"
            case dataSets = "DataSets"
            case dataSources = "DataSources"
            case themes = "Themes"
        }
    }

    public struct AssetBundleImportJobOverrideTags: AWSEncodableShape & AWSDecodableShape {
        /// A list of tag overrides for any Analysis resources that are present in the asset bundle that is imported.
        public let analyses: [AssetBundleImportJobAnalysisOverrideTags]?
        /// A list of tag overrides for any Dashboard resources that are present in the asset bundle that is imported.
        public let dashboards: [AssetBundleImportJobDashboardOverrideTags]?
        /// A list of tag overrides for any DataSet resources that are present in the asset bundle that is imported.
        public let dataSets: [AssetBundleImportJobDataSetOverrideTags]?
        /// A list of tag overrides for any DataSource resources that are present in the asset bundle that is imported.
        public let dataSources: [AssetBundleImportJobDataSourceOverrideTags]?
        /// A list of tag overrides for any Theme resources that are present in the asset bundle that is imported.
        public let themes: [AssetBundleImportJobThemeOverrideTags]?
        /// A list of tag overrides for any VPCConnection resources that are present in the asset bundle that is imported.
        public let vpcConnections: [AssetBundleImportJobVPCConnectionOverrideTags]?

        public init(analyses: [AssetBundleImportJobAnalysisOverrideTags]? = nil, dashboards: [AssetBundleImportJobDashboardOverrideTags]? = nil, dataSets: [AssetBundleImportJobDataSetOverrideTags]? = nil, dataSources: [AssetBundleImportJobDataSourceOverrideTags]? = nil, themes: [AssetBundleImportJobThemeOverrideTags]? = nil, vpcConnections: [AssetBundleImportJobVPCConnectionOverrideTags]? = nil) {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.themes = themes
            self.vpcConnections = vpcConnections
        }

        public func validate(name: String) throws {
            try self.analyses?.forEach {
                try $0.validate(name: "\(name).analyses[]")
            }
            try self.validate(self.analyses, name: "analyses", parent: name, max: 5)
            try self.validate(self.analyses, name: "analyses", parent: name, min: 1)
            try self.dashboards?.forEach {
                try $0.validate(name: "\(name).dashboards[]")
            }
            try self.validate(self.dashboards, name: "dashboards", parent: name, max: 5)
            try self.validate(self.dashboards, name: "dashboards", parent: name, min: 1)
            try self.dataSets?.forEach {
                try $0.validate(name: "\(name).dataSets[]")
            }
            try self.validate(self.dataSets, name: "dataSets", parent: name, max: 5)
            try self.validate(self.dataSets, name: "dataSets", parent: name, min: 1)
            try self.dataSources?.forEach {
                try $0.validate(name: "\(name).dataSources[]")
            }
            try self.validate(self.dataSources, name: "dataSources", parent: name, max: 5)
            try self.validate(self.dataSources, name: "dataSources", parent: name, min: 1)
            try self.themes?.forEach {
                try $0.validate(name: "\(name).themes[]")
            }
            try self.validate(self.themes, name: "themes", parent: name, max: 5)
            try self.validate(self.themes, name: "themes", parent: name, min: 1)
            try self.vpcConnections?.forEach {
                try $0.validate(name: "\(name).vpcConnections[]")
            }
            try self.validate(self.vpcConnections, name: "vpcConnections", parent: name, max: 5)
            try self.validate(self.vpcConnections, name: "vpcConnections", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case analyses = "Analyses"
            case dashboards = "Dashboards"
            case dataSets = "DataSets"
            case dataSources = "DataSources"
            case themes = "Themes"
            case vpcConnections = "VPCConnections"
        }
    }

    public struct AssetBundleImportJobOverrideValidationStrategy: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value that indicates whether to import all analyses and dashboards under strict or lenient mode.
        public let strictModeForAllResources: Bool?

        public init(strictModeForAllResources: Bool? = nil) {
            self.strictModeForAllResources = strictModeForAllResources
        }

        private enum CodingKeys: String, CodingKey {
            case strictModeForAllResources = "StrictModeForAllResources"
        }
    }

    public struct AssetBundleImportJobRefreshScheduleOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// A partial identifier for the specific RefreshSchedule resource that is being overridden. This structure is used together with the ScheduleID structure.
        public let dataSetId: String
        /// A partial identifier for the specific RefreshSchedule resource being overridden. This structure is used together with the DataSetId structure.
        public let scheduleId: String
        /// An override for the StartAfterDateTime of a RefreshSchedule. Make sure that the StartAfterDateTime is set to a time that takes place in the future.
        public let startAfterDateTime: Date?

        public init(dataSetId: String, scheduleId: String, startAfterDateTime: Date? = nil) {
            self.dataSetId = dataSetId
            self.scheduleId = scheduleId
            self.startAfterDateTime = startAfterDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case scheduleId = "ScheduleId"
            case startAfterDateTime = "StartAfterDateTime"
        }
    }

    public struct AssetBundleImportJobResourceIdOverrideConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An option to request a CloudFormation variable for a prefix to be prepended to each resource's ID before import. The prefix is only added to the asset IDs and does not change the name of the asset.
        public let prefixForAllResources: String?

        public init(prefixForAllResources: String? = nil) {
            self.prefixForAllResources = prefixForAllResources
        }

        private enum CodingKeys: String, CodingKey {
            case prefixForAllResources = "PrefixForAllResources"
        }
    }

    public struct AssetBundleImportJobSummary: AWSDecodableShape {
        /// The ARN of the import job.
        public let arn: String?
        /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
        public let assetBundleImportJobId: String?
        /// The time that the import job was created.
        public let createdTime: Date?
        /// The failure action for the import job.
        public let failureAction: AssetBundleImportFailureAction?
        /// The current status of the import job.
        public let jobStatus: AssetBundleImportJobStatus?

        public init(arn: String? = nil, assetBundleImportJobId: String? = nil, createdTime: Date? = nil, failureAction: AssetBundleImportFailureAction? = nil, jobStatus: AssetBundleImportJobStatus? = nil) {
            self.arn = arn
            self.assetBundleImportJobId = assetBundleImportJobId
            self.createdTime = createdTime
            self.failureAction = failureAction
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetBundleImportJobId = "AssetBundleImportJobId"
            case createdTime = "CreatedTime"
            case failureAction = "FailureAction"
            case jobStatus = "JobStatus"
        }
    }

    public struct AssetBundleImportJobThemeOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// A new name for the theme.
        public let name: String?
        /// The ID of the theme to apply overrides to.
        public let themeId: String

        public init(name: String? = nil, themeId: String) {
            self.name = name
            self.themeId = themeId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case themeId = "ThemeId"
        }
    }

    public struct AssetBundleImportJobThemeOverridePermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of permissions for the themes that you want to apply overrides to.
        public let permissions: AssetBundleResourcePermissions
        /// A list of theme IDs that you want to apply overrides to. You can use * to override all themes in this asset bundle.
        public let themeIds: [String]

        public init(permissions: AssetBundleResourcePermissions, themeIds: [String]) {
            self.permissions = permissions
            self.themeIds = themeIds
        }

        public func validate(name: String) throws {
            try self.permissions.validate(name: "\(name).permissions")
            try self.themeIds.forEach {
                try validate($0, name: "themeIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.themeIds, name: "themeIds", parent: name, max: 50)
            try self.validate(self.themeIds, name: "themeIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case themeIds = "ThemeIds"
        }
    }

    public struct AssetBundleImportJobThemeOverrideTags: AWSEncodableShape & AWSDecodableShape {
        /// A list of tags for the themes that you want to apply overrides to.
        public let tags: [Tag]
        /// A list of theme IDs that you want to apply overrides to. You can use * to override all themes in this asset bundle.
        public let themeIds: [String]

        public init(tags: [Tag], themeIds: [String]) {
            self.tags = tags
            self.themeIds = themeIds
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.themeIds.forEach {
                try validate($0, name: "themeIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.themeIds, name: "themeIds", parent: name, max: 50)
            try self.validate(self.themeIds, name: "themeIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case themeIds = "ThemeIds"
        }
    }

    public struct AssetBundleImportJobVPCConnectionOverrideParameters: AWSEncodableShape & AWSDecodableShape {
        /// An optional override of DNS resolvers to be used by the VPC connection.
        public let dnsResolvers: [String]?
        /// A new name for the VPC connection.
        public let name: String?
        /// An optional override of the role ARN to be used by the VPC connection.
        public let roleArn: String?
        /// A new security group ID for the VPC connection you are importing. This field is required if you are importing the VPC connection from another Amazon Web Services account or Region.
        public let securityGroupIds: [String]?
        /// A list of new subnet IDs for the VPC connection you are importing. This field is required if you are importing the VPC connection from another Amazon Web Services account or Region.
        public let subnetIds: [String]?
        /// The ID of the VPC Connection to apply overrides to.
        public let vpcConnectionId: String

        public init(dnsResolvers: [String]? = nil, name: String? = nil, roleArn: String? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcConnectionId: String) {
            self.dnsResolvers = dnsResolvers
            self.name = name
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcConnectionId = vpcConnectionId
        }

        public func validate(name: String) throws {
            try self.dnsResolvers?.forEach {
                try validate($0, name: "dnsResolvers[]", parent: name, max: 15)
                try validate($0, name: "dnsResolvers[]", parent: name, min: 7)
            }
            try self.validate(self.dnsResolvers, name: "dnsResolvers", parent: name, max: 15)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-z]*$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 16)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 255)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[0-9a-z]*$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 15)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 2)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, max: 1000)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dnsResolvers = "DnsResolvers"
            case name = "Name"
            case roleArn = "RoleArn"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcConnectionId = "VPCConnectionId"
        }
    }

    public struct AssetBundleImportJobVPCConnectionOverrideTags: AWSEncodableShape & AWSDecodableShape {
        /// A list of tags for the VPC connections that you want to apply overrides to.
        public let tags: [Tag]
        /// A list of VPC connection IDs that you want to apply overrides to. You can use * to override all VPC connections in this asset bundle.
        public let vpcConnectionIds: [String]

        public init(tags: [Tag], vpcConnectionIds: [String]) {
            self.tags = tags
            self.vpcConnectionIds = vpcConnectionIds
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.vpcConnectionIds.forEach {
                try validate($0, name: "vpcConnectionIds[]", parent: name, pattern: "^\\*|[\\w\\-]{1,2048}$")
            }
            try self.validate(self.vpcConnectionIds, name: "vpcConnectionIds", parent: name, max: 50)
            try self.validate(self.vpcConnectionIds, name: "vpcConnectionIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case vpcConnectionIds = "VPCConnectionIds"
        }
    }

    public struct AssetBundleImportSource: AWSEncodableShape {
        /// The bytes of the base64 encoded asset bundle import zip file. This file can't exceed 20 MB. If you are calling the API operations from the Amazon Web Services SDK for Java, JavaScript, Python, or PHP, the SDK encodes base64 automatically to allow the direct setting of the zip file's bytes. If you are using an SDK for a different language or receiving related errors, try to base64 encode your data.
        public let body: AWSBase64Data?
        /// The Amazon S3 URI for an asset bundle import file that exists in an Amazon S3 bucket that the caller has read access to. The file must be a zip format file and can't exceed 20 MB.
        public let s3Uri: String?

        public init(body: AWSBase64Data? = nil, s3Uri: String? = nil) {
            self.body = body
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 20971520)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^(https|s3)://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case s3Uri = "S3Uri"
        }
    }

    public struct AssetBundleImportSourceDescription: AWSDecodableShape {
        /// An HTTPS download URL for the provided asset bundle that you optionally provided at the start of the import job. This URL is valid for five minutes after issuance. Call DescribeAssetBundleExportJob again for a fresh URL if needed. The downloaded asset bundle is a .qs zip file.
        public let body: String?
        /// The Amazon S3 URI that you provided at the start of the import job.
        public let s3Uri: String?

        public init(body: String? = nil, s3Uri: String? = nil) {
            self.body = body
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case s3Uri = "S3Uri"
        }
    }

    public struct AssetBundleResourceLinkSharingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of link sharing permissions for the dashboards that you want to apply overrides to.
        public let permissions: AssetBundleResourcePermissions?

        public init(permissions: AssetBundleResourcePermissions? = nil) {
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.permissions?.validate(name: "\(name).permissions")
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
        }
    }

    public struct AssetBundleResourcePermissions: AWSEncodableShape & AWSDecodableShape {
        /// A list of IAM actions to grant permissions on.
        public let actions: [String]
        /// A list of principals to grant permissions on.
        public let principals: [String]

        public init(actions: [String], principals: [String]) {
            self.actions = actions
            self.principals = principals
        }

        public func validate(name: String) throws {
            try self.validate(self.actions, name: "actions", parent: name, max: 20)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.principals.forEach {
                try validate($0, name: "principals[]", parent: name, max: 256)
                try validate($0, name: "principals[]", parent: name, min: 1)
            }
            try self.validate(self.principals, name: "principals", parent: name, max: 64)
            try self.validate(self.principals, name: "principals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case principals = "Principals"
        }
    }

    public struct AssetOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the timezone for the analysis.
        public let timezone: String?
        /// Determines the week start day for an analysis.
        public let weekStart: DayOfTheWeek?

        public init(timezone: String? = nil, weekStart: DayOfTheWeek? = nil) {
            self.timezone = timezone
            self.weekStart = weekStart
        }

        private enum CodingKeys: String, CodingKey {
            case timezone = "Timezone"
            case weekStart = "WeekStart"
        }
    }

    public struct AthenaParameters: AWSEncodableShape & AWSDecodableShape {
        /// Use the RoleArn structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use RoleArn to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.
        public let roleArn: String?
        /// The workgroup that Amazon Athena uses.
        public let workGroup: String?

        public init(roleArn: String? = nil, workGroup: String? = nil) {
            self.roleArn = roleArn
            self.workGroup = workGroup
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.workGroup, name: "workGroup", parent: name, max: 128)
            try self.validate(self.workGroup, name: "workGroup", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case workGroup = "WorkGroup"
        }
    }

    public struct AttributeAggregationFunction: AWSEncodableShape & AWSDecodableShape {
        /// The built-in aggregation functions for attributes.    UNIQUE_VALUE: Returns the unique value for a field, aggregated by the dimension fields.
        public let simpleAttributeAggregation: SimpleAttributeAggregationFunction?
        /// Used by the UNIQUE_VALUE aggregation function. If there are multiple values for the field used by the aggregation, the value for this property will be returned instead. Defaults to '*'.
        public let valueForMultipleValues: String?

        public init(simpleAttributeAggregation: SimpleAttributeAggregationFunction? = nil, valueForMultipleValues: String? = nil) {
            self.simpleAttributeAggregation = simpleAttributeAggregation
            self.valueForMultipleValues = valueForMultipleValues
        }

        private enum CodingKeys: String, CodingKey {
            case simpleAttributeAggregation = "SimpleAttributeAggregation"
            case valueForMultipleValues = "ValueForMultipleValues"
        }
    }

    public struct AuroraParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct AuroraPostgreSqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Aurora PostgreSQL database to connect to.
        public let database: String
        /// The Amazon Aurora PostgreSQL-Compatible host to connect to.
        public let host: String
        /// The port that Amazon Aurora PostgreSQL is listening on.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct AuthorizedTargetsByService: AWSDecodableShape {
        /// Aist of authorized targets that are represented by IAM Identity Center application ARNs.
        public let authorizedTargets: [String]?
        /// The name of the Amazon Web Services service.
        public let service: ServiceType?

        public init(authorizedTargets: [String]? = nil, service: ServiceType? = nil) {
            self.authorizedTargets = authorizedTargets
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedTargets = "AuthorizedTargets"
            case service = "Service"
        }
    }

    public struct AwsIotAnalyticsParameters: AWSEncodableShape & AWSDecodableShape {
        /// Dataset name.
        public let dataSetName: String

        public init(dataSetName: String) {
            self.dataSetName = dataSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, max: 128)
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetName = "DataSetName"
        }
    }

    public struct AxisDataOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options for an axis with a date field.
        public let dateAxisOptions: DateAxisOptions?
        /// The options for an axis with a numeric field.
        public let numericAxisOptions: NumericAxisOptions?

        public init(dateAxisOptions: DateAxisOptions? = nil, numericAxisOptions: NumericAxisOptions? = nil) {
            self.dateAxisOptions = dateAxisOptions
            self.numericAxisOptions = numericAxisOptions
        }

        private enum CodingKeys: String, CodingKey {
            case dateAxisOptions = "DateAxisOptions"
            case numericAxisOptions = "NumericAxisOptions"
        }
    }

    public struct AxisDisplayDataDrivenRange: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AxisDisplayMinMaxRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum setup for an axis display range.
        public let maximum: Double?
        /// The minimum setup for an axis display range.
        public let minimum: Double?

        public init(maximum: Double? = nil, minimum: Double? = nil) {
            self.maximum = maximum
            self.minimum = minimum
        }

        private enum CodingKeys: String, CodingKey {
            case maximum = "Maximum"
            case minimum = "Minimum"
        }
    }

    public struct AxisDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not the axis line is visible.
        public let axisLineVisibility: Visibility?
        /// The offset value that determines the starting placement of the axis within a visual's bounds.
        public let axisOffset: String?
        /// The data options for an axis.
        public let dataOptions: AxisDataOptions?
        /// Determines whether or not the grid line is visible.
        public let gridLineVisibility: Visibility?
        /// The scroll bar options for an axis.
        public let scrollbarOptions: ScrollBarOptions?
        /// The tick label options of an axis.
        public let tickLabelOptions: AxisTickLabelOptions?

        public init(axisLineVisibility: Visibility? = nil, axisOffset: String? = nil, dataOptions: AxisDataOptions? = nil, gridLineVisibility: Visibility? = nil, scrollbarOptions: ScrollBarOptions? = nil, tickLabelOptions: AxisTickLabelOptions? = nil) {
            self.axisLineVisibility = axisLineVisibility
            self.axisOffset = axisOffset
            self.dataOptions = dataOptions
            self.gridLineVisibility = gridLineVisibility
            self.scrollbarOptions = scrollbarOptions
            self.tickLabelOptions = tickLabelOptions
        }

        public func validate(name: String) throws {
            try self.scrollbarOptions?.validate(name: "\(name).scrollbarOptions")
            try self.tickLabelOptions?.validate(name: "\(name).tickLabelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case axisLineVisibility = "AxisLineVisibility"
            case axisOffset = "AxisOffset"
            case dataOptions = "DataOptions"
            case gridLineVisibility = "GridLineVisibility"
            case scrollbarOptions = "ScrollbarOptions"
            case tickLabelOptions = "TickLabelOptions"
        }
    }

    public struct AxisDisplayRange: AWSEncodableShape & AWSDecodableShape {
        /// The data-driven setup of an axis display range.
        public let dataDriven: AxisDisplayDataDrivenRange?
        /// The minimum and maximum setup of an axis display range.
        public let minMax: AxisDisplayMinMaxRange?

        public init(dataDriven: AxisDisplayDataDrivenRange? = nil, minMax: AxisDisplayMinMaxRange? = nil) {
            self.dataDriven = dataDriven
            self.minMax = minMax
        }

        private enum CodingKeys: String, CodingKey {
            case dataDriven = "DataDriven"
            case minMax = "MinMax"
        }
    }

    public struct AxisLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that indicate which field the label belongs to.
        public let applyTo: AxisLabelReferenceOptions?
        /// The text for the axis label.
        public let customLabel: String?
        /// The font configuration of the axis label.
        public let fontConfiguration: FontConfiguration?

        public init(applyTo: AxisLabelReferenceOptions? = nil, customLabel: String? = nil, fontConfiguration: FontConfiguration? = nil) {
            self.applyTo = applyTo
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
        }

        public func validate(name: String) throws {
            try self.applyTo?.validate(name: "\(name).applyTo")
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case applyTo = "ApplyTo"
            case customLabel = "CustomLabel"
            case fontConfiguration = "FontConfiguration"
        }
    }

    public struct AxisLabelReferenceOptions: AWSEncodableShape & AWSDecodableShape {
        /// The column that the axis label is targeted to.
        public let column: ColumnIdentifier
        /// The field that the axis label is targeted to.
        public let fieldId: String

        public init(column: ColumnIdentifier, fieldId: String) {
            self.column = column
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
        }
    }

    public struct AxisLinearScale: AWSEncodableShape & AWSDecodableShape {
        /// The step count setup of a linear axis.
        public let stepCount: Int?
        /// The step size setup of a linear axis.
        public let stepSize: Double?

        public init(stepCount: Int? = nil, stepSize: Double? = nil) {
            self.stepCount = stepCount
            self.stepSize = stepSize
        }

        private enum CodingKeys: String, CodingKey {
            case stepCount = "StepCount"
            case stepSize = "StepSize"
        }
    }

    public struct AxisLogarithmicScale: AWSEncodableShape & AWSDecodableShape {
        /// The base setup of a logarithmic axis scale.
        public let base: Double?

        public init(base: Double? = nil) {
            self.base = base
        }

        private enum CodingKeys: String, CodingKey {
            case base = "Base"
        }
    }

    public struct AxisScale: AWSEncodableShape & AWSDecodableShape {
        /// The linear axis scale setup.
        public let linear: AxisLinearScale?
        /// The logarithmic axis scale setup.
        public let logarithmic: AxisLogarithmicScale?

        public init(linear: AxisLinearScale? = nil, logarithmic: AxisLogarithmicScale? = nil) {
            self.linear = linear
            self.logarithmic = logarithmic
        }

        private enum CodingKeys: String, CodingKey {
            case linear = "Linear"
            case logarithmic = "Logarithmic"
        }
    }

    public struct AxisTickLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not the axis ticks are visible.
        public let labelOptions: LabelOptions?
        /// The rotation angle of the axis tick labels.
        public let rotationAngle: Double?

        public init(labelOptions: LabelOptions? = nil, rotationAngle: Double? = nil) {
            self.labelOptions = labelOptions
            self.rotationAngle = rotationAngle
        }

        public func validate(name: String) throws {
            try self.labelOptions?.validate(name: "\(name).labelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case labelOptions = "LabelOptions"
            case rotationAngle = "RotationAngle"
        }
    }

    public struct BarChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category (y-axis) field well of a bar chart.
        public let category: [DimensionField]?
        /// The color (group/color) field well of a bar chart.
        public let colors: [DimensionField]?
        /// The small multiples field well of a bar chart.
        public let smallMultiples: [DimensionField]?
        /// The value field wells of a bar chart. Values are aggregated by category.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, colors: [DimensionField]? = nil, smallMultiples: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.smallMultiples?.forEach {
                try $0.validate(name: "\(name).smallMultiples[]")
            }
            try self.validate(self.smallMultiples, name: "smallMultiples", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case colors = "Colors"
            case smallMultiples = "SmallMultiples"
            case values = "Values"
        }
    }

    public struct BarChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.
        public let barsArrangement: BarsArrangement?
        /// The label display options (grid line, range, scale, axis step) for bar chart category.
        public let categoryAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.
        public let colorLabelOptions: ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public let contributionAnalysisDefaults: [ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: BarChartFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The orientation of the bars in a bar chart visual. There are two valid values in this structure:    HORIZONTAL: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.    VERTICAL: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.
        public let orientation: BarChartOrientation?
        /// The reference line setup of the visual.
        public let referenceLines: [ReferenceLine]?
        /// The small multiples setup for the visual.
        public let smallMultiplesOptions: SmallMultiplesOptions?
        /// The sort configuration of a BarChartVisual.
        public let sortConfiguration: BarChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The label display options (grid line, range, scale, axis step) for a bar chart value.
        public let valueAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart value.
        public let valueLabelOptions: ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(barsArrangement: BarsArrangement? = nil, categoryAxis: AxisDisplayOptions? = nil, categoryLabelOptions: ChartAxisLabelOptions? = nil, colorLabelOptions: ChartAxisLabelOptions? = nil, contributionAnalysisDefaults: [ContributionAnalysisDefault]? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: BarChartFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, orientation: BarChartOrientation? = nil, referenceLines: [ReferenceLine]? = nil, smallMultiplesOptions: SmallMultiplesOptions? = nil, sortConfiguration: BarChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, valueAxis: AxisDisplayOptions? = nil, valueLabelOptions: ChartAxisLabelOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.orientation = orientation
            self.referenceLines = referenceLines
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueAxis = valueAxis
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryAxis?.validate(name: "\(name).categoryAxis")
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.colorLabelOptions?.validate(name: "\(name).colorLabelOptions")
            try self.contributionAnalysisDefaults?.forEach {
                try $0.validate(name: "\(name).contributionAnalysisDefaults[]")
            }
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, max: 200)
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, min: 1)
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.smallMultiplesOptions?.validate(name: "\(name).smallMultiplesOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.valueAxis?.validate(name: "\(name).valueAxis")
            try self.valueLabelOptions?.validate(name: "\(name).valueLabelOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case barsArrangement = "BarsArrangement"
            case categoryAxis = "CategoryAxis"
            case categoryLabelOptions = "CategoryLabelOptions"
            case colorLabelOptions = "ColorLabelOptions"
            case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case orientation = "Orientation"
            case referenceLines = "ReferenceLines"
            case smallMultiplesOptions = "SmallMultiplesOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case valueAxis = "ValueAxis"
            case valueLabelOptions = "ValueLabelOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct BarChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a bar chart.
        public let barChartAggregatedFieldWells: BarChartAggregatedFieldWells?

        public init(barChartAggregatedFieldWells: BarChartAggregatedFieldWells? = nil) {
            self.barChartAggregatedFieldWells = barChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.barChartAggregatedFieldWells?.validate(name: "\(name).barChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case barChartAggregatedFieldWells = "BarChartAggregatedFieldWells"
        }
    }

    public struct BarChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories displayed in a bar chart.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of category fields.
        public let categorySort: [FieldSortOptions]?
        /// The limit on the number of values displayed in a bar chart.
        public let colorItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of color fields in a bar chart.
        public let colorSort: [FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public let smallMultiplesLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public let smallMultiplesSort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, colorItemsLimit: ItemsLimitConfiguration? = nil, colorSort: [FieldSortOptions]? = nil, smallMultiplesLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.colorSort?.forEach {
                try $0.validate(name: "\(name).colorSort[]")
            }
            try self.validate(self.colorSort, name: "colorSort", parent: name, max: 100)
            try self.smallMultiplesSort?.forEach {
                try $0.validate(name: "\(name).smallMultiplesSort[]")
            }
            try self.validate(self.smallMultiplesSort, name: "smallMultiplesSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
            case colorItemsLimit = "ColorItemsLimit"
            case colorSort = "ColorSort"
            case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
            case smallMultiplesSort = "SmallMultiplesSort"
        }
    }

    public struct BarChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: BarChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: BarChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct BigQueryParameters: AWSEncodableShape & AWSDecodableShape {
        /// The storage location where you create a Google BigQuery data source.
        public let dataSetRegion: String?
        /// The Google Cloud Platform project ID where your datasource was created.
        public let projectId: String

        public init(dataSetRegion: String? = nil, projectId: String) {
            self.dataSetRegion = dataSetRegion
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetRegion, name: "dataSetRegion", parent: name, max: 256)
            try self.validate(self.dataSetRegion, name: "dataSetRegion", parent: name, min: 1)
            try self.validate(self.projectId, name: "projectId", parent: name, max: 256)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetRegion = "DataSetRegion"
            case projectId = "ProjectId"
        }
    }

    public struct BinCountOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the bin count value.
        public let value: Int?

        public init(value: Int? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct BinWidthOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the bin count limit.
        public let binCountLimit: Int64?
        /// The options that determine the bin width value.
        public let value: Double?

        public init(binCountLimit: Int64? = nil, value: Double? = nil) {
            self.binCountLimit = binCountLimit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.binCountLimit, name: "binCountLimit", parent: name, max: 1000)
            try self.validate(self.binCountLimit, name: "binCountLimit", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case binCountLimit = "BinCountLimit"
            case value = "Value"
        }
    }

    public struct BodySectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of content in a body section.
        public let content: BodySectionContent
        /// The configuration of a page break for a section.
        public let pageBreakConfiguration: SectionPageBreakConfiguration?
        /// The unique identifier of a body section.
        public let sectionId: String
        /// The style options of a body section.
        public let style: SectionStyle?

        public init(content: BodySectionContent, pageBreakConfiguration: SectionPageBreakConfiguration? = nil, sectionId: String, style: SectionStyle? = nil) {
            self.content = content
            self.pageBreakConfiguration = pageBreakConfiguration
            self.sectionId = sectionId
            self.style = style
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
            try self.validate(self.sectionId, name: "sectionId", parent: name, max: 512)
            try self.validate(self.sectionId, name: "sectionId", parent: name, min: 1)
            try self.validate(self.sectionId, name: "sectionId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case pageBreakConfiguration = "PageBreakConfiguration"
            case sectionId = "SectionId"
            case style = "Style"
        }
    }

    public struct BodySectionContent: AWSEncodableShape & AWSDecodableShape {
        /// The layout configuration of a body section.
        public let layout: SectionLayoutConfiguration?

        public init(layout: SectionLayoutConfiguration? = nil) {
            self.layout = layout
        }

        public func validate(name: String) throws {
            try self.layout?.validate(name: "\(name).layout")
        }

        private enum CodingKeys: String, CodingKey {
            case layout = "Layout"
        }
    }

    public struct BookmarksConfigurations: AWSEncodableShape {
        /// A Boolean value that determines whether a user can bookmark an embedded dashboard.
        public let enabled: Bool

        public init(enabled: Bool = false) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct BorderStyle: AWSEncodableShape & AWSDecodableShape {
        /// The option to enable display of borders for visuals.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct BoxPlotAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The group by field well of a box plot chart. Values are grouped based on group by fields.
        public let groupBy: [DimensionField]?
        /// The value field well of a box plot chart. Values are aggregated based on group by fields.
        public let values: [MeasureField]?

        public init(groupBy: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.groupBy = groupBy
            self.values = values
        }

        public func validate(name: String) throws {
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case values = "Values"
        }
    }

    public struct BoxPlotChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The box plot chart options for a box plot visual
        public let boxPlotOptions: BoxPlotOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public let categoryAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort Icon visibility) of a box plot category.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: BoxPlotFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        public let legend: LegendOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public let primaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) of a box plot value.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public let referenceLines: [ReferenceLine]?
        /// The sort configuration of a BoxPlotVisual.
        public let sortConfiguration: BoxPlotSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(boxPlotOptions: BoxPlotOptions? = nil, categoryAxis: AxisDisplayOptions? = nil, categoryLabelOptions: ChartAxisLabelOptions? = nil, fieldWells: BoxPlotFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, primaryYAxisDisplayOptions: AxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, referenceLines: [ReferenceLine]? = nil, sortConfiguration: BoxPlotSortConfiguration? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.boxPlotOptions = boxPlotOptions
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryAxis?.validate(name: "\(name).categoryAxis")
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case boxPlotOptions = "BoxPlotOptions"
            case categoryAxis = "CategoryAxis"
            case categoryLabelOptions = "CategoryLabelOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case referenceLines = "ReferenceLines"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
        }
    }

    public struct BoxPlotFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a box plot.
        public let boxPlotAggregatedFieldWells: BoxPlotAggregatedFieldWells?

        public init(boxPlotAggregatedFieldWells: BoxPlotAggregatedFieldWells? = nil) {
            self.boxPlotAggregatedFieldWells = boxPlotAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.boxPlotAggregatedFieldWells?.validate(name: "\(name).boxPlotAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case boxPlotAggregatedFieldWells = "BoxPlotAggregatedFieldWells"
        }
    }

    public struct BoxPlotOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of all data points of the box plot.
        public let allDataPointsVisibility: Visibility?
        /// Determines the visibility of the outlier in a box plot.
        public let outlierVisibility: Visibility?
        /// The style options of the box plot.
        public let styleOptions: BoxPlotStyleOptions?

        public init(allDataPointsVisibility: Visibility? = nil, outlierVisibility: Visibility? = nil, styleOptions: BoxPlotStyleOptions? = nil) {
            self.allDataPointsVisibility = allDataPointsVisibility
            self.outlierVisibility = outlierVisibility
            self.styleOptions = styleOptions
        }

        private enum CodingKeys: String, CodingKey {
            case allDataPointsVisibility = "AllDataPointsVisibility"
            case outlierVisibility = "OutlierVisibility"
            case styleOptions = "StyleOptions"
        }
    }

    public struct BoxPlotSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration of a group by fields.
        public let categorySort: [FieldSortOptions]?
        /// The pagination configuration of a table visual or box plot.
        public let paginationConfiguration: PaginationConfiguration?

        public init(categorySort: [FieldSortOptions]? = nil, paginationConfiguration: PaginationConfiguration? = nil) {
            self.categorySort = categorySort
            self.paginationConfiguration = paginationConfiguration
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.paginationConfiguration?.validate(name: "\(name).paginationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case categorySort = "CategorySort"
            case paginationConfiguration = "PaginationConfiguration"
        }
    }

    public struct BoxPlotStyleOptions: AWSEncodableShape & AWSDecodableShape {
        /// The fill styles (solid, transparent) of the box plot.
        public let fillStyle: BoxPlotFillStyle?

        public init(fillStyle: BoxPlotFillStyle? = nil) {
            self.fillStyle = fillStyle
        }

        private enum CodingKeys: String, CodingKey {
            case fillStyle = "FillStyle"
        }
    }

    public struct BoxPlotVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: BoxPlotChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: BoxPlotChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct CalculatedColumn: AWSEncodableShape & AWSDecodableShape {
        /// A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        public let columnId: String
        /// Column name.
        public let columnName: String
        /// An expression that defines the calculated column.
        public let expression: String

        public init(columnId: String, columnName: String, expression: String) {
            self.columnId = columnId
            self.columnName = columnName
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.columnId, name: "columnId", parent: name, max: 64)
            try self.validate(self.columnId, name: "columnId", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnId = "ColumnId"
            case columnName = "ColumnName"
            case expression = "Expression"
        }
    }

    public struct CalculatedField: AWSEncodableShape & AWSDecodableShape {
        /// The data set that is used in this calculated field.
        public let dataSetIdentifier: String
        /// The expression of the calculated field.
        public let expression: String
        /// The name of the calculated field.
        public let name: String

        public init(dataSetIdentifier: String, expression: String, name: String) {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 32000)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIdentifier = "DataSetIdentifier"
            case expression = "Expression"
            case name = "Name"
        }
    }

    public struct CalculatedMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The expression in the table calculation.
        public let expression: String
        /// The custom field ID.
        public let fieldId: String

        public init(expression: String, fieldId: String) {
            self.expression = expression
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case fieldId = "FieldId"
        }
    }

    public struct CancelIngestionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String

        public init(awsAccountId: String, dataSetId: String, ingestionId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.ingestionId, key: "IngestionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelIngestionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the data ingestion.
        public let arn: String?
        /// An ID for the ingestion.
        public let ingestionId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.ingestionId = try container.decodeIfPresent(String.self, forKey: .ingestionId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
        }
    }

    public struct CascadingControlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of source controls that determine the values that are used in the current control.
        public let sourceControls: [CascadingControlSource]?

        public init(sourceControls: [CascadingControlSource]? = nil) {
            self.sourceControls = sourceControls
        }

        public func validate(name: String) throws {
            try self.sourceControls?.forEach {
                try $0.validate(name: "\(name).sourceControls[]")
            }
            try self.validate(self.sourceControls, name: "sourceControls", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case sourceControls = "SourceControls"
        }
    }

    public struct CascadingControlSource: AWSEncodableShape & AWSDecodableShape {
        /// The column identifier that determines which column to look up for the source sheet control.
        public let columnToMatch: ColumnIdentifier?
        /// The source sheet control ID of a CascadingControlSource.
        public let sourceSheetControlId: String?

        public init(columnToMatch: ColumnIdentifier? = nil, sourceSheetControlId: String? = nil) {
            self.columnToMatch = columnToMatch
            self.sourceSheetControlId = sourceSheetControlId
        }

        public func validate(name: String) throws {
            try self.columnToMatch?.validate(name: "\(name).columnToMatch")
        }

        private enum CodingKeys: String, CodingKey {
            case columnToMatch = "ColumnToMatch"
            case sourceSheetControlId = "SourceSheetControlId"
        }
    }

    public struct CastColumnTypeOperation: AWSEncodableShape & AWSDecodableShape {
        /// Column name.
        public let columnName: String
        /// When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        public let format: String?
        /// New column data type.
        public let newColumnType: ColumnDataType
        /// The sub data type of the new column. Sub types are only available for decimal columns that are part of a SPICE dataset.
        public let subType: ColumnDataSubType?

        public init(columnName: String, format: String? = nil, newColumnType: ColumnDataType, subType: ColumnDataSubType? = nil) {
            self.columnName = columnName
            self.format = format
            self.newColumnType = newColumnType
            self.subType = subType
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.format, name: "format", parent: name, max: 32)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case format = "Format"
            case newColumnType = "NewColumnType"
            case subType = "SubType"
        }
    }

    public struct CategoricalDimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the CategoricalDimensionField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: StringFormatConfiguration?
        /// The custom hierarchy ID.
        public let hierarchyId: String?

        public init(column: ColumnIdentifier, fieldId: String, formatConfiguration: StringFormatConfiguration? = nil, hierarchyId: String? = nil) {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct CategoricalMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the measure field.
        public let aggregationFunction: CategoricalAggregationFunction?
        /// The column that is used in the CategoricalMeasureField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: StringFormatConfiguration?

        public init(aggregationFunction: CategoricalAggregationFunction? = nil, column: ColumnIdentifier, fieldId: String, formatConfiguration: StringFormatConfiguration? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct CategoryDrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// A list of the string inputs that are the values of the category drill down filter.
        public let categoryValues: [String]
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier

        public init(categoryValues: [String], column: ColumnIdentifier) {
            self.categoryValues = categoryValues
            self.column = column
        }

        public func validate(name: String) throws {
            try self.categoryValues.forEach {
                try validate($0, name: "categoryValues[]", parent: name, max: 512)
            }
            try self.validate(self.categoryValues, name: "categoryValues", parent: name, max: 100000)
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValues = "CategoryValues"
            case column = "Column"
        }
    }

    public struct CategoryFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The configuration for a CategoryFilter.
        public let configuration: CategoryFilterConfiguration
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String

        public init(column: ColumnIdentifier, configuration: CategoryFilterConfiguration, filterId: String) {
            self.column = column
            self.configuration = configuration
            self.filterId = filterId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case configuration = "Configuration"
            case filterId = "FilterId"
        }
    }

    public struct CategoryFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom filter that filters based on a single value. This filter can be partially matched.
        public let customFilterConfiguration: CustomFilterConfiguration?
        /// A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.
        public let customFilterListConfiguration: CustomFilterListConfiguration?
        /// A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.
        public let filterListConfiguration: FilterListConfiguration?

        public init(customFilterConfiguration: CustomFilterConfiguration? = nil, customFilterListConfiguration: CustomFilterListConfiguration? = nil, filterListConfiguration: FilterListConfiguration? = nil) {
            self.customFilterConfiguration = customFilterConfiguration
            self.customFilterListConfiguration = customFilterListConfiguration
            self.filterListConfiguration = filterListConfiguration
        }

        public func validate(name: String) throws {
            try self.customFilterConfiguration?.validate(name: "\(name).customFilterConfiguration")
            try self.customFilterListConfiguration?.validate(name: "\(name).customFilterListConfiguration")
            try self.filterListConfiguration?.validate(name: "\(name).filterListConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customFilterConfiguration = "CustomFilterConfiguration"
            case customFilterListConfiguration = "CustomFilterListConfiguration"
            case filterListConfiguration = "FilterListConfiguration"
        }
    }

    public struct CellValueSynonym: AWSEncodableShape & AWSDecodableShape {
        /// The cell value.
        public let cellValue: String?
        /// Other names or aliases for the cell value.
        public let synonyms: [String]?

        public init(cellValue: String? = nil, synonyms: [String]? = nil) {
            self.cellValue = cellValue
            self.synonyms = synonyms
        }

        public func validate(name: String) throws {
            try self.validate(self.cellValue, name: "cellValue", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case cellValue = "CellValue"
            case synonyms = "Synonyms"
        }
    }

    public struct ChartAxisLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The label options for a chart axis.
        public let axisLabelOptions: [AxisLabelOptions]?
        /// The visibility configuration of the sort icon on a chart's axis label.
        public let sortIconVisibility: Visibility?
        /// The visibility of an axis label on a chart. Choose one of the following options:    VISIBLE: Shows the axis.    HIDDEN: Hides the axis.
        public let visibility: Visibility?

        public init(axisLabelOptions: [AxisLabelOptions]? = nil, sortIconVisibility: Visibility? = nil, visibility: Visibility? = nil) {
            self.axisLabelOptions = axisLabelOptions
            self.sortIconVisibility = sortIconVisibility
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.axisLabelOptions?.forEach {
                try $0.validate(name: "\(name).axisLabelOptions[]")
            }
            try self.validate(self.axisLabelOptions, name: "axisLabelOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case axisLabelOptions = "AxisLabelOptions"
            case sortIconVisibility = "SortIconVisibility"
            case visibility = "Visibility"
        }
    }

    public struct ClusterMarker: AWSEncodableShape & AWSDecodableShape {
        /// The simple cluster marker of the cluster marker.
        public let simpleClusterMarker: SimpleClusterMarker?

        public init(simpleClusterMarker: SimpleClusterMarker? = nil) {
            self.simpleClusterMarker = simpleClusterMarker
        }

        public func validate(name: String) throws {
            try self.simpleClusterMarker?.validate(name: "\(name).simpleClusterMarker")
        }

        private enum CodingKeys: String, CodingKey {
            case simpleClusterMarker = "SimpleClusterMarker"
        }
    }

    public struct ClusterMarkerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The cluster marker that is a part of the cluster marker configuration.
        public let clusterMarker: ClusterMarker?

        public init(clusterMarker: ClusterMarker? = nil) {
            self.clusterMarker = clusterMarker
        }

        public func validate(name: String) throws {
            try self.clusterMarker?.validate(name: "\(name).clusterMarker")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterMarker = "ClusterMarker"
        }
    }

    public struct CollectiveConstant: AWSEncodableShape & AWSDecodableShape {
        /// A list of values for the collective constant.
        public let valueList: [String]?

        public init(valueList: [String]? = nil) {
            self.valueList = valueList
        }

        private enum CodingKeys: String, CodingKey {
            case valueList = "ValueList"
        }
    }

    public struct ColorScale: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color fill type.
        public let colorFillType: ColorFillType
        /// Determines the list of colors that are applied to the visual.
        public let colors: [DataColor]
        /// Determines the color that is applied to null values.
        public let nullValueColor: DataColor?

        public init(colorFillType: ColorFillType, colors: [DataColor], nullValueColor: DataColor? = nil) {
            self.colorFillType = colorFillType
            self.colors = colors
            self.nullValueColor = nullValueColor
        }

        public func validate(name: String) throws {
            try self.colors.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 3)
            try self.validate(self.colors, name: "colors", parent: name, min: 2)
            try self.nullValueColor?.validate(name: "\(name).nullValueColor")
        }

        private enum CodingKeys: String, CodingKey {
            case colorFillType = "ColorFillType"
            case colors = "Colors"
            case nullValueColor = "NullValueColor"
        }
    }

    public struct ColorsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of up to 50 custom colors.
        public let customColors: [CustomColor]?

        public init(customColors: [CustomColor]? = nil) {
            self.customColors = customColors
        }

        public func validate(name: String) throws {
            try self.customColors?.forEach {
                try $0.validate(name: "\(name).customColors[]")
            }
            try self.validate(self.customColors, name: "customColors", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case customColors = "CustomColors"
        }
    }

    public struct ColumnConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The color configurations of the column.
        public let colorsConfiguration: ColorsConfiguration?
        /// The column.
        public let column: ColumnIdentifier
        /// The format configuration of a column.
        public let formatConfiguration: FormatConfiguration?
        /// The role of the column.
        public let role: ColumnRole?

        public init(colorsConfiguration: ColorsConfiguration? = nil, column: ColumnIdentifier, formatConfiguration: FormatConfiguration? = nil, role: ColumnRole? = nil) {
            self.colorsConfiguration = colorsConfiguration
            self.column = column
            self.formatConfiguration = formatConfiguration
            self.role = role
        }

        public func validate(name: String) throws {
            try self.colorsConfiguration?.validate(name: "\(name).colorsConfiguration")
            try self.column.validate(name: "\(name).column")
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case colorsConfiguration = "ColorsConfiguration"
            case column = "Column"
            case formatConfiguration = "FormatConfiguration"
            case role = "Role"
        }
    }

    public struct ColumnDescription: AWSEncodableShape & AWSDecodableShape {
        /// The text of a description for a column.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct ColumnGroup: AWSEncodableShape & AWSDecodableShape {
        /// Geospatial column group that denotes a hierarchy.
        public let geoSpatialColumnGroup: GeoSpatialColumnGroup?

        public init(geoSpatialColumnGroup: GeoSpatialColumnGroup? = nil) {
            self.geoSpatialColumnGroup = geoSpatialColumnGroup
        }

        public func validate(name: String) throws {
            try self.geoSpatialColumnGroup?.validate(name: "\(name).geoSpatialColumnGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case geoSpatialColumnGroup = "GeoSpatialColumnGroup"
        }
    }

    public struct ColumnGroupColumnSchema: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column group's column schema.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ColumnGroupSchema: AWSEncodableShape & AWSDecodableShape {
        /// A structure containing the list of schemas for column group columns.
        public let columnGroupColumnSchemaList: [ColumnGroupColumnSchema]?
        /// The name of the column group schema.
        public let name: String?

        public init(columnGroupColumnSchemaList: [ColumnGroupColumnSchema]? = nil, name: String? = nil) {
            self.columnGroupColumnSchemaList = columnGroupColumnSchemaList
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.columnGroupColumnSchemaList, name: "columnGroupColumnSchemaList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroupColumnSchemaList = "ColumnGroupColumnSchemaList"
            case name = "Name"
        }
    }

    public struct ColumnHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the hierarchy of any DateTime fields.
        public let dateTimeHierarchy: DateTimeHierarchy?
        /// The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.
        public let explicitHierarchy: ExplicitHierarchy?
        /// The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.
        public let predefinedHierarchy: PredefinedHierarchy?

        public init(dateTimeHierarchy: DateTimeHierarchy? = nil, explicitHierarchy: ExplicitHierarchy? = nil, predefinedHierarchy: PredefinedHierarchy? = nil) {
            self.dateTimeHierarchy = dateTimeHierarchy
            self.explicitHierarchy = explicitHierarchy
            self.predefinedHierarchy = predefinedHierarchy
        }

        public func validate(name: String) throws {
            try self.dateTimeHierarchy?.validate(name: "\(name).dateTimeHierarchy")
            try self.explicitHierarchy?.validate(name: "\(name).explicitHierarchy")
            try self.predefinedHierarchy?.validate(name: "\(name).predefinedHierarchy")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeHierarchy = "DateTimeHierarchy"
            case explicitHierarchy = "ExplicitHierarchy"
            case predefinedHierarchy = "PredefinedHierarchy"
        }
    }

    public struct ColumnIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The data set that the column belongs to.
        public let dataSetIdentifier: String

        public init(columnName: String, dataSetIdentifier: String) {
            self.columnName = columnName
            self.dataSetIdentifier = dataSetIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case dataSetIdentifier = "DataSetIdentifier"
        }
    }

    public struct ColumnLevelPermissionRule: AWSEncodableShape & AWSDecodableShape {
        /// An array of column names.
        public let columnNames: [String]?
        /// An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.
        public let principals: [String]?

        public init(columnNames: [String]? = nil, principals: [String]? = nil) {
            self.columnNames = columnNames
            self.principals = principals
        }

        public func validate(name: String) throws {
            try self.validate(self.columnNames, name: "columnNames", parent: name, min: 1)
            try self.validate(self.principals, name: "principals", parent: name, max: 100)
            try self.validate(self.principals, name: "principals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "ColumnNames"
            case principals = "Principals"
        }
    }

    public struct ColumnSchema: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the column schema.
        public let dataType: String?
        /// The geographic role of the column schema.
        public let geographicRole: String?
        /// The name of the column schema.
        public let name: String?

        public init(dataType: String? = nil, geographicRole: String? = nil, name: String? = nil) {
            self.dataType = dataType
            self.geographicRole = geographicRole
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "DataType"
            case geographicRole = "GeographicRole"
            case name = "Name"
        }
    }

    public struct ColumnSort: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function that is defined in the column sort.
        public let aggregationFunction: AggregationFunction?
        /// The sort direction.
        public let direction: SortDirection
        public let sortBy: ColumnIdentifier

        public init(aggregationFunction: AggregationFunction? = nil, direction: SortDirection, sortBy: ColumnIdentifier) {
            self.aggregationFunction = aggregationFunction
            self.direction = direction
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.sortBy.validate(name: "\(name).sortBy")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case direction = "Direction"
            case sortBy = "SortBy"
        }
    }

    public struct ColumnTag: AWSEncodableShape & AWSDecodableShape {
        /// A description for a column.
        public let columnDescription: ColumnDescription?
        /// A geospatial role for a column.
        public let columnGeographicRole: GeoSpatialDataRole?

        public init(columnDescription: ColumnDescription? = nil, columnGeographicRole: GeoSpatialDataRole? = nil) {
            self.columnDescription = columnDescription
            self.columnGeographicRole = columnGeographicRole
        }

        public func validate(name: String) throws {
            try self.columnDescription?.validate(name: "\(name).columnDescription")
        }

        private enum CodingKeys: String, CodingKey {
            case columnDescription = "ColumnDescription"
            case columnGeographicRole = "ColumnGeographicRole"
        }
    }

    public struct ColumnTooltipItem: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the column tooltip item.
        public let aggregation: AggregationFunction?
        /// The target column of the tooltip item.
        public let column: ColumnIdentifier
        /// The label of the tooltip item.
        public let label: String?
        /// Determines the target of the column tooltip item in a combo chart visual.
        public let tooltipTarget: TooltipTarget?
        /// The visibility of the tooltip item.
        public let visibility: Visibility?

        public init(aggregation: AggregationFunction? = nil, column: ColumnIdentifier, label: String? = nil, tooltipTarget: TooltipTarget? = nil, visibility: Visibility? = nil) {
            self.aggregation = aggregation
            self.column = column
            self.label = label
            self.tooltipTarget = tooltipTarget
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.aggregation?.validate(name: "\(name).aggregation")
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "Aggregation"
            case column = "Column"
            case label = "Label"
            case tooltipTarget = "TooltipTarget"
            case visibility = "Visibility"
        }
    }

    public struct ComboChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated BarValues field well of a combo chart.
        public let barValues: [MeasureField]?
        /// The aggregated category field wells of a combo chart.
        public let category: [DimensionField]?
        /// The aggregated colors field well of a combo chart.
        public let colors: [DimensionField]?
        /// The aggregated LineValues field well of a combo chart.
        public let lineValues: [MeasureField]?

        public init(barValues: [MeasureField]? = nil, category: [DimensionField]? = nil, colors: [DimensionField]? = nil, lineValues: [MeasureField]? = nil) {
            self.barValues = barValues
            self.category = category
            self.colors = colors
            self.lineValues = lineValues
        }

        public func validate(name: String) throws {
            try self.barValues?.forEach {
                try $0.validate(name: "\(name).barValues[]")
            }
            try self.validate(self.barValues, name: "barValues", parent: name, max: 200)
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.lineValues?.forEach {
                try $0.validate(name: "\(name).lineValues[]")
            }
            try self.validate(self.lineValues, name: "lineValues", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case barValues = "BarValues"
            case category = "Category"
            case colors = "Colors"
            case lineValues = "LineValues"
        }
    }

    public struct ComboChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine if visual data labels are displayed. The data label options for a bar in a combo chart.
        public let barDataLabels: DataLabelOptions?
        /// Determines the bar arrangement in a combo chart. The following are valid values in this structure:    CLUSTERED: For clustered bar combo charts.    STACKED: For stacked bar combo charts.    STACKED_PERCENT: Do not use. If you use this value, the operation returns a validation error.
        public let barsArrangement: BarsArrangement?
        /// The category axis of a combo chart.
        public let categoryAxis: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.
        public let colorLabelOptions: ChartAxisLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: ComboChartFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The options that determine if visual data labels are displayed. The data label options for a line in a combo chart.
        public let lineDataLabels: DataLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.
        public let primaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public let referenceLines: [ReferenceLine]?
        /// The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.
        public let secondaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.
        public let secondaryYAxisLabelOptions: ChartAxisLabelOptions?
        public let singleAxisOptions: SingleAxisOptions?
        /// The sort configuration of a ComboChartVisual.
        public let sortConfiguration: ComboChartSortConfiguration?
        /// The legend display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(barDataLabels: DataLabelOptions? = nil, barsArrangement: BarsArrangement? = nil, categoryAxis: AxisDisplayOptions? = nil, categoryLabelOptions: ChartAxisLabelOptions? = nil, colorLabelOptions: ChartAxisLabelOptions? = nil, fieldWells: ComboChartFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, lineDataLabels: DataLabelOptions? = nil, primaryYAxisDisplayOptions: AxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, referenceLines: [ReferenceLine]? = nil, secondaryYAxisDisplayOptions: AxisDisplayOptions? = nil, secondaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, singleAxisOptions: SingleAxisOptions? = nil, sortConfiguration: ComboChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.barDataLabels = barDataLabels
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.lineDataLabels = lineDataLabels
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.singleAxisOptions = singleAxisOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.barDataLabels?.validate(name: "\(name).barDataLabels")
            try self.categoryAxis?.validate(name: "\(name).categoryAxis")
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.colorLabelOptions?.validate(name: "\(name).colorLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.lineDataLabels?.validate(name: "\(name).lineDataLabels")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.secondaryYAxisDisplayOptions?.validate(name: "\(name).secondaryYAxisDisplayOptions")
            try self.secondaryYAxisLabelOptions?.validate(name: "\(name).secondaryYAxisLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case barDataLabels = "BarDataLabels"
            case barsArrangement = "BarsArrangement"
            case categoryAxis = "CategoryAxis"
            case categoryLabelOptions = "CategoryLabelOptions"
            case colorLabelOptions = "ColorLabelOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case lineDataLabels = "LineDataLabels"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case referenceLines = "ReferenceLines"
            case secondaryYAxisDisplayOptions = "SecondaryYAxisDisplayOptions"
            case secondaryYAxisLabelOptions = "SecondaryYAxisLabelOptions"
            case singleAxisOptions = "SingleAxisOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
        }
    }

    public struct ComboChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.
        public let comboChartAggregatedFieldWells: ComboChartAggregatedFieldWells?

        public init(comboChartAggregatedFieldWells: ComboChartAggregatedFieldWells? = nil) {
            self.comboChartAggregatedFieldWells = comboChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.comboChartAggregatedFieldWells?.validate(name: "\(name).comboChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case comboChartAggregatedFieldWells = "ComboChartAggregatedFieldWells"
        }
    }

    public struct ComboChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The item limit configuration for the category field well of a combo chart.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category field well in a combo chart.
        public let categorySort: [FieldSortOptions]?
        /// The item limit configuration of the color field well in a combo chart.
        public let colorItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the color field well in a combo chart.
        public let colorSort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, colorItemsLimit: ItemsLimitConfiguration? = nil, colorSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.colorSort?.forEach {
                try $0.validate(name: "\(name).colorSort[]")
            }
            try self.validate(self.colorSort, name: "colorSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
            case colorItemsLimit = "ColorItemsLimit"
            case colorSort = "ColorSort"
        }
    }

    public struct ComboChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: ComboChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: ComboChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct ComparativeOrder: AWSEncodableShape & AWSDecodableShape {
        /// The list of columns to be used in the ordering.
        public let specifedOrder: [String]?
        /// The treat of undefined specified values. Valid values for this structure are LEAST and MOST.
        public let treatUndefinedSpecifiedValues: UndefinedSpecifiedValueType?
        /// The ordering type for a column. Valid values for this structure are GREATER_IS_BETTER, LESSER_IS_BETTER and SPECIFIED.
        public let useOrdering: ColumnOrderingType?

        public init(specifedOrder: [String]? = nil, treatUndefinedSpecifiedValues: UndefinedSpecifiedValueType? = nil, useOrdering: ColumnOrderingType? = nil) {
            self.specifedOrder = specifedOrder
            self.treatUndefinedSpecifiedValues = treatUndefinedSpecifiedValues
            self.useOrdering = useOrdering
        }

        private enum CodingKeys: String, CodingKey {
            case specifedOrder = "SpecifedOrder"
            case treatUndefinedSpecifiedValues = "TreatUndefinedSpecifiedValues"
            case useOrdering = "UseOrdering"
        }
    }

    public struct ComparisonConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The format of the comparison.
        public let comparisonFormat: ComparisonFormatConfiguration?
        /// The method of the comparison. Choose from the following options:    DIFFERENCE     PERCENT_DIFFERENCE     PERCENT
        public let comparisonMethod: ComparisonMethod?

        public init(comparisonFormat: ComparisonFormatConfiguration? = nil, comparisonMethod: ComparisonMethod? = nil) {
            self.comparisonFormat = comparisonFormat
            self.comparisonMethod = comparisonMethod
        }

        public func validate(name: String) throws {
            try self.comparisonFormat?.validate(name: "\(name).comparisonFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonFormat = "ComparisonFormat"
            case comparisonMethod = "ComparisonMethod"
        }
    }

    public struct ComparisonFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number display format.
        public let numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration?
        /// The percentage display format.
        public let percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration?

        public init(numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration? = nil, percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration? = nil) {
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.numberDisplayFormatConfiguration?.validate(name: "\(name).numberDisplayFormatConfiguration")
            try self.percentageDisplayFormatConfiguration?.validate(name: "\(name).percentageDisplayFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case numberDisplayFormatConfiguration = "NumberDisplayFormatConfiguration"
            case percentageDisplayFormatConfiguration = "PercentageDisplayFormatConfiguration"
        }
    }

    public struct Computation: AWSEncodableShape & AWSDecodableShape {
        /// The forecast computation configuration.
        public let forecast: ForecastComputation?
        /// The growth rate computation configuration.
        public let growthRate: GrowthRateComputation?
        /// The maximum and minimum computation configuration.
        public let maximumMinimum: MaximumMinimumComputation?
        /// The metric comparison computation configuration.
        public let metricComparison: MetricComparisonComputation?
        /// The period over period computation configuration.
        public let periodOverPeriod: PeriodOverPeriodComputation?
        /// The period to DataSetIdentifier computation configuration.
        public let periodToDate: PeriodToDateComputation?
        /// The top movers and bottom movers computation configuration.
        public let topBottomMovers: TopBottomMoversComputation?
        /// The top ranked and bottom ranked computation configuration.
        public let topBottomRanked: TopBottomRankedComputation?
        /// The total aggregation computation configuration.
        public let totalAggregation: TotalAggregationComputation?
        /// The unique values computation configuration.
        public let uniqueValues: UniqueValuesComputation?

        public init(forecast: ForecastComputation? = nil, growthRate: GrowthRateComputation? = nil, maximumMinimum: MaximumMinimumComputation? = nil, metricComparison: MetricComparisonComputation? = nil, periodOverPeriod: PeriodOverPeriodComputation? = nil, periodToDate: PeriodToDateComputation? = nil, topBottomMovers: TopBottomMoversComputation? = nil, topBottomRanked: TopBottomRankedComputation? = nil, totalAggregation: TotalAggregationComputation? = nil, uniqueValues: UniqueValuesComputation? = nil) {
            self.forecast = forecast
            self.growthRate = growthRate
            self.maximumMinimum = maximumMinimum
            self.metricComparison = metricComparison
            self.periodOverPeriod = periodOverPeriod
            self.periodToDate = periodToDate
            self.topBottomMovers = topBottomMovers
            self.topBottomRanked = topBottomRanked
            self.totalAggregation = totalAggregation
            self.uniqueValues = uniqueValues
        }

        public func validate(name: String) throws {
            try self.forecast?.validate(name: "\(name).forecast")
            try self.growthRate?.validate(name: "\(name).growthRate")
            try self.maximumMinimum?.validate(name: "\(name).maximumMinimum")
            try self.metricComparison?.validate(name: "\(name).metricComparison")
            try self.periodOverPeriod?.validate(name: "\(name).periodOverPeriod")
            try self.periodToDate?.validate(name: "\(name).periodToDate")
            try self.topBottomMovers?.validate(name: "\(name).topBottomMovers")
            try self.topBottomRanked?.validate(name: "\(name).topBottomRanked")
            try self.totalAggregation?.validate(name: "\(name).totalAggregation")
            try self.uniqueValues?.validate(name: "\(name).uniqueValues")
        }

        private enum CodingKeys: String, CodingKey {
            case forecast = "Forecast"
            case growthRate = "GrowthRate"
            case maximumMinimum = "MaximumMinimum"
            case metricComparison = "MetricComparison"
            case periodOverPeriod = "PeriodOverPeriod"
            case periodToDate = "PeriodToDate"
            case topBottomMovers = "TopBottomMovers"
            case topBottomRanked = "TopBottomRanked"
            case totalAggregation = "TotalAggregation"
            case uniqueValues = "UniqueValues"
        }
    }

    public struct ConditionalFormattingColor: AWSEncodableShape & AWSDecodableShape {
        /// Formatting configuration for gradient color.
        public let gradient: ConditionalFormattingGradientColor?
        /// Formatting configuration for solid color.
        public let solid: ConditionalFormattingSolidColor?

        public init(gradient: ConditionalFormattingGradientColor? = nil, solid: ConditionalFormattingSolidColor? = nil) {
            self.gradient = gradient
            self.solid = solid
        }

        public func validate(name: String) throws {
            try self.gradient?.validate(name: "\(name).gradient")
            try self.solid?.validate(name: "\(name).solid")
        }

        private enum CodingKeys: String, CodingKey {
            case gradient = "Gradient"
            case solid = "Solid"
        }
    }

    public struct ConditionalFormattingCustomIconCondition: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color of the icon.
        public let color: String?
        /// Determines the icon display configuration.
        public let displayConfiguration: ConditionalFormattingIconDisplayConfiguration?
        /// The expression that determines the condition of the icon set.
        public let expression: String
        /// Custom icon options for an icon set.
        public let iconOptions: ConditionalFormattingCustomIconOptions

        public init(color: String? = nil, displayConfiguration: ConditionalFormattingIconDisplayConfiguration? = nil, expression: String, iconOptions: ConditionalFormattingCustomIconOptions) {
            self.color = color
            self.displayConfiguration = displayConfiguration
            self.expression = expression
            self.iconOptions = iconOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.iconOptions.validate(name: "\(name).iconOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case displayConfiguration = "DisplayConfiguration"
            case expression = "Expression"
            case iconOptions = "IconOptions"
        }
    }

    public struct ConditionalFormattingCustomIconOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the type of icon.
        public let icon: Icon?
        /// Determines the Unicode icon type.
        public let unicodeIcon: String?

        public init(icon: Icon? = nil, unicodeIcon: String? = nil) {
            self.icon = icon
            self.unicodeIcon = unicodeIcon
        }

        public func validate(name: String) throws {
            try self.validate(self.unicodeIcon, name: "unicodeIcon", parent: name, pattern: "^[^\\u0000-\\u00FF]$")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case unicodeIcon = "UnicodeIcon"
        }
    }

    public struct ConditionalFormattingGradientColor: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color.
        public let color: GradientColor
        /// The expression that determines the formatting configuration for gradient color.
        public let expression: String

        public init(color: GradientColor, expression: String) {
            self.color = color
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.color.validate(name: "\(name).color")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case expression = "Expression"
        }
    }

    public struct ConditionalFormattingIcon: AWSEncodableShape & AWSDecodableShape {
        /// Determines the custom condition for an icon set.
        public let customCondition: ConditionalFormattingCustomIconCondition?
        /// Formatting configuration for icon set.
        public let iconSet: ConditionalFormattingIconSet?

        public init(customCondition: ConditionalFormattingCustomIconCondition? = nil, iconSet: ConditionalFormattingIconSet? = nil) {
            self.customCondition = customCondition
            self.iconSet = iconSet
        }

        public func validate(name: String) throws {
            try self.customCondition?.validate(name: "\(name).customCondition")
            try self.iconSet?.validate(name: "\(name).iconSet")
        }

        private enum CodingKeys: String, CodingKey {
            case customCondition = "CustomCondition"
            case iconSet = "IconSet"
        }
    }

    public struct ConditionalFormattingIconDisplayConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the icon display configuration.
        public let iconDisplayOption: ConditionalFormattingIconDisplayOption?

        public init(iconDisplayOption: ConditionalFormattingIconDisplayOption? = nil) {
            self.iconDisplayOption = iconDisplayOption
        }

        private enum CodingKeys: String, CodingKey {
            case iconDisplayOption = "IconDisplayOption"
        }
    }

    public struct ConditionalFormattingIconSet: AWSEncodableShape & AWSDecodableShape {
        /// The expression that determines the formatting configuration for the icon set.
        public let expression: String
        /// Determines the icon set type.
        public let iconSetType: ConditionalFormattingIconSetType?

        public init(expression: String, iconSetType: ConditionalFormattingIconSetType? = nil) {
            self.expression = expression
            self.iconSetType = iconSetType
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case iconSetType = "IconSetType"
        }
    }

    public struct ConditionalFormattingSolidColor: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color.
        public let color: String?
        /// The expression that determines the formatting configuration for solid color.
        public let expression: String

        public init(color: String? = nil, expression: String) {
            self.color = color
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case expression = "Expression"
        }
    }

    public struct ContextMenuOption: AWSEncodableShape & AWSDecodableShape {
        /// The availability status of the context menu options. If the value of this property is set to ENABLED, dashboard readers can interact with the context menu.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct ContributionAnalysisDefault: AWSEncodableShape & AWSDecodableShape {
        /// The dimensions columns that are used in the contribution analysis, usually a list of ColumnIdentifiers.
        public let contributorDimensions: [ColumnIdentifier]
        /// The measure field that is used in the contribution analysis.
        public let measureFieldId: String

        public init(contributorDimensions: [ColumnIdentifier], measureFieldId: String) {
            self.contributorDimensions = contributorDimensions
            self.measureFieldId = measureFieldId
        }

        public func validate(name: String) throws {
            try self.contributorDimensions.forEach {
                try $0.validate(name: "\(name).contributorDimensions[]")
            }
            try self.validate(self.contributorDimensions, name: "contributorDimensions", parent: name, max: 4)
            try self.validate(self.contributorDimensions, name: "contributorDimensions", parent: name, min: 1)
            try self.validate(self.measureFieldId, name: "measureFieldId", parent: name, max: 512)
            try self.validate(self.measureFieldId, name: "measureFieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contributorDimensions = "ContributorDimensions"
            case measureFieldId = "MeasureFieldId"
        }
    }

    public struct CreateAccountCustomizationRequest: AWSEncodableShape {
        /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region. You can add these to an Amazon Web Services account and a QuickSight namespace.  For example, you can add a default theme by setting AccountCustomization to the midnight theme: "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight::aws:theme/MIDNIGHT" }. Or, you can add a custom theme by specifying "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639" }.
        public let accountCustomization: AccountCustomization
        /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
        public let awsAccountId: String
        /// The Amazon QuickSight namespace that you want to add customizations to.
        public let namespace: String?
        /// A list of the tags that you want to attach to this resource.
        public let tags: [Tag]?

        public init(accountCustomization: AccountCustomization, awsAccountId: String, namespace: String? = nil, tags: [Tag]? = nil) {
            self.accountCustomization = accountCustomization
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.accountCustomization, forKey: .accountCustomization)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.namespace, key: "namespace")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case tags = "Tags"
        }
    }

    public struct CreateAccountCustomizationResponse: AWSDecodableShape {
        /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) for the customization that you created for this Amazon Web Services account.
        public let arn: String?
        /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
        public let awsAccountId: String?
        /// The namespace associated with the customization you're creating.
        public let namespace: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accountCustomization = try container.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.awsAccountId = try container.decodeIfPresent(String.self, forKey: .awsAccountId)
            self.namespace = try container.decodeIfPresent(String.self, forKey: .namespace)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
        }
    }

    public struct CreateAccountSubscriptionRequest: AWSEncodableShape {
        /// The name of your Amazon QuickSight account. This name is unique over all of Amazon Web Services, and it appears only when users sign in. You can't change AccountName value after the Amazon QuickSight account is created.
        public let accountName: String
        /// The name of your Active Directory. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
        public let activeDirectoryName: String?
        /// The admin group associated with your Active Directory or IAM Identity Center account. This field is required if ACTIVE_DIRECTORY or IAM_IDENTITY_CENTER is the selected authentication method of the new Amazon QuickSight account. For more information about using IAM Identity Center in Amazon QuickSight, see Using IAM Identity Center with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see Using Active Directory with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide.
        public let adminGroup: [String]?
        /// The method that you want to use to authenticate your Amazon QuickSight account. If you choose ACTIVE_DIRECTORY, provide an ActiveDirectoryName and an AdminGroup associated with your Active Directory. If you choose IAM_IDENTITY_CENTER, provide an AdminGroup associated with your IAM Identity Center account.
        public let authenticationMethod: AuthenticationMethodOption
        /// The author group associated with your Active Directory or IAM Identity Center account. For more information about using IAM Identity Center in Amazon QuickSight, see Using IAM Identity Center with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see Using Active Directory with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide.
        public let authorGroup: [String]?
        /// The Amazon Web Services account ID of the account that you're using to create your Amazon QuickSight account.
        public let awsAccountId: String
        /// A 10-digit phone number for the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let contactNumber: String?
        /// The ID of the Active Directory that is associated with your Amazon QuickSight account.
        public let directoryId: String?
        /// The edition of Amazon QuickSight that you want your account to have. Currently, you can choose from ENTERPRISE or ENTERPRISE_AND_Q. If you choose ENTERPRISE_AND_Q, the following parameters are required:    FirstName     LastName     EmailAddress     ContactNumber
        public let edition: Edition
        /// The email address of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let emailAddress: String?
        /// The first name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let firstName: String?
        /// The Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public let iamIdentityCenterInstanceArn: String?
        /// The last name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
        public let lastName: String?
        /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon QuickSight account or Amazon QuickSight subscription.
        public let notificationEmail: String
        /// The reader group associated with your Active Directory or IAM Identity Center account. For more information about using IAM Identity Center in Amazon QuickSight, see Using IAM Identity Center with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see Using Active Directory with Amazon QuickSight Enterprise Edition in the Amazon QuickSight User Guide.
        public let readerGroup: [String]?
        /// The realm of the Active Directory that is associated with your Amazon QuickSight account. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
        public let realm: String?

        public init(accountName: String, activeDirectoryName: String? = nil, adminGroup: [String]? = nil, authenticationMethod: AuthenticationMethodOption, authorGroup: [String]? = nil, awsAccountId: String, contactNumber: String? = nil, directoryId: String? = nil, edition: Edition, emailAddress: String? = nil, firstName: String? = nil, iamIdentityCenterInstanceArn: String? = nil, lastName: String? = nil, notificationEmail: String, readerGroup: [String]? = nil, realm: String? = nil) {
            self.accountName = accountName
            self.activeDirectoryName = activeDirectoryName
            self.adminGroup = adminGroup
            self.authenticationMethod = authenticationMethod
            self.authorGroup = authorGroup
            self.awsAccountId = awsAccountId
            self.contactNumber = contactNumber
            self.directoryId = directoryId
            self.edition = edition
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.iamIdentityCenterInstanceArn = iamIdentityCenterInstanceArn
            self.lastName = lastName
            self.notificationEmail = notificationEmail
            self.readerGroup = readerGroup
            self.realm = realm
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.accountName, forKey: .accountName)
            try container.encodeIfPresent(self.activeDirectoryName, forKey: .activeDirectoryName)
            try container.encodeIfPresent(self.adminGroup, forKey: .adminGroup)
            try container.encode(self.authenticationMethod, forKey: .authenticationMethod)
            try container.encodeIfPresent(self.authorGroup, forKey: .authorGroup)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.contactNumber, forKey: .contactNumber)
            try container.encodeIfPresent(self.directoryId, forKey: .directoryId)
            try container.encode(self.edition, forKey: .edition)
            try container.encodeIfPresent(self.emailAddress, forKey: .emailAddress)
            try container.encodeIfPresent(self.firstName, forKey: .firstName)
            try container.encodeIfPresent(self.iamIdentityCenterInstanceArn, forKey: .iamIdentityCenterInstanceArn)
            try container.encodeIfPresent(self.lastName, forKey: .lastName)
            try container.encode(self.notificationEmail, forKey: .notificationEmail)
            try container.encodeIfPresent(self.readerGroup, forKey: .readerGroup)
            try container.encodeIfPresent(self.realm, forKey: .realm)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountName, name: "accountName", parent: name, max: 62)
            try self.validate(self.accountName, name: "accountName", parent: name, min: 1)
            try self.validate(self.accountName, name: "accountName", parent: name, pattern: "^(?!D-|d-)([\\da-zA-Z]+)([-]*[\\da-zA-Z])*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "AccountName"
            case activeDirectoryName = "ActiveDirectoryName"
            case adminGroup = "AdminGroup"
            case authenticationMethod = "AuthenticationMethod"
            case authorGroup = "AuthorGroup"
            case contactNumber = "ContactNumber"
            case directoryId = "DirectoryId"
            case edition = "Edition"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case iamIdentityCenterInstanceArn = "IAMIdentityCenterInstanceArn"
            case lastName = "LastName"
            case notificationEmail = "NotificationEmail"
            case readerGroup = "ReaderGroup"
            case realm = "Realm"
        }
    }

    public struct CreateAccountSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// A SignupResponse object that returns information about a newly created Amazon QuickSight account.
        public let signupResponse: SignupResponse?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, signupResponse: SignupResponse? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.signupResponse = signupResponse
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.signupResponse = try container.decodeIfPresent(SignupResponse.self, forKey: .signupResponse)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case signupResponse = "SignupResponse"
        }
    }

    public struct CreateAnalysisRequest: AWSEncodableShape {
        /// The ID for the analysis that you're creating. This ID displays in the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account where you are creating an analysis.
        public let awsAccountId: String
        /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis. Either a SourceEntity or a Definition must be provided in  order for the request to be valid.
        public let definition: AnalysisDefinition?
        /// When you create the analysis, Amazon QuickSight adds the analysis to these folders.
        public let folderArns: [String]?
        /// A descriptive name for the analysis that you're creating. This name displays for the analysis in the Amazon QuickSight console.
        public let name: String
        /// The parameter names and override values that you want to use. An analysis can have  any parameter type, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A structure that describes the principals and the resource-level permissions on an analysis. You can use the Permissions structure to grant permissions by providing a list of Identity and Access Management (IAM) action information for each principal listed by Amazon Resource Name (ARN).  To specify no permissions, omit Permissions.
        public let permissions: [ResourcePermission]?
        /// A source entity to use for the analysis that you're creating. This metadata structure contains details that describe a source template and one or more datasets. Either a SourceEntity or a Definition must be provided in  order for the request to be valid.
        public let sourceEntity: AnalysisSourceEntity?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the analysis.
        public let tags: [Tag]?
        /// The ARN for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
        public let themeArn: String?
        /// The option to relax the validation needed to create an analysis with definition objects. This skips the validation step for specific errors.
        public let validationStrategy: ValidationStrategy?

        public init(analysisId: String, awsAccountId: String, definition: AnalysisDefinition? = nil, folderArns: [String]? = nil, name: String, parameters: Parameters? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: AnalysisSourceEntity? = nil, tags: [Tag]? = nil, themeArn: String? = nil, validationStrategy: ValidationStrategy? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.folderArns = folderArns
            self.name = name
            self.parameters = parameters
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.themeArn = themeArn
            self.validationStrategy = validationStrategy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.folderArns, forKey: .folderArns)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encodeIfPresent(self.sourceEntity, forKey: .sourceEntity)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.themeArn, forKey: .themeArn)
            try container.encodeIfPresent(self.validationStrategy, forKey: .validationStrategy)
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.folderArns, name: "folderArns", parent: name, max: 1)
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case folderArns = "FolderArns"
            case name = "Name"
            case parameters = "Parameters"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case themeArn = "ThemeArn"
            case validationStrategy = "ValidationStrategy"
        }
    }

    public struct CreateAnalysisResponse: AWSDecodableShape {
        /// The ID of the analysis.
        public let analysisId: String?
        /// The ARN for the analysis.
        public let arn: String?
        /// The status of the creation of the analysis.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisId = try container.decodeIfPresent(String.self, forKey: .analysisId)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.creationStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
        }
    }

    public struct CreateColumnsOperation: AWSEncodableShape & AWSDecodableShape {
        /// Calculated columns to create.
        public let columns: [CalculatedColumn]

        public init(columns: [CalculatedColumn]) {
            self.columns = columns
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 128)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account where you want to create the dashboard.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the IAM policy.
        public let dashboardId: String
        /// Options for publishing the dashboard when you create it:    AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.     AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.     VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
        public let dashboardPublishOptions: DashboardPublishOptions?
        /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis. Either a SourceEntity or a Definition must be provided in  order for the request to be valid.
        public let definition: DashboardVersionDefinition?
        /// When you create the dashboard, Amazon QuickSight adds the dashboard to these folders.
        public let folderArns: [String]?
        /// A list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
        public let linkEntities: [String]?
        /// A structure that contains the permissions of a shareable link to the dashboard.
        public let linkSharingConfiguration: LinkSharingConfiguration?
        /// The display name of the dashboard.
        public let name: String
        /// The parameters for the creation of the dashboard, which you want to use to override the default settings. A dashboard can have any type of parameters, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A structure that contains the permissions of the dashboard. You can use this structure for granting permissions by providing a list of IAM action information for each principal ARN.  To specify no permissions, omit the permissions list.
        public let permissions: [ResourcePermission]?
        /// The entity that you are using as a source when you create the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only create a dashboard from a template, so you use a SourceTemplate entity. If you need to create a dashboard from an analysis, first convert the analysis to a template by using the  CreateTemplate  API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplateARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region.  Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.  Either a SourceEntity or a Definition must be provided in  order for the request to be valid.
        public let sourceEntity: DashboardSourceEntity?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dashboard.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that is used in the source entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
        public let themeArn: String?
        /// The option to relax the validation needed to create a dashboard with definition objects. This option skips the validation step for specific errors.
        public let validationStrategy: ValidationStrategy?
        /// A description for the first version of the dashboard being created.
        public let versionDescription: String?

        public init(awsAccountId: String, dashboardId: String, dashboardPublishOptions: DashboardPublishOptions? = nil, definition: DashboardVersionDefinition? = nil, folderArns: [String]? = nil, linkEntities: [String]? = nil, linkSharingConfiguration: LinkSharingConfiguration? = nil, name: String, parameters: Parameters? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: DashboardSourceEntity? = nil, tags: [Tag]? = nil, themeArn: String? = nil, validationStrategy: ValidationStrategy? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.dashboardPublishOptions = dashboardPublishOptions
            self.definition = definition
            self.folderArns = folderArns
            self.linkEntities = linkEntities
            self.linkSharingConfiguration = linkSharingConfiguration
            self.name = name
            self.parameters = parameters
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.themeArn = themeArn
            self.validationStrategy = validationStrategy
            self.versionDescription = versionDescription
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            try container.encodeIfPresent(self.dashboardPublishOptions, forKey: .dashboardPublishOptions)
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.folderArns, forKey: .folderArns)
            try container.encodeIfPresent(self.linkEntities, forKey: .linkEntities)
            try container.encodeIfPresent(self.linkSharingConfiguration, forKey: .linkSharingConfiguration)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encodeIfPresent(self.sourceEntity, forKey: .sourceEntity)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.themeArn, forKey: .themeArn)
            try container.encodeIfPresent(self.validationStrategy, forKey: .validationStrategy)
            try container.encodeIfPresent(self.versionDescription, forKey: .versionDescription)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.folderArns, name: "folderArns", parent: name, max: 1)
            try self.linkEntities?.forEach {
                try validate($0, name: "linkEntities[]", parent: name, max: 1024)
                try validate($0, name: "linkEntities[]", parent: name, min: 1)
                try validate($0, name: "linkEntities[]", parent: name, pattern: "^arn:aws[\\w\\-]*:quicksight:[\\w\\-]+:\\d+:analysis/[\\w\\-]{1,512}$")
            }
            try self.validate(self.linkEntities, name: "linkEntities", parent: name, max: 5)
            try self.linkSharingConfiguration?.validate(name: "\(name).linkSharingConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardPublishOptions = "DashboardPublishOptions"
            case definition = "Definition"
            case folderArns = "FolderArns"
            case linkEntities = "LinkEntities"
            case linkSharingConfiguration = "LinkSharingConfiguration"
            case name = "Name"
            case parameters = "Parameters"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case themeArn = "ThemeArn"
            case validationStrategy = "ValidationStrategy"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {
        /// The ARN of the dashboard.
        public let arn: String?
        /// The status of the dashboard creation request.
        public let creationStatus: ResourceStatus?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the dashboard, including the version number of the first version that is created.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
            self.versionArn = versionArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.creationStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
            self.dashboardId = try container.decodeIfPresent(String.self, forKey: .dashboardId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.versionArn = try container.decodeIfPresent(String.self, forKey: .versionArn)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case versionArn = "VersionArn"
        }
    }

    public struct CreateDataSetRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// An ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String
        /// The parameter declarations of the dataset.
        public let datasetParameters: [DatasetParameter]?
        public let dataSetUsageConfiguration: DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// When you create the dataset, Amazon QuickSight adds the dataset to these folders.
        public let folderArns: [String]?
        /// Indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// The display name for the dataset.
        public let name: String
        /// A list of resource permissions on the dataset.
        public let permissions: [ResourcePermission]?
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]
        /// The row-level security configuration for the data that you want to create.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
        public let rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.
        public let tags: [Tag]?

        public init(awsAccountId: String, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, dataSetId: String, datasetParameters: [DatasetParameter]? = nil, dataSetUsageConfiguration: DataSetUsageConfiguration? = nil, fieldFolders: [String: FieldFolder]? = nil, folderArns: [String]? = nil, importMode: DataSetImportMode, logicalTableMap: [String: LogicalTable]? = nil, name: String, permissions: [ResourcePermission]? = nil, physicalTableMap: [String: PhysicalTable], rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration? = nil, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.dataSetId = dataSetId
            self.datasetParameters = datasetParameters
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.folderArns = folderArns
            self.importMode = importMode
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.permissions = permissions
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.columnGroups, forKey: .columnGroups)
            try container.encodeIfPresent(self.columnLevelPermissionRules, forKey: .columnLevelPermissionRules)
            try container.encode(self.dataSetId, forKey: .dataSetId)
            try container.encodeIfPresent(self.datasetParameters, forKey: .datasetParameters)
            try container.encodeIfPresent(self.dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
            try container.encodeIfPresent(self.fieldFolders, forKey: .fieldFolders)
            try container.encodeIfPresent(self.folderArns, forKey: .folderArns)
            try container.encode(self.importMode, forKey: .importMode)
            try container.encodeIfPresent(self.logicalTableMap, forKey: .logicalTableMap)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encode(self.physicalTableMap, forKey: .physicalTableMap)
            try container.encodeIfPresent(self.rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
            try container.encodeIfPresent(self.rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.columnGroups?.forEach {
                try $0.validate(name: "\(name).columnGroups[]")
            }
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, max: 8)
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, min: 1)
            try self.columnLevelPermissionRules?.forEach {
                try $0.validate(name: "\(name).columnLevelPermissionRules[]")
            }
            try self.validate(self.columnLevelPermissionRules, name: "columnLevelPermissionRules", parent: name, min: 1)
            try self.datasetParameters?.forEach {
                try $0.validate(name: "\(name).datasetParameters[]")
            }
            try self.validate(self.datasetParameters, name: "datasetParameters", parent: name, max: 32)
            try self.validate(self.datasetParameters, name: "datasetParameters", parent: name, min: 1)
            try self.fieldFolders?.forEach {
                try validate($0.key, name: "fieldFolders.key", parent: name, max: 1000)
                try validate($0.key, name: "fieldFolders.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).fieldFolders[\"\($0.key)\"]")
            }
            try self.validate(self.folderArns, name: "folderArns", parent: name, max: 1)
            try self.logicalTableMap?.forEach {
                try validate($0.key, name: "logicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "logicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "logicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).logicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, max: 64)
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.physicalTableMap.forEach {
                try validate($0.key, name: "physicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "physicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "physicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).physicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.physicalTableMap, name: "physicalTableMap", parent: name, max: 32)
            try self.rowLevelPermissionDataSet?.validate(name: "\(name).rowLevelPermissionDataSet")
            try self.rowLevelPermissionTagConfiguration?.validate(name: "\(name).rowLevelPermissionTagConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case dataSetId = "DataSetId"
            case datasetParameters = "DatasetParameters"
            case dataSetUsageConfiguration = "DataSetUsageConfiguration"
            case fieldFolders = "FieldFolders"
            case folderArns = "FolderArns"
            case importMode = "ImportMode"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case permissions = "Permissions"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateDataSetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionArn: String?
        /// The ID of the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, ingestionArn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.ingestionArn = ingestionArn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.dataSetId = try container.decodeIfPresent(String.self, forKey: .dataSetId)
            self.ingestionArn = try container.decodeIfPresent(String.self, forKey: .ingestionArn)
            self.ingestionId = try container.decodeIfPresent(String.self, forKey: .ingestionId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case ingestionArn = "IngestionArn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The credentials Amazon QuickSight that uses to connect to your underlying source. Currently, only
        /// 			credentials based on user name and password are supported.
        public let credentials: DataSourceCredentials?
        /// An ID for the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String
        /// The parameters that Amazon QuickSight uses to connect to your underlying source.
        public let dataSourceParameters: DataSourceParameters?
        /// When you create the data source, Amazon QuickSight adds the data source to these folders.
        public let folderArns: [String]?
        /// A display name for the data source.
        public let name: String
        /// A list of resource permissions on the data source.
        public let permissions: [ResourcePermission]?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
        public let sslProperties: SslProperties?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.
        public let tags: [Tag]?
        /// The type of the data source. To return a
        /// 			list of all data sources, use ListDataSources. Use AMAZON_ELASTICSEARCH for Amazon OpenSearch Service.
        public let type: DataSourceType
        /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to
        /// 			your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(awsAccountId: String, credentials: DataSourceCredentials? = nil, dataSourceId: String, dataSourceParameters: DataSourceParameters? = nil, folderArns: [String]? = nil, name: String, permissions: [ResourcePermission]? = nil, sslProperties: SslProperties? = nil, tags: [Tag]? = nil, type: DataSourceType, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.awsAccountId = awsAccountId
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.folderArns = folderArns
            self.name = name
            self.permissions = permissions
            self.sslProperties = sslProperties
            self.tags = tags
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.credentials, forKey: .credentials)
            try container.encode(self.dataSourceId, forKey: .dataSourceId)
            try container.encodeIfPresent(self.dataSourceParameters, forKey: .dataSourceParameters)
            try container.encodeIfPresent(self.folderArns, forKey: .folderArns)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encodeIfPresent(self.sslProperties, forKey: .sslProperties)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
            try container.encodeIfPresent(self.vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.credentials?.validate(name: "\(name).credentials")
            try self.dataSourceParameters?.validate(name: "\(name).dataSourceParameters")
            try self.validate(self.folderArns, name: "folderArns", parent: name, max: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case dataSourceId = "DataSourceId"
            case dataSourceParameters = "DataSourceParameters"
            case folderArns = "FolderArns"
            case name = "Name"
            case permissions = "Permissions"
            case sslProperties = "SslProperties"
            case tags = "Tags"
            case type = "Type"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The status of creating the data source.
        public let creationStatus: ResourceStatus?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.creationStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
            self.dataSourceId = try container.decodeIfPresent(String.self, forKey: .dataSourceId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
        }
    }

    public struct CreateFolderMembershipRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The ID of the asset that you want to add to the folder.
        public let memberId: String
        /// The member type of the asset that you want to add to a folder.
        public let memberType: MemberType

        public init(awsAccountId: String, folderId: String, memberId: String, memberType: MemberType) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.memberId = memberId
            self.memberType = memberType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodePath(self.memberId, key: "MemberId")
            request.encodePath(self.memberType, key: "MemberType")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 2048)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateFolderMembershipResponse: AWSDecodableShape {
        /// Information about the member in the folder.
        public let folderMember: FolderMember?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderMember: FolderMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderMember = folderMember
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case folderMember = "FolderMember"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct CreateFolderRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account where you want to create the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The type of folder. By default, folderType is SHARED.
        public let folderType: FolderType?
        /// The name of the folder.
        public let name: String?
        /// The Amazon Resource Name (ARN) for the parent folder.  ParentFolderArn can be null. An empty parentFolderArn creates a root-level folder.
        public let parentFolderArn: String?
        /// A structure that describes the principals and the resource-level permissions of a folder. To specify no permissions, omit Permissions.
        public let permissions: [ResourcePermission]?
        /// An optional parameter that determines the sharing scope of the folder. The default value for this parameter is ACCOUNT.
        public let sharingModel: SharingModel?
        /// Tags for the folder.
        public let tags: [Tag]?

        public init(awsAccountId: String, folderId: String, folderType: FolderType? = nil, name: String? = nil, parentFolderArn: String? = nil, permissions: [ResourcePermission]? = nil, sharingModel: SharingModel? = nil, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.folderType = folderType
            self.name = name
            self.parentFolderArn = parentFolderArn
            self.permissions = permissions
            self.sharingModel = sharingModel
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            try container.encodeIfPresent(self.folderType, forKey: .folderType)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.parentFolderArn, forKey: .parentFolderArn)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encodeIfPresent(self.sharingModel, forKey: .sharingModel)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case folderType = "FolderType"
            case name = "Name"
            case parentFolderArn = "ParentFolderArn"
            case permissions = "Permissions"
            case sharingModel = "SharingModel"
            case tags = "Tags"
        }
    }

    public struct CreateFolderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the newly created folder.
        public let arn: String?
        /// The folder ID for the newly created folder.
        public let folderId: String?
        /// The request ID for the newly created folder.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.folderId = try container.decodeIfPresent(String.self, forKey: .folderId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
        }
    }

    public struct CreateGroupMembershipRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to add the user to.
        public let groupName: String
        /// The name of the user that you want to add to the group membership.
        public let memberName: String
        /// The namespace that you want the user to be a part of.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.groupName, key: "GroupName")
            request.encodePath(self.memberName, key: "MemberName")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateGroupMembershipResponse: AWSDecodableShape {
        /// The group member.
        public let groupMember: GroupMember?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMember: GroupMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMember = groupMember
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.groupMember = try container.decodeIfPresent(GroupMember.self, forKey: .groupMember)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case groupMember = "GroupMember"
            case requestId = "RequestId"
        }
    }

    public struct CreateGroupRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// A description for the group that you want to create.
        public let description: String?
        /// A name for the group that you want to create.
        public let groupName: String
        /// The namespace that you want the group to be a part of.
        public let namespace: String

        public init(awsAccountId: String, description: String? = nil, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.groupName = groupName
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.groupName, forKey: .groupName)
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case groupName = "GroupName"
        }
    }

    public struct CreateGroupResponse: AWSDecodableShape {
        /// The name of the group.
        public let group: Group?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.group = try container.decodeIfPresent(Group.self, forKey: .group)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
        }
    }

    public struct CreateIAMPolicyAssignmentRequest: AWSEncodableShape {
        /// The name of the assignment, also called a rule.
        /// 			The
        /// 			name
        /// 			must be unique within the
        /// 			Amazon Web Services account.
        public let assignmentName: String
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when
        /// 					creating the data source.    DISABLED - This assignment isn't used when creating the data
        /// 					source.    DRAFT - This assignment is an unfinished draft and isn't used
        /// 					when creating the data source.
        public let assignmentStatus: AssignmentStatus
        /// The ID of the Amazon Web Services account where you want to assign an IAM policy to Amazon QuickSight users or groups.
        public let awsAccountId: String
        /// The Amazon QuickSight users, groups, or both that you want to assign the policy
        /// 			to.
        public let identities: [String: [String]]?
        /// The namespace that contains the assignment.
        public let namespace: String
        /// The ARN for the IAM policy to apply to the Amazon QuickSight users and
        /// 			groups specified in this assignment.
        public let policyArn: String?

        public init(assignmentName: String, assignmentStatus: AssignmentStatus, awsAccountId: String, identities: [String: [String]]? = nil, namespace: String, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.namespace = namespace
            self.policyArn = policyArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.assignmentName, forKey: .assignmentName)
            try container.encode(self.assignmentStatus, forKey: .assignmentStatus)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.identities, forKey: .identities)
            request.encodePath(self.namespace, key: "Namespace")
            try container.encodeIfPresent(self.policyArn, forKey: .policyArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct CreateIAMPolicyAssignmentResponse: AWSDecodableShape {
        /// The ID for the assignment.
        public let assignmentId: String?
        /// The name of the assignment.
        /// 			The
        /// 			name must be unique within the Amazon Web Services account.
        public let assignmentName: String?
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when
        /// 					creating the data source.    DISABLED - This assignment isn't used when creating the data
        /// 					source.    DRAFT - This assignment is an unfinished draft and isn't used
        /// 					when creating the data source.
        public let assignmentStatus: AssignmentStatus?
        /// The Amazon QuickSight users, groups, or both that the IAM policy is
        /// 			assigned to.
        public let identities: [String: [String]]?
        /// The ARN for the IAM policy that is applied to the Amazon QuickSight
        /// 			users and groups specified in this assignment.
        public let policyArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.identities = identities
            self.policyArn = policyArn
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.assignmentId = try container.decodeIfPresent(String.self, forKey: .assignmentId)
            self.assignmentName = try container.decodeIfPresent(String.self, forKey: .assignmentName)
            self.assignmentStatus = try container.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
            self.identities = try container.decodeIfPresent([String: [String]].self, forKey: .identities)
            self.policyArn = try container.decodeIfPresent(String.self, forKey: .policyArn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
            case requestId = "RequestId"
        }
    }

    public struct CreateIngestionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String
        /// The type of ingestion that you want to create.
        public let ingestionType: IngestionType?

        public init(awsAccountId: String, dataSetId: String, ingestionId: String, ingestionType: IngestionType? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
            self.ingestionType = ingestionType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.ingestionId, key: "IngestionId")
            try container.encodeIfPresent(self.ingestionType, forKey: .ingestionType)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionType = "IngestionType"
        }
    }

    public struct CreateIngestionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the data ingestion.
        public let arn: String?
        /// An ID for the ingestion.
        public let ingestionId: String?
        /// The ingestion status.
        public let ingestionStatus: IngestionStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, ingestionId: String? = nil, ingestionStatus: IngestionStatus? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.ingestionId = ingestionId
            self.ingestionStatus = ingestionStatus
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.ingestionId = try container.decodeIfPresent(String.self, forKey: .ingestionId)
            self.ingestionStatus = try container.decodeIfPresent(IngestionStatus.self, forKey: .ingestionStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case ingestionId = "IngestionId"
            case ingestionStatus = "IngestionStatus"
            case requestId = "RequestId"
        }
    }

    public struct CreateNamespaceRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to create the Amazon QuickSight namespace in.
        public let awsAccountId: String
        /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
        public let identityStore: IdentityStore
        /// The name that you want to use to describe the new namespace.
        public let namespace: String
        /// The tags that you want to associate with the namespace that you're creating.
        public let tags: [Tag]?

        public init(awsAccountId: String, identityStore: IdentityStore, namespace: String, tags: [Tag]? = nil) {
            self.awsAccountId = awsAccountId
            self.identityStore = identityStore
            self.namespace = namespace
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.identityStore, forKey: .identityStore)
            try container.encode(self.namespace, forKey: .namespace)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStore = "IdentityStore"
            case namespace = "Namespace"
            case tags = "Tags"
        }
    }

    public struct CreateNamespaceResponse: AWSDecodableShape {
        /// The ARN of the Amazon QuickSight namespace you created.
        public let arn: String?
        /// The Amazon Web Services Region; that you want to use for the free SPICE capacity for the new namespace. This is set to the region that you run CreateNamespace in.
        public let capacityRegion: String?
        /// The status of the creation of the namespace. This is an asynchronous process. A status of CREATED means that your namespace is ready to use. If an error occurs, it indicates if the process is retryable or non-retryable. In the case of a non-retryable error, refer to the error message for follow-up tasks.
        public let creationStatus: NamespaceStatus?
        /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
        public let identityStore: IdentityStore?
        /// The name of the new namespace that you created.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, capacityRegion: String? = nil, creationStatus: NamespaceStatus? = nil, identityStore: IdentityStore? = nil, name: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.capacityRegion = try container.decodeIfPresent(String.self, forKey: .capacityRegion)
            self.creationStatus = try container.decodeIfPresent(NamespaceStatus.self, forKey: .creationStatus)
            self.identityStore = try container.decodeIfPresent(IdentityStore.self, forKey: .identityStore)
            self.name = try container.decodeIfPresent(String.self, forKey: .name)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacityRegion = "CapacityRegion"
            case creationStatus = "CreationStatus"
            case identityStore = "IdentityStore"
            case name = "Name"
            case requestId = "RequestId"
        }
    }

    public struct CreateRefreshScheduleRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String
        /// The refresh schedule.
        public let schedule: RefreshSchedule

        public init(awsAccountId: String, dataSetId: String, schedule: RefreshSchedule) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.schedule = schedule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encode(self.schedule, forKey: .schedule)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.schedule.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "Schedule"
        }
    }

    public struct CreateRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the refresh schedule.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The ID of the refresh schedule.
        public let scheduleId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, requestId: String? = nil, scheduleId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.scheduleId = scheduleId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.scheduleId = try container.decodeIfPresent(String.self, forKey: .scheduleId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case scheduleId = "ScheduleId"
        }
    }

    public struct CreateRoleMembershipRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to add to the role.
        public let memberName: String
        /// The namespace that the role belongs to.
        public let namespace: String
        /// The role that you want to add a group to.
        public let role: Role

        public init(awsAccountId: String, memberName: String, namespace: String, role: Role) {
            self.awsAccountId = awsAccountId
            self.memberName = memberName
            self.namespace = namespace
            self.role = role
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.memberName, key: "MemberName")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.role, key: "Role")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateRoleMembershipResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct CreateTemplateAliasRequest: AWSEncodableShape {
        /// The name that you want to give to the template alias that you're creating. Don't start the
        /// 			alias name with the $ character. Alias names that start with $
        /// 			are reserved by Amazon QuickSight.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the template that you creating an alias for.
        public let awsAccountId: String
        /// An ID for the template.
        public let templateId: String
        /// The version number of the template.
        public let templateVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, templateId: String, templateVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.templateVersionNumber = templateVersionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
            try container.encode(self.templateVersionNumber, forKey: .templateVersionNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.templateVersionNumber, name: "templateVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct CreateTemplateAliasResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateAlias = try container.decodeIfPresent(TemplateAlias.self, forKey: .templateAlias)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct CreateTemplateRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. You use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis. Either a SourceEntity or a Definition must be provided in
        /// 			order for the request to be valid.
        public let definition: TemplateVersionDefinition?
        /// A display name for the template.
        public let name: String?
        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The entity that you are using as a source when you create the template. In
        /// 			SourceEntity, you specify the type of object you're using as source:
        /// 			SourceTemplate for a template or SourceAnalysis for an
        /// 			analysis. Both of these require an Amazon Resource Name (ARN). For
        /// 			SourceTemplate, specify the ARN of the source template. For
        /// 			SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate
        /// 			ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region.  Use the DataSetReferences entity within SourceTemplate or
        /// 			SourceAnalysis to list the replacement datasets for the placeholders listed
        /// 			in the original. The schema in each dataset must match its placeholder.  Either a SourceEntity or a Definition must be provided in
        /// 			order for the request to be valid.
        public let sourceEntity: TemplateSourceEntity?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [Tag]?
        /// An ID for the template that you want to create. This template is unique per Amazon Web Services Region; in
        /// 			each Amazon Web Services account.
        public let templateId: String
        /// TThe option to relax the validation needed to create a template with definition objects. This skips the validation step for specific errors.
        public let validationStrategy: ValidationStrategy?
        /// A description of the current template version being created. This API operation creates the
        /// 			first version of the template. Every time UpdateTemplate is called, a new
        /// 			version is created. Each version of the template maintains a description of the version
        /// 			in the VersionDescription field.
        public let versionDescription: String?

        public init(awsAccountId: String, definition: TemplateVersionDefinition? = nil, name: String? = nil, permissions: [ResourcePermission]? = nil, sourceEntity: TemplateSourceEntity? = nil, tags: [Tag]? = nil, templateId: String, validationStrategy: ValidationStrategy? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.name = name
            self.permissions = permissions
            self.sourceEntity = sourceEntity
            self.tags = tags
            self.templateId = templateId
            self.validationStrategy = validationStrategy
            self.versionDescription = versionDescription
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encodeIfPresent(self.sourceEntity, forKey: .sourceEntity)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.templateId, key: "TemplateId")
            try container.encodeIfPresent(self.validationStrategy, forKey: .validationStrategy)
            try container.encodeIfPresent(self.versionDescription, forKey: .versionDescription)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case name = "Name"
            case permissions = "Permissions"
            case sourceEntity = "SourceEntity"
            case tags = "Tags"
            case validationStrategy = "ValidationStrategy"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateTemplateResponse: AWSDecodableShape {
        /// The ARN for the template.
        public let arn: String?
        /// The template creation status.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the template.
        public let templateId: String?
        /// The ARN for the template, including the version information of
        /// 			the first version.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
            self.versionArn = versionArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.creationStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
            self.versionArn = try container.decodeIfPresent(String.self, forKey: .versionArn)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case templateId = "TemplateId"
            case versionArn = "VersionArn"
        }
    }

    public struct CreateThemeAliasRequest: AWSEncodableShape {
        /// The name that you want to give to the theme alias that you are creating. The
        /// 			alias name can't begin with a $. Alias names that start with $
        /// 			are reserved by Amazon QuickSight.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme for the new theme alias.
        public let awsAccountId: String
        /// An ID for the theme alias.
        public let themeId: String
        /// The version number of the theme.
        public let themeVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, themeId: String, themeVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.themeVersionNumber = themeVersionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.themeId, key: "ThemeId")
            try container.encode(self.themeVersionNumber, forKey: .themeVersionNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.themeVersionNumber, name: "themeVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct CreateThemeAliasResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeAlias = try container.decodeIfPresent(ThemeAlias.self, forKey: .themeAlias)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct CreateThemeRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account where you want to store the new theme.
        public let awsAccountId: String
        /// The ID of the theme that a custom theme will inherit from. All themes inherit from one of
        /// 			the starting themes defined by Amazon QuickSight. For a list of the starting themes, use
        /// 				ListThemes or choose Themes from
        /// 			within an analysis.
        public let baseThemeId: String
        /// The theme configuration, which contains the theme display properties.
        public let configuration: ThemeConfiguration
        /// A display name for the theme.
        public let name: String
        /// A valid grouping of resource permissions to apply to the new theme.
        ///
        public let permissions: [ResourcePermission]?
        /// A map of the key-value pairs for the resource tag or tags that you want to add to the
        /// 			resource.
        public let tags: [Tag]?
        /// An ID for the theme that you want to create. The theme ID is unique per Amazon Web Services Region in
        /// 			each Amazon Web Services account.
        public let themeId: String
        /// A description of the first version of the theme that you're creating. Every time
        /// 				UpdateTheme is called, a new version is created. Each version of the
        /// 			theme has a description of the version in the VersionDescription
        /// 			field.
        public let versionDescription: String?

        public init(awsAccountId: String, baseThemeId: String, configuration: ThemeConfiguration, name: String, permissions: [ResourcePermission]? = nil, tags: [Tag]? = nil, themeId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.name = name
            self.permissions = permissions
            self.tags = tags
            self.themeId = themeId
            self.versionDescription = versionDescription
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.baseThemeId, forKey: .baseThemeId)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.themeId, key: "ThemeId")
            try container.encodeIfPresent(self.versionDescription, forKey: .versionDescription)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, max: 512)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, min: 1)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case name = "Name"
            case permissions = "Permissions"
            case tags = "Tags"
            case versionDescription = "VersionDescription"
        }
    }

    public struct CreateThemeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the theme.
        public let arn: String?
        /// The theme creation status.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the theme.
        public let themeId: String?
        /// The Amazon Resource Name (ARN) for the new theme.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
            self.versionArn = versionArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.creationStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeId = try container.decodeIfPresent(String.self, forKey: .themeId)
            self.versionArn = try container.decodeIfPresent(String.self, forKey: .versionArn)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case themeId = "ThemeId"
            case versionArn = "VersionArn"
        }
    }

    public struct CreateTopicRefreshScheduleRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic you're creating a refresh schedule for.
        public let awsAccountId: String
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String
        /// The name of the dataset.
        public let datasetName: String?
        /// The definition of a refresh schedule.
        public let refreshSchedule: TopicRefreshSchedule
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, datasetArn: String, datasetName: String? = nil, refreshSchedule: TopicRefreshSchedule, topicId: String) {
            self.awsAccountId = awsAccountId
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.refreshSchedule = refreshSchedule
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.datasetArn, forKey: .datasetArn)
            try container.encodeIfPresent(self.datasetName, forKey: .datasetName)
            try container.encode(self.refreshSchedule, forKey: .refreshSchedule)
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.refreshSchedule.validate(name: "\(name).refreshSchedule")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case datasetName = "DatasetName"
            case refreshSchedule = "RefreshSchedule"
        }
    }

    public struct CreateTopicRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the topic.
        public let topicArn: String?
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(datasetArn: String? = nil, requestId: String? = nil, status: Int? = nil, topicArn: String? = nil, topicId: String? = nil) {
            self.datasetArn = datasetArn
            self.requestId = requestId
            self.status = status
            self.topicArn = topicArn
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.datasetArn = try container.decodeIfPresent(String.self, forKey: .datasetArn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicArn = try container.decodeIfPresent(String.self, forKey: .topicArn)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case requestId = "RequestId"
            case topicArn = "TopicArn"
            case topicId = "TopicId"
        }
    }

    public struct CreateTopicRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that you want to create a topic in.
        public let awsAccountId: String
        /// Contains a map of the key-value pairs for the resource tag or tags that are assigned to the dataset.
        public let tags: [Tag]?
        /// The definition of a topic to create.
        public let topic: TopicDetails
        /// The ID for the topic that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, tags: [Tag]? = nil, topic: TopicDetails, topicId: String) {
            self.awsAccountId = awsAccountId
            self.tags = tags
            self.topic = topic
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.topic, forKey: .topic)
            try container.encode(self.topicId, forKey: .topicId)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.topic.validate(name: "\(name).topic")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case topic = "Topic"
            case topicId = "TopicId"
        }
    }

    public struct CreateTopicResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the topic.
        public let arn: String?
        /// The Amazon Resource Name (ARN) of the topic refresh.
        public let refreshArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the topic that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(arn: String? = nil, refreshArn: String? = nil, requestId: String? = nil, status: Int? = nil, topicId: String? = nil) {
            self.arn = arn
            self.refreshArn = refreshArn
            self.requestId = requestId
            self.status = status
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.refreshArn = try container.decodeIfPresent(String.self, forKey: .refreshArn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case refreshArn = "RefreshArn"
            case requestId = "RequestId"
            case topicId = "TopicId"
        }
    }

    public struct CreateVPCConnectionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the account where you want to create a new VPC
        /// 			connection.
        public let awsAccountId: String
        /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
        public let dnsResolvers: [String]?
        /// The display name for the VPC connection.
        public let name: String
        /// The IAM role to associate with the VPC connection.
        public let roleArn: String
        /// A list of security group IDs for the VPC connection.
        public let securityGroupIds: [String]
        /// A list of subnet IDs for the VPC connection.
        public let subnetIds: [String]
        /// A map of the key-value pairs for the resource tag or tags assigned to the VPC
        /// 			connection.
        public let tags: [Tag]?
        /// The ID of the VPC connection that
        /// 			you're creating. This ID is a unique identifier for each Amazon Web Services Region in an
        /// 				Amazon Web Services account.
        public let vpcConnectionId: String

        public init(awsAccountId: String, dnsResolvers: [String]? = nil, name: String, roleArn: String, securityGroupIds: [String], subnetIds: [String], tags: [Tag]? = nil, vpcConnectionId: String) {
            self.awsAccountId = awsAccountId
            self.dnsResolvers = dnsResolvers
            self.name = name
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcConnectionId = vpcConnectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.dnsResolvers, forKey: .dnsResolvers)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.securityGroupIds, forKey: .securityGroupIds)
            try container.encode(self.subnetIds, forKey: .subnetIds)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.vpcConnectionId, forKey: .vpcConnectionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.dnsResolvers?.forEach {
                try validate($0, name: "dnsResolvers[]", parent: name, max: 15)
                try validate($0, name: "dnsResolvers[]", parent: name, min: 7)
            }
            try self.validate(self.dnsResolvers, name: "dnsResolvers", parent: name, max: 15)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-z]*$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 16)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 255)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[0-9a-z]*$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 15)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 2)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, max: 1000)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, min: 1)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dnsResolvers = "DnsResolvers"
            case name = "Name"
            case roleArn = "RoleArn"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case tags = "Tags"
            case vpcConnectionId = "VPCConnectionId"
        }
    }

    public struct CreateVPCConnectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public let arn: String?
        /// The availability status of the VPC connection.
        public let availabilityStatus: VPCConnectionAvailabilityStatus?
        /// The status of the creation of the VPC connection.
        public let creationStatus: VPCConnectionResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the VPC connection that
        /// 			you're creating. This ID is unique per Amazon Web Services Region for each Amazon Web Services
        /// 			account.
        public let vpcConnectionId: String?

        public init(arn: String? = nil, availabilityStatus: VPCConnectionAvailabilityStatus? = nil, creationStatus: VPCConnectionResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, vpcConnectionId: String? = nil) {
            self.arn = arn
            self.availabilityStatus = availabilityStatus
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.vpcConnectionId = vpcConnectionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.availabilityStatus = try container.decodeIfPresent(VPCConnectionAvailabilityStatus.self, forKey: .availabilityStatus)
            self.creationStatus = try container.decodeIfPresent(VPCConnectionResourceStatus.self, forKey: .creationStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.vpcConnectionId = try container.decodeIfPresent(String.self, forKey: .vpcConnectionId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case availabilityStatus = "AvailabilityStatus"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case vpcConnectionId = "VPCConnectionId"
        }
    }

    public struct CredentialPair: AWSEncodableShape {
        /// A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the AlternateDataSourceParameters list is null, the DataSourceParameters originally used with these Credentials is automatically allowed.
        public let alternateDataSourceParameters: [DataSourceParameters]?
        /// Password.
        public let password: String
        /// User name.
        public let username: String

        public init(alternateDataSourceParameters: [DataSourceParameters]? = nil, password: String, username: String) {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.alternateDataSourceParameters?.forEach {
                try $0.validate(name: "\(name).alternateDataSourceParameters[]")
            }
            try self.validate(self.alternateDataSourceParameters, name: "alternateDataSourceParameters", parent: name, max: 50)
            try self.validate(self.alternateDataSourceParameters, name: "alternateDataSourceParameters", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, max: 1024)
            try self.validate(self.password, name: "password", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 64)
            try self.validate(self.username, name: "username", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case alternateDataSourceParameters = "AlternateDataSourceParameters"
            case password = "Password"
            case username = "Username"
        }
    }

    public struct CurrencyDisplayFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the decimal places configuration.
        public let decimalPlacesConfiguration: DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public let negativeValueConfiguration: NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// Determines the number scale value for the currency format.
        public let numberScale: NumberScale?
        /// Determines the prefix value of the currency format.
        public let prefix: String?
        /// The options that determine the numeric separator configuration.
        public let separatorConfiguration: NumericSeparatorConfiguration?
        /// Determines the suffix value of the currency format.
        public let suffix: String?
        /// Determines the symbol for the currency format.
        public let symbol: String?

        public init(decimalPlacesConfiguration: DecimalPlacesConfiguration? = nil, negativeValueConfiguration: NegativeValueConfiguration? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numberScale: NumberScale? = nil, prefix: String? = nil, separatorConfiguration: NumericSeparatorConfiguration? = nil, suffix: String? = nil, symbol: String? = nil) {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.prefix = prefix
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
            self.symbol = symbol
        }

        public func validate(name: String) throws {
            try self.decimalPlacesConfiguration?.validate(name: "\(name).decimalPlacesConfiguration")
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 128)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
            try self.validate(self.symbol, name: "symbol", parent: name, pattern: "^[A-Z]{3}$")
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
            case negativeValueConfiguration = "NegativeValueConfiguration"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numberScale = "NumberScale"
            case prefix = "Prefix"
            case separatorConfiguration = "SeparatorConfiguration"
            case suffix = "Suffix"
            case symbol = "Symbol"
        }
    }

    public struct CustomActionFilterOperation: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that chooses the fields to be filtered.
        public let selectedFieldsConfiguration: FilterOperationSelectedFieldsConfiguration
        /// The configuration that chooses the target visuals to be filtered.
        public let targetVisualsConfiguration: FilterOperationTargetVisualsConfiguration

        public init(selectedFieldsConfiguration: FilterOperationSelectedFieldsConfiguration, targetVisualsConfiguration: FilterOperationTargetVisualsConfiguration) {
            self.selectedFieldsConfiguration = selectedFieldsConfiguration
            self.targetVisualsConfiguration = targetVisualsConfiguration
        }

        public func validate(name: String) throws {
            try self.selectedFieldsConfiguration.validate(name: "\(name).selectedFieldsConfiguration")
            try self.targetVisualsConfiguration.validate(name: "\(name).targetVisualsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case selectedFieldsConfiguration = "SelectedFieldsConfiguration"
            case targetVisualsConfiguration = "TargetVisualsConfiguration"
        }
    }

    public struct CustomActionNavigationOperation: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that chooses the navigation target.
        public let localNavigationConfiguration: LocalNavigationConfiguration?

        public init(localNavigationConfiguration: LocalNavigationConfiguration? = nil) {
            self.localNavigationConfiguration = localNavigationConfiguration
        }

        public func validate(name: String) throws {
            try self.localNavigationConfiguration?.validate(name: "\(name).localNavigationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case localNavigationConfiguration = "LocalNavigationConfiguration"
        }
    }

    public struct CustomActionSetParametersOperation: AWSEncodableShape & AWSDecodableShape {
        /// The parameter that determines the value configuration.
        public let parameterValueConfigurations: [SetParameterValueConfiguration]

        public init(parameterValueConfigurations: [SetParameterValueConfiguration]) {
            self.parameterValueConfigurations = parameterValueConfigurations
        }

        public func validate(name: String) throws {
            try self.parameterValueConfigurations.forEach {
                try $0.validate(name: "\(name).parameterValueConfigurations[]")
            }
            try self.validate(self.parameterValueConfigurations, name: "parameterValueConfigurations", parent: name, max: 200)
            try self.validate(self.parameterValueConfigurations, name: "parameterValueConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parameterValueConfigurations = "ParameterValueConfigurations"
        }
    }

    public struct CustomActionURLOperation: AWSEncodableShape & AWSDecodableShape {
        /// The target of the CustomActionURLOperation. Valid values are defined as follows:    NEW_TAB: Opens the target URL in a new browser tab.    NEW_WINDOW: Opens the target URL in a new browser window.    SAME_TAB: Opens the target URL in the same browser tab.
        public let urlTarget: URLTargetConfiguration
        /// THe URL link of the CustomActionURLOperation.
        public let urlTemplate: String

        public init(urlTarget: URLTargetConfiguration, urlTemplate: String) {
            self.urlTarget = urlTarget
            self.urlTemplate = urlTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.urlTemplate, name: "urlTemplate", parent: name, max: 2048)
            try self.validate(self.urlTemplate, name: "urlTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case urlTarget = "URLTarget"
            case urlTemplate = "URLTemplate"
        }
    }

    public struct CustomColor: AWSEncodableShape & AWSDecodableShape {
        /// The color that is applied to the data value.
        public let color: String
        /// The data value that the color is applied to.
        public let fieldValue: String?
        /// The value of a special data value.
        public let specialValue: SpecialValue?

        public init(color: String, fieldValue: String? = nil, specialValue: SpecialValue? = nil) {
            self.color = color
            self.fieldValue = fieldValue
            self.specialValue = specialValue
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.fieldValue, name: "fieldValue", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case fieldValue = "FieldValue"
            case specialValue = "SpecialValue"
        }
    }

    public struct CustomContentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The content type of the custom content visual. You can use this to have the visual render as an image.
        public let contentType: CustomContentType?
        /// The input URL that links to the custom content that you want in the custom visual.
        public let contentUrl: String?
        /// The sizing options for the size of the custom content visual. This structure is required when the ContentType of the visual is 'IMAGE'.
        public let imageScaling: CustomContentImageScalingConfiguration?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?

        public init(contentType: CustomContentType? = nil, contentUrl: String? = nil, imageScaling: CustomContentImageScalingConfiguration? = nil, interactions: VisualInteractionOptions? = nil) {
            self.contentType = contentType
            self.contentUrl = contentUrl
            self.imageScaling = imageScaling
            self.interactions = interactions
        }

        public func validate(name: String) throws {
            try self.validate(self.contentUrl, name: "contentUrl", parent: name, max: 2048)
            try self.validate(self.contentUrl, name: "contentUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case contentUrl = "ContentUrl"
            case imageScaling = "ImageScaling"
            case interactions = "Interactions"
        }
    }

    public struct CustomContentVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a CustomContentVisual.
        public let chartConfiguration: CustomContentConfiguration?
        /// The dataset that is used to create the custom content visual. You can't create a visual without a dataset.
        public let dataSetIdentifier: String
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: CustomContentConfiguration? = nil, dataSetIdentifier: String, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.dataSetIdentifier = dataSetIdentifier
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case dataSetIdentifier = "DataSetIdentifier"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct CustomFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The category value for the filter. This field is mutually exclusive to ParameterName.
        public let categoryValue: String?
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: CategoryFilterMatchOperator
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to CategoryValue.
        public let parameterName: String?
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: CategoryFilterSelectAllOptions?

        public init(categoryValue: String? = nil, matchOperator: CategoryFilterMatchOperator, nullOption: FilterNullOption, parameterName: String? = nil, selectAllOptions: CategoryFilterSelectAllOptions? = nil) {
            self.categoryValue = categoryValue
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.categoryValue, name: "categoryValue", parent: name, max: 512)
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValue = "CategoryValue"
            case matchOperator = "MatchOperator"
            case nullOption = "NullOption"
            case parameterName = "ParameterName"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct CustomFilterListConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The list of category values for the filter.
        public let categoryValues: [String]?
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: CategoryFilterMatchOperator
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: CategoryFilterSelectAllOptions?

        public init(categoryValues: [String]? = nil, matchOperator: CategoryFilterMatchOperator, nullOption: FilterNullOption, selectAllOptions: CategoryFilterSelectAllOptions? = nil) {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.categoryValues?.forEach {
                try validate($0, name: "categoryValues[]", parent: name, max: 512)
            }
            try self.validate(self.categoryValues, name: "categoryValues", parent: name, max: 100000)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValues = "CategoryValues"
            case matchOperator = "MatchOperator"
            case nullOption = "NullOption"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct CustomNarrativeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The string input of custom narrative.
        public let narrative: String

        public init(narrative: String) {
            self.narrative = narrative
        }

        public func validate(name: String) throws {
            try self.validate(self.narrative, name: "narrative", parent: name, max: 150000)
        }

        private enum CodingKeys: String, CodingKey {
            case narrative = "Narrative"
        }
    }

    public struct CustomParameterValues: AWSEncodableShape & AWSDecodableShape {
        /// A list of datetime-type parameter values.
        public let dateTimeValues: [Date]?
        /// A list of decimal-type parameter values.
        public let decimalValues: [Double]?
        /// A list of integer-type parameter values.
        public let integerValues: [Int64]?
        /// A list of string-type parameter values.
        public let stringValues: [String]?

        public init(dateTimeValues: [Date]? = nil, decimalValues: [Double]? = nil, integerValues: [Int64]? = nil, stringValues: [String]? = nil) {
            self.dateTimeValues = dateTimeValues
            self.decimalValues = decimalValues
            self.integerValues = integerValues
            self.stringValues = stringValues
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeValues, name: "dateTimeValues", parent: name, max: 50000)
            try self.validate(self.decimalValues, name: "decimalValues", parent: name, max: 50000)
            try self.validate(self.integerValues, name: "integerValues", parent: name, max: 50000)
            try self.validate(self.stringValues, name: "stringValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeValues = "DateTimeValues"
            case decimalValues = "DecimalValues"
            case integerValues = "IntegerValues"
            case stringValues = "StringValues"
        }
    }

    public struct CustomSql: AWSEncodableShape & AWSDecodableShape {
        /// The column schema from the SQL query result set.
        public let columns: [InputColumn]?
        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String
        /// A display name for the SQL query result.
        public let name: String
        /// The SQL query.
        public let sqlQuery: String

        public init(columns: [InputColumn]? = nil, dataSourceArn: String, name: String, sqlQuery: String) {
            self.columns = columns
            self.dataSourceArn = dataSourceArn
            self.name = name
            self.sqlQuery = sqlQuery
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 2048)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sqlQuery, name: "sqlQuery", parent: name, max: 168000)
            try self.validate(self.sqlQuery, name: "sqlQuery", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case dataSourceArn = "DataSourceArn"
            case name = "Name"
            case sqlQuery = "SqlQuery"
        }
    }

    public struct CustomValuesConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let customValues: CustomParameterValues
        /// Includes the null value in custom action parameter values.
        public let includeNullValue: Bool?

        public init(customValues: CustomParameterValues, includeNullValue: Bool? = nil) {
            self.customValues = customValues
            self.includeNullValue = includeNullValue
        }

        public func validate(name: String) throws {
            try self.customValues.validate(name: "\(name).customValues")
        }

        private enum CodingKeys: String, CodingKey {
            case customValues = "CustomValues"
            case includeNullValue = "IncludeNullValue"
        }
    }

    public struct Dashboard: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard was created.
        public let createdTime: Date?
        /// Dashboard ID.
        public let dashboardId: String?
        /// The last time that this dashboard was published.
        public let lastPublishedTime: Date?
        /// The last time that this dashboard was updated.
        public let lastUpdatedTime: Date?
        /// A list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
        public let linkEntities: [String]?
        /// A display name for the dashboard.
        public let name: String?
        /// Version.
        public let version: DashboardVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, dashboardId: String? = nil, lastPublishedTime: Date? = nil, lastUpdatedTime: Date? = nil, linkEntities: [String]? = nil, name: String? = nil, version: DashboardVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.linkEntities = linkEntities
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dashboardId = "DashboardId"
            case lastPublishedTime = "LastPublishedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case linkEntities = "LinkEntities"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct DashboardError: AWSDecodableShape {
        /// Message.
        public let message: String?
        /// Type.
        public let type: DashboardErrorType?
        /// Lists the violated entities that caused the dashboard error.
        public let violatedEntities: [Entity]?

        public init(message: String? = nil, type: DashboardErrorType? = nil, violatedEntities: [Entity]? = nil) {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
            case violatedEntities = "ViolatedEntities"
        }
    }

    public struct DashboardPublishOptions: AWSEncodableShape & AWSDecodableShape {
        /// Ad hoc (one-time) filtering option.
        public let adHocFilteringOption: AdHocFilteringOption?
        /// The drill-down options of data points in a dashboard.
        public let dataPointDrillUpDownOption: DataPointDrillUpDownOption?
        /// The data point menu label options of a dashboard.
        public let dataPointMenuLabelOption: DataPointMenuLabelOption?
        /// The data point tool tip options of a dashboard.
        public let dataPointTooltipOption: DataPointTooltipOption?
        /// Export to .csv option.
        public let exportToCSVOption: ExportToCSVOption?
        /// Determines if hidden fields are exported with a dashboard.
        public let exportWithHiddenFieldsOption: ExportWithHiddenFieldsOption?
        /// Sheet controls option.
        public let sheetControlsOption: SheetControlsOption?
        /// The sheet layout maximization options of a dashbaord.
        public let sheetLayoutElementMaximizationOption: SheetLayoutElementMaximizationOption?
        /// The axis sort options of a dashboard.
        public let visualAxisSortOption: VisualAxisSortOption?
        /// The menu options of a visual in a dashboard.
        public let visualMenuOption: VisualMenuOption?
        /// The visual publish options of a visual in a dashboard.
        public let visualPublishOptions: DashboardVisualPublishOptions?

        public init(adHocFilteringOption: AdHocFilteringOption? = nil, dataPointDrillUpDownOption: DataPointDrillUpDownOption? = nil, dataPointMenuLabelOption: DataPointMenuLabelOption? = nil, dataPointTooltipOption: DataPointTooltipOption? = nil, exportToCSVOption: ExportToCSVOption? = nil, exportWithHiddenFieldsOption: ExportWithHiddenFieldsOption? = nil, sheetControlsOption: SheetControlsOption? = nil, sheetLayoutElementMaximizationOption: SheetLayoutElementMaximizationOption? = nil, visualAxisSortOption: VisualAxisSortOption? = nil, visualMenuOption: VisualMenuOption? = nil) {
            self.adHocFilteringOption = adHocFilteringOption
            self.dataPointDrillUpDownOption = dataPointDrillUpDownOption
            self.dataPointMenuLabelOption = dataPointMenuLabelOption
            self.dataPointTooltipOption = dataPointTooltipOption
            self.exportToCSVOption = exportToCSVOption
            self.exportWithHiddenFieldsOption = exportWithHiddenFieldsOption
            self.sheetControlsOption = sheetControlsOption
            self.sheetLayoutElementMaximizationOption = sheetLayoutElementMaximizationOption
            self.visualAxisSortOption = visualAxisSortOption
            self.visualMenuOption = visualMenuOption
            self.visualPublishOptions = nil
        }

        @available(*, deprecated, message: "Members visualPublishOptions have been deprecated")
        public init(adHocFilteringOption: AdHocFilteringOption? = nil, dataPointDrillUpDownOption: DataPointDrillUpDownOption? = nil, dataPointMenuLabelOption: DataPointMenuLabelOption? = nil, dataPointTooltipOption: DataPointTooltipOption? = nil, exportToCSVOption: ExportToCSVOption? = nil, exportWithHiddenFieldsOption: ExportWithHiddenFieldsOption? = nil, sheetControlsOption: SheetControlsOption? = nil, sheetLayoutElementMaximizationOption: SheetLayoutElementMaximizationOption? = nil, visualAxisSortOption: VisualAxisSortOption? = nil, visualMenuOption: VisualMenuOption? = nil, visualPublishOptions: DashboardVisualPublishOptions? = nil) {
            self.adHocFilteringOption = adHocFilteringOption
            self.dataPointDrillUpDownOption = dataPointDrillUpDownOption
            self.dataPointMenuLabelOption = dataPointMenuLabelOption
            self.dataPointTooltipOption = dataPointTooltipOption
            self.exportToCSVOption = exportToCSVOption
            self.exportWithHiddenFieldsOption = exportWithHiddenFieldsOption
            self.sheetControlsOption = sheetControlsOption
            self.sheetLayoutElementMaximizationOption = sheetLayoutElementMaximizationOption
            self.visualAxisSortOption = visualAxisSortOption
            self.visualMenuOption = visualMenuOption
            self.visualPublishOptions = visualPublishOptions
        }

        private enum CodingKeys: String, CodingKey {
            case adHocFilteringOption = "AdHocFilteringOption"
            case dataPointDrillUpDownOption = "DataPointDrillUpDownOption"
            case dataPointMenuLabelOption = "DataPointMenuLabelOption"
            case dataPointTooltipOption = "DataPointTooltipOption"
            case exportToCSVOption = "ExportToCSVOption"
            case exportWithHiddenFieldsOption = "ExportWithHiddenFieldsOption"
            case sheetControlsOption = "SheetControlsOption"
            case sheetLayoutElementMaximizationOption = "SheetLayoutElementMaximizationOption"
            case visualAxisSortOption = "VisualAxisSortOption"
            case visualMenuOption = "VisualMenuOption"
            case visualPublishOptions = "VisualPublishOptions"
        }
    }

    public struct DashboardSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.    QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.    DASHBOARD_NAME: Any dashboards whose names have a substring match to this value will be returned.
        public let name: DashboardFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example  "Operator": "StringEquals". Valid values are "StringEquals" and  "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example,  "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DASHBOARD_NAME.
        public let `operator`: FilterOperator
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String?

        public init(name: DashboardFilterAttribute? = nil, operator: FilterOperator, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct DashboardSourceEntity: AWSEncodableShape {
        /// Source template.
        public let sourceTemplate: DashboardSourceTemplate?

        public init(sourceTemplate: DashboardSourceTemplate? = nil) {
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceTemplate?.validate(name: "\(name).sourceTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct DashboardSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// Dataset references.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct DashboardSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard was created.
        public let createdTime: Date?
        /// Dashboard ID.
        public let dashboardId: String?
        /// The last time that this dashboard was published.
        public let lastPublishedTime: Date?
        /// The last time that this dashboard was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dashboard.
        public let name: String?
        /// Published version number.
        public let publishedVersionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, dashboardId: String? = nil, lastPublishedTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, publishedVersionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishedVersionNumber = publishedVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dashboardId = "DashboardId"
            case lastPublishedTime = "LastPublishedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case publishedVersionNumber = "PublishedVersionNumber"
        }
    }

    public struct DashboardVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard version was created.
        public let createdTime: Date?
        /// The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.
        public let dataSetArns: [String]?
        /// Description.
        public let description: String?
        /// Errors associated with this dashboard version.
        public let errors: [DashboardError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// Source entity ARN.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The ARN of the theme associated with a version of the dashboard.
        public let themeArn: String?
        /// Version number for this version of the dashboard.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, dataSetArns: [String]? = nil, description: String? = nil, errors: [DashboardError]? = nil, sheets: [Sheet]? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, themeArn: String? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSetArns = "DataSetArns"
            case description = "Description"
            case errors = "Errors"
            case sheets = "Sheets"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case themeArn = "ThemeArn"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DashboardVersionDefinition: AWSEncodableShape & AWSDecodableShape {
        public let analysisDefaults: AnalysisDefaults?
        /// An array of calculated field definitions for the dashboard.
        public let calculatedFields: [CalculatedField]?
        /// An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard.
        public let columnConfigurations: [ColumnConfiguration]?
        /// An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.
        public let dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration]
        /// The filter definitions for a dashboard. For more information, see Filtering Data in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let filterGroups: [FilterGroup]?
        /// An array of option definitions for a dashboard.
        public let options: AssetOptions?
        /// The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see Parameters in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterDeclarations: [ParameterDeclaration]?
        /// An array of sheet definitions for a dashboard.
        public let sheets: [SheetDefinition]?

        public init(analysisDefaults: AnalysisDefaults? = nil, calculatedFields: [CalculatedField]? = nil, columnConfigurations: [ColumnConfiguration]? = nil, dataSetIdentifierDeclarations: [DataSetIdentifierDeclaration], filterGroups: [FilterGroup]? = nil, options: AssetOptions? = nil, parameterDeclarations: [ParameterDeclaration]? = nil, sheets: [SheetDefinition]? = nil) {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.options = options
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }

        public func validate(name: String) throws {
            try self.calculatedFields?.forEach {
                try $0.validate(name: "\(name).calculatedFields[]")
            }
            try self.validate(self.calculatedFields, name: "calculatedFields", parent: name, max: 500)
            try self.columnConfigurations?.forEach {
                try $0.validate(name: "\(name).columnConfigurations[]")
            }
            try self.validate(self.columnConfigurations, name: "columnConfigurations", parent: name, max: 2000)
            try self.dataSetIdentifierDeclarations.forEach {
                try $0.validate(name: "\(name).dataSetIdentifierDeclarations[]")
            }
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, max: 50)
            try self.validate(self.dataSetIdentifierDeclarations, name: "dataSetIdentifierDeclarations", parent: name, min: 1)
            try self.filterGroups?.forEach {
                try $0.validate(name: "\(name).filterGroups[]")
            }
            try self.validate(self.filterGroups, name: "filterGroups", parent: name, max: 2000)
            try self.parameterDeclarations?.forEach {
                try $0.validate(name: "\(name).parameterDeclarations[]")
            }
            try self.validate(self.parameterDeclarations, name: "parameterDeclarations", parent: name, max: 200)
            try self.sheets?.forEach {
                try $0.validate(name: "\(name).sheets[]")
            }
            try self.validate(self.sheets, name: "sheets", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisDefaults = "AnalysisDefaults"
            case calculatedFields = "CalculatedFields"
            case columnConfigurations = "ColumnConfigurations"
            case dataSetIdentifierDeclarations = "DataSetIdentifierDeclarations"
            case filterGroups = "FilterGroups"
            case options = "Options"
            case parameterDeclarations = "ParameterDeclarations"
            case sheets = "Sheets"
        }
    }

    public struct DashboardVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The time that this dashboard version was created.
        public let createdTime: Date?
        /// Description.
        public let description: String?
        /// Source entity ARN.
        public let sourceEntityArn: String?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// Version number.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DashboardVisualId: AWSEncodableShape {
        /// The ID of the dashboard that has the visual that you want to embed. The DashboardId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the DashboardId with a ListDashboards API operation.
        public let dashboardId: String
        /// The ID of the sheet that the has visual that you want to embed. The SheetId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        public let sheetId: String
        /// The ID of the visual that you want to embed. The VisualID can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        public let visualId: String

        public init(dashboardId: String, sheetId: String, visualId: String) {
            self.dashboardId = dashboardId
            self.sheetId = sheetId
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sheetId, name: "sheetId", parent: name, max: 512)
            try self.validate(self.sheetId, name: "sheetId", parent: name, min: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardId = "DashboardId"
            case sheetId = "SheetId"
            case visualId = "VisualId"
        }
    }

    public struct DashboardVisualPublishOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines if hidden fields are included in an exported dashboard.
        public let exportHiddenFieldsOption: ExportHiddenFieldsOption?

        public init(exportHiddenFieldsOption: ExportHiddenFieldsOption? = nil) {
            self.exportHiddenFieldsOption = exportHiddenFieldsOption
        }

        private enum CodingKeys: String, CodingKey {
            case exportHiddenFieldsOption = "ExportHiddenFieldsOption"
        }
    }

    public struct DataAggregation: AWSEncodableShape & AWSDecodableShape {
        /// The level of time precision that is used to aggregate DateTime values.
        public let datasetRowDateGranularity: TopicTimeGranularity?
        /// The column name for the default date.
        public let defaultDateColumnName: String?

        public init(datasetRowDateGranularity: TopicTimeGranularity? = nil, defaultDateColumnName: String? = nil) {
            self.datasetRowDateGranularity = datasetRowDateGranularity
            self.defaultDateColumnName = defaultDateColumnName
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultDateColumnName, name: "defaultDateColumnName", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetRowDateGranularity = "DatasetRowDateGranularity"
            case defaultDateColumnName = "DefaultDateColumnName"
        }
    }

    public struct DataBarsOptions: AWSEncodableShape & AWSDecodableShape {
        /// The field ID for the data bars options.
        public let fieldId: String
        /// The color of the negative data bar.
        public let negativeColor: String?
        /// The color of the positive data bar.
        public let positiveColor: String?

        public init(fieldId: String, negativeColor: String? = nil, positiveColor: String? = nil) {
            self.fieldId = fieldId
            self.negativeColor = negativeColor
            self.positiveColor = positiveColor
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.negativeColor, name: "negativeColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.positiveColor, name: "positiveColor", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case negativeColor = "NegativeColor"
            case positiveColor = "PositiveColor"
        }
    }

    public struct DataColor: AWSEncodableShape & AWSDecodableShape {
        /// The color that is applied to the data value.
        public let color: String?
        /// The data value that the color is applied to.
        public let dataValue: Double?

        public init(color: String? = nil, dataValue: Double? = nil) {
            self.color = color
            self.dataValue = dataValue
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case dataValue = "DataValue"
        }
    }

    public struct DataColorPalette: AWSEncodableShape & AWSDecodableShape {
        /// The hexadecimal codes for the colors.
        public let colors: [String]?
        /// The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        public let emptyFillColor: String?
        /// The minimum and maximum hexadecimal codes that describe a color gradient.
        public let minMaxGradient: [String]?

        public init(colors: [String]? = nil, emptyFillColor: String? = nil, minMaxGradient: [String]? = nil) {
            self.colors = colors
            self.emptyFillColor = emptyFillColor
            self.minMaxGradient = minMaxGradient
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try validate($0, name: "colors[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 100)
            try self.validate(self.emptyFillColor, name: "emptyFillColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.minMaxGradient?.forEach {
                try validate($0, name: "minMaxGradient[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.minMaxGradient, name: "minMaxGradient", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
            case emptyFillColor = "EmptyFillColor"
            case minMaxGradient = "MinMaxGradient"
        }
    }

    public struct DataFieldSeriesItem: AWSEncodableShape & AWSDecodableShape {
        /// The axis that you are binding the field to.
        public let axisBinding: AxisBinding
        /// The field ID of the field that you are setting the axis binding to.
        public let fieldId: String
        /// The field value of the field that you are setting the axis binding to.
        public let fieldValue: String?
        /// The options that determine the presentation of line series associated to the field.
        public let settings: LineChartSeriesSettings?

        public init(axisBinding: AxisBinding, fieldId: String, fieldValue: String? = nil, settings: LineChartSeriesSettings? = nil) {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.settings = settings
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.settings?.validate(name: "\(name).settings")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case fieldId = "FieldId"
            case fieldValue = "FieldValue"
            case settings = "Settings"
        }
    }

    public struct DataLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of the category field labels.
        public let categoryLabelVisibility: Visibility?
        /// The option that determines the data label type.
        public let dataLabelTypes: [DataLabelType]?
        /// Determines the color of the data labels.
        public let labelColor: String?
        /// Determines the content of the data labels.
        public let labelContent: DataLabelContent?
        /// Determines the font configuration of the data labels.
        public let labelFontConfiguration: FontConfiguration?
        /// Determines the visibility of the measure field labels.
        public let measureLabelVisibility: Visibility?
        /// Determines whether overlap is enabled or disabled for the data labels.
        public let overlap: DataLabelOverlap?
        /// Determines the position of the data labels.
        public let position: DataLabelPosition?
        /// Determines the visibility of the total.
        public let totalsVisibility: Visibility?
        /// Determines the visibility of the data labels.
        public let visibility: Visibility?

        public init(categoryLabelVisibility: Visibility? = nil, dataLabelTypes: [DataLabelType]? = nil, labelColor: String? = nil, labelContent: DataLabelContent? = nil, labelFontConfiguration: FontConfiguration? = nil, measureLabelVisibility: Visibility? = nil, overlap: DataLabelOverlap? = nil, position: DataLabelPosition? = nil, totalsVisibility: Visibility? = nil, visibility: Visibility? = nil) {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.dataLabelTypes = dataLabelTypes
            self.labelColor = labelColor
            self.labelContent = labelContent
            self.labelFontConfiguration = labelFontConfiguration
            self.measureLabelVisibility = measureLabelVisibility
            self.overlap = overlap
            self.position = position
            self.totalsVisibility = totalsVisibility
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.dataLabelTypes?.forEach {
                try $0.validate(name: "\(name).dataLabelTypes[]")
            }
            try self.validate(self.dataLabelTypes, name: "dataLabelTypes", parent: name, max: 100)
            try self.validate(self.labelColor, name: "labelColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.labelFontConfiguration?.validate(name: "\(name).labelFontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelVisibility = "CategoryLabelVisibility"
            case dataLabelTypes = "DataLabelTypes"
            case labelColor = "LabelColor"
            case labelContent = "LabelContent"
            case labelFontConfiguration = "LabelFontConfiguration"
            case measureLabelVisibility = "MeasureLabelVisibility"
            case overlap = "Overlap"
            case position = "Position"
            case totalsVisibility = "TotalsVisibility"
            case visibility = "Visibility"
        }
    }

    public struct DataLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The option that specifies individual data values for labels.
        public let dataPathLabelType: DataPathLabelType?
        /// Determines the label configuration for the entire field.
        public let fieldLabelType: FieldLabelType?
        /// Determines the label configuration for the maximum value in a visual.
        public let maximumLabelType: MaximumLabelType?
        /// Determines the label configuration for the minimum value in a visual.
        public let minimumLabelType: MinimumLabelType?
        /// Determines the label configuration for range end value in a visual.
        public let rangeEndsLabelType: RangeEndsLabelType?

        public init(dataPathLabelType: DataPathLabelType? = nil, fieldLabelType: FieldLabelType? = nil, maximumLabelType: MaximumLabelType? = nil, minimumLabelType: MinimumLabelType? = nil, rangeEndsLabelType: RangeEndsLabelType? = nil) {
            self.dataPathLabelType = dataPathLabelType
            self.fieldLabelType = fieldLabelType
            self.maximumLabelType = maximumLabelType
            self.minimumLabelType = minimumLabelType
            self.rangeEndsLabelType = rangeEndsLabelType
        }

        public func validate(name: String) throws {
            try self.dataPathLabelType?.validate(name: "\(name).dataPathLabelType")
            try self.fieldLabelType?.validate(name: "\(name).fieldLabelType")
        }

        private enum CodingKeys: String, CodingKey {
            case dataPathLabelType = "DataPathLabelType"
            case fieldLabelType = "FieldLabelType"
            case maximumLabelType = "MaximumLabelType"
            case minimumLabelType = "MinimumLabelType"
            case rangeEndsLabelType = "RangeEndsLabelType"
        }
    }

    public struct DataPathColor: AWSEncodableShape & AWSDecodableShape {
        /// The color that needs to be applied to the element.
        public let color: String
        /// The element that the color needs to be applied to.
        public let element: DataPathValue
        /// The time granularity of the field that the color needs to be applied to.
        public let timeGranularity: TimeGranularity?

        public init(color: String, element: DataPathValue, timeGranularity: TimeGranularity? = nil) {
            self.color = color
            self.element = element
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.element.validate(name: "\(name).element")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case element = "Element"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct DataPathLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the field that the data label needs to be applied to.
        public let fieldId: String?
        /// The actual value of the field that is labeled.
        public let fieldValue: String?
        /// The visibility of the data label.
        public let visibility: Visibility?

        public init(fieldId: String? = nil, fieldValue: String? = nil, visibility: Visibility? = nil) {
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.fieldValue, name: "fieldValue", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case fieldValue = "FieldValue"
            case visibility = "Visibility"
        }
    }

    public struct DataPathSort: AWSEncodableShape & AWSDecodableShape {
        /// Determines the sort direction.
        public let direction: SortDirection
        /// The list of data paths that need to be sorted.
        public let sortPaths: [DataPathValue]

        public init(direction: SortDirection, sortPaths: [DataPathValue]) {
            self.direction = direction
            self.sortPaths = sortPaths
        }

        public func validate(name: String) throws {
            try self.sortPaths.forEach {
                try $0.validate(name: "\(name).sortPaths[]")
            }
            try self.validate(self.sortPaths, name: "sortPaths", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "Direction"
            case sortPaths = "SortPaths"
        }
    }

    public struct DataPathType: AWSEncodableShape & AWSDecodableShape {
        /// The type of data path value utilized in a pivot table. Choose one of the following options:    HIERARCHY_ROWS_LAYOUT_COLUMN - The type of data path for the rows layout column, when RowsLayout is set to HIERARCHY.    MULTIPLE_ROW_METRICS_COLUMN - The type of data path for the metric column when the row is set to Metric Placement.    EMPTY_COLUMN_HEADER - The type of data path for the column with empty column header, when there is no field in ColumnsFieldWell and the row is set to Metric Placement.    COUNT_METRIC_COLUMN - The type of data path for the column with COUNT as the metric, when there is no field in the ValuesFieldWell.
        public let pivotTableDataPathType: PivotTableDataPathType?

        public init(pivotTableDataPathType: PivotTableDataPathType? = nil) {
            self.pivotTableDataPathType = pivotTableDataPathType
        }

        private enum CodingKeys: String, CodingKey {
            case pivotTableDataPathType = "PivotTableDataPathType"
        }
    }

    public struct DataPathValue: AWSEncodableShape & AWSDecodableShape {
        /// The type configuration of the field.
        public let dataPathType: DataPathType?
        /// The field ID of the field that needs to be sorted.
        public let fieldId: String?
        /// The actual value of the field that needs to be sorted.
        public let fieldValue: String?

        public init(dataPathType: DataPathType? = nil, fieldId: String? = nil, fieldValue: String? = nil) {
            self.dataPathType = dataPathType
            self.fieldId = fieldId
            self.fieldValue = fieldValue
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.fieldValue, name: "fieldValue", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case dataPathType = "DataPathType"
            case fieldId = "FieldId"
            case fieldValue = "FieldValue"
        }
    }

    public struct DataPointDrillUpDownOption: AWSEncodableShape & AWSDecodableShape {
        /// The status of the drill down options of data points.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct DataPointMenuLabelOption: AWSEncodableShape & AWSDecodableShape {
        /// The status of the data point menu options.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct DataPointTooltipOption: AWSEncodableShape & AWSDecodableShape {
        /// The status of the data point tool tip options.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct DataSet: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.
        public let consumedSpiceCapacityInBytes: Int64?
        /// The time that this dataset was created.
        public let createdTime: Date?
        /// The ID of the dataset.
        public let dataSetId: String?
        /// The parameters that are declared in a dataset.
        public let datasetParameters: [DatasetParameter]?
        /// The usage configuration to apply to child datasets that reference this dataset as a source.
        public let dataSetUsageConfiguration: DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// A value that indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode?
        /// The last time that this dataset was updated.
        public let lastUpdatedTime: Date?
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// A display name for the dataset.
        public let name: String?
        /// The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.
        public let outputColumns: [OutputColumn]?
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]?
        /// The row-level security configuration for the dataset.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// The element you can use to define tags for row-level security.
        public let rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration?

        public init(arn: String? = nil, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, consumedSpiceCapacityInBytes: Int64? = nil, createdTime: Date? = nil, dataSetId: String? = nil, datasetParameters: [DatasetParameter]? = nil, dataSetUsageConfiguration: DataSetUsageConfiguration? = nil, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode? = nil, lastUpdatedTime: Date? = nil, logicalTableMap: [String: LogicalTable]? = nil, name: String? = nil, outputColumns: [OutputColumn]? = nil, physicalTableMap: [String: PhysicalTable]? = nil, rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration? = nil) {
            self.arn = arn
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytes
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.datasetParameters = datasetParameters
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.outputColumns = outputColumns
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case consumedSpiceCapacityInBytes = "ConsumedSpiceCapacityInBytes"
            case createdTime = "CreatedTime"
            case dataSetId = "DataSetId"
            case datasetParameters = "DatasetParameters"
            case dataSetUsageConfiguration = "DataSetUsageConfiguration"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case lastUpdatedTime = "LastUpdatedTime"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case outputColumns = "OutputColumns"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        }
    }

    public struct DataSetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A structure containing the list of column group schemas.
        public let columnGroupSchemaList: [ColumnGroupSchema]?
        /// Dataset schema.
        public let dataSetSchema: DataSetSchema?
        /// Placeholder.
        public let placeholder: String?

        public init(columnGroupSchemaList: [ColumnGroupSchema]? = nil, dataSetSchema: DataSetSchema? = nil, placeholder: String? = nil) {
            self.columnGroupSchemaList = columnGroupSchemaList
            self.dataSetSchema = dataSetSchema
            self.placeholder = placeholder
        }

        public func validate(name: String) throws {
            try self.columnGroupSchemaList?.forEach {
                try $0.validate(name: "\(name).columnGroupSchemaList[]")
            }
            try self.validate(self.columnGroupSchemaList, name: "columnGroupSchemaList", parent: name, max: 500)
            try self.dataSetSchema?.validate(name: "\(name).dataSetSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroupSchemaList = "ColumnGroupSchemaList"
            case dataSetSchema = "DataSetSchema"
            case placeholder = "Placeholder"
        }
    }

    public struct DataSetIdentifierDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data set.
        public let dataSetArn: String
        /// The identifier of the data set, typically the data set's name.
        public let identifier: String

        public init(dataSetArn: String, identifier: String) {
            self.dataSetArn = dataSetArn
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 2048)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case identifier = "Identifier"
        }
    }

    public struct DataSetReference: AWSEncodableShape {
        /// Dataset Amazon Resource Name (ARN).
        public let dataSetArn: String
        /// Dataset placeholder.
        public let dataSetPlaceholder: String

        public init(dataSetArn: String, dataSetPlaceholder: String) {
            self.dataSetArn = dataSetArn
            self.dataSetPlaceholder = dataSetPlaceholder
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetPlaceholder, name: "dataSetPlaceholder", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetPlaceholder = "DataSetPlaceholder"
        }
    }

    public struct DataSetRefreshProperties: AWSEncodableShape & AWSDecodableShape {
        /// The refresh configuration for a dataset.
        public let refreshConfiguration: RefreshConfiguration

        public init(refreshConfiguration: RefreshConfiguration) {
            self.refreshConfiguration = refreshConfiguration
        }

        public func validate(name: String) throws {
            try self.refreshConfiguration.validate(name: "\(name).refreshConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case refreshConfiguration = "RefreshConfiguration"
        }
    }

    public struct DataSetSchema: AWSEncodableShape & AWSDecodableShape {
        /// A structure containing the list of column schemas.
        public let columnSchemaList: [ColumnSchema]?

        public init(columnSchemaList: [ColumnSchema]? = nil) {
            self.columnSchemaList = columnSchemaList
        }

        public func validate(name: String) throws {
            try self.validate(self.columnSchemaList, name: "columnSchemaList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case columnSchemaList = "ColumnSchemaList"
        }
    }

    public struct DataSetSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.    QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.    DATASET_NAME: Any datasets whose names have a substring match to this value will be returned.
        public let name: DataSetFilterAttribute
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose datasets you want to search in the "Value" field. For example, "Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the datasets you are searching for. For example, "Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASET_NAME.
        public let `operator`: FilterOperator
        /// The value of the named item, in this case QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String

        public init(name: DataSetFilterAttribute, operator: FilterOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct DataSetSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// A value that indicates if the dataset has column level permission configured.
        public let columnLevelPermissionRulesApplied: Bool?
        /// The time that this dataset was created.
        public let createdTime: Date?
        /// The ID of the dataset.
        public let dataSetId: String?
        /// A value that indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode?
        /// The last time that this dataset was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the dataset.
        public let name: String?
        /// The row-level security configuration for the dataset.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// Whether or not the row level permission tags are applied.
        public let rowLevelPermissionTagConfigurationApplied: Bool?

        public init(arn: String? = nil, columnLevelPermissionRulesApplied: Bool? = nil, createdTime: Date? = nil, dataSetId: String? = nil, importMode: DataSetImportMode? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfigurationApplied: Bool? = nil) {
            self.arn = arn
            self.columnLevelPermissionRulesApplied = columnLevelPermissionRulesApplied
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfigurationApplied = rowLevelPermissionTagConfigurationApplied
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case columnLevelPermissionRulesApplied = "ColumnLevelPermissionRulesApplied"
            case createdTime = "CreatedTime"
            case dataSetId = "DataSetId"
            case importMode = "ImportMode"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfigurationApplied = "RowLevelPermissionTagConfigurationApplied"
        }
    }

    public struct DataSetUsageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An option that controls whether a child dataset of a direct query can use this dataset as a source.
        public let disableUseAsDirectQuerySource: Bool?
        /// An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        public let disableUseAsImportedSource: Bool?

        public init(disableUseAsDirectQuerySource: Bool? = nil, disableUseAsImportedSource: Bool? = nil) {
            self.disableUseAsDirectQuerySource = disableUseAsDirectQuerySource
            self.disableUseAsImportedSource = disableUseAsImportedSource
        }

        private enum CodingKeys: String, CodingKey {
            case disableUseAsDirectQuerySource = "DisableUseAsDirectQuerySource"
            case disableUseAsImportedSource = "DisableUseAsImportedSource"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the AlternateDataSourceParameters list is null, the Credentials originally used with this DataSourceParameters are automatically allowed.
        public let alternateDataSourceParameters: [DataSourceParameters]?
        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The time that this data source was created.
        public let createdTime: Date?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
        public let dataSourceParameters: DataSourceParameters?
        /// Error information from the last update or the creation of the data source.
        public let errorInfo: DataSourceErrorInfo?
        /// The last time that this data source was updated.
        public let lastUpdatedTime: Date?
        /// A display name for the data source.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public let secretArn: String?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
        public let sslProperties: SslProperties?
        /// The HTTP status of the request.
        public let status: ResourceStatus?
        /// The type of the data source. This type indicates which database engine the data source connects to.
        public let type: DataSourceType?
        /// The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(alternateDataSourceParameters: [DataSourceParameters]? = nil, arn: String? = nil, createdTime: Date? = nil, dataSourceId: String? = nil, dataSourceParameters: DataSourceParameters? = nil, errorInfo: DataSourceErrorInfo? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, secretArn: String? = nil, sslProperties: SslProperties? = nil, status: ResourceStatus? = nil, type: DataSourceType? = nil, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.errorInfo = errorInfo
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.secretArn = secretArn
            self.sslProperties = sslProperties
            self.status = status
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        private enum CodingKeys: String, CodingKey {
            case alternateDataSourceParameters = "AlternateDataSourceParameters"
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSourceId = "DataSourceId"
            case dataSourceParameters = "DataSourceParameters"
            case errorInfo = "ErrorInfo"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case secretArn = "SecretArn"
            case sslProperties = "SslProperties"
            case status = "Status"
            case type = "Type"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct DataSourceCredentials: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When CopySourceArn is not null, the credential pair from the data source in the ARN is used as the credentials for the DataSourceCredentials structure.
        public let copySourceArn: String?
        /// Credential pair. For more information, see  CredentialPair .
        public let credentialPair: CredentialPair?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public let secretArn: String?

        public init(copySourceArn: String? = nil, credentialPair: CredentialPair? = nil, secretArn: String? = nil) {
            self.copySourceArn = copySourceArn
            self.credentialPair = credentialPair
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.copySourceArn, name: "copySourceArn", parent: name, pattern: "^arn:[-a-z0-9]*:quicksight:[-a-z0-9]*:[0-9]{12}:datasource/.+$")
            try self.credentialPair?.validate(name: "\(name).credentialPair")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 2048)
            try self.validate(self.secretArn, name: "secretArn", parent: name, min: 1)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[-a-z0-9]*:secretsmanager:[-a-z0-9]*:[0-9]{12}:secret:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case copySourceArn = "CopySourceArn"
            case credentialPair = "CredentialPair"
            case secretArn = "SecretArn"
        }
    }

    public struct DataSourceErrorInfo: AWSDecodableShape {
        /// Error message.
        public let message: String?
        /// Error type.
        public let type: DataSourceErrorInfoType?

        public init(message: String? = nil, type: DataSourceErrorInfoType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct DataSourceSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example, "Name": "DIRECT_QUICKSIGHT_OWNER". Valid values are defined as follows:    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.    DATASOURCE_NAME: Any data sources whose names have a substring match to the provided value are returned.
        public let name: DataSourceFilterAttribute
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose data sources you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the data sources you are searching for. For example, "Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASOURCE_NAME.
        public let `operator`: FilterOperator
        /// The value of the named item, for example DIRECT_QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public let value: String

        public init(name: DataSourceFilterAttribute, operator: FilterOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct DataSourceSummary: AWSDecodableShape {
        /// The arn of the datasource.
        public let arn: String?
        /// The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public let createdTime: Date?
        /// The unique ID of the data source.
        public let dataSourceId: String?
        /// The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public let lastUpdatedTime: Date?
        /// The name of the data source.
        public let name: String?
        /// The type of the data source.
        public let type: DataSourceType?

        public init(arn: String? = nil, createdTime: Date? = nil, dataSourceId: String? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, type: DataSourceType? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case dataSourceId = "DataSourceId"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct DatabricksParameters: AWSEncodableShape & AWSDecodableShape {
        /// The host name of the Databricks data source.
        public let host: String
        /// The port for the Databricks data source.
        public let port: Int
        /// The HTTP path of the Databricks data source.
        public let sqlEndpointPath: String

        public init(host: String, port: Int, sqlEndpointPath: String) {
            self.host = host
            self.port = port
            self.sqlEndpointPath = sqlEndpointPath
        }

        public func validate(name: String) throws {
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.sqlEndpointPath, name: "sqlEndpointPath", parent: name, max: 4096)
            try self.validate(self.sqlEndpointPath, name: "sqlEndpointPath", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case port = "Port"
            case sqlEndpointPath = "SqlEndpointPath"
        }
    }

    public struct DatasetMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The list of calculated field definitions.
        public let calculatedFields: [TopicCalculatedField]?
        /// The list of column definitions.
        public let columns: [TopicColumn]?
        /// The definition of a data aggregation.
        public let dataAggregation: DataAggregation?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String
        /// The description of the dataset.
        public let datasetDescription: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The list of filter definitions.
        public let filters: [TopicFilter]?
        /// The list of named entities definitions.
        public let namedEntities: [TopicNamedEntity]?

        public init(calculatedFields: [TopicCalculatedField]? = nil, columns: [TopicColumn]? = nil, dataAggregation: DataAggregation? = nil, datasetArn: String, datasetDescription: String? = nil, datasetName: String? = nil, filters: [TopicFilter]? = nil, namedEntities: [TopicNamedEntity]? = nil) {
            self.calculatedFields = calculatedFields
            self.columns = columns
            self.dataAggregation = dataAggregation
            self.datasetArn = datasetArn
            self.datasetDescription = datasetDescription
            self.datasetName = datasetName
            self.filters = filters
            self.namedEntities = namedEntities
        }

        public func validate(name: String) throws {
            try self.calculatedFields?.forEach {
                try $0.validate(name: "\(name).calculatedFields[]")
            }
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.dataAggregation?.validate(name: "\(name).dataAggregation")
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, max: 256)
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 256)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.namedEntities?.forEach {
                try $0.validate(name: "\(name).namedEntities[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedFields = "CalculatedFields"
            case columns = "Columns"
            case dataAggregation = "DataAggregation"
            case datasetArn = "DatasetArn"
            case datasetDescription = "DatasetDescription"
            case datasetName = "DatasetName"
            case filters = "Filters"
            case namedEntities = "NamedEntities"
        }
    }

    public struct DatasetParameter: AWSEncodableShape & AWSDecodableShape {
        /// A date time parameter that is created in the dataset.
        public let dateTimeDatasetParameter: DateTimeDatasetParameter?
        /// A decimal parameter that is created in the dataset.
        public let decimalDatasetParameter: DecimalDatasetParameter?
        /// An integer parameter that is created in the dataset.
        public let integerDatasetParameter: IntegerDatasetParameter?
        /// A string parameter that is created in the dataset.
        public let stringDatasetParameter: StringDatasetParameter?

        public init(dateTimeDatasetParameter: DateTimeDatasetParameter? = nil, decimalDatasetParameter: DecimalDatasetParameter? = nil, integerDatasetParameter: IntegerDatasetParameter? = nil, stringDatasetParameter: StringDatasetParameter? = nil) {
            self.dateTimeDatasetParameter = dateTimeDatasetParameter
            self.decimalDatasetParameter = decimalDatasetParameter
            self.integerDatasetParameter = integerDatasetParameter
            self.stringDatasetParameter = stringDatasetParameter
        }

        public func validate(name: String) throws {
            try self.dateTimeDatasetParameter?.validate(name: "\(name).dateTimeDatasetParameter")
            try self.decimalDatasetParameter?.validate(name: "\(name).decimalDatasetParameter")
            try self.integerDatasetParameter?.validate(name: "\(name).integerDatasetParameter")
            try self.stringDatasetParameter?.validate(name: "\(name).stringDatasetParameter")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeDatasetParameter = "DateTimeDatasetParameter"
            case decimalDatasetParameter = "DecimalDatasetParameter"
            case integerDatasetParameter = "IntegerDatasetParameter"
            case stringDatasetParameter = "StringDatasetParameter"
        }
    }

    public struct DateAxisOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not missing dates are displayed.
        public let missingDateVisibility: Visibility?

        public init(missingDateVisibility: Visibility? = nil) {
            self.missingDateVisibility = missingDateVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case missingDateVisibility = "MissingDateVisibility"
        }
    }

    public struct DateDimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the DateDimensionField.
        public let column: ColumnIdentifier
        /// The date granularity of the DateDimensionField. Choose one of the following options:    YEAR     QUARTER     MONTH     WEEK     DAY     HOUR     MINUTE     SECOND     MILLISECOND
        public let dateGranularity: TimeGranularity?
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: DateTimeFormatConfiguration?
        /// The custom hierarchy ID.
        public let hierarchyId: String?

        public init(column: ColumnIdentifier, dateGranularity: TimeGranularity? = nil, fieldId: String, formatConfiguration: DateTimeFormatConfiguration? = nil, hierarchyId: String? = nil) {
            self.column = column
            self.dateGranularity = dateGranularity
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case dateGranularity = "DateGranularity"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct DateMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the measure field.
        public let aggregationFunction: DateAggregationFunction?
        /// The column that is used in the DateMeasureField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: DateTimeFormatConfiguration?

        public init(aggregationFunction: DateAggregationFunction? = nil, column: ColumnIdentifier, fieldId: String, formatConfiguration: DateTimeFormatConfiguration? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct DateTimeDatasetParameter: AWSEncodableShape & AWSDecodableShape {
        /// A list of default values for a given date time parameter. This structure only accepts static values.
        public let defaultValues: DateTimeDatasetParameterDefaultValues?
        /// An identifier for the parameter that is created in the dataset.
        public let id: String
        /// The name of the date time parameter that is created in the dataset.
        public let name: String
        /// The time granularity of the date time parameter.
        public let timeGranularity: TimeGranularity?
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        public let valueType: DatasetParameterValueType

        public init(defaultValues: DateTimeDatasetParameterDefaultValues? = nil, id: String, name: String, timeGranularity: TimeGranularity? = nil, valueType: DatasetParameterValueType) {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.timeGranularity = timeGranularity
            self.valueType = valueType
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case id = "Id"
            case name = "Name"
            case timeGranularity = "TimeGranularity"
            case valueType = "ValueType"
        }
    }

    public struct DateTimeDatasetParameterDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// A list of static default values for a given date time parameter.
        public let staticValues: [Date]?

        public init(staticValues: [Date]? = nil) {
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 32)
            try self.validate(self.staticValues, name: "staticValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case staticValues = "StaticValues"
        }
    }

    public struct DateTimeDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the  DataTimeDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The rolling date of the DataTimeDefaultValues. The date is determined from the dataset based on input expression.
        public let rollingDate: RollingDateConfiguration?
        /// The static values of the DataTimeDefaultValues.
        public let staticValues: [Date]?

        public init(dynamicValue: DynamicDefaultValue? = nil, rollingDate: RollingDateConfiguration? = nil, staticValues: [Date]? = nil) {
            self.dynamicValue = dynamicValue
            self.rollingDate = rollingDate
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.rollingDate?.validate(name: "\(name).rollingDate")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case rollingDate = "RollingDate"
            case staticValues = "StaticValues"
        }
    }

    public struct DateTimeFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the DateTime format.
        public let dateTimeFormat: String?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// The formatting configuration for numeric DateTime fields.
        public let numericFormatConfiguration: NumericFormatConfiguration?

        public init(dateTimeFormat: String? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numericFormatConfiguration: NumericFormatConfiguration? = nil) {
            self.dateTimeFormat = dateTimeFormat
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, max: 128)
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, min: 1)
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.numericFormatConfiguration?.validate(name: "\(name).numericFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormat = "DateTimeFormat"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numericFormatConfiguration = "NumericFormatConfiguration"
        }
    }

    public struct DateTimeHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the drill down filters for the DateTime hierarchy.
        public let drillDownFilters: [DrillDownFilter]?
        /// The hierarchy ID of the DateTime hierarchy.
        public let hierarchyId: String

        public init(drillDownFilters: [DrillDownFilter]? = nil, hierarchyId: String) {
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.drillDownFilters?.forEach {
                try $0.validate(name: "\(name).drillDownFilters[]")
            }
            try self.validate(self.drillDownFilters, name: "drillDownFilters", parent: name, max: 10)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case drillDownFilters = "DrillDownFilters"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct DateTimeParameter: AWSEncodableShape & AWSDecodableShape {
        /// A display name for the date-time parameter.
        public let name: String
        /// The values for the date-time parameter.
        public let values: [Date]

        public init(name: String, values: [Date]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct DateTimeParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: DateTimeDefaultValues?
        public let mappedDataSetParameters: [MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?
        /// The configuration that defines the default value of a DateTime parameter when a value has not been set.
        public let valueWhenUnset: DateTimeValueWhenUnsetConfiguration?

        public init(defaultValues: DateTimeDefaultValues? = nil, mappedDataSetParameters: [MappedDataSetParameter]? = nil, name: String, timeGranularity: TimeGranularity? = nil, valueWhenUnset: DateTimeValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.timeGranularity = timeGranularity
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.mappedDataSetParameters?.forEach {
                try $0.validate(name: "\(name).mappedDataSetParameters[]")
            }
            try self.validate(self.mappedDataSetParameters, name: "mappedDataSetParameters", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case mappedDataSetParameters = "MappedDataSetParameters"
            case name = "Name"
            case timeGranularity = "TimeGranularity"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct DateTimePickerControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// Customize how dates are formatted in controls.
        public let dateTimeFormat: String?
        /// The configuration of info icon label options.
        public let infoIconLabelOptions: SheetControlInfoIconLabelOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(dateTimeFormat: String? = nil, infoIconLabelOptions: SheetControlInfoIconLabelOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.dateTimeFormat = dateTimeFormat
            self.infoIconLabelOptions = infoIconLabelOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, max: 128)
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, min: 1)
            try self.infoIconLabelOptions?.validate(name: "\(name).infoIconLabelOptions")
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormat = "DateTimeFormat"
            case infoIconLabelOptions = "InfoIconLabelOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct DateTimeValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: Date?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: Date? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct DecimalDatasetParameter: AWSEncodableShape & AWSDecodableShape {
        /// A list of default values for a given decimal parameter. This structure only accepts static values.
        public let defaultValues: DecimalDatasetParameterDefaultValues?
        /// An identifier for the decimal parameter created in the dataset.
        public let id: String
        /// The name of the decimal parameter that is created in the dataset.
        public let name: String
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        public let valueType: DatasetParameterValueType

        public init(defaultValues: DecimalDatasetParameterDefaultValues? = nil, id: String, name: String, valueType: DatasetParameterValueType) {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.valueType = valueType
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case id = "Id"
            case name = "Name"
            case valueType = "ValueType"
        }
    }

    public struct DecimalDatasetParameterDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// A list of static default values for a given decimal parameter.
        public let staticValues: [Double]?

        public init(staticValues: [Double]? = nil) {
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 32)
            try self.validate(self.staticValues, name: "staticValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case staticValues = "StaticValues"
        }
    }

    public struct DecimalDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the DecimalDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public let staticValues: [Double]?

        public init(dynamicValue: DynamicDefaultValue? = nil, staticValues: [Double]? = nil) {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case staticValues = "StaticValues"
        }
    }

    public struct DecimalParameter: AWSEncodableShape & AWSDecodableShape {
        /// A display name for the decimal parameter.
        public let name: String
        /// The values for the decimal parameter.
        public let values: [Double]

        public init(name: String, values: [Double]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct DecimalParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: DecimalDefaultValues?
        public let mappedDataSetParameters: [MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        public let parameterValueType: ParameterValueType
        /// The configuration that defines the default value of a Decimal parameter when a value has not been set.
        public let valueWhenUnset: DecimalValueWhenUnsetConfiguration?

        public init(defaultValues: DecimalDefaultValues? = nil, mappedDataSetParameters: [MappedDataSetParameter]? = nil, name: String, parameterValueType: ParameterValueType, valueWhenUnset: DecimalValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.mappedDataSetParameters?.forEach {
                try $0.validate(name: "\(name).mappedDataSetParameters[]")
            }
            try self.validate(self.mappedDataSetParameters, name: "mappedDataSetParameters", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case mappedDataSetParameters = "MappedDataSetParameters"
            case name = "Name"
            case parameterValueType = "ParameterValueType"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct DecimalPlacesConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The values of the decimal places.
        public let decimalPlaces: Int64

        public init(decimalPlaces: Int64) {
            self.decimalPlaces = decimalPlaces
        }

        public func validate(name: String) throws {
            try self.validate(self.decimalPlaces, name: "decimalPlaces", parent: name, max: 20)
            try self.validate(self.decimalPlaces, name: "decimalPlaces", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlaces = "DecimalPlaces"
        }
    }

    public struct DecimalValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: Double?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: Double? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct DefaultFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The display format. Valid values for this structure are AUTO, PERCENT, CURRENCY, NUMBER, DATE, and STRING.
        public let displayFormat: DisplayFormat?
        /// The additional options for display formatting.
        public let displayFormatOptions: DisplayFormatOptions?

        public init(displayFormat: DisplayFormat? = nil, displayFormatOptions: DisplayFormatOptions? = nil) {
            self.displayFormat = displayFormat
            self.displayFormatOptions = displayFormatOptions
        }

        public func validate(name: String) throws {
            try self.displayFormatOptions?.validate(name: "\(name).displayFormatOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case displayFormat = "DisplayFormat"
            case displayFormatOptions = "DisplayFormatOptions"
        }
    }

    public struct DefaultFreeFormLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the screen canvas size options for a free-form layout.
        public let canvasSizeOptions: FreeFormLayoutCanvasSizeOptions

        public init(canvasSizeOptions: FreeFormLayoutCanvasSizeOptions) {
            self.canvasSizeOptions = canvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
        }
    }

    public struct DefaultGridLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the screen canvas size options for a grid layout.
        public let canvasSizeOptions: GridLayoutCanvasSizeOptions

        public init(canvasSizeOptions: GridLayoutCanvasSizeOptions) {
            self.canvasSizeOptions = canvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
        }
    }

    public struct DefaultInteractiveLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the default settings of a free-form layout configuration.
        public let freeForm: DefaultFreeFormLayoutConfiguration?
        /// The options that determine the default settings for a grid layout configuration.
        public let grid: DefaultGridLayoutConfiguration?

        public init(freeForm: DefaultFreeFormLayoutConfiguration? = nil, grid: DefaultGridLayoutConfiguration? = nil) {
            self.freeForm = freeForm
            self.grid = grid
        }

        private enum CodingKeys: String, CodingKey {
            case freeForm = "FreeForm"
            case grid = "Grid"
        }
    }

    public struct DefaultNewSheetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the default settings for interactive layout configuration.
        public let interactiveLayoutConfiguration: DefaultInteractiveLayoutConfiguration?
        /// The options that determine the default settings for a paginated layout configuration.
        public let paginatedLayoutConfiguration: DefaultPaginatedLayoutConfiguration?
        /// The option that determines the sheet content type.
        public let sheetContentType: SheetContentType?

        public init(interactiveLayoutConfiguration: DefaultInteractiveLayoutConfiguration? = nil, paginatedLayoutConfiguration: DefaultPaginatedLayoutConfiguration? = nil, sheetContentType: SheetContentType? = nil) {
            self.interactiveLayoutConfiguration = interactiveLayoutConfiguration
            self.paginatedLayoutConfiguration = paginatedLayoutConfiguration
            self.sheetContentType = sheetContentType
        }

        private enum CodingKeys: String, CodingKey {
            case interactiveLayoutConfiguration = "InteractiveLayoutConfiguration"
            case paginatedLayoutConfiguration = "PaginatedLayoutConfiguration"
            case sheetContentType = "SheetContentType"
        }
    }

    public struct DefaultPaginatedLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the default settings for a section-based layout configuration.
        public let sectionBased: DefaultSectionBasedLayoutConfiguration?

        public init(sectionBased: DefaultSectionBasedLayoutConfiguration? = nil) {
            self.sectionBased = sectionBased
        }

        private enum CodingKeys: String, CodingKey {
            case sectionBased = "SectionBased"
        }
    }

    public struct DefaultSectionBasedLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the screen canvas size options for a section-based layout.
        public let canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions

        public init(canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions) {
            self.canvasSizeOptions = canvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
        }
    }

    public struct DeleteAccountCustomizationRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to delete Amazon QuickSight customizations from in this Amazon Web Services Region.
        public let awsAccountId: String
        /// The Amazon QuickSight namespace that you're deleting the customizations from.
        public let namespace: String?

        public init(awsAccountId: String, namespace: String? = nil) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.namespace, key: "namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccountCustomizationResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteAccountSubscriptionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the account that you want to delete.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccountSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteAnalysisRequest: AWSEncodableShape {
        /// The ID of the analysis that you're deleting.
        public let analysisId: String
        /// The ID of the Amazon Web Services account where you want to delete an analysis.
        public let awsAccountId: String
        /// This option defaults to the value NoForceDeleteWithoutRecovery. To immediately delete the analysis, add the ForceDeleteWithoutRecovery option. You can't restore an analysis after it's deleted.
        public let forceDeleteWithoutRecovery: Bool?
        /// A value that specifies the number of days that Amazon QuickSight waits before it deletes the analysis. You can't use this parameter with the ForceDeleteWithoutRecovery option in the same API call. The default value is 30.
        public let recoveryWindowInDays: Int64?

        public init(analysisId: String, awsAccountId: String, forceDeleteWithoutRecovery: Bool? = nil, recoveryWindowInDays: Int64? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
            self.recoveryWindowInDays = recoveryWindowInDays
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.forceDeleteWithoutRecovery, key: "force-delete-without-recovery")
            request.encodeQuery(self.recoveryWindowInDays, key: "recovery-window-in-days")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.recoveryWindowInDays, name: "recoveryWindowInDays", parent: name, max: 30)
            try self.validate(self.recoveryWindowInDays, name: "recoveryWindowInDays", parent: name, min: 7)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnalysisResponse: AWSDecodableShape {
        /// The ID of the deleted analysis.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the deleted analysis.
        public let arn: String?
        /// The date and time that the analysis is scheduled to be deleted.
        public let deletionTime: Date?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, deletionTime: Date? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.deletionTime = deletionTime
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisId = try container.decodeIfPresent(String.self, forKey: .analysisId)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.deletionTime = try container.decodeIfPresent(Date.self, forKey: .deletionTime)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case deletionTime = "DeletionTime"
            case requestId = "RequestId"
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboard that you're deleting.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number of the dashboard. If the version number property is provided, only the specified version of the dashboard is deleted.
        public let versionNumber: Int64?

        public init(awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {
        /// The Secure Socket Layer (SSL) properties that apply for the resource.
        public let arn: String?
        /// The ID of the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.dashboardId = try container.decodeIfPresent(String.self, forKey: .dashboardId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
        }
    }

    public struct DeleteDataSetRefreshPropertiesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSetRefreshPropertiesResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteDataSetRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.dataSetId = try container.decodeIfPresent(String.self, forKey: .dataSetId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case requestId = "RequestId"
        }
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSourceId, key: "DataSourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data source that you deleted.
        public let arn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.dataSourceId = try container.decodeIfPresent(String.self, forKey: .dataSourceId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
        }
    }

    public struct DeleteFolderMembershipRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The Folder ID.
        public let folderId: String
        /// The ID of the asset that you want to delete.
        public let memberId: String
        /// The member type of the asset that you want to delete from a folder.
        public let memberType: MemberType

        public init(awsAccountId: String, folderId: String, memberId: String, memberType: MemberType) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.memberId = memberId
            self.memberType = memberType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodePath(self.memberId, key: "MemberId")
            request.encodePath(self.memberType, key: "MemberType")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.memberId, name: "memberId", parent: name, max: 2048)
            try self.validate(self.memberId, name: "memberId", parent: name, min: 1)
            try self.validate(self.memberId, name: "memberId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderMembershipResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteFolderRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFolderResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the deleted folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.folderId = try container.decodeIfPresent(String.self, forKey: .folderId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
        }
    }

    public struct DeleteGroupMembershipRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to delete the user from.
        public let groupName: String
        /// The name of the user that you want to delete from the group membership.
        public let memberName: String
        /// The namespace of the group that you want to remove a user from.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.groupName, key: "GroupName")
            request.encodePath(self.memberName, key: "MemberName")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupMembershipResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to delete.
        public let groupName: String
        /// The namespace of the group that you want to delete.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.groupName, key: "GroupName")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteIAMPolicyAssignmentRequest: AWSEncodableShape {
        /// The name of the assignment.
        public let assignmentName: String
        /// The Amazon Web Services account ID where you want to delete the IAM
        /// 			policy assignment.
        public let awsAccountId: String
        /// The namespace that contains the assignment.
        public let namespace: String

        public init(assignmentName: String, awsAccountId: String, namespace: String) {
            self.assignmentName = assignmentName
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assignmentName, key: "AssignmentName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIAMPolicyAssignmentResponse: AWSDecodableShape {
        /// The name of the assignment.
        public let assignmentName: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentName: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentName = assignmentName
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.assignmentName = try container.decodeIfPresent(String.self, forKey: .assignmentName)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case requestId = "RequestId"
        }
    }

    public struct DeleteIdentityPropagationConfigRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that you want to delete an identity propagation configuration from.
        public let awsAccountId: String
        /// The name of the Amazon Web Services service that you want to delete the associated access scopes and authorized targets from.
        public let service: ServiceType

        public init(awsAccountId: String, service: ServiceType) {
            self.awsAccountId = awsAccountId
            self.service = service
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.service, key: "Service")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdentityPropagationConfigResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteNamespaceRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to delete the Amazon QuickSight namespace from.
        public let awsAccountId: String
        /// The namespace that you want to delete.
        public let namespace: String

        public init(awsAccountId: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNamespaceResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteRefreshScheduleRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String
        /// The ID of the refresh schedule.
        public let scheduleId: String

        public init(awsAccountId: String, dataSetId: String, scheduleId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.scheduleId = scheduleId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.scheduleId, key: "ScheduleId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the refresh schedule.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The ID of the refresh schedule.
        public let scheduleId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, requestId: String? = nil, scheduleId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.scheduleId = scheduleId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.scheduleId = try container.decodeIfPresent(String.self, forKey: .scheduleId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case scheduleId = "ScheduleId"
        }
    }

    public struct DeleteRoleCustomPermissionRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace that includes the role.
        public let namespace: String
        /// The role that you want to remove permissions from.
        public let role: Role

        public init(awsAccountId: String, namespace: String, role: Role) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.role = role
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.role, key: "Role")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRoleCustomPermissionResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DeleteRoleMembershipRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group.
        public let memberName: String
        /// The namespace that contains the role.
        public let namespace: String
        /// The role that you want to remove permissions from.
        public let role: Role

        public init(awsAccountId: String, memberName: String, namespace: String, role: Role) {
            self.awsAccountId = awsAccountId
            self.memberName = memberName
            self.namespace = namespace
            self.role = role
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.memberName, key: "MemberName")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.role, key: "Role")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRoleMembershipResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteTemplateAliasRequest: AWSEncodableShape {
        /// The name for the template alias. To delete a specific alias, you delete the version that the
        /// 			alias points to. You can specify the alias name, or specify the latest version of the
        /// 			template by providing the keyword $LATEST in the AliasName
        /// 			parameter.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the item to delete.
        public let awsAccountId: String
        /// The ID for the template that the specified alias is for.
        public let templateId: String

        public init(aliasName: String, awsAccountId: String, templateId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTemplateAliasResponse: AWSDecodableShape {
        /// The name for the template alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the template you want to delete.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the template associated with the deletion.
        public let templateId: String?

        public init(aliasName: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.aliasName = try container.decodeIfPresent(String.self, forKey: .aliasName)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case requestId = "RequestId"
            case templateId = "TemplateId"
        }
    }

    public struct DeleteTemplateRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the template that you're deleting.
        public let awsAccountId: String
        /// An ID for the template you want to delete.
        public let templateId: String
        /// Specifies the version of the template that you want to delete.
        /// 			If you don't provide a version number, DeleteTemplate deletes all versions of the template.
        ///
        public let versionNumber: Int64?

        public init(awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the template.
        public let templateId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case templateId = "TemplateId"
        }
    }

    public struct DeleteThemeAliasRequest: AWSEncodableShape {
        /// The unique name for the theme alias to delete.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme alias to delete.
        public let awsAccountId: String
        /// The ID for the theme that the specified alias is for.
        public let themeId: String

        public init(aliasName: String, awsAccountId: String, themeId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.themeId, key: "ThemeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThemeAliasResponse: AWSDecodableShape {
        /// The name for the theme alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the theme resource using the deleted alias.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the theme associated with the deletion.
        public let themeId: String?

        public init(aliasName: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.aliasName = try container.decodeIfPresent(String.self, forKey: .aliasName)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeId = try container.decodeIfPresent(String.self, forKey: .themeId)
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case requestId = "RequestId"
            case themeId = "ThemeId"
        }
    }

    public struct DeleteThemeRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the theme that you're deleting.
        public let awsAccountId: String
        /// An ID for the theme that you want to delete.
        public let themeId: String
        /// The version of the theme that you want to delete.   Note: If you don't provide a version number, you're
        /// 			using this call to DeleteTheme to delete all versions of the theme.
        public let versionNumber: Int64?

        public init(awsAccountId: String, themeId: String, versionNumber: Int64? = nil) {
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.themeId, key: "ThemeId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteThemeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// An ID for the theme.
        public let themeId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeId = try container.decodeIfPresent(String.self, forKey: .themeId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case themeId = "ThemeId"
        }
    }

    public struct DeleteTopicRefreshScheduleRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let datasetId: String
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, datasetId: String, topicId: String) {
            self.awsAccountId = awsAccountId
            self.datasetId = datasetId
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.datasetId, key: "DatasetId")
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTopicRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the topic.
        public let topicArn: String?
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(datasetArn: String? = nil, requestId: String? = nil, status: Int? = nil, topicArn: String? = nil, topicId: String? = nil) {
            self.datasetArn = datasetArn
            self.requestId = requestId
            self.status = status
            self.topicArn = topicArn
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.datasetArn = try container.decodeIfPresent(String.self, forKey: .datasetArn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicArn = try container.decodeIfPresent(String.self, forKey: .topicArn)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case requestId = "RequestId"
            case topicArn = "TopicArn"
            case topicId = "TopicId"
        }
    }

    public struct DeleteTopicRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic that you want to delete.
        public let awsAccountId: String
        /// The ID of the topic that you want to delete. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, topicId: String) {
            self.awsAccountId = awsAccountId
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTopicResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the topic.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the topic that you want to delete. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, topicId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case topicId = "TopicId"
        }
    }

    public struct DeleteUserByPrincipalIdRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The principal ID of the user.
        public let principalId: String

        public init(awsAccountId: String, namespace: String, principalId: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.principalId = principalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.principalId, key: "PrincipalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserByPrincipalIdResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The name of the user that you want to delete.
        public let userName: String

        public init(awsAccountId: String, namespace: String, userName: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.userName, key: "UserName")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct DeleteVPCConnectionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the account where you want to delete a VPC
        /// 			connection.
        public let awsAccountId: String
        /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an
        /// 				Amazon Web Services account.
        public let vpcConnectionId: String

        public init(awsAccountId: String, vpcConnectionId: String) {
            self.awsAccountId = awsAccountId
            self.vpcConnectionId = vpcConnectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.vpcConnectionId, key: "VPCConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, max: 1000)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVPCConnectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted VPC connection.
        public let arn: String?
        /// The availability status of the VPC connection.
        public let availabilityStatus: VPCConnectionAvailabilityStatus?
        /// The deletion status of the VPC connection.
        public let deletionStatus: VPCConnectionResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the VPC connection that
        /// 			you're creating. This ID is a unique identifier for each Amazon Web Services Region in an
        /// 				Amazon Web Services account.
        public let vpcConnectionId: String?

        public init(arn: String? = nil, availabilityStatus: VPCConnectionAvailabilityStatus? = nil, deletionStatus: VPCConnectionResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, vpcConnectionId: String? = nil) {
            self.arn = arn
            self.availabilityStatus = availabilityStatus
            self.deletionStatus = deletionStatus
            self.requestId = requestId
            self.status = status
            self.vpcConnectionId = vpcConnectionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.availabilityStatus = try container.decodeIfPresent(VPCConnectionAvailabilityStatus.self, forKey: .availabilityStatus)
            self.deletionStatus = try container.decodeIfPresent(VPCConnectionResourceStatus.self, forKey: .deletionStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.vpcConnectionId = try container.decodeIfPresent(String.self, forKey: .vpcConnectionId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case availabilityStatus = "AvailabilityStatus"
            case deletionStatus = "DeletionStatus"
            case requestId = "RequestId"
            case vpcConnectionId = "VPCConnectionId"
        }
    }

    public struct DescribeAccountCustomizationRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to describe Amazon QuickSight customizations for.
        public let awsAccountId: String
        /// The Amazon QuickSight namespace that you want to describe Amazon QuickSight customizations for.
        public let namespace: String?
        /// The Resolved flag works with the other parameters to determine which view of Amazon QuickSight customizations is returned. You can add this flag to your command to use the same view that Amazon QuickSight uses to identify which customizations to apply to the console. Omit this flag, or set it to no-resolved, to reveal customizations that are configured at different levels.
        public let resolved: Bool?

        public init(awsAccountId: String, namespace: String? = nil, resolved: Bool? = nil) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.resolved = resolved
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.resolved, key: "resolved")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountCustomizationResponse: AWSDecodableShape {
        /// The Amazon QuickSight customizations that exist in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) of the customization that's associated with this Amazon Web Services account.
        public let arn: String?
        /// The ID for the Amazon Web Services account that you're describing.
        public let awsAccountId: String?
        /// The Amazon QuickSight namespace that you're describing.
        public let namespace: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accountCustomization = try container.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.awsAccountId = try container.decodeIfPresent(String.self, forKey: .awsAccountId)
            self.namespace = try container.decodeIfPresent(String.self, forKey: .namespace)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
        }
    }

    public struct DescribeAccountSettingsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the settings that you want to list.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountSettingsResponse: AWSDecodableShape {
        /// The Amazon QuickSight settings for this Amazon Web Services account. This information includes the edition of Amazon Amazon QuickSight that you subscribed to (Standard or Enterprise) and the notification email for the Amazon QuickSight subscription.  In the QuickSight console, the Amazon QuickSight subscription is sometimes referred to as a QuickSight "account" even though it's technically not an account by itself. Instead, it's a subscription to the Amazon QuickSight service for your Amazon Web Services account. The edition that you subscribe to applies to Amazon QuickSight in every Amazon Web Services Region where you use it.
        public let accountSettings: AccountSettings?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountSettings: AccountSettings? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountSettings = accountSettings
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accountSettings = try container.decodeIfPresent(AccountSettings.self, forKey: .accountSettings)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettings = "AccountSettings"
            case requestId = "RequestId"
        }
    }

    public struct DescribeAccountSubscriptionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID associated with your Amazon QuickSight account.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccountSubscriptionResponse: AWSDecodableShape {
        /// A structure that contains the following elements:   Your Amazon QuickSight account name.   The edition of Amazon QuickSight that your account is using.   The notification email address that is associated with the Amazon QuickSight account.    The authentication type of the Amazon QuickSight account.   The status of the Amazon QuickSight account's subscription.
        public let accountInfo: AccountInfo?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountInfo: AccountInfo? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountInfo = accountInfo
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accountInfo = try container.decodeIfPresent(AccountInfo.self, forKey: .accountInfo)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case accountInfo = "AccountInfo"
            case requestId = "RequestId"
        }
    }

    public struct DescribeAnalysisDefinitionRequest: AWSEncodableShape {
        /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis. You must be using the Amazon Web Services account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisDefinitionResponse: AWSDecodableShape {
        /// The ID of the analysis described.
        public let analysisId: String?
        /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: AnalysisDefinition?
        /// Errors associated with the analysis.
        public let errors: [AnalysisError]?
        /// The descriptive name of the analysis.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// Status associated with the analysis.    CREATION_IN_PROGRESS     CREATION_SUCCESSFUL     CREATION_FAILED     UPDATE_IN_PROGRESS     UPDATE_SUCCESSFUL     UPDATE_FAILED     DELETED
        public let resourceStatus: ResourceStatus?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the theme of the analysis.
        public let themeArn: String?

        public init(analysisId: String? = nil, definition: AnalysisDefinition? = nil, errors: [AnalysisError]? = nil, name: String? = nil, requestId: String? = nil, resourceStatus: ResourceStatus? = nil, status: Int? = nil, themeArn: String? = nil) {
            self.analysisId = analysisId
            self.definition = definition
            self.errors = errors
            self.name = name
            self.requestId = requestId
            self.resourceStatus = resourceStatus
            self.status = status
            self.themeArn = themeArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisId = try container.decodeIfPresent(String.self, forKey: .analysisId)
            self.definition = try container.decodeIfPresent(AnalysisDefinition.self, forKey: .definition)
            self.errors = try container.decodeIfPresent([AnalysisError].self, forKey: .errors)
            self.name = try container.decodeIfPresent(String.self, forKey: .name)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.resourceStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .resourceStatus)
            self.status = response.decodeStatus()
            self.themeArn = try container.decodeIfPresent(String.self, forKey: .themeArn)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case definition = "Definition"
            case errors = "Errors"
            case name = "Name"
            case requestId = "RequestId"
            case resourceStatus = "ResourceStatus"
            case themeArn = "ThemeArn"
        }
    }

    public struct DescribeAnalysisPermissionsRequest: AWSEncodableShape {
        /// The ID of the analysis whose permissions you're describing. The ID is part of the analysis URL.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're describing. You must be using the Amazon Web Services account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis whose permissions you're describing.
        public let analysisArn: String?
        /// The ID of the analysis whose permissions you're describing.
        public let analysisId: String?
        /// A structure that describes the principals and the resource-level permissions on an analysis.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisArn: String? = nil, analysisId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisArn = analysisArn
            self.analysisId = analysisId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisArn = try container.decodeIfPresent(String.self, forKey: .analysisArn)
            self.analysisId = try container.decodeIfPresent(String.self, forKey: .analysisId)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysisArn = "AnalysisArn"
            case analysisId = "AnalysisId"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct DescribeAnalysisRequest: AWSEncodableShape {
        /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis. You must be using the  Amazon Web Services account that the analysis is in.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAnalysisResponse: AWSDecodableShape {
        /// A metadata structure that contains summary information for the analysis that you're describing.
        public let analysis: Analysis?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysis: Analysis? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysis = analysis
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysis = try container.decodeIfPresent(Analysis.self, forKey: .analysis)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysis = "Analysis"
            case requestId = "RequestId"
        }
    }

    public struct DescribeAssetBundleExportJobRequest: AWSEncodableShape {
        /// The ID of the job that you want described. The job ID is set when you start a new job with a StartAssetBundleExportJob API call.
        public let assetBundleExportJobId: String
        /// The ID of the Amazon Web Services account the export job is executed in.
        public let awsAccountId: String

        public init(assetBundleExportJobId: String, awsAccountId: String) {
            self.assetBundleExportJobId = assetBundleExportJobId
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetBundleExportJobId, key: "AssetBundleExportJobId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetBundleExportJobId, name: "assetBundleExportJobId", parent: name, max: 512)
            try self.validate(self.assetBundleExportJobId, name: "assetBundleExportJobId", parent: name, min: 1)
            try self.validate(self.assetBundleExportJobId, name: "assetBundleExportJobId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetBundleExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the export job.
        public let arn: String?
        /// The ID of the job. The job ID is set when you start a new job with a StartAssetBundleExportJob API call.
        public let assetBundleExportJobId: String?
        /// The ID of the Amazon Web Services account that the export job was executed in.
        public let awsAccountId: String?
        /// The CloudFormation override property configuration for the export job.
        public let cloudFormationOverridePropertyConfiguration: AssetBundleCloudFormationOverridePropertyConfiguration?
        /// The time that the export job was created.
        public let createdTime: Date?
        /// The URL to download the exported asset bundle data from. This URL is available only after the job has succeeded. This URL is valid for 5 minutes after issuance. Call DescribeAssetBundleExportJob again for a fresh URL if needed. The downloaded asset bundle is a zip file named assetbundle-{jobId}.qs. The file has a .qs extension. This URL can't be used in a StartAssetBundleImportJob API call and should only be used for download purposes.
        public let downloadUrl: String?
        /// An array of error records that describes any failures that occurred during the export job processing. Error records accumulate while the job runs. The complete set of error records is available after the job has completed and failed.
        public let errors: [AssetBundleExportJobError]?
        /// The format of the exported asset bundle. A QUICKSIGHT_JSON formatted file can be used to make a StartAssetBundleImportJob API call. A CLOUDFORMATION_JSON formatted file can be used in the CloudFormation console and with the CloudFormation APIs.
        public let exportFormat: AssetBundleExportFormat?
        /// The include dependencies flag.
        public let includeAllDependencies: Bool?
        /// The include permissions flag.
        public let includePermissions: Bool?
        /// The include tags flag.
        public let includeTags: Bool?
        /// Indicates the status of a job through its queuing and execution. Poll this DescribeAssetBundleExportApi until JobStatus is either SUCCESSFUL or FAILED.
        public let jobStatus: AssetBundleExportJobStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// A list of resource ARNs that exported with the job.
        public let resourceArns: [String]?
        /// The HTTP status of the response.
        public let status: Int?
        /// The validation strategy that is used to export the analysis or dashboard.
        public let validationStrategy: AssetBundleExportJobValidationStrategy?
        /// An array of warning records that describe the analysis or dashboard that is exported. This array includes UI errors that can be skipped during the validation process. This property only appears if StrictModeForAllResources in ValidationStrategy is set to FALSE.
        public let warnings: [AssetBundleExportJobWarning]?

        public init(arn: String? = nil, assetBundleExportJobId: String? = nil, awsAccountId: String? = nil, cloudFormationOverridePropertyConfiguration: AssetBundleCloudFormationOverridePropertyConfiguration? = nil, createdTime: Date? = nil, downloadUrl: String? = nil, errors: [AssetBundleExportJobError]? = nil, exportFormat: AssetBundleExportFormat? = nil, includeAllDependencies: Bool? = nil, includePermissions: Bool? = nil, includeTags: Bool? = nil, jobStatus: AssetBundleExportJobStatus? = nil, requestId: String? = nil, resourceArns: [String]? = nil, status: Int? = nil, validationStrategy: AssetBundleExportJobValidationStrategy? = nil, warnings: [AssetBundleExportJobWarning]? = nil) {
            self.arn = arn
            self.assetBundleExportJobId = assetBundleExportJobId
            self.awsAccountId = awsAccountId
            self.cloudFormationOverridePropertyConfiguration = cloudFormationOverridePropertyConfiguration
            self.createdTime = createdTime
            self.downloadUrl = downloadUrl
            self.errors = errors
            self.exportFormat = exportFormat
            self.includeAllDependencies = includeAllDependencies
            self.includePermissions = includePermissions
            self.includeTags = includeTags
            self.jobStatus = jobStatus
            self.requestId = requestId
            self.resourceArns = resourceArns
            self.status = status
            self.validationStrategy = validationStrategy
            self.warnings = warnings
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.assetBundleExportJobId = try container.decodeIfPresent(String.self, forKey: .assetBundleExportJobId)
            self.awsAccountId = try container.decodeIfPresent(String.self, forKey: .awsAccountId)
            self.cloudFormationOverridePropertyConfiguration = try container.decodeIfPresent(AssetBundleCloudFormationOverridePropertyConfiguration.self, forKey: .cloudFormationOverridePropertyConfiguration)
            self.createdTime = try container.decodeIfPresent(Date.self, forKey: .createdTime)
            self.downloadUrl = try container.decodeIfPresent(String.self, forKey: .downloadUrl)
            self.errors = try container.decodeIfPresent([AssetBundleExportJobError].self, forKey: .errors)
            self.exportFormat = try container.decodeIfPresent(AssetBundleExportFormat.self, forKey: .exportFormat)
            self.includeAllDependencies = try container.decodeIfPresent(Bool.self, forKey: .includeAllDependencies)
            self.includePermissions = try container.decodeIfPresent(Bool.self, forKey: .includePermissions)
            self.includeTags = try container.decodeIfPresent(Bool.self, forKey: .includeTags)
            self.jobStatus = try container.decodeIfPresent(AssetBundleExportJobStatus.self, forKey: .jobStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.resourceArns = try container.decodeIfPresent([String].self, forKey: .resourceArns)
            self.status = response.decodeStatus()
            self.validationStrategy = try container.decodeIfPresent(AssetBundleExportJobValidationStrategy.self, forKey: .validationStrategy)
            self.warnings = try container.decodeIfPresent([AssetBundleExportJobWarning].self, forKey: .warnings)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetBundleExportJobId = "AssetBundleExportJobId"
            case awsAccountId = "AwsAccountId"
            case cloudFormationOverridePropertyConfiguration = "CloudFormationOverridePropertyConfiguration"
            case createdTime = "CreatedTime"
            case downloadUrl = "DownloadUrl"
            case errors = "Errors"
            case exportFormat = "ExportFormat"
            case includeAllDependencies = "IncludeAllDependencies"
            case includePermissions = "IncludePermissions"
            case includeTags = "IncludeTags"
            case jobStatus = "JobStatus"
            case requestId = "RequestId"
            case resourceArns = "ResourceArns"
            case validationStrategy = "ValidationStrategy"
            case warnings = "Warnings"
        }
    }

    public struct DescribeAssetBundleImportJobRequest: AWSEncodableShape {
        /// The ID of the job. The job ID is set when you start a new job with a StartAssetBundleImportJob API call.
        public let assetBundleImportJobId: String
        /// The ID of the Amazon Web Services account the import job was executed in.
        public let awsAccountId: String

        public init(assetBundleImportJobId: String, awsAccountId: String) {
            self.assetBundleImportJobId = assetBundleImportJobId
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetBundleImportJobId, key: "AssetBundleImportJobId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetBundleImportJobId, name: "assetBundleImportJobId", parent: name, max: 512)
            try self.validate(self.assetBundleImportJobId, name: "assetBundleImportJobId", parent: name, min: 1)
            try self.validate(self.assetBundleImportJobId, name: "assetBundleImportJobId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetBundleImportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the import job.
        public let arn: String?
        /// The ID of the job. The job ID is set when you start a new job with a StartAssetBundleImportJob API call.
        public let assetBundleImportJobId: String?
        /// The source of the asset bundle zip file that contains the data that is imported by the job.
        public let assetBundleImportSource: AssetBundleImportSourceDescription?
        /// The ID of the Amazon Web Services account the import job was executed in.
        public let awsAccountId: String?
        /// The time that the import job was created.
        public let createdTime: Date?
        /// An array of error records that describes any failures that occurred during the export job processing. Error records accumulate while the job is still running. The complete set of error records is available after the job has completed and failed.
        public let errors: [AssetBundleImportJobError]?
        /// The failure action for the import job.
        public let failureAction: AssetBundleImportFailureAction?
        /// Indicates the status of a job through its queuing and execution. Poll the DescribeAssetBundleImport API until JobStatus returns one of the following values:    SUCCESSFUL     FAILED     FAILED_ROLLBACK_COMPLETED     FAILED_ROLLBACK_ERROR
        public let jobStatus: AssetBundleImportJobStatus?
        /// Optional overrides that are applied to the resource configuration before import.
        public let overrideParameters: AssetBundleImportJobOverrideParameters?
        /// Optional permission overrides that are applied to the resource configuration before import.
        public let overridePermissions: AssetBundleImportJobOverridePermissions?
        /// Optional tag overrides that are applied to the resource configuration before import.
        public let overrideTags: AssetBundleImportJobOverrideTags?
        /// An optional validation strategy override for all analyses and dashboards to be applied to the resource configuration before import.
        public let overrideValidationStrategy: AssetBundleImportJobOverrideValidationStrategy?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// An array of error records that describes any failures that occurred while an import job was attempting a rollback. Error records accumulate while the job is still running. The complete set of error records is available after the job has completed and failed.
        public let rollbackErrors: [AssetBundleImportJobError]?
        /// The HTTP status of the response.
        public let status: Int?

        public init(arn: String? = nil, assetBundleImportJobId: String? = nil, assetBundleImportSource: AssetBundleImportSourceDescription? = nil, awsAccountId: String? = nil, createdTime: Date? = nil, errors: [AssetBundleImportJobError]? = nil, failureAction: AssetBundleImportFailureAction? = nil, jobStatus: AssetBundleImportJobStatus? = nil, overrideParameters: AssetBundleImportJobOverrideParameters? = nil, overridePermissions: AssetBundleImportJobOverridePermissions? = nil, overrideTags: AssetBundleImportJobOverrideTags? = nil, overrideValidationStrategy: AssetBundleImportJobOverrideValidationStrategy? = nil, requestId: String? = nil, rollbackErrors: [AssetBundleImportJobError]? = nil, status: Int? = nil) {
            self.arn = arn
            self.assetBundleImportJobId = assetBundleImportJobId
            self.assetBundleImportSource = assetBundleImportSource
            self.awsAccountId = awsAccountId
            self.createdTime = createdTime
            self.errors = errors
            self.failureAction = failureAction
            self.jobStatus = jobStatus
            self.overrideParameters = overrideParameters
            self.overridePermissions = overridePermissions
            self.overrideTags = overrideTags
            self.overrideValidationStrategy = overrideValidationStrategy
            self.requestId = requestId
            self.rollbackErrors = rollbackErrors
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.assetBundleImportJobId = try container.decodeIfPresent(String.self, forKey: .assetBundleImportJobId)
            self.assetBundleImportSource = try container.decodeIfPresent(AssetBundleImportSourceDescription.self, forKey: .assetBundleImportSource)
            self.awsAccountId = try container.decodeIfPresent(String.self, forKey: .awsAccountId)
            self.createdTime = try container.decodeIfPresent(Date.self, forKey: .createdTime)
            self.errors = try container.decodeIfPresent([AssetBundleImportJobError].self, forKey: .errors)
            self.failureAction = try container.decodeIfPresent(AssetBundleImportFailureAction.self, forKey: .failureAction)
            self.jobStatus = try container.decodeIfPresent(AssetBundleImportJobStatus.self, forKey: .jobStatus)
            self.overrideParameters = try container.decodeIfPresent(AssetBundleImportJobOverrideParameters.self, forKey: .overrideParameters)
            self.overridePermissions = try container.decodeIfPresent(AssetBundleImportJobOverridePermissions.self, forKey: .overridePermissions)
            self.overrideTags = try container.decodeIfPresent(AssetBundleImportJobOverrideTags.self, forKey: .overrideTags)
            self.overrideValidationStrategy = try container.decodeIfPresent(AssetBundleImportJobOverrideValidationStrategy.self, forKey: .overrideValidationStrategy)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.rollbackErrors = try container.decodeIfPresent([AssetBundleImportJobError].self, forKey: .rollbackErrors)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetBundleImportJobId = "AssetBundleImportJobId"
            case assetBundleImportSource = "AssetBundleImportSource"
            case awsAccountId = "AwsAccountId"
            case createdTime = "CreatedTime"
            case errors = "Errors"
            case failureAction = "FailureAction"
            case jobStatus = "JobStatus"
            case overrideParameters = "OverrideParameters"
            case overridePermissions = "OverridePermissions"
            case overrideTags = "OverrideTags"
            case overrideValidationStrategy = "OverrideValidationStrategy"
            case requestId = "RequestId"
            case rollbackErrors = "RollbackErrors"
        }
    }

    public struct DescribeDashboardDefinitionRequest: AWSEncodableShape {
        /// The alias name.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aliasName, key: "alias-name")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardDefinitionResponse: AWSDecodableShape {
        /// The ID of the dashboard described.
        public let dashboardId: String?
        /// Options for publishing the dashboard:    AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.     AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.     VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
        public let dashboardPublishOptions: DashboardPublishOptions?
        /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: DashboardVersionDefinition?
        /// Errors associated with this dashboard version.
        public let errors: [DashboardError]?
        /// The display name of the dashboard.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// Status associated with the dashboard version.    CREATION_IN_PROGRESS     CREATION_SUCCESSFUL     CREATION_FAILED     UPDATE_IN_PROGRESS     UPDATE_SUCCESSFUL     UPDATE_FAILED     DELETED
        public let resourceStatus: ResourceStatus?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the theme of the dashboard.
        public let themeArn: String?

        public init(dashboardId: String? = nil, dashboardPublishOptions: DashboardPublishOptions? = nil, definition: DashboardVersionDefinition? = nil, errors: [DashboardError]? = nil, name: String? = nil, requestId: String? = nil, resourceStatus: ResourceStatus? = nil, status: Int? = nil, themeArn: String? = nil) {
            self.dashboardId = dashboardId
            self.dashboardPublishOptions = dashboardPublishOptions
            self.definition = definition
            self.errors = errors
            self.name = name
            self.requestId = requestId
            self.resourceStatus = resourceStatus
            self.status = status
            self.themeArn = themeArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardId = try container.decodeIfPresent(String.self, forKey: .dashboardId)
            self.dashboardPublishOptions = try container.decodeIfPresent(DashboardPublishOptions.self, forKey: .dashboardPublishOptions)
            self.definition = try container.decodeIfPresent(DashboardVersionDefinition.self, forKey: .definition)
            self.errors = try container.decodeIfPresent([DashboardError].self, forKey: .errors)
            self.name = try container.decodeIfPresent(String.self, forKey: .name)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.resourceStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .resourceStatus)
            self.status = response.decodeStatus()
            self.themeArn = try container.decodeIfPresent(String.self, forKey: .themeArn)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardId = "DashboardId"
            case dashboardPublishOptions = "DashboardPublishOptions"
            case definition = "Definition"
            case errors = "Errors"
            case name = "Name"
            case requestId = "RequestId"
            case resourceStatus = "ResourceStatus"
            case themeArn = "ThemeArn"
        }
    }

    public struct DescribeDashboardPermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboard that you're describing permissions for.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the IAM policy.
        public let dashboardId: String

        public init(awsAccountId: String, dashboardId: String) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// A structure that contains the configuration of a shareable link that grants access to the dashboard. Your users can use the link to view and interact with the dashboard, if the dashboard has been shared with them. For more information about sharing dashboards, see Sharing Dashboards.
        public let linkSharingConfiguration: LinkSharingConfiguration?
        /// A structure that contains the permissions for the dashboard.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, linkSharingConfiguration: LinkSharingConfiguration? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.linkSharingConfiguration = linkSharingConfiguration
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardArn = try container.decodeIfPresent(String.self, forKey: .dashboardArn)
            self.dashboardId = try container.decodeIfPresent(String.self, forKey: .dashboardId)
            self.linkSharingConfiguration = try container.decodeIfPresent(LinkSharingConfiguration.self, forKey: .linkSharingConfiguration)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case linkSharingConfiguration = "LinkSharingConfiguration"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        /// The alias name.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, dashboardId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aliasName, key: "alias-name")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {
        /// Information about the dashboard.
        public let dashboard: Dashboard?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of this request.
        public let status: Int?

        public init(dashboard: Dashboard? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboard = dashboard
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboard = try container.decodeIfPresent(Dashboard.self, forKey: .dashboard)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboard = "Dashboard"
            case requestId = "RequestId"
        }
    }

    public struct DescribeDashboardSnapshotJobRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
        public let awsAccountId: String
        /// The ID of the dashboard that you have started a snapshot job for.
        public let dashboardId: String
        /// The ID of the job to be described. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
        public let snapshotJobId: String

        public init(awsAccountId: String, dashboardId: String, snapshotJobId: String) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.snapshotJobId = snapshotJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodePath(self.snapshotJobId, key: "SnapshotJobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, max: 512)
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, min: 1)
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardSnapshotJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the snapshot job. The job ARN is generated when you start a new job with a StartDashboardSnapshotJob API call.
        public let arn: String?
        ///  The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
        public let awsAccountId: String?
        ///  The time that the snapshot job was created.
        public let createdTime: Date?
        /// The ID of the dashboard that you have started a snapshot job for.
        public let dashboardId: String?
        /// Indicates the status of a job. The status updates as the job executes. This shows one of the following values.    COMPLETED - The job was completed successfully.    FAILED - The job failed to execute.    QUEUED - The job is queued and hasn't started yet.    RUNNING - The job is still running.
        public let jobStatus: SnapshotJobStatus?
        ///  The time that the snapshot job status was last updated.
        public let lastUpdatedTime: Date?
        ///  The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The snapshot configuration of the job. This information is provided when you make a StartDashboardSnapshotJob API call.
        public let snapshotConfiguration: SnapshotConfiguration?
        /// The ID of the job to be described. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
        public let snapshotJobId: String?
        /// The HTTP status of the request
        public let status: Int?
        /// The user configuration for the snapshot job. This information is provided when you make a StartDashboardSnapshotJob API call.
        public let userConfiguration: SnapshotUserConfigurationRedacted?

        public init(arn: String? = nil, awsAccountId: String? = nil, createdTime: Date? = nil, dashboardId: String? = nil, jobStatus: SnapshotJobStatus? = nil, lastUpdatedTime: Date? = nil, requestId: String? = nil, snapshotConfiguration: SnapshotConfiguration? = nil, snapshotJobId: String? = nil, status: Int? = nil, userConfiguration: SnapshotUserConfigurationRedacted? = nil) {
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.jobStatus = jobStatus
            self.lastUpdatedTime = lastUpdatedTime
            self.requestId = requestId
            self.snapshotConfiguration = snapshotConfiguration
            self.snapshotJobId = snapshotJobId
            self.status = status
            self.userConfiguration = userConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case createdTime = "CreatedTime"
            case dashboardId = "DashboardId"
            case jobStatus = "JobStatus"
            case lastUpdatedTime = "LastUpdatedTime"
            case requestId = "RequestId"
            case snapshotConfiguration = "SnapshotConfiguration"
            case snapshotJobId = "SnapshotJobId"
            case status = "Status"
            case userConfiguration = "UserConfiguration"
        }
    }

    public struct DescribeDashboardSnapshotJobResultRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
        public let awsAccountId: String
        /// The ID of the dashboard that you have started a snapshot job for.
        public let dashboardId: String
        /// The ID of the job to be described. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
        public let snapshotJobId: String

        public init(awsAccountId: String, dashboardId: String, snapshotJobId: String) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.snapshotJobId = snapshotJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodePath(self.snapshotJobId, key: "SnapshotJobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, max: 512)
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, min: 1)
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardSnapshotJobResultResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the snapshot job. The job ARN is generated when you start a new job with a StartDashboardSnapshotJob API call.
        public let arn: String?
        /// The time that a snapshot job was created.
        public let createdTime: Date?
        /// Displays information for the error that caused a job to fail.
        public let errorInfo: SnapshotJobErrorInfo?
        /// Indicates the status of a job after it has reached a terminal state. A finished snapshot job will retuen a COMPLETED or FAILED status.
        public let jobStatus: SnapshotJobStatus?
        /// The time that a snapshot job status was last updated.
        public let lastUpdatedTime: Date?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The result of the snapshot job. Jobs that have successfully completed will return the S3Uri where they are located. Jobs that have failedwill return information on the error that caused the job to fail.
        public let result: SnapshotJobResult?
        /// The HTTP status of the request
        public let status: Int?

        public init(arn: String? = nil, createdTime: Date? = nil, errorInfo: SnapshotJobErrorInfo? = nil, jobStatus: SnapshotJobStatus? = nil, lastUpdatedTime: Date? = nil, requestId: String? = nil, result: SnapshotJobResult? = nil, status: Int? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.errorInfo = errorInfo
            self.jobStatus = jobStatus
            self.lastUpdatedTime = lastUpdatedTime
            self.requestId = requestId
            self.result = result
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.createdTime = try container.decodeIfPresent(Date.self, forKey: .createdTime)
            self.errorInfo = try container.decodeIfPresent(SnapshotJobErrorInfo.self, forKey: .errorInfo)
            self.jobStatus = try container.decodeIfPresent(SnapshotJobStatus.self, forKey: .jobStatus)
            self.lastUpdatedTime = try container.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.result = try container.decodeIfPresent(SnapshotJobResult.self, forKey: .result)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case errorInfo = "ErrorInfo"
            case jobStatus = "JobStatus"
            case lastUpdatedTime = "LastUpdatedTime"
            case requestId = "RequestId"
            case result = "Result"
        }
    }

    public struct DescribeDataSetPermissionsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSetPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let dataSetArn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// A list of resource permissions on the dataset.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetArn: String? = nil, dataSetId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetArn = dataSetArn
            self.dataSetId = dataSetId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSetArn = try container.decodeIfPresent(String.self, forKey: .dataSetArn)
            self.dataSetId = try container.decodeIfPresent(String.self, forKey: .dataSetId)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetId = "DataSetId"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct DescribeDataSetRefreshPropertiesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSetRefreshPropertiesResponse: AWSDecodableShape {
        /// The dataset refresh properties.
        public let dataSetRefreshProperties: DataSetRefreshProperties?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetRefreshProperties: DataSetRefreshProperties? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetRefreshProperties = dataSetRefreshProperties
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSetRefreshProperties = try container.decodeIfPresent(DataSetRefreshProperties.self, forKey: .dataSetRefreshProperties)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetRefreshProperties = "DataSetRefreshProperties"
            case requestId = "RequestId"
        }
    }

    public struct DescribeDataSetRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSetResponse: AWSDecodableShape {
        /// Information on the dataset.
        public let dataSet: DataSet?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSet: DataSet? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSet = dataSet
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSet = try container.decodeIfPresent(DataSet.self, forKey: .dataSet)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSet = "DataSet"
            case requestId = "RequestId"
        }
    }

    public struct DescribeDataSourcePermissionsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSourceId, key: "DataSourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSourcePermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// A list of resource permissions on the data source.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSourceArn = try container.decodeIfPresent(String.self, forKey: .dataSourceArn)
            self.dataSourceId = try container.decodeIfPresent(String.self, forKey: .dataSourceId)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case dataSourceId = "DataSourceId"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct DescribeDataSourceRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String

        public init(awsAccountId: String, dataSourceId: String) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSourceId, key: "DataSourceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDataSourceResponse: AWSDecodableShape {
        /// The information on the data source.
        public let dataSource: DataSource?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSource: DataSource? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSource = dataSource
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSource = try container.decodeIfPresent(DataSource.self, forKey: .dataSource)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case requestId = "RequestId"
        }
    }

    public struct DescribeFolderPermissionsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace of the folder whose permissions you want described.
        public let namespace: String?
        /// A pagination token for the next set of results.
        public let nextToken: String?

        public init(awsAccountId: String, folderId: String, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// The pagination token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Information about the permissions on the folder.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, nextToken: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.nextToken = nextToken
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.folderId = try container.decodeIfPresent(String.self, forKey: .folderId)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case nextToken = "NextToken"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct DescribeFolderRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String

        public init(awsAccountId: String, folderId: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderResolvedPermissionsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace of the folder whose permissions you want described.
        public let namespace: String?
        /// A pagination token for the next set of results.
        public let nextToken: String?

        public init(awsAccountId: String, folderId: String, maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeFolderResolvedPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// A pagination token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Information about the permissions for the folder.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, nextToken: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.nextToken = nextToken
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.folderId = try container.decodeIfPresent(String.self, forKey: .folderId)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case nextToken = "NextToken"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct DescribeFolderResponse: AWSDecodableShape {
        /// Information about the folder.
        public let folder: Folder?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folder: Folder? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folder = folder
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.folder = try container.decodeIfPresent(Folder.self, forKey: .folder)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case folder = "Folder"
            case requestId = "RequestId"
        }
    }

    public struct DescribeGroupMembershipRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the  Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to search.
        public let groupName: String
        /// The user name of the user that you want to search for.
        public let memberName: String
        /// The namespace that includes the group you are searching within.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, memberName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.memberName = memberName
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.groupName, key: "GroupName")
            request.encodePath(self.memberName, key: "MemberName")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.memberName, name: "memberName", parent: name, max: 256)
            try self.validate(self.memberName, name: "memberName", parent: name, min: 1)
            try self.validate(self.memberName, name: "memberName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGroupMembershipResponse: AWSDecodableShape {
        public let groupMember: GroupMember?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMember: GroupMember? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMember = groupMember
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.groupMember = try container.decodeIfPresent(GroupMember.self, forKey: .groupMember)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case groupMember = "GroupMember"
            case requestId = "RequestId"
        }
    }

    public struct DescribeGroupRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to describe.
        public let groupName: String
        /// The namespace of the group that you want described.
        public let namespace: String

        public init(awsAccountId: String, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.groupName, key: "GroupName")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGroupResponse: AWSDecodableShape {
        /// The name of the group.
        public let group: Group?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.group = try container.decodeIfPresent(Group.self, forKey: .group)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
        }
    }

    public struct DescribeIAMPolicyAssignmentRequest: AWSEncodableShape {
        /// The name of the assignment, also called a rule.
        public let assignmentName: String
        /// The ID of the Amazon Web Services account that contains the assignment that you want to
        /// 			describe.
        public let awsAccountId: String
        /// The namespace that contains the assignment.
        public let namespace: String

        public init(assignmentName: String, awsAccountId: String, namespace: String) {
            self.assignmentName = assignmentName
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assignmentName, key: "AssignmentName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIAMPolicyAssignmentResponse: AWSDecodableShape {
        /// Information describing the IAM policy assignment.
        public let iamPolicyAssignment: IAMPolicyAssignment?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(iamPolicyAssignment: IAMPolicyAssignment? = nil, requestId: String? = nil, status: Int? = nil) {
            self.iamPolicyAssignment = iamPolicyAssignment
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.iamPolicyAssignment = try container.decodeIfPresent(IAMPolicyAssignment.self, forKey: .iamPolicyAssignment)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case iamPolicyAssignment = "IAMPolicyAssignment"
            case requestId = "RequestId"
        }
    }

    public struct DescribeIngestionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// An ID for the ingestion.
        public let ingestionId: String

        public init(awsAccountId: String, dataSetId: String, ingestionId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.ingestionId = ingestionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.ingestionId, key: "IngestionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, max: 128)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, min: 1)
            try self.validate(self.ingestionId, name: "ingestionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIngestionResponse: AWSDecodableShape {
        /// Information about the ingestion.
        public let ingestion: Ingestion?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(ingestion: Ingestion? = nil, requestId: String? = nil, status: Int? = nil) {
            self.ingestion = ingestion
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.ingestion = try container.decodeIfPresent(Ingestion.self, forKey: .ingestion)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case ingestion = "Ingestion"
            case requestId = "RequestId"
        }
    }

    public struct DescribeIpRestrictionRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String

        public init(awsAccountId: String) {
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeIpRestrictionResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String?
        /// A value that specifies whether IP rules are turned on.
        public let enabled: Bool?
        /// A map that describes the IP rules with CIDR range and description.
        public let ipRestrictionRuleMap: [String: String]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        ///
        public let status: Int?
        /// A map of allowed VPC endpoint IDs and their rule descriptions.
        public let vpcEndpointIdRestrictionRuleMap: [String: String]?
        /// A map of allowed VPC IDs and their rule descriptions.
        public let vpcIdRestrictionRuleMap: [String: String]?

        public init(awsAccountId: String? = nil, enabled: Bool? = nil, ipRestrictionRuleMap: [String: String]? = nil, requestId: String? = nil, status: Int? = nil, vpcEndpointIdRestrictionRuleMap: [String: String]? = nil, vpcIdRestrictionRuleMap: [String: String]? = nil) {
            self.awsAccountId = awsAccountId
            self.enabled = enabled
            self.ipRestrictionRuleMap = ipRestrictionRuleMap
            self.requestId = requestId
            self.status = status
            self.vpcEndpointIdRestrictionRuleMap = vpcEndpointIdRestrictionRuleMap
            self.vpcIdRestrictionRuleMap = vpcIdRestrictionRuleMap
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.awsAccountId = try container.decodeIfPresent(String.self, forKey: .awsAccountId)
            self.enabled = try container.decodeIfPresent(Bool.self, forKey: .enabled)
            self.ipRestrictionRuleMap = try container.decodeIfPresent([String: String].self, forKey: .ipRestrictionRuleMap)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.vpcEndpointIdRestrictionRuleMap = try container.decodeIfPresent([String: String].self, forKey: .vpcEndpointIdRestrictionRuleMap)
            self.vpcIdRestrictionRuleMap = try container.decodeIfPresent([String: String].self, forKey: .vpcIdRestrictionRuleMap)
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case enabled = "Enabled"
            case ipRestrictionRuleMap = "IpRestrictionRuleMap"
            case requestId = "RequestId"
            case vpcEndpointIdRestrictionRuleMap = "VpcEndpointIdRestrictionRuleMap"
            case vpcIdRestrictionRuleMap = "VpcIdRestrictionRuleMap"
        }
    }

    public struct DescribeNamespaceRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespace that you want to describe.
        public let awsAccountId: String
        /// The namespace that you want to describe.
        public let namespace: String

        public init(awsAccountId: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeNamespaceResponse: AWSDecodableShape {
        /// The information about the namespace that you're describing. The response includes  the namespace ARN, name, Amazon Web Services Region, creation status, and identity store. DescribeNamespace also works for namespaces that are in the process of being created. For incomplete namespaces, this API operation lists the namespace error types and messages associated with the creation process.
        public let namespace: NamespaceInfoV2?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(namespace: NamespaceInfoV2? = nil, requestId: String? = nil, status: Int? = nil) {
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.namespace = try container.decodeIfPresent(NamespaceInfoV2.self, forKey: .namespace)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case requestId = "RequestId"
        }
    }

    public struct DescribeRefreshScheduleRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String
        /// The ID of the refresh schedule.
        public let scheduleId: String

        public init(awsAccountId: String, dataSetId: String, scheduleId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.scheduleId = scheduleId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodePath(self.scheduleId, key: "ScheduleId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the refresh schedule.
        public let arn: String?
        /// The refresh schedule.
        public let refreshSchedule: RefreshSchedule?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, refreshSchedule: RefreshSchedule? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.refreshSchedule = refreshSchedule
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.refreshSchedule = try container.decodeIfPresent(RefreshSchedule.self, forKey: .refreshSchedule)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case refreshSchedule = "RefreshSchedule"
            case requestId = "RequestId"
        }
    }

    public struct DescribeRoleCustomPermissionRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace that contains the role.
        public let namespace: String
        /// The name of the role whose permissions you want described.
        public let role: Role

        public init(awsAccountId: String, namespace: String, role: Role) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.role = role
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.role, key: "Role")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRoleCustomPermissionResponse: AWSDecodableShape {
        /// The name of the custom permission that is described.
        public let customPermissionsName: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(customPermissionsName: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.customPermissionsName = customPermissionsName
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case customPermissionsName = "CustomPermissionsName"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct DescribeTemplateAliasRequest: AWSEncodableShape {
        /// The name of the template alias that you want to describe. If you name a specific alias, you
        /// 			describe the version that the alias points to. You can specify the latest version of the
        /// 			template by providing the keyword $LATEST in the AliasName
        /// 			parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the template alias that you're
        /// 			describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String

        public init(aliasName: String, awsAccountId: String, templateId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateAliasResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateAlias = try container.decodeIfPresent(TemplateAlias.self, forKey: .templateAlias)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct DescribeTemplateDefinitionRequest: AWSEncodableShape {
        /// The alias of the template that you want to describe. If you name a specific alias, you
        /// 			 describe the version that the alias points to. You can specify the latest version of the
        /// 			 template by providing the keyword $LATEST in the AliasName
        /// 			 parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the template. You must be using the
        /// 			 Amazon Web Services account that the template is in.
        public let awsAccountId: String
        /// The ID of the template that you're describing.
        public let templateId: String
        /// The version number of the template.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aliasName, key: "alias-name")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateDefinitionResponse: AWSDecodableShape {
        /// The definition of the template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: TemplateVersionDefinition?
        /// Errors associated with the template version.
        public let errors: [TemplateError]?
        /// The descriptive name of the template.
        public let name: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// Status associated with the template.    CREATION_IN_PROGRESS     CREATION_SUCCESSFUL     CREATION_FAILED     UPDATE_IN_PROGRESS     UPDATE_SUCCESSFUL     UPDATE_FAILED     DELETED
        public let resourceStatus: ResourceStatus?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the template described.
        public let templateId: String?
        /// The ARN of the theme of the template.
        public let themeArn: String?

        public init(definition: TemplateVersionDefinition? = nil, errors: [TemplateError]? = nil, name: String? = nil, requestId: String? = nil, resourceStatus: ResourceStatus? = nil, status: Int? = nil, templateId: String? = nil, themeArn: String? = nil) {
            self.definition = definition
            self.errors = errors
            self.name = name
            self.requestId = requestId
            self.resourceStatus = resourceStatus
            self.status = status
            self.templateId = templateId
            self.themeArn = themeArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.definition = try container.decodeIfPresent(TemplateVersionDefinition.self, forKey: .definition)
            self.errors = try container.decodeIfPresent([TemplateError].self, forKey: .errors)
            self.name = try container.decodeIfPresent(String.self, forKey: .name)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.resourceStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .resourceStatus)
            self.status = response.decodeStatus()
            self.templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
            self.themeArn = try container.decodeIfPresent(String.self, forKey: .themeArn)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case errors = "Errors"
            case name = "Name"
            case requestId = "RequestId"
            case resourceStatus = "ResourceStatus"
            case templateId = "TemplateId"
            case themeArn = "ThemeArn"
        }
    }

    public struct DescribeTemplatePermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the template that you're describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, templateId: String) {
            self.awsAccountId = awsAccountId
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplatePermissionsResponse: AWSDecodableShape {
        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String?
        /// The ID for the template.
        public let templateId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, templateArn: String? = nil, templateId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateArn = try container.decodeIfPresent(String.self, forKey: .templateArn)
            self.templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case templateArn = "TemplateArn"
            case templateId = "TemplateId"
        }
    }

    public struct DescribeTemplateRequest: AWSEncodableShape {
        /// The alias of the template that you want to describe. If you name a specific alias, you
        /// 			describe the version that the alias points to. You can specify the latest version of the
        /// 			template by providing the keyword $LATEST in the AliasName
        /// 			parameter. The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the template that you're describing.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String
        /// (Optional) The number for the version to describe. If a VersionNumber parameter
        /// 			value isn't provided, the latest version of the template is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, templateId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aliasName, key: "alias-name")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTemplateResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The template structure for the object you want to describe.
        public let template: Template?

        public init(requestId: String? = nil, status: Int? = nil, template: Template? = nil) {
            self.requestId = requestId
            self.status = status
            self.template = template
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.template = try container.decodeIfPresent(Template.self, forKey: .template)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case template = "Template"
        }
    }

    public struct DescribeThemeAliasRequest: AWSEncodableShape {
        /// The name of the theme alias that you want to describe.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme alias that you're
        /// 			describing.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String

        public init(aliasName: String, awsAccountId: String, themeId: String) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.themeId, key: "ThemeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemeAliasResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeAlias = try container.decodeIfPresent(ThemeAlias.self, forKey: .themeAlias)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct DescribeThemePermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the theme that you're describing.
        public let awsAccountId: String
        /// The ID for the theme that you want to describe permissions for.
        public let themeId: String

        public init(awsAccountId: String, themeId: String) {
            self.awsAccountId = awsAccountId
            self.themeId = themeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.themeId, key: "ThemeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemePermissionsResponse: AWSDecodableShape {
        /// A list of resource permissions set on the theme.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the theme.
        public let themeArn: String?
        /// The ID for the theme.
        public let themeId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, themeArn: String? = nil, themeId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.themeArn = themeArn
            self.themeId = themeId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeArn = try container.decodeIfPresent(String.self, forKey: .themeArn)
            self.themeId = try container.decodeIfPresent(String.self, forKey: .themeId)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case themeArn = "ThemeArn"
            case themeId = "ThemeId"
        }
    }

    public struct DescribeThemeRequest: AWSEncodableShape {
        /// The alias of the theme that you want to describe. If you name a specific alias, you
        /// 			describe the version that the alias points to. You can specify the latest version of the
        /// 			theme by providing the keyword $LATEST in the AliasName
        /// 			parameter. The keyword $PUBLISHED doesn't apply to themes.
        public let aliasName: String?
        /// The ID of the Amazon Web Services account that contains the theme that you're describing.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String
        /// The version number for the version to describe. If a VersionNumber parameter
        /// 			value isn't provided, the latest version of the theme is described.
        public let versionNumber: Int64?

        public init(aliasName: String? = nil, awsAccountId: String, themeId: String, versionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aliasName, key: "alias-name")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.themeId, key: "ThemeId")
            request.encodeQuery(self.versionNumber, key: "version-number")
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^(aws|[0-9]{12})$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeThemeResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The information about the theme that you are describing.
        public let theme: Theme?

        public init(requestId: String? = nil, status: Int? = nil, theme: Theme? = nil) {
            self.requestId = requestId
            self.status = status
            self.theme = theme
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.theme = try container.decodeIfPresent(Theme.self, forKey: .theme)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case theme = "Theme"
        }
    }

    public struct DescribeTopicPermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic that you want described.
        public let awsAccountId: String
        /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, topicId: String) {
            self.awsAccountId = awsAccountId
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTopicPermissionsResponse: AWSDecodableShape {
        /// A list of resource permissions that are configured to the topic.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the topic.
        public let topicArn: String?
        /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, topicArn: String? = nil, topicId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.topicArn = topicArn
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicArn = try container.decodeIfPresent(String.self, forKey: .topicArn)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case topicArn = "TopicArn"
            case topicId = "TopicId"
        }
    }

    public struct DescribeTopicRefreshRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic whose refresh you want to describe.
        public let awsAccountId: String
        /// The ID of the refresh, which is performed when the topic is created or updated.
        public let refreshId: String
        /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, refreshId: String, topicId: String) {
            self.awsAccountId = awsAccountId
            self.refreshId = refreshId
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.refreshId, key: "RefreshId")
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTopicRefreshResponse: AWSDecodableShape {
        /// Details of the refresh, which is performed when the topic is created or updated.
        public let refreshDetails: TopicRefreshDetails?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(refreshDetails: TopicRefreshDetails? = nil, requestId: String? = nil, status: Int? = nil) {
            self.refreshDetails = refreshDetails
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.refreshDetails = try container.decodeIfPresent(TopicRefreshDetails.self, forKey: .refreshDetails)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case refreshDetails = "RefreshDetails"
            case requestId = "RequestId"
        }
    }

    public struct DescribeTopicRefreshScheduleRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let datasetId: String
        /// The ID of the topic that contains the refresh schedule that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, datasetId: String, topicId: String) {
            self.awsAccountId = awsAccountId
            self.datasetId = datasetId
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.datasetId, key: "DatasetId")
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTopicRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The definition of a refresh schedule.
        public let refreshSchedule: TopicRefreshSchedule?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the topic.
        public let topicArn: String?
        /// The ID of the topic that contains the refresh schedule that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(datasetArn: String? = nil, refreshSchedule: TopicRefreshSchedule? = nil, requestId: String? = nil, status: Int? = nil, topicArn: String? = nil, topicId: String? = nil) {
            self.datasetArn = datasetArn
            self.refreshSchedule = refreshSchedule
            self.requestId = requestId
            self.status = status
            self.topicArn = topicArn
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.datasetArn = try container.decodeIfPresent(String.self, forKey: .datasetArn)
            self.refreshSchedule = try container.decodeIfPresent(TopicRefreshSchedule.self, forKey: .refreshSchedule)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicArn = try container.decodeIfPresent(String.self, forKey: .topicArn)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case refreshSchedule = "RefreshSchedule"
            case requestId = "RequestId"
            case topicArn = "TopicArn"
            case topicId = "TopicId"
        }
    }

    public struct DescribeTopicRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, topicId: String) {
            self.awsAccountId = awsAccountId
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTopicResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the topic.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The definition of a topic.
        public let topic: TopicDetails?
        /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(arn: String? = nil, requestId: String? = nil, status: Int? = nil, topic: TopicDetails? = nil, topicId: String? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.topic = topic
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topic = try container.decodeIfPresent(TopicDetails.self, forKey: .topic)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case topic = "Topic"
            case topicId = "TopicId"
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The name of the user that you want to describe.
        public let userName: String

        public init(awsAccountId: String, namespace: String, userName: String) {
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.userName, key: "UserName")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The user name.
        public let user: User?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.user = try container.decodeIfPresent(User.self, forKey: .user)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct DescribeVPCConnectionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the account that contains the VPC connection that
        /// 			you want described.
        public let awsAccountId: String
        /// The ID of the VPC connection that
        /// 			you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
        public let vpcConnectionId: String

        public init(awsAccountId: String, vpcConnectionId: String) {
            self.awsAccountId = awsAccountId
            self.vpcConnectionId = vpcConnectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.vpcConnectionId, key: "VPCConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, max: 1000)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVPCConnectionResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A response object that provides information for the specified VPC connection.
        public let vpcConnection: VPCConnection?

        public init(requestId: String? = nil, status: Int? = nil, vpcConnection: VPCConnection? = nil) {
            self.requestId = requestId
            self.status = status
            self.vpcConnection = vpcConnection
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
            case vpcConnection = "VPCConnection"
        }
    }

    public struct DestinationParameterValueConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of custom values for destination parameter in DestinationParameterValueConfiguration.
        public let customValuesConfiguration: CustomValuesConfiguration?
        /// The configuration that selects all options.
        public let selectAllValueOptions: SelectAllValueOptions?
        public let sourceColumn: ColumnIdentifier?
        /// The source field ID of the destination parameter.
        public let sourceField: String?
        /// The source parameter name of the destination parameter.
        public let sourceParameterName: String?

        public init(customValuesConfiguration: CustomValuesConfiguration? = nil, selectAllValueOptions: SelectAllValueOptions? = nil, sourceColumn: ColumnIdentifier? = nil, sourceField: String? = nil, sourceParameterName: String? = nil) {
            self.customValuesConfiguration = customValuesConfiguration
            self.selectAllValueOptions = selectAllValueOptions
            self.sourceColumn = sourceColumn
            self.sourceField = sourceField
            self.sourceParameterName = sourceParameterName
        }

        public func validate(name: String) throws {
            try self.customValuesConfiguration?.validate(name: "\(name).customValuesConfiguration")
            try self.sourceColumn?.validate(name: "\(name).sourceColumn")
            try self.validate(self.sourceField, name: "sourceField", parent: name, max: 512)
            try self.validate(self.sourceField, name: "sourceField", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customValuesConfiguration = "CustomValuesConfiguration"
            case selectAllValueOptions = "SelectAllValueOptions"
            case sourceColumn = "SourceColumn"
            case sourceField = "SourceField"
            case sourceParameterName = "SourceParameterName"
        }
    }

    public struct DimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The dimension type field with categorical type columns.
        public let categoricalDimensionField: CategoricalDimensionField?
        /// The dimension type field with date type columns.
        public let dateDimensionField: DateDimensionField?
        /// The dimension type field with numerical type columns.
        public let numericalDimensionField: NumericalDimensionField?

        public init(categoricalDimensionField: CategoricalDimensionField? = nil, dateDimensionField: DateDimensionField? = nil, numericalDimensionField: NumericalDimensionField? = nil) {
            self.categoricalDimensionField = categoricalDimensionField
            self.dateDimensionField = dateDimensionField
            self.numericalDimensionField = numericalDimensionField
        }

        public func validate(name: String) throws {
            try self.categoricalDimensionField?.validate(name: "\(name).categoricalDimensionField")
            try self.dateDimensionField?.validate(name: "\(name).dateDimensionField")
            try self.numericalDimensionField?.validate(name: "\(name).numericalDimensionField")
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalDimensionField = "CategoricalDimensionField"
            case dateDimensionField = "DateDimensionField"
            case numericalDimensionField = "NumericalDimensionField"
        }
    }

    public struct DisplayFormatOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the blank cell format.
        public let blankCellFormat: String?
        /// The currency symbol, such as USD.
        public let currencySymbol: String?
        /// Determines the DateTime format.
        public let dateFormat: String?
        /// Determines the decimal separator.
        public let decimalSeparator: TopicNumericSeparatorSymbol?
        /// Determines the number of fraction digits.
        public let fractionDigits: Int?
        /// Determines the grouping separator.
        public let groupingSeparator: String?
        /// The negative format.
        public let negativeFormat: NegativeFormat?
        /// The prefix value for a display format.
        public let prefix: String?
        /// The suffix value for a display format.
        public let suffix: String?
        /// The unit scaler. Valid values for this structure are: NONE, AUTO, THOUSANDS, MILLIONS, BILLIONS, and TRILLIONS.
        public let unitScaler: NumberScale?
        /// A Boolean value that indicates whether to use blank cell format.
        public let useBlankCellFormat: Bool?
        /// A Boolean value that indicates whether to use grouping.
        public let useGrouping: Bool?

        public init(blankCellFormat: String? = nil, currencySymbol: String? = nil, dateFormat: String? = nil, decimalSeparator: TopicNumericSeparatorSymbol? = nil, fractionDigits: Int? = nil, groupingSeparator: String? = nil, negativeFormat: NegativeFormat? = nil, prefix: String? = nil, suffix: String? = nil, unitScaler: NumberScale? = nil, useBlankCellFormat: Bool? = nil, useGrouping: Bool? = nil) {
            self.blankCellFormat = blankCellFormat
            self.currencySymbol = currencySymbol
            self.dateFormat = dateFormat
            self.decimalSeparator = decimalSeparator
            self.fractionDigits = fractionDigits
            self.groupingSeparator = groupingSeparator
            self.negativeFormat = negativeFormat
            self.prefix = prefix
            self.suffix = suffix
            self.unitScaler = unitScaler
            self.useBlankCellFormat = useBlankCellFormat
            self.useGrouping = useGrouping
        }

        public func validate(name: String) throws {
            try self.validate(self.blankCellFormat, name: "blankCellFormat", parent: name, max: 256)
            try self.validate(self.currencySymbol, name: "currencySymbol", parent: name, max: 256)
            try self.validate(self.dateFormat, name: "dateFormat", parent: name, max: 256)
            try self.validate(self.groupingSeparator, name: "groupingSeparator", parent: name, max: 256)
            try self.negativeFormat?.validate(name: "\(name).negativeFormat")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 256)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case blankCellFormat = "BlankCellFormat"
            case currencySymbol = "CurrencySymbol"
            case dateFormat = "DateFormat"
            case decimalSeparator = "DecimalSeparator"
            case fractionDigits = "FractionDigits"
            case groupingSeparator = "GroupingSeparator"
            case negativeFormat = "NegativeFormat"
            case prefix = "Prefix"
            case suffix = "Suffix"
            case unitScaler = "UnitScaler"
            case useBlankCellFormat = "UseBlankCellFormat"
            case useGrouping = "UseGrouping"
        }
    }

    public struct DonutCenterOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called 'Show total'.
        public let labelVisibility: Visibility?

        public init(labelVisibility: Visibility? = nil) {
            self.labelVisibility = labelVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case labelVisibility = "LabelVisibility"
        }
    }

    public struct DonutOptions: AWSEncodableShape & AWSDecodableShape {
        /// The option for define the arc of the chart shape. Valid values are as follows:    WHOLE - A pie chart    SMALL- A small-sized donut chart    MEDIUM- A medium-sized donut chart    LARGE- A large-sized donut chart
        public let arcOptions: ArcOptions?
        /// The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.
        public let donutCenterOptions: DonutCenterOptions?

        public init(arcOptions: ArcOptions? = nil, donutCenterOptions: DonutCenterOptions? = nil) {
            self.arcOptions = arcOptions
            self.donutCenterOptions = donutCenterOptions
        }

        private enum CodingKeys: String, CodingKey {
            case arcOptions = "ArcOptions"
            case donutCenterOptions = "DonutCenterOptions"
        }
    }

    public struct DrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// The category type drill down filter. This filter is used for string type columns.
        public let categoryFilter: CategoryDrillDownFilter?
        /// The numeric equality type drill down filter. This filter is used for number type columns.
        public let numericEqualityFilter: NumericEqualityDrillDownFilter?
        /// The time range drill down filter. This filter is used for date time columns.
        public let timeRangeFilter: TimeRangeDrillDownFilter?

        public init(categoryFilter: CategoryDrillDownFilter? = nil, numericEqualityFilter: NumericEqualityDrillDownFilter? = nil, timeRangeFilter: TimeRangeDrillDownFilter? = nil) {
            self.categoryFilter = categoryFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.timeRangeFilter = timeRangeFilter
        }

        public func validate(name: String) throws {
            try self.categoryFilter?.validate(name: "\(name).categoryFilter")
            try self.numericEqualityFilter?.validate(name: "\(name).numericEqualityFilter")
            try self.timeRangeFilter?.validate(name: "\(name).timeRangeFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryFilter = "CategoryFilter"
            case numericEqualityFilter = "NumericEqualityFilter"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct DropDownControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of info icon label options.
        public let infoIconLabelOptions: SheetControlInfoIconLabelOptions?
        /// The configuration of the Select all options in a dropdown control.
        public let selectAllOptions: ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(infoIconLabelOptions: SheetControlInfoIconLabelOptions? = nil, selectAllOptions: ListControlSelectAllOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.infoIconLabelOptions?.validate(name: "\(name).infoIconLabelOptions")
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case infoIconLabelOptions = "InfoIconLabelOptions"
            case selectAllOptions = "SelectAllOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct DynamicDefaultValue: AWSEncodableShape & AWSDecodableShape {
        /// The column that contains the default value of each user or group.
        public let defaultValueColumn: ColumnIdentifier
        /// The column that contains the group name.
        public let groupNameColumn: ColumnIdentifier?
        /// The column that contains the username.
        public let userNameColumn: ColumnIdentifier?

        public init(defaultValueColumn: ColumnIdentifier, groupNameColumn: ColumnIdentifier? = nil, userNameColumn: ColumnIdentifier? = nil) {
            self.defaultValueColumn = defaultValueColumn
            self.groupNameColumn = groupNameColumn
            self.userNameColumn = userNameColumn
        }

        public func validate(name: String) throws {
            try self.defaultValueColumn.validate(name: "\(name).defaultValueColumn")
            try self.groupNameColumn?.validate(name: "\(name).groupNameColumn")
            try self.userNameColumn?.validate(name: "\(name).userNameColumn")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValueColumn = "DefaultValueColumn"
            case groupNameColumn = "GroupNameColumn"
            case userNameColumn = "UserNameColumn"
        }
    }

    public struct EmptyVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The data set that is used in the empty visual. Every visual requires a dataset to render.
        public let dataSetIdentifier: String
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, dataSetIdentifier: String, visualId: String) {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case dataSetIdentifier = "DataSetIdentifier"
            case visualId = "VisualId"
        }
    }

    public struct Entity: AWSDecodableShape {
        /// The hierarchical path of the entity within the analysis, template, or dashboard definition tree.
        public let path: String?

        public init(path: String? = nil) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// Error message.
        public let message: String?
        /// Error type.
        public let type: IngestionErrorType?

        public init(message: String? = nil, type: IngestionErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ExasolParameters: AWSEncodableShape & AWSDecodableShape {
        /// The hostname or IP address of the Exasol data source.
        public let host: String
        /// The port for the Exasol data source.
        public let port: Int

        public init(host: String, port: Int) {
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case port = "Port"
        }
    }

    public struct ExcludePeriodConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The amount or number of the exclude period.
        public let amount: Int
        /// The granularity or unit (day, month, year) of the exclude period.
        public let granularity: TimeGranularity
        /// The status of the exclude period. Choose from the following options:    ENABLED     DISABLED
        public let status: WidgetStatus?

        public init(amount: Int, granularity: TimeGranularity, status: WidgetStatus? = nil) {
            self.amount = amount
            self.granularity = granularity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "Amount"
            case granularity = "Granularity"
            case status = "Status"
        }
    }

    public struct ExplicitHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The list of columns that define the explicit hierarchy.
        public let columns: [ColumnIdentifier]
        /// The option that determines the drill down filters for the explicit hierarchy.
        public let drillDownFilters: [DrillDownFilter]?
        /// The hierarchy ID of the explicit hierarchy.
        public let hierarchyId: String

        public init(columns: [ColumnIdentifier], drillDownFilters: [DrillDownFilter]? = nil, hierarchyId: String) {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 10)
            try self.validate(self.columns, name: "columns", parent: name, min: 2)
            try self.drillDownFilters?.forEach {
                try $0.validate(name: "\(name).drillDownFilters[]")
            }
            try self.validate(self.drillDownFilters, name: "drillDownFilters", parent: name, max: 10)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case drillDownFilters = "DrillDownFilters"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct ExportHiddenFieldsOption: AWSEncodableShape & AWSDecodableShape {
        /// The status of the export hidden fields options of a dashbaord.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct ExportToCSVOption: AWSEncodableShape & AWSDecodableShape {
        /// Availability status.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct ExportWithHiddenFieldsOption: AWSEncodableShape & AWSDecodableShape {
        /// The status of the export with hidden fields options.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct FieldBasedTooltip: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of Show aggregations.
        public let aggregationVisibility: Visibility?
        /// The fields configuration in the tooltip.
        public let tooltipFields: [TooltipItem]?
        /// The type for the >tooltip title. Choose one of the following options:    NONE: Doesn't use the primary value as the title.    PRIMARY_VALUE: Uses primary value as the title.
        public let tooltipTitleType: TooltipTitleType?

        public init(aggregationVisibility: Visibility? = nil, tooltipFields: [TooltipItem]? = nil, tooltipTitleType: TooltipTitleType? = nil) {
            self.aggregationVisibility = aggregationVisibility
            self.tooltipFields = tooltipFields
            self.tooltipTitleType = tooltipTitleType
        }

        public func validate(name: String) throws {
            try self.tooltipFields?.forEach {
                try $0.validate(name: "\(name).tooltipFields[]")
            }
            try self.validate(self.tooltipFields, name: "tooltipFields", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationVisibility = "AggregationVisibility"
            case tooltipFields = "TooltipFields"
            case tooltipTitleType = "TooltipTitleType"
        }
    }

    public struct FieldFolder: AWSEncodableShape & AWSDecodableShape {
        /// A folder has a list of columns. A column can only be in one folder.
        public let columns: [String]?
        /// The description for a field folder.
        public let description: String?

        public init(columns: [String]? = nil, description: String? = nil) {
            self.columns = columns
            self.description = description
        }

        public func validate(name: String) throws {
            try self.validate(self.columns, name: "columns", parent: name, max: 5000)
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "columns"
            case description = "description"
        }
    }

    public struct FieldLabelType: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the field that is targeted by the field label.
        public let fieldId: String?
        /// The visibility of the field label.
        public let visibility: Visibility?

        public init(fieldId: String? = nil, visibility: Visibility? = nil) {
            self.fieldId = fieldId
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case visibility = "Visibility"
        }
    }

    public struct FieldSeriesItem: AWSEncodableShape & AWSDecodableShape {
        /// The axis that you are binding the field to.
        public let axisBinding: AxisBinding
        /// The field ID of the field for which you are setting the axis binding.
        public let fieldId: String
        /// The options that determine the presentation of line series associated to the field.
        public let settings: LineChartSeriesSettings?

        public init(axisBinding: AxisBinding, fieldId: String, settings: LineChartSeriesSettings? = nil) {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.settings = settings
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.settings?.validate(name: "\(name).settings")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case fieldId = "FieldId"
            case settings = "Settings"
        }
    }

    public struct FieldSort: AWSEncodableShape & AWSDecodableShape {
        /// The sort direction. Choose one of the following options:    ASC: Ascending    DESC: Descending
        public let direction: SortDirection
        /// The sort configuration target field.
        public let fieldId: String

        public init(direction: SortDirection, fieldId: String) {
            self.direction = direction
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "Direction"
            case fieldId = "FieldId"
        }
    }

    public struct FieldSortOptions: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration for a column that is not used in a field well.
        public let columnSort: ColumnSort?
        /// The sort configuration for a field in a field well.
        public let fieldSort: FieldSort?

        public init(columnSort: ColumnSort? = nil, fieldSort: FieldSort? = nil) {
            self.columnSort = columnSort
            self.fieldSort = fieldSort
        }

        public func validate(name: String) throws {
            try self.columnSort?.validate(name: "\(name).columnSort")
            try self.fieldSort?.validate(name: "\(name).fieldSort")
        }

        private enum CodingKeys: String, CodingKey {
            case columnSort = "ColumnSort"
            case fieldSort = "FieldSort"
        }
    }

    public struct FieldTooltipItem: AWSEncodableShape & AWSDecodableShape {
        /// The unique ID of the field that is targeted by the tooltip.
        public let fieldId: String
        /// The label of the tooltip item.
        public let label: String?
        /// Determines the target of the field tooltip item in a combo chart visual.
        public let tooltipTarget: TooltipTarget?
        /// The visibility of the tooltip item.
        public let visibility: Visibility?

        public init(fieldId: String, label: String? = nil, tooltipTarget: TooltipTarget? = nil, visibility: Visibility? = nil) {
            self.fieldId = fieldId
            self.label = label
            self.tooltipTarget = tooltipTarget
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case label = "Label"
            case tooltipTarget = "TooltipTarget"
            case visibility = "Visibility"
        }
    }

    public struct FilledMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated location field well of the filled map. Values are grouped by location fields.
        public let geospatial: [DimensionField]?
        /// The aggregated color field well of a filled map. Values are aggregated based on location fields.
        public let values: [MeasureField]?

        public init(geospatial: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.geospatial = geospatial
            self.values = values
        }

        public func validate(name: String) throws {
            try self.geospatial?.forEach {
                try $0.validate(name: "\(name).geospatial[]")
            }
            try self.validate(self.geospatial, name: "geospatial", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case geospatial = "Geospatial"
            case values = "Values"
        }
    }

    public struct FilledMapConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options of a FilledMapVisual.
        public let conditionalFormattingOptions: [FilledMapConditionalFormattingOption]

        public init(conditionalFormattingOptions: [FilledMapConditionalFormattingOption]) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct FilledMapConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting that determines the shape of the filled map.
        public let shape: FilledMapShapeConditionalFormatting

        public init(shape: FilledMapShapeConditionalFormatting) {
            self.shape = shape
        }

        public func validate(name: String) throws {
            try self.shape.validate(name: "\(name).shape")
        }

        private enum CodingKeys: String, CodingKey {
            case shape = "Shape"
        }
    }

    public struct FilledMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field wells of the visual.
        public let fieldWells: FilledMapFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The map style options of the filled map visual.
        public let mapStyleOptions: GeospatialMapStyleOptions?
        /// The sort configuration of a FilledMapVisual.
        public let sortConfiguration: FilledMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The window options of the filled map visual.
        public let windowOptions: GeospatialWindowOptions?

        public init(fieldWells: FilledMapFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, mapStyleOptions: GeospatialMapStyleOptions? = nil, sortConfiguration: FilledMapSortConfiguration? = nil, tooltip: TooltipOptions? = nil, windowOptions: GeospatialWindowOptions? = nil) {
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.windowOptions = windowOptions
        }

        public func validate(name: String) throws {
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.windowOptions?.validate(name: "\(name).windowOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case mapStyleOptions = "MapStyleOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case windowOptions = "WindowOptions"
        }
    }

    public struct FilledMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well of the filled map.
        public let filledMapAggregatedFieldWells: FilledMapAggregatedFieldWells?

        public init(filledMapAggregatedFieldWells: FilledMapAggregatedFieldWells? = nil) {
            self.filledMapAggregatedFieldWells = filledMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.filledMapAggregatedFieldWells?.validate(name: "\(name).filledMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case filledMapAggregatedFieldWells = "FilledMapAggregatedFieldWells"
        }
    }

    public struct FilledMapShapeConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the filled map shape.
        public let fieldId: String
        /// The conditional formatting that determines the background color of a filled map's shape.
        public let format: ShapeConditionalFormat?

        public init(fieldId: String, format: ShapeConditionalFormat? = nil) {
            self.fieldId = fieldId
            self.format = format
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.format?.validate(name: "\(name).format")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case format = "Format"
        }
    }

    public struct FilledMapSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration of the location fields.
        public let categorySort: [FieldSortOptions]?

        public init(categorySort: [FieldSortOptions]? = nil) {
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categorySort = "CategorySort"
        }
    }

    public struct FilledMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: FilledMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The conditional formatting of a FilledMapVisual.
        public let conditionalFormatting: FilledMapConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: FilledMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, conditionalFormatting: FilledMapConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        /// A CategoryFilter filters text values. For more information, see Adding text filters in the Amazon QuickSight User Guide.
        public let categoryFilter: CategoryFilter?
        /// A NumericEqualityFilter filters numeric values that equal or do not equal a given numeric value.
        public let numericEqualityFilter: NumericEqualityFilter?
        /// A NumericRangeFilter filters numeric values that are either inside or outside a given numeric range.
        public let numericRangeFilter: NumericRangeFilter?
        /// A RelativeDatesFilter filters date values that are relative to a given date.
        public let relativeDatesFilter: RelativeDatesFilter?
        /// A TimeEqualityFilter filters date-time values that equal or do not equal a given date/time value.
        public let timeEqualityFilter: TimeEqualityFilter?
        /// A TimeRangeFilter filters date-time values that are either inside or outside a given date/time range.
        public let timeRangeFilter: TimeRangeFilter?
        /// A TopBottomFilter filters data to the top or bottom values for a given column.
        public let topBottomFilter: TopBottomFilter?

        public init(categoryFilter: CategoryFilter? = nil, numericEqualityFilter: NumericEqualityFilter? = nil, numericRangeFilter: NumericRangeFilter? = nil, relativeDatesFilter: RelativeDatesFilter? = nil, timeEqualityFilter: TimeEqualityFilter? = nil, timeRangeFilter: TimeRangeFilter? = nil, topBottomFilter: TopBottomFilter? = nil) {
            self.categoryFilter = categoryFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.numericRangeFilter = numericRangeFilter
            self.relativeDatesFilter = relativeDatesFilter
            self.timeEqualityFilter = timeEqualityFilter
            self.timeRangeFilter = timeRangeFilter
            self.topBottomFilter = topBottomFilter
        }

        public func validate(name: String) throws {
            try self.categoryFilter?.validate(name: "\(name).categoryFilter")
            try self.numericEqualityFilter?.validate(name: "\(name).numericEqualityFilter")
            try self.numericRangeFilter?.validate(name: "\(name).numericRangeFilter")
            try self.relativeDatesFilter?.validate(name: "\(name).relativeDatesFilter")
            try self.timeEqualityFilter?.validate(name: "\(name).timeEqualityFilter")
            try self.timeRangeFilter?.validate(name: "\(name).timeRangeFilter")
            try self.topBottomFilter?.validate(name: "\(name).topBottomFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryFilter = "CategoryFilter"
            case numericEqualityFilter = "NumericEqualityFilter"
            case numericRangeFilter = "NumericRangeFilter"
            case relativeDatesFilter = "RelativeDatesFilter"
            case timeEqualityFilter = "TimeEqualityFilter"
            case timeRangeFilter = "TimeRangeFilter"
            case topBottomFilter = "TopBottomFilter"
        }
    }

    public struct FilterControl: AWSEncodableShape & AWSDecodableShape {
        /// A control from a date filter that is used to specify date and time.
        public let dateTimePicker: FilterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public let dropdown: FilterDropDownControl?
        /// A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.
        public let list: FilterListControl?
        /// A control from a date filter that is used to specify the relative date.
        public let relativeDateTime: FilterRelativeDateTimeControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public let slider: FilterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public let textArea: FilterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public let textField: FilterTextFieldControl?

        public init(dateTimePicker: FilterDateTimePickerControl? = nil, dropdown: FilterDropDownControl? = nil, list: FilterListControl? = nil, relativeDateTime: FilterRelativeDateTimeControl? = nil, slider: FilterSliderControl? = nil, textArea: FilterTextAreaControl? = nil, textField: FilterTextFieldControl? = nil) {
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.relativeDateTime = relativeDateTime
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.dateTimePicker?.validate(name: "\(name).dateTimePicker")
            try self.dropdown?.validate(name: "\(name).dropdown")
            try self.list?.validate(name: "\(name).list")
            try self.relativeDateTime?.validate(name: "\(name).relativeDateTime")
            try self.slider?.validate(name: "\(name).slider")
            try self.textArea?.validate(name: "\(name).textArea")
            try self.textField?.validate(name: "\(name).textField")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimePicker = "DateTimePicker"
            case dropdown = "Dropdown"
            case list = "List"
            case relativeDateTime = "RelativeDateTime"
            case slider = "Slider"
            case textArea = "TextArea"
            case textField = "TextField"
        }
    }

    public struct FilterDateTimePickerControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: DateTimePickerControlDisplayOptions?
        /// The ID of the FilterDateTimePickerControl.
        public let filterControlId: String
        /// The source filter ID of the FilterDateTimePickerControl.
        public let sourceFilterId: String
        /// The title of the FilterDateTimePickerControl.
        public let title: String
        /// The date time picker type of a FilterDateTimePickerControl. Choose one of the following options:    SINGLE_VALUED: The filter condition is a fixed date.    DATE_RANGE: The filter condition is a date time range.
        public let type: SheetControlDateTimePickerType?

        public init(displayOptions: DateTimePickerControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String, type: SheetControlDateTimePickerType? = nil) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterDropDownControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of the FilterDropDownControl.
        public let displayOptions: DropDownControlDisplayOptions?
        /// The ID of the FilterDropDownControl.
        public let filterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: FilterSelectableValues?
        /// The source filter ID of the FilterDropDownControl.
        public let sourceFilterId: String
        /// The title of the FilterDropDownControl.
        public let title: String
        /// The type of the FilterDropDownControl. Choose one of the following options:    MULTI_SELECT: The user can select multiple entries from a dropdown menu.    SINGLE_SELECT: The user can select a single entry from a dropdown menu.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: DropDownControlDisplayOptions? = nil, filterControlId: String, selectableValues: FilterSelectableValues? = nil, sourceFilterId: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case selectableValues = "SelectableValues"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterGroup: AWSEncodableShape & AWSDecodableShape {
        /// The filter new feature which can apply filter group to all data sets. Choose one of the following options:    ALL_DATASETS     SINGLE_DATASET
        public let crossDataset: CrossDatasetTypes
        /// The value that uniquely identifies a FilterGroup within a dashboard, template, or analysis.
        public let filterGroupId: String
        /// The list of filters that are present in a FilterGroup.
        public let filters: [Filter]
        /// The configuration that specifies what scope to apply to a FilterGroup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        public let scopeConfiguration: FilterScopeConfiguration
        /// The status of the FilterGroup.
        public let status: WidgetStatus?

        public init(crossDataset: CrossDatasetTypes, filterGroupId: String, filters: [Filter], scopeConfiguration: FilterScopeConfiguration, status: WidgetStatus? = nil) {
            self.crossDataset = crossDataset
            self.filterGroupId = filterGroupId
            self.filters = filters
            self.scopeConfiguration = scopeConfiguration
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.filterGroupId, name: "filterGroupId", parent: name, max: 512)
            try self.validate(self.filterGroupId, name: "filterGroupId", parent: name, min: 1)
            try self.validate(self.filterGroupId, name: "filterGroupId", parent: name, pattern: "^[\\w\\-]+$")
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.scopeConfiguration.validate(name: "\(name).scopeConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case crossDataset = "CrossDataset"
            case filterGroupId = "FilterGroupId"
            case filters = "Filters"
            case scopeConfiguration = "ScopeConfiguration"
            case status = "Status"
        }
    }

    public struct FilterListConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The list of category values for the filter.
        public let categoryValues: [String]?
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: CategoryFilterMatchOperator
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption?
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: CategoryFilterSelectAllOptions?

        public init(categoryValues: [String]? = nil, matchOperator: CategoryFilterMatchOperator, nullOption: FilterNullOption? = nil, selectAllOptions: CategoryFilterSelectAllOptions? = nil) {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.categoryValues?.forEach {
                try validate($0, name: "categoryValues[]", parent: name, max: 512)
            }
            try self.validate(self.categoryValues, name: "categoryValues", parent: name, max: 100000)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryValues = "CategoryValues"
            case matchOperator = "MatchOperator"
            case nullOption = "NullOption"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct FilterListControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of a control.
        public let displayOptions: ListControlDisplayOptions?
        /// The ID of the FilterListControl.
        public let filterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: FilterSelectableValues?
        /// The source filter ID of the FilterListControl.
        public let sourceFilterId: String
        /// The title of the FilterListControl.
        public let title: String
        /// The type of FilterListControl. Choose one of the following options:    MULTI_SELECT: The user can select multiple entries from the list.    SINGLE_SELECT: The user can select a single entry from the list.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: ListControlDisplayOptions? = nil, filterControlId: String, selectableValues: FilterSelectableValues? = nil, sourceFilterId: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case selectableValues = "SelectableValues"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterOperation: AWSEncodableShape & AWSDecodableShape {
        /// An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        public let conditionExpression: String

        public init(conditionExpression: String) {
            self.conditionExpression = conditionExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, max: 4096)
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionExpression = "ConditionExpression"
        }
    }

    public struct FilterOperationSelectedFieldsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The selected columns of a dataset.
        public let selectedColumns: [ColumnIdentifier]?
        /// A structure that contains the options that choose which fields are filtered in the CustomActionFilterOperation. Valid values are defined as follows:    ALL_FIELDS: Applies the filter operation to all fields.
        public let selectedFieldOptions: SelectedFieldOptions?
        /// Chooses the fields that are filtered in CustomActionFilterOperation.
        public let selectedFields: [String]?

        public init(selectedColumns: [ColumnIdentifier]? = nil, selectedFieldOptions: SelectedFieldOptions? = nil, selectedFields: [String]? = nil) {
            self.selectedColumns = selectedColumns
            self.selectedFieldOptions = selectedFieldOptions
            self.selectedFields = selectedFields
        }

        public func validate(name: String) throws {
            try self.selectedColumns?.forEach {
                try $0.validate(name: "\(name).selectedColumns[]")
            }
            try self.validate(self.selectedColumns, name: "selectedColumns", parent: name, max: 10)
            try self.selectedFields?.forEach {
                try validate($0, name: "selectedFields[]", parent: name, max: 512)
                try validate($0, name: "selectedFields[]", parent: name, min: 1)
            }
            try self.validate(self.selectedFields, name: "selectedFields", parent: name, max: 20)
            try self.validate(self.selectedFields, name: "selectedFields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case selectedColumns = "SelectedColumns"
            case selectedFieldOptions = "SelectedFieldOptions"
            case selectedFields = "SelectedFields"
        }
    }

    public struct FilterOperationTargetVisualsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the same-sheet target visuals that you want to be filtered.
        public let sameSheetTargetVisualConfiguration: SameSheetTargetVisualConfiguration?

        public init(sameSheetTargetVisualConfiguration: SameSheetTargetVisualConfiguration? = nil) {
            self.sameSheetTargetVisualConfiguration = sameSheetTargetVisualConfiguration
        }

        public func validate(name: String) throws {
            try self.sameSheetTargetVisualConfiguration?.validate(name: "\(name).sameSheetTargetVisualConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case sameSheetTargetVisualConfiguration = "SameSheetTargetVisualConfiguration"
        }
    }

    public struct FilterRelativeDateTimeControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: RelativeDateTimeControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        public let filterControlId: String
        /// The source filter ID of the FilterTextAreaControl.
        public let sourceFilterId: String
        /// The title of the FilterTextAreaControl.
        public let title: String

        public init(displayOptions: RelativeDateTimeControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
        }
    }

    public struct FilterScopeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that applies a filter to all sheets. When you choose AllSheets as the value for a FilterScopeConfiguration, this filter is applied to all visuals of all sheets in an Analysis, Dashboard, or Template. The AllSheetsFilterScopeConfiguration is chosen.
        public let allSheets: AllSheetsFilterScopeConfiguration?
        /// The configuration for applying a filter to specific sheets.
        public let selectedSheets: SelectedSheetsFilterScopeConfiguration?

        public init(allSheets: AllSheetsFilterScopeConfiguration? = nil, selectedSheets: SelectedSheetsFilterScopeConfiguration? = nil) {
            self.allSheets = allSheets
            self.selectedSheets = selectedSheets
        }

        public func validate(name: String) throws {
            try self.selectedSheets?.validate(name: "\(name).selectedSheets")
        }

        private enum CodingKeys: String, CodingKey {
            case allSheets = "AllSheets"
            case selectedSheets = "SelectedSheets"
        }
    }

    public struct FilterSelectableValues: AWSEncodableShape & AWSDecodableShape {
        /// The values that are used in the FilterSelectableValues.
        public let values: [String]?

        public init(values: [String]? = nil) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.values, name: "values", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct FilterSliderControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: SliderControlDisplayOptions?
        /// The ID of the FilterSliderControl.
        public let filterControlId: String
        /// The smaller value that is displayed at the left of the slider.
        public let maximumValue: Double
        /// The larger value that is displayed at the right of the slider.
        public let minimumValue: Double
        /// The source filter ID of the FilterSliderControl.
        public let sourceFilterId: String
        /// The number of increments that the slider bar is divided into.
        public let stepSize: Double
        /// The title of the FilterSliderControl.
        public let title: String
        /// The type of FilterSliderControl. Choose one of the following options:    SINGLE_POINT: Filter against(equals) a single data point.    RANGE: Filter data that is in a specified range.
        public let type: SheetControlSliderType?

        public init(displayOptions: SliderControlDisplayOptions? = nil, filterControlId: String, maximumValue: Double, minimumValue: Double, sourceFilterId: String, stepSize: Double, title: String, type: SheetControlSliderType? = nil) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.sourceFilterId = sourceFilterId
            self.stepSize = stepSize
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case sourceFilterId = "SourceFilterId"
            case stepSize = "StepSize"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct FilterTextAreaControl: AWSEncodableShape & AWSDecodableShape {
        /// The delimiter that is used to separate the lines in text.
        public let delimiter: String?
        /// The display options of a control.
        public let displayOptions: TextAreaControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        public let filterControlId: String
        /// The source filter ID of the FilterTextAreaControl.
        public let sourceFilterId: String
        /// The title of the FilterTextAreaControl.
        public let title: String

        public init(delimiter: String? = nil, displayOptions: TextAreaControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String) {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 2048)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
        }
    }

    public struct FilterTextFieldControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: TextFieldControlDisplayOptions?
        /// The ID of the FilterTextFieldControl.
        public let filterControlId: String
        /// The source filter ID of the FilterTextFieldControl.
        public let sourceFilterId: String
        /// The title of the FilterTextFieldControl.
        public let title: String

        public init(displayOptions: TextFieldControlDisplayOptions? = nil, filterControlId: String, sourceFilterId: String, title: String) {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, max: 512)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, min: 1)
            try self.validate(self.filterControlId, name: "filterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, max: 512)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, min: 1)
            try self.validate(self.sourceFilterId, name: "sourceFilterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case filterControlId = "FilterControlId"
            case sourceFilterId = "SourceFilterId"
            case title = "Title"
        }
    }

    public struct Folder: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the folder.
        public let arn: String?
        /// The time that the folder was created.
        public let createdTime: Date?
        /// The ID of the folder.
        public let folderId: String?
        /// An array of ancestor ARN strings for the folder.
        public let folderPath: [String]?
        /// The type of folder it is.
        public let folderType: FolderType?
        /// The time that the folder was last updated.
        public let lastUpdatedTime: Date?
        /// A display name for the folder.
        public let name: String?
        /// The sharing scope of the folder.
        public let sharingModel: SharingModel?

        public init(arn: String? = nil, createdTime: Date? = nil, folderId: String? = nil, folderPath: [String]? = nil, folderType: FolderType? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, sharingModel: SharingModel? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderPath = folderPath
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sharingModel = sharingModel
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case folderId = "FolderId"
            case folderPath = "FolderPath"
            case folderType = "FolderType"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case sharingModel = "SharingModel"
        }
    }

    public struct FolderMember: AWSDecodableShape {
        /// The ID of an asset in the folder.
        public let memberId: String?
        /// The type of asset that it is.
        public let memberType: MemberType?

        public init(memberId: String? = nil, memberType: MemberType? = nil) {
            self.memberId = memberId
            self.memberType = memberType
        }

        private enum CodingKeys: String, CodingKey {
            case memberId = "MemberId"
            case memberType = "MemberType"
        }
    }

    public struct FolderSearchFilter: AWSEncodableShape {
        /// The name of a value that you want to use in the filter. For example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:    QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.    QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.    DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.    DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered.     FOLDER_NAME: Any folders whose names have a substring match to this value will be returned.    PARENT_FOLDER_ARN: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned.
        public let name: FolderFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example  "Operator": "StringEquals". Valid values are  "StringEquals"  and  "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example,  "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value FOLDER_NAME.
        public let `operator`: FilterOperator?
        /// The value of the named item (in this example, PARENT_FOLDER_ARN), that you want to use as a filter. For example, "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId".
        public let value: String?

        public init(name: FolderFilterAttribute? = nil, operator: FilterOperator? = nil, value: String? = nil) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct FolderSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The time that the folder was created.
        public let createdTime: Date?
        /// The ID of the folder.
        public let folderId: String?
        /// The type of folder.
        public let folderType: FolderType?
        /// The time that the folder was last updated.
        public let lastUpdatedTime: Date?
        /// The display name of the folder.
        public let name: String?
        /// The sharing scope of the folder.
        public let sharingModel: SharingModel?

        public init(arn: String? = nil, createdTime: Date? = nil, folderId: String? = nil, folderType: FolderType? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, sharingModel: SharingModel? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sharingModel = sharingModel
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case folderId = "FolderId"
            case folderType = "FolderType"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case sharingModel = "SharingModel"
        }
    }

    public struct Font: AWSEncodableShape & AWSDecodableShape {
        /// Determines the font family settings.
        public let fontFamily: String?

        public init(fontFamily: String? = nil) {
            self.fontFamily = fontFamily
        }

        private enum CodingKeys: String, CodingKey {
            case fontFamily = "FontFamily"
        }
    }

    public struct FontConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color of the text.
        public let fontColor: String?
        /// Determines the appearance of decorative lines on the text.
        public let fontDecoration: FontDecoration?
        /// The option that determines the text display size.
        public let fontSize: FontSize?
        /// Determines the text display face that is inherited by the given font family.
        public let fontStyle: FontStyle?
        /// The option that determines the text display weight, or boldness.
        public let fontWeight: FontWeight?

        public init(fontColor: String? = nil, fontDecoration: FontDecoration? = nil, fontSize: FontSize? = nil, fontStyle: FontStyle? = nil, fontWeight: FontWeight? = nil) {
            self.fontColor = fontColor
            self.fontDecoration = fontDecoration
            self.fontSize = fontSize
            self.fontStyle = fontStyle
            self.fontWeight = fontWeight
        }

        public func validate(name: String) throws {
            try self.validate(self.fontColor, name: "fontColor", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fontColor = "FontColor"
            case fontDecoration = "FontDecoration"
            case fontSize = "FontSize"
            case fontStyle = "FontStyle"
            case fontWeight = "FontWeight"
        }
    }

    public struct FontSize: AWSEncodableShape & AWSDecodableShape {
        /// The lexical name for the text size, proportional to its surrounding context.
        public let relative: RelativeFontSize?

        public init(relative: RelativeFontSize? = nil) {
            self.relative = relative
        }

        private enum CodingKeys: String, CodingKey {
            case relative = "Relative"
        }
    }

    public struct FontWeight: AWSEncodableShape & AWSDecodableShape {
        /// The lexical name for the level of boldness of the text display.
        public let name: FontWeightName?

        public init(name: FontWeightName? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ForecastComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The custom seasonality value setup of a forecast computation.
        public let customSeasonalityValue: Int?
        /// The lower boundary setup of a forecast computation.
        public let lowerBoundary: Double?
        /// The name of a computation.
        public let name: String?
        /// The periods backward setup of a forecast computation.
        public let periodsBackward: Int?
        /// The periods forward setup of a forecast computation.
        public let periodsForward: Int?
        /// The prediction interval setup of a forecast computation.
        public let predictionInterval: Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:    AUTOMATIC     CUSTOM: Checks the custom seasonality value.
        public let seasonality: ForecastComputationSeasonality?
        /// The time field that is used in a computation.
        public let time: DimensionField?
        /// The upper boundary setup of a forecast computation.
        public let upperBoundary: Double?
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, customSeasonalityValue: Int? = nil, lowerBoundary: Double? = nil, name: String? = nil, periodsBackward: Int? = nil, periodsForward: Int? = nil, predictionInterval: Int? = nil, seasonality: ForecastComputationSeasonality? = nil, time: DimensionField? = nil, upperBoundary: Double? = nil, value: MeasureField? = nil) {
            self.computationId = computationId
            self.customSeasonalityValue = customSeasonalityValue
            self.lowerBoundary = lowerBoundary
            self.name = name
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.time = time
            self.upperBoundary = upperBoundary
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.customSeasonalityValue, name: "customSeasonalityValue", parent: name, max: 180)
            try self.validate(self.customSeasonalityValue, name: "customSeasonalityValue", parent: name, min: 1)
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, max: 1000)
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, min: 0)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, max: 1000)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, min: 1)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, max: 95)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, min: 50)
            try self.time?.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case customSeasonalityValue = "CustomSeasonalityValue"
            case lowerBoundary = "LowerBoundary"
            case name = "Name"
            case periodsBackward = "PeriodsBackward"
            case periodsForward = "PeriodsForward"
            case predictionInterval = "PredictionInterval"
            case seasonality = "Seasonality"
            case time = "Time"
            case upperBoundary = "UpperBoundary"
            case value = "Value"
        }
    }

    public struct ForecastConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The forecast properties setup of a forecast in the line chart.
        public let forecastProperties: TimeBasedForecastProperties?
        /// The forecast scenario of a forecast in the line chart.
        public let scenario: ForecastScenario?

        public init(forecastProperties: TimeBasedForecastProperties? = nil, scenario: ForecastScenario? = nil) {
            self.forecastProperties = forecastProperties
            self.scenario = scenario
        }

        public func validate(name: String) throws {
            try self.forecastProperties?.validate(name: "\(name).forecastProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastProperties = "ForecastProperties"
            case scenario = "Scenario"
        }
    }

    public struct ForecastScenario: AWSEncodableShape & AWSDecodableShape {
        /// The what-if analysis forecast setup with the target date.
        public let whatIfPointScenario: WhatIfPointScenario?
        /// The what-if analysis forecast setup with the date range.
        public let whatIfRangeScenario: WhatIfRangeScenario?

        public init(whatIfPointScenario: WhatIfPointScenario? = nil, whatIfRangeScenario: WhatIfRangeScenario? = nil) {
            self.whatIfPointScenario = whatIfPointScenario
            self.whatIfRangeScenario = whatIfRangeScenario
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfPointScenario = "WhatIfPointScenario"
            case whatIfRangeScenario = "WhatIfRangeScenario"
        }
    }

    public struct FormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Formatting configuration for DateTime fields.
        public let dateTimeFormatConfiguration: DateTimeFormatConfiguration?
        /// Formatting configuration for number fields.
        public let numberFormatConfiguration: NumberFormatConfiguration?
        /// Formatting configuration for string fields.
        public let stringFormatConfiguration: StringFormatConfiguration?

        public init(dateTimeFormatConfiguration: DateTimeFormatConfiguration? = nil, numberFormatConfiguration: NumberFormatConfiguration? = nil, stringFormatConfiguration: StringFormatConfiguration? = nil) {
            self.dateTimeFormatConfiguration = dateTimeFormatConfiguration
            self.numberFormatConfiguration = numberFormatConfiguration
            self.stringFormatConfiguration = stringFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.dateTimeFormatConfiguration?.validate(name: "\(name).dateTimeFormatConfiguration")
            try self.numberFormatConfiguration?.validate(name: "\(name).numberFormatConfiguration")
            try self.stringFormatConfiguration?.validate(name: "\(name).stringFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormatConfiguration = "DateTimeFormatConfiguration"
            case numberFormatConfiguration = "NumberFormatConfiguration"
            case stringFormatConfiguration = "StringFormatConfiguration"
        }
    }

    public struct FreeFormLayoutCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the sizing of the canvas used in a free-form layout.
        public let screenCanvasSizeOptions: FreeFormLayoutScreenCanvasSizeOptions?

        public init(screenCanvasSizeOptions: FreeFormLayoutScreenCanvasSizeOptions? = nil) {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case screenCanvasSizeOptions = "ScreenCanvasSizeOptions"
        }
    }

    public struct FreeFormLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let canvasSizeOptions: FreeFormLayoutCanvasSizeOptions?
        /// The elements that are included in a free-form layout.
        public let elements: [FreeFormLayoutElement]

        public init(canvasSizeOptions: FreeFormLayoutCanvasSizeOptions? = nil, elements: [FreeFormLayoutElement]) {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }

        public func validate(name: String) throws {
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 430)
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
            case elements = "Elements"
        }
    }

    public struct FreeFormLayoutElement: AWSEncodableShape & AWSDecodableShape {
        /// The background style configuration of a free-form layout element.
        public let backgroundStyle: FreeFormLayoutElementBackgroundStyle?
        /// The border style configuration of a free-form layout element.
        public let borderStyle: FreeFormLayoutElementBorderStyle?
        /// A unique identifier for an element within a free-form layout.
        public let elementId: String
        /// The type of element.
        public let elementType: LayoutElementType
        /// The height of an element within a free-form layout.
        public let height: String
        /// The loading animation configuration of a free-form layout element.
        public let loadingAnimation: LoadingAnimation?
        /// The rendering rules that determine when an element should be displayed within a free-form layout.
        public let renderingRules: [SheetElementRenderingRule]?
        /// The border style configuration of a free-form layout element. This border style is used when the element is selected.
        public let selectedBorderStyle: FreeFormLayoutElementBorderStyle?
        /// The visibility of an element within a free-form layout.
        public let visibility: Visibility?
        /// The width of an element within a free-form layout.
        public let width: String
        /// The x-axis coordinate of the element.
        public let xAxisLocation: String
        /// The y-axis coordinate of the element.
        public let yAxisLocation: String

        public init(backgroundStyle: FreeFormLayoutElementBackgroundStyle? = nil, borderStyle: FreeFormLayoutElementBorderStyle? = nil, elementId: String, elementType: LayoutElementType, height: String, loadingAnimation: LoadingAnimation? = nil, renderingRules: [SheetElementRenderingRule]? = nil, selectedBorderStyle: FreeFormLayoutElementBorderStyle? = nil, visibility: Visibility? = nil, width: String, xAxisLocation: String, yAxisLocation: String) {
            self.backgroundStyle = backgroundStyle
            self.borderStyle = borderStyle
            self.elementId = elementId
            self.elementType = elementType
            self.height = height
            self.loadingAnimation = loadingAnimation
            self.renderingRules = renderingRules
            self.selectedBorderStyle = selectedBorderStyle
            self.visibility = visibility
            self.width = width
            self.xAxisLocation = xAxisLocation
            self.yAxisLocation = yAxisLocation
        }

        public func validate(name: String) throws {
            try self.backgroundStyle?.validate(name: "\(name).backgroundStyle")
            try self.borderStyle?.validate(name: "\(name).borderStyle")
            try self.validate(self.elementId, name: "elementId", parent: name, max: 512)
            try self.validate(self.elementId, name: "elementId", parent: name, min: 1)
            try self.validate(self.elementId, name: "elementId", parent: name, pattern: "^[\\w\\-]+$")
            try self.renderingRules?.forEach {
                try $0.validate(name: "\(name).renderingRules[]")
            }
            try self.validate(self.renderingRules, name: "renderingRules", parent: name, max: 10000)
            try self.selectedBorderStyle?.validate(name: "\(name).selectedBorderStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundStyle = "BackgroundStyle"
            case borderStyle = "BorderStyle"
            case elementId = "ElementId"
            case elementType = "ElementType"
            case height = "Height"
            case loadingAnimation = "LoadingAnimation"
            case renderingRules = "RenderingRules"
            case selectedBorderStyle = "SelectedBorderStyle"
            case visibility = "Visibility"
            case width = "Width"
            case xAxisLocation = "XAxisLocation"
            case yAxisLocation = "YAxisLocation"
        }
    }

    public struct FreeFormLayoutElementBackgroundStyle: AWSEncodableShape & AWSDecodableShape {
        /// The background color of a free-form layout element.
        public let color: String?
        /// The background visibility of a free-form layout element.
        public let visibility: Visibility?

        public init(color: String? = nil, visibility: Visibility? = nil) {
            self.color = color
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case visibility = "Visibility"
        }
    }

    public struct FreeFormLayoutElementBorderStyle: AWSEncodableShape & AWSDecodableShape {
        /// The border color of a free-form layout element.
        public let color: String?
        /// The border visibility of a free-form layout element.
        public let visibility: Visibility?

        public init(color: String? = nil, visibility: Visibility? = nil) {
            self.color = color
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case visibility = "Visibility"
        }
    }

    public struct FreeFormLayoutScreenCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The width that the view port will be optimized for when the layout renders.
        public let optimizedViewPortWidth: String

        public init(optimizedViewPortWidth: String) {
            self.optimizedViewPortWidth = optimizedViewPortWidth
        }

        private enum CodingKeys: String, CodingKey {
            case optimizedViewPortWidth = "OptimizedViewPortWidth"
        }
    }

    public struct FreeFormSectionLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The elements that are included in the free-form layout.
        public let elements: [FreeFormLayoutElement]

        public init(elements: [FreeFormLayoutElement]) {
            self.elements = elements
        }

        public func validate(name: String) throws {
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 430)
        }

        private enum CodingKeys: String, CodingKey {
            case elements = "Elements"
        }
    }

    public struct FunnelChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category field wells of a funnel chart. Values are grouped by category fields.
        public let category: [DimensionField]?
        /// The value field wells of a funnel chart. Values are aggregated based on categories.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case values = "Values"
        }
    }

    public struct FunnelChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options of the categories that are displayed in a FunnelChartVisual.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The options that determine the presentation of the data labels.
        public let dataLabelOptions: FunnelChartDataLabelOptions?
        /// The field well configuration of a FunnelChartVisual.
        public let fieldWells: FunnelChartFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The sort configuration of a FunnelChartVisual.
        public let sortConfiguration: FunnelChartSortConfiguration?
        /// The tooltip configuration of a FunnelChartVisual.
        public let tooltip: TooltipOptions?
        /// The label options for the values that are displayed in a FunnelChartVisual.
        public let valueLabelOptions: ChartAxisLabelOptions?
        /// The visual palette configuration of a FunnelChartVisual.
        public let visualPalette: VisualPalette?

        public init(categoryLabelOptions: ChartAxisLabelOptions? = nil, dataLabelOptions: FunnelChartDataLabelOptions? = nil, fieldWells: FunnelChartFieldWells? = nil, interactions: VisualInteractionOptions? = nil, sortConfiguration: FunnelChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, valueLabelOptions: ChartAxisLabelOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.categoryLabelOptions = categoryLabelOptions
            self.dataLabelOptions = dataLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.dataLabelOptions?.validate(name: "\(name).dataLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.valueLabelOptions?.validate(name: "\(name).valueLabelOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelOptions = "CategoryLabelOptions"
            case dataLabelOptions = "DataLabelOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case valueLabelOptions = "ValueLabelOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct FunnelChartDataLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the category labels within the data labels.
        public let categoryLabelVisibility: Visibility?
        /// The color of the data label text.
        public let labelColor: String?
        /// The font configuration for the data labels. Only the FontSize attribute of the font configuration is used for data labels.
        public let labelFontConfiguration: FontConfiguration?
        /// Determines the style of the metric labels.
        public let measureDataLabelStyle: FunnelChartMeasureDataLabelStyle?
        /// The visibility of the measure labels within the data labels.
        public let measureLabelVisibility: Visibility?
        /// Determines the positioning of the data label relative to a section of the funnel.
        public let position: DataLabelPosition?
        /// The visibility option that determines if data labels are displayed.
        public let visibility: Visibility?

        public init(categoryLabelVisibility: Visibility? = nil, labelColor: String? = nil, labelFontConfiguration: FontConfiguration? = nil, measureDataLabelStyle: FunnelChartMeasureDataLabelStyle? = nil, measureLabelVisibility: Visibility? = nil, position: DataLabelPosition? = nil, visibility: Visibility? = nil) {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.labelColor = labelColor
            self.labelFontConfiguration = labelFontConfiguration
            self.measureDataLabelStyle = measureDataLabelStyle
            self.measureLabelVisibility = measureLabelVisibility
            self.position = position
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.labelColor, name: "labelColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.labelFontConfiguration?.validate(name: "\(name).labelFontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelVisibility = "CategoryLabelVisibility"
            case labelColor = "LabelColor"
            case labelFontConfiguration = "LabelFontConfiguration"
            case measureDataLabelStyle = "MeasureDataLabelStyle"
            case measureLabelVisibility = "MeasureLabelVisibility"
            case position = "Position"
            case visibility = "Visibility"
        }
    }

    public struct FunnelChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a FunnelChartVisual.
        public let funnelChartAggregatedFieldWells: FunnelChartAggregatedFieldWells?

        public init(funnelChartAggregatedFieldWells: FunnelChartAggregatedFieldWells? = nil) {
            self.funnelChartAggregatedFieldWells = funnelChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.funnelChartAggregatedFieldWells?.validate(name: "\(name).funnelChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case funnelChartAggregatedFieldWells = "FunnelChartAggregatedFieldWells"
        }
    }

    public struct FunnelChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories displayed.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
        }
    }

    public struct FunnelChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a FunnelChartVisual.
        public let chartConfiguration: FunnelChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: FunnelChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct GaugeChartArcConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the arc foreground color.
        public let foregroundColor: ConditionalFormattingColor?

        public init(foregroundColor: ConditionalFormattingColor? = nil) {
            self.foregroundColor = foregroundColor
        }

        public func validate(name: String) throws {
            try self.foregroundColor?.validate(name: "\(name).foregroundColor")
        }

        private enum CodingKeys: String, CodingKey {
            case foregroundColor = "ForegroundColor"
        }
    }

    public struct GaugeChartConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options of a GaugeChartVisual.
        public let conditionalFormattingOptions: [GaugeChartConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [GaugeChartConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct GaugeChartConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of the arc of a GaugeChartVisual.
        public let arc: GaugeChartArcConditionalFormatting?
        /// The conditional formatting for the primary value of a GaugeChartVisual.
        public let primaryValue: GaugeChartPrimaryValueConditionalFormatting?

        public init(arc: GaugeChartArcConditionalFormatting? = nil, primaryValue: GaugeChartPrimaryValueConditionalFormatting? = nil) {
            self.arc = arc
            self.primaryValue = primaryValue
        }

        public func validate(name: String) throws {
            try self.arc?.validate(name: "\(name).arc")
            try self.primaryValue?.validate(name: "\(name).primaryValue")
        }

        private enum CodingKeys: String, CodingKey {
            case arc = "Arc"
            case primaryValue = "PrimaryValue"
        }
    }

    public struct GaugeChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data label configuration of a GaugeChartVisual.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a GaugeChartVisual.
        public let fieldWells: GaugeChartFieldWells?
        /// The options that determine the presentation of the GaugeChartVisual.
        public let gaugeChartOptions: GaugeChartOptions?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The tooltip configuration of a GaugeChartVisual.
        public let tooltipOptions: TooltipOptions?
        /// The visual palette configuration of a GaugeChartVisual.
        public let visualPalette: VisualPalette?

        public init(dataLabels: DataLabelOptions? = nil, fieldWells: GaugeChartFieldWells? = nil, gaugeChartOptions: GaugeChartOptions? = nil, interactions: VisualInteractionOptions? = nil, tooltipOptions: TooltipOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.gaugeChartOptions = gaugeChartOptions
            self.interactions = interactions
            self.tooltipOptions = tooltipOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.gaugeChartOptions?.validate(name: "\(name).gaugeChartOptions")
            try self.tooltipOptions?.validate(name: "\(name).tooltipOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case gaugeChartOptions = "GaugeChartOptions"
            case interactions = "Interactions"
            case tooltipOptions = "TooltipOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct GaugeChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The target value field wells of a GaugeChartVisual.
        public let targetValues: [MeasureField]?
        /// The value field wells of a GaugeChartVisual.
        public let values: [MeasureField]?

        public init(targetValues: [MeasureField]? = nil, values: [MeasureField]? = nil) {
            self.targetValues = targetValues
            self.values = values
        }

        public func validate(name: String) throws {
            try self.targetValues?.forEach {
                try $0.validate(name: "\(name).targetValues[]")
            }
            try self.validate(self.targetValues, name: "targetValues", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case targetValues = "TargetValues"
            case values = "Values"
        }
    }

    public struct GaugeChartOptions: AWSEncodableShape & AWSDecodableShape {
        /// The arc configuration of a GaugeChartVisual.
        public let arc: ArcConfiguration?
        /// The arc axis configuration of a GaugeChartVisual.
        public let arcAxis: ArcAxisConfiguration?
        /// The comparison configuration of a GaugeChartVisual.
        public let comparison: ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public let primaryValueDisplayType: PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public let primaryValueFontConfiguration: FontConfiguration?

        public init(arc: ArcConfiguration? = nil, arcAxis: ArcAxisConfiguration? = nil, comparison: ComparisonConfiguration? = nil, primaryValueDisplayType: PrimaryValueDisplayType? = nil, primaryValueFontConfiguration: FontConfiguration? = nil) {
            self.arc = arc
            self.arcAxis = arcAxis
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
        }

        public func validate(name: String) throws {
            try self.comparison?.validate(name: "\(name).comparison")
            try self.primaryValueFontConfiguration?.validate(name: "\(name).primaryValueFontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case arc = "Arc"
            case arcAxis = "ArcAxis"
            case comparison = "Comparison"
            case primaryValueDisplayType = "PrimaryValueDisplayType"
            case primaryValueFontConfiguration = "PrimaryValueFontConfiguration"
        }
    }

    public struct GaugeChartPrimaryValueConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the primary value icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting of the primary value text color.
        public let textColor: ConditionalFormattingColor?

        public init(icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct GaugeChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a GaugeChartVisual.
        public let chartConfiguration: GaugeChartConfiguration?
        /// The conditional formatting of a GaugeChartVisual.
        public let conditionalFormatting: GaugeChartConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: GaugeChartConfiguration? = nil, conditionalFormatting: GaugeChartConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct GenerateEmbedUrlForAnonymousUserRequest: AWSEncodableShape {
        /// The domains that you want to add to the allow list for access to the generated URL that is then embedded. This optional parameter overrides the static domains that are configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it allows only the domains that you include in this parameter. You can list up to three domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
        public let allowedDomains: [String]?
        /// The Amazon Resource Names (ARNs) for the Amazon QuickSight resources that the user is authorized to access during the lifetime of the session. If you choose Dashboard embedding experience, pass the list of dashboard ARNs in the account that you want the user to be able to view. If you want to make changes to the theme of your embedded content, pass a list of theme ARNs that the anonymous users need access to. Currently, you can pass up to 25 theme ARNs in each API call.
        public let authorizedResourceArns: [String]
        /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
        public let awsAccountId: String
        /// The configuration of the experience that you are embedding.
        public let experienceConfiguration: AnonymousUserEmbeddingExperienceConfiguration
        /// The Amazon QuickSight namespace that the anonymous user virtually belongs to. If you are not using an Amazon QuickSight custom namespace, set this to default.
        public let namespace: String
        /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
        public let sessionLifetimeInMinutes: Int64?
        /// The session tags used for row-level security. Before you use this parameter, make sure that you have configured the relevant datasets using the DataSet$RowLevelPermissionTagConfiguration parameter so that session tags can be used to provide row-level security. These are not the tags used for the Amazon Web Services resource tagging feature. For more information, see Using Row-Level Security (RLS) with Tagsin the Amazon QuickSight User Guide.
        public let sessionTags: [SessionTag]?

        public init(allowedDomains: [String]? = nil, authorizedResourceArns: [String], awsAccountId: String, experienceConfiguration: AnonymousUserEmbeddingExperienceConfiguration, namespace: String, sessionLifetimeInMinutes: Int64? = nil, sessionTags: [SessionTag]? = nil) {
            self.allowedDomains = allowedDomains
            self.authorizedResourceArns = authorizedResourceArns
            self.awsAccountId = awsAccountId
            self.experienceConfiguration = experienceConfiguration
            self.namespace = namespace
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.sessionTags = sessionTags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedDomains, forKey: .allowedDomains)
            try container.encode(self.authorizedResourceArns, forKey: .authorizedResourceArns)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.experienceConfiguration, forKey: .experienceConfiguration)
            try container.encode(self.namespace, forKey: .namespace)
            try container.encodeIfPresent(self.sessionLifetimeInMinutes, forKey: .sessionLifetimeInMinutes)
            try container.encodeIfPresent(self.sessionTags, forKey: .sessionTags)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.experienceConfiguration.validate(name: "\(name).experienceConfiguration")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
            try self.sessionTags?.forEach {
                try $0.validate(name: "\(name).sessionTags[]")
            }
            try self.validate(self.sessionTags, name: "sessionTags", parent: name, max: 50)
            try self.validate(self.sessionTags, name: "sessionTags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedDomains = "AllowedDomains"
            case authorizedResourceArns = "AuthorizedResourceArns"
            case experienceConfiguration = "ExperienceConfiguration"
            case namespace = "Namespace"
            case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
            case sessionTags = "SessionTags"
        }
    }

    public struct GenerateEmbedUrlForAnonymousUserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) to use for the anonymous Amazon QuickSight user.
        public let anonymousUserArn: String
        /// The embed URL for the dashboard.
        public let embedUrl: String
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String
        /// The HTTP status of the request.
        public let status: Int

        public init(anonymousUserArn: String, embedUrl: String, requestId: String, status: Int) {
            self.anonymousUserArn = anonymousUserArn
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.anonymousUserArn = try container.decode(String.self, forKey: .anonymousUserArn)
            self.embedUrl = try container.decode(String.self, forKey: .embedUrl)
            self.requestId = try container.decode(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case anonymousUserArn = "AnonymousUserArn"
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
        }
    }

    public struct GenerateEmbedUrlForRegisteredUserRequest: AWSEncodableShape {
        /// The domains that you want to add to the allow list for access to the generated URL that  is then embedded. This optional parameter overrides the static domains that are  configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it  allows only the domains that you include in this parameter. You can list up to three  domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
        public let allowedDomains: [String]?
        /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
        public let awsAccountId: String
        /// The experience you are embedding. For registered users, you can embed Amazon QuickSight dashboards, Amazon QuickSight visuals, the Amazon QuickSight Q search bar, or the entire Amazon QuickSight console.
        public let experienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration
        /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
        public let sessionLifetimeInMinutes: Int64?
        /// The Amazon Resource Name for the registered user.
        public let userArn: String

        public init(allowedDomains: [String]? = nil, awsAccountId: String, experienceConfiguration: RegisteredUserEmbeddingExperienceConfiguration, sessionLifetimeInMinutes: Int64? = nil, userArn: String) {
            self.allowedDomains = allowedDomains
            self.awsAccountId = awsAccountId
            self.experienceConfiguration = experienceConfiguration
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.userArn = userArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedDomains, forKey: .allowedDomains)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.experienceConfiguration, forKey: .experienceConfiguration)
            try container.encodeIfPresent(self.sessionLifetimeInMinutes, forKey: .sessionLifetimeInMinutes)
            try container.encode(self.userArn, forKey: .userArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.experienceConfiguration.validate(name: "\(name).experienceConfiguration")
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedDomains = "AllowedDomains"
            case experienceConfiguration = "ExperienceConfiguration"
            case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
            case userArn = "UserArn"
        }
    }

    public struct GenerateEmbedUrlForRegisteredUserResponse: AWSDecodableShape {
        /// The embed URL for the Amazon QuickSight dashboard, visual, Q search bar, or console.
        public let embedUrl: String
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String
        /// The HTTP status of the request.
        public let status: Int

        public init(embedUrl: String, requestId: String, status: Int) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.embedUrl = try container.decode(String.self, forKey: .embedUrl)
            self.requestId = try container.decode(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
        }
    }

    public struct GeoSpatialColumnGroup: AWSEncodableShape & AWSDecodableShape {
        /// Columns in this hierarchy.
        public let columns: [String]
        /// Country code.
        public let countryCode: GeoSpatialCountryCode?
        /// A display name for the hierarchy.
        public let name: String

        public init(columns: [String], countryCode: GeoSpatialCountryCode? = nil, name: String) {
            self.columns = columns
            self.countryCode = countryCode
            self.name = name
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try validate($0, name: "columns[]", parent: name, max: 128)
                try validate($0, name: "columns[]", parent: name, min: 1)
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 16)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case countryCode = "CountryCode"
            case name = "Name"
        }
    }

    public struct GeospatialCoordinateBounds: AWSEncodableShape & AWSDecodableShape {
        /// The longitude of the east bound of the geospatial coordinate bounds.
        public let east: Double
        /// The latitude of the north bound of the geospatial coordinate bounds.
        public let north: Double
        /// The latitude of the south bound of the geospatial coordinate bounds.
        public let south: Double
        /// The longitude of the west bound of the geospatial coordinate bounds.
        public let west: Double

        public init(east: Double, north: Double, south: Double, west: Double) {
            self.east = east
            self.north = north
            self.south = south
            self.west = west
        }

        public func validate(name: String) throws {
            try self.validate(self.east, name: "east", parent: name, max: 1800.0)
            try self.validate(self.east, name: "east", parent: name, min: -1800.0)
            try self.validate(self.north, name: "north", parent: name, max: 90.0)
            try self.validate(self.north, name: "north", parent: name, min: -90.0)
            try self.validate(self.south, name: "south", parent: name, max: 90.0)
            try self.validate(self.south, name: "south", parent: name, min: -90.0)
            try self.validate(self.west, name: "west", parent: name, max: 1800.0)
            try self.validate(self.west, name: "west", parent: name, min: -1800.0)
        }

        private enum CodingKeys: String, CodingKey {
            case east = "East"
            case north = "North"
            case south = "South"
            case west = "West"
        }
    }

    public struct GeospatialHeatmapColorScale: AWSEncodableShape & AWSDecodableShape {
        /// The list of colors to be used in heatmap point style.
        public let colors: [GeospatialHeatmapDataColor]?

        public init(colors: [GeospatialHeatmapDataColor]? = nil) {
            self.colors = colors
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 2)
            try self.validate(self.colors, name: "colors", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
        }
    }

    public struct GeospatialHeatmapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The color scale specification for the heatmap point style.
        public let heatmapColor: GeospatialHeatmapColorScale?

        public init(heatmapColor: GeospatialHeatmapColorScale? = nil) {
            self.heatmapColor = heatmapColor
        }

        public func validate(name: String) throws {
            try self.heatmapColor?.validate(name: "\(name).heatmapColor")
        }

        private enum CodingKeys: String, CodingKey {
            case heatmapColor = "HeatmapColor"
        }
    }

    public struct GeospatialHeatmapDataColor: AWSEncodableShape & AWSDecodableShape {
        /// The hex color to be used in the heatmap point style.
        public let color: String

        public init(color: String) {
            self.color = color
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
        }
    }

    public struct GeospatialMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The color field wells of a geospatial map.
        public let colors: [DimensionField]?
        /// The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.
        public let geospatial: [DimensionField]?
        /// The size field wells of a geospatial map. Values are aggregated based on geospatial fields.
        public let values: [MeasureField]?

        public init(colors: [DimensionField]? = nil, geospatial: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.colors = colors
            self.geospatial = geospatial
            self.values = values
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.geospatial?.forEach {
                try $0.validate(name: "\(name).geospatial[]")
            }
            try self.validate(self.geospatial, name: "geospatial", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
            case geospatial = "Geospatial"
            case values = "Values"
        }
    }

    public struct GeospatialMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field wells of the visual.
        public let fieldWells: GeospatialMapFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The map style options of the geospatial map.
        public let mapStyleOptions: GeospatialMapStyleOptions?
        /// The point style options of the geospatial map.
        public let pointStyleOptions: GeospatialPointStyleOptions?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        public let visualPalette: VisualPalette?
        /// The window options of the geospatial map.
        public let windowOptions: GeospatialWindowOptions?

        public init(fieldWells: GeospatialMapFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, mapStyleOptions: GeospatialMapStyleOptions? = nil, pointStyleOptions: GeospatialPointStyleOptions? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil, windowOptions: GeospatialWindowOptions? = nil) {
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.pointStyleOptions = pointStyleOptions
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.windowOptions = windowOptions
        }

        public func validate(name: String) throws {
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.pointStyleOptions?.validate(name: "\(name).pointStyleOptions")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.windowOptions?.validate(name: "\(name).windowOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case mapStyleOptions = "MapStyleOptions"
            case pointStyleOptions = "PointStyleOptions"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
            case windowOptions = "WindowOptions"
        }
    }

    public struct GeospatialMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well for a geospatial map.
        public let geospatialMapAggregatedFieldWells: GeospatialMapAggregatedFieldWells?

        public init(geospatialMapAggregatedFieldWells: GeospatialMapAggregatedFieldWells? = nil) {
            self.geospatialMapAggregatedFieldWells = geospatialMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.geospatialMapAggregatedFieldWells?.validate(name: "\(name).geospatialMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case geospatialMapAggregatedFieldWells = "GeospatialMapAggregatedFieldWells"
        }
    }

    public struct GeospatialMapStyleOptions: AWSEncodableShape & AWSDecodableShape {
        /// The base map style of the geospatial map.
        public let baseMapStyle: BaseMapStyleType?

        public init(baseMapStyle: BaseMapStyleType? = nil) {
            self.baseMapStyle = baseMapStyle
        }

        private enum CodingKeys: String, CodingKey {
            case baseMapStyle = "BaseMapStyle"
        }
    }

    public struct GeospatialMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: GeospatialMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: GeospatialMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct GeospatialPointStyleOptions: AWSEncodableShape & AWSDecodableShape {
        /// The cluster marker configuration of the geospatial point style.
        public let clusterMarkerConfiguration: ClusterMarkerConfiguration?
        /// The heatmap configuration of the geospatial point style.
        public let heatmapConfiguration: GeospatialHeatmapConfiguration?
        /// The selected point styles (point, cluster) of the geospatial map.
        public let selectedPointStyle: GeospatialSelectedPointStyle?

        public init(clusterMarkerConfiguration: ClusterMarkerConfiguration? = nil, heatmapConfiguration: GeospatialHeatmapConfiguration? = nil, selectedPointStyle: GeospatialSelectedPointStyle? = nil) {
            self.clusterMarkerConfiguration = clusterMarkerConfiguration
            self.heatmapConfiguration = heatmapConfiguration
            self.selectedPointStyle = selectedPointStyle
        }

        public func validate(name: String) throws {
            try self.clusterMarkerConfiguration?.validate(name: "\(name).clusterMarkerConfiguration")
            try self.heatmapConfiguration?.validate(name: "\(name).heatmapConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterMarkerConfiguration = "ClusterMarkerConfiguration"
            case heatmapConfiguration = "HeatmapConfiguration"
            case selectedPointStyle = "SelectedPointStyle"
        }
    }

    public struct GeospatialWindowOptions: AWSEncodableShape & AWSDecodableShape {
        /// The bounds options (north, south, west, east) of the geospatial window options.
        public let bounds: GeospatialCoordinateBounds?
        /// The map zoom modes (manual, auto) of the geospatial window options.
        public let mapZoomMode: MapZoomMode?

        public init(bounds: GeospatialCoordinateBounds? = nil, mapZoomMode: MapZoomMode? = nil) {
            self.bounds = bounds
            self.mapZoomMode = mapZoomMode
        }

        public func validate(name: String) throws {
            try self.bounds?.validate(name: "\(name).bounds")
        }

        private enum CodingKeys: String, CodingKey {
            case bounds = "Bounds"
            case mapZoomMode = "MapZoomMode"
        }
    }

    public struct GetDashboardEmbedUrlRequest: AWSEncodableShape {
        /// A list of one or more dashboard IDs that you want anonymous users to have tempporary access to. Currently, the IdentityType parameter must be set to ANONYMOUS because other identity types authenticate as Amazon QuickSight or IAM users. For example, if you set "--dashboard-id dash_id1 --dashboard-id dash_id2 dash_id3 identity-type ANONYMOUS", the session can access all three dashboards.
        public let additionalDashboardIds: [String]?
        /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
        public let awsAccountId: String
        /// The ID for the dashboard, also added to the Identity and Access Management (IAM) policy.
        public let dashboardId: String
        /// The authentication method that the user uses to sign in.
        public let identityType: EmbeddingIdentityType
        /// The Amazon QuickSight namespace that contains the dashboard IDs in this request. 	   If you're not using a custom namespace, set Namespace = default.
        public let namespace: String?
        /// Remove the reset button on the embedded dashboard. The default is FALSE, which enables the
        /// 			reset button.
        public let resetDisabled: Bool?
        /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
        public let sessionLifetimeInMinutes: Int64?
        /// Adds persistence of state for the user session in an embedded dashboard. Persistence applies to the sheet and the parameter settings. These are control settings that the dashboard subscriber (Amazon QuickSight reader) chooses while viewing the dashboard. If this is set to TRUE, the settings are the same when the subscriber reopens the same dashboard URL. The state is stored in Amazon QuickSight, not in a browser cookie. If this is set to FALSE, the state of the user session is not persisted. The default is FALSE.
        public let statePersistenceEnabled: Bool?
        /// Remove the undo/redo button on the embedded dashboard. The default is FALSE, which enables
        /// 			the undo/redo button.
        public let undoRedoDisabled: Bool?
        /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type.
        /// 			You can use this for any Amazon QuickSight users in your account (readers, authors, or
        /// 			admins) authenticated as one of the following:   Active Directory (AD) users or group members   Invited nonfederated users   IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using
        /// 					SAML, OpenID Connect, or IAM federation.   Omit this parameter for users in the third group – IAM users and IAM role-based sessions.
        public let userArn: String?

        public init(additionalDashboardIds: [String]? = nil, awsAccountId: String, dashboardId: String, identityType: EmbeddingIdentityType, namespace: String? = nil, resetDisabled: Bool? = nil, sessionLifetimeInMinutes: Int64? = nil, statePersistenceEnabled: Bool? = nil, undoRedoDisabled: Bool? = nil, userArn: String? = nil) {
            self.additionalDashboardIds = additionalDashboardIds
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.identityType = identityType
            self.namespace = namespace
            self.resetDisabled = resetDisabled
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.statePersistenceEnabled = statePersistenceEnabled
            self.undoRedoDisabled = undoRedoDisabled
            self.userArn = userArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.additionalDashboardIds, key: "additional-dashboard-ids")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodeQuery(self.identityType, key: "creds-type")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.resetDisabled, key: "reset-disabled")
            request.encodeQuery(self.sessionLifetimeInMinutes, key: "session-lifetime")
            request.encodeQuery(self.statePersistenceEnabled, key: "state-persistence-enabled")
            request.encodeQuery(self.undoRedoDisabled, key: "undo-redo-disabled")
            request.encodeQuery(self.userArn, key: "user-arn")
        }

        public func validate(name: String) throws {
            try self.additionalDashboardIds?.forEach {
                try validate($0, name: "additionalDashboardIds[]", parent: name, max: 512)
                try validate($0, name: "additionalDashboardIds[]", parent: name, min: 1)
                try validate($0, name: "additionalDashboardIds[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.additionalDashboardIds, name: "additionalDashboardIds", parent: name, max: 20)
            try self.validate(self.additionalDashboardIds, name: "additionalDashboardIds", parent: name, min: 1)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDashboardEmbedUrlResponse: AWSDecodableShape {
        /// A single-use URL that you can put into your server-side webpage to embed your
        /// 			dashboard. This URL is valid for 5 minutes. The API operation provides the URL with an
        /// 			auth_code value that enables one (and only one) sign-on to a user session
        /// 			that is valid for 10 hours.
        public let embedUrl: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(embedUrl: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.embedUrl = try container.decodeIfPresent(String.self, forKey: .embedUrl)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
        }
    }

    public struct GetSessionEmbedUrlRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account associated with your Amazon QuickSight subscription.
        public let awsAccountId: String
        /// The URL you use to access the embedded session. The entry point URL is constrained to the following paths:    /start     /start/analyses     /start/dashboards     /start/favorites     /dashboards/DashboardId - where DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard    /analyses/AnalysisId - where AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis
        public let entryPoint: String?
        /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
        public let sessionLifetimeInMinutes: Int64?
        /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type.
        /// 			You can use this for any type of Amazon QuickSight users in your account (readers, authors, or
        /// 			admins). They need to be authenticated as one of the following:   Active Directory (AD) users or group members   Invited nonfederated users   IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation   Omit this parameter for users in the third group, IAM users and IAM role-based sessions.
        public let userArn: String?

        public init(awsAccountId: String, entryPoint: String? = nil, sessionLifetimeInMinutes: Int64? = nil, userArn: String? = nil) {
            self.awsAccountId = awsAccountId
            self.entryPoint = entryPoint
            self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
            self.userArn = userArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.entryPoint, key: "entry-point")
            request.encodeQuery(self.sessionLifetimeInMinutes, key: "session-lifetime")
            request.encodeQuery(self.userArn, key: "user-arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, max: 1000)
            try self.validate(self.entryPoint, name: "entryPoint", parent: name, min: 1)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, max: 600)
            try self.validate(self.sessionLifetimeInMinutes, name: "sessionLifetimeInMinutes", parent: name, min: 15)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionEmbedUrlResponse: AWSDecodableShape {
        /// A single-use URL that you can put into your server-side web page to embed your
        /// 			Amazon QuickSight session. This URL is valid for 5 minutes. The API operation provides the URL with an
        /// 			auth_code value that enables one (and only one) sign-on to a user session
        /// 			that is valid for 10 hours.
        public let embedUrl: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(embedUrl: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.embedUrl = embedUrl
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.embedUrl = try container.decodeIfPresent(String.self, forKey: .embedUrl)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case embedUrl = "EmbedUrl"
            case requestId = "RequestId"
        }
    }

    public struct GlobalTableBorderOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the options for side specific border.
        public let sideSpecificBorder: TableSideBorderOptions?
        /// Determines the options for uniform border.
        public let uniformBorder: TableBorderOptions?

        public init(sideSpecificBorder: TableSideBorderOptions? = nil, uniformBorder: TableBorderOptions? = nil) {
            self.sideSpecificBorder = sideSpecificBorder
            self.uniformBorder = uniformBorder
        }

        public func validate(name: String) throws {
            try self.sideSpecificBorder?.validate(name: "\(name).sideSpecificBorder")
            try self.uniformBorder?.validate(name: "\(name).uniformBorder")
        }

        private enum CodingKeys: String, CodingKey {
            case sideSpecificBorder = "SideSpecificBorder"
            case uniformBorder = "UniformBorder"
        }
    }

    public struct GradientColor: AWSEncodableShape & AWSDecodableShape {
        /// The list of gradient color stops.
        public let stops: [GradientStop]?

        public init(stops: [GradientStop]? = nil) {
            self.stops = stops
        }

        public func validate(name: String) throws {
            try self.stops?.forEach {
                try $0.validate(name: "\(name).stops[]")
            }
            try self.validate(self.stops, name: "stops", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case stops = "Stops"
        }
    }

    public struct GradientStop: AWSEncodableShape & AWSDecodableShape {
        /// Determines the color.
        public let color: String?
        /// Determines the data value.
        public let dataValue: Double?
        /// Determines gradient offset value.
        public let gradientOffset: Double

        public init(color: String? = nil, dataValue: Double? = nil, gradientOffset: Double) {
            self.color = color
            self.dataValue = dataValue
            self.gradientOffset = gradientOffset
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case dataValue = "DataValue"
            case gradientOffset = "GradientOffset"
        }
    }

    public struct GridLayoutCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the sizing of the canvas used in a grid layout.
        public let screenCanvasSizeOptions: GridLayoutScreenCanvasSizeOptions?

        public init(screenCanvasSizeOptions: GridLayoutScreenCanvasSizeOptions? = nil) {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case screenCanvasSizeOptions = "ScreenCanvasSizeOptions"
        }
    }

    public struct GridLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let canvasSizeOptions: GridLayoutCanvasSizeOptions?
        /// The elements that are included in a grid layout.
        public let elements: [GridLayoutElement]

        public init(canvasSizeOptions: GridLayoutCanvasSizeOptions? = nil, elements: [GridLayoutElement]) {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }

        public func validate(name: String) throws {
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.elements, name: "elements", parent: name, max: 430)
        }

        private enum CodingKeys: String, CodingKey {
            case canvasSizeOptions = "CanvasSizeOptions"
            case elements = "Elements"
        }
    }

    public struct GridLayoutElement: AWSEncodableShape & AWSDecodableShape {
        /// The column index for the upper left corner of an element.
        public let columnIndex: Int?
        /// The width of a grid element expressed as a number of grid columns.
        public let columnSpan: Int
        /// A unique identifier for an element within a grid layout.
        public let elementId: String
        /// The type of element.
        public let elementType: LayoutElementType
        /// The row index for the upper left corner of an element.
        public let rowIndex: Int?
        /// The height of a grid element expressed as a number of grid rows.
        public let rowSpan: Int

        public init(columnIndex: Int? = nil, columnSpan: Int, elementId: String, elementType: LayoutElementType, rowIndex: Int? = nil, rowSpan: Int) {
            self.columnIndex = columnIndex
            self.columnSpan = columnSpan
            self.elementId = elementId
            self.elementType = elementType
            self.rowIndex = rowIndex
            self.rowSpan = rowSpan
        }

        public func validate(name: String) throws {
            try self.validate(self.columnIndex, name: "columnIndex", parent: name, max: 35)
            try self.validate(self.columnIndex, name: "columnIndex", parent: name, min: 0)
            try self.validate(self.columnSpan, name: "columnSpan", parent: name, max: 36)
            try self.validate(self.columnSpan, name: "columnSpan", parent: name, min: 1)
            try self.validate(self.elementId, name: "elementId", parent: name, max: 512)
            try self.validate(self.elementId, name: "elementId", parent: name, min: 1)
            try self.validate(self.elementId, name: "elementId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.rowIndex, name: "rowIndex", parent: name, max: 9009)
            try self.validate(self.rowIndex, name: "rowIndex", parent: name, min: 0)
            try self.validate(self.rowSpan, name: "rowSpan", parent: name, max: 21)
            try self.validate(self.rowSpan, name: "rowSpan", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnIndex = "ColumnIndex"
            case columnSpan = "ColumnSpan"
            case elementId = "ElementId"
            case elementType = "ElementType"
            case rowIndex = "RowIndex"
            case rowSpan = "RowSpan"
        }
    }

    public struct GridLayoutScreenCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The width that the view port will be optimized for when the layout renders.
        public let optimizedViewPortWidth: String?
        /// This value determines the layout behavior when the viewport is resized.    FIXED: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called Classic.    RESPONSIVE: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called Tiled.
        public let resizeOption: ResizeOption

        public init(optimizedViewPortWidth: String? = nil, resizeOption: ResizeOption) {
            self.optimizedViewPortWidth = optimizedViewPortWidth
            self.resizeOption = resizeOption
        }

        private enum CodingKeys: String, CodingKey {
            case optimizedViewPortWidth = "OptimizedViewPortWidth"
            case resizeOption = "ResizeOption"
        }
    }

    public struct Group: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the group.
        public let arn: String?
        /// The group description.
        public let description: String?
        /// The name of the group.
        public let groupName: String?
        /// The principal ID of the group.
        public let principalId: String?

        public init(arn: String? = nil, description: String? = nil, groupName: String? = nil, principalId: String? = nil) {
            self.arn = arn
            self.description = description
            self.groupName = groupName
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case groupName = "GroupName"
            case principalId = "PrincipalId"
        }
    }

    public struct GroupMember: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the group member (user).
        public let arn: String?
        /// The name of the group member (user).
        public let memberName: String?

        public init(arn: String? = nil, memberName: String? = nil) {
            self.arn = arn
            self.memberName = memberName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case memberName = "MemberName"
        }
    }

    public struct GroupSearchFilter: AWSEncodableShape {
        /// The name of the value that you want to use as a filter, for example "Name": "GROUP_NAME". Currently, the only supported name is GROUP_NAME.
        public let name: GroupFilterAttribute
        /// The comparison operator that you want to use as a filter, for example "Operator": "StartsWith". Currently, the only supported operator is StartsWith.
        public let `operator`: GroupFilterOperator
        /// The value of the named item, in this case GROUP_NAME, that you want to use as a filter.
        public let value: String

        public init(name: GroupFilterAttribute, operator: GroupFilterOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct GrowthRateComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The period size setup of a growth rate computation.
        public let periodSize: Int?
        /// The time field that is used in a computation.
        public let time: DimensionField?
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, periodSize: Int? = nil, time: DimensionField? = nil, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.periodSize = periodSize
            self.time = time
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.periodSize, name: "periodSize", parent: name, max: 52)
            try self.validate(self.periodSize, name: "periodSize", parent: name, min: 2)
            try self.time?.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case periodSize = "PeriodSize"
            case time = "Time"
            case value = "Value"
        }
    }

    public struct GutterStyle: AWSEncodableShape & AWSDecodableShape {
        /// This Boolean value controls whether to display a gutter space between sheet tiles.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct HeaderFooterSectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The layout configuration of the header or footer section.
        public let layout: SectionLayoutConfiguration
        /// The unique identifier of the header or footer section.
        public let sectionId: String
        /// The style options of a header or footer section.
        public let style: SectionStyle?

        public init(layout: SectionLayoutConfiguration, sectionId: String, style: SectionStyle? = nil) {
            self.layout = layout
            self.sectionId = sectionId
            self.style = style
        }

        public func validate(name: String) throws {
            try self.layout.validate(name: "\(name).layout")
            try self.validate(self.sectionId, name: "sectionId", parent: name, max: 512)
            try self.validate(self.sectionId, name: "sectionId", parent: name, min: 1)
            try self.validate(self.sectionId, name: "sectionId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case layout = "Layout"
            case sectionId = "SectionId"
            case style = "Style"
        }
    }

    public struct HeatMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The columns field well of a heat map.
        public let columns: [DimensionField]?
        /// The rows field well of a heat map.
        public let rows: [DimensionField]?
        /// The values field well of a heat map.
        public let values: [MeasureField]?

        public init(columns: [DimensionField]? = nil, rows: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.columns = columns
            self.rows = rows
            self.values = values
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 1)
            try self.rows?.forEach {
                try $0.validate(name: "\(name).rows[]")
            }
            try self.validate(self.rows, name: "rows", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case rows = "Rows"
            case values = "Values"
        }
    }

    public struct HeatMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The color options (gradient color, point of divergence) in a heat map.
        public let colorScale: ColorScale?
        /// The label options of the column that is displayed in a heat map.
        public let columnLabelOptions: ChartAxisLabelOptions?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: HeatMapFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The label options of the row that is displayed in a heat map.
        public let rowLabelOptions: ChartAxisLabelOptions?
        /// The sort configuration of a heat map.
        public let sortConfiguration: HeatMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?

        public init(colorScale: ColorScale? = nil, columnLabelOptions: ChartAxisLabelOptions? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: HeatMapFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, rowLabelOptions: ChartAxisLabelOptions? = nil, sortConfiguration: HeatMapSortConfiguration? = nil, tooltip: TooltipOptions? = nil) {
            self.colorScale = colorScale
            self.columnLabelOptions = columnLabelOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.rowLabelOptions = rowLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }

        public func validate(name: String) throws {
            try self.colorScale?.validate(name: "\(name).colorScale")
            try self.columnLabelOptions?.validate(name: "\(name).columnLabelOptions")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.rowLabelOptions?.validate(name: "\(name).rowLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
        }

        private enum CodingKeys: String, CodingKey {
            case colorScale = "ColorScale"
            case columnLabelOptions = "ColumnLabelOptions"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case rowLabelOptions = "RowLabelOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
        }
    }

    public struct HeatMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a heat map.
        public let heatMapAggregatedFieldWells: HeatMapAggregatedFieldWells?

        public init(heatMapAggregatedFieldWells: HeatMapAggregatedFieldWells? = nil) {
            self.heatMapAggregatedFieldWells = heatMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.heatMapAggregatedFieldWells?.validate(name: "\(name).heatMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case heatMapAggregatedFieldWells = "HeatMapAggregatedFieldWells"
        }
    }

    public struct HeatMapSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of columns that are displayed in a heat map.
        public let heatMapColumnItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The column sort configuration for heat map for columns that aren't a part of a field well.
        public let heatMapColumnSort: [FieldSortOptions]?
        /// The limit on the number of rows that are displayed in a heat map.
        public let heatMapRowItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The field sort configuration of the rows fields.
        public let heatMapRowSort: [FieldSortOptions]?

        public init(heatMapColumnItemsLimitConfiguration: ItemsLimitConfiguration? = nil, heatMapColumnSort: [FieldSortOptions]? = nil, heatMapRowItemsLimitConfiguration: ItemsLimitConfiguration? = nil, heatMapRowSort: [FieldSortOptions]? = nil) {
            self.heatMapColumnItemsLimitConfiguration = heatMapColumnItemsLimitConfiguration
            self.heatMapColumnSort = heatMapColumnSort
            self.heatMapRowItemsLimitConfiguration = heatMapRowItemsLimitConfiguration
            self.heatMapRowSort = heatMapRowSort
        }

        public func validate(name: String) throws {
            try self.heatMapColumnSort?.forEach {
                try $0.validate(name: "\(name).heatMapColumnSort[]")
            }
            try self.validate(self.heatMapColumnSort, name: "heatMapColumnSort", parent: name, max: 100)
            try self.heatMapRowSort?.forEach {
                try $0.validate(name: "\(name).heatMapRowSort[]")
            }
            try self.validate(self.heatMapRowSort, name: "heatMapRowSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case heatMapColumnItemsLimitConfiguration = "HeatMapColumnItemsLimitConfiguration"
            case heatMapColumnSort = "HeatMapColumnSort"
            case heatMapRowItemsLimitConfiguration = "HeatMapRowItemsLimitConfiguration"
            case heatMapRowSort = "HeatMapRowSort"
        }
    }

    public struct HeatMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a heat map.
        public let chartConfiguration: HeatMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: HeatMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct HistogramAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The value field wells of a histogram. Values are aggregated by COUNT or DISTINCT_COUNT.
        public let values: [MeasureField]?

        public init(values: [MeasureField]? = nil) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct HistogramBinOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the bin count of a histogram.
        public let binCount: BinCountOptions?
        /// The options that determine the bin width of a histogram.
        public let binWidth: BinWidthOptions?
        /// The options that determine the selected bin type.
        public let selectedBinType: HistogramBinType?
        /// The options that determine the bin start value.
        public let startValue: Double?

        public init(binCount: BinCountOptions? = nil, binWidth: BinWidthOptions? = nil, selectedBinType: HistogramBinType? = nil, startValue: Double? = nil) {
            self.binCount = binCount
            self.binWidth = binWidth
            self.selectedBinType = selectedBinType
            self.startValue = startValue
        }

        public func validate(name: String) throws {
            try self.binCount?.validate(name: "\(name).binCount")
            try self.binWidth?.validate(name: "\(name).binWidth")
        }

        private enum CodingKeys: String, CodingKey {
            case binCount = "BinCount"
            case binWidth = "BinWidth"
            case selectedBinType = "SelectedBinType"
            case startValue = "StartValue"
        }
    }

    public struct HistogramConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of histogram bins.
        public let binOptions: HistogramBinOptions?
        /// The data label configuration of a histogram.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a histogram.
        public let fieldWells: HistogramFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The tooltip configuration of a histogram.
        public let tooltip: TooltipOptions?
        /// The visual palette configuration of a histogram.
        public let visualPalette: VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public let xAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public let xAxisLabelOptions: ChartAxisLabelOptions?
        /// The options that determine the presentation of the y-axis.
        public let yAxisDisplayOptions: AxisDisplayOptions?

        public init(binOptions: HistogramBinOptions? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: HistogramFieldWells? = nil, interactions: VisualInteractionOptions? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil, xAxisDisplayOptions: AxisDisplayOptions? = nil, xAxisLabelOptions: ChartAxisLabelOptions? = nil, yAxisDisplayOptions: AxisDisplayOptions? = nil) {
            self.binOptions = binOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
        }

        public func validate(name: String) throws {
            try self.binOptions?.validate(name: "\(name).binOptions")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.xAxisDisplayOptions?.validate(name: "\(name).xAxisDisplayOptions")
            try self.xAxisLabelOptions?.validate(name: "\(name).xAxisLabelOptions")
            try self.yAxisDisplayOptions?.validate(name: "\(name).yAxisDisplayOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case binOptions = "BinOptions"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
            case xAxisDisplayOptions = "XAxisDisplayOptions"
            case xAxisLabelOptions = "XAxisLabelOptions"
            case yAxisDisplayOptions = "YAxisDisplayOptions"
        }
    }

    public struct HistogramFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a histogram.
        public let histogramAggregatedFieldWells: HistogramAggregatedFieldWells?

        public init(histogramAggregatedFieldWells: HistogramAggregatedFieldWells? = nil) {
            self.histogramAggregatedFieldWells = histogramAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.histogramAggregatedFieldWells?.validate(name: "\(name).histogramAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case histogramAggregatedFieldWells = "HistogramAggregatedFieldWells"
        }
    }

    public struct HistogramVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration for a HistogramVisual.
        public let chartConfiguration: HistogramConfiguration?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: HistogramConfiguration? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct IAMPolicyAssignment: AWSDecodableShape {
        /// Assignment ID.
        public let assignmentId: String?
        /// Assignment name.
        public let assignmentName: String?
        /// Assignment status.
        public let assignmentStatus: AssignmentStatus?
        /// The Amazon Web Services account ID.
        public let awsAccountId: String?
        /// Identities.
        public let identities: [String: [String]]?
        /// The Amazon Resource Name (ARN) for the IAM policy.
        public let policyArn: String?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, awsAccountId: String? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.policyArn = policyArn
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case awsAccountId = "AwsAccountId"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct IAMPolicyAssignmentSummary: AWSDecodableShape {
        /// Assignment name.
        public let assignmentName: String?
        /// Assignment status.
        public let assignmentStatus: AssignmentStatus?

        public init(assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
        }
    }

    public struct IdentityCenterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean option that controls whether Trusted Identity Propagation should be used.
        public let enableIdentityPropagation: Bool?

        public init(enableIdentityPropagation: Bool? = nil) {
            self.enableIdentityPropagation = enableIdentityPropagation
        }

        private enum CodingKeys: String, CodingKey {
            case enableIdentityPropagation = "EnableIdentityPropagation"
        }
    }

    public struct IncrementalRefresh: AWSEncodableShape & AWSDecodableShape {
        /// The lookback window setup for an incremental refresh configuration.
        public let lookbackWindow: LookbackWindow

        public init(lookbackWindow: LookbackWindow) {
            self.lookbackWindow = lookbackWindow
        }

        public func validate(name: String) throws {
            try self.lookbackWindow.validate(name: "\(name).lookbackWindow")
        }

        private enum CodingKeys: String, CodingKey {
            case lookbackWindow = "LookbackWindow"
        }
    }

    public struct Ingestion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// The time that this ingestion started.
        public let createdTime: Date
        /// Error information for this ingestion.
        public let errorInfo: ErrorInfo?
        /// Ingestion ID.
        public let ingestionId: String?
        /// The size of the data ingested, in bytes.
        public let ingestionSizeInBytes: Int64?
        /// Ingestion status.
        public let ingestionStatus: IngestionStatus
        /// The time that this ingestion took, measured in seconds.
        public let ingestionTimeInSeconds: Int64?
        public let queueInfo: QueueInfo?
        /// Event source for this ingestion.
        public let requestSource: IngestionRequestSource?
        /// Type of this ingestion.
        public let requestType: IngestionRequestType?
        public let rowInfo: RowInfo?

        public init(arn: String, createdTime: Date, errorInfo: ErrorInfo? = nil, ingestionId: String? = nil, ingestionSizeInBytes: Int64? = nil, ingestionStatus: IngestionStatus, ingestionTimeInSeconds: Int64? = nil, queueInfo: QueueInfo? = nil, requestSource: IngestionRequestSource? = nil, requestType: IngestionRequestType? = nil, rowInfo: RowInfo? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.errorInfo = errorInfo
            self.ingestionId = ingestionId
            self.ingestionSizeInBytes = ingestionSizeInBytes
            self.ingestionStatus = ingestionStatus
            self.ingestionTimeInSeconds = ingestionTimeInSeconds
            self.queueInfo = queueInfo
            self.requestSource = requestSource
            self.requestType = requestType
            self.rowInfo = rowInfo
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case errorInfo = "ErrorInfo"
            case ingestionId = "IngestionId"
            case ingestionSizeInBytes = "IngestionSizeInBytes"
            case ingestionStatus = "IngestionStatus"
            case ingestionTimeInSeconds = "IngestionTimeInSeconds"
            case queueInfo = "QueueInfo"
            case requestSource = "RequestSource"
            case requestType = "RequestType"
            case rowInfo = "RowInfo"
        }
    }

    public struct InputColumn: AWSEncodableShape & AWSDecodableShape {
        /// The name of this column in the underlying data source.
        public let name: String
        /// The sub data type of the column. Sub types are only available for decimal columns that are part of a SPICE dataset.
        public let subType: ColumnDataSubType?
        /// The data type of the column.
        public let type: InputColumnDataType

        public init(name: String, subType: ColumnDataSubType? = nil, type: InputColumnDataType) {
            self.name = name
            self.subType = subType
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case subType = "SubType"
            case type = "Type"
        }
    }

    public struct InsightConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The computations configurations of the insight visual
        public let computations: [Computation]?
        /// The custom narrative of the insight visual.
        public let customNarrative: CustomNarrativeOptions?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?

        public init(computations: [Computation]? = nil, customNarrative: CustomNarrativeOptions? = nil, interactions: VisualInteractionOptions? = nil) {
            self.computations = computations
            self.customNarrative = customNarrative
            self.interactions = interactions
        }

        public func validate(name: String) throws {
            try self.computations?.forEach {
                try $0.validate(name: "\(name).computations[]")
            }
            try self.validate(self.computations, name: "computations", parent: name, max: 100)
            try self.customNarrative?.validate(name: "\(name).customNarrative")
        }

        private enum CodingKeys: String, CodingKey {
            case computations = "Computations"
            case customNarrative = "CustomNarrative"
            case interactions = "Interactions"
        }
    }

    public struct InsightVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The dataset that is used in the insight visual.
        public let dataSetIdentifier: String
        /// The configuration of an insight visual.
        public let insightConfiguration: InsightConfiguration?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, dataSetIdentifier: String, insightConfiguration: InsightConfiguration? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.insightConfiguration = insightConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.insightConfiguration?.validate(name: "\(name).insightConfiguration")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case dataSetIdentifier = "DataSetIdentifier"
            case insightConfiguration = "InsightConfiguration"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct IntegerDatasetParameter: AWSEncodableShape & AWSDecodableShape {
        /// A list of default values for a given integer parameter. This structure only accepts static values.
        public let defaultValues: IntegerDatasetParameterDefaultValues?
        /// An identifier for the integer parameter created in the dataset.
        public let id: String
        /// The name of the integer parameter that is created in the dataset.
        public let name: String
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        public let valueType: DatasetParameterValueType

        public init(defaultValues: IntegerDatasetParameterDefaultValues? = nil, id: String, name: String, valueType: DatasetParameterValueType) {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.valueType = valueType
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case id = "Id"
            case name = "Name"
            case valueType = "ValueType"
        }
    }

    public struct IntegerDatasetParameterDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// A list of static default values for a given integer parameter.
        public let staticValues: [Int64]?

        public init(staticValues: [Int64]? = nil) {
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 32)
            try self.validate(self.staticValues, name: "staticValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case staticValues = "StaticValues"
        }
    }

    public struct IntegerDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the IntegerDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The static values of the IntegerDefaultValues.
        public let staticValues: [Int64]?

        public init(dynamicValue: DynamicDefaultValue? = nil, staticValues: [Int64]? = nil) {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case staticValues = "StaticValues"
        }
    }

    public struct IntegerParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the integer parameter.
        public let name: String
        /// The values for the integer parameter.
        public let values: [Int64]

        public init(name: String, values: [Int64]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct IntegerParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: IntegerDefaultValues?
        public let mappedDataSetParameters: [MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        public let parameterValueType: ParameterValueType
        /// A parameter declaration for the Integer data type.
        public let valueWhenUnset: IntegerValueWhenUnsetConfiguration?

        public init(defaultValues: IntegerDefaultValues? = nil, mappedDataSetParameters: [MappedDataSetParameter]? = nil, name: String, parameterValueType: ParameterValueType, valueWhenUnset: IntegerValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.mappedDataSetParameters?.forEach {
                try $0.validate(name: "\(name).mappedDataSetParameters[]")
            }
            try self.validate(self.mappedDataSetParameters, name: "mappedDataSetParameters", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case mappedDataSetParameters = "MappedDataSetParameters"
            case name = "Name"
            case parameterValueType = "ParameterValueType"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct IntegerValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: Int64?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: Int64? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct ItemsLimitConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.
        public let itemsLimit: Int64?
        /// The Show other of an axis in the chart. Choose one of the following options:    INCLUDE     EXCLUDE
        public let otherCategories: OtherCategories?

        public init(itemsLimit: Int64? = nil, otherCategories: OtherCategories? = nil) {
            self.itemsLimit = itemsLimit
            self.otherCategories = otherCategories
        }

        private enum CodingKeys: String, CodingKey {
            case itemsLimit = "ItemsLimit"
            case otherCategories = "OtherCategories"
        }
    }

    public struct JiraParameters: AWSEncodableShape & AWSDecodableShape {
        /// The base URL of the Jira site.
        public let siteBaseUrl: String

        public init(siteBaseUrl: String) {
            self.siteBaseUrl = siteBaseUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, max: 1024)
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case siteBaseUrl = "SiteBaseUrl"
        }
    }

    public struct JoinInstruction: AWSEncodableShape & AWSDecodableShape {
        /// Join key properties of the left operand.
        public let leftJoinKeyProperties: JoinKeyProperties?
        /// The operand on the left side of a join.
        public let leftOperand: String
        /// The join instructions provided in the ON clause of a join.
        public let onClause: String
        /// Join key properties of the right operand.
        public let rightJoinKeyProperties: JoinKeyProperties?
        /// The operand on the right side of a join.
        public let rightOperand: String
        /// The type of join that it is.
        public let type: JoinType

        public init(leftJoinKeyProperties: JoinKeyProperties? = nil, leftOperand: String, onClause: String, rightJoinKeyProperties: JoinKeyProperties? = nil, rightOperand: String, type: JoinType) {
            self.leftJoinKeyProperties = leftJoinKeyProperties
            self.leftOperand = leftOperand
            self.onClause = onClause
            self.rightJoinKeyProperties = rightJoinKeyProperties
            self.rightOperand = rightOperand
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, max: 64)
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, min: 1)
            try self.validate(self.leftOperand, name: "leftOperand", parent: name, pattern: "^[0-9a-zA-Z-]*$")
            try self.validate(self.onClause, name: "onClause", parent: name, max: 512)
            try self.validate(self.onClause, name: "onClause", parent: name, min: 1)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, max: 64)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, min: 1)
            try self.validate(self.rightOperand, name: "rightOperand", parent: name, pattern: "^[0-9a-zA-Z-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case leftJoinKeyProperties = "LeftJoinKeyProperties"
            case leftOperand = "LeftOperand"
            case onClause = "OnClause"
            case rightJoinKeyProperties = "RightJoinKeyProperties"
            case rightOperand = "RightOperand"
            case type = "Type"
        }
    }

    public struct JoinKeyProperties: AWSEncodableShape & AWSDecodableShape {
        /// A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        public let uniqueKey: Bool?

        public init(uniqueKey: Bool? = nil) {
            self.uniqueKey = uniqueKey
        }

        private enum CodingKeys: String, CodingKey {
            case uniqueKey = "UniqueKey"
        }
    }

    public struct KPIActualValueConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the actual value's icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting of the actual value's text color.
        public let textColor: ConditionalFormattingColor?

        public init(icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct KPIComparisonValueConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the comparison value's icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting of the comparison value's text color.
        public let textColor: ConditionalFormattingColor?

        public init(icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct KPIConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting options of a KPI visual.
        public let conditionalFormattingOptions: [KPIConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [KPIConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct KPIConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting for the actual value of a KPI visual.
        public let actualValue: KPIActualValueConditionalFormatting?
        /// The conditional formatting for the comparison value of a KPI visual.
        public let comparisonValue: KPIComparisonValueConditionalFormatting?
        /// The conditional formatting for the primary value of a KPI visual.
        public let primaryValue: KPIPrimaryValueConditionalFormatting?
        /// The conditional formatting for the progress bar of a KPI visual.
        public let progressBar: KPIProgressBarConditionalFormatting?

        public init(actualValue: KPIActualValueConditionalFormatting? = nil, comparisonValue: KPIComparisonValueConditionalFormatting? = nil, primaryValue: KPIPrimaryValueConditionalFormatting? = nil, progressBar: KPIProgressBarConditionalFormatting? = nil) {
            self.actualValue = actualValue
            self.comparisonValue = comparisonValue
            self.primaryValue = primaryValue
            self.progressBar = progressBar
        }

        public func validate(name: String) throws {
            try self.actualValue?.validate(name: "\(name).actualValue")
            try self.comparisonValue?.validate(name: "\(name).comparisonValue")
            try self.primaryValue?.validate(name: "\(name).primaryValue")
            try self.progressBar?.validate(name: "\(name).progressBar")
        }

        private enum CodingKeys: String, CodingKey {
            case actualValue = "ActualValue"
            case comparisonValue = "ComparisonValue"
            case primaryValue = "PrimaryValue"
            case progressBar = "ProgressBar"
        }
    }

    public struct KPIConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a KPI visual.
        public let fieldWells: KPIFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The options that determine the presentation of a KPI visual.
        public let kpiOptions: KPIOptions?
        /// The sort configuration of a KPI visual.
        public let sortConfiguration: KPISortConfiguration?

        public init(fieldWells: KPIFieldWells? = nil, interactions: VisualInteractionOptions? = nil, kpiOptions: KPIOptions? = nil, sortConfiguration: KPISortConfiguration? = nil) {
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.kpiOptions = kpiOptions
            self.sortConfiguration = sortConfiguration
        }

        public func validate(name: String) throws {
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.kpiOptions?.validate(name: "\(name).kpiOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case kpiOptions = "KPIOptions"
            case sortConfiguration = "SortConfiguration"
        }
    }

    public struct KPIFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The target value field wells of a KPI visual.
        public let targetValues: [MeasureField]?
        /// The trend group field wells of a KPI visual.
        public let trendGroups: [DimensionField]?
        /// The value field wells of a KPI visual.
        public let values: [MeasureField]?

        public init(targetValues: [MeasureField]? = nil, trendGroups: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.targetValues = targetValues
            self.trendGroups = trendGroups
            self.values = values
        }

        public func validate(name: String) throws {
            try self.targetValues?.forEach {
                try $0.validate(name: "\(name).targetValues[]")
            }
            try self.validate(self.targetValues, name: "targetValues", parent: name, max: 200)
            try self.trendGroups?.forEach {
                try $0.validate(name: "\(name).trendGroups[]")
            }
            try self.validate(self.trendGroups, name: "trendGroups", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case targetValues = "TargetValues"
            case trendGroups = "TrendGroups"
            case values = "Values"
        }
    }

    public struct KPIOptions: AWSEncodableShape & AWSDecodableShape {
        /// The comparison configuration of a KPI visual.
        public let comparison: ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public let primaryValueDisplayType: PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public let primaryValueFontConfiguration: FontConfiguration?
        /// The options that determine the presentation of the progress bar of a KPI visual.
        public let progressBar: ProgressBarOptions?
        /// The options that determine the presentation of the secondary value of a KPI visual.
        public let secondaryValue: SecondaryValueOptions?
        /// The options that determine the secondary value font configuration.
        public let secondaryValueFontConfiguration: FontConfiguration?
        /// The options that determine the visibility, color, type, and tooltip visibility of the sparkline of a KPI visual.
        public let sparkline: KPISparklineOptions?
        /// The options that determine the presentation of trend arrows in a KPI visual.
        public let trendArrows: TrendArrowOptions?
        /// The options that determine the layout a KPI visual.
        public let visualLayoutOptions: KPIVisualLayoutOptions?

        public init(comparison: ComparisonConfiguration? = nil, primaryValueDisplayType: PrimaryValueDisplayType? = nil, primaryValueFontConfiguration: FontConfiguration? = nil, progressBar: ProgressBarOptions? = nil, secondaryValue: SecondaryValueOptions? = nil, secondaryValueFontConfiguration: FontConfiguration? = nil, sparkline: KPISparklineOptions? = nil, trendArrows: TrendArrowOptions? = nil, visualLayoutOptions: KPIVisualLayoutOptions? = nil) {
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
            self.progressBar = progressBar
            self.secondaryValue = secondaryValue
            self.secondaryValueFontConfiguration = secondaryValueFontConfiguration
            self.sparkline = sparkline
            self.trendArrows = trendArrows
            self.visualLayoutOptions = visualLayoutOptions
        }

        public func validate(name: String) throws {
            try self.comparison?.validate(name: "\(name).comparison")
            try self.primaryValueFontConfiguration?.validate(name: "\(name).primaryValueFontConfiguration")
            try self.secondaryValueFontConfiguration?.validate(name: "\(name).secondaryValueFontConfiguration")
            try self.sparkline?.validate(name: "\(name).sparkline")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case primaryValueDisplayType = "PrimaryValueDisplayType"
            case primaryValueFontConfiguration = "PrimaryValueFontConfiguration"
            case progressBar = "ProgressBar"
            case secondaryValue = "SecondaryValue"
            case secondaryValueFontConfiguration = "SecondaryValueFontConfiguration"
            case sparkline = "Sparkline"
            case trendArrows = "TrendArrows"
            case visualLayoutOptions = "VisualLayoutOptions"
        }
    }

    public struct KPIPrimaryValueConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the primary value's icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting of the  primary value's text color.
        public let textColor: ConditionalFormattingColor?

        public init(icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct KPIProgressBarConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting of the progress bar's foreground color.
        public let foregroundColor: ConditionalFormattingColor?

        public init(foregroundColor: ConditionalFormattingColor? = nil) {
            self.foregroundColor = foregroundColor
        }

        public func validate(name: String) throws {
            try self.foregroundColor?.validate(name: "\(name).foregroundColor")
        }

        private enum CodingKeys: String, CodingKey {
            case foregroundColor = "ForegroundColor"
        }
    }

    public struct KPISortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sort configuration of the trend group fields.
        public let trendGroupSort: [FieldSortOptions]?

        public init(trendGroupSort: [FieldSortOptions]? = nil) {
            self.trendGroupSort = trendGroupSort
        }

        public func validate(name: String) throws {
            try self.trendGroupSort?.forEach {
                try $0.validate(name: "\(name).trendGroupSort[]")
            }
            try self.validate(self.trendGroupSort, name: "trendGroupSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case trendGroupSort = "TrendGroupSort"
        }
    }

    public struct KPISparklineOptions: AWSEncodableShape & AWSDecodableShape {
        /// The color of the sparkline.
        public let color: String?
        /// The tooltip visibility of the sparkline.
        public let tooltipVisibility: Visibility?
        /// The type of the sparkline.
        public let type: KPISparklineType
        /// The visibility of the sparkline.
        public let visibility: Visibility?

        public init(color: String? = nil, tooltipVisibility: Visibility? = nil, type: KPISparklineType, visibility: Visibility? = nil) {
            self.color = color
            self.tooltipVisibility = tooltipVisibility
            self.type = type
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case tooltipVisibility = "TooltipVisibility"
            case type = "Type"
            case visibility = "Visibility"
        }
    }

    public struct KPIVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a KPI visual.
        public let chartConfiguration: KPIConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The conditional formatting of a KPI visual.
        public let conditionalFormatting: KPIConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: KPIConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, conditionalFormatting: KPIConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct KPIVisualLayoutOptions: AWSEncodableShape & AWSDecodableShape {
        /// The standard layout of the KPI visual.
        public let standardLayout: KPIVisualStandardLayout?

        public init(standardLayout: KPIVisualStandardLayout? = nil) {
            self.standardLayout = standardLayout
        }

        private enum CodingKeys: String, CodingKey {
            case standardLayout = "StandardLayout"
        }
    }

    public struct KPIVisualStandardLayout: AWSEncodableShape & AWSDecodableShape {
        /// The standard layout type.
        public let type: KPIVisualStandardLayoutType

        public init(type: KPIVisualStandardLayoutType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct LabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The text for the label.
        public let customLabel: String?
        /// The font configuration of the label.
        public let fontConfiguration: FontConfiguration?
        /// Determines whether or not the label is visible.
        public let visibility: Visibility?

        public init(customLabel: String? = nil, fontConfiguration: FontConfiguration? = nil, visibility: Visibility? = nil) {
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fontConfiguration = "FontConfiguration"
            case visibility = "Visibility"
        }
    }

    public struct Layout: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that determines what the type of layout for a sheet.
        public let configuration: LayoutConfiguration

        public init(configuration: LayoutConfiguration) {
            self.configuration = configuration
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct LayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.
        public let freeFormLayout: FreeFormLayoutConfiguration?
        /// A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: FIXED or RESPONSIVE.
        public let gridLayout: GridLayoutConfiguration?
        /// A section based layout organizes visuals into multiple sections and has customized header, footer and page break.
        public let sectionBasedLayout: SectionBasedLayoutConfiguration?

        public init(freeFormLayout: FreeFormLayoutConfiguration? = nil, gridLayout: GridLayoutConfiguration? = nil, sectionBasedLayout: SectionBasedLayoutConfiguration? = nil) {
            self.freeFormLayout = freeFormLayout
            self.gridLayout = gridLayout
            self.sectionBasedLayout = sectionBasedLayout
        }

        public func validate(name: String) throws {
            try self.freeFormLayout?.validate(name: "\(name).freeFormLayout")
            try self.gridLayout?.validate(name: "\(name).gridLayout")
            try self.sectionBasedLayout?.validate(name: "\(name).sectionBasedLayout")
        }

        private enum CodingKeys: String, CodingKey {
            case freeFormLayout = "FreeFormLayout"
            case gridLayout = "GridLayout"
            case sectionBasedLayout = "SectionBasedLayout"
        }
    }

    public struct LegendOptions: AWSEncodableShape & AWSDecodableShape {
        /// The height of the legend. If this value is omitted, a default height is used when rendering.
        public let height: String?
        /// The positions for the legend. Choose one of the following options:    AUTO     RIGHT     BOTTOM     LEFT
        public let position: LegendPosition?
        /// The custom title for the legend.
        public let title: LabelOptions?
        /// Determines whether or not the legend is visible.
        public let visibility: Visibility?
        /// The width of the legend. If this value is omitted, a default width is used when rendering.
        public let width: String?

        public init(height: String? = nil, position: LegendPosition? = nil, title: LabelOptions? = nil, visibility: Visibility? = nil, width: String? = nil) {
            self.height = height
            self.position = position
            self.title = title
            self.visibility = visibility
            self.width = width
        }

        public func validate(name: String) throws {
            try self.title?.validate(name: "\(name).title")
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case position = "Position"
            case title = "Title"
            case visibility = "Visibility"
            case width = "Width"
        }
    }

    public struct LineChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category field wells of a line chart. Values are grouped by category fields.
        public let category: [DimensionField]?
        /// The color field wells of a line chart. Values are grouped by category fields.
        public let colors: [DimensionField]?
        /// The small multiples field well of a line chart.
        public let smallMultiples: [DimensionField]?
        /// The value field wells of a line chart. Values are aggregated based on categories.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, colors: [DimensionField]? = nil, smallMultiples: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 200)
            try self.smallMultiples?.forEach {
                try $0.validate(name: "\(name).smallMultiples[]")
            }
            try self.validate(self.smallMultiples, name: "smallMultiples", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case colors = "Colors"
            case smallMultiples = "SmallMultiples"
            case values = "Values"
        }
    }

    public struct LineChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The default configuration of a line chart's contribution analysis.
        public let contributionAnalysisDefaults: [ContributionAnalysisDefault]?
        /// The data label configuration of a line chart.
        public let dataLabels: DataLabelOptions?
        /// The options that determine the default presentation of all line series in LineChartVisual.
        public let defaultSeriesSettings: LineChartDefaultSeriesSettings?
        /// The field well configuration of a line chart.
        public let fieldWells: LineChartFieldWells?
        /// The forecast configuration of a line chart.
        public let forecastConfigurations: [ForecastConfiguration]?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend configuration of a line chart.
        public let legend: LegendOptions?
        /// The series axis configuration of a line chart.
        public let primaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The reference lines configuration of a line chart.
        public let referenceLines: [ReferenceLine]?
        /// The series axis configuration of a line chart.
        public let secondaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the secondary y-axis label.
        public let secondaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The series item configuration of a line chart.
        public let series: [SeriesItem]?
        public let singleAxisOptions: SingleAxisOptions?
        /// The small multiples setup for the visual.
        public let smallMultiplesOptions: SmallMultiplesOptions?
        /// The sort configuration of a line chart.
        public let sortConfiguration: LineChartSortConfiguration?
        /// The tooltip configuration of a line chart.
        public let tooltip: TooltipOptions?
        /// Determines the type of the line chart.
        public let type: LineChartType?
        /// The visual palette configuration of a line chart.
        public let visualPalette: VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public let xAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public let xAxisLabelOptions: ChartAxisLabelOptions?

        public init(contributionAnalysisDefaults: [ContributionAnalysisDefault]? = nil, dataLabels: DataLabelOptions? = nil, defaultSeriesSettings: LineChartDefaultSeriesSettings? = nil, fieldWells: LineChartFieldWells? = nil, forecastConfigurations: [ForecastConfiguration]? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, primaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, referenceLines: [ReferenceLine]? = nil, secondaryYAxisDisplayOptions: LineSeriesAxisDisplayOptions? = nil, secondaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, series: [SeriesItem]? = nil, singleAxisOptions: SingleAxisOptions? = nil, smallMultiplesOptions: SmallMultiplesOptions? = nil, sortConfiguration: LineChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, type: LineChartType? = nil, visualPalette: VisualPalette? = nil, xAxisDisplayOptions: AxisDisplayOptions? = nil, xAxisLabelOptions: ChartAxisLabelOptions? = nil) {
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.defaultSeriesSettings = defaultSeriesSettings
            self.fieldWells = fieldWells
            self.forecastConfigurations = forecastConfigurations
            self.interactions = interactions
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.series = series
            self.singleAxisOptions = singleAxisOptions
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.type = type
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
        }

        public func validate(name: String) throws {
            try self.contributionAnalysisDefaults?.forEach {
                try $0.validate(name: "\(name).contributionAnalysisDefaults[]")
            }
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, max: 200)
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, min: 1)
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.defaultSeriesSettings?.validate(name: "\(name).defaultSeriesSettings")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.forecastConfigurations?.forEach {
                try $0.validate(name: "\(name).forecastConfigurations[]")
            }
            try self.validate(self.forecastConfigurations, name: "forecastConfigurations", parent: name, max: 10)
            try self.legend?.validate(name: "\(name).legend")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.referenceLines?.forEach {
                try $0.validate(name: "\(name).referenceLines[]")
            }
            try self.validate(self.referenceLines, name: "referenceLines", parent: name, max: 20)
            try self.secondaryYAxisDisplayOptions?.validate(name: "\(name).secondaryYAxisDisplayOptions")
            try self.secondaryYAxisLabelOptions?.validate(name: "\(name).secondaryYAxisLabelOptions")
            try self.series?.forEach {
                try $0.validate(name: "\(name).series[]")
            }
            try self.validate(self.series, name: "series", parent: name, max: 10)
            try self.smallMultiplesOptions?.validate(name: "\(name).smallMultiplesOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.xAxisDisplayOptions?.validate(name: "\(name).xAxisDisplayOptions")
            try self.xAxisLabelOptions?.validate(name: "\(name).xAxisLabelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
            case dataLabels = "DataLabels"
            case defaultSeriesSettings = "DefaultSeriesSettings"
            case fieldWells = "FieldWells"
            case forecastConfigurations = "ForecastConfigurations"
            case interactions = "Interactions"
            case legend = "Legend"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case referenceLines = "ReferenceLines"
            case secondaryYAxisDisplayOptions = "SecondaryYAxisDisplayOptions"
            case secondaryYAxisLabelOptions = "SecondaryYAxisLabelOptions"
            case series = "Series"
            case singleAxisOptions = "SingleAxisOptions"
            case smallMultiplesOptions = "SmallMultiplesOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case type = "Type"
            case visualPalette = "VisualPalette"
            case xAxisDisplayOptions = "XAxisDisplayOptions"
            case xAxisLabelOptions = "XAxisLabelOptions"
        }
    }

    public struct LineChartDefaultSeriesSettings: AWSEncodableShape & AWSDecodableShape {
        /// The axis to which you are binding all line series to.
        public let axisBinding: AxisBinding?
        /// Line styles options for all line series in the visual.
        public let lineStyleSettings: LineChartLineStyleSettings?
        /// Marker styles options for all line series in the visual.
        public let markerStyleSettings: LineChartMarkerStyleSettings?

        public init(axisBinding: AxisBinding? = nil, lineStyleSettings: LineChartLineStyleSettings? = nil, markerStyleSettings: LineChartMarkerStyleSettings? = nil) {
            self.axisBinding = axisBinding
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }

        public func validate(name: String) throws {
            try self.markerStyleSettings?.validate(name: "\(name).markerStyleSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case lineStyleSettings = "LineStyleSettings"
            case markerStyleSettings = "MarkerStyleSettings"
        }
    }

    public struct LineChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a line chart.
        public let lineChartAggregatedFieldWells: LineChartAggregatedFieldWells?

        public init(lineChartAggregatedFieldWells: LineChartAggregatedFieldWells? = nil) {
            self.lineChartAggregatedFieldWells = lineChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.lineChartAggregatedFieldWells?.validate(name: "\(name).lineChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case lineChartAggregatedFieldWells = "LineChartAggregatedFieldWells"
        }
    }

    public struct LineChartLineStyleSettings: AWSEncodableShape & AWSDecodableShape {
        /// Interpolation style for line series.    LINEAR: Show as default, linear style.    SMOOTH: Show as a smooth curve.    STEPPED: Show steps in line.
        public let lineInterpolation: LineInterpolation?
        /// Line style for line series.    SOLID: Show as a solid line.    DOTTED: Show as a dotted line.    DASHED: Show as a dashed line.
        public let lineStyle: LineChartLineStyle?
        /// Configuration option that determines whether to show the line for the series.
        public let lineVisibility: Visibility?
        /// Width that determines the line thickness.
        public let lineWidth: String?

        public init(lineInterpolation: LineInterpolation? = nil, lineStyle: LineChartLineStyle? = nil, lineVisibility: Visibility? = nil, lineWidth: String? = nil) {
            self.lineInterpolation = lineInterpolation
            self.lineStyle = lineStyle
            self.lineVisibility = lineVisibility
            self.lineWidth = lineWidth
        }

        private enum CodingKeys: String, CodingKey {
            case lineInterpolation = "LineInterpolation"
            case lineStyle = "LineStyle"
            case lineVisibility = "LineVisibility"
            case lineWidth = "LineWidth"
        }
    }

    public struct LineChartMarkerStyleSettings: AWSEncodableShape & AWSDecodableShape {
        /// Color of marker in the series.
        public let markerColor: String?
        /// Shape option for markers in the series.    CIRCLE: Show marker as a circle.    TRIANGLE: Show marker as a triangle.    SQUARE: Show marker as a square.    DIAMOND: Show marker as a diamond.    ROUNDED_SQUARE: Show marker as a rounded square.
        public let markerShape: LineChartMarkerShape?
        /// Size of marker in the series.
        public let markerSize: String?
        /// Configuration option that determines whether to show the markers in the series.
        public let markerVisibility: Visibility?

        public init(markerColor: String? = nil, markerShape: LineChartMarkerShape? = nil, markerSize: String? = nil, markerVisibility: Visibility? = nil) {
            self.markerColor = markerColor
            self.markerShape = markerShape
            self.markerSize = markerSize
            self.markerVisibility = markerVisibility
        }

        public func validate(name: String) throws {
            try self.validate(self.markerColor, name: "markerColor", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case markerColor = "MarkerColor"
            case markerShape = "MarkerShape"
            case markerSize = "MarkerSize"
            case markerVisibility = "MarkerVisibility"
        }
    }

    public struct LineChartSeriesSettings: AWSEncodableShape & AWSDecodableShape {
        /// Line styles options for a line series in LineChartVisual.
        public let lineStyleSettings: LineChartLineStyleSettings?
        /// Marker styles options for a line series in LineChartVisual.
        public let markerStyleSettings: LineChartMarkerStyleSettings?

        public init(lineStyleSettings: LineChartLineStyleSettings? = nil, markerStyleSettings: LineChartMarkerStyleSettings? = nil) {
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }

        public func validate(name: String) throws {
            try self.markerStyleSettings?.validate(name: "\(name).markerStyleSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case lineStyleSettings = "LineStyleSettings"
            case markerStyleSettings = "MarkerStyleSettings"
        }
    }

    public struct LineChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories that are displayed in a line chart.
        public let categoryItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?
        /// The limit on the number of lines that are displayed in a line chart.
        public let colorItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The limit on the number of small multiples panels that are displayed.
        public let smallMultiplesLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public let smallMultiplesSort: [FieldSortOptions]?

        public init(categoryItemsLimitConfiguration: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, colorItemsLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimitConfiguration = categoryItemsLimitConfiguration
            self.categorySort = categorySort
            self.colorItemsLimitConfiguration = colorItemsLimitConfiguration
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.smallMultiplesSort?.forEach {
                try $0.validate(name: "\(name).smallMultiplesSort[]")
            }
            try self.validate(self.smallMultiplesSort, name: "smallMultiplesSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimitConfiguration = "CategoryItemsLimitConfiguration"
            case categorySort = "CategorySort"
            case colorItemsLimitConfiguration = "ColorItemsLimitConfiguration"
            case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
            case smallMultiplesSort = "SmallMultiplesSort"
        }
    }

    public struct LineChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a line chart.
        public let chartConfiguration: LineChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: LineChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct LineSeriesAxisDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of the line series axis.
        public let axisOptions: AxisDisplayOptions?
        /// The configuration options that determine how missing data is treated during the rendering of a line chart.
        public let missingDataConfigurations: [MissingDataConfiguration]?

        public init(axisOptions: AxisDisplayOptions? = nil, missingDataConfigurations: [MissingDataConfiguration]? = nil) {
            self.axisOptions = axisOptions
            self.missingDataConfigurations = missingDataConfigurations
        }

        public func validate(name: String) throws {
            try self.axisOptions?.validate(name: "\(name).axisOptions")
            try self.validate(self.missingDataConfigurations, name: "missingDataConfigurations", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case axisOptions = "AxisOptions"
            case missingDataConfigurations = "MissingDataConfigurations"
        }
    }

    public struct LinkSharingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains the permissions of a shareable link.
        public let permissions: [ResourcePermission]?

        public init(permissions: [ResourcePermission]? = nil) {
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.permissions?.forEach {
                try $0.validate(name: "\(name).permissions[]")
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 64)
            try self.validate(self.permissions, name: "permissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
        }
    }

    public struct ListAnalysesRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the analyses.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalysesResponse: AWSDecodableShape {
        /// Metadata describing each of the analyses that are listed.
        public let analysisSummaryList: [AnalysisSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisSummaryList: [AnalysisSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisSummaryList = analysisSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisSummaryList = try container.decodeIfPresent([AnalysisSummary].self, forKey: .analysisSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSummaryList = "AnalysisSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListAssetBundleExportJobsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that the export jobs were executed in.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetBundleExportJobsResponse: AWSDecodableShape {
        /// A list of export job summaries.
        public let assetBundleExportJobSummaryList: [AssetBundleExportJobSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assetBundleExportJobSummaryList: [AssetBundleExportJobSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assetBundleExportJobSummaryList = assetBundleExportJobSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.assetBundleExportJobSummaryList = try container.decodeIfPresent([AssetBundleExportJobSummary].self, forKey: .assetBundleExportJobSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case assetBundleExportJobSummaryList = "AssetBundleExportJobSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListAssetBundleImportJobsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that the import jobs were executed in.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetBundleImportJobsResponse: AWSDecodableShape {
        /// A list of import job summaries.
        public let assetBundleImportJobSummaryList: [AssetBundleImportJobSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the response.
        public let status: Int?

        public init(assetBundleImportJobSummaryList: [AssetBundleImportJobSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assetBundleImportJobSummaryList = assetBundleImportJobSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.assetBundleImportJobSummaryList = try container.decodeIfPresent([AssetBundleImportJobSummary].self, forKey: .assetBundleImportJobSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case assetBundleImportJobSummaryList = "AssetBundleImportJobSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of info icon label options.
        public let infoIconLabelOptions: SheetControlInfoIconLabelOptions?
        /// The configuration of the search options in a list control.
        public let searchOptions: ListControlSearchOptions?
        /// The configuration of the Select all options in a list control.
        public let selectAllOptions: ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(infoIconLabelOptions: SheetControlInfoIconLabelOptions? = nil, searchOptions: ListControlSearchOptions? = nil, selectAllOptions: ListControlSelectAllOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.searchOptions = searchOptions
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.infoIconLabelOptions?.validate(name: "\(name).infoIconLabelOptions")
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case infoIconLabelOptions = "InfoIconLabelOptions"
            case searchOptions = "SearchOptions"
            case selectAllOptions = "SelectAllOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct ListControlSearchOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of the search options in a list control.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct ListControlSelectAllOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of the Select all options in a list control.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct ListDashboardVersionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboard that you're listing versions for.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, dashboardId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardVersionsResponse: AWSDecodableShape {
        /// A structure that contains information about each version of the dashboard.
        public let dashboardVersionSummaryList: [DashboardVersionSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardVersionSummaryList: [DashboardVersionSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardVersionSummaryList = dashboardVersionSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardVersionSummaryList = try container.decodeIfPresent([DashboardVersionSummary].self, forKey: .dashboardVersionSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardVersionSummaryList = "DashboardVersionSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboards that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {
        /// A structure that contains all of the dashboards in your Amazon Web Services account. This structure provides basic information about the dashboards.
        public let dashboardSummaryList: [DashboardSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardSummaryList: [DashboardSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardSummaryList = dashboardSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardSummaryList = try container.decodeIfPresent([DashboardSummary].self, forKey: .dashboardSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaryList = "DashboardSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListDataSetsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetsResponse: AWSDecodableShape {
        /// The list of dataset summaries.
        public let dataSetSummaries: [DataSetSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetSummaries: [DataSetSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetSummaries = dataSetSummaries
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSetSummaries = try container.decodeIfPresent([DataSetSummary].self, forKey: .dataSetSummaries)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetSummaries = "DataSetSummaries"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// A list of data sources.
        public let dataSources: [DataSource]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSources: [DataSource]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSources = dataSources
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSources = try container.decodeIfPresent([DataSource].self, forKey: .dataSources)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "DataSources"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListFolderMembersRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, folderId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFolderMembersResponse: AWSDecodableShape {
        /// A structure that contains all of the folder members (dashboards, analyses, and datasets) in the folder.
        public let folderMemberList: [MemberIdArnPair]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderMemberList: [MemberIdArnPair]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderMemberList = folderMemberList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.folderMemberList = try container.decodeIfPresent([MemberIdArnPair].self, forKey: .folderMemberList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case folderMemberList = "FolderMemberList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListFoldersRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFoldersResponse: AWSDecodableShape {
        /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
        public let folderSummaryList: [FolderSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderSummaryList: [FolderSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderSummaryList = folderSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.folderSummaryList = try container.decodeIfPresent([FolderSummary].self, forKey: .folderSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case folderSummaryList = "FolderSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListGroupMembershipsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the group that you want to see a membership list of.
        public let groupName: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace of the group that you want a list of users from.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, groupName: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.groupName = groupName
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.groupName, key: "GroupName")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupMembershipsResponse: AWSDecodableShape {
        /// The list of the members of the group.
        public let groupMemberList: [GroupMember]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupMemberList: [GroupMember]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupMemberList = groupMemberList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.groupMemberList = try container.decodeIfPresent([GroupMember].self, forKey: .groupMemberList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case groupMemberList = "GroupMemberList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListGroupsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The namespace that you want a list of groups from.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupsResponse: AWSDecodableShape {
        /// The list of the groups.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.groupList = try container.decodeIfPresent([Group].self, forKey: .groupList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListIAMPolicyAssignmentsForUserRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the assignments.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace of the assignment.
        public let namespace: String
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The name of the user.
        public let userName: String

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.userName, key: "UserName")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIAMPolicyAssignmentsForUserResponse: AWSDecodableShape {
        /// The active assignments for this user.
        public let activeAssignments: [ActiveIAMPolicyAssignment]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(activeAssignments: [ActiveIAMPolicyAssignment]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.activeAssignments = activeAssignments
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.activeAssignments = try container.decodeIfPresent([ActiveIAMPolicyAssignment].self, forKey: .activeAssignments)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case activeAssignments = "ActiveAssignments"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListIAMPolicyAssignmentsRequest: AWSEncodableShape {
        /// The status of the assignments.
        public let assignmentStatus: AssignmentStatus?
        /// The ID of the Amazon Web Services account that contains these IAM policy
        /// 			assignments.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The namespace for the assignments.
        public let namespace: String
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(assignmentStatus: AssignmentStatus? = nil, awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assignmentStatus, key: "assignment-status")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIAMPolicyAssignmentsResponse: AWSDecodableShape {
        /// Information describing the IAM policy assignments.
        public let iamPolicyAssignments: [IAMPolicyAssignmentSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(iamPolicyAssignments: [IAMPolicyAssignmentSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.iamPolicyAssignments = iamPolicyAssignments
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.iamPolicyAssignments = try container.decodeIfPresent([IAMPolicyAssignmentSummary].self, forKey: .iamPolicyAssignments)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case iamPolicyAssignments = "IAMPolicyAssignments"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListIdentityPropagationConfigsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contain the identity propagation configurations of.
        public let awsAccountId: String
        /// The maximum number of results to be returned.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdentityPropagationConfigsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// A list of services and their authorized targets that the Amazon QuickSight IAM Identity Center application can access.
        public let services: [AuthorizedTargetsByService]?
        /// The HTTP status of the request.
        public let status: Int?

        public init(nextToken: String? = nil, requestId: String? = nil, services: [AuthorizedTargetsByService]? = nil, status: Int? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.services = services
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.services = try container.decodeIfPresent([AuthorizedTargetsByService].self, forKey: .services)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case services = "Services"
        }
    }

    public struct ListIngestionsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset used in the ingestion.
        public let dataSetId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, dataSetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIngestionsResponse: AWSDecodableShape {
        /// A list of the ingestions.
        public let ingestions: [Ingestion]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(ingestions: [Ingestion]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.ingestions = ingestions
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.ingestions = try container.decodeIfPresent([Ingestion].self, forKey: .ingestions)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case ingestions = "Ingestions"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListNamespacesRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespaces that you want to list.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A unique pagination token that can be used in a subsequent request. You will receive a pagination token in the response body of a previous ListNameSpaces API call if there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNamespacesResponse: AWSDecodableShape {
        /// The information about the namespaces in this Amazon Web Services account. The response includes  the namespace ARN, name, Amazon Web Services Region, notification email address, creation status, and  identity store.
        public let namespaces: [NamespaceInfoV2]?
        /// A unique pagination token that can be used in a subsequent request. Receiving NextToken in your response inticates that there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(namespaces: [NamespaceInfoV2]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.namespaces = namespaces
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.namespaces = try container.decodeIfPresent([NamespaceInfoV2].self, forKey: .namespaces)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case namespaces = "Namespaces"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListRefreshSchedulesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String

        public init(awsAccountId: String, dataSetId: String) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRefreshSchedulesResponse: AWSDecodableShape {
        /// The list of refresh schedules for the dataset.
        public let refreshSchedules: [RefreshSchedule]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(refreshSchedules: [RefreshSchedule]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.refreshSchedules = refreshSchedules
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.refreshSchedules = try container.decodeIfPresent([RefreshSchedule].self, forKey: .refreshSchedules)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchedules = "RefreshSchedules"
            case requestId = "RequestId"
        }
    }

    public struct ListRoleMembershipsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The namespace that includes the role.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The name of the role.
        public let role: Role

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil, role: Role) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.role = role
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.role, key: "Role")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoleMembershipsResponse: AWSDecodableShape {
        /// The list of groups associated with a role
        public let membersList: [String]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(membersList: [String]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.membersList = membersList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.membersList = try container.decodeIfPresent([String].self, forKey: .membersList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case membersList = "MembersList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want a list of tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the
        /// 			resource.
        public let tags: [Tag]?

        public init(requestId: String? = nil, status: Int? = nil, tags: [Tag]? = nil) {
            self.requestId = requestId
            self.status = status
            self.tags = tags
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.tags = try container.decodeIfPresent([Tag].self, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case tags = "Tags"
        }
    }

    public struct ListTemplateAliasesRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the template aliases that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-result")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.templateId, key: "TemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplateAliasesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing the list of the template's aliases.
        public let templateAliasList: [TemplateAlias]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateAliasList: [TemplateAlias]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateAliasList = templateAliasList
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateAliasList = try container.decodeIfPresent([TemplateAlias].self, forKey: .templateAliasList)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case templateAliasList = "TemplateAliasList"
        }
    }

    public struct ListTemplateVersionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the templates that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.templateId, key: "TemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplateVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing a list of all the versions of the specified template.
        public let templateVersionSummaryList: [TemplateVersionSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateVersionSummaryList: [TemplateVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateVersionSummaryList = templateVersionSummaryList
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateVersionSummaryList = try container.decodeIfPresent([TemplateVersionSummary].self, forKey: .templateVersionSummaryList)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case templateVersionSummaryList = "TemplateVersionSummaryList"
        }
    }

    public struct ListTemplatesRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the templates that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-result")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplatesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing information about the templates in the list.
        public let templateSummaryList: [TemplateSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, templateSummaryList: [TemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.templateSummaryList = templateSummaryList
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateSummaryList = try container.decodeIfPresent([TemplateSummary].self, forKey: .templateSummaryList)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case templateSummaryList = "TemplateSummaryList"
        }
    }

    public struct ListThemeAliasesRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the theme aliases that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.themeId = themeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-result")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.themeId, key: "ThemeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemeAliasesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing the list of the theme's aliases.
        public let themeAliasList: [ThemeAlias]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeAliasList: [ThemeAlias]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeAliasList = themeAliasList
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeAliasList = try container.decodeIfPresent([ThemeAlias].self, forKey: .themeAliasList)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case themeAliasList = "ThemeAliasList"
        }
    }

    public struct ListThemeVersionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the themes that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.themeId = themeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.themeId, key: "ThemeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemeVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A structure containing a list of all the versions of the specified theme.
        public let themeVersionSummaryList: [ThemeVersionSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeVersionSummaryList: [ThemeVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeVersionSummaryList = themeVersionSummaryList
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeVersionSummaryList = try container.decodeIfPresent([ThemeVersionSummary].self, forKey: .themeVersionSummaryList)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case themeVersionSummaryList = "ThemeVersionSummaryList"
        }
    }

    public struct ListThemesRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the themes that you're listing.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The type of themes that you want to list. Valid options include the following:    ALL (default)- Display all existing themes.    CUSTOM - Display only the themes created by people using Amazon QuickSight.    QUICKSIGHT - Display only the starting themes defined by Amazon QuickSight.
        public let type: ThemeType?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil, type: ThemeType? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListThemesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the themes in the list.
        public let themeSummaryList: [ThemeSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, themeSummaryList: [ThemeSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.themeSummaryList = themeSummaryList
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeSummaryList = try container.decodeIfPresent([ThemeSummary].self, forKey: .themeSummaryList)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case themeSummaryList = "ThemeSummaryList"
        }
    }

    public struct ListTopicRefreshSchedulesRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic whose refresh schedule you want described.
        public let awsAccountId: String
        /// The ID for the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, topicId: String) {
            self.awsAccountId = awsAccountId
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTopicRefreshSchedulesResponse: AWSDecodableShape {
        /// The list of topic refresh schedules.
        public let refreshSchedules: [TopicRefreshScheduleSummary]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the topic.
        public let topicArn: String?
        /// The ID for the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(refreshSchedules: [TopicRefreshScheduleSummary]? = nil, requestId: String? = nil, status: Int? = nil, topicArn: String? = nil, topicId: String? = nil) {
            self.refreshSchedules = refreshSchedules
            self.requestId = requestId
            self.status = status
            self.topicArn = topicArn
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.refreshSchedules = try container.decodeIfPresent([TopicRefreshScheduleSummary].self, forKey: .refreshSchedules)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicArn = try container.decodeIfPresent(String.self, forKey: .topicArn)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchedules = "RefreshSchedules"
            case requestId = "RequestId"
            case topicArn = "TopicArn"
            case topicId = "TopicId"
        }
    }

    public struct ListTopicsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topics that you want to list.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTopicsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A list of topic summaries.
        public let topicsSummaries: [TopicSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, topicsSummaries: [TopicSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.topicsSummaries = topicsSummaries
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicsSummaries = try container.decodeIfPresent([TopicSummary].self, forKey: .topicsSummaries)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case topicsSummaries = "TopicsSummaries"
        }
    }

    public struct ListUserGroupsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID that the user is in. Currently, you use the ID for the Amazon Web Services account
        /// 			that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon QuickSight user name that you want to list group memberships for.
        public let userName: String

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodePath(self.userName, key: "UserName")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserGroupsResponse: AWSDecodableShape {
        /// The list of groups the user is a member of.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.groupList = try container.decodeIfPresent([Group].self, forKey: .groupList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The list of users.
        public let userList: [User]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, userList: [User]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.userList = userList
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.userList = try container.decodeIfPresent([User].self, forKey: .userList)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case userList = "UserList"
        }
    }

    public struct ListVPCConnectionsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the account that contains the VPC connections
        /// 			that you want to list.
        public let awsAccountId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVPCConnectionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more
        /// 			results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// A VPCConnectionSummaries object that returns a summary of VPC connection
        /// 			objects.
        public let vpcConnectionSummaries: [VPCConnectionSummary]?

        public init(nextToken: String? = nil, requestId: String? = nil, status: Int? = nil, vpcConnectionSummaries: [VPCConnectionSummary]? = nil) {
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
            self.vpcConnectionSummaries = vpcConnectionSummaries
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.vpcConnectionSummaries = try container.decodeIfPresent([VPCConnectionSummary].self, forKey: .vpcConnectionSummaries)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestId = "RequestId"
            case vpcConnectionSummaries = "VPCConnectionSummaries"
        }
    }

    public struct LoadingAnimation: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of LoadingAnimation.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct LocalNavigationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sheet that is targeted for navigation in the same analysis.
        public let targetSheetId: String

        public init(targetSheetId: String) {
            self.targetSheetId = targetSheetId
        }

        public func validate(name: String) throws {
            try self.validate(self.targetSheetId, name: "targetSheetId", parent: name, max: 512)
            try self.validate(self.targetSheetId, name: "targetSheetId", parent: name, min: 1)
            try self.validate(self.targetSheetId, name: "targetSheetId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetSheetId = "TargetSheetId"
        }
    }

    public struct LogicalTable: AWSEncodableShape & AWSDecodableShape {
        /// A display name for the logical table.
        public let alias: String
        /// Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null.
        public let dataTransforms: [TransformOperation]?
        /// Source of this logical table.
        public let source: LogicalTableSource

        public init(alias: String, dataTransforms: [TransformOperation]? = nil, source: LogicalTableSource) {
            self.alias = alias
            self.dataTransforms = dataTransforms
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 64)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.dataTransforms?.forEach {
                try $0.validate(name: "\(name).dataTransforms[]")
            }
            try self.validate(self.dataTransforms, name: "dataTransforms", parent: name, max: 2048)
            try self.validate(self.dataTransforms, name: "dataTransforms", parent: name, min: 1)
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case dataTransforms = "DataTransforms"
            case source = "Source"
        }
    }

    public struct LogicalTableSource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Number (ARN) of the parent dataset.
        public let dataSetArn: String?
        /// Specifies the result of a join of two logical tables.
        public let joinInstruction: JoinInstruction?
        /// Physical table ID.
        public let physicalTableId: String?

        public init(dataSetArn: String? = nil, joinInstruction: JoinInstruction? = nil, physicalTableId: String? = nil) {
            self.dataSetArn = dataSetArn
            self.joinInstruction = joinInstruction
            self.physicalTableId = physicalTableId
        }

        public func validate(name: String) throws {
            try self.joinInstruction?.validate(name: "\(name).joinInstruction")
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, max: 64)
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, min: 1)
            try self.validate(self.physicalTableId, name: "physicalTableId", parent: name, pattern: "^[0-9a-zA-Z-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case joinInstruction = "JoinInstruction"
            case physicalTableId = "PhysicalTableId"
        }
    }

    public struct LongFormatText: AWSEncodableShape & AWSDecodableShape {
        /// Plain text format.
        public let plainText: String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public let richText: String?

        public init(plainText: String? = nil, richText: String? = nil) {
            self.plainText = plainText
            self.richText = richText
        }

        public func validate(name: String) throws {
            try self.validate(self.plainText, name: "plainText", parent: name, max: 1024)
            try self.validate(self.plainText, name: "plainText", parent: name, min: 1)
            try self.validate(self.richText, name: "richText", parent: name, max: 2048)
            try self.validate(self.richText, name: "richText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case plainText = "PlainText"
            case richText = "RichText"
        }
    }

    public struct LookbackWindow: AWSEncodableShape & AWSDecodableShape {
        /// The name of the lookback window column.
        public let columnName: String
        /// The lookback window column size.
        public let size: Int64
        /// The size unit that is used for the lookback window column. Valid values for this structure are HOUR, DAY, and WEEK.
        public let sizeUnit: LookbackWindowSizeUnit

        public init(columnName: String, size: Int64, sizeUnit: LookbackWindowSizeUnit) {
            self.columnName = columnName
            self.size = size
            self.sizeUnit = sizeUnit
        }

        public func validate(name: String) throws {
            try self.validate(self.size, name: "size", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case size = "Size"
            case sizeUnit = "SizeUnit"
        }
    }

    public struct ManifestFileLocation: AWSEncodableShape & AWSDecodableShape {
        /// Amazon S3 bucket.
        public let bucket: String
        /// Amazon S3 key that identifies an object.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 1024)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct MappedDataSetParameter: AWSEncodableShape & AWSDecodableShape {
        /// A unique name that identifies a dataset within the analysis or dashboard.
        public let dataSetIdentifier: String
        /// The name of the dataset parameter.
        public let dataSetParameterName: String

        public init(dataSetIdentifier: String, dataSetParameterName: String) {
            self.dataSetIdentifier = dataSetIdentifier
            self.dataSetParameterName = dataSetParameterName
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.validate(self.dataSetParameterName, name: "dataSetParameterName", parent: name, max: 2048)
            try self.validate(self.dataSetParameterName, name: "dataSetParameterName", parent: name, min: 1)
            try self.validate(self.dataSetParameterName, name: "dataSetParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIdentifier = "DataSetIdentifier"
            case dataSetParameterName = "DataSetParameterName"
        }
    }

    public struct MarginStyle: AWSEncodableShape & AWSDecodableShape {
        /// This Boolean value controls whether to display sheet margins.
        public let show: Bool?

        public init(show: Bool? = nil) {
            self.show = show
        }

        private enum CodingKeys: String, CodingKey {
            case show = "Show"
        }
    }

    public struct MariaDbParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct MaximumLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the maximum label.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct MaximumMinimumComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The time field that is used in a computation.
        public let time: DimensionField?
        /// The type of computation. Choose one of the following options:   MAXIMUM: A maximum computation.   MINIMUM: A minimum computation.
        public let type: MaximumMinimumComputationType
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, time: DimensionField? = nil, type: MaximumMinimumComputationType, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.time?.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case time = "Time"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct MeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The calculated measure field only used in pivot tables.
        public let calculatedMeasureField: CalculatedMeasureField?
        /// The measure type field with categorical type columns.
        public let categoricalMeasureField: CategoricalMeasureField?
        /// The measure type field with date type columns.
        public let dateMeasureField: DateMeasureField?
        /// The measure type field with numerical type columns.
        public let numericalMeasureField: NumericalMeasureField?

        public init(calculatedMeasureField: CalculatedMeasureField? = nil, categoricalMeasureField: CategoricalMeasureField? = nil, dateMeasureField: DateMeasureField? = nil, numericalMeasureField: NumericalMeasureField? = nil) {
            self.calculatedMeasureField = calculatedMeasureField
            self.categoricalMeasureField = categoricalMeasureField
            self.dateMeasureField = dateMeasureField
            self.numericalMeasureField = numericalMeasureField
        }

        public func validate(name: String) throws {
            try self.calculatedMeasureField?.validate(name: "\(name).calculatedMeasureField")
            try self.categoricalMeasureField?.validate(name: "\(name).categoricalMeasureField")
            try self.dateMeasureField?.validate(name: "\(name).dateMeasureField")
            try self.numericalMeasureField?.validate(name: "\(name).numericalMeasureField")
        }

        private enum CodingKeys: String, CodingKey {
            case calculatedMeasureField = "CalculatedMeasureField"
            case categoricalMeasureField = "CategoricalMeasureField"
            case dateMeasureField = "DateMeasureField"
            case numericalMeasureField = "NumericalMeasureField"
        }
    }

    public struct MemberIdArnPair: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the member.
        public let memberArn: String?
        /// The ID of the member.
        public let memberId: String?

        public init(memberArn: String? = nil, memberId: String? = nil) {
            self.memberArn = memberArn
            self.memberId = memberId
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
            case memberId = "MemberId"
        }
    }

    public struct MetricComparisonComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The field that is used in a metric comparison from value setup.
        public let fromValue: MeasureField?
        /// The name of a computation.
        public let name: String?
        /// The field that is used in a metric comparison to value setup.
        public let targetValue: MeasureField?
        /// The time field that is used in a computation.
        public let time: DimensionField?

        public init(computationId: String, fromValue: MeasureField? = nil, name: String? = nil, targetValue: MeasureField? = nil, time: DimensionField? = nil) {
            self.computationId = computationId
            self.fromValue = fromValue
            self.name = name
            self.targetValue = targetValue
            self.time = time
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.fromValue?.validate(name: "\(name).fromValue")
            try self.targetValue?.validate(name: "\(name).targetValue")
            try self.time?.validate(name: "\(name).time")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case fromValue = "FromValue"
            case name = "Name"
            case targetValue = "TargetValue"
            case time = "Time"
        }
    }

    public struct MinimumLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the minimum label.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct MissingDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The treatment option that determines how missing data should be rendered. Choose from the following options:    INTERPOLATE: Interpolate missing values between the prior and the next known value.    SHOW_AS_ZERO: Show missing values as the value 0.    SHOW_AS_BLANK: Display a blank space when rendering missing data.
        public let treatmentOption: MissingDataTreatmentOption?

        public init(treatmentOption: MissingDataTreatmentOption? = nil) {
            self.treatmentOption = treatmentOption
        }

        private enum CodingKeys: String, CodingKey {
            case treatmentOption = "TreatmentOption"
        }
    }

    public struct MySqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct NamedEntityDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The name of the entity.
        public let fieldName: String?
        /// The definition of a metric.
        public let metric: NamedEntityDefinitionMetric?
        /// The property name to be used for the named entity.
        public let propertyName: String?
        /// The property role. Valid values for this structure are PRIMARY and ID.
        public let propertyRole: PropertyRole?
        /// The property usage. Valid values for this structure are INHERIT, DIMENSION, and MEASURE.
        public let propertyUsage: PropertyUsage?

        public init(fieldName: String? = nil, metric: NamedEntityDefinitionMetric? = nil, propertyName: String? = nil, propertyRole: PropertyRole? = nil, propertyUsage: PropertyUsage? = nil) {
            self.fieldName = fieldName
            self.metric = metric
            self.propertyName = propertyName
            self.propertyRole = propertyRole
            self.propertyUsage = propertyUsage
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 256)
            try self.metric?.validate(name: "\(name).metric")
            try self.validate(self.propertyName, name: "propertyName", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "FieldName"
            case metric = "Metric"
            case propertyName = "PropertyName"
            case propertyRole = "PropertyRole"
            case propertyUsage = "PropertyUsage"
        }
    }

    public struct NamedEntityDefinitionMetric: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation of a named entity. Valid values for this structure are SUM, MIN, MAX, COUNT, AVERAGE, DISTINCT_COUNT, STDEV, STDEVP, VAR, VARP, PERCENTILE, MEDIAN, and CUSTOM.
        public let aggregation: NamedEntityAggType?
        /// The additional parameters for an aggregation function.
        public let aggregationFunctionParameters: [String: String]?

        public init(aggregation: NamedEntityAggType? = nil, aggregationFunctionParameters: [String: String]? = nil) {
            self.aggregation = aggregation
            self.aggregationFunctionParameters = aggregationFunctionParameters
        }

        public func validate(name: String) throws {
            try self.aggregationFunctionParameters?.forEach {
                try validate($0.key, name: "aggregationFunctionParameters.key", parent: name, max: 256)
                try validate($0.value, name: "aggregationFunctionParameters[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "Aggregation"
            case aggregationFunctionParameters = "AggregationFunctionParameters"
        }
    }

    public struct NamespaceError: AWSDecodableShape {
        /// The message for the error.
        public let message: String?
        /// The error type.
        public let type: NamespaceErrorType?

        public init(message: String? = nil, type: NamespaceErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct NamespaceInfoV2: AWSDecodableShape {
        /// The namespace ARN.
        public let arn: String?
        /// The namespace Amazon Web Services Region.
        public let capacityRegion: String?
        /// The creation status of a namespace that is not yet completely created.
        public let creationStatus: NamespaceStatus?
        /// The identity store used for the namespace.
        public let identityStore: IdentityStore?
        /// The name of the error.
        public let name: String?
        /// An error that occurred when the namespace was created.
        public let namespaceError: NamespaceError?

        public init(arn: String? = nil, capacityRegion: String? = nil, creationStatus: NamespaceStatus? = nil, identityStore: IdentityStore? = nil, name: String? = nil, namespaceError: NamespaceError? = nil) {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.namespaceError = namespaceError
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacityRegion = "CapacityRegion"
            case creationStatus = "CreationStatus"
            case identityStore = "IdentityStore"
            case name = "Name"
            case namespaceError = "NamespaceError"
        }
    }

    public struct NegativeFormat: AWSEncodableShape & AWSDecodableShape {
        /// The prefix for a negative format.
        public let prefix: String?
        /// The suffix for a negative format.
        public let suffix: String?

        public init(prefix: String? = nil, suffix: String? = nil) {
            self.prefix = prefix
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.validate(self.prefix, name: "prefix", parent: name, max: 256)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "Prefix"
            case suffix = "Suffix"
        }
    }

    public struct NegativeValueConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the display mode of the negative value configuration.
        public let displayMode: NegativeValueDisplayMode

        public init(displayMode: NegativeValueDisplayMode) {
            self.displayMode = displayMode
        }

        private enum CodingKeys: String, CodingKey {
            case displayMode = "DisplayMode"
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// The availability zone that the network interface resides in.
        public let availabilityZone: String?
        /// An error message.
        public let errorMessage: String?
        /// The network interface ID.
        public let networkInterfaceId: String?
        /// The status of the network interface.
        public let status: NetworkInterfaceStatus?
        /// The subnet ID associated with the network interface.
        public let subnetId: String?

        public init(availabilityZone: String? = nil, errorMessage: String? = nil, networkInterfaceId: String? = nil, status: NetworkInterfaceStatus? = nil, subnetId: String? = nil) {
            self.availabilityZone = availabilityZone
            self.errorMessage = errorMessage
            self.networkInterfaceId = networkInterfaceId
            self.status = status
            self.subnetId = subnetId
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case errorMessage = "ErrorMessage"
            case networkInterfaceId = "NetworkInterfaceId"
            case status = "Status"
            case subnetId = "SubnetId"
        }
    }

    public struct NewDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// A list of static default values for a given date time parameter.
        public let dateTimeStaticValues: [Date]?
        /// A list of static default values for a given decimal parameter.
        public let decimalStaticValues: [Double]?
        /// A list of static default values for a given integer parameter.
        public let integerStaticValues: [Int64]?
        /// A list of static default values for a given string parameter.
        public let stringStaticValues: [String]?

        public init(dateTimeStaticValues: [Date]? = nil, decimalStaticValues: [Double]? = nil, integerStaticValues: [Int64]? = nil, stringStaticValues: [String]? = nil) {
            self.dateTimeStaticValues = dateTimeStaticValues
            self.decimalStaticValues = decimalStaticValues
            self.integerStaticValues = integerStaticValues
            self.stringStaticValues = stringStaticValues
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeStaticValues, name: "dateTimeStaticValues", parent: name, max: 32)
            try self.validate(self.dateTimeStaticValues, name: "dateTimeStaticValues", parent: name, min: 1)
            try self.validate(self.decimalStaticValues, name: "decimalStaticValues", parent: name, max: 32)
            try self.validate(self.decimalStaticValues, name: "decimalStaticValues", parent: name, min: 1)
            try self.validate(self.integerStaticValues, name: "integerStaticValues", parent: name, max: 32)
            try self.validate(self.integerStaticValues, name: "integerStaticValues", parent: name, min: 1)
            try self.stringStaticValues?.forEach {
                try validate($0, name: "stringStaticValues[]", parent: name, max: 512)
            }
            try self.validate(self.stringStaticValues, name: "stringStaticValues", parent: name, max: 32)
            try self.validate(self.stringStaticValues, name: "stringStaticValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeStaticValues = "DateTimeStaticValues"
            case decimalStaticValues = "DecimalStaticValues"
            case integerStaticValues = "IntegerStaticValues"
            case stringStaticValues = "StringStaticValues"
        }
    }

    public struct NullValueFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the null string of null values.
        public let nullString: String

        public init(nullString: String) {
            self.nullString = nullString
        }

        public func validate(name: String) throws {
            try self.validate(self.nullString, name: "nullString", parent: name, max: 128)
            try self.validate(self.nullString, name: "nullString", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nullString = "NullString"
        }
    }

    public struct NumberDisplayFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the decimal places configuration.
        public let decimalPlacesConfiguration: DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public let negativeValueConfiguration: NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// Determines the number scale value of the number format.
        public let numberScale: NumberScale?
        /// Determines the prefix value of the number format.
        public let prefix: String?
        /// The options that determine the numeric separator configuration.
        public let separatorConfiguration: NumericSeparatorConfiguration?
        /// Determines the suffix value of the number format.
        public let suffix: String?

        public init(decimalPlacesConfiguration: DecimalPlacesConfiguration? = nil, negativeValueConfiguration: NegativeValueConfiguration? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numberScale: NumberScale? = nil, prefix: String? = nil, separatorConfiguration: NumericSeparatorConfiguration? = nil, suffix: String? = nil) {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.prefix = prefix
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.decimalPlacesConfiguration?.validate(name: "\(name).decimalPlacesConfiguration")
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 128)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
            case negativeValueConfiguration = "NegativeValueConfiguration"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numberScale = "NumberScale"
            case prefix = "Prefix"
            case separatorConfiguration = "SeparatorConfiguration"
            case suffix = "Suffix"
        }
    }

    public struct NumberFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the numeric format configuration.
        public let formatConfiguration: NumericFormatConfiguration?

        public init(formatConfiguration: NumericFormatConfiguration? = nil) {
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct NumericAxisOptions: AWSEncodableShape & AWSDecodableShape {
        /// The range setup of a numeric axis.
        public let range: AxisDisplayRange?
        /// The scale setup of a numeric axis.
        public let scale: AxisScale?

        public init(range: AxisDisplayRange? = nil, scale: AxisScale? = nil) {
            self.range = range
            self.scale = scale
        }

        private enum CodingKeys: String, CodingKey {
            case range = "Range"
            case scale = "Scale"
        }
    }

    public struct NumericEqualityDrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The value of the double input numeric drill down filter.
        public let value: Double

        public init(column: ColumnIdentifier, value: Double) {
            self.column = column
            self.value = value
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case value = "Value"
        }
    }

    public struct NumericEqualityFilter: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the filter.
        public let aggregationFunction: AggregationFunction?
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The match operator that is used to determine if a filter should be applied.
        public let matchOperator: NumericEqualityMatchOperator
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The parameter whose value should be used for the filter value.
        public let parameterName: String?
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: NumericFilterSelectAllOptions?
        /// The input value.
        public let value: Double?

        public init(aggregationFunction: AggregationFunction? = nil, column: ColumnIdentifier, filterId: String, matchOperator: NumericEqualityMatchOperator, nullOption: FilterNullOption, parameterName: String? = nil, selectAllOptions: NumericFilterSelectAllOptions? = nil, value: Double? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.filterId = filterId
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
            self.value = value
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case filterId = "FilterId"
            case matchOperator = "MatchOperator"
            case nullOption = "NullOption"
            case parameterName = "ParameterName"
            case selectAllOptions = "SelectAllOptions"
            case value = "Value"
        }
    }

    public struct NumericFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the currency display format configuration.
        public let currencyDisplayFormatConfiguration: CurrencyDisplayFormatConfiguration?
        /// The options that determine the number display format configuration.
        public let numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration?
        /// The options that determine the percentage display format configuration.
        public let percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration?

        public init(currencyDisplayFormatConfiguration: CurrencyDisplayFormatConfiguration? = nil, numberDisplayFormatConfiguration: NumberDisplayFormatConfiguration? = nil, percentageDisplayFormatConfiguration: PercentageDisplayFormatConfiguration? = nil) {
            self.currencyDisplayFormatConfiguration = currencyDisplayFormatConfiguration
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.currencyDisplayFormatConfiguration?.validate(name: "\(name).currencyDisplayFormatConfiguration")
            try self.numberDisplayFormatConfiguration?.validate(name: "\(name).numberDisplayFormatConfiguration")
            try self.percentageDisplayFormatConfiguration?.validate(name: "\(name).percentageDisplayFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case currencyDisplayFormatConfiguration = "CurrencyDisplayFormatConfiguration"
            case numberDisplayFormatConfiguration = "NumberDisplayFormatConfiguration"
            case percentageDisplayFormatConfiguration = "PercentageDisplayFormatConfiguration"
        }
    }

    public struct NumericRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the filter.
        public let aggregationFunction: AggregationFunction?
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public let includeMaximum: Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public let includeMinimum: Bool?
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The maximum value for the filter value range.
        public let rangeMaximum: NumericRangeFilterValue?
        /// The minimum value for the filter value range.
        public let rangeMinimum: NumericRangeFilterValue?
        /// Select all of the values. Null is not the assigned value of select all.    FILTER_ALL_VALUES
        public let selectAllOptions: NumericFilterSelectAllOptions?

        public init(aggregationFunction: AggregationFunction? = nil, column: ColumnIdentifier, filterId: String, includeMaximum: Bool? = nil, includeMinimum: Bool? = nil, nullOption: FilterNullOption, rangeMaximum: NumericRangeFilterValue? = nil, rangeMinimum: NumericRangeFilterValue? = nil, selectAllOptions: NumericFilterSelectAllOptions? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.selectAllOptions = selectAllOptions
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.rangeMaximum?.validate(name: "\(name).rangeMaximum")
            try self.rangeMinimum?.validate(name: "\(name).rangeMinimum")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case filterId = "FilterId"
            case includeMaximum = "IncludeMaximum"
            case includeMinimum = "IncludeMinimum"
            case nullOption = "NullOption"
            case rangeMaximum = "RangeMaximum"
            case rangeMinimum = "RangeMinimum"
            case selectAllOptions = "SelectAllOptions"
        }
    }

    public struct NumericRangeFilterValue: AWSEncodableShape & AWSDecodableShape {
        /// The parameter that is used in the numeric range.
        public let parameter: String?
        /// The static value of the numeric range filter.
        public let staticValue: Double?

        public init(parameter: String? = nil, staticValue: Double? = nil) {
            self.parameter = parameter
            self.staticValue = staticValue
        }

        public func validate(name: String) throws {
            try self.validate(self.parameter, name: "parameter", parent: name, max: 2048)
            try self.validate(self.parameter, name: "parameter", parent: name, min: 1)
            try self.validate(self.parameter, name: "parameter", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case parameter = "Parameter"
            case staticValue = "StaticValue"
        }
    }

    public struct NumericSeparatorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the decimal separator.
        public let decimalSeparator: NumericSeparatorSymbol?
        /// The options that determine the thousands separator configuration.
        public let thousandsSeparator: ThousandSeparatorOptions?

        public init(decimalSeparator: NumericSeparatorSymbol? = nil, thousandsSeparator: ThousandSeparatorOptions? = nil) {
            self.decimalSeparator = decimalSeparator
            self.thousandsSeparator = thousandsSeparator
        }

        private enum CodingKeys: String, CodingKey {
            case decimalSeparator = "DecimalSeparator"
            case thousandsSeparator = "ThousandsSeparator"
        }
    }

    public struct NumericalAggregationFunction: AWSEncodableShape & AWSDecodableShape {
        /// An aggregation based on the percentile of values in a dimension or measure.
        public let percentileAggregation: PercentileAggregation?
        /// Built-in aggregation functions for numerical values.    SUM: The sum of a dimension or measure.     AVERAGE: The average of a dimension or measure.    MIN: The minimum value of a dimension or measure.    MAX: The maximum value of a dimension or measure.    COUNT: The count of a dimension or measure.    DISTINCT_COUNT: The count of distinct values in a dimension or measure.    VAR: The variance of a dimension or measure.    VARP: The partitioned variance of a dimension or measure.    STDEV: The standard deviation of a dimension or measure.    STDEVP: The partitioned standard deviation of a dimension or measure.    MEDIAN: The median value of a dimension or measure.
        public let simpleNumericalAggregation: SimpleNumericalAggregationFunction?

        public init(percentileAggregation: PercentileAggregation? = nil, simpleNumericalAggregation: SimpleNumericalAggregationFunction? = nil) {
            self.percentileAggregation = percentileAggregation
            self.simpleNumericalAggregation = simpleNumericalAggregation
        }

        public func validate(name: String) throws {
            try self.percentileAggregation?.validate(name: "\(name).percentileAggregation")
        }

        private enum CodingKeys: String, CodingKey {
            case percentileAggregation = "PercentileAggregation"
            case simpleNumericalAggregation = "SimpleNumericalAggregation"
        }
    }

    public struct NumericalDimensionField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the NumericalDimensionField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: NumberFormatConfiguration?
        /// The custom hierarchy ID.
        public let hierarchyId: String?

        public init(column: ColumnIdentifier, fieldId: String, formatConfiguration: NumberFormatConfiguration? = nil, hierarchyId: String? = nil) {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct NumericalMeasureField: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation function of the measure field.
        public let aggregationFunction: NumericalAggregationFunction?
        /// The column that is used in the NumericalMeasureField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: NumberFormatConfiguration?

        public init(aggregationFunction: NumericalAggregationFunction? = nil, column: ColumnIdentifier, fieldId: String, formatConfiguration: NumberFormatConfiguration? = nil) {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.aggregationFunction?.validate(name: "\(name).aggregationFunction")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationFunction = "AggregationFunction"
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct OracleParameters: AWSEncodableShape & AWSDecodableShape {
        /// The database.
        public let database: String
        /// An Oracle host.
        public let host: String
        /// The port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct OutputColumn: AWSDecodableShape {
        /// A description for a column.
        public let description: String?
        /// The display name of the column..
        public let name: String?
        /// The sub data type of the column.
        public let subType: ColumnDataSubType?
        /// The data type of the column.
        public let type: ColumnDataType?

        public init(description: String? = nil, name: String? = nil, subType: ColumnDataSubType? = nil, type: ColumnDataType? = nil) {
            self.description = description
            self.name = name
            self.subType = subType
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case subType = "SubType"
            case type = "Type"
        }
    }

    public struct OverrideDatasetParameterOperation: AWSEncodableShape & AWSDecodableShape {
        /// The new default values for the parameter.
        public let newDefaultValues: NewDefaultValues?
        /// The new name for the parameter.
        public let newParameterName: String?
        /// The name of the parameter to be overridden with different values.
        public let parameterName: String

        public init(newDefaultValues: NewDefaultValues? = nil, newParameterName: String? = nil, parameterName: String) {
            self.newDefaultValues = newDefaultValues
            self.newParameterName = newParameterName
            self.parameterName = parameterName
        }

        public func validate(name: String) throws {
            try self.newDefaultValues?.validate(name: "\(name).newDefaultValues")
            try self.validate(self.newParameterName, name: "newParameterName", parent: name, max: 2048)
            try self.validate(self.newParameterName, name: "newParameterName", parent: name, min: 1)
            try self.validate(self.newParameterName, name: "newParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case newDefaultValues = "NewDefaultValues"
            case newParameterName = "NewParameterName"
            case parameterName = "ParameterName"
        }
    }

    public struct PaginationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the page number.
        public let pageNumber: Int64
        /// Indicates how many items render in one page.
        public let pageSize: Int64

        public init(pageNumber: Int64, pageSize: Int64) {
            self.pageNumber = pageNumber
            self.pageSize = pageSize
        }

        public func validate(name: String) throws {
            try self.validate(self.pageNumber, name: "pageNumber", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "PageNumber"
            case pageSize = "PageSize"
        }
    }

    public struct PanelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Sets the background color for each panel.
        public let backgroundColor: String?
        /// Determines whether or not a background for each small multiples panel is rendered.
        public let backgroundVisibility: Visibility?
        /// Sets the line color of panel borders.
        public let borderColor: String?
        /// Sets the line style of panel borders.
        public let borderStyle: PanelBorderStyle?
        /// Sets the line thickness of panel borders.
        public let borderThickness: String?
        /// Determines whether or not each panel displays a border.
        public let borderVisibility: Visibility?
        /// Sets the total amount of negative space to display between sibling panels.
        public let gutterSpacing: String?
        /// Determines whether or not negative space between sibling panels is rendered.
        public let gutterVisibility: Visibility?
        /// Configures the title display within each small multiples panel.
        public let title: PanelTitleOptions?

        public init(backgroundColor: String? = nil, backgroundVisibility: Visibility? = nil, borderColor: String? = nil, borderStyle: PanelBorderStyle? = nil, borderThickness: String? = nil, borderVisibility: Visibility? = nil, gutterSpacing: String? = nil, gutterVisibility: Visibility? = nil, title: PanelTitleOptions? = nil) {
            self.backgroundColor = backgroundColor
            self.backgroundVisibility = backgroundVisibility
            self.borderColor = borderColor
            self.borderStyle = borderStyle
            self.borderThickness = borderThickness
            self.borderVisibility = borderVisibility
            self.gutterSpacing = gutterSpacing
            self.gutterVisibility = gutterVisibility
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.backgroundColor, name: "backgroundColor", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
            try self.validate(self.borderColor, name: "borderColor", parent: name, pattern: "^#[A-F0-9]{6}(?:[A-F0-9]{2})?$")
            try self.title?.validate(name: "\(name).title")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case backgroundVisibility = "BackgroundVisibility"
            case borderColor = "BorderColor"
            case borderStyle = "BorderStyle"
            case borderThickness = "BorderThickness"
            case borderVisibility = "BorderVisibility"
            case gutterSpacing = "GutterSpacing"
            case gutterVisibility = "GutterVisibility"
            case title = "Title"
        }
    }

    public struct PanelTitleOptions: AWSEncodableShape & AWSDecodableShape {
        public let fontConfiguration: FontConfiguration?
        /// Sets the horizontal text alignment of the title within each panel.
        public let horizontalTextAlignment: HorizontalTextAlignment?
        /// Determines whether or not panel titles are displayed.
        public let visibility: Visibility?

        public init(fontConfiguration: FontConfiguration? = nil, horizontalTextAlignment: HorizontalTextAlignment? = nil, visibility: Visibility? = nil) {
            self.fontConfiguration = fontConfiguration
            self.horizontalTextAlignment = horizontalTextAlignment
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case fontConfiguration = "FontConfiguration"
            case horizontalTextAlignment = "HorizontalTextAlignment"
            case visibility = "Visibility"
        }
    }

    public struct ParameterControl: AWSEncodableShape & AWSDecodableShape {
        /// A control from a date parameter that specifies date and time.
        public let dateTimePicker: ParameterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public let dropdown: ParameterDropDownControl?
        /// A control to display a list with buttons or boxes that are used to select either a single value or multiple values.
        public let list: ParameterListControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public let slider: ParameterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public let textArea: ParameterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public let textField: ParameterTextFieldControl?

        public init(dateTimePicker: ParameterDateTimePickerControl? = nil, dropdown: ParameterDropDownControl? = nil, list: ParameterListControl? = nil, slider: ParameterSliderControl? = nil, textArea: ParameterTextAreaControl? = nil, textField: ParameterTextFieldControl? = nil) {
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }

        public func validate(name: String) throws {
            try self.dateTimePicker?.validate(name: "\(name).dateTimePicker")
            try self.dropdown?.validate(name: "\(name).dropdown")
            try self.list?.validate(name: "\(name).list")
            try self.slider?.validate(name: "\(name).slider")
            try self.textArea?.validate(name: "\(name).textArea")
            try self.textField?.validate(name: "\(name).textField")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimePicker = "DateTimePicker"
            case dropdown = "Dropdown"
            case list = "List"
            case slider = "Slider"
            case textArea = "TextArea"
            case textField = "TextField"
        }
    }

    public struct ParameterDateTimePickerControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: DateTimePickerControlDisplayOptions?
        /// The ID of the ParameterDateTimePickerControl.
        public let parameterControlId: String
        /// The name of the ParameterDateTimePickerControl.
        public let sourceParameterName: String
        /// The title of the ParameterDateTimePickerControl.
        public let title: String

        public init(displayOptions: DateTimePickerControlDisplayOptions? = nil, parameterControlId: String, sourceParameterName: String, title: String) {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
        }
    }

    public struct ParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// A parameter declaration for the DateTime data type.
        public let dateTimeParameterDeclaration: DateTimeParameterDeclaration?
        /// A parameter declaration for the Decimal data type.
        public let decimalParameterDeclaration: DecimalParameterDeclaration?
        /// A parameter declaration for the Integer data type.
        public let integerParameterDeclaration: IntegerParameterDeclaration?
        /// A parameter declaration for the String data type.
        public let stringParameterDeclaration: StringParameterDeclaration?

        public init(dateTimeParameterDeclaration: DateTimeParameterDeclaration? = nil, decimalParameterDeclaration: DecimalParameterDeclaration? = nil, integerParameterDeclaration: IntegerParameterDeclaration? = nil, stringParameterDeclaration: StringParameterDeclaration? = nil) {
            self.dateTimeParameterDeclaration = dateTimeParameterDeclaration
            self.decimalParameterDeclaration = decimalParameterDeclaration
            self.integerParameterDeclaration = integerParameterDeclaration
            self.stringParameterDeclaration = stringParameterDeclaration
        }

        public func validate(name: String) throws {
            try self.dateTimeParameterDeclaration?.validate(name: "\(name).dateTimeParameterDeclaration")
            try self.decimalParameterDeclaration?.validate(name: "\(name).decimalParameterDeclaration")
            try self.integerParameterDeclaration?.validate(name: "\(name).integerParameterDeclaration")
            try self.stringParameterDeclaration?.validate(name: "\(name).stringParameterDeclaration")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeParameterDeclaration = "DateTimeParameterDeclaration"
            case decimalParameterDeclaration = "DecimalParameterDeclaration"
            case integerParameterDeclaration = "IntegerParameterDeclaration"
            case stringParameterDeclaration = "StringParameterDeclaration"
        }
    }

    public struct ParameterDropDownControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of a control.
        public let displayOptions: DropDownControlDisplayOptions?
        /// The ID of the ParameterDropDownControl.
        public let parameterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: ParameterSelectableValues?
        /// The source parameter name of the ParameterDropDownControl.
        public let sourceParameterName: String
        /// The title of the ParameterDropDownControl.
        public let title: String
        /// The type parameter name of the ParameterDropDownControl.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: DropDownControlDisplayOptions? = nil, parameterControlId: String, selectableValues: ParameterSelectableValues? = nil, sourceParameterName: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case selectableValues = "SelectableValues"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct ParameterListControl: AWSEncodableShape & AWSDecodableShape {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public let cascadingControlConfiguration: CascadingControlConfiguration?
        /// The display options of a control.
        public let displayOptions: ListControlDisplayOptions?
        /// The ID of the ParameterListControl.
        public let parameterControlId: String
        /// A list of selectable values that are used in a control.
        public let selectableValues: ParameterSelectableValues?
        /// The source parameter name of the ParameterListControl.
        public let sourceParameterName: String
        /// The title of the ParameterListControl.
        public let title: String
        /// The type of ParameterListControl.
        public let type: SheetControlListType?

        public init(cascadingControlConfiguration: CascadingControlConfiguration? = nil, displayOptions: ListControlDisplayOptions? = nil, parameterControlId: String, selectableValues: ParameterSelectableValues? = nil, sourceParameterName: String, title: String, type: SheetControlListType? = nil) {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.cascadingControlConfiguration?.validate(name: "\(name).cascadingControlConfiguration")
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.selectableValues?.validate(name: "\(name).selectableValues")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cascadingControlConfiguration = "CascadingControlConfiguration"
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case selectableValues = "SelectableValues"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct ParameterSelectableValues: AWSEncodableShape & AWSDecodableShape {
        /// The column identifier that fetches values from the data set.
        public let linkToDataSetColumn: ColumnIdentifier?
        /// The values that are used in ParameterSelectableValues.
        public let values: [String]?

        public init(linkToDataSetColumn: ColumnIdentifier? = nil, values: [String]? = nil) {
            self.linkToDataSetColumn = linkToDataSetColumn
            self.values = values
        }

        public func validate(name: String) throws {
            try self.linkToDataSetColumn?.validate(name: "\(name).linkToDataSetColumn")
            try self.validate(self.values, name: "values", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case linkToDataSetColumn = "LinkToDataSetColumn"
            case values = "Values"
        }
    }

    public struct ParameterSliderControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: SliderControlDisplayOptions?
        /// The smaller value that is displayed at the left of the slider.
        public let maximumValue: Double
        /// The larger value that is displayed at the right of the slider.
        public let minimumValue: Double
        /// The ID of the ParameterSliderControl.
        public let parameterControlId: String
        /// The source parameter name of the ParameterSliderControl.
        public let sourceParameterName: String
        /// The number of increments that the slider bar is divided into.
        public let stepSize: Double
        /// The title of the ParameterSliderControl.
        public let title: String

        public init(displayOptions: SliderControlDisplayOptions? = nil, maximumValue: Double, minimumValue: Double, parameterControlId: String, sourceParameterName: String, stepSize: Double, title: String) {
            self.displayOptions = displayOptions
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.stepSize = stepSize
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case stepSize = "StepSize"
            case title = "Title"
        }
    }

    public struct ParameterTextAreaControl: AWSEncodableShape & AWSDecodableShape {
        /// The delimiter that is used to separate the lines in text.
        public let delimiter: String?
        /// The display options of a control.
        public let displayOptions: TextAreaControlDisplayOptions?
        /// The ID of the ParameterTextAreaControl.
        public let parameterControlId: String
        /// The source parameter name of the ParameterTextAreaControl.
        public let sourceParameterName: String
        /// The title of the ParameterTextAreaControl.
        public let title: String

        public init(delimiter: String? = nil, displayOptions: TextAreaControlDisplayOptions? = nil, parameterControlId: String, sourceParameterName: String, title: String) {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 2048)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
        }
    }

    public struct ParameterTextFieldControl: AWSEncodableShape & AWSDecodableShape {
        /// The display options of a control.
        public let displayOptions: TextFieldControlDisplayOptions?
        /// The ID of the ParameterTextFieldControl.
        public let parameterControlId: String
        /// The source parameter name of the ParameterTextFieldControl.
        public let sourceParameterName: String
        /// The title of the ParameterTextFieldControl.
        public let title: String

        public init(displayOptions: TextFieldControlDisplayOptions? = nil, parameterControlId: String, sourceParameterName: String, title: String) {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }

        public func validate(name: String) throws {
            try self.displayOptions?.validate(name: "\(name).displayOptions")
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, max: 512)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, min: 1)
            try self.validate(self.parameterControlId, name: "parameterControlId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, max: 2048)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, min: 1)
            try self.validate(self.sourceParameterName, name: "sourceParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.title, name: "title", parent: name, max: 2048)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayOptions = "DisplayOptions"
            case parameterControlId = "ParameterControlId"
            case sourceParameterName = "SourceParameterName"
            case title = "Title"
        }
    }

    public struct Parameters: AWSEncodableShape & AWSDecodableShape {
        /// The parameters that have a data type of date-time.
        public let dateTimeParameters: [DateTimeParameter]?
        /// The parameters that have a data type of decimal.
        public let decimalParameters: [DecimalParameter]?
        /// The parameters that have a data type of integer.
        public let integerParameters: [IntegerParameter]?
        /// The parameters that have a data type of string.
        public let stringParameters: [StringParameter]?

        public init(dateTimeParameters: [DateTimeParameter]? = nil, decimalParameters: [DecimalParameter]? = nil, integerParameters: [IntegerParameter]? = nil, stringParameters: [StringParameter]? = nil) {
            self.dateTimeParameters = dateTimeParameters
            self.decimalParameters = decimalParameters
            self.integerParameters = integerParameters
            self.stringParameters = stringParameters
        }

        public func validate(name: String) throws {
            try self.dateTimeParameters?.forEach {
                try $0.validate(name: "\(name).dateTimeParameters[]")
            }
            try self.validate(self.dateTimeParameters, name: "dateTimeParameters", parent: name, max: 100)
            try self.decimalParameters?.forEach {
                try $0.validate(name: "\(name).decimalParameters[]")
            }
            try self.validate(self.decimalParameters, name: "decimalParameters", parent: name, max: 100)
            try self.integerParameters?.forEach {
                try $0.validate(name: "\(name).integerParameters[]")
            }
            try self.validate(self.integerParameters, name: "integerParameters", parent: name, max: 100)
            try self.stringParameters?.forEach {
                try $0.validate(name: "\(name).stringParameters[]")
            }
            try self.validate(self.stringParameters, name: "stringParameters", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeParameters = "DateTimeParameters"
            case decimalParameters = "DecimalParameters"
            case integerParameters = "IntegerParameters"
            case stringParameters = "StringParameters"
        }
    }

    public struct PercentVisibleRange: AWSEncodableShape & AWSDecodableShape {
        /// The lower bound of the range.
        public let from: Double?
        /// The top bound of the range.
        public let to: Double?

        public init(from: Double? = nil, to: Double? = nil) {
            self.from = from
            self.to = to
        }

        public func validate(name: String) throws {
            try self.validate(self.from, name: "from", parent: name, max: 100.0)
            try self.validate(self.from, name: "from", parent: name, min: 0.0)
            try self.validate(self.to, name: "to", parent: name, max: 100.0)
            try self.validate(self.to, name: "to", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct PercentageDisplayFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The option that determines the decimal places configuration.
        public let decimalPlacesConfiguration: DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public let negativeValueConfiguration: NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// Determines the prefix value of the percentage format.
        public let prefix: String?
        /// The options that determine the numeric separator configuration.
        public let separatorConfiguration: NumericSeparatorConfiguration?
        /// Determines the suffix value of the percentage format.
        public let suffix: String?

        public init(decimalPlacesConfiguration: DecimalPlacesConfiguration? = nil, negativeValueConfiguration: NegativeValueConfiguration? = nil, nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, prefix: String? = nil, separatorConfiguration: NumericSeparatorConfiguration? = nil, suffix: String? = nil) {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.prefix = prefix
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.decimalPlacesConfiguration?.validate(name: "\(name).decimalPlacesConfiguration")
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 128)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
            case negativeValueConfiguration = "NegativeValueConfiguration"
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case prefix = "Prefix"
            case separatorConfiguration = "SeparatorConfiguration"
            case suffix = "Suffix"
        }
    }

    public struct PercentileAggregation: AWSEncodableShape & AWSDecodableShape {
        /// The percentile value. This value can be any numeric constant 0–100. A percentile value of 50 computes the median value of the measure.
        public let percentileValue: Double?

        public init(percentileValue: Double? = nil) {
            self.percentileValue = percentileValue
        }

        public func validate(name: String) throws {
            try self.validate(self.percentileValue, name: "percentileValue", parent: name, max: 100.0)
            try self.validate(self.percentileValue, name: "percentileValue", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case percentileValue = "PercentileValue"
        }
    }

    public struct PeriodOverPeriodComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The time field that is used in a computation.
        public let time: DimensionField?
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, time: DimensionField? = nil, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.time?.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case time = "Time"
            case value = "Value"
        }
    }

    public struct PeriodToDateComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The time granularity setup of period to date computation. Choose from the following options:   YEAR: Year to date.   MONTH: Month to date.
        public let periodTimeGranularity: TimeGranularity?
        /// The time field that is used in a computation.
        public let time: DimensionField?
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, periodTimeGranularity: TimeGranularity? = nil, time: DimensionField? = nil, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.periodTimeGranularity = periodTimeGranularity
            self.time = time
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.time?.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case periodTimeGranularity = "PeriodTimeGranularity"
            case time = "Time"
            case value = "Value"
        }
    }

    public struct PieChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category (group/color) field wells of a pie chart.
        public let category: [DimensionField]?
        /// The small multiples field well of a pie chart.
        public let smallMultiples: [DimensionField]?
        /// The value field wells of a pie chart. Values are aggregated based on categories.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, smallMultiples: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.smallMultiples = smallMultiples
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.smallMultiples?.forEach {
                try $0.validate(name: "\(name).smallMultiples[]")
            }
            try self.validate(self.smallMultiples, name: "smallMultiples", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case smallMultiples = "SmallMultiples"
            case values = "Values"
        }
    }

    public struct PieChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options of the group/color that is displayed in a pie chart.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public let contributionAnalysisDefaults: [ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.
        public let donutOptions: DonutOptions?
        /// The field wells of the visual.
        public let fieldWells: PieChartFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The small multiples setup for the visual.
        public let smallMultiplesOptions: SmallMultiplesOptions?
        /// The sort configuration of a pie chart.
        public let sortConfiguration: PieChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The label options for the value that is displayed in a pie chart.
        public let valueLabelOptions: ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(categoryLabelOptions: ChartAxisLabelOptions? = nil, contributionAnalysisDefaults: [ContributionAnalysisDefault]? = nil, dataLabels: DataLabelOptions? = nil, donutOptions: DonutOptions? = nil, fieldWells: PieChartFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, smallMultiplesOptions: SmallMultiplesOptions? = nil, sortConfiguration: PieChartSortConfiguration? = nil, tooltip: TooltipOptions? = nil, valueLabelOptions: ChartAxisLabelOptions? = nil, visualPalette: VisualPalette? = nil) {
            self.categoryLabelOptions = categoryLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.donutOptions = donutOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.contributionAnalysisDefaults?.forEach {
                try $0.validate(name: "\(name).contributionAnalysisDefaults[]")
            }
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, max: 200)
            try self.validate(self.contributionAnalysisDefaults, name: "contributionAnalysisDefaults", parent: name, min: 1)
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.smallMultiplesOptions?.validate(name: "\(name).smallMultiplesOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.valueLabelOptions?.validate(name: "\(name).valueLabelOptions")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelOptions = "CategoryLabelOptions"
            case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
            case dataLabels = "DataLabels"
            case donutOptions = "DonutOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case smallMultiplesOptions = "SmallMultiplesOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case valueLabelOptions = "ValueLabelOptions"
            case visualPalette = "VisualPalette"
        }
    }

    public struct PieChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a pie chart.
        public let pieChartAggregatedFieldWells: PieChartAggregatedFieldWells?

        public init(pieChartAggregatedFieldWells: PieChartAggregatedFieldWells? = nil) {
            self.pieChartAggregatedFieldWells = pieChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.pieChartAggregatedFieldWells?.validate(name: "\(name).pieChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case pieChartAggregatedFieldWells = "PieChartAggregatedFieldWells"
        }
    }

    public struct PieChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of categories that are displayed in a pie chart.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public let smallMultiplesLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public let smallMultiplesSort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, smallMultiplesLimitConfiguration: ItemsLimitConfiguration? = nil, smallMultiplesSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.smallMultiplesSort?.forEach {
                try $0.validate(name: "\(name).smallMultiplesSort[]")
            }
            try self.validate(self.smallMultiplesSort, name: "smallMultiplesSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
            case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
            case smallMultiplesSort = "SmallMultiplesSort"
        }
    }

    public struct PieChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a pie chart.
        public let chartConfiguration: PieChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: PieChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct PivotFieldSortOptions: AWSEncodableShape & AWSDecodableShape {
        /// The field ID for the field sort options.
        public let fieldId: String
        /// The sort by field for the field sort options.
        public let sortBy: PivotTableSortBy

        public init(fieldId: String, sortBy: PivotTableSortBy) {
            self.fieldId = fieldId
            self.sortBy = sortBy
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.sortBy.validate(name: "\(name).sortBy")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case sortBy = "SortBy"
        }
    }

    public struct PivotTableAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The columns field well for a pivot table. Values are grouped by columns fields.
        public let columns: [DimensionField]?
        /// The rows field well for a pivot table. Values are grouped by rows fields.
        public let rows: [DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on rows and columns fields.
        public let values: [MeasureField]?

        public init(columns: [DimensionField]? = nil, rows: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.columns = columns
            self.rows = rows
            self.values = values
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 40)
            try self.rows?.forEach {
                try $0.validate(name: "\(name).rows[]")
            }
            try self.validate(self.rows, name: "rows", parent: name, max: 40)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 40)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case rows = "Rows"
            case values = "Values"
        }
    }

    public struct PivotTableCellConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the cell for conditional formatting.
        public let fieldId: String
        /// The scope of the cell for conditional formatting.
        public let scope: PivotTableConditionalFormattingScope?
        /// A list of cell scopes for conditional formatting.
        public let scopes: [PivotTableConditionalFormattingScope]?
        /// The text format of the cell for conditional formatting.
        public let textFormat: TextConditionalFormat?

        public init(fieldId: String, scope: PivotTableConditionalFormattingScope? = nil, scopes: [PivotTableConditionalFormattingScope]? = nil, textFormat: TextConditionalFormat? = nil) {
            self.fieldId = fieldId
            self.scope = scope
            self.scopes = scopes
            self.textFormat = textFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.scopes, name: "scopes", parent: name, max: 3)
            try self.textFormat?.validate(name: "\(name).textFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case scope = "Scope"
            case scopes = "Scopes"
            case textFormat = "TextFormat"
        }
    }

    public struct PivotTableConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options for a PivotTableVisual.
        public let conditionalFormattingOptions: [PivotTableConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [PivotTableConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct PivotTableConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The cell conditional formatting option for a pivot table.
        public let cell: PivotTableCellConditionalFormatting?

        public init(cell: PivotTableCellConditionalFormatting? = nil) {
            self.cell = cell
        }

        public func validate(name: String) throws {
            try self.cell?.validate(name: "\(name).cell")
        }

        private enum CodingKeys: String, CodingKey {
            case cell = "Cell"
        }
    }

    public struct PivotTableConditionalFormattingScope: AWSEncodableShape & AWSDecodableShape {
        /// The role (field, field total, grand total) of the cell for conditional formatting.
        public let role: PivotTableConditionalFormattingScopeRole?

        public init(role: PivotTableConditionalFormattingScopeRole? = nil) {
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case role = "Role"
        }
    }

    public struct PivotTableConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field options for a pivot table visual.
        public let fieldOptions: PivotTableFieldOptions?
        /// The field wells of the visual.
        public let fieldWells: PivotTableFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The paginated report options for a pivot table visual.
        public let paginatedReportOptions: PivotTablePaginatedReportOptions?
        /// The sort configuration for a PivotTableVisual.
        public let sortConfiguration: PivotTableSortConfiguration?
        /// The table options for a pivot table visual.
        public let tableOptions: PivotTableOptions?
        /// The total options for a pivot table visual.
        public let totalOptions: PivotTableTotalOptions?

        public init(fieldOptions: PivotTableFieldOptions? = nil, fieldWells: PivotTableFieldWells? = nil, interactions: VisualInteractionOptions? = nil, paginatedReportOptions: PivotTablePaginatedReportOptions? = nil, sortConfiguration: PivotTableSortConfiguration? = nil, tableOptions: PivotTableOptions? = nil, totalOptions: PivotTableTotalOptions? = nil) {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }

        public func validate(name: String) throws {
            try self.fieldOptions?.validate(name: "\(name).fieldOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tableOptions?.validate(name: "\(name).tableOptions")
            try self.totalOptions?.validate(name: "\(name).totalOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldOptions = "FieldOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case paginatedReportOptions = "PaginatedReportOptions"
            case sortConfiguration = "SortConfiguration"
            case tableOptions = "TableOptions"
            case totalOptions = "TotalOptions"
        }
    }

    public struct PivotTableDataPathOption: AWSEncodableShape & AWSDecodableShape {
        /// The list of data path values for the data path options.
        public let dataPathList: [DataPathValue]
        /// The width of the data path option.
        public let width: String?

        public init(dataPathList: [DataPathValue], width: String? = nil) {
            self.dataPathList = dataPathList
            self.width = width
        }

        public func validate(name: String) throws {
            try self.dataPathList.forEach {
                try $0.validate(name: "\(name).dataPathList[]")
            }
            try self.validate(self.dataPathList, name: "dataPathList", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case dataPathList = "DataPathList"
            case width = "Width"
        }
    }

    public struct PivotTableFieldCollapseStateOption: AWSEncodableShape & AWSDecodableShape {
        /// The state of the field target of a pivot table. Choose one of the following options:    COLLAPSED     EXPANDED
        public let state: PivotTableFieldCollapseState?
        /// A tagged-union object that sets the collapse state.
        public let target: PivotTableFieldCollapseStateTarget

        public init(state: PivotTableFieldCollapseState? = nil, target: PivotTableFieldCollapseStateTarget) {
            self.state = state
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case target = "Target"
        }
    }

    public struct PivotTableFieldCollapseStateTarget: AWSEncodableShape & AWSDecodableShape {
        /// The data path of the pivot table's header. Used to set the collapse state.
        public let fieldDataPathValues: [DataPathValue]?
        /// The field ID of the pivot table that the collapse state needs to be set to.
        public let fieldId: String?

        public init(fieldDataPathValues: [DataPathValue]? = nil, fieldId: String? = nil) {
            self.fieldDataPathValues = fieldDataPathValues
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.fieldDataPathValues?.forEach {
                try $0.validate(name: "\(name).fieldDataPathValues[]")
            }
            try self.validate(self.fieldDataPathValues, name: "fieldDataPathValues", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldDataPathValues = "FieldDataPathValues"
            case fieldId = "FieldId"
        }
    }

    public struct PivotTableFieldOption: AWSEncodableShape & AWSDecodableShape {
        /// The custom label of the pivot table field.
        public let customLabel: String?
        /// The field ID of the pivot table field.
        public let fieldId: String
        /// The visibility of the pivot table field.
        public let visibility: Visibility?

        public init(customLabel: String? = nil, fieldId: String, visibility: Visibility? = nil) {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.customLabel, name: "customLabel", parent: name, max: 2048)
            try self.validate(self.customLabel, name: "customLabel", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fieldId = "FieldId"
            case visibility = "Visibility"
        }
    }

    public struct PivotTableFieldOptions: AWSEncodableShape & AWSDecodableShape {
        /// The collapse state options for the pivot table field options.
        public let collapseStateOptions: [PivotTableFieldCollapseStateOption]?
        /// The data path options for the pivot table field options.
        public let dataPathOptions: [PivotTableDataPathOption]?
        /// The selected field options for the pivot table field options.
        public let selectedFieldOptions: [PivotTableFieldOption]?

        public init(collapseStateOptions: [PivotTableFieldCollapseStateOption]? = nil, dataPathOptions: [PivotTableDataPathOption]? = nil, selectedFieldOptions: [PivotTableFieldOption]? = nil) {
            self.collapseStateOptions = collapseStateOptions
            self.dataPathOptions = dataPathOptions
            self.selectedFieldOptions = selectedFieldOptions
        }

        public func validate(name: String) throws {
            try self.collapseStateOptions?.forEach {
                try $0.validate(name: "\(name).collapseStateOptions[]")
            }
            try self.dataPathOptions?.forEach {
                try $0.validate(name: "\(name).dataPathOptions[]")
            }
            try self.validate(self.dataPathOptions, name: "dataPathOptions", parent: name, max: 100)
            try self.selectedFieldOptions?.forEach {
                try $0.validate(name: "\(name).selectedFieldOptions[]")
            }
            try self.validate(self.selectedFieldOptions, name: "selectedFieldOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case collapseStateOptions = "CollapseStateOptions"
            case dataPathOptions = "DataPathOptions"
            case selectedFieldOptions = "SelectedFieldOptions"
        }
    }

    public struct PivotTableFieldSubtotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the subtotal options.
        public let fieldId: String?

        public init(fieldId: String? = nil) {
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
        }
    }

    public struct PivotTableFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well for the pivot table.
        public let pivotTableAggregatedFieldWells: PivotTableAggregatedFieldWells?

        public init(pivotTableAggregatedFieldWells: PivotTableAggregatedFieldWells? = nil) {
            self.pivotTableAggregatedFieldWells = pivotTableAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.pivotTableAggregatedFieldWells?.validate(name: "\(name).pivotTableAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case pivotTableAggregatedFieldWells = "PivotTableAggregatedFieldWells"
        }
    }

    public struct PivotTableOptions: AWSEncodableShape & AWSDecodableShape {
        /// The table cell style of cells.
        public let cellStyle: TableCellStyle?
        /// The visibility setting of a pivot table's collapsed row dimension fields. If the value of this structure is HIDDEN, all collapsed columns in a pivot table are automatically hidden. The default value is VISIBLE.
        public let collapsedRowDimensionsVisibility: Visibility?
        /// The table cell style of the column header.
        public let columnHeaderStyle: TableCellStyle?
        /// The visibility of the column names.
        public let columnNamesVisibility: Visibility?
        /// The default cell width of the pivot table.
        public let defaultCellWidth: String?
        /// The metric placement (row, column) options.
        public let metricPlacement: PivotTableMetricPlacement?
        /// The row alternate color options (widget status, row alternate colors).
        public let rowAlternateColorOptions: RowAlternateColorOptions?
        /// The table cell style of row field names.
        public let rowFieldNamesStyle: TableCellStyle?
        /// The table cell style of the row headers.
        public let rowHeaderStyle: TableCellStyle?
        /// The options for the label that is located above the row headers. This option is only applicable when RowsLayout is set to HIERARCHY.
        public let rowsLabelOptions: PivotTableRowsLabelOptions?
        /// The layout for the row dimension headers of a pivot table. Choose one of the following options.    TABULAR: (Default) Each row field is displayed in a separate column.    HIERARCHY: All row fields are displayed in a single column. Indentation is used to differentiate row headers of different fields.
        public let rowsLayout: PivotTableRowsLayout?
        /// The visibility of the single metric options.
        public let singleMetricVisibility: Visibility?
        /// Determines the visibility of the pivot table.
        public let toggleButtonsVisibility: Visibility?

        public init(cellStyle: TableCellStyle? = nil, collapsedRowDimensionsVisibility: Visibility? = nil, columnHeaderStyle: TableCellStyle? = nil, columnNamesVisibility: Visibility? = nil, defaultCellWidth: String? = nil, metricPlacement: PivotTableMetricPlacement? = nil, rowAlternateColorOptions: RowAlternateColorOptions? = nil, rowFieldNamesStyle: TableCellStyle? = nil, rowHeaderStyle: TableCellStyle? = nil, rowsLabelOptions: PivotTableRowsLabelOptions? = nil, rowsLayout: PivotTableRowsLayout? = nil, singleMetricVisibility: Visibility? = nil, toggleButtonsVisibility: Visibility? = nil) {
            self.cellStyle = cellStyle
            self.collapsedRowDimensionsVisibility = collapsedRowDimensionsVisibility
            self.columnHeaderStyle = columnHeaderStyle
            self.columnNamesVisibility = columnNamesVisibility
            self.defaultCellWidth = defaultCellWidth
            self.metricPlacement = metricPlacement
            self.rowAlternateColorOptions = rowAlternateColorOptions
            self.rowFieldNamesStyle = rowFieldNamesStyle
            self.rowHeaderStyle = rowHeaderStyle
            self.rowsLabelOptions = rowsLabelOptions
            self.rowsLayout = rowsLayout
            self.singleMetricVisibility = singleMetricVisibility
            self.toggleButtonsVisibility = toggleButtonsVisibility
        }

        public func validate(name: String) throws {
            try self.cellStyle?.validate(name: "\(name).cellStyle")
            try self.columnHeaderStyle?.validate(name: "\(name).columnHeaderStyle")
            try self.rowAlternateColorOptions?.validate(name: "\(name).rowAlternateColorOptions")
            try self.rowFieldNamesStyle?.validate(name: "\(name).rowFieldNamesStyle")
            try self.rowHeaderStyle?.validate(name: "\(name).rowHeaderStyle")
            try self.rowsLabelOptions?.validate(name: "\(name).rowsLabelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case cellStyle = "CellStyle"
            case collapsedRowDimensionsVisibility = "CollapsedRowDimensionsVisibility"
            case columnHeaderStyle = "ColumnHeaderStyle"
            case columnNamesVisibility = "ColumnNamesVisibility"
            case defaultCellWidth = "DefaultCellWidth"
            case metricPlacement = "MetricPlacement"
            case rowAlternateColorOptions = "RowAlternateColorOptions"
            case rowFieldNamesStyle = "RowFieldNamesStyle"
            case rowHeaderStyle = "RowHeaderStyle"
            case rowsLabelOptions = "RowsLabelOptions"
            case rowsLayout = "RowsLayout"
            case singleMetricVisibility = "SingleMetricVisibility"
            case toggleButtonsVisibility = "ToggleButtonsVisibility"
        }
    }

    public struct PivotTablePaginatedReportOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the repeating header rows on each page.
        public let overflowColumnHeaderVisibility: Visibility?
        /// The visibility of the printing table overflow across pages.
        public let verticalOverflowVisibility: Visibility?

        public init(overflowColumnHeaderVisibility: Visibility? = nil, verticalOverflowVisibility: Visibility? = nil) {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case overflowColumnHeaderVisibility = "OverflowColumnHeaderVisibility"
            case verticalOverflowVisibility = "VerticalOverflowVisibility"
        }
    }

    public struct PivotTableRowsLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The custom label string for the rows label.
        public let customLabel: String?
        /// The visibility of the rows label.
        public let visibility: Visibility?

        public init(customLabel: String? = nil, visibility: Visibility? = nil) {
            self.customLabel = customLabel
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.customLabel, name: "customLabel", parent: name, max: 1024)
            try self.validate(self.customLabel, name: "customLabel", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case visibility = "Visibility"
        }
    }

    public struct PivotTableSortBy: AWSEncodableShape & AWSDecodableShape {
        /// The column sort (field id, direction) for the pivot table sort by options.
        public let column: ColumnSort?
        /// The data path sort (data path value, direction) for the pivot table sort by options.
        public let dataPath: DataPathSort?
        /// The field sort (field id, direction) for the pivot table sort by options.
        public let field: FieldSort?

        public init(column: ColumnSort? = nil, dataPath: DataPathSort? = nil, field: FieldSort? = nil) {
            self.column = column
            self.dataPath = dataPath
            self.field = field
        }

        public func validate(name: String) throws {
            try self.column?.validate(name: "\(name).column")
            try self.dataPath?.validate(name: "\(name).dataPath")
            try self.field?.validate(name: "\(name).field")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case dataPath = "DataPath"
            case field = "Field"
        }
    }

    public struct PivotTableSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field sort options for a pivot table sort configuration.
        public let fieldSortOptions: [PivotFieldSortOptions]?

        public init(fieldSortOptions: [PivotFieldSortOptions]? = nil) {
            self.fieldSortOptions = fieldSortOptions
        }

        public func validate(name: String) throws {
            try self.fieldSortOptions?.forEach {
                try $0.validate(name: "\(name).fieldSortOptions[]")
            }
            try self.validate(self.fieldSortOptions, name: "fieldSortOptions", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldSortOptions = "FieldSortOptions"
        }
    }

    public struct PivotTableTotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The column subtotal options.
        public let columnSubtotalOptions: SubtotalOptions?
        /// The column total options.
        public let columnTotalOptions: PivotTotalOptions?
        /// The row subtotal options.
        public let rowSubtotalOptions: SubtotalOptions?
        /// The row total options.
        public let rowTotalOptions: PivotTotalOptions?

        public init(columnSubtotalOptions: SubtotalOptions? = nil, columnTotalOptions: PivotTotalOptions? = nil, rowSubtotalOptions: SubtotalOptions? = nil, rowTotalOptions: PivotTotalOptions? = nil) {
            self.columnSubtotalOptions = columnSubtotalOptions
            self.columnTotalOptions = columnTotalOptions
            self.rowSubtotalOptions = rowSubtotalOptions
            self.rowTotalOptions = rowTotalOptions
        }

        public func validate(name: String) throws {
            try self.columnSubtotalOptions?.validate(name: "\(name).columnSubtotalOptions")
            try self.columnTotalOptions?.validate(name: "\(name).columnTotalOptions")
            try self.rowSubtotalOptions?.validate(name: "\(name).rowSubtotalOptions")
            try self.rowTotalOptions?.validate(name: "\(name).rowTotalOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case columnSubtotalOptions = "ColumnSubtotalOptions"
            case columnTotalOptions = "ColumnTotalOptions"
            case rowSubtotalOptions = "RowSubtotalOptions"
            case rowTotalOptions = "RowTotalOptions"
        }
    }

    public struct PivotTableVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: PivotTableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public let conditionalFormatting: PivotTableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: PivotTableConfiguration? = nil, conditionalFormatting: PivotTableConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct PivotTotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The custom label string for the total cells.
        public let customLabel: String?
        /// The cell styling options for the total of header cells.
        public let metricHeaderCellStyle: TableCellStyle?
        /// The placement (start, end) for the total cells.
        public let placement: TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public let scrollStatus: TableTotalsScrollStatus?
        /// The total aggregation options for each value field.
        public let totalAggregationOptions: [TotalAggregationOption]?
        /// The cell styling options for the total cells.
        public let totalCellStyle: TableCellStyle?
        /// The visibility configuration for the total cells.
        public let totalsVisibility: Visibility?
        /// The cell styling options for the totals of value cells.
        public let valueCellStyle: TableCellStyle?

        public init(customLabel: String? = nil, metricHeaderCellStyle: TableCellStyle? = nil, placement: TableTotalsPlacement? = nil, scrollStatus: TableTotalsScrollStatus? = nil, totalAggregationOptions: [TotalAggregationOption]? = nil, totalCellStyle: TableCellStyle? = nil, totalsVisibility: Visibility? = nil, valueCellStyle: TableCellStyle? = nil) {
            self.customLabel = customLabel
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalAggregationOptions = totalAggregationOptions
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }

        public func validate(name: String) throws {
            try self.metricHeaderCellStyle?.validate(name: "\(name).metricHeaderCellStyle")
            try self.totalAggregationOptions?.forEach {
                try $0.validate(name: "\(name).totalAggregationOptions[]")
            }
            try self.validate(self.totalAggregationOptions, name: "totalAggregationOptions", parent: name, max: 200)
            try self.totalCellStyle?.validate(name: "\(name).totalCellStyle")
            try self.valueCellStyle?.validate(name: "\(name).valueCellStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case metricHeaderCellStyle = "MetricHeaderCellStyle"
            case placement = "Placement"
            case scrollStatus = "ScrollStatus"
            case totalAggregationOptions = "TotalAggregationOptions"
            case totalCellStyle = "TotalCellStyle"
            case totalsVisibility = "TotalsVisibility"
            case valueCellStyle = "ValueCellStyle"
        }
    }

    public struct PostgreSqlParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct PredefinedHierarchy: AWSEncodableShape & AWSDecodableShape {
        /// The list of columns that define the predefined hierarchy.
        public let columns: [ColumnIdentifier]
        /// The option that determines the drill down filters for the predefined hierarchy.
        public let drillDownFilters: [DrillDownFilter]?
        /// The hierarchy ID of the predefined hierarchy.
        public let hierarchyId: String

        public init(columns: [ColumnIdentifier], drillDownFilters: [DrillDownFilter]? = nil, hierarchyId: String) {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 10)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
            try self.drillDownFilters?.forEach {
                try $0.validate(name: "\(name).drillDownFilters[]")
            }
            try self.validate(self.drillDownFilters, name: "drillDownFilters", parent: name, max: 10)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 512)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case drillDownFilters = "DrillDownFilters"
            case hierarchyId = "HierarchyId"
        }
    }

    public struct PrestoParameters: AWSEncodableShape & AWSDecodableShape {
        /// Catalog.
        public let catalog: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(catalog: String, host: String, port: Int) {
            self.catalog = catalog
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 128)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct ProgressBarOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the progress bar.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct ProjectOperation: AWSEncodableShape & AWSDecodableShape {
        /// Projected columns.
        public let projectedColumns: [String]

        public init(projectedColumns: [String]) {
            self.projectedColumns = projectedColumns
        }

        public func validate(name: String) throws {
            try self.validate(self.projectedColumns, name: "projectedColumns", parent: name, max: 2000)
            try self.validate(self.projectedColumns, name: "projectedColumns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case projectedColumns = "ProjectedColumns"
        }
    }

    public struct PutDataSetRefreshPropertiesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String
        /// The dataset refresh properties.
        public let dataSetRefreshProperties: DataSetRefreshProperties

        public init(awsAccountId: String, dataSetId: String, dataSetRefreshProperties: DataSetRefreshProperties) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.dataSetRefreshProperties = dataSetRefreshProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encode(self.dataSetRefreshProperties, forKey: .dataSetRefreshProperties)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.dataSetRefreshProperties.validate(name: "\(name).dataSetRefreshProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetRefreshProperties = "DataSetRefreshProperties"
        }
    }

    public struct PutDataSetRefreshPropertiesResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct QueueInfo: AWSDecodableShape {
        /// The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.
        public let queuedIngestion: String
        /// The ID of the queued ingestion.
        public let waitingOnIngestion: String

        public init(queuedIngestion: String, waitingOnIngestion: String) {
            self.queuedIngestion = queuedIngestion
            self.waitingOnIngestion = waitingOnIngestion
        }

        private enum CodingKeys: String, CodingKey {
            case queuedIngestion = "QueuedIngestion"
            case waitingOnIngestion = "WaitingOnIngestion"
        }
    }

    public struct RadarChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well categories of a radar chart.
        public let category: [DimensionField]?
        /// The color that are assigned to the aggregated field wells of a radar chart.
        public let color: [DimensionField]?
        /// The values that are assigned to the aggregated field wells of a radar chart.
        public let values: [MeasureField]?

        public init(category: [DimensionField]? = nil, color: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.category = category
            self.color = color
            self.values = values
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 1)
            try self.color?.forEach {
                try $0.validate(name: "\(name).color[]")
            }
            try self.validate(self.color, name: "color", parent: name, max: 1)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case color = "Color"
            case values = "Values"
        }
    }

    public struct RadarChartAreaStyleSettings: AWSEncodableShape & AWSDecodableShape {
        /// The visibility settings of a radar chart.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct RadarChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of the colors of alternatign bands in a radar chart.
        public let alternateBandColorsVisibility: Visibility?
        /// The color of the even-numbered alternate bands of a radar chart.
        public let alternateBandEvenColor: String?
        /// The color of the odd-numbered alternate bands of a radar chart.
        public let alternateBandOddColor: String?
        /// The axis behavior options of a radar chart.
        public let axesRangeScale: RadarChartAxesRangeScale?
        /// The base sreies settings of a radar chart.
        public let baseSeriesSettings: RadarChartSeriesSettings?
        /// The category axis of a radar chart.
        public let categoryAxis: AxisDisplayOptions?
        /// The category label options of a radar chart.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The color axis of a radar chart.
        public let colorAxis: AxisDisplayOptions?
        /// The color label options of a radar chart.
        public let colorLabelOptions: ChartAxisLabelOptions?
        /// The field well configuration of a RadarChartVisual.
        public let fieldWells: RadarChartFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The shape of the radar chart.
        public let shape: RadarChartShape?
        /// The sort configuration of a RadarChartVisual.
        public let sortConfiguration: RadarChartSortConfiguration?
        /// The start angle of a radar chart's axis.
        public let startAngle: Double?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?

        public init(alternateBandColorsVisibility: Visibility? = nil, alternateBandEvenColor: String? = nil, alternateBandOddColor: String? = nil, axesRangeScale: RadarChartAxesRangeScale? = nil, baseSeriesSettings: RadarChartSeriesSettings? = nil, categoryAxis: AxisDisplayOptions? = nil, categoryLabelOptions: ChartAxisLabelOptions? = nil, colorAxis: AxisDisplayOptions? = nil, colorLabelOptions: ChartAxisLabelOptions? = nil, fieldWells: RadarChartFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, shape: RadarChartShape? = nil, sortConfiguration: RadarChartSortConfiguration? = nil, startAngle: Double? = nil, visualPalette: VisualPalette? = nil) {
            self.alternateBandColorsVisibility = alternateBandColorsVisibility
            self.alternateBandEvenColor = alternateBandEvenColor
            self.alternateBandOddColor = alternateBandOddColor
            self.axesRangeScale = axesRangeScale
            self.baseSeriesSettings = baseSeriesSettings
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorAxis = colorAxis
            self.colorLabelOptions = colorLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.shape = shape
            self.sortConfiguration = sortConfiguration
            self.startAngle = startAngle
            self.visualPalette = visualPalette
        }

        public func validate(name: String) throws {
            try self.validate(self.alternateBandEvenColor, name: "alternateBandEvenColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.alternateBandOddColor, name: "alternateBandOddColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.categoryAxis?.validate(name: "\(name).categoryAxis")
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.colorAxis?.validate(name: "\(name).colorAxis")
            try self.colorLabelOptions?.validate(name: "\(name).colorLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.validate(self.startAngle, name: "startAngle", parent: name, max: 360.0)
            try self.validate(self.startAngle, name: "startAngle", parent: name, min: -360.0)
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case alternateBandColorsVisibility = "AlternateBandColorsVisibility"
            case alternateBandEvenColor = "AlternateBandEvenColor"
            case alternateBandOddColor = "AlternateBandOddColor"
            case axesRangeScale = "AxesRangeScale"
            case baseSeriesSettings = "BaseSeriesSettings"
            case categoryAxis = "CategoryAxis"
            case categoryLabelOptions = "CategoryLabelOptions"
            case colorAxis = "ColorAxis"
            case colorLabelOptions = "ColorLabelOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case shape = "Shape"
            case sortConfiguration = "SortConfiguration"
            case startAngle = "StartAngle"
            case visualPalette = "VisualPalette"
        }
    }

    public struct RadarChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a radar chart visual.
        public let radarChartAggregatedFieldWells: RadarChartAggregatedFieldWells?

        public init(radarChartAggregatedFieldWells: RadarChartAggregatedFieldWells? = nil) {
            self.radarChartAggregatedFieldWells = radarChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.radarChartAggregatedFieldWells?.validate(name: "\(name).radarChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case radarChartAggregatedFieldWells = "RadarChartAggregatedFieldWells"
        }
    }

    public struct RadarChartSeriesSettings: AWSEncodableShape & AWSDecodableShape {
        /// The area style settings of a radar chart.
        public let areaStyleSettings: RadarChartAreaStyleSettings?

        public init(areaStyleSettings: RadarChartAreaStyleSettings? = nil) {
            self.areaStyleSettings = areaStyleSettings
        }

        private enum CodingKeys: String, CodingKey {
            case areaStyleSettings = "AreaStyleSettings"
        }
    }

    public struct RadarChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The category items limit for a radar chart.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The category sort options of a radar chart.
        public let categorySort: [FieldSortOptions]?
        /// The color items limit of a radar chart.
        public let colorItemsLimit: ItemsLimitConfiguration?
        /// The color sort configuration of a radar chart.
        public let colorSort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil, colorItemsLimit: ItemsLimitConfiguration? = nil, colorSort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
            try self.colorSort?.forEach {
                try $0.validate(name: "\(name).colorSort[]")
            }
            try self.validate(self.colorSort, name: "colorSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
            case colorItemsLimit = "ColorItemsLimit"
            case colorSort = "ColorSort"
        }
    }

    public struct RadarChartVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: RadarChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: RadarChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct RangeConstant: AWSEncodableShape & AWSDecodableShape {
        /// The maximum value for a range constant.
        public let maximum: String?
        /// The minimum value for a range constant.
        public let minimum: String?

        public init(maximum: String? = nil, minimum: String? = nil) {
            self.maximum = maximum
            self.minimum = minimum
        }

        public func validate(name: String) throws {
            try self.validate(self.maximum, name: "maximum", parent: name, max: 256)
            try self.validate(self.minimum, name: "minimum", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maximum = "Maximum"
            case minimum = "Minimum"
        }
    }

    public struct RangeEndsLabelType: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the range ends label.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct RdsParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Instance ID.
        public let instanceId: String

        public init(database: String, instanceId: String) {
            self.database = database
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 64)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case instanceId = "InstanceId"
        }
    }

    public struct RedshiftIAMParameters: AWSEncodableShape & AWSDecodableShape {
        /// Automatically creates a database user. If your database doesn't have a DatabaseUser, set this parameter to True. If there is no DatabaseUser, Amazon QuickSight can't connect to your cluster. The RoleArn that you use for this operation must grant access to redshift:CreateClusterUser to successfully create the user.
        public let autoCreateDatabaseUser: Bool?
        /// A list of groups whose permissions will be granted to Amazon QuickSight to access the cluster. These permissions are combined with the permissions granted to Amazon QuickSight by the DatabaseUser. If you choose to include this parameter, the RoleArn must grant access to redshift:JoinGroup.
        public let databaseGroups: [String]?
        /// The user whose permissions and group memberships will be used by Amazon QuickSight to access the cluster. If this user already exists in your database, Amazon QuickSight is granted the same permissions that the user has. If the user doesn't exist, set the value of AutoCreateDatabaseUser to True to create a new user with PUBLIC permissions.
        public let databaseUser: String
        /// Use the RoleArn structure to allow Amazon QuickSight to call redshift:GetClusterCredentials on your cluster. The calling principal must have iam:PassRole access to pass the role to Amazon QuickSight. The role's trust policy must allow the Amazon QuickSight service principal to assume the role.
        public let roleArn: String

        public init(autoCreateDatabaseUser: Bool? = nil, databaseGroups: [String]? = nil, databaseUser: String, roleArn: String) {
            self.autoCreateDatabaseUser = autoCreateDatabaseUser
            self.databaseGroups = databaseGroups
            self.databaseUser = databaseUser
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.databaseGroups?.forEach {
                try validate($0, name: "databaseGroups[]", parent: name, max: 64)
                try validate($0, name: "databaseGroups[]", parent: name, min: 1)
            }
            try self.validate(self.databaseGroups, name: "databaseGroups", parent: name, max: 50)
            try self.validate(self.databaseGroups, name: "databaseGroups", parent: name, min: 1)
            try self.validate(self.databaseUser, name: "databaseUser", parent: name, max: 64)
            try self.validate(self.databaseUser, name: "databaseUser", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case autoCreateDatabaseUser = "AutoCreateDatabaseUser"
            case databaseGroups = "DatabaseGroups"
            case databaseUser = "DatabaseUser"
            case roleArn = "RoleArn"
        }
    }

    public struct RedshiftParameters: AWSEncodableShape & AWSDecodableShape {
        /// Cluster ID. This field can be blank if the Host and Port are provided.
        public let clusterId: String?
        /// Database.
        public let database: String
        /// Host. This field can be blank if ClusterId is provided.
        public let host: String?
        /// An optional parameter that uses IAM authentication to grant Amazon QuickSight access to your cluster. This parameter can be used instead of DataSourceCredentials.
        public let iamParameters: RedshiftIAMParameters?
        /// An optional parameter that configures IAM Identity Center authentication to grant Amazon QuickSight access to your cluster. This parameter can only be specified if your Amazon QuickSight account is configured with IAM Identity Center.
        public let identityCenterConfiguration: IdentityCenterConfiguration?
        /// Port. This field can be blank if the ClusterId is provided.
        public let port: Int?

        public init(clusterId: String? = nil, database: String, host: String? = nil, iamParameters: RedshiftIAMParameters? = nil, identityCenterConfiguration: IdentityCenterConfiguration? = nil, port: Int? = nil) {
            self.clusterId = clusterId
            self.database = database
            self.host = host
            self.iamParameters = iamParameters
            self.identityCenterConfiguration = identityCenterConfiguration
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterId, name: "clusterId", parent: name, max: 64)
            try self.validate(self.clusterId, name: "clusterId", parent: name, min: 1)
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.iamParameters?.validate(name: "\(name).iamParameters")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clusterId = "ClusterId"
            case database = "Database"
            case host = "Host"
            case iamParameters = "IAMParameters"
            case identityCenterConfiguration = "IdentityCenterConfiguration"
            case port = "Port"
        }
    }

    public struct ReferenceLine: AWSEncodableShape & AWSDecodableShape {
        /// The data configuration of the reference line.
        public let dataConfiguration: ReferenceLineDataConfiguration
        /// The label configuration of the reference line.
        public let labelConfiguration: ReferenceLineLabelConfiguration?
        /// The status of the reference line. Choose one of the following options:    ENABLE     DISABLE
        public let status: WidgetStatus?
        /// The style configuration of the reference line.
        public let styleConfiguration: ReferenceLineStyleConfiguration?

        public init(dataConfiguration: ReferenceLineDataConfiguration, labelConfiguration: ReferenceLineLabelConfiguration? = nil, status: WidgetStatus? = nil, styleConfiguration: ReferenceLineStyleConfiguration? = nil) {
            self.dataConfiguration = dataConfiguration
            self.labelConfiguration = labelConfiguration
            self.status = status
            self.styleConfiguration = styleConfiguration
        }

        public func validate(name: String) throws {
            try self.dataConfiguration.validate(name: "\(name).dataConfiguration")
            try self.labelConfiguration?.validate(name: "\(name).labelConfiguration")
            try self.styleConfiguration?.validate(name: "\(name).styleConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataConfiguration = "DataConfiguration"
            case labelConfiguration = "LabelConfiguration"
            case status = "Status"
            case styleConfiguration = "StyleConfiguration"
        }
    }

    public struct ReferenceLineCustomLabelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The string text of the custom label.
        public let customLabel: String

        public init(customLabel: String) {
            self.customLabel = customLabel
        }

        public func validate(name: String) throws {
            try self.validate(self.customLabel, name: "customLabel", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
        }
    }

    public struct ReferenceLineDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The axis binding type of the reference line. Choose one of the following options:    PrimaryY     SecondaryY
        public let axisBinding: AxisBinding?
        /// The dynamic configuration of the reference line data configuration.
        public let dynamicConfiguration: ReferenceLineDynamicDataConfiguration?
        /// The series type of the reference line data configuration. Choose one of the following options:    BAR     LINE
        public let seriesType: ReferenceLineSeriesType?
        /// The static data configuration of the reference line data configuration.
        public let staticConfiguration: ReferenceLineStaticDataConfiguration?

        public init(axisBinding: AxisBinding? = nil, dynamicConfiguration: ReferenceLineDynamicDataConfiguration? = nil, seriesType: ReferenceLineSeriesType? = nil, staticConfiguration: ReferenceLineStaticDataConfiguration? = nil) {
            self.axisBinding = axisBinding
            self.dynamicConfiguration = dynamicConfiguration
            self.seriesType = seriesType
            self.staticConfiguration = staticConfiguration
        }

        public func validate(name: String) throws {
            try self.dynamicConfiguration?.validate(name: "\(name).dynamicConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case axisBinding = "AxisBinding"
            case dynamicConfiguration = "DynamicConfiguration"
            case seriesType = "SeriesType"
            case staticConfiguration = "StaticConfiguration"
        }
    }

    public struct ReferenceLineDynamicDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The calculation that is used in the dynamic data.
        public let calculation: NumericalAggregationFunction
        /// The column that the dynamic data targets.
        public let column: ColumnIdentifier
        /// The aggregation function that is used in the dynamic data.
        public let measureAggregationFunction: AggregationFunction?

        public init(calculation: NumericalAggregationFunction, column: ColumnIdentifier, measureAggregationFunction: AggregationFunction? = nil) {
            self.calculation = calculation
            self.column = column
            self.measureAggregationFunction = measureAggregationFunction
        }

        public func validate(name: String) throws {
            try self.calculation.validate(name: "\(name).calculation")
            try self.column.validate(name: "\(name).column")
            try self.measureAggregationFunction?.validate(name: "\(name).measureAggregationFunction")
        }

        private enum CodingKeys: String, CodingKey {
            case calculation = "Calculation"
            case column = "Column"
            case measureAggregationFunction = "MeasureAggregationFunction"
        }
    }

    public struct ReferenceLineLabelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The custom label configuration of the label in a reference line.
        public let customLabelConfiguration: ReferenceLineCustomLabelConfiguration?
        /// The font color configuration of the label in a reference line.
        public let fontColor: String?
        /// The font configuration of the label in a reference line.
        public let fontConfiguration: FontConfiguration?
        /// The horizontal position configuration of the label in a reference line. Choose one of the following options:    LEFT     CENTER     RIGHT
        public let horizontalPosition: ReferenceLineLabelHorizontalPosition?
        /// The value label configuration of the label in a reference line.
        public let valueLabelConfiguration: ReferenceLineValueLabelConfiguration?
        /// The vertical position configuration of the label in a reference line. Choose one of the following options:    ABOVE     BELOW
        public let verticalPosition: ReferenceLineLabelVerticalPosition?

        public init(customLabelConfiguration: ReferenceLineCustomLabelConfiguration? = nil, fontColor: String? = nil, fontConfiguration: FontConfiguration? = nil, horizontalPosition: ReferenceLineLabelHorizontalPosition? = nil, valueLabelConfiguration: ReferenceLineValueLabelConfiguration? = nil, verticalPosition: ReferenceLineLabelVerticalPosition? = nil) {
            self.customLabelConfiguration = customLabelConfiguration
            self.fontColor = fontColor
            self.fontConfiguration = fontConfiguration
            self.horizontalPosition = horizontalPosition
            self.valueLabelConfiguration = valueLabelConfiguration
            self.verticalPosition = verticalPosition
        }

        public func validate(name: String) throws {
            try self.customLabelConfiguration?.validate(name: "\(name).customLabelConfiguration")
            try self.validate(self.fontColor, name: "fontColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
            try self.valueLabelConfiguration?.validate(name: "\(name).valueLabelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabelConfiguration = "CustomLabelConfiguration"
            case fontColor = "FontColor"
            case fontConfiguration = "FontConfiguration"
            case horizontalPosition = "HorizontalPosition"
            case valueLabelConfiguration = "ValueLabelConfiguration"
            case verticalPosition = "VerticalPosition"
        }
    }

    public struct ReferenceLineStaticDataConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The double input of the static data.
        public let value: Double

        public init(value: Double) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct ReferenceLineStyleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The hex color of the reference line.
        public let color: String?
        /// The pattern type of the line style. Choose one of the following options:    SOLID     DASHED     DOTTED
        public let pattern: ReferenceLinePatternType?

        public init(color: String? = nil, pattern: ReferenceLinePatternType? = nil) {
            self.color = color
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case pattern = "Pattern"
        }
    }

    public struct ReferenceLineValueLabelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The format configuration of the value label.
        public let formatConfiguration: NumericFormatConfiguration?
        /// The relative position of the value label. Choose one of the following options:    BEFORE_CUSTOM_LABEL     AFTER_CUSTOM_LABEL
        public let relativePosition: ReferenceLineValueLabelRelativePosition?

        public init(formatConfiguration: NumericFormatConfiguration? = nil, relativePosition: ReferenceLineValueLabelRelativePosition? = nil) {
            self.formatConfiguration = formatConfiguration
            self.relativePosition = relativePosition
        }

        public func validate(name: String) throws {
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case formatConfiguration = "FormatConfiguration"
            case relativePosition = "RelativePosition"
        }
    }

    public struct RefreshConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The incremental refresh for the dataset.
        public let incrementalRefresh: IncrementalRefresh

        public init(incrementalRefresh: IncrementalRefresh) {
            self.incrementalRefresh = incrementalRefresh
        }

        public func validate(name: String) throws {
            try self.incrementalRefresh.validate(name: "\(name).incrementalRefresh")
        }

        private enum CodingKeys: String, CodingKey {
            case incrementalRefresh = "IncrementalRefresh"
        }
    }

    public struct RefreshFrequency: AWSEncodableShape & AWSDecodableShape {
        /// The interval between scheduled refreshes. Valid values are as follows:    MINUTE15: The dataset refreshes every 15 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.    MINUTE30:The dataset refreshes every 30 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.    HOURLY: The dataset refreshes every hour. This interval can only be used for one schedule per dataset.    DAILY: The dataset refreshes every day.    WEEKLY: The dataset refreshes every week.    MONTHLY: The dataset refreshes every month.
        public let interval: RefreshInterval
        /// The day of the week that you want to schedule the refresh on. This value is required for weekly and monthly refresh intervals.
        public let refreshOnDay: ScheduleRefreshOnEntity?
        /// The time of day that you want the datset to refresh. This value is expressed in HH:MM format. This field is not required for schedules that refresh hourly.
        public let timeOfTheDay: String?
        /// The timezone that you want the refresh schedule to use. The timezone ID must match a corresponding ID found on java.util.time.getAvailableIDs().
        public let timezone: String?

        public init(interval: RefreshInterval, refreshOnDay: ScheduleRefreshOnEntity? = nil, timeOfTheDay: String? = nil, timezone: String? = nil) {
            self.interval = interval
            self.refreshOnDay = refreshOnDay
            self.timeOfTheDay = timeOfTheDay
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.refreshOnDay?.validate(name: "\(name).refreshOnDay")
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "Interval"
            case refreshOnDay = "RefreshOnDay"
            case timeOfTheDay = "TimeOfTheDay"
            case timezone = "Timezone"
        }
    }

    public struct RefreshSchedule: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the refresh schedule.
        public let arn: String?
        /// The type of refresh that a datset undergoes. Valid values are as follows:    FULL_REFRESH: A complete refresh of a dataset.    INCREMENTAL_REFRESH: A partial refresh of some rows of a dataset, based on the time window specified.   For more information on full and incremental refreshes, see Refreshing SPICE data in the Amazon QuickSight User Guide.
        public let refreshType: IngestionType
        /// The frequency for the refresh schedule.
        public let scheduleFrequency: RefreshFrequency
        /// An identifier for the refresh schedule.
        public let scheduleId: String
        /// Time after which the refresh schedule can be started, expressed in YYYY-MM-DDTHH:MM:SS format.
        public let startAfterDateTime: Date?

        public init(arn: String? = nil, refreshType: IngestionType, scheduleFrequency: RefreshFrequency, scheduleId: String, startAfterDateTime: Date? = nil) {
            self.arn = arn
            self.refreshType = refreshType
            self.scheduleFrequency = scheduleFrequency
            self.scheduleId = scheduleId
            self.startAfterDateTime = startAfterDateTime
        }

        public func validate(name: String) throws {
            try self.scheduleFrequency.validate(name: "\(name).scheduleFrequency")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case refreshType = "RefreshType"
            case scheduleFrequency = "ScheduleFrequency"
            case scheduleId = "ScheduleId"
            case startAfterDateTime = "StartAfterDateTime"
        }
    }

    public struct RegisterUserRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
        public let customFederationProviderUrl: String?
        /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:   Create and update data sources   Create and update datasets   Create and update email reports   Subscribe to email reports   To add custom permissions to an existing user, use  UpdateUser instead. A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user.  Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
        public let customPermissionsName: String?
        /// The email address of the user that you want to register.
        public let email: String
        /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, don’t use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
        public let externalLoginFederationProviderType: String?
        /// The identity ID for a user in the external login provider.
        public let externalLoginId: String?
        /// The ARN of the IAM user or role that you are registering with Amazon QuickSight.
        public let iamArn: String?
        /// Amazon QuickSight supports several ways of managing the identity of users. This
        /// 			parameter accepts two values:    IAM: A user whose identity maps to an existing IAM user or role.
        /// 				    QUICKSIGHT: A user whose identity is owned and managed internally by
        /// 					Amazon QuickSight.
        public let identityType: IdentityType
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// You need to use this parameter only when you register one or more users using an assumed
        /// 			IAM role. You don't need to provide the session name for other scenarios, for example when
        /// 			you are registering an IAM user or an Amazon QuickSight user. You can register multiple
        /// 			users using the same IAM role if each user has a different session name. For more
        /// 			information on assuming IAM roles, see  assume-role in the CLI Reference.
        public let sessionName: String?
        /// The tags to associate with the user.
        public let tags: [Tag]?
        /// The Amazon QuickSight user name that you want to create for the user you are
        /// 			registering.
        public let userName: String?
        /// The Amazon QuickSight role for the user. The user role can be one of the
        /// 			following:    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and
        /// 					dashboards.    ADMIN: A user who is an author, who can also manage Amazon QuickSight
        /// 					settings.    RESTRICTED_READER: This role isn't currently available for
        /// 					use.    RESTRICTED_AUTHOR: This role isn't currently available for
        /// 					use.
        public let userRole: UserRole

        public init(awsAccountId: String, customFederationProviderUrl: String? = nil, customPermissionsName: String? = nil, email: String, externalLoginFederationProviderType: String? = nil, externalLoginId: String? = nil, iamArn: String? = nil, identityType: IdentityType, namespace: String, sessionName: String? = nil, tags: [Tag]? = nil, userName: String? = nil, userRole: UserRole) {
            self.awsAccountId = awsAccountId
            self.customFederationProviderUrl = customFederationProviderUrl
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginId = externalLoginId
            self.iamArn = iamArn
            self.identityType = identityType
            self.namespace = namespace
            self.sessionName = sessionName
            self.tags = tags
            self.userName = userName
            self.userRole = userRole
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.customFederationProviderUrl, forKey: .customFederationProviderUrl)
            try container.encodeIfPresent(self.customPermissionsName, forKey: .customPermissionsName)
            try container.encode(self.email, forKey: .email)
            try container.encodeIfPresent(self.externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
            try container.encodeIfPresent(self.externalLoginId, forKey: .externalLoginId)
            try container.encodeIfPresent(self.iamArn, forKey: .iamArn)
            try container.encode(self.identityType, forKey: .identityType)
            request.encodePath(self.namespace, key: "Namespace")
            try container.encodeIfPresent(self.sessionName, forKey: .sessionName)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.userName, forKey: .userName)
            try container.encode(self.userRole, forKey: .userRole)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, max: 64)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, min: 1)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, pattern: "^[a-zA-Z0-9+=,.@_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.sessionName, name: "sessionName", parent: name, max: 64)
            try self.validate(self.sessionName, name: "sessionName", parent: name, min: 2)
            try self.validate(self.sessionName, name: "sessionName", parent: name, pattern: "^[\\w+=.@-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customFederationProviderUrl = "CustomFederationProviderUrl"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginId = "ExternalLoginId"
            case iamArn = "IamArn"
            case identityType = "IdentityType"
            case sessionName = "SessionName"
            case tags = "Tags"
            case userName = "UserName"
            case userRole = "UserRole"
        }
    }

    public struct RegisterUserResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The user's user name.
        public let user: User?
        /// The URL the user visits to complete registration and provide a password. This is
        /// 			returned only for users with an identity type of QUICKSIGHT.
        public let userInvitationUrl: String?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil, userInvitationUrl: String? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
            self.userInvitationUrl = userInvitationUrl
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.user = try container.decodeIfPresent(User.self, forKey: .user)
            self.userInvitationUrl = try container.decodeIfPresent(String.self, forKey: .userInvitationUrl)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case user = "User"
            case userInvitationUrl = "UserInvitationUrl"
        }
    }

    public struct RegisteredUserConsoleFeatureConfigurations: AWSEncodableShape {
        /// The state persistence configurations of an embedded Amazon QuickSight console.
        public let statePersistence: StatePersistenceConfigurations?

        public init(statePersistence: StatePersistenceConfigurations? = nil) {
            self.statePersistence = statePersistence
        }

        private enum CodingKeys: String, CodingKey {
            case statePersistence = "StatePersistence"
        }
    }

    public struct RegisteredUserDashboardEmbeddingConfiguration: AWSEncodableShape {
        /// The feature configurations of an embbedded Amazon QuickSight dashboard.
        public let featureConfigurations: RegisteredUserDashboardFeatureConfigurations?
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it. If the user does not have permission to view this dashboard, they see a permissions error message.
        public let initialDashboardId: String

        public init(featureConfigurations: RegisteredUserDashboardFeatureConfigurations? = nil, initialDashboardId: String) {
            self.featureConfigurations = featureConfigurations
            self.initialDashboardId = initialDashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, max: 512)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, min: 1)
            try self.validate(self.initialDashboardId, name: "initialDashboardId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case featureConfigurations = "FeatureConfigurations"
            case initialDashboardId = "InitialDashboardId"
        }
    }

    public struct RegisteredUserDashboardFeatureConfigurations: AWSEncodableShape {
        /// The bookmarks configuration for an embedded dashboard in Amazon QuickSight.
        public let bookmarks: BookmarksConfigurations?
        /// The state persistence settings of an embedded dashboard.
        public let statePersistence: StatePersistenceConfigurations?

        public init(bookmarks: BookmarksConfigurations? = nil, statePersistence: StatePersistenceConfigurations? = nil) {
            self.bookmarks = bookmarks
            self.statePersistence = statePersistence
        }

        private enum CodingKeys: String, CodingKey {
            case bookmarks = "Bookmarks"
            case statePersistence = "StatePersistence"
        }
    }

    public struct RegisteredUserDashboardVisualEmbeddingConfiguration: AWSEncodableShape {
        /// The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        public let initialDashboardVisualId: DashboardVisualId

        public init(initialDashboardVisualId: DashboardVisualId) {
            self.initialDashboardVisualId = initialDashboardVisualId
        }

        public func validate(name: String) throws {
            try self.initialDashboardVisualId.validate(name: "\(name).initialDashboardVisualId")
        }

        private enum CodingKeys: String, CodingKey {
            case initialDashboardVisualId = "InitialDashboardVisualId"
        }
    }

    public struct RegisteredUserEmbeddingExperienceConfiguration: AWSEncodableShape {
        /// The configuration details for providing a dashboard embedding experience.
        public let dashboard: RegisteredUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public let dashboardVisual: RegisteredUserDashboardVisualEmbeddingConfiguration?
        /// The configuration details for embedding the Q search bar. For more information about embedding the Q search bar, see Embedding Overview in the Amazon QuickSight User Guide.
        public let qSearchBar: RegisteredUserQSearchBarEmbeddingConfiguration?
        /// The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see Customizing Access to the Amazon QuickSight Console in the Amazon QuickSight User Guide. Use  GenerateEmbedUrlForRegisteredUser  where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the  UpdateUser API operation. Use the  RegisterUser API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the Amazon QuickSight User Guide:    Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users     Customizing Access to the Amazon QuickSight Console    For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the Amazon QuickSight Developer Portal.
        public let quickSightConsole: RegisteredUserQuickSightConsoleEmbeddingConfiguration?

        public init(dashboard: RegisteredUserDashboardEmbeddingConfiguration? = nil, dashboardVisual: RegisteredUserDashboardVisualEmbeddingConfiguration? = nil, qSearchBar: RegisteredUserQSearchBarEmbeddingConfiguration? = nil, quickSightConsole: RegisteredUserQuickSightConsoleEmbeddingConfiguration? = nil) {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.qSearchBar = qSearchBar
            self.quickSightConsole = quickSightConsole
        }

        public func validate(name: String) throws {
            try self.dashboard?.validate(name: "\(name).dashboard")
            try self.dashboardVisual?.validate(name: "\(name).dashboardVisual")
            try self.qSearchBar?.validate(name: "\(name).qSearchBar")
            try self.quickSightConsole?.validate(name: "\(name).quickSightConsole")
        }

        private enum CodingKeys: String, CodingKey {
            case dashboard = "Dashboard"
            case dashboardVisual = "DashboardVisual"
            case qSearchBar = "QSearchBar"
            case quickSightConsole = "QuickSightConsole"
        }
    }

    public struct RegisteredUserQSearchBarEmbeddingConfiguration: AWSEncodableShape {
        /// The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open. If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.
        public let initialTopicId: String?

        public init(initialTopicId: String? = nil) {
            self.initialTopicId = initialTopicId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, max: 2048)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, min: 1)
            try self.validate(self.initialTopicId, name: "initialTopicId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initialTopicId = "InitialTopicId"
        }
    }

    public struct RegisteredUserQuickSightConsoleEmbeddingConfiguration: AWSEncodableShape {
        /// The embedding configuration of an embedded Amazon QuickSight console.
        public let featureConfigurations: RegisteredUserConsoleFeatureConfigurations?
        /// The initial URL path for the Amazon QuickSight console. InitialPath is required. The entry point URL is constrained to the following paths:    /start     /start/analyses     /start/dashboards     /start/favorites     /dashboards/DashboardId. DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard.    /analyses/AnalysisId. AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis.
        public let initialPath: String?

        public init(featureConfigurations: RegisteredUserConsoleFeatureConfigurations? = nil, initialPath: String? = nil) {
            self.featureConfigurations = featureConfigurations
            self.initialPath = initialPath
        }

        public func validate(name: String) throws {
            try self.validate(self.initialPath, name: "initialPath", parent: name, max: 1000)
            try self.validate(self.initialPath, name: "initialPath", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case featureConfigurations = "FeatureConfigurations"
            case initialPath = "InitialPath"
        }
    }

    public struct RelationalTable: AWSEncodableShape & AWSDecodableShape {
        /// The catalog associated with a table.
        public let catalog: String?
        /// The Amazon Resource Name (ARN) for the data source.
        public let dataSourceArn: String
        /// The column schema of the table.
        public let inputColumns: [InputColumn]
        /// The name of the relational table.
        public let name: String
        /// The schema name. This name applies to certain relational database engines.
        public let schema: String?

        public init(catalog: String? = nil, dataSourceArn: String, inputColumns: [InputColumn], name: String, schema: String? = nil) {
            self.catalog = catalog
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.name = name
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 256)
            try self.inputColumns.forEach {
                try $0.validate(name: "\(name).inputColumns[]")
            }
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, max: 2048)
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.schema, name: "schema", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case dataSourceArn = "DataSourceArn"
            case inputColumns = "InputColumns"
            case name = "Name"
            case schema = "Schema"
        }
    }

    public struct RelativeDateTimeControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// Customize how dates are formatted in controls.
        public let dateTimeFormat: String?
        /// The configuration of info icon label options.
        public let infoIconLabelOptions: SheetControlInfoIconLabelOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(dateTimeFormat: String? = nil, infoIconLabelOptions: SheetControlInfoIconLabelOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.dateTimeFormat = dateTimeFormat
            self.infoIconLabelOptions = infoIconLabelOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, max: 128)
            try self.validate(self.dateTimeFormat, name: "dateTimeFormat", parent: name, min: 1)
            try self.infoIconLabelOptions?.validate(name: "\(name).infoIconLabelOptions")
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFormat = "DateTimeFormat"
            case infoIconLabelOptions = "InfoIconLabelOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct RelativeDatesFilter: AWSEncodableShape & AWSDecodableShape {
        /// The date configuration of the filter.
        public let anchorDateConfiguration: AnchorDateConfiguration
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The configuration for the exclude period of the filter.
        public let excludePeriodConfiguration: ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The minimum granularity (period granularity) of the relative dates filter.
        public let minimumGranularity: TimeGranularity?
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The parameter whose value should be used for the filter value.
        public let parameterName: String?
        /// The range date type of the filter. Choose one of the options below:    PREVIOUS     THIS     LAST     NOW     NEXT
        public let relativeDateType: RelativeDateType
        /// The date value of the filter.
        public let relativeDateValue: Int?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity

        public init(anchorDateConfiguration: AnchorDateConfiguration, column: ColumnIdentifier, excludePeriodConfiguration: ExcludePeriodConfiguration? = nil, filterId: String, minimumGranularity: TimeGranularity? = nil, nullOption: FilterNullOption, parameterName: String? = nil, relativeDateType: RelativeDateType, relativeDateValue: Int? = nil, timeGranularity: TimeGranularity) {
            self.anchorDateConfiguration = anchorDateConfiguration
            self.column = column
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.minimumGranularity = minimumGranularity
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.relativeDateType = relativeDateType
            self.relativeDateValue = relativeDateValue
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.anchorDateConfiguration.validate(name: "\(name).anchorDateConfiguration")
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case anchorDateConfiguration = "AnchorDateConfiguration"
            case column = "Column"
            case excludePeriodConfiguration = "ExcludePeriodConfiguration"
            case filterId = "FilterId"
            case minimumGranularity = "MinimumGranularity"
            case nullOption = "NullOption"
            case parameterName = "ParameterName"
            case relativeDateType = "RelativeDateType"
            case relativeDateValue = "RelativeDateValue"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct RenameColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column to be renamed.
        public let columnName: String
        /// The new name for the column.
        public let newColumnName: String

        public init(columnName: String, newColumnName: String) {
            self.columnName = columnName
            self.newColumnName = newColumnName
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.newColumnName, name: "newColumnName", parent: name, max: 128)
            try self.validate(self.newColumnName, name: "newColumnName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case newColumnName = "NewColumnName"
        }
    }

    public struct ResourcePermission: AWSEncodableShape & AWSDecodableShape {
        /// The IAM action to grant or revoke permissions on.
        public let actions: [String]
        /// The Amazon Resource Name (ARN) of the principal. This can be one of the following:   The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)   The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)   The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.)
        public let principal: String

        public init(actions: [String], principal: String) {
            self.actions = actions
            self.principal = principal
        }

        public func validate(name: String) throws {
            try self.validate(self.actions, name: "actions", parent: name, max: 20)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.principal, name: "principal", parent: name, max: 256)
            try self.validate(self.principal, name: "principal", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case principal = "Principal"
        }
    }

    public struct RestoreAnalysisRequest: AWSEncodableShape {
        /// The ID of the analysis that you're restoring.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis.
        public let awsAccountId: String

        public init(analysisId: String, awsAccountId: String) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RestoreAnalysisResponse: AWSDecodableShape {
        /// The ID of the analysis that you're restoring.
        public let analysisId: String?
        /// The Amazon Resource Name (ARN) of the analysis that you're restoring.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisId: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisId = try container.decodeIfPresent(String.self, forKey: .analysisId)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case requestId = "RequestId"
        }
    }

    public struct RollingDateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data set that is used in the rolling date configuration.
        public let dataSetIdentifier: String?
        /// The expression of the rolling date configuration.
        public let expression: String

        public init(dataSetIdentifier: String? = nil, expression: String) {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, max: 2048)
            try self.validate(self.dataSetIdentifier, name: "dataSetIdentifier", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIdentifier = "DataSetIdentifier"
            case expression = "Expression"
        }
    }

    public struct RowAlternateColorOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the list of row alternate colors.
        public let rowAlternateColors: [String]?
        /// Determines the widget status.
        public let status: WidgetStatus?
        /// The primary background color options for alternate rows.
        public let usePrimaryBackgroundColor: WidgetStatus?

        public init(rowAlternateColors: [String]? = nil, status: WidgetStatus? = nil, usePrimaryBackgroundColor: WidgetStatus? = nil) {
            self.rowAlternateColors = rowAlternateColors
            self.status = status
            self.usePrimaryBackgroundColor = usePrimaryBackgroundColor
        }

        public func validate(name: String) throws {
            try self.rowAlternateColors?.forEach {
                try validate($0, name: "rowAlternateColors[]", parent: name, pattern: "^#[A-F0-9]{6}$")
            }
            try self.validate(self.rowAlternateColors, name: "rowAlternateColors", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rowAlternateColors = "RowAlternateColors"
            case status = "Status"
            case usePrimaryBackgroundColor = "UsePrimaryBackgroundColor"
        }
    }

    public struct RowInfo: AWSDecodableShape {
        /// The number of rows that were not ingested.
        public let rowsDropped: Int64?
        /// The number of rows that were ingested.
        public let rowsIngested: Int64?
        /// The total number of rows in the dataset.
        public let totalRowsInDataset: Int64?

        public init(rowsDropped: Int64? = nil, rowsIngested: Int64? = nil, totalRowsInDataset: Int64? = nil) {
            self.rowsDropped = rowsDropped
            self.rowsIngested = rowsIngested
            self.totalRowsInDataset = totalRowsInDataset
        }

        private enum CodingKeys: String, CodingKey {
            case rowsDropped = "RowsDropped"
            case rowsIngested = "RowsIngested"
            case totalRowsInDataset = "TotalRowsInDataset"
        }
    }

    public struct RowLevelPermissionDataSet: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.
        public let arn: String
        /// The user or group rules associated with the dataset that contains permissions for RLS. By default, FormatVersion is VERSION_1. When FormatVersion is VERSION_1, UserName and GroupName are required. When FormatVersion is VERSION_2, UserARN and GroupARN are required, and Namespace must not exist.
        public let formatVersion: RowLevelPermissionFormatVersion?
        /// The namespace associated with the dataset that contains permissions for RLS.
        public let namespace: String?
        /// The type of permissions to use when interpreting the permissions for RLS. DENY_ACCESS is included for backward compatibility only.
        public let permissionPolicy: RowLevelPermissionPolicy
        /// The status of the row-level security permission dataset. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public let status: Status?

        public init(arn: String, formatVersion: RowLevelPermissionFormatVersion? = nil, namespace: String? = nil, permissionPolicy: RowLevelPermissionPolicy, status: Status? = nil) {
            self.arn = arn
            self.formatVersion = formatVersion
            self.namespace = namespace
            self.permissionPolicy = permissionPolicy
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case formatVersion = "FormatVersion"
            case namespace = "Namespace"
            case permissionPolicy = "PermissionPolicy"
            case status = "Status"
        }
    }

    public struct RowLevelPermissionTagConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The status of row-level security tags. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public let status: Status?
        /// A list of tag configuration rules to apply to a dataset. All tag configurations have the OR condition. Tags within each tile will be joined (AND). At least one rule in this structure must have all tag values assigned to it to apply Row-level security (RLS) to the dataset.
        public let tagRuleConfigurations: [[String]]?
        /// A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.
        public let tagRules: [RowLevelPermissionTagRule]

        public init(status: Status? = nil, tagRuleConfigurations: [[String]]? = nil, tagRules: [RowLevelPermissionTagRule]) {
            self.status = status
            self.tagRuleConfigurations = tagRuleConfigurations
            self.tagRules = tagRules
        }

        public func validate(name: String) throws {
            try self.tagRuleConfigurations?.forEach {
                try validate($0, name: "tagRuleConfigurations[]", parent: name, max: 50)
                try validate($0, name: "tagRuleConfigurations[]", parent: name, min: 1)
            }
            try self.validate(self.tagRuleConfigurations, name: "tagRuleConfigurations", parent: name, max: 50)
            try self.validate(self.tagRuleConfigurations, name: "tagRuleConfigurations", parent: name, min: 1)
            try self.tagRules.forEach {
                try $0.validate(name: "\(name).tagRules[]")
            }
            try self.validate(self.tagRules, name: "tagRules", parent: name, max: 50)
            try self.validate(self.tagRules, name: "tagRules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case tagRuleConfigurations = "TagRuleConfigurations"
            case tagRules = "TagRules"
        }
    }

    public struct RowLevelPermissionTagRule: AWSEncodableShape & AWSDecodableShape {
        /// The column name that a tag key is assigned to.
        public let columnName: String
        /// A string that you want to use to filter by all the values in a column in the dataset and don’t want to list the values one by one. For example, you can use an asterisk as your match all value.
        public let matchAllValue: String?
        /// The unique key for a tag.
        public let tagKey: String
        /// A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.
        public let tagMultiValueDelimiter: String?

        public init(columnName: String, matchAllValue: String? = nil, tagKey: String, tagMultiValueDelimiter: String? = nil) {
            self.columnName = columnName
            self.matchAllValue = matchAllValue
            self.tagKey = tagKey
            self.tagMultiValueDelimiter = tagMultiValueDelimiter
        }

        public func validate(name: String) throws {
            try self.validate(self.matchAllValue, name: "matchAllValue", parent: name, max: 256)
            try self.validate(self.matchAllValue, name: "matchAllValue", parent: name, min: 1)
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 128)
            try self.validate(self.tagKey, name: "tagKey", parent: name, min: 1)
            try self.validate(self.tagMultiValueDelimiter, name: "tagMultiValueDelimiter", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case matchAllValue = "MatchAllValue"
            case tagKey = "TagKey"
            case tagMultiValueDelimiter = "TagMultiValueDelimiter"
        }
    }

    public struct S3BucketConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of an existing Amazon S3 bucket where the generated snapshot artifacts are sent.
        public let bucketName: String
        /// The prefix of the Amazon S3 bucket that the generated snapshots are stored in.
        public let bucketPrefix: String
        /// The region that the Amazon S3 bucket is located in. The bucket must be located in the same region that the StartDashboardSnapshotJob API call is made.
        public let bucketRegion: String

        public init(bucketName: String, bucketPrefix: String, bucketRegion: String) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.bucketRegion = bucketRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S")
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: "\\S")
            try self.validate(self.bucketRegion, name: "bucketRegion", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case bucketPrefix = "BucketPrefix"
            case bucketRegion = "BucketRegion"
        }
    }

    public struct S3Parameters: AWSEncodableShape & AWSDecodableShape {
        /// Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.
        public let manifestFileLocation: ManifestFileLocation
        /// Use the RoleArn structure to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use RoleArn to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.
        public let roleArn: String?

        public init(manifestFileLocation: ManifestFileLocation, roleArn: String? = nil) {
            self.manifestFileLocation = manifestFileLocation
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.manifestFileLocation.validate(name: "\(name).manifestFileLocation")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case manifestFileLocation = "ManifestFileLocation"
            case roleArn = "RoleArn"
        }
    }

    public struct S3Source: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the data source.
        public let dataSourceArn: String
        /// A physical table type for an S3 data source.  For files that aren't JSON, only STRING data types are supported in input columns.
        public let inputColumns: [InputColumn]
        /// Information about the format for the S3 source file or files.
        public let uploadSettings: UploadSettings?

        public init(dataSourceArn: String, inputColumns: [InputColumn], uploadSettings: UploadSettings? = nil) {
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.uploadSettings = uploadSettings
        }

        public func validate(name: String) throws {
            try self.inputColumns.forEach {
                try $0.validate(name: "\(name).inputColumns[]")
            }
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, max: 2048)
            try self.validate(self.inputColumns, name: "inputColumns", parent: name, min: 1)
            try self.uploadSettings?.validate(name: "\(name).uploadSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case inputColumns = "InputColumns"
            case uploadSettings = "UploadSettings"
        }
    }

    public struct SameSheetTargetVisualConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that choose the target visual in the same sheet. Valid values are defined as follows:    ALL_VISUALS: Applies the filter operation to all visuals in the same sheet.
        public let targetVisualOptions: TargetVisualOptions?
        /// A list of the target visual IDs that are located in the same sheet of the analysis.
        public let targetVisuals: [String]?

        public init(targetVisualOptions: TargetVisualOptions? = nil, targetVisuals: [String]? = nil) {
            self.targetVisualOptions = targetVisualOptions
            self.targetVisuals = targetVisuals
        }

        public func validate(name: String) throws {
            try self.targetVisuals?.forEach {
                try validate($0, name: "targetVisuals[]", parent: name, max: 512)
                try validate($0, name: "targetVisuals[]", parent: name, min: 1)
                try validate($0, name: "targetVisuals[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.targetVisuals, name: "targetVisuals", parent: name, max: 50)
            try self.validate(self.targetVisuals, name: "targetVisuals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetVisualOptions = "TargetVisualOptions"
            case targetVisuals = "TargetVisuals"
        }
    }

    public struct SankeyDiagramAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The destination field wells of a sankey diagram.
        public let destination: [DimensionField]?
        /// The source field wells of a sankey diagram.
        public let source: [DimensionField]?
        /// The weight field wells of a sankey diagram.
        public let weight: [MeasureField]?

        public init(destination: [DimensionField]? = nil, source: [DimensionField]? = nil, weight: [MeasureField]? = nil) {
            self.destination = destination
            self.source = source
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.destination?.forEach {
                try $0.validate(name: "\(name).destination[]")
            }
            try self.validate(self.destination, name: "destination", parent: name, max: 200)
            try self.source?.forEach {
                try $0.validate(name: "\(name).source[]")
            }
            try self.validate(self.source, name: "source", parent: name, max: 200)
            try self.weight?.forEach {
                try $0.validate(name: "\(name).weight[]")
            }
            try self.validate(self.weight, name: "weight", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case source = "Source"
            case weight = "Weight"
        }
    }

    public struct SankeyDiagramChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data label configuration of a sankey diagram.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a sankey diagram.
        public let fieldWells: SankeyDiagramFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The sort configuration of a sankey diagram.
        public let sortConfiguration: SankeyDiagramSortConfiguration?

        public init(dataLabels: DataLabelOptions? = nil, fieldWells: SankeyDiagramFieldWells? = nil, interactions: VisualInteractionOptions? = nil, sortConfiguration: SankeyDiagramSortConfiguration? = nil) {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.sortConfiguration = sortConfiguration
        }

        public func validate(name: String) throws {
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case sortConfiguration = "SortConfiguration"
        }
    }

    public struct SankeyDiagramFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a sankey diagram.
        public let sankeyDiagramAggregatedFieldWells: SankeyDiagramAggregatedFieldWells?

        public init(sankeyDiagramAggregatedFieldWells: SankeyDiagramAggregatedFieldWells? = nil) {
            self.sankeyDiagramAggregatedFieldWells = sankeyDiagramAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.sankeyDiagramAggregatedFieldWells?.validate(name: "\(name).sankeyDiagramAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case sankeyDiagramAggregatedFieldWells = "SankeyDiagramAggregatedFieldWells"
        }
    }

    public struct SankeyDiagramSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of destination nodes that are displayed in a sankey diagram.
        public let destinationItemsLimit: ItemsLimitConfiguration?
        /// The limit on the number of source nodes that are displayed in a sankey diagram.
        public let sourceItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the weight fields.
        public let weightSort: [FieldSortOptions]?

        public init(destinationItemsLimit: ItemsLimitConfiguration? = nil, sourceItemsLimit: ItemsLimitConfiguration? = nil, weightSort: [FieldSortOptions]? = nil) {
            self.destinationItemsLimit = destinationItemsLimit
            self.sourceItemsLimit = sourceItemsLimit
            self.weightSort = weightSort
        }

        public func validate(name: String) throws {
            try self.weightSort?.forEach {
                try $0.validate(name: "\(name).weightSort[]")
            }
            try self.validate(self.weightSort, name: "weightSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationItemsLimit = "DestinationItemsLimit"
            case sourceItemsLimit = "SourceItemsLimit"
            case weightSort = "WeightSort"
        }
    }

    public struct SankeyDiagramVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration of a sankey diagram.
        public let chartConfiguration: SankeyDiagramChartConfiguration?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: SankeyDiagramChartConfiguration? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct ScatterPlotCategoricallyAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category field well of a scatter plot.
        public let category: [DimensionField]?
        /// The label field well of a scatter plot.
        public let label: [DimensionField]?
        /// The size field well of a scatter plot.
        public let size: [MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is aggregated by category.
        public let xAxis: [MeasureField]?
        /// The y-axis field well of a scatter plot. The y-axis is aggregated by category.
        public let yAxis: [MeasureField]?

        public init(category: [DimensionField]? = nil, label: [DimensionField]? = nil, size: [MeasureField]? = nil, xAxis: [MeasureField]? = nil, yAxis: [MeasureField]? = nil) {
            self.category = category
            self.label = label
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.label?.forEach {
                try $0.validate(name: "\(name).label[]")
            }
            try self.validate(self.label, name: "label", parent: name, max: 200)
            try self.size?.forEach {
                try $0.validate(name: "\(name).size[]")
            }
            try self.validate(self.size, name: "size", parent: name, max: 200)
            try self.xAxis?.forEach {
                try $0.validate(name: "\(name).xAxis[]")
            }
            try self.validate(self.xAxis, name: "xAxis", parent: name, max: 200)
            try self.yAxis?.forEach {
                try $0.validate(name: "\(name).yAxis[]")
            }
            try self.validate(self.yAxis, name: "yAxis", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case label = "Label"
            case size = "Size"
            case xAxis = "XAxis"
            case yAxis = "YAxis"
        }
    }

    public struct ScatterPlotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: ScatterPlotFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The sort configuration of a scatter plot.
        public let sortConfiguration: ScatterPlotSortConfiguration?
        /// The legend display setup of the visual.
        public let tooltip: TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public let visualPalette: VisualPalette?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.
        public let xAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.
        public let xAxisLabelOptions: ChartAxisLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.
        public let yAxisDisplayOptions: AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.
        public let yAxisLabelOptions: ChartAxisLabelOptions?

        public init(dataLabels: DataLabelOptions? = nil, fieldWells: ScatterPlotFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, sortConfiguration: ScatterPlotSortConfiguration? = nil, tooltip: TooltipOptions? = nil, visualPalette: VisualPalette? = nil, xAxisDisplayOptions: AxisDisplayOptions? = nil, xAxisLabelOptions: ChartAxisLabelOptions? = nil, yAxisDisplayOptions: AxisDisplayOptions? = nil, yAxisLabelOptions: ChartAxisLabelOptions? = nil) {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
            self.yAxisLabelOptions = yAxisLabelOptions
        }

        public func validate(name: String) throws {
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.tooltip?.validate(name: "\(name).tooltip")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
            try self.xAxisDisplayOptions?.validate(name: "\(name).xAxisDisplayOptions")
            try self.xAxisLabelOptions?.validate(name: "\(name).xAxisLabelOptions")
            try self.yAxisDisplayOptions?.validate(name: "\(name).yAxisDisplayOptions")
            try self.yAxisLabelOptions?.validate(name: "\(name).yAxisLabelOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
            case visualPalette = "VisualPalette"
            case xAxisDisplayOptions = "XAxisDisplayOptions"
            case xAxisLabelOptions = "XAxisLabelOptions"
            case yAxisDisplayOptions = "YAxisDisplayOptions"
            case yAxisLabelOptions = "YAxisLabelOptions"
        }
    }

    public struct ScatterPlotFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a scatter plot. The x and y-axes of scatter plots with aggregated field wells are aggregated by category, label, or both.
        public let scatterPlotCategoricallyAggregatedFieldWells: ScatterPlotCategoricallyAggregatedFieldWells?
        /// The unaggregated field wells of a scatter plot. The x and y-axes of these scatter plots are unaggregated.
        public let scatterPlotUnaggregatedFieldWells: ScatterPlotUnaggregatedFieldWells?

        public init(scatterPlotCategoricallyAggregatedFieldWells: ScatterPlotCategoricallyAggregatedFieldWells? = nil, scatterPlotUnaggregatedFieldWells: ScatterPlotUnaggregatedFieldWells? = nil) {
            self.scatterPlotCategoricallyAggregatedFieldWells = scatterPlotCategoricallyAggregatedFieldWells
            self.scatterPlotUnaggregatedFieldWells = scatterPlotUnaggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.scatterPlotCategoricallyAggregatedFieldWells?.validate(name: "\(name).scatterPlotCategoricallyAggregatedFieldWells")
            try self.scatterPlotUnaggregatedFieldWells?.validate(name: "\(name).scatterPlotUnaggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case scatterPlotCategoricallyAggregatedFieldWells = "ScatterPlotCategoricallyAggregatedFieldWells"
            case scatterPlotUnaggregatedFieldWells = "ScatterPlotUnaggregatedFieldWells"
        }
    }

    public struct ScatterPlotSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let scatterPlotLimitConfiguration: ItemsLimitConfiguration?

        public init(scatterPlotLimitConfiguration: ItemsLimitConfiguration? = nil) {
            self.scatterPlotLimitConfiguration = scatterPlotLimitConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case scatterPlotLimitConfiguration = "ScatterPlotLimitConfiguration"
        }
    }

    public struct ScatterPlotUnaggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The category field well of a scatter plot.
        public let category: [DimensionField]?
        /// The label field well of a scatter plot.
        public let label: [DimensionField]?
        /// The size field well of a scatter plot.
        public let size: [MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is a dimension field and cannot be aggregated.
        public let xAxis: [DimensionField]?
        /// The y-axis field well of a scatter plot. The y-axis is a dimension field and cannot be aggregated.
        public let yAxis: [DimensionField]?

        public init(category: [DimensionField]? = nil, label: [DimensionField]? = nil, size: [MeasureField]? = nil, xAxis: [DimensionField]? = nil, yAxis: [DimensionField]? = nil) {
            self.category = category
            self.label = label
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }

        public func validate(name: String) throws {
            try self.category?.forEach {
                try $0.validate(name: "\(name).category[]")
            }
            try self.validate(self.category, name: "category", parent: name, max: 200)
            try self.label?.forEach {
                try $0.validate(name: "\(name).label[]")
            }
            try self.validate(self.label, name: "label", parent: name, max: 200)
            try self.size?.forEach {
                try $0.validate(name: "\(name).size[]")
            }
            try self.validate(self.size, name: "size", parent: name, max: 200)
            try self.xAxis?.forEach {
                try $0.validate(name: "\(name).xAxis[]")
            }
            try self.validate(self.xAxis, name: "xAxis", parent: name, max: 200)
            try self.yAxis?.forEach {
                try $0.validate(name: "\(name).yAxis[]")
            }
            try self.validate(self.yAxis, name: "yAxis", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case label = "Label"
            case size = "Size"
            case xAxis = "XAxis"
            case yAxis = "YAxis"
        }
    }

    public struct ScatterPlotVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: ScatterPlotConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: ScatterPlotConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct ScheduleRefreshOnEntity: AWSEncodableShape & AWSDecodableShape {
        /// The day of the month that you want to schedule refresh on.
        public let dayOfMonth: String?
        /// The day of the week that you want to schedule a refresh on.
        public let dayOfWeek: DayOfWeek?

        public init(dayOfMonth: String? = nil, dayOfWeek: DayOfWeek? = nil) {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
        }

        public func validate(name: String) throws {
            try self.validate(self.dayOfMonth, name: "dayOfMonth", parent: name, max: 17)
            try self.validate(self.dayOfMonth, name: "dayOfMonth", parent: name, min: 1)
            try self.validate(self.dayOfMonth, name: "dayOfMonth", parent: name, pattern: "^(?:LAST_DAY_OF_MONTH|1[0-9]|2[0-8]|[12]|[3-9])$")
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfMonth = "DayOfMonth"
            case dayOfWeek = "DayOfWeek"
        }
    }

    public struct ScrollBarOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the data zoom scroll bar.
        public let visibility: Visibility?
        /// The visibility range for the data zoom scroll bar.
        public let visibleRange: VisibleRangeOptions?

        public init(visibility: Visibility? = nil, visibleRange: VisibleRangeOptions? = nil) {
            self.visibility = visibility
            self.visibleRange = visibleRange
        }

        public func validate(name: String) throws {
            try self.visibleRange?.validate(name: "\(name).visibleRange")
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
            case visibleRange = "VisibleRange"
        }
    }

    public struct SearchAnalysesRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the analyses that you're searching for.
        public let awsAccountId: String
        /// The structure for the search filters that you want to apply to your search.
        public let filters: [AnalysisSearchFilter]
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [AnalysisSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchAnalysesResponse: AWSDecodableShape {
        /// Metadata describing the analyses that you searched for.
        public let analysisSummaryList: [AnalysisSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisSummaryList: [AnalysisSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisSummaryList = analysisSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisSummaryList = try container.decodeIfPresent([AnalysisSummary].self, forKey: .analysisSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSummaryList = "AnalysisSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct SearchDashboardsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the user whose dashboards you're searching for.
        public let awsAccountId: String
        /// The filters to apply to the search. Currently, you can search only by user name, for example, "Filters": [ { "Name": "QUICKSIGHT_USER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]
        public let filters: [DashboardSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [DashboardSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchDashboardsResponse: AWSDecodableShape {
        /// The list of dashboards owned by the user specified in Filters in your request.
        public let dashboardSummaryList: [DashboardSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardSummaryList: [DashboardSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardSummaryList = dashboardSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardSummaryList = try container.decodeIfPresent([DashboardSummary].self, forKey: .dashboardSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaryList = "DashboardSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct SearchDataSetsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The filters to apply to the search.
        public let filters: [DataSetSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [DataSetSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchDataSetsResponse: AWSDecodableShape {
        /// A DataSetSummaries object that returns a summary of a dataset.
        public let dataSetSummaries: [DataSetSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetSummaries: [DataSetSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetSummaries = dataSetSummaries
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSetSummaries = try container.decodeIfPresent([DataSetSummary].self, forKey: .dataSetSummaries)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetSummaries = "DataSetSummaries"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct SearchDataSourcesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The filters to apply to the search.
        public let filters: [DataSourceSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [DataSourceSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchDataSourcesResponse: AWSDecodableShape {
        /// A DataSourceSummaries object that returns a summary of a data source.
        public let dataSourceSummaries: [DataSourceSummary]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceSummaries: [DataSourceSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceSummaries = dataSourceSummaries
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSourceSummaries = try container.decodeIfPresent([DataSourceSummary].self, forKey: .dataSourceSummaries)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSummaries = "DataSourceSummaries"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct SearchFoldersRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder.
        public let awsAccountId: String
        /// The filters to apply to the search. Currently, you can search only by the parent folder ARN. For example, "Filters": [ { "Name": "PARENT_FOLDER_ARN", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId" } ].
        public let filters: [FolderSearchFilter]
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [FolderSearchFilter], maxResults: Int? = nil, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct SearchFoldersResponse: AWSDecodableShape {
        /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
        public let folderSummaryList: [FolderSummary]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(folderSummaryList: [FolderSummary]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.folderSummaryList = folderSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.folderSummaryList = try container.decodeIfPresent([FolderSummary].self, forKey: .folderSummaryList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case folderSummaryList = "FolderSummaryList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct SearchGroupsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The structure for the search filters that you want to apply to your search.
        public let filters: [GroupSearchFilter]
        /// The maximum number of results to return from this request.
        public let maxResults: Int?
        /// The namespace that you want to search.
        public let namespace: String
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?

        public init(awsAccountId: String, filters: [GroupSearchFilter], maxResults: Int? = nil, namespace: String, nextToken: String? = nil) {
            self.awsAccountId = awsAccountId
            self.filters = filters
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.filters, forKey: .filters)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodePath(self.namespace, key: "Namespace")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.filters, name: "filters", parent: name, max: 1)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
        }
    }

    public struct SearchGroupsResponse: AWSDecodableShape {
        /// A list of groups in a specified namespace that match the filters you set in your SearchGroups request.
        public let groupList: [Group]?
        /// A pagination token that can be used in a subsequent request.
        public let nextToken: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(groupList: [Group]? = nil, nextToken: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.groupList = groupList
            self.nextToken = nextToken
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.groupList = try container.decodeIfPresent([Group].self, forKey: .groupList)
            self.nextToken = try container.decodeIfPresent(String.self, forKey: .nextToken)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case groupList = "GroupList"
            case nextToken = "NextToken"
            case requestId = "RequestId"
        }
    }

    public struct SecondaryValueOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the visibility of the secondary value.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct SectionAfterPageBreak: AWSEncodableShape & AWSDecodableShape {
        /// The option that enables or disables a page break at the end of a section.
        public let status: SectionPageBreakStatus?

        public init(status: SectionPageBreakStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct SectionBasedLayoutCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The options for a paper canvas of a section-based layout.
        public let paperCanvasSizeOptions: SectionBasedLayoutPaperCanvasSizeOptions?

        public init(paperCanvasSizeOptions: SectionBasedLayoutPaperCanvasSizeOptions? = nil) {
            self.paperCanvasSizeOptions = paperCanvasSizeOptions
        }

        private enum CodingKeys: String, CodingKey {
            case paperCanvasSizeOptions = "PaperCanvasSizeOptions"
        }
    }

    public struct SectionBasedLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of body section configurations.
        public let bodySections: [BodySectionConfiguration]
        /// The options for the canvas of a section-based layout.
        public let canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions
        /// A list of footer section configurations.
        public let footerSections: [HeaderFooterSectionConfiguration]
        /// A list of header section configurations.
        public let headerSections: [HeaderFooterSectionConfiguration]

        public init(bodySections: [BodySectionConfiguration], canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions, footerSections: [HeaderFooterSectionConfiguration], headerSections: [HeaderFooterSectionConfiguration]) {
            self.bodySections = bodySections
            self.canvasSizeOptions = canvasSizeOptions
            self.footerSections = footerSections
            self.headerSections = headerSections
        }

        public func validate(name: String) throws {
            try self.bodySections.forEach {
                try $0.validate(name: "\(name).bodySections[]")
            }
            try self.validate(self.bodySections, name: "bodySections", parent: name, max: 28)
            try self.footerSections.forEach {
                try $0.validate(name: "\(name).footerSections[]")
            }
            try self.validate(self.footerSections, name: "footerSections", parent: name, max: 1)
            try self.headerSections.forEach {
                try $0.validate(name: "\(name).headerSections[]")
            }
            try self.validate(self.headerSections, name: "headerSections", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bodySections = "BodySections"
            case canvasSizeOptions = "CanvasSizeOptions"
            case footerSections = "FooterSections"
            case headerSections = "HeaderSections"
        }
    }

    public struct SectionBasedLayoutPaperCanvasSizeOptions: AWSEncodableShape & AWSDecodableShape {
        /// Defines the spacing between the canvas content and the top, bottom, left, and right edges.
        public let paperMargin: Spacing?
        /// The paper orientation that is used to define canvas dimensions. Choose one of the following options:   PORTRAIT   LANDSCAPE
        public let paperOrientation: PaperOrientation?
        /// The paper size that is used to define canvas dimensions.
        public let paperSize: PaperSize?

        public init(paperMargin: Spacing? = nil, paperOrientation: PaperOrientation? = nil, paperSize: PaperSize? = nil) {
            self.paperMargin = paperMargin
            self.paperOrientation = paperOrientation
            self.paperSize = paperSize
        }

        private enum CodingKeys: String, CodingKey {
            case paperMargin = "PaperMargin"
            case paperOrientation = "PaperOrientation"
            case paperSize = "PaperSize"
        }
    }

    public struct SectionLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The free-form layout configuration of a section.
        public let freeFormLayout: FreeFormSectionLayoutConfiguration

        public init(freeFormLayout: FreeFormSectionLayoutConfiguration) {
            self.freeFormLayout = freeFormLayout
        }

        public func validate(name: String) throws {
            try self.freeFormLayout.validate(name: "\(name).freeFormLayout")
        }

        private enum CodingKeys: String, CodingKey {
            case freeFormLayout = "FreeFormLayout"
        }
    }

    public struct SectionPageBreakConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of a page break after a section.
        public let after: SectionAfterPageBreak?

        public init(after: SectionAfterPageBreak? = nil) {
            self.after = after
        }

        private enum CodingKeys: String, CodingKey {
            case after = "After"
        }
    }

    public struct SectionStyle: AWSEncodableShape & AWSDecodableShape {
        /// The height of a section. Heights can only be defined for header and footer sections. The default height margin is 0.5 inches.
        public let height: String?
        /// The spacing between section content and its top, bottom, left, and right edges. There is no padding by default.
        public let padding: Spacing?

        public init(height: String? = nil, padding: Spacing? = nil) {
            self.height = height
            self.padding = padding
        }

        private enum CodingKeys: String, CodingKey {
            case height = "Height"
            case padding = "Padding"
        }
    }

    public struct SelectedSheetsFilterScopeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.
        public let sheetVisualScopingConfigurations: [SheetVisualScopingConfiguration]?

        public init(sheetVisualScopingConfigurations: [SheetVisualScopingConfiguration]? = nil) {
            self.sheetVisualScopingConfigurations = sheetVisualScopingConfigurations
        }

        public func validate(name: String) throws {
            try self.sheetVisualScopingConfigurations?.forEach {
                try $0.validate(name: "\(name).sheetVisualScopingConfigurations[]")
            }
            try self.validate(self.sheetVisualScopingConfigurations, name: "sheetVisualScopingConfigurations", parent: name, max: 50)
            try self.validate(self.sheetVisualScopingConfigurations, name: "sheetVisualScopingConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sheetVisualScopingConfigurations = "SheetVisualScopingConfigurations"
        }
    }

    public struct SemanticEntityType: AWSEncodableShape & AWSDecodableShape {
        /// The semantic entity sub type name.
        public let subTypeName: String?
        /// The semantic entity type name.
        public let typeName: String?
        /// The semantic entity type parameters.
        public let typeParameters: [String: String]?

        public init(subTypeName: String? = nil, typeName: String? = nil, typeParameters: [String: String]? = nil) {
            self.subTypeName = subTypeName
            self.typeName = typeName
            self.typeParameters = typeParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.subTypeName, name: "subTypeName", parent: name, max: 256)
            try self.validate(self.typeName, name: "typeName", parent: name, max: 256)
            try self.typeParameters?.forEach {
                try validate($0.key, name: "typeParameters.key", parent: name, max: 256)
                try validate($0.value, name: "typeParameters[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case subTypeName = "SubTypeName"
            case typeName = "TypeName"
            case typeParameters = "TypeParameters"
        }
    }

    public struct SemanticType: AWSEncodableShape & AWSDecodableShape {
        /// The semantic type falsey cell value.
        public let falseyCellValue: String?
        /// The other names or aliases for the false cell value.
        public let falseyCellValueSynonyms: [String]?
        /// The semantic type sub type name.
        public let subTypeName: String?
        /// The semantic type truthy cell value.
        public let truthyCellValue: String?
        /// The other names or aliases for the true cell value.
        public let truthyCellValueSynonyms: [String]?
        /// The semantic type name.
        public let typeName: String?
        /// The semantic type parameters.
        public let typeParameters: [String: String]?

        public init(falseyCellValue: String? = nil, falseyCellValueSynonyms: [String]? = nil, subTypeName: String? = nil, truthyCellValue: String? = nil, truthyCellValueSynonyms: [String]? = nil, typeName: String? = nil, typeParameters: [String: String]? = nil) {
            self.falseyCellValue = falseyCellValue
            self.falseyCellValueSynonyms = falseyCellValueSynonyms
            self.subTypeName = subTypeName
            self.truthyCellValue = truthyCellValue
            self.truthyCellValueSynonyms = truthyCellValueSynonyms
            self.typeName = typeName
            self.typeParameters = typeParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.subTypeName, name: "subTypeName", parent: name, max: 256)
            try self.validate(self.typeName, name: "typeName", parent: name, max: 256)
            try self.typeParameters?.forEach {
                try validate($0.key, name: "typeParameters.key", parent: name, max: 256)
                try validate($0.value, name: "typeParameters[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case falseyCellValue = "FalseyCellValue"
            case falseyCellValueSynonyms = "FalseyCellValueSynonyms"
            case subTypeName = "SubTypeName"
            case truthyCellValue = "TruthyCellValue"
            case truthyCellValueSynonyms = "TruthyCellValueSynonyms"
            case typeName = "TypeName"
            case typeParameters = "TypeParameters"
        }
    }

    public struct SeriesItem: AWSEncodableShape & AWSDecodableShape {
        /// The data field series item configuration of a line chart.
        public let dataFieldSeriesItem: DataFieldSeriesItem?
        /// The field series item configuration of a line chart.
        public let fieldSeriesItem: FieldSeriesItem?

        public init(dataFieldSeriesItem: DataFieldSeriesItem? = nil, fieldSeriesItem: FieldSeriesItem? = nil) {
            self.dataFieldSeriesItem = dataFieldSeriesItem
            self.fieldSeriesItem = fieldSeriesItem
        }

        public func validate(name: String) throws {
            try self.dataFieldSeriesItem?.validate(name: "\(name).dataFieldSeriesItem")
            try self.fieldSeriesItem?.validate(name: "\(name).fieldSeriesItem")
        }

        private enum CodingKeys: String, CodingKey {
            case dataFieldSeriesItem = "DataFieldSeriesItem"
            case fieldSeriesItem = "FieldSeriesItem"
        }
    }

    public struct ServiceNowParameters: AWSEncodableShape & AWSDecodableShape {
        /// URL of the base site.
        public let siteBaseUrl: String

        public init(siteBaseUrl: String) {
            self.siteBaseUrl = siteBaseUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, max: 1024)
            try self.validate(self.siteBaseUrl, name: "siteBaseUrl", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case siteBaseUrl = "SiteBaseUrl"
        }
    }

    public struct SessionTag: AWSEncodableShape {
        /// The key for the tag.
        public let key: String
        /// The value that you want to assign the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct SetParameterValueConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The destination parameter name of the SetParameterValueConfiguration.
        public let destinationParameterName: String
        public let value: DestinationParameterValueConfiguration

        public init(destinationParameterName: String, value: DestinationParameterValueConfiguration) {
            self.destinationParameterName = destinationParameterName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationParameterName, name: "destinationParameterName", parent: name, max: 2048)
            try self.validate(self.destinationParameterName, name: "destinationParameterName", parent: name, min: 1)
            try self.validate(self.destinationParameterName, name: "destinationParameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationParameterName = "DestinationParameterName"
            case value = "Value"
        }
    }

    public struct ShapeConditionalFormat: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting for the shape background color of a filled map visual.
        public let backgroundColor: ConditionalFormattingColor

        public init(backgroundColor: ConditionalFormattingColor) {
            self.backgroundColor = backgroundColor
        }

        public func validate(name: String) throws {
            try self.backgroundColor.validate(name: "\(name).backgroundColor")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
        }
    }

    public struct Sheet: AWSDecodableShape {
        /// The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public let name: String?
        /// The unique identifier associated with a sheet.
        public let sheetId: String?

        public init(name: String? = nil, sheetId: String? = nil) {
            self.name = name
            self.sheetId = sheetId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case sheetId = "SheetId"
        }
    }

    public struct SheetControlInfoIconLabelOptions: AWSEncodableShape & AWSDecodableShape {
        ///  The text content of info icon.
        public let infoIconText: String?
        /// The visibility configuration of info icon label options.
        public let visibility: Visibility?

        public init(infoIconText: String? = nil, visibility: Visibility? = nil) {
            self.infoIconText = infoIconText
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.infoIconText, name: "infoIconText", parent: name, max: 100)
            try self.validate(self.infoIconText, name: "infoIconText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case infoIconText = "InfoIconText"
            case visibility = "Visibility"
        }
    }

    public struct SheetControlLayout: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that determines the elements and canvas size options of sheet control.
        public let configuration: SheetControlLayoutConfiguration

        public init(configuration: SheetControlLayoutConfiguration) {
            self.configuration = configuration
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct SheetControlLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that determines the elements and canvas size options of sheet control.
        public let gridLayout: GridLayoutConfiguration?

        public init(gridLayout: GridLayoutConfiguration? = nil) {
            self.gridLayout = gridLayout
        }

        public func validate(name: String) throws {
            try self.gridLayout?.validate(name: "\(name).gridLayout")
        }

        private enum CodingKeys: String, CodingKey {
            case gridLayout = "GridLayout"
        }
    }

    public struct SheetControlsOption: AWSEncodableShape & AWSDecodableShape {
        /// Visibility state.
        public let visibilityState: DashboardUIState?

        public init(visibilityState: DashboardUIState? = nil) {
            self.visibilityState = visibilityState
        }

        private enum CodingKeys: String, CodingKey {
            case visibilityState = "VisibilityState"
        }
    }

    public struct SheetDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The layout content type of the sheet. Choose one of the following options:    PAGINATED: Creates a sheet for a paginated report.    INTERACTIVE: Creates a sheet for an interactive dashboard.
        public let contentType: SheetContentType?
        /// A description of the sheet.
        public let description: String?
        /// The list of filter controls that are on a sheet. For more information, see Adding filter controls to analysis sheets in the Amazon QuickSight User Guide.
        public let filterControls: [FilterControl]?
        /// Layouts define how the components of a sheet are arranged. For more information, see Types of layout in the Amazon QuickSight User Guide.
        public let layouts: [Layout]?
        /// The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public let name: String?
        /// The list of parameter controls that are on a sheet. For more information, see Using a Control with a Parameter in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterControls: [ParameterControl]?
        /// The control layouts of the sheet.
        public let sheetControlLayouts: [SheetControlLayout]?
        /// The unique identifier of a sheet.
        public let sheetId: String
        /// The text boxes that are on a sheet.
        public let textBoxes: [SheetTextBox]?
        /// The title of the sheet.
        public let title: String?
        /// A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.
        public let visuals: [Visual]?

        public init(contentType: SheetContentType? = nil, description: String? = nil, filterControls: [FilterControl]? = nil, layouts: [Layout]? = nil, name: String? = nil, parameterControls: [ParameterControl]? = nil, sheetControlLayouts: [SheetControlLayout]? = nil, sheetId: String, textBoxes: [SheetTextBox]? = nil, title: String? = nil, visuals: [Visual]? = nil) {
            self.contentType = contentType
            self.description = description
            self.filterControls = filterControls
            self.layouts = layouts
            self.name = name
            self.parameterControls = parameterControls
            self.sheetControlLayouts = sheetControlLayouts
            self.sheetId = sheetId
            self.textBoxes = textBoxes
            self.title = title
            self.visuals = visuals
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.filterControls?.forEach {
                try $0.validate(name: "\(name).filterControls[]")
            }
            try self.validate(self.filterControls, name: "filterControls", parent: name, max: 200)
            try self.layouts?.forEach {
                try $0.validate(name: "\(name).layouts[]")
            }
            try self.validate(self.layouts, name: "layouts", parent: name, max: 1)
            try self.validate(self.layouts, name: "layouts", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameterControls?.forEach {
                try $0.validate(name: "\(name).parameterControls[]")
            }
            try self.validate(self.parameterControls, name: "parameterControls", parent: name, max: 200)
            try self.sheetControlLayouts?.forEach {
                try $0.validate(name: "\(name).sheetControlLayouts[]")
            }
            try self.validate(self.sheetControlLayouts, name: "sheetControlLayouts", parent: name, max: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, max: 512)
            try self.validate(self.sheetId, name: "sheetId", parent: name, min: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, pattern: "^[\\w\\-]+$")
            try self.textBoxes?.forEach {
                try $0.validate(name: "\(name).textBoxes[]")
            }
            try self.validate(self.textBoxes, name: "textBoxes", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, max: 1024)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.visuals?.forEach {
                try $0.validate(name: "\(name).visuals[]")
            }
            try self.validate(self.visuals, name: "visuals", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case description = "Description"
            case filterControls = "FilterControls"
            case layouts = "Layouts"
            case name = "Name"
            case parameterControls = "ParameterControls"
            case sheetControlLayouts = "SheetControlLayouts"
            case sheetId = "SheetId"
            case textBoxes = "TextBoxes"
            case title = "Title"
            case visuals = "Visuals"
        }
    }

    public struct SheetElementConfigurationOverrides: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether or not the overrides are visible. Choose one of the following options:    VISIBLE     HIDDEN
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct SheetElementRenderingRule: AWSEncodableShape & AWSDecodableShape {
        /// The override configuration of the rendering rules of a sheet.
        public let configurationOverrides: SheetElementConfigurationOverrides
        /// The expression of the rendering rules of a sheet.
        public let expression: String

        public init(configurationOverrides: SheetElementConfigurationOverrides, expression: String) {
            self.configurationOverrides = configurationOverrides
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationOverrides = "ConfigurationOverrides"
            case expression = "Expression"
        }
    }

    public struct SheetLayoutElementMaximizationOption: AWSEncodableShape & AWSDecodableShape {
        /// The status of the sheet layout maximization options of a dashbaord.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct SheetStyle: AWSEncodableShape & AWSDecodableShape {
        /// The display options for tiles.
        public let tile: TileStyle?
        /// The layout options for tiles.
        public let tileLayout: TileLayoutStyle?

        public init(tile: TileStyle? = nil, tileLayout: TileLayoutStyle? = nil) {
            self.tile = tile
            self.tileLayout = tileLayout
        }

        private enum CodingKeys: String, CodingKey {
            case tile = "Tile"
            case tileLayout = "TileLayout"
        }
    }

    public struct SheetTextBox: AWSEncodableShape & AWSDecodableShape {
        /// The content that is displayed in the text box.
        public let content: String?
        /// The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.
        public let sheetTextBoxId: String

        public init(content: String? = nil, sheetTextBoxId: String) {
            self.content = content
            self.sheetTextBoxId = sheetTextBoxId
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 150000)
            try self.validate(self.sheetTextBoxId, name: "sheetTextBoxId", parent: name, max: 512)
            try self.validate(self.sheetTextBoxId, name: "sheetTextBoxId", parent: name, min: 1)
            try self.validate(self.sheetTextBoxId, name: "sheetTextBoxId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case sheetTextBoxId = "SheetTextBoxId"
        }
    }

    public struct SheetVisualScopingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The scope of the applied entities. Choose one of the following options:    ALL_VISUALS     SELECTED_VISUALS
        public let scope: FilterVisualScope
        /// The selected sheet that the filter is applied to.
        public let sheetId: String
        /// The selected visuals that the filter is applied to.
        public let visualIds: [String]?

        public init(scope: FilterVisualScope, sheetId: String, visualIds: [String]? = nil) {
            self.scope = scope
            self.sheetId = sheetId
            self.visualIds = visualIds
        }

        public func validate(name: String) throws {
            try self.validate(self.sheetId, name: "sheetId", parent: name, max: 512)
            try self.validate(self.sheetId, name: "sheetId", parent: name, min: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, pattern: "^[\\w\\-]+$")
            try self.visualIds?.forEach {
                try validate($0, name: "visualIds[]", parent: name, max: 512)
                try validate($0, name: "visualIds[]", parent: name, min: 1)
                try validate($0, name: "visualIds[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.visualIds, name: "visualIds", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case scope = "Scope"
            case sheetId = "SheetId"
            case visualIds = "VisualIds"
        }
    }

    public struct ShortFormatText: AWSEncodableShape & AWSDecodableShape {
        /// Plain text format.
        public let plainText: String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public let richText: String?

        public init(plainText: String? = nil, richText: String? = nil) {
            self.plainText = plainText
            self.richText = richText
        }

        public func validate(name: String) throws {
            try self.validate(self.plainText, name: "plainText", parent: name, max: 512)
            try self.validate(self.plainText, name: "plainText", parent: name, min: 1)
            try self.validate(self.richText, name: "richText", parent: name, max: 1024)
            try self.validate(self.richText, name: "richText", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case plainText = "PlainText"
            case richText = "RichText"
        }
    }

    public struct SignupResponse: AWSDecodableShape {
        /// The name of your Amazon QuickSight account.
        public let accountName: String?
        /// The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are SIMPLE_AD, AD_CONNECTOR, and MICROSOFT_AD.
        public let directoryType: String?
        /// A Boolean that is TRUE if the Amazon QuickSight uses IAM as an authentication method.
        public let iamUser: Bool?
        /// The user login name for your Amazon QuickSight account.
        public let userLoginName: String?

        public init(accountName: String? = nil, directoryType: String? = nil, iamUser: Bool? = nil, userLoginName: String? = nil) {
            self.accountName = accountName
            self.directoryType = directoryType
            self.iamUser = iamUser
            self.userLoginName = userLoginName
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "accountName"
            case directoryType = "directoryType"
            case iamUser = "IAMUser"
            case userLoginName = "userLoginName"
        }
    }

    public struct SimpleClusterMarker: AWSEncodableShape & AWSDecodableShape {
        /// The color of the simple cluster marker.
        public let color: String?

        public init(color: String? = nil) {
            self.color = color
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
        }
    }

    public struct SingleAxisOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Y axis options of a single axis configuration.
        public let yAxisOptions: YAxisOptions?

        public init(yAxisOptions: YAxisOptions? = nil) {
            self.yAxisOptions = yAxisOptions
        }

        private enum CodingKeys: String, CodingKey {
            case yAxisOptions = "YAxisOptions"
        }
    }

    public struct SliderControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of info icon label options.
        public let infoIconLabelOptions: SheetControlInfoIconLabelOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(infoIconLabelOptions: SheetControlInfoIconLabelOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.infoIconLabelOptions?.validate(name: "\(name).infoIconLabelOptions")
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case infoIconLabelOptions = "InfoIconLabelOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct SmallMultiplesAxisProperties: AWSEncodableShape & AWSDecodableShape {
        /// Defines the placement of the axis. By default, axes are rendered OUTSIDE of the panels. Axes with INDEPENDENT scale are rendered INSIDE the panels.
        public let placement: SmallMultiplesAxisPlacement?
        /// Determines whether scale of the axes are shared or independent. The default value is SHARED.
        public let scale: SmallMultiplesAxisScale?

        public init(placement: SmallMultiplesAxisPlacement? = nil, scale: SmallMultiplesAxisScale? = nil) {
            self.placement = placement
            self.scale = scale
        }

        private enum CodingKeys: String, CodingKey {
            case placement = "Placement"
            case scale = "Scale"
        }
    }

    public struct SmallMultiplesOptions: AWSEncodableShape & AWSDecodableShape {
        /// Sets the maximum number of visible columns to display in the grid of small multiples panels. The default is Auto, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.
        public let maxVisibleColumns: Int64?
        /// Sets the maximum number of visible rows to display in the grid of small multiples panels. The default value is Auto, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.
        public let maxVisibleRows: Int64?
        /// Configures the display options for each small multiples panel.
        public let panelConfiguration: PanelConfiguration?
        /// The properties of a small multiples X axis.
        public let xAxis: SmallMultiplesAxisProperties?
        /// The properties of a small multiples Y axis.
        public let yAxis: SmallMultiplesAxisProperties?

        public init(maxVisibleColumns: Int64? = nil, maxVisibleRows: Int64? = nil, panelConfiguration: PanelConfiguration? = nil, xAxis: SmallMultiplesAxisProperties? = nil, yAxis: SmallMultiplesAxisProperties? = nil) {
            self.maxVisibleColumns = maxVisibleColumns
            self.maxVisibleRows = maxVisibleRows
            self.panelConfiguration = panelConfiguration
            self.xAxis = xAxis
            self.yAxis = yAxis
        }

        public func validate(name: String) throws {
            try self.validate(self.maxVisibleColumns, name: "maxVisibleColumns", parent: name, max: 10)
            try self.validate(self.maxVisibleColumns, name: "maxVisibleColumns", parent: name, min: 1)
            try self.validate(self.maxVisibleRows, name: "maxVisibleRows", parent: name, max: 10)
            try self.validate(self.maxVisibleRows, name: "maxVisibleRows", parent: name, min: 1)
            try self.panelConfiguration?.validate(name: "\(name).panelConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case maxVisibleColumns = "MaxVisibleColumns"
            case maxVisibleRows = "MaxVisibleRows"
            case panelConfiguration = "PanelConfiguration"
            case xAxis = "XAxis"
            case yAxis = "YAxis"
        }
    }

    public struct SnapshotAnonymousUser: AWSEncodableShape {
        /// The tags to be used for row-level security (RLS). Make sure that the relevant datasets have RLS tags configured before you start a snapshot export job. You can configure the RLS tags of a dataset with a DataSet$RowLevelPermissionTagConfiguration API call. These are not the tags that are used for Amazon Web Services resource tagging. For more information on row level security in Amazon QuickSight, see Using Row-Level Security (RLS) with Tagsin the Amazon QuickSight User Guide.
        public let rowLevelPermissionTags: [SessionTag]?

        public init(rowLevelPermissionTags: [SessionTag]? = nil) {
            self.rowLevelPermissionTags = rowLevelPermissionTags
        }

        public func validate(name: String) throws {
            try self.rowLevelPermissionTags?.forEach {
                try $0.validate(name: "\(name).rowLevelPermissionTags[]")
            }
            try self.validate(self.rowLevelPermissionTags, name: "rowLevelPermissionTags", parent: name, max: 50)
            try self.validate(self.rowLevelPermissionTags, name: "rowLevelPermissionTags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rowLevelPermissionTags = "RowLevelPermissionTags"
        }
    }

    public struct SnapshotAnonymousUserRedacted: AWSDecodableShape {
        /// The tag keys for the RowLevelPermissionTags.
        public let rowLevelPermissionTagKeys: [String]?

        public init(rowLevelPermissionTagKeys: [String]? = nil) {
            self.rowLevelPermissionTagKeys = rowLevelPermissionTagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case rowLevelPermissionTagKeys = "RowLevelPermissionTagKeys"
        }
    }

    public struct SnapshotConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains information on the Amazon S3 bucket that the generated snapshot is stored in.
        public let destinationConfiguration: SnapshotDestinationConfiguration?
        /// A list of SnapshotJobResultFileGroup objects that contain information about the snapshot that is generated. This list can hold a maximum of 6 FileGroup configurations.
        public let fileGroups: [SnapshotFileGroup]
        public let parameters: Parameters?

        public init(destinationConfiguration: SnapshotDestinationConfiguration? = nil, fileGroups: [SnapshotFileGroup], parameters: Parameters? = nil) {
            self.destinationConfiguration = destinationConfiguration
            self.fileGroups = fileGroups
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.destinationConfiguration?.validate(name: "\(name).destinationConfiguration")
            try self.fileGroups.forEach {
                try $0.validate(name: "\(name).fileGroups[]")
            }
            try self.validate(self.fileGroups, name: "fileGroups", parent: name, max: 7)
            try self.validate(self.fileGroups, name: "fileGroups", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfiguration = "DestinationConfiguration"
            case fileGroups = "FileGroups"
            case parameters = "Parameters"
        }
    }

    public struct SnapshotDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  A list of SnapshotS3DestinationConfiguration objects that contain Amazon S3 destination configurations. This structure can hold a maximum of 1 S3DestinationConfiguration.
        public let s3Destinations: [SnapshotS3DestinationConfiguration]?

        public init(s3Destinations: [SnapshotS3DestinationConfiguration]? = nil) {
            self.s3Destinations = s3Destinations
        }

        public func validate(name: String) throws {
            try self.s3Destinations?.forEach {
                try $0.validate(name: "\(name).s3Destinations[]")
            }
            try self.validate(self.s3Destinations, name: "s3Destinations", parent: name, max: 1)
            try self.validate(self.s3Destinations, name: "s3Destinations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Destinations = "S3Destinations"
        }
    }

    public struct SnapshotFile: AWSEncodableShape & AWSDecodableShape {
        /// The format of the snapshot file to be generated. You can choose between CSV, Excel, or PDF.
        public let formatType: SnapshotFileFormatType
        /// A list of SnapshotFileSheetSelection objects that contain information on the dashboard sheet that is exported. These objects provide information about the snapshot artifacts that are generated during the job. This structure can hold a maximum of 5 CSV configurations, 5 Excel configurations, or 1 configuration for PDF.
        public let sheetSelections: [SnapshotFileSheetSelection]

        public init(formatType: SnapshotFileFormatType, sheetSelections: [SnapshotFileSheetSelection]) {
            self.formatType = formatType
            self.sheetSelections = sheetSelections
        }

        public func validate(name: String) throws {
            try self.sheetSelections.forEach {
                try $0.validate(name: "\(name).sheetSelections[]")
            }
            try self.validate(self.sheetSelections, name: "sheetSelections", parent: name, max: 5)
            try self.validate(self.sheetSelections, name: "sheetSelections", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case formatType = "FormatType"
            case sheetSelections = "SheetSelections"
        }
    }

    public struct SnapshotFileGroup: AWSEncodableShape & AWSDecodableShape {
        /// A list of SnapshotFile objects that contain the information on the snapshot files that need to be generated. This structure can hold 1 configuration at a time.
        public let files: [SnapshotFile]?

        public init(files: [SnapshotFile]? = nil) {
            self.files = files
        }

        public func validate(name: String) throws {
            try self.files?.forEach {
                try $0.validate(name: "\(name).files[]")
            }
            try self.validate(self.files, name: "files", parent: name, max: 1)
            try self.validate(self.files, name: "files", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case files = "Files"
        }
    }

    public struct SnapshotFileSheetSelection: AWSEncodableShape & AWSDecodableShape {
        /// The selection scope of the visuals on a sheet of a dashboard that you are generating a snapthot of. You can choose one of the following options.    ALL_VISUALS - Selects all visuals that are on the sheet. This value is required if the snapshot is a PDF.    SELECTED_VISUALS - Select the visual that you want to add to the snapshot. This value is required if the snapshot is a CSV or Excel workbook.
        public let selectionScope: SnapshotFileSheetSelectionScope
        /// The sheet ID of the dashboard to generate the snapshot artifact from. This value is required for CSV, Excel, and PDF format types.
        public let sheetId: String
        ///  A structure that lists the IDs of the visuals in the selected sheet. Supported visual types are table, pivot table visuals. This value is required if you are generating a CSV or Excel workbook. This value supports a maximum of 1 visual ID for CSV and 5 visual IDs across up to 5 sheet selections for Excel. If you are generating an Excel workbook, the order of the visual IDs provided in this structure determines the order of the worksheets in the Excel file.
        public let visualIds: [String]?

        public init(selectionScope: SnapshotFileSheetSelectionScope, sheetId: String, visualIds: [String]? = nil) {
            self.selectionScope = selectionScope
            self.sheetId = sheetId
            self.visualIds = visualIds
        }

        public func validate(name: String) throws {
            try self.validate(self.sheetId, name: "sheetId", parent: name, max: 512)
            try self.validate(self.sheetId, name: "sheetId", parent: name, min: 1)
            try self.validate(self.sheetId, name: "sheetId", parent: name, pattern: "^[\\w\\-]+$")
            try self.visualIds?.forEach {
                try validate($0, name: "visualIds[]", parent: name, max: 512)
                try validate($0, name: "visualIds[]", parent: name, min: 1)
                try validate($0, name: "visualIds[]", parent: name, pattern: "^[\\w\\-]+$")
            }
            try self.validate(self.visualIds, name: "visualIds", parent: name, max: 5)
            try self.validate(self.visualIds, name: "visualIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case selectionScope = "SelectionScope"
            case sheetId = "SheetId"
            case visualIds = "VisualIds"
        }
    }

    public struct SnapshotJobErrorInfo: AWSDecodableShape {
        /// The error message.
        public let errorMessage: String?
        /// The error type.
        public let errorType: String?

        public init(errorMessage: String? = nil, errorType: String? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorType = "ErrorType"
        }
    }

    public struct SnapshotJobResult: AWSDecodableShape {
        ///  A list of AnonymousUserSnapshotJobResult objects that contain information on anonymous users and their user configurations. This data provided by you when you make a StartDashboardSnapshotJob API call.
        public let anonymousUsers: [AnonymousUserSnapshotJobResult]?

        public init(anonymousUsers: [AnonymousUserSnapshotJobResult]? = nil) {
            self.anonymousUsers = anonymousUsers
        }

        private enum CodingKeys: String, CodingKey {
            case anonymousUsers = "AnonymousUsers"
        }
    }

    public struct SnapshotJobResultErrorInfo: AWSDecodableShape {
        /// The error message.
        public let errorMessage: String?
        /// The error type.
        public let errorType: String?

        public init(errorMessage: String? = nil, errorType: String? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorType = "ErrorType"
        }
    }

    public struct SnapshotJobResultFileGroup: AWSDecodableShape {
        ///  A list of SnapshotFile objects.
        public let files: [SnapshotFile]?
        ///  A list of SnapshotJobS3Result objects.
        public let s3Results: [SnapshotJobS3Result]?

        public init(files: [SnapshotFile]? = nil, s3Results: [SnapshotJobS3Result]? = nil) {
            self.files = files
            self.s3Results = s3Results
        }

        private enum CodingKeys: String, CodingKey {
            case files = "Files"
            case s3Results = "S3Results"
        }
    }

    public struct SnapshotJobS3Result: AWSDecodableShape {
        /// An array of error records that describe any failures that occur while the dashboard snapshot job runs.
        public let errorInfo: [SnapshotJobResultErrorInfo]?
        /// A list of Amazon S3 bucket configurations that are provided when you make a StartDashboardSnapshotJob API call.
        public let s3DestinationConfiguration: SnapshotS3DestinationConfiguration?
        /// The Amazon S3 Uri.
        public let s3Uri: String?

        public init(errorInfo: [SnapshotJobResultErrorInfo]? = nil, s3DestinationConfiguration: SnapshotS3DestinationConfiguration? = nil, s3Uri: String? = nil) {
            self.errorInfo = errorInfo
            self.s3DestinationConfiguration = s3DestinationConfiguration
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case errorInfo = "ErrorInfo"
            case s3DestinationConfiguration = "S3DestinationConfiguration"
            case s3Uri = "S3Uri"
        }
    }

    public struct SnapshotS3DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains details about the Amazon S3 bucket that the generated dashboard snapshot is saved in.
        public let bucketConfiguration: S3BucketConfiguration

        public init(bucketConfiguration: S3BucketConfiguration) {
            self.bucketConfiguration = bucketConfiguration
        }

        public func validate(name: String) throws {
            try self.bucketConfiguration.validate(name: "\(name).bucketConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketConfiguration = "BucketConfiguration"
        }
    }

    public struct SnapshotUserConfiguration: AWSEncodableShape {
        /// An array of records that describe the anonymous users that the dashboard snapshot is generated for.
        public let anonymousUsers: [SnapshotAnonymousUser]?

        public init(anonymousUsers: [SnapshotAnonymousUser]? = nil) {
            self.anonymousUsers = anonymousUsers
        }

        public func validate(name: String) throws {
            try self.anonymousUsers?.forEach {
                try $0.validate(name: "\(name).anonymousUsers[]")
            }
            try self.validate(self.anonymousUsers, name: "anonymousUsers", parent: name, max: 1)
            try self.validate(self.anonymousUsers, name: "anonymousUsers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case anonymousUsers = "AnonymousUsers"
        }
    }

    public struct SnapshotUserConfigurationRedacted: AWSDecodableShape {
        ///  An array of records that describe anonymous users that the dashboard snapshot is generated for. Sensitive user information is excluded.
        public let anonymousUsers: [SnapshotAnonymousUserRedacted]?

        public init(anonymousUsers: [SnapshotAnonymousUserRedacted]? = nil) {
            self.anonymousUsers = anonymousUsers
        }

        private enum CodingKeys: String, CodingKey {
            case anonymousUsers = "AnonymousUsers"
        }
    }

    public struct SnowflakeParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Warehouse.
        public let warehouse: String

        public init(database: String, host: String, warehouse: String) {
            self.database = database
            self.host = host
            self.warehouse = warehouse
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.warehouse, name: "warehouse", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case warehouse = "Warehouse"
        }
    }

    public struct Spacing: AWSEncodableShape & AWSDecodableShape {
        /// Define the bottom spacing.
        public let bottom: String?
        /// Define the left spacing.
        public let left: String?
        /// Define the right spacing.
        public let right: String?
        /// Define the top spacing.
        public let top: String?

        public init(bottom: String? = nil, left: String? = nil, right: String? = nil, top: String? = nil) {
            self.bottom = bottom
            self.left = left
            self.right = right
            self.top = top
        }

        private enum CodingKeys: String, CodingKey {
            case bottom = "Bottom"
            case left = "Left"
            case right = "Right"
            case top = "Top"
        }
    }

    public struct SparkParameters: AWSEncodableShape & AWSDecodableShape {
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(host: String, port: Int) {
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case port = "Port"
        }
    }

    public struct SqlServerParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct SslProperties: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean option to control whether SSL should be disabled.
        public let disableSsl: Bool?

        public init(disableSsl: Bool? = nil) {
            self.disableSsl = disableSsl
        }

        private enum CodingKeys: String, CodingKey {
            case disableSsl = "DisableSsl"
        }
    }

    public struct StarburstParameters: AWSEncodableShape & AWSDecodableShape {
        /// The catalog name for the Starburst data source.
        public let catalog: String
        /// The host name of the Starburst data source.
        public let host: String
        /// The port for the Starburst data source.
        public let port: Int
        /// The product type for the Starburst data source.
        public let productType: StarburstProductType?

        public init(catalog: String, host: String, port: Int, productType: StarburstProductType? = nil) {
            self.catalog = catalog
            self.host = host
            self.port = port
            self.productType = productType
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 128)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case host = "Host"
            case port = "Port"
            case productType = "ProductType"
        }
    }

    public struct StartAssetBundleExportJobRequest: AWSEncodableShape {
        /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
        public let assetBundleExportJobId: String
        /// The ID of the Amazon Web Services account to export assets from.
        public let awsAccountId: String
        /// An optional collection of structures that generate CloudFormation parameters to override the existing resource property values when the resource is exported to a new CloudFormation template. Use this field if the ExportFormat field of a StartAssetBundleExportJobRequest API call is set to CLOUDFORMATION_JSON.
        public let cloudFormationOverridePropertyConfiguration: AssetBundleCloudFormationOverridePropertyConfiguration?
        /// The export data format.
        public let exportFormat: AssetBundleExportFormat
        /// A Boolean that determines whether all dependencies of each resource ARN are recursively exported with the job. For example, say you provided a Dashboard ARN to the ResourceArns parameter. If you set IncludeAllDependencies to TRUE, any theme, dataset, and data source resource that is a dependency of the dashboard is also exported.
        public let includeAllDependencies: Bool?
        /// A Boolean that determines whether all permissions for each resource ARN are exported with the job. If you set IncludePermissions to TRUE, any permissions associated with each resource are exported.
        public let includePermissions: Bool?
        ///  A Boolean that determines whether all tags for each resource ARN are exported with the job. If you set IncludeTags to TRUE, any tags associated with each resource are exported.
        public let includeTags: Bool?
        /// An array of resource ARNs to export. The following resources are supported.    Analysis     Dashboard     DataSet     DataSource     RefreshSchedule     Theme     VPCConnection    The API caller must have the necessary permissions in their IAM role to access each resource before the resources can be exported.
        public let resourceArns: [String]
        /// An optional parameter that determines which validation strategy to use for the export job. If StrictModeForAllResources is set to TRUE, strict validation for every error is enforced. If it is set to FALSE, validation is skipped for specific UI errors that are shown as warnings. The default value for StrictModeForAllResources is FALSE.
        public let validationStrategy: AssetBundleExportJobValidationStrategy?

        public init(assetBundleExportJobId: String, awsAccountId: String, cloudFormationOverridePropertyConfiguration: AssetBundleCloudFormationOverridePropertyConfiguration? = nil, exportFormat: AssetBundleExportFormat, includeAllDependencies: Bool? = nil, includePermissions: Bool? = nil, includeTags: Bool? = nil, resourceArns: [String], validationStrategy: AssetBundleExportJobValidationStrategy? = nil) {
            self.assetBundleExportJobId = assetBundleExportJobId
            self.awsAccountId = awsAccountId
            self.cloudFormationOverridePropertyConfiguration = cloudFormationOverridePropertyConfiguration
            self.exportFormat = exportFormat
            self.includeAllDependencies = includeAllDependencies
            self.includePermissions = includePermissions
            self.includeTags = includeTags
            self.resourceArns = resourceArns
            self.validationStrategy = validationStrategy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.assetBundleExportJobId, forKey: .assetBundleExportJobId)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.cloudFormationOverridePropertyConfiguration, forKey: .cloudFormationOverridePropertyConfiguration)
            try container.encode(self.exportFormat, forKey: .exportFormat)
            try container.encodeIfPresent(self.includeAllDependencies, forKey: .includeAllDependencies)
            try container.encodeIfPresent(self.includePermissions, forKey: .includePermissions)
            try container.encodeIfPresent(self.includeTags, forKey: .includeTags)
            try container.encode(self.resourceArns, forKey: .resourceArns)
            try container.encodeIfPresent(self.validationStrategy, forKey: .validationStrategy)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetBundleExportJobId, name: "assetBundleExportJobId", parent: name, max: 512)
            try self.validate(self.assetBundleExportJobId, name: "assetBundleExportJobId", parent: name, min: 1)
            try self.validate(self.assetBundleExportJobId, name: "assetBundleExportJobId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.cloudFormationOverridePropertyConfiguration?.validate(name: "\(name).cloudFormationOverridePropertyConfiguration")
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 100)
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetBundleExportJobId = "AssetBundleExportJobId"
            case cloudFormationOverridePropertyConfiguration = "CloudFormationOverridePropertyConfiguration"
            case exportFormat = "ExportFormat"
            case includeAllDependencies = "IncludeAllDependencies"
            case includePermissions = "IncludePermissions"
            case includeTags = "IncludeTags"
            case resourceArns = "ResourceArns"
            case validationStrategy = "ValidationStrategy"
        }
    }

    public struct StartAssetBundleExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the export job.
        public let arn: String?
        /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
        public let assetBundleExportJobId: String?
        /// The Amazon Web Services response ID for this operation.
        public let requestId: String?
        /// The HTTP status of the response.
        public let status: Int?

        public init(arn: String? = nil, assetBundleExportJobId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.assetBundleExportJobId = assetBundleExportJobId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.assetBundleExportJobId = try container.decodeIfPresent(String.self, forKey: .assetBundleExportJobId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetBundleExportJobId = "AssetBundleExportJobId"
            case requestId = "RequestId"
        }
    }

    public struct StartAssetBundleImportJobRequest: AWSEncodableShape {
        /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
        public let assetBundleImportJobId: String
        /// The source of the asset bundle zip file that contains the data that you want to import. The file must be in QUICKSIGHT_JSON format.
        public let assetBundleImportSource: AssetBundleImportSource
        /// The ID of the Amazon Web Services account to import assets into.
        public let awsAccountId: String
        /// The failure action for the import job. If you choose ROLLBACK, failed  import jobs will attempt to  undo any asset changes caused by the failed job. If you choose DO_NOTHING, failed import jobs will not attempt to roll back any asset changes caused by the failed job, possibly keeping the Amazon QuickSight account in an inconsistent state.
        public let failureAction: AssetBundleImportFailureAction?
        /// Optional overrides that are applied to the resource configuration before import.
        public let overrideParameters: AssetBundleImportJobOverrideParameters?
        /// Optional permission overrides that are applied to the resource configuration before import.
        public let overridePermissions: AssetBundleImportJobOverridePermissions?
        /// Optional tag overrides that are applied to the resource configuration before import.
        public let overrideTags: AssetBundleImportJobOverrideTags?
        /// An optional validation strategy override for all analyses and dashboards that is applied to the resource configuration before import.
        public let overrideValidationStrategy: AssetBundleImportJobOverrideValidationStrategy?

        public init(assetBundleImportJobId: String, assetBundleImportSource: AssetBundleImportSource, awsAccountId: String, failureAction: AssetBundleImportFailureAction? = nil, overrideParameters: AssetBundleImportJobOverrideParameters? = nil, overridePermissions: AssetBundleImportJobOverridePermissions? = nil, overrideTags: AssetBundleImportJobOverrideTags? = nil, overrideValidationStrategy: AssetBundleImportJobOverrideValidationStrategy? = nil) {
            self.assetBundleImportJobId = assetBundleImportJobId
            self.assetBundleImportSource = assetBundleImportSource
            self.awsAccountId = awsAccountId
            self.failureAction = failureAction
            self.overrideParameters = overrideParameters
            self.overridePermissions = overridePermissions
            self.overrideTags = overrideTags
            self.overrideValidationStrategy = overrideValidationStrategy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.assetBundleImportJobId, forKey: .assetBundleImportJobId)
            try container.encode(self.assetBundleImportSource, forKey: .assetBundleImportSource)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.failureAction, forKey: .failureAction)
            try container.encodeIfPresent(self.overrideParameters, forKey: .overrideParameters)
            try container.encodeIfPresent(self.overridePermissions, forKey: .overridePermissions)
            try container.encodeIfPresent(self.overrideTags, forKey: .overrideTags)
            try container.encodeIfPresent(self.overrideValidationStrategy, forKey: .overrideValidationStrategy)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetBundleImportJobId, name: "assetBundleImportJobId", parent: name, max: 512)
            try self.validate(self.assetBundleImportJobId, name: "assetBundleImportJobId", parent: name, min: 1)
            try self.validate(self.assetBundleImportJobId, name: "assetBundleImportJobId", parent: name, pattern: "^[\\w\\-]+$")
            try self.assetBundleImportSource.validate(name: "\(name).assetBundleImportSource")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.overrideParameters?.validate(name: "\(name).overrideParameters")
            try self.overridePermissions?.validate(name: "\(name).overridePermissions")
            try self.overrideTags?.validate(name: "\(name).overrideTags")
        }

        private enum CodingKeys: String, CodingKey {
            case assetBundleImportJobId = "AssetBundleImportJobId"
            case assetBundleImportSource = "AssetBundleImportSource"
            case failureAction = "FailureAction"
            case overrideParameters = "OverrideParameters"
            case overridePermissions = "OverridePermissions"
            case overrideTags = "OverrideTags"
            case overrideValidationStrategy = "OverrideValidationStrategy"
        }
    }

    public struct StartAssetBundleImportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the import job.
        public let arn: String?
        /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
        public let assetBundleImportJobId: String?
        /// The Amazon Web Services response ID for this operation.
        public let requestId: String?
        /// The HTTP status of the response.
        public let status: Int?

        public init(arn: String? = nil, assetBundleImportJobId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.assetBundleImportJobId = assetBundleImportJobId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.assetBundleImportJobId = try container.decodeIfPresent(String.self, forKey: .assetBundleImportJobId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assetBundleImportJobId = "AssetBundleImportJobId"
            case requestId = "RequestId"
        }
    }

    public struct StartDashboardSnapshotJobRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
        public let awsAccountId: String
        /// The ID of the dashboard that you want to start a snapshot job for.
        public let dashboardId: String
        /// A structure that describes the configuration of the dashboard snapshot.
        public let snapshotConfiguration: SnapshotConfiguration
        /// An ID for the dashboard snapshot job. This ID is unique to the dashboard while the job is running. This ID can be used to poll the status of a job with a DescribeDashboardSnapshotJob while the job runs. You can reuse this ID for another job 24 hours after the current job is completed.
        public let snapshotJobId: String
        ///  A structure that contains information about the anonymous users that the generated snapshot is for. This API will not return information about registered Amazon QuickSight.
        public let userConfiguration: SnapshotUserConfiguration

        public init(awsAccountId: String, dashboardId: String, snapshotConfiguration: SnapshotConfiguration, snapshotJobId: String, userConfiguration: SnapshotUserConfiguration) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.snapshotConfiguration = snapshotConfiguration
            self.snapshotJobId = snapshotJobId
            self.userConfiguration = userConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            try container.encode(self.snapshotConfiguration, forKey: .snapshotConfiguration)
            try container.encode(self.snapshotJobId, forKey: .snapshotJobId)
            try container.encode(self.userConfiguration, forKey: .userConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.snapshotConfiguration.validate(name: "\(name).snapshotConfiguration")
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, max: 512)
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, min: 1)
            try self.validate(self.snapshotJobId, name: "snapshotJobId", parent: name, pattern: "^[\\w\\-]+$")
            try self.userConfiguration.validate(name: "\(name).userConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotConfiguration = "SnapshotConfiguration"
            case snapshotJobId = "SnapshotJobId"
            case userConfiguration = "UserConfiguration"
        }
    }

    public struct StartDashboardSnapshotJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the dashboard snapshot job.
        public let arn: String?
        ///  The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The ID of the job. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
        public let snapshotJobId: String?
        /// The HTTP status of the request
        public let status: Int?

        public init(arn: String? = nil, requestId: String? = nil, snapshotJobId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.snapshotJobId = snapshotJobId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.snapshotJobId = try container.decodeIfPresent(String.self, forKey: .snapshotJobId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case snapshotJobId = "SnapshotJobId"
        }
    }

    public struct StatePersistenceConfigurations: AWSEncodableShape {
        /// Determines if a Amazon QuickSight dashboard's state persistence settings are turned on or off.
        public let enabled: Bool

        public init(enabled: Bool = false) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct StringDatasetParameter: AWSEncodableShape & AWSDecodableShape {
        /// A list of default values for a given string dataset parameter type. This structure only accepts static values.
        public let defaultValues: StringDatasetParameterDefaultValues?
        /// An identifier for the string parameter that is created in the dataset.
        public let id: String
        /// The name of the string parameter that is created in the dataset.
        public let name: String
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        public let valueType: DatasetParameterValueType

        public init(defaultValues: StringDatasetParameterDefaultValues? = nil, id: String, name: String, valueType: DatasetParameterValueType) {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.valueType = valueType
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case id = "Id"
            case name = "Name"
            case valueType = "ValueType"
        }
    }

    public struct StringDatasetParameterDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// A list of static default values for a given string parameter.
        public let staticValues: [String]?

        public init(staticValues: [String]? = nil) {
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.staticValues?.forEach {
                try validate($0, name: "staticValues[]", parent: name, max: 512)
            }
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 32)
            try self.validate(self.staticValues, name: "staticValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case staticValues = "StaticValues"
        }
    }

    public struct StringDefaultValues: AWSEncodableShape & AWSDecodableShape {
        /// The dynamic value of the StringDefaultValues. Different defaults displayed according to users, groups, and values mapping.
        public let dynamicValue: DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public let staticValues: [String]?

        public init(dynamicValue: DynamicDefaultValue? = nil, staticValues: [String]? = nil) {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }

        public func validate(name: String) throws {
            try self.dynamicValue?.validate(name: "\(name).dynamicValue")
            try self.validate(self.staticValues, name: "staticValues", parent: name, max: 50000)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicValue = "DynamicValue"
            case staticValues = "StaticValues"
        }
    }

    public struct StringFormatConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the null value format configuration.
        public let nullValueFormatConfiguration: NullValueFormatConfiguration?
        /// The formatting configuration for numeric strings.
        public let numericFormatConfiguration: NumericFormatConfiguration?

        public init(nullValueFormatConfiguration: NullValueFormatConfiguration? = nil, numericFormatConfiguration: NumericFormatConfiguration? = nil) {
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }

        public func validate(name: String) throws {
            try self.nullValueFormatConfiguration?.validate(name: "\(name).nullValueFormatConfiguration")
            try self.numericFormatConfiguration?.validate(name: "\(name).numericFormatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case nullValueFormatConfiguration = "NullValueFormatConfiguration"
            case numericFormatConfiguration = "NumericFormatConfiguration"
        }
    }

    public struct StringParameter: AWSEncodableShape & AWSDecodableShape {
        /// A display name for a string parameter.
        public let name: String
        /// The values of a string parameter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct StringParameterDeclaration: AWSEncodableShape & AWSDecodableShape {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public let defaultValues: StringDefaultValues?
        public let mappedDataSetParameters: [MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        public let name: String
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        public let parameterValueType: ParameterValueType
        /// The configuration that defines the default value of a String parameter when a value has not been set.
        public let valueWhenUnset: StringValueWhenUnsetConfiguration?

        public init(defaultValues: StringDefaultValues? = nil, mappedDataSetParameters: [MappedDataSetParameter]? = nil, name: String, parameterValueType: ParameterValueType, valueWhenUnset: StringValueWhenUnsetConfiguration? = nil) {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }

        public func validate(name: String) throws {
            try self.defaultValues?.validate(name: "\(name).defaultValues")
            try self.mappedDataSetParameters?.forEach {
                try $0.validate(name: "\(name).mappedDataSetParameters[]")
            }
            try self.validate(self.mappedDataSetParameters, name: "mappedDataSetParameters", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case mappedDataSetParameters = "MappedDataSetParameters"
            case name = "Name"
            case parameterValueType = "ParameterValueType"
            case valueWhenUnset = "ValueWhenUnset"
        }
    }

    public struct StringValueWhenUnsetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A custom value that's used when the value of a parameter isn't set.
        public let customValue: String?
        /// The built-in options for default values. The value can be one of the following:    RECOMMENDED: The recommended value.    NULL: The NULL value.
        public let valueWhenUnsetOption: ValueWhenUnsetOption?

        public init(customValue: String? = nil, valueWhenUnsetOption: ValueWhenUnsetOption? = nil) {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }

        private enum CodingKeys: String, CodingKey {
            case customValue = "CustomValue"
            case valueWhenUnsetOption = "ValueWhenUnsetOption"
        }
    }

    public struct SubtotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The custom label string for the subtotal cells.
        public let customLabel: String?
        /// The field level (all, custom, last) for the subtotal cells.
        public let fieldLevel: PivotTableSubtotalLevel?
        /// The optional configuration of subtotal cells.
        public let fieldLevelOptions: [PivotTableFieldSubtotalOptions]?
        /// The cell styling options for the subtotals of header cells.
        public let metricHeaderCellStyle: TableCellStyle?
        /// The style targets options for subtotals.
        public let styleTargets: [TableStyleTarget]?
        /// The cell styling options for the subtotal cells.
        public let totalCellStyle: TableCellStyle?
        /// The visibility configuration for the subtotal cells.
        public let totalsVisibility: Visibility?
        /// The cell styling options for the subtotals of value cells.
        public let valueCellStyle: TableCellStyle?

        public init(customLabel: String? = nil, fieldLevel: PivotTableSubtotalLevel? = nil, fieldLevelOptions: [PivotTableFieldSubtotalOptions]? = nil, metricHeaderCellStyle: TableCellStyle? = nil, styleTargets: [TableStyleTarget]? = nil, totalCellStyle: TableCellStyle? = nil, totalsVisibility: Visibility? = nil, valueCellStyle: TableCellStyle? = nil) {
            self.customLabel = customLabel
            self.fieldLevel = fieldLevel
            self.fieldLevelOptions = fieldLevelOptions
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.styleTargets = styleTargets
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }

        public func validate(name: String) throws {
            try self.fieldLevelOptions?.forEach {
                try $0.validate(name: "\(name).fieldLevelOptions[]")
            }
            try self.validate(self.fieldLevelOptions, name: "fieldLevelOptions", parent: name, max: 100)
            try self.metricHeaderCellStyle?.validate(name: "\(name).metricHeaderCellStyle")
            try self.validate(self.styleTargets, name: "styleTargets", parent: name, max: 3)
            try self.totalCellStyle?.validate(name: "\(name).totalCellStyle")
            try self.valueCellStyle?.validate(name: "\(name).valueCellStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fieldLevel = "FieldLevel"
            case fieldLevelOptions = "FieldLevelOptions"
            case metricHeaderCellStyle = "MetricHeaderCellStyle"
            case styleTargets = "StyleTargets"
            case totalCellStyle = "TotalCellStyle"
            case totalsVisibility = "TotalsVisibility"
            case valueCellStyle = "ValueCellStyle"
        }
    }

    public struct TableAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The group by field well for a pivot table. Values are grouped by group by fields.
        public let groupBy: [DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on group by fields.
        public let values: [MeasureField]?

        public init(groupBy: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.groupBy = groupBy
            self.values = values
        }

        public func validate(name: String) throws {
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case values = "Values"
        }
    }

    public struct TableBorderOptions: AWSEncodableShape & AWSDecodableShape {
        /// The color of a table border.
        public let color: String?
        /// The style (none, solid) of a table border.
        public let style: TableBorderStyle?
        /// The thickness of a table border.
        public let thickness: Int?

        public init(color: String? = nil, style: TableBorderStyle? = nil, thickness: Int? = nil) {
            self.color = color
            self.style = style
            self.thickness = thickness
        }

        public func validate(name: String) throws {
            try self.validate(self.color, name: "color", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.thickness, name: "thickness", parent: name, max: 4)
            try self.validate(self.thickness, name: "thickness", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case color = "Color"
            case style = "Style"
            case thickness = "Thickness"
        }
    }

    public struct TableCellConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The field ID of the cell for conditional formatting.
        public let fieldId: String
        /// The text format of the cell for conditional formatting.
        public let textFormat: TextConditionalFormat?

        public init(fieldId: String, textFormat: TextConditionalFormat? = nil) {
            self.fieldId = fieldId
            self.textFormat = textFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.textFormat?.validate(name: "\(name).textFormat")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case textFormat = "TextFormat"
        }
    }

    public struct TableCellImageSizingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The cell scaling configuration of the sizing options for the table image configuration.
        public let tableCellImageScalingConfiguration: TableCellImageScalingConfiguration?

        public init(tableCellImageScalingConfiguration: TableCellImageScalingConfiguration? = nil) {
            self.tableCellImageScalingConfiguration = tableCellImageScalingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case tableCellImageScalingConfiguration = "TableCellImageScalingConfiguration"
        }
    }

    public struct TableCellStyle: AWSEncodableShape & AWSDecodableShape {
        /// The background color for the table cells.
        public let backgroundColor: String?
        /// The borders for the table cells.
        public let border: GlobalTableBorderOptions?
        /// The font configuration of the table cells.
        public let fontConfiguration: FontConfiguration?
        /// The height color for the table cells.
        public let height: Int?
        /// The horizontal text alignment (left, center, right, auto) for the table cells.
        public let horizontalTextAlignment: HorizontalTextAlignment?
        /// The text wrap (none, wrap) for the table cells.
        public let textWrap: TextWrap?
        /// The vertical text alignment (top, middle, bottom) for the table cells.
        public let verticalTextAlignment: VerticalTextAlignment?
        /// The visibility of the table cells.
        public let visibility: Visibility?

        public init(backgroundColor: String? = nil, border: GlobalTableBorderOptions? = nil, fontConfiguration: FontConfiguration? = nil, height: Int? = nil, horizontalTextAlignment: HorizontalTextAlignment? = nil, textWrap: TextWrap? = nil, verticalTextAlignment: VerticalTextAlignment? = nil, visibility: Visibility? = nil) {
            self.backgroundColor = backgroundColor
            self.border = border
            self.fontConfiguration = fontConfiguration
            self.height = height
            self.horizontalTextAlignment = horizontalTextAlignment
            self.textWrap = textWrap
            self.verticalTextAlignment = verticalTextAlignment
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.backgroundColor, name: "backgroundColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.border?.validate(name: "\(name).border")
            try self.fontConfiguration?.validate(name: "\(name).fontConfiguration")
            try self.validate(self.height, name: "height", parent: name, max: 500)
            try self.validate(self.height, name: "height", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case border = "Border"
            case fontConfiguration = "FontConfiguration"
            case height = "Height"
            case horizontalTextAlignment = "HorizontalTextAlignment"
            case textWrap = "TextWrap"
            case verticalTextAlignment = "VerticalTextAlignment"
            case visibility = "Visibility"
        }
    }

    public struct TableConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// Conditional formatting options for a PivotTableVisual.
        public let conditionalFormattingOptions: [TableConditionalFormattingOption]?

        public init(conditionalFormattingOptions: [TableConditionalFormattingOption]? = nil) {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }

        public func validate(name: String) throws {
            try self.conditionalFormattingOptions?.forEach {
                try $0.validate(name: "\(name).conditionalFormattingOptions[]")
            }
            try self.validate(self.conditionalFormattingOptions, name: "conditionalFormattingOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionalFormattingOptions = "ConditionalFormattingOptions"
        }
    }

    public struct TableConditionalFormattingOption: AWSEncodableShape & AWSDecodableShape {
        /// The cell conditional formatting option for a table.
        public let cell: TableCellConditionalFormatting?
        /// The row conditional formatting option for a table.
        public let row: TableRowConditionalFormatting?

        public init(cell: TableCellConditionalFormatting? = nil, row: TableRowConditionalFormatting? = nil) {
            self.cell = cell
            self.row = row
        }

        public func validate(name: String) throws {
            try self.cell?.validate(name: "\(name).cell")
            try self.row?.validate(name: "\(name).row")
        }

        private enum CodingKeys: String, CodingKey {
            case cell = "Cell"
            case row = "Row"
        }
    }

    public struct TableConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The field options for a table visual.
        public let fieldOptions: TableFieldOptions?
        /// The field wells of the visual.
        public let fieldWells: TableFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The paginated report options for a table visual.
        public let paginatedReportOptions: TablePaginatedReportOptions?
        /// The sort configuration for a TableVisual.
        public let sortConfiguration: TableSortConfiguration?
        /// A collection of inline visualizations to display within a chart.
        public let tableInlineVisualizations: [TableInlineVisualization]?
        /// The table options for a table visual.
        public let tableOptions: TableOptions?
        /// The total options for a table visual.
        public let totalOptions: TotalOptions?

        public init(fieldOptions: TableFieldOptions? = nil, fieldWells: TableFieldWells? = nil, interactions: VisualInteractionOptions? = nil, paginatedReportOptions: TablePaginatedReportOptions? = nil, sortConfiguration: TableSortConfiguration? = nil, tableInlineVisualizations: [TableInlineVisualization]? = nil, tableOptions: TableOptions? = nil, totalOptions: TotalOptions? = nil) {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableInlineVisualizations = tableInlineVisualizations
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }

        public func validate(name: String) throws {
            try self.fieldOptions?.validate(name: "\(name).fieldOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tableInlineVisualizations?.forEach {
                try $0.validate(name: "\(name).tableInlineVisualizations[]")
            }
            try self.validate(self.tableInlineVisualizations, name: "tableInlineVisualizations", parent: name, max: 200)
            try self.tableOptions?.validate(name: "\(name).tableOptions")
            try self.totalOptions?.validate(name: "\(name).totalOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldOptions = "FieldOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case paginatedReportOptions = "PaginatedReportOptions"
            case sortConfiguration = "SortConfiguration"
            case tableInlineVisualizations = "TableInlineVisualizations"
            case tableOptions = "TableOptions"
            case totalOptions = "TotalOptions"
        }
    }

    public struct TableFieldCustomIconContent: AWSEncodableShape & AWSDecodableShape {
        /// The icon set type (link) of the custom icon content for table URL link content.
        public let icon: TableFieldIconSetType?

        public init(icon: TableFieldIconSetType? = nil) {
            self.icon = icon
        }

        private enum CodingKeys: String, CodingKey {
            case icon = "Icon"
        }
    }

    public struct TableFieldCustomTextContent: AWSEncodableShape & AWSDecodableShape {
        /// The font configuration of the custom text content for the table URL link content.
        public let fontConfiguration: FontConfiguration
        /// The string value of the custom text content for the table URL link content.
        public let value: String?

        public init(fontConfiguration: FontConfiguration, value: String? = nil) {
            self.fontConfiguration = fontConfiguration
            self.value = value
        }

        public func validate(name: String) throws {
            try self.fontConfiguration.validate(name: "\(name).fontConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case fontConfiguration = "FontConfiguration"
            case value = "Value"
        }
    }

    public struct TableFieldImageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sizing options for the table image configuration.
        public let sizingOptions: TableCellImageSizingConfiguration?

        public init(sizingOptions: TableCellImageSizingConfiguration? = nil) {
            self.sizingOptions = sizingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case sizingOptions = "SizingOptions"
        }
    }

    public struct TableFieldLinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The URL content (text, icon) for the table link configuration.
        public let content: TableFieldLinkContentConfiguration
        /// The URL target (new tab, new window, same tab) for the table link configuration.
        public let target: URLTargetConfiguration

        public init(content: TableFieldLinkContentConfiguration, target: URLTargetConfiguration) {
            self.content = content
            self.target = target
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case target = "Target"
        }
    }

    public struct TableFieldLinkContentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The custom icon content for the table link content configuration.
        public let customIconContent: TableFieldCustomIconContent?
        /// The custom text content (value, font configuration) for the table link content configuration.
        public let customTextContent: TableFieldCustomTextContent?

        public init(customIconContent: TableFieldCustomIconContent? = nil, customTextContent: TableFieldCustomTextContent? = nil) {
            self.customIconContent = customIconContent
            self.customTextContent = customTextContent
        }

        public func validate(name: String) throws {
            try self.customTextContent?.validate(name: "\(name).customTextContent")
        }

        private enum CodingKeys: String, CodingKey {
            case customIconContent = "CustomIconContent"
            case customTextContent = "CustomTextContent"
        }
    }

    public struct TableFieldOption: AWSEncodableShape & AWSDecodableShape {
        /// The custom label for a table field.
        public let customLabel: String?
        /// The field ID for a table field.
        public let fieldId: String
        /// The URL configuration for a table field.
        public let urlStyling: TableFieldURLConfiguration?
        /// The visibility of a table field.
        public let visibility: Visibility?
        /// The width for a table field.
        public let width: String?

        public init(customLabel: String? = nil, fieldId: String, urlStyling: TableFieldURLConfiguration? = nil, visibility: Visibility? = nil, width: String? = nil) {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.urlStyling = urlStyling
            self.visibility = visibility
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.customLabel, name: "customLabel", parent: name, max: 2048)
            try self.validate(self.customLabel, name: "customLabel", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.urlStyling?.validate(name: "\(name).urlStyling")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case fieldId = "FieldId"
            case urlStyling = "URLStyling"
            case visibility = "Visibility"
            case width = "Width"
        }
    }

    public struct TableFieldOptions: AWSEncodableShape & AWSDecodableShape {
        /// The order of the field IDs that are configured as field options for a table visual.
        public let order: [String]?
        /// The settings for the pinned columns of a table visual.
        public let pinnedFieldOptions: TablePinnedFieldOptions?
        /// The field options to be configured to a table.
        public let selectedFieldOptions: [TableFieldOption]?

        public init(order: [String]? = nil, pinnedFieldOptions: TablePinnedFieldOptions? = nil, selectedFieldOptions: [TableFieldOption]? = nil) {
            self.order = order
            self.pinnedFieldOptions = pinnedFieldOptions
            self.selectedFieldOptions = selectedFieldOptions
        }

        public func validate(name: String) throws {
            try self.order?.forEach {
                try validate($0, name: "order[]", parent: name, max: 512)
                try validate($0, name: "order[]", parent: name, min: 1)
            }
            try self.validate(self.order, name: "order", parent: name, max: 200)
            try self.pinnedFieldOptions?.validate(name: "\(name).pinnedFieldOptions")
            try self.selectedFieldOptions?.forEach {
                try $0.validate(name: "\(name).selectedFieldOptions[]")
            }
            try self.validate(self.selectedFieldOptions, name: "selectedFieldOptions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case order = "Order"
            case pinnedFieldOptions = "PinnedFieldOptions"
            case selectedFieldOptions = "SelectedFieldOptions"
        }
    }

    public struct TableFieldURLConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The image configuration of a table field URL.
        public let imageConfiguration: TableFieldImageConfiguration?
        /// The link configuration of a table field URL.
        public let linkConfiguration: TableFieldLinkConfiguration?

        public init(imageConfiguration: TableFieldImageConfiguration? = nil, linkConfiguration: TableFieldLinkConfiguration? = nil) {
            self.imageConfiguration = imageConfiguration
            self.linkConfiguration = linkConfiguration
        }

        public func validate(name: String) throws {
            try self.linkConfiguration?.validate(name: "\(name).linkConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case imageConfiguration = "ImageConfiguration"
            case linkConfiguration = "LinkConfiguration"
        }
    }

    public struct TableFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field well for the table.
        public let tableAggregatedFieldWells: TableAggregatedFieldWells?
        /// The unaggregated field well for the table.
        public let tableUnaggregatedFieldWells: TableUnaggregatedFieldWells?

        public init(tableAggregatedFieldWells: TableAggregatedFieldWells? = nil, tableUnaggregatedFieldWells: TableUnaggregatedFieldWells? = nil) {
            self.tableAggregatedFieldWells = tableAggregatedFieldWells
            self.tableUnaggregatedFieldWells = tableUnaggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.tableAggregatedFieldWells?.validate(name: "\(name).tableAggregatedFieldWells")
            try self.tableUnaggregatedFieldWells?.validate(name: "\(name).tableUnaggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case tableAggregatedFieldWells = "TableAggregatedFieldWells"
            case tableUnaggregatedFieldWells = "TableUnaggregatedFieldWells"
        }
    }

    public struct TableInlineVisualization: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of the inline visualization of the data bars within a chart.
        public let dataBars: DataBarsOptions?

        public init(dataBars: DataBarsOptions? = nil) {
            self.dataBars = dataBars
        }

        public func validate(name: String) throws {
            try self.dataBars?.validate(name: "\(name).dataBars")
        }

        private enum CodingKeys: String, CodingKey {
            case dataBars = "DataBars"
        }
    }

    public struct TableOptions: AWSEncodableShape & AWSDecodableShape {
        /// The table cell style of table cells.
        public let cellStyle: TableCellStyle?
        /// The table cell style of a table header.
        public let headerStyle: TableCellStyle?
        /// The orientation (vertical, horizontal) for a table.
        public let orientation: TableOrientation?
        /// The row alternate color options (widget status, row alternate colors) for a table.
        public let rowAlternateColorOptions: RowAlternateColorOptions?

        public init(cellStyle: TableCellStyle? = nil, headerStyle: TableCellStyle? = nil, orientation: TableOrientation? = nil, rowAlternateColorOptions: RowAlternateColorOptions? = nil) {
            self.cellStyle = cellStyle
            self.headerStyle = headerStyle
            self.orientation = orientation
            self.rowAlternateColorOptions = rowAlternateColorOptions
        }

        public func validate(name: String) throws {
            try self.cellStyle?.validate(name: "\(name).cellStyle")
            try self.headerStyle?.validate(name: "\(name).headerStyle")
            try self.rowAlternateColorOptions?.validate(name: "\(name).rowAlternateColorOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case cellStyle = "CellStyle"
            case headerStyle = "HeaderStyle"
            case orientation = "Orientation"
            case rowAlternateColorOptions = "RowAlternateColorOptions"
        }
    }

    public struct TablePaginatedReportOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of repeating header rows on each page.
        public let overflowColumnHeaderVisibility: Visibility?
        /// The visibility of printing table overflow across pages.
        public let verticalOverflowVisibility: Visibility?

        public init(overflowColumnHeaderVisibility: Visibility? = nil, verticalOverflowVisibility: Visibility? = nil) {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }

        private enum CodingKeys: String, CodingKey {
            case overflowColumnHeaderVisibility = "OverflowColumnHeaderVisibility"
            case verticalOverflowVisibility = "VerticalOverflowVisibility"
        }
    }

    public struct TablePinnedFieldOptions: AWSEncodableShape & AWSDecodableShape {
        /// A list of columns to be pinned to the left of a table visual.
        public let pinnedLeftFields: [String]?

        public init(pinnedLeftFields: [String]? = nil) {
            self.pinnedLeftFields = pinnedLeftFields
        }

        public func validate(name: String) throws {
            try self.pinnedLeftFields?.forEach {
                try validate($0, name: "pinnedLeftFields[]", parent: name, max: 512)
                try validate($0, name: "pinnedLeftFields[]", parent: name, min: 1)
            }
            try self.validate(self.pinnedLeftFields, name: "pinnedLeftFields", parent: name, max: 201)
        }

        private enum CodingKeys: String, CodingKey {
            case pinnedLeftFields = "PinnedLeftFields"
        }
    }

    public struct TableRowConditionalFormatting: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting color (solid, gradient) of the background for a table row.
        public let backgroundColor: ConditionalFormattingColor?
        /// The conditional formatting color (solid, gradient) of the text for a table row.
        public let textColor: ConditionalFormattingColor?

        public init(backgroundColor: ConditionalFormattingColor? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.backgroundColor = backgroundColor
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.backgroundColor?.validate(name: "\(name).backgroundColor")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case textColor = "TextColor"
        }
    }

    public struct TableSideBorderOptions: AWSEncodableShape & AWSDecodableShape {
        /// The table border options of the bottom border.
        public let bottom: TableBorderOptions?
        /// The table border options of the inner horizontal border.
        public let innerHorizontal: TableBorderOptions?
        /// The table border options of the inner vertical border.
        public let innerVertical: TableBorderOptions?
        /// The table border options of the left border.
        public let left: TableBorderOptions?
        /// The table border options of the right border.
        public let right: TableBorderOptions?
        /// The table border options of the top border.
        public let top: TableBorderOptions?

        public init(bottom: TableBorderOptions? = nil, innerHorizontal: TableBorderOptions? = nil, innerVertical: TableBorderOptions? = nil, left: TableBorderOptions? = nil, right: TableBorderOptions? = nil, top: TableBorderOptions? = nil) {
            self.bottom = bottom
            self.innerHorizontal = innerHorizontal
            self.innerVertical = innerVertical
            self.left = left
            self.right = right
            self.top = top
        }

        public func validate(name: String) throws {
            try self.bottom?.validate(name: "\(name).bottom")
            try self.innerHorizontal?.validate(name: "\(name).innerHorizontal")
            try self.innerVertical?.validate(name: "\(name).innerVertical")
            try self.left?.validate(name: "\(name).left")
            try self.right?.validate(name: "\(name).right")
            try self.top?.validate(name: "\(name).top")
        }

        private enum CodingKeys: String, CodingKey {
            case bottom = "Bottom"
            case innerHorizontal = "InnerHorizontal"
            case innerVertical = "InnerVertical"
            case left = "Left"
            case right = "Right"
            case top = "Top"
        }
    }

    public struct TableSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The pagination configuration (page size, page number) for the table.
        public let paginationConfiguration: PaginationConfiguration?
        /// The field sort options for rows in the table.
        public let rowSort: [FieldSortOptions]?

        public init(paginationConfiguration: PaginationConfiguration? = nil, rowSort: [FieldSortOptions]? = nil) {
            self.paginationConfiguration = paginationConfiguration
            self.rowSort = rowSort
        }

        public func validate(name: String) throws {
            try self.paginationConfiguration?.validate(name: "\(name).paginationConfiguration")
            try self.rowSort?.forEach {
                try $0.validate(name: "\(name).rowSort[]")
            }
            try self.validate(self.rowSort, name: "rowSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case paginationConfiguration = "PaginationConfiguration"
            case rowSort = "RowSort"
        }
    }

    public struct TableStyleTarget: AWSEncodableShape & AWSDecodableShape {
        /// The cell type of the table style target.
        public let cellType: StyledCellType

        public init(cellType: StyledCellType) {
            self.cellType = cellType
        }

        private enum CodingKeys: String, CodingKey {
            case cellType = "CellType"
        }
    }

    public struct TableUnaggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The values field well for a pivot table. Values are unaggregated for an unaggregated table.
        public let values: [UnaggregatedField]?

        public init(values: [UnaggregatedField]? = nil) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct TableVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: TableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public let conditionalFormatting: TableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: TableConfiguration? = nil, conditionalFormatting: TableConditionalFormatting? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.conditionalFormatting?.validate(name: "\(name).conditionalFormatting")
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case conditionalFormatting = "ConditionalFormatting"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Tag key.
        public let key: String
        /// Tag value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The column that this operation acts on.
        public let columnName: String
        /// The dataset column tag, currently only used for geospatial type tagging.  This is not tags for the Amazon Web Services tagging feature.
        public let tags: [ColumnTag]

        public init(columnName: String, tags: [ColumnTag]) {
            self.columnName = columnName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 16)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case tags = "Tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct Template: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the template.
        public let arn: String?
        /// Time when this was created.
        public let createdTime: Date?
        /// Time when this was last updated.
        public let lastUpdatedTime: Date?
        /// The display name of the template.
        public let name: String?
        /// The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let templateId: String?
        /// A structure describing the versions of the template.
        public let version: TemplateVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, templateId: String? = nil, version: TemplateVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.templateId = templateId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case templateId = "TemplateId"
            case version = "Version"
        }
    }

    public struct TemplateAlias: AWSDecodableShape {
        /// The display name of the template alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the template alias.
        public let arn: String?
        /// The version number of the template alias.
        public let templateVersionNumber: Int64?

        public init(aliasName: String? = nil, arn: String? = nil, templateVersionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.templateVersionNumber = templateVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct TemplateError: AWSDecodableShape {
        /// Description of the error type.
        public let message: String?
        /// Type of error.
        public let type: TemplateErrorType?
        /// An error path that shows which entities caused the template error.
        public let violatedEntities: [Entity]?

        public init(message: String? = nil, type: TemplateErrorType? = nil, violatedEntities: [Entity]? = nil) {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
            case violatedEntities = "ViolatedEntities"
        }
    }

    public struct TemplateSourceAnalysis: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String
        /// A structure containing information about the dataset references used as placeholders in the template.
        public let dataSetReferences: [DataSetReference]

        public init(arn: String, dataSetReferences: [DataSetReference]) {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }

        public func validate(name: String) throws {
            try self.dataSetReferences.forEach {
                try $0.validate(name: "\(name).dataSetReferences[]")
            }
            try self.validate(self.dataSetReferences, name: "dataSetReferences", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetReferences = "DataSetReferences"
        }
    }

    public struct TemplateSourceEntity: AWSEncodableShape {
        /// The source analysis, if it is based on an analysis.
        public let sourceAnalysis: TemplateSourceAnalysis?
        /// The source template, if it is based on an template.
        public let sourceTemplate: TemplateSourceTemplate?

        public init(sourceAnalysis: TemplateSourceAnalysis? = nil, sourceTemplate: TemplateSourceTemplate? = nil) {
            self.sourceAnalysis = sourceAnalysis
            self.sourceTemplate = sourceTemplate
        }

        public func validate(name: String) throws {
            try self.sourceAnalysis?.validate(name: "\(name).sourceAnalysis")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAnalysis = "SourceAnalysis"
            case sourceTemplate = "SourceTemplate"
        }
    }

    public struct TemplateSourceTemplate: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct TemplateSummary: AWSDecodableShape {
        /// A summary of a template.
        public let arn: String?
        /// The last time that this template was created.
        public let createdTime: Date?
        /// The last time that this template was updated.
        public let lastUpdatedTime: Date?
        /// A structure containing a list of version numbers for the template summary.
        public let latestVersionNumber: Int64?
        /// A display name for the template.
        public let name: String?
        /// The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let templateId: String?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, latestVersionNumber: Int64? = nil, name: String? = nil, templateId: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case latestVersionNumber = "LatestVersionNumber"
            case name = "Name"
            case templateId = "TemplateId"
        }
    }

    public struct TemplateVersion: AWSDecodableShape {
        /// The time that this template version was created.
        public let createdTime: Date?
        /// Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.
        public let dataSetConfigurations: [DataSetConfiguration]?
        /// The description of the template.
        public let description: String?
        /// Errors associated with this template version.
        public let errors: [TemplateError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public let sheets: [Sheet]?
        /// The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.
        public let sourceEntityArn: String?
        /// The status that is associated with the template.    CREATION_IN_PROGRESS     CREATION_SUCCESSFUL     CREATION_FAILED     UPDATE_IN_PROGRESS     UPDATE_SUCCESSFUL     UPDATE_FAILED     DELETED
        public let status: ResourceStatus?
        /// The ARN of the theme associated with this version of the template.
        public let themeArn: String?
        /// The version number of the template version.
        public let versionNumber: Int64?

        public init(createdTime: Date? = nil, dataSetConfigurations: [DataSetConfiguration]? = nil, description: String? = nil, errors: [TemplateError]? = nil, sheets: [Sheet]? = nil, sourceEntityArn: String? = nil, status: ResourceStatus? = nil, themeArn: String? = nil, versionNumber: Int64? = nil) {
            self.createdTime = createdTime
            self.dataSetConfigurations = dataSetConfigurations
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case dataSetConfigurations = "DataSetConfigurations"
            case description = "Description"
            case errors = "Errors"
            case sheets = "Sheets"
            case sourceEntityArn = "SourceEntityArn"
            case status = "Status"
            case themeArn = "ThemeArn"
            case versionNumber = "VersionNumber"
        }
    }

    public struct TemplateVersionDefinition: AWSEncodableShape & AWSDecodableShape {
        public let analysisDefaults: AnalysisDefaults?
        /// An array of calculated field definitions for the template.
        public let calculatedFields: [CalculatedField]?
        ///  An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template.
        public let columnConfigurations: [ColumnConfiguration]?
        /// An array of dataset configurations. These configurations define the required columns for each dataset used within a template.
        public let dataSetConfigurations: [DataSetConfiguration]
        /// Filter definitions for a template. For more information, see Filtering Data in the Amazon QuickSight User Guide.
        public let filterGroups: [FilterGroup]?
        /// An array of option definitions for a template.
        public let options: AssetOptions?
        /// An array of parameter declarations for a template.  Parameters are named variables that can transfer a value for use by an action or an object. For more information, see Parameters in Amazon QuickSight in the Amazon QuickSight User Guide.
        public let parameterDeclarations: [ParameterDeclaration]?
        /// An array of sheet definitions for a template.
        public let sheets: [SheetDefinition]?

        public init(analysisDefaults: AnalysisDefaults? = nil, calculatedFields: [CalculatedField]? = nil, columnConfigurations: [ColumnConfiguration]? = nil, dataSetConfigurations: [DataSetConfiguration], filterGroups: [FilterGroup]? = nil, options: AssetOptions? = nil, parameterDeclarations: [ParameterDeclaration]? = nil, sheets: [SheetDefinition]? = nil) {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetConfigurations = dataSetConfigurations
            self.filterGroups = filterGroups
            self.options = options
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }

        public func validate(name: String) throws {
            try self.calculatedFields?.forEach {
                try $0.validate(name: "\(name).calculatedFields[]")
            }
            try self.validate(self.calculatedFields, name: "calculatedFields", parent: name, max: 500)
            try self.columnConfigurations?.forEach {
                try $0.validate(name: "\(name).columnConfigurations[]")
            }
            try self.validate(self.columnConfigurations, name: "columnConfigurations", parent: name, max: 2000)
            try self.dataSetConfigurations.forEach {
                try $0.validate(name: "\(name).dataSetConfigurations[]")
            }
            try self.validate(self.dataSetConfigurations, name: "dataSetConfigurations", parent: name, max: 30)
            try self.filterGroups?.forEach {
                try $0.validate(name: "\(name).filterGroups[]")
            }
            try self.validate(self.filterGroups, name: "filterGroups", parent: name, max: 2000)
            try self.parameterDeclarations?.forEach {
                try $0.validate(name: "\(name).parameterDeclarations[]")
            }
            try self.validate(self.parameterDeclarations, name: "parameterDeclarations", parent: name, max: 200)
            try self.sheets?.forEach {
                try $0.validate(name: "\(name).sheets[]")
            }
            try self.validate(self.sheets, name: "sheets", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisDefaults = "AnalysisDefaults"
            case calculatedFields = "CalculatedFields"
            case columnConfigurations = "ColumnConfigurations"
            case dataSetConfigurations = "DataSetConfigurations"
            case filterGroups = "FilterGroups"
            case options = "Options"
            case parameterDeclarations = "ParameterDeclarations"
            case sheets = "Sheets"
        }
    }

    public struct TemplateVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the template version.
        public let arn: String?
        /// The time that this template version was created.
        public let createdTime: Date?
        /// The description of the template version.
        public let description: String?
        /// The status of the template version.
        public let status: ResourceStatus?
        /// The version number of the template version.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct TeradataParameters: AWSEncodableShape & AWSDecodableShape {
        /// Database.
        public let database: String
        /// Host.
        public let host: String
        /// Port.
        public let port: Int

        public init(database: String, host: String, port: Int) {
            self.database = database
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, max: 128)
            try self.validate(self.database, name: "database", parent: name, min: 1)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct TextAreaControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of info icon label options.
        public let infoIconLabelOptions: SheetControlInfoIconLabelOptions?
        /// The configuration of the placeholder options in a text area control.
        public let placeholderOptions: TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(infoIconLabelOptions: SheetControlInfoIconLabelOptions? = nil, placeholderOptions: TextControlPlaceholderOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.infoIconLabelOptions?.validate(name: "\(name).infoIconLabelOptions")
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case infoIconLabelOptions = "InfoIconLabelOptions"
            case placeholderOptions = "PlaceholderOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct TextConditionalFormat: AWSEncodableShape & AWSDecodableShape {
        /// The conditional formatting for the text background color.
        public let backgroundColor: ConditionalFormattingColor?
        /// The conditional formatting for the icon.
        public let icon: ConditionalFormattingIcon?
        /// The conditional formatting for the text color.
        public let textColor: ConditionalFormattingColor?

        public init(backgroundColor: ConditionalFormattingColor? = nil, icon: ConditionalFormattingIcon? = nil, textColor: ConditionalFormattingColor? = nil) {
            self.backgroundColor = backgroundColor
            self.icon = icon
            self.textColor = textColor
        }

        public func validate(name: String) throws {
            try self.backgroundColor?.validate(name: "\(name).backgroundColor")
            try self.icon?.validate(name: "\(name).icon")
            try self.textColor?.validate(name: "\(name).textColor")
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "BackgroundColor"
            case icon = "Icon"
            case textColor = "TextColor"
        }
    }

    public struct TextControlPlaceholderOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility configuration of the placeholder options in a text control.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct TextFieldControlDisplayOptions: AWSEncodableShape & AWSDecodableShape {
        /// The configuration of info icon label options.
        public let infoIconLabelOptions: SheetControlInfoIconLabelOptions?
        /// The configuration of the placeholder options in a text field control.
        public let placeholderOptions: TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public let titleOptions: LabelOptions?

        public init(infoIconLabelOptions: SheetControlInfoIconLabelOptions? = nil, placeholderOptions: TextControlPlaceholderOptions? = nil, titleOptions: LabelOptions? = nil) {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }

        public func validate(name: String) throws {
            try self.infoIconLabelOptions?.validate(name: "\(name).infoIconLabelOptions")
            try self.titleOptions?.validate(name: "\(name).titleOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case infoIconLabelOptions = "InfoIconLabelOptions"
            case placeholderOptions = "PlaceholderOptions"
            case titleOptions = "TitleOptions"
        }
    }

    public struct Theme: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the theme.
        public let arn: String?
        /// The date and time that the theme was created.
        public let createdTime: Date?
        /// The date and time that the theme was last updated.
        public let lastUpdatedTime: Date?
        /// The name that the user gives to the theme.
        public let name: String?
        /// The identifier that the user gives to the theme.
        public let themeId: String?
        /// The type of theme, based on how it was created. Valid values include: QUICKSIGHT and CUSTOM.
        public let type: ThemeType?
        public let version: ThemeVersion?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, themeId: String? = nil, type: ThemeType? = nil, version: ThemeVersion? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.themeId = themeId
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case themeId = "ThemeId"
            case type = "Type"
            case version = "Version"
        }
    }

    public struct ThemeAlias: AWSDecodableShape {
        /// The display name of the theme alias.
        public let aliasName: String?
        /// The Amazon Resource Name (ARN) of the theme alias.
        public let arn: String?
        /// The version number of the theme alias.
        public let themeVersionNumber: Int64?

        public init(aliasName: String? = nil, arn: String? = nil, themeVersionNumber: Int64? = nil) {
            self.aliasName = aliasName
            self.arn = arn
            self.themeVersionNumber = themeVersionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case aliasName = "AliasName"
            case arn = "Arn"
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct ThemeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Color properties that apply to chart data colors.
        public let dataColorPalette: DataColorPalette?
        /// Display options related to sheets.
        public let sheet: SheetStyle?
        public let typography: Typography?
        /// Color properties that apply to the UI and to charts, excluding the colors that apply to data.
        public let uiColorPalette: UIColorPalette?

        public init(dataColorPalette: DataColorPalette? = nil, sheet: SheetStyle? = nil, typography: Typography? = nil, uiColorPalette: UIColorPalette? = nil) {
            self.dataColorPalette = dataColorPalette
            self.sheet = sheet
            self.typography = typography
            self.uiColorPalette = uiColorPalette
        }

        public func validate(name: String) throws {
            try self.dataColorPalette?.validate(name: "\(name).dataColorPalette")
            try self.typography?.validate(name: "\(name).typography")
            try self.uiColorPalette?.validate(name: "\(name).uiColorPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case dataColorPalette = "DataColorPalette"
            case sheet = "Sheet"
            case typography = "Typography"
            case uiColorPalette = "UIColorPalette"
        }
    }

    public struct ThemeError: AWSDecodableShape {
        /// The error message.
        public let message: String?
        /// The type of error.
        public let type: ThemeErrorType?

        public init(message: String? = nil, type: ThemeErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ThemeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The date and time that this theme was created.
        public let createdTime: Date?
        /// The last date and time that this theme was updated.
        public let lastUpdatedTime: Date?
        /// The latest version number for the theme.
        public let latestVersionNumber: Int64?
        /// the display name for the theme.
        public let name: String?
        /// The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let themeId: String?

        public init(arn: String? = nil, createdTime: Date? = nil, lastUpdatedTime: Date? = nil, latestVersionNumber: Int64? = nil, name: String? = nil, themeId: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.themeId = themeId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case lastUpdatedTime = "LastUpdatedTime"
            case latestVersionNumber = "LatestVersionNumber"
            case name = "Name"
            case themeId = "ThemeId"
        }
    }

    public struct ThemeVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
        public let baseThemeId: String?
        /// The theme configuration, which contains all the theme display properties.
        public let configuration: ThemeConfiguration?
        /// The date and time that this theme version was created.
        public let createdTime: Date?
        /// The description of the theme.
        public let description: String?
        /// Errors associated with the theme.
        public let errors: [ThemeError]?
        /// The status of the theme version.
        public let status: ResourceStatus?
        /// The version number of the theme.
        public let versionNumber: Int64?

        public init(arn: String? = nil, baseThemeId: String? = nil, configuration: ThemeConfiguration? = nil, createdTime: Date? = nil, description: String? = nil, errors: [ThemeError]? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.createdTime = createdTime
            self.description = description
            self.errors = errors
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case createdTime = "CreatedTime"
            case description = "Description"
            case errors = "Errors"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ThemeVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the theme version.
        public let arn: String?
        /// The date and time that this theme version was created.
        public let createdTime: Date?
        /// The description of the theme version.
        public let description: String?
        /// The status of the theme version.
        public let status: ResourceStatus?
        /// The version number of the theme version.
        public let versionNumber: Int64?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, status: ResourceStatus? = nil, versionNumber: Int64? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ThousandSeparatorOptions: AWSEncodableShape & AWSDecodableShape {
        /// Determines the thousands separator symbol.
        public let symbol: NumericSeparatorSymbol?
        /// Determines the visibility of the thousands separator.
        public let visibility: Visibility?

        public init(symbol: NumericSeparatorSymbol? = nil, visibility: Visibility? = nil) {
            self.symbol = symbol
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case symbol = "Symbol"
            case visibility = "Visibility"
        }
    }

    public struct TileLayoutStyle: AWSEncodableShape & AWSDecodableShape {
        /// The gutter settings that apply between tiles.
        public let gutter: GutterStyle?
        /// The margin settings that apply around the outside edge of sheets.
        public let margin: MarginStyle?

        public init(gutter: GutterStyle? = nil, margin: MarginStyle? = nil) {
            self.gutter = gutter
            self.margin = margin
        }

        private enum CodingKeys: String, CodingKey {
            case gutter = "Gutter"
            case margin = "Margin"
        }
    }

    public struct TileStyle: AWSEncodableShape & AWSDecodableShape {
        /// The border around a tile.
        public let border: BorderStyle?

        public init(border: BorderStyle? = nil) {
            self.border = border
        }

        private enum CodingKeys: String, CodingKey {
            case border = "Border"
        }
    }

    public struct TimeBasedForecastProperties: AWSEncodableShape & AWSDecodableShape {
        /// The lower boundary setup of a forecast computation.
        public let lowerBoundary: Double?
        /// The periods backward setup of a forecast computation.
        public let periodsBackward: Int?
        /// The periods forward setup of a forecast computation.
        public let periodsForward: Int?
        /// The prediction interval setup of a forecast computation.
        public let predictionInterval: Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:    NULL: The input is set to NULL.    NON_NULL: The input is set to a custom value.
        public let seasonality: Int?
        /// The upper boundary setup of a forecast computation.
        public let upperBoundary: Double?

        public init(lowerBoundary: Double? = nil, periodsBackward: Int? = nil, periodsForward: Int? = nil, predictionInterval: Int? = nil, seasonality: Int? = nil, upperBoundary: Double? = nil) {
            self.lowerBoundary = lowerBoundary
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.upperBoundary = upperBoundary
        }

        public func validate(name: String) throws {
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, max: 1000)
            try self.validate(self.periodsBackward, name: "periodsBackward", parent: name, min: 0)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, max: 1000)
            try self.validate(self.periodsForward, name: "periodsForward", parent: name, min: 1)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, max: 95)
            try self.validate(self.predictionInterval, name: "predictionInterval", parent: name, min: 50)
            try self.validate(self.seasonality, name: "seasonality", parent: name, max: 180)
            try self.validate(self.seasonality, name: "seasonality", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBoundary = "LowerBoundary"
            case periodsBackward = "PeriodsBackward"
            case periodsForward = "PeriodsForward"
            case predictionInterval = "PredictionInterval"
            case seasonality = "Seasonality"
            case upperBoundary = "UpperBoundary"
        }
    }

    public struct TimeEqualityFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to Value and RollingDate.
        public let parameterName: String?
        /// The rolling date input for the TimeEquality filter. This field is mutually exclusive to Value and ParameterName.
        public let rollingDate: RollingDateConfiguration?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?
        /// The value of a TimeEquality filter. This field is mutually exclusive to RollingDate and ParameterName.
        public let value: Date?

        public init(column: ColumnIdentifier, filterId: String, parameterName: String? = nil, rollingDate: RollingDateConfiguration? = nil, timeGranularity: TimeGranularity? = nil, value: Date? = nil) {
            self.column = column
            self.filterId = filterId
            self.parameterName = parameterName
            self.rollingDate = rollingDate
            self.timeGranularity = timeGranularity
            self.value = value
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.rollingDate?.validate(name: "\(name).rollingDate")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case filterId = "FilterId"
            case parameterName = "ParameterName"
            case rollingDate = "RollingDate"
            case timeGranularity = "TimeGranularity"
            case value = "Value"
        }
    }

    public struct TimeRangeDrillDownFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The maximum value for the filter value range.
        public let rangeMaximum: Date
        /// The minimum value for the filter value range.
        public let rangeMinimum: Date
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity

        public init(column: ColumnIdentifier, rangeMaximum: Date, rangeMinimum: Date, timeGranularity: TimeGranularity) {
            self.column = column
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case rangeMaximum = "RangeMaximum"
            case rangeMinimum = "RangeMinimum"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TimeRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// The exclude period of the time range filter.
        public let excludePeriodConfiguration: ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public let includeMaximum: Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public let includeMinimum: Bool?
        /// This option determines how null values should be treated when filtering data.    ALL_VALUES: Include null values in filtered results.    NULLS_ONLY: Only include null values in filtered results.    NON_NULLS_ONLY: Exclude null values from filtered results.
        public let nullOption: FilterNullOption
        /// The maximum value for the filter value range.
        public let rangeMaximumValue: TimeRangeFilterValue?
        /// The minimum value for the filter value range.
        public let rangeMinimumValue: TimeRangeFilterValue?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?

        public init(column: ColumnIdentifier, excludePeriodConfiguration: ExcludePeriodConfiguration? = nil, filterId: String, includeMaximum: Bool? = nil, includeMinimum: Bool? = nil, nullOption: FilterNullOption, rangeMaximumValue: TimeRangeFilterValue? = nil, rangeMinimumValue: TimeRangeFilterValue? = nil, timeGranularity: TimeGranularity? = nil) {
            self.column = column
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximumValue = rangeMaximumValue
            self.rangeMinimumValue = rangeMinimumValue
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.rangeMaximumValue?.validate(name: "\(name).rangeMaximumValue")
            try self.rangeMinimumValue?.validate(name: "\(name).rangeMinimumValue")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case excludePeriodConfiguration = "ExcludePeriodConfiguration"
            case filterId = "FilterId"
            case includeMaximum = "IncludeMaximum"
            case includeMinimum = "IncludeMinimum"
            case nullOption = "NullOption"
            case rangeMaximumValue = "RangeMaximumValue"
            case rangeMinimumValue = "RangeMinimumValue"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TimeRangeFilterValue: AWSEncodableShape & AWSDecodableShape {
        /// The parameter type input value.
        public let parameter: String?
        /// The rolling date input value.
        public let rollingDate: RollingDateConfiguration?
        /// The static input value.
        public let staticValue: Date?

        public init(parameter: String? = nil, rollingDate: RollingDateConfiguration? = nil, staticValue: Date? = nil) {
            self.parameter = parameter
            self.rollingDate = rollingDate
            self.staticValue = staticValue
        }

        public func validate(name: String) throws {
            try self.validate(self.parameter, name: "parameter", parent: name, max: 2048)
            try self.validate(self.parameter, name: "parameter", parent: name, min: 1)
            try self.validate(self.parameter, name: "parameter", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.rollingDate?.validate(name: "\(name).rollingDate")
        }

        private enum CodingKeys: String, CodingKey {
            case parameter = "Parameter"
            case rollingDate = "RollingDate"
            case staticValue = "StaticValue"
        }
    }

    public struct TooltipItem: AWSEncodableShape & AWSDecodableShape {
        /// The tooltip item for the columns that are not part of a field well.
        public let columnTooltipItem: ColumnTooltipItem?
        /// The tooltip item for the fields.
        public let fieldTooltipItem: FieldTooltipItem?

        public init(columnTooltipItem: ColumnTooltipItem? = nil, fieldTooltipItem: FieldTooltipItem? = nil) {
            self.columnTooltipItem = columnTooltipItem
            self.fieldTooltipItem = fieldTooltipItem
        }

        public func validate(name: String) throws {
            try self.columnTooltipItem?.validate(name: "\(name).columnTooltipItem")
            try self.fieldTooltipItem?.validate(name: "\(name).fieldTooltipItem")
        }

        private enum CodingKeys: String, CodingKey {
            case columnTooltipItem = "ColumnTooltipItem"
            case fieldTooltipItem = "FieldTooltipItem"
        }
    }

    public struct TooltipOptions: AWSEncodableShape & AWSDecodableShape {
        /// The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.
        public let fieldBasedTooltip: FieldBasedTooltip?
        /// The selected type for the tooltip. Choose one of the following options:    BASIC: A basic tooltip.    DETAILED: A detailed tooltip.
        public let selectedTooltipType: SelectedTooltipType?
        /// Determines whether or not the tooltip is visible.
        public let tooltipVisibility: Visibility?

        public init(fieldBasedTooltip: FieldBasedTooltip? = nil, selectedTooltipType: SelectedTooltipType? = nil, tooltipVisibility: Visibility? = nil) {
            self.fieldBasedTooltip = fieldBasedTooltip
            self.selectedTooltipType = selectedTooltipType
            self.tooltipVisibility = tooltipVisibility
        }

        public func validate(name: String) throws {
            try self.fieldBasedTooltip?.validate(name: "\(name).fieldBasedTooltip")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldBasedTooltip = "FieldBasedTooltip"
            case selectedTooltipType = "SelectedTooltipType"
            case tooltipVisibility = "TooltipVisibility"
        }
    }

    public struct TopBottomFilter: AWSEncodableShape & AWSDecodableShape {
        /// The aggregation and sort configuration of the top bottom filter.
        public let aggregationSortConfigurations: [AggregationSortConfiguration]
        /// The column that the filter is applied to.
        public let column: ColumnIdentifier
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        public let filterId: String
        /// The number of items to include in the top bottom filter results.
        public let limit: Int?
        /// The parameter whose value should be used for the filter value.
        public let parameterName: String?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TimeGranularity?

        public init(aggregationSortConfigurations: [AggregationSortConfiguration], column: ColumnIdentifier, filterId: String, limit: Int? = nil, parameterName: String? = nil, timeGranularity: TimeGranularity? = nil) {
            self.aggregationSortConfigurations = aggregationSortConfigurations
            self.column = column
            self.filterId = filterId
            self.limit = limit
            self.parameterName = parameterName
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.aggregationSortConfigurations.forEach {
                try $0.validate(name: "\(name).aggregationSortConfigurations[]")
            }
            try self.validate(self.aggregationSortConfigurations, name: "aggregationSortConfigurations", parent: name, max: 100)
            try self.column.validate(name: "\(name).column")
            try self.validate(self.filterId, name: "filterId", parent: name, max: 512)
            try self.validate(self.filterId, name: "filterId", parent: name, min: 1)
            try self.validate(self.filterId, name: "filterId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.parameterName, name: "parameterName", parent: name, max: 2048)
            try self.validate(self.parameterName, name: "parameterName", parent: name, min: 1)
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "^[a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationSortConfigurations = "AggregationSortConfigurations"
            case column = "Column"
            case filterId = "FilterId"
            case limit = "Limit"
            case parameterName = "ParameterName"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TopBottomMoversComputation: AWSEncodableShape & AWSDecodableShape {
        /// The category field that is used in a computation.
        public let category: DimensionField?
        /// The ID for a computation.
        public let computationId: String
        /// The mover size setup of the top and bottom movers computation.
        public let moverSize: Int?
        /// The name of a computation.
        public let name: String?
        /// The sort order setup of the top and bottom movers computation.
        public let sortOrder: TopBottomSortOrder?
        /// The time field that is used in a computation.
        public let time: DimensionField?
        /// The computation type. Choose from the following options:   TOP: Top movers computation.   BOTTOM: Bottom movers computation.
        public let type: TopBottomComputationType
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(category: DimensionField? = nil, computationId: String, moverSize: Int? = nil, name: String? = nil, sortOrder: TopBottomSortOrder? = nil, time: DimensionField? = nil, type: TopBottomComputationType, value: MeasureField? = nil) {
            self.category = category
            self.computationId = computationId
            self.moverSize = moverSize
            self.name = name
            self.sortOrder = sortOrder
            self.time = time
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.category?.validate(name: "\(name).category")
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.moverSize, name: "moverSize", parent: name, max: 20)
            try self.validate(self.moverSize, name: "moverSize", parent: name, min: 1)
            try self.time?.validate(name: "\(name).time")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case computationId = "ComputationId"
            case moverSize = "MoverSize"
            case name = "Name"
            case sortOrder = "SortOrder"
            case time = "Time"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct TopBottomRankedComputation: AWSEncodableShape & AWSDecodableShape {
        /// The category field that is used in a computation.
        public let category: DimensionField?
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The result size of a top and bottom ranked computation.
        public let resultSize: Int?
        /// The computation type. Choose one of the following options:   TOP: A top ranked computation.   BOTTOM: A bottom ranked computation.
        public let type: TopBottomComputationType
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(category: DimensionField? = nil, computationId: String, name: String? = nil, resultSize: Int? = nil, type: TopBottomComputationType, value: MeasureField? = nil) {
            self.category = category
            self.computationId = computationId
            self.name = name
            self.resultSize = resultSize
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.category?.validate(name: "\(name).category")
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.resultSize, name: "resultSize", parent: name, max: 20)
            try self.validate(self.resultSize, name: "resultSize", parent: name, min: 1)
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case computationId = "ComputationId"
            case name = "Name"
            case resultSize = "ResultSize"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct TopicCalculatedField: AWSEncodableShape & AWSDecodableShape {
        /// The default aggregation. Valid values for this structure are SUM, MAX, MIN, COUNT, DISTINCT_COUNT, and AVERAGE.
        public let aggregation: DefaultAggregation?
        /// The list of aggregation types that are allowed for the calculated field. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public let allowedAggregations: [AuthorSpecifiedAggregation]?
        /// The calculated field description.
        public let calculatedFieldDescription: String?
        /// The calculated field name.
        public let calculatedFieldName: String
        /// The other names or aliases for the calculated field.
        public let calculatedFieldSynonyms: [String]?
        /// The other names or aliases for the calculated field cell value.
        public let cellValueSynonyms: [CellValueSynonym]?
        /// The column data role for a calculated field. Valid values for this structure are DIMENSION and MEASURE.
        public let columnDataRole: ColumnDataRole?
        /// The order in which data is displayed for the calculated field when it's used in a comparative context.
        public let comparativeOrder: ComparativeOrder?
        /// The default formatting definition.
        public let defaultFormatting: DefaultFormatting?
        /// A Boolean value that indicates if a calculated field is visible in the autocomplete.
        public let disableIndexing: Bool?
        /// The calculated field expression.
        public let expression: String
        /// A boolean value that indicates if a calculated field is included in the topic.
        public let isIncludedInTopic: Bool?
        /// A Boolean value that indicates whether to never aggregate calculated field in filters.
        public let neverAggregateInFilter: Bool?
        /// The non additive for the table style target.
        public let nonAdditive: Bool?
        /// The list of aggregation types that are not allowed for the calculated field. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public let notAllowedAggregations: [AuthorSpecifiedAggregation]?
        /// The semantic type.
        public let semanticType: SemanticType?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TopicTimeGranularity?

        public init(aggregation: DefaultAggregation? = nil, allowedAggregations: [AuthorSpecifiedAggregation]? = nil, calculatedFieldDescription: String? = nil, calculatedFieldName: String, calculatedFieldSynonyms: [String]? = nil, cellValueSynonyms: [CellValueSynonym]? = nil, columnDataRole: ColumnDataRole? = nil, comparativeOrder: ComparativeOrder? = nil, defaultFormatting: DefaultFormatting? = nil, disableIndexing: Bool? = nil, expression: String, isIncludedInTopic: Bool? = nil, neverAggregateInFilter: Bool? = nil, nonAdditive: Bool? = nil, notAllowedAggregations: [AuthorSpecifiedAggregation]? = nil, semanticType: SemanticType? = nil, timeGranularity: TopicTimeGranularity? = nil) {
            self.aggregation = aggregation
            self.allowedAggregations = allowedAggregations
            self.calculatedFieldDescription = calculatedFieldDescription
            self.calculatedFieldName = calculatedFieldName
            self.calculatedFieldSynonyms = calculatedFieldSynonyms
            self.cellValueSynonyms = cellValueSynonyms
            self.columnDataRole = columnDataRole
            self.comparativeOrder = comparativeOrder
            self.defaultFormatting = defaultFormatting
            self.disableIndexing = disableIndexing
            self.expression = expression
            self.isIncludedInTopic = isIncludedInTopic
            self.neverAggregateInFilter = neverAggregateInFilter
            self.nonAdditive = nonAdditive
            self.notAllowedAggregations = notAllowedAggregations
            self.semanticType = semanticType
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.validate(self.calculatedFieldDescription, name: "calculatedFieldDescription", parent: name, max: 256)
            try self.validate(self.calculatedFieldName, name: "calculatedFieldName", parent: name, max: 256)
            try self.calculatedFieldSynonyms?.forEach {
                try validate($0, name: "calculatedFieldSynonyms[]", parent: name, max: 256)
            }
            try self.cellValueSynonyms?.forEach {
                try $0.validate(name: "\(name).cellValueSynonyms[]")
            }
            try self.defaultFormatting?.validate(name: "\(name).defaultFormatting")
            try self.validate(self.expression, name: "expression", parent: name, max: 4096)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.semanticType?.validate(name: "\(name).semanticType")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "Aggregation"
            case allowedAggregations = "AllowedAggregations"
            case calculatedFieldDescription = "CalculatedFieldDescription"
            case calculatedFieldName = "CalculatedFieldName"
            case calculatedFieldSynonyms = "CalculatedFieldSynonyms"
            case cellValueSynonyms = "CellValueSynonyms"
            case columnDataRole = "ColumnDataRole"
            case comparativeOrder = "ComparativeOrder"
            case defaultFormatting = "DefaultFormatting"
            case disableIndexing = "DisableIndexing"
            case expression = "Expression"
            case isIncludedInTopic = "IsIncludedInTopic"
            case neverAggregateInFilter = "NeverAggregateInFilter"
            case nonAdditive = "NonAdditive"
            case notAllowedAggregations = "NotAllowedAggregations"
            case semanticType = "SemanticType"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TopicCategoryFilter: AWSEncodableShape & AWSDecodableShape {
        /// The category filter function. Valid values for this structure are EXACT and CONTAINS.
        public let categoryFilterFunction: CategoryFilterFunction?
        /// The category filter type. This element is used to specify whether a filter is a simple category filter or an inverse category filter.
        public let categoryFilterType: CategoryFilterType?
        /// The constant used in a category filter.
        public let constant: TopicCategoryFilterConstant?
        /// A Boolean value that indicates if the filter is inverse.
        public let inverse: Bool?

        public init(categoryFilterFunction: CategoryFilterFunction? = nil, categoryFilterType: CategoryFilterType? = nil, constant: TopicCategoryFilterConstant? = nil, inverse: Bool? = nil) {
            self.categoryFilterFunction = categoryFilterFunction
            self.categoryFilterType = categoryFilterType
            self.constant = constant
            self.inverse = inverse
        }

        public func validate(name: String) throws {
            try self.constant?.validate(name: "\(name).constant")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryFilterFunction = "CategoryFilterFunction"
            case categoryFilterType = "CategoryFilterType"
            case constant = "Constant"
            case inverse = "Inverse"
        }
    }

    public struct TopicCategoryFilterConstant: AWSEncodableShape & AWSDecodableShape {
        /// A collective constant used in a category filter. This element is used to specify a list of values for the constant.
        public let collectiveConstant: CollectiveConstant?
        /// The type of category filter constant. This element is used to specify whether a constant is a singular or collective. Valid values are SINGULAR and COLLECTIVE.
        public let constantType: ConstantType?
        /// A singular constant used in a category filter. This element is used to specify a single value for the constant.
        public let singularConstant: String?

        public init(collectiveConstant: CollectiveConstant? = nil, constantType: ConstantType? = nil, singularConstant: String? = nil) {
            self.collectiveConstant = collectiveConstant
            self.constantType = constantType
            self.singularConstant = singularConstant
        }

        public func validate(name: String) throws {
            try self.validate(self.singularConstant, name: "singularConstant", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case collectiveConstant = "CollectiveConstant"
            case constantType = "ConstantType"
            case singularConstant = "SingularConstant"
        }
    }

    public struct TopicColumn: AWSEncodableShape & AWSDecodableShape {
        /// The type of aggregation that is performed on the column data when it's queried.
        public let aggregation: DefaultAggregation?
        /// The list of aggregation types that are allowed for the column. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public let allowedAggregations: [AuthorSpecifiedAggregation]?
        /// The other names or aliases for the column cell value.
        public let cellValueSynonyms: [CellValueSynonym]?
        /// The role of the column in the data. Valid values are DIMENSION and MEASURE.
        public let columnDataRole: ColumnDataRole?
        /// A description of the column and its contents.
        public let columnDescription: String?
        /// A user-friendly name for the column.
        public let columnFriendlyName: String?
        /// The name of the column.
        public let columnName: String
        /// The other names or aliases for the column.
        public let columnSynonyms: [String]?
        /// The order in which data is displayed for the column when it's used in a comparative context.
        public let comparativeOrder: ComparativeOrder?
        /// The default formatting used for values in the column.
        public let defaultFormatting: DefaultFormatting?
        /// A Boolean value that indicates whether the column shows in the autocomplete functionality.
        public let disableIndexing: Bool?
        /// A Boolean value that indicates whether the column is included in the query results.
        public let isIncludedInTopic: Bool?
        /// A Boolean value that indicates whether to aggregate the column data when it's used in a filter context.
        public let neverAggregateInFilter: Bool?
        /// The non additive value for the column.
        public let nonAdditive: Bool?
        /// The list of aggregation types that are not allowed for the column. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public let notAllowedAggregations: [AuthorSpecifiedAggregation]?
        /// The semantic type of data contained in the column.
        public let semanticType: SemanticType?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TopicTimeGranularity?

        public init(aggregation: DefaultAggregation? = nil, allowedAggregations: [AuthorSpecifiedAggregation]? = nil, cellValueSynonyms: [CellValueSynonym]? = nil, columnDataRole: ColumnDataRole? = nil, columnDescription: String? = nil, columnFriendlyName: String? = nil, columnName: String, columnSynonyms: [String]? = nil, comparativeOrder: ComparativeOrder? = nil, defaultFormatting: DefaultFormatting? = nil, disableIndexing: Bool? = nil, isIncludedInTopic: Bool? = nil, neverAggregateInFilter: Bool? = nil, nonAdditive: Bool? = nil, notAllowedAggregations: [AuthorSpecifiedAggregation]? = nil, semanticType: SemanticType? = nil, timeGranularity: TopicTimeGranularity? = nil) {
            self.aggregation = aggregation
            self.allowedAggregations = allowedAggregations
            self.cellValueSynonyms = cellValueSynonyms
            self.columnDataRole = columnDataRole
            self.columnDescription = columnDescription
            self.columnFriendlyName = columnFriendlyName
            self.columnName = columnName
            self.columnSynonyms = columnSynonyms
            self.comparativeOrder = comparativeOrder
            self.defaultFormatting = defaultFormatting
            self.disableIndexing = disableIndexing
            self.isIncludedInTopic = isIncludedInTopic
            self.neverAggregateInFilter = neverAggregateInFilter
            self.nonAdditive = nonAdditive
            self.notAllowedAggregations = notAllowedAggregations
            self.semanticType = semanticType
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.cellValueSynonyms?.forEach {
                try $0.validate(name: "\(name).cellValueSynonyms[]")
            }
            try self.validate(self.columnDescription, name: "columnDescription", parent: name, max: 256)
            try self.validate(self.columnFriendlyName, name: "columnFriendlyName", parent: name, max: 256)
            try self.validate(self.columnName, name: "columnName", parent: name, max: 256)
            try self.columnSynonyms?.forEach {
                try validate($0, name: "columnSynonyms[]", parent: name, max: 256)
            }
            try self.defaultFormatting?.validate(name: "\(name).defaultFormatting")
            try self.semanticType?.validate(name: "\(name).semanticType")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "Aggregation"
            case allowedAggregations = "AllowedAggregations"
            case cellValueSynonyms = "CellValueSynonyms"
            case columnDataRole = "ColumnDataRole"
            case columnDescription = "ColumnDescription"
            case columnFriendlyName = "ColumnFriendlyName"
            case columnName = "ColumnName"
            case columnSynonyms = "ColumnSynonyms"
            case comparativeOrder = "ComparativeOrder"
            case defaultFormatting = "DefaultFormatting"
            case disableIndexing = "DisableIndexing"
            case isIncludedInTopic = "IsIncludedInTopic"
            case neverAggregateInFilter = "NeverAggregateInFilter"
            case nonAdditive = "NonAdditive"
            case notAllowedAggregations = "NotAllowedAggregations"
            case semanticType = "SemanticType"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TopicDateRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// The constant used in a date range filter.
        public let constant: TopicRangeFilterConstant?
        /// A Boolean value that indicates whether the date range filter should include the boundary values. If set to true, the filter includes the start and end dates. If set to false, the filter excludes them.
        public let inclusive: Bool?

        public init(constant: TopicRangeFilterConstant? = nil, inclusive: Bool? = nil) {
            self.constant = constant
            self.inclusive = inclusive
        }

        public func validate(name: String) throws {
            try self.constant?.validate(name: "\(name).constant")
        }

        private enum CodingKeys: String, CodingKey {
            case constant = "Constant"
            case inclusive = "Inclusive"
        }
    }

    public struct TopicDetails: AWSEncodableShape & AWSDecodableShape {
        /// The data sets that the topic is associated with.
        public let dataSets: [DatasetMetadata]?
        /// The description of the topic.
        public let description: String?
        /// The name of the topic.
        public let name: String?
        /// The user experience version of a topic.
        public let userExperienceVersion: TopicUserExperienceVersion?

        public init(dataSets: [DatasetMetadata]? = nil, description: String? = nil, name: String? = nil, userExperienceVersion: TopicUserExperienceVersion? = nil) {
            self.dataSets = dataSets
            self.description = description
            self.name = name
            self.userExperienceVersion = userExperienceVersion
        }

        public func validate(name: String) throws {
            try self.dataSets?.forEach {
                try $0.validate(name: "\(name).dataSets[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSets = "DataSets"
            case description = "Description"
            case name = "Name"
            case userExperienceVersion = "UserExperienceVersion"
        }
    }

    public struct TopicFilter: AWSEncodableShape & AWSDecodableShape {
        /// The category filter that is associated with this filter.
        public let categoryFilter: TopicCategoryFilter?
        /// The date range filter.
        public let dateRangeFilter: TopicDateRangeFilter?
        /// The class of the filter. Valid values for this structure are ENFORCED_VALUE_FILTER, CONDITIONAL_VALUE_FILTER, and NAMED_VALUE_FILTER.
        public let filterClass: FilterClass?
        /// A description of the filter used to select items for a topic.
        public let filterDescription: String?
        /// The name of the filter.
        public let filterName: String
        /// The other names or aliases for the filter.
        public let filterSynonyms: [String]?
        /// The type of the filter. Valid values for this structure are CATEGORY_FILTER, NUMERIC_EQUALITY_FILTER, NUMERIC_RANGE_FILTER, DATE_RANGE_FILTER, and RELATIVE_DATE_FILTER.
        public let filterType: NamedFilterType?
        /// The numeric equality filter.
        public let numericEqualityFilter: TopicNumericEqualityFilter?
        /// The numeric range filter.
        public let numericRangeFilter: TopicNumericRangeFilter?
        /// The name of the field that the filter operates on.
        public let operandFieldName: String
        /// The relative date filter.
        public let relativeDateFilter: TopicRelativeDateFilter?

        public init(categoryFilter: TopicCategoryFilter? = nil, dateRangeFilter: TopicDateRangeFilter? = nil, filterClass: FilterClass? = nil, filterDescription: String? = nil, filterName: String, filterSynonyms: [String]? = nil, filterType: NamedFilterType? = nil, numericEqualityFilter: TopicNumericEqualityFilter? = nil, numericRangeFilter: TopicNumericRangeFilter? = nil, operandFieldName: String, relativeDateFilter: TopicRelativeDateFilter? = nil) {
            self.categoryFilter = categoryFilter
            self.dateRangeFilter = dateRangeFilter
            self.filterClass = filterClass
            self.filterDescription = filterDescription
            self.filterName = filterName
            self.filterSynonyms = filterSynonyms
            self.filterType = filterType
            self.numericEqualityFilter = numericEqualityFilter
            self.numericRangeFilter = numericRangeFilter
            self.operandFieldName = operandFieldName
            self.relativeDateFilter = relativeDateFilter
        }

        public func validate(name: String) throws {
            try self.categoryFilter?.validate(name: "\(name).categoryFilter")
            try self.dateRangeFilter?.validate(name: "\(name).dateRangeFilter")
            try self.validate(self.filterDescription, name: "filterDescription", parent: name, max: 256)
            try self.validate(self.filterName, name: "filterName", parent: name, max: 256)
            try self.filterSynonyms?.forEach {
                try validate($0, name: "filterSynonyms[]", parent: name, max: 256)
            }
            try self.numericEqualityFilter?.validate(name: "\(name).numericEqualityFilter")
            try self.numericRangeFilter?.validate(name: "\(name).numericRangeFilter")
            try self.validate(self.operandFieldName, name: "operandFieldName", parent: name, max: 256)
            try self.relativeDateFilter?.validate(name: "\(name).relativeDateFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryFilter = "CategoryFilter"
            case dateRangeFilter = "DateRangeFilter"
            case filterClass = "FilterClass"
            case filterDescription = "FilterDescription"
            case filterName = "FilterName"
            case filterSynonyms = "FilterSynonyms"
            case filterType = "FilterType"
            case numericEqualityFilter = "NumericEqualityFilter"
            case numericRangeFilter = "NumericRangeFilter"
            case operandFieldName = "OperandFieldName"
            case relativeDateFilter = "RelativeDateFilter"
        }
    }

    public struct TopicNamedEntity: AWSEncodableShape & AWSDecodableShape {
        /// The definition of a named entity.
        public let definition: [NamedEntityDefinition]?
        /// The description of the named entity.
        public let entityDescription: String?
        /// The name of the named entity.
        public let entityName: String
        /// The other names or aliases for the named entity.
        public let entitySynonyms: [String]?
        /// The type of named entity that a topic represents.
        public let semanticEntityType: SemanticEntityType?

        public init(definition: [NamedEntityDefinition]? = nil, entityDescription: String? = nil, entityName: String, entitySynonyms: [String]? = nil, semanticEntityType: SemanticEntityType? = nil) {
            self.definition = definition
            self.entityDescription = entityDescription
            self.entityName = entityName
            self.entitySynonyms = entitySynonyms
            self.semanticEntityType = semanticEntityType
        }

        public func validate(name: String) throws {
            try self.definition?.forEach {
                try $0.validate(name: "\(name).definition[]")
            }
            try self.validate(self.entityDescription, name: "entityDescription", parent: name, max: 256)
            try self.validate(self.entityName, name: "entityName", parent: name, max: 256)
            try self.entitySynonyms?.forEach {
                try validate($0, name: "entitySynonyms[]", parent: name, max: 256)
            }
            try self.semanticEntityType?.validate(name: "\(name).semanticEntityType")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case entityDescription = "EntityDescription"
            case entityName = "EntityName"
            case entitySynonyms = "EntitySynonyms"
            case semanticEntityType = "SemanticEntityType"
        }
    }

    public struct TopicNumericEqualityFilter: AWSEncodableShape & AWSDecodableShape {
        /// An aggregation function that specifies how to calculate the value of a numeric field for a topic. Valid values for this structure are NO_AGGREGATION, SUM, AVERAGE, COUNT, DISTINCT_COUNT, MAX, MEDIAN, MIN, STDEV, STDEVP, VAR, and VARP.
        public let aggregation: NamedFilterAggType?
        /// The constant used in a numeric equality filter.
        public let constant: TopicSingularFilterConstant?

        public init(aggregation: NamedFilterAggType? = nil, constant: TopicSingularFilterConstant? = nil) {
            self.aggregation = aggregation
            self.constant = constant
        }

        public func validate(name: String) throws {
            try self.constant?.validate(name: "\(name).constant")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "Aggregation"
            case constant = "Constant"
        }
    }

    public struct TopicNumericRangeFilter: AWSEncodableShape & AWSDecodableShape {
        /// An aggregation function that specifies how to calculate the value of a numeric field for a topic, Valid values for this structure are NO_AGGREGATION, SUM, AVERAGE, COUNT, DISTINCT_COUNT, MAX, MEDIAN, MIN, STDEV, STDEVP, VAR, and VARP.
        public let aggregation: NamedFilterAggType?
        /// The constant used in a numeric range filter.
        public let constant: TopicRangeFilterConstant?
        /// A Boolean value that indicates whether the endpoints of the numeric range are included in the filter. If set to true, topics whose numeric field value is equal to the endpoint values will be included in the filter. If set to false, topics whose numeric field value is equal to the endpoint values will be excluded from the filter.
        public let inclusive: Bool?

        public init(aggregation: NamedFilterAggType? = nil, constant: TopicRangeFilterConstant? = nil, inclusive: Bool? = nil) {
            self.aggregation = aggregation
            self.constant = constant
            self.inclusive = inclusive
        }

        public func validate(name: String) throws {
            try self.constant?.validate(name: "\(name).constant")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "Aggregation"
            case constant = "Constant"
            case inclusive = "Inclusive"
        }
    }

    public struct TopicRangeFilterConstant: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the constant value that is used in a range filter. Valid values for this structure are RANGE.
        public let constantType: ConstantType?
        /// The value of the constant that is used to specify the endpoints of a range filter.
        public let rangeConstant: RangeConstant?

        public init(constantType: ConstantType? = nil, rangeConstant: RangeConstant? = nil) {
            self.constantType = constantType
            self.rangeConstant = rangeConstant
        }

        public func validate(name: String) throws {
            try self.rangeConstant?.validate(name: "\(name).rangeConstant")
        }

        private enum CodingKeys: String, CodingKey {
            case constantType = "ConstantType"
            case rangeConstant = "RangeConstant"
        }
    }

    public struct TopicRefreshDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the topic refresh.
        public let refreshArn: String?
        /// The ID of the refresh, which occurs as a result of topic creation or topic update.
        public let refreshId: String?
        /// The status of the refresh job that indicates whether the job is still running, completed successfully, or failed.
        public let refreshStatus: TopicRefreshStatus?

        public init(refreshArn: String? = nil, refreshId: String? = nil, refreshStatus: TopicRefreshStatus? = nil) {
            self.refreshArn = refreshArn
            self.refreshId = refreshId
            self.refreshStatus = refreshStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshArn = "RefreshArn"
            case refreshId = "RefreshId"
            case refreshStatus = "RefreshStatus"
        }
    }

    public struct TopicRefreshSchedule: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean value that controls whether to schedule runs at the same schedule that is specified in SPICE dataset.
        public let basedOnSpiceSchedule: Bool
        /// A Boolean value that controls whether to schedule is enabled.
        public let isEnabled: Bool
        /// The time of day when the refresh should run, for example, Monday-Sunday.
        public let repeatAt: String?
        /// The starting date and time for the refresh schedule.
        public let startingAt: Date?
        /// The timezone that you want the refresh schedule to use.
        public let timezone: String?
        /// The type of refresh schedule. Valid values for this structure are HOURLY, DAILY, WEEKLY, and MONTHLY.
        public let topicScheduleType: TopicScheduleType?

        public init(basedOnSpiceSchedule: Bool, isEnabled: Bool, repeatAt: String? = nil, startingAt: Date? = nil, timezone: String? = nil, topicScheduleType: TopicScheduleType? = nil) {
            self.basedOnSpiceSchedule = basedOnSpiceSchedule
            self.isEnabled = isEnabled
            self.repeatAt = repeatAt
            self.startingAt = startingAt
            self.timezone = timezone
            self.topicScheduleType = topicScheduleType
        }

        public func validate(name: String) throws {
            try self.validate(self.repeatAt, name: "repeatAt", parent: name, max: 256)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case basedOnSpiceSchedule = "BasedOnSpiceSchedule"
            case isEnabled = "IsEnabled"
            case repeatAt = "RepeatAt"
            case startingAt = "StartingAt"
            case timezone = "Timezone"
            case topicScheduleType = "TopicScheduleType"
        }
    }

    public struct TopicRefreshScheduleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The ID of the dataset.
        public let datasetId: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The definition of a refresh schedule.
        public let refreshSchedule: TopicRefreshSchedule?

        public init(datasetArn: String? = nil, datasetId: String? = nil, datasetName: String? = nil, refreshSchedule: TopicRefreshSchedule? = nil) {
            self.datasetArn = datasetArn
            self.datasetId = datasetId
            self.datasetName = datasetName
            self.refreshSchedule = refreshSchedule
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case datasetId = "DatasetId"
            case datasetName = "DatasetName"
            case refreshSchedule = "RefreshSchedule"
        }
    }

    public struct TopicRelativeDateFilter: AWSEncodableShape & AWSDecodableShape {
        /// The constant used in a relative date filter.
        public let constant: TopicSingularFilterConstant?
        /// The function to be used in a relative date filter to determine the range of dates to include in the results. Valid values for this structure are BEFORE, AFTER, and BETWEEN.
        public let relativeDateFilterFunction: TopicRelativeDateFilterFunction?
        /// The level of time precision that is used to aggregate DateTime values.
        public let timeGranularity: TopicTimeGranularity?

        public init(constant: TopicSingularFilterConstant? = nil, relativeDateFilterFunction: TopicRelativeDateFilterFunction? = nil, timeGranularity: TopicTimeGranularity? = nil) {
            self.constant = constant
            self.relativeDateFilterFunction = relativeDateFilterFunction
            self.timeGranularity = timeGranularity
        }

        public func validate(name: String) throws {
            try self.constant?.validate(name: "\(name).constant")
        }

        private enum CodingKeys: String, CodingKey {
            case constant = "Constant"
            case relativeDateFilterFunction = "RelativeDateFilterFunction"
            case timeGranularity = "TimeGranularity"
        }
    }

    public struct TopicSingularFilterConstant: AWSEncodableShape & AWSDecodableShape {
        /// The type of the singular filter constant. Valid values for this structure are SINGULAR.
        public let constantType: ConstantType?
        /// The value of the singular filter constant.
        public let singularConstant: String?

        public init(constantType: ConstantType? = nil, singularConstant: String? = nil) {
            self.constantType = constantType
            self.singularConstant = singularConstant
        }

        public func validate(name: String) throws {
            try self.validate(self.singularConstant, name: "singularConstant", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case constantType = "ConstantType"
            case singularConstant = "SingularConstant"
        }
    }

    public struct TopicSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the topic.
        public let arn: String?
        /// The name of the topic.
        public let name: String?
        /// The ID for the topic. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(arn: String? = nil, name: String? = nil, topicId: String? = nil) {
            self.arn = arn
            self.name = name
            self.topicId = topicId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case topicId = "TopicId"
        }
    }

    public struct TotalAggregationComputation: AWSEncodableShape & AWSDecodableShape {
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?
        /// The value field that is used in a computation.
        public let value: MeasureField?

        public init(computationId: String, name: String? = nil, value: MeasureField? = nil) {
            self.computationId = computationId
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case computationId = "ComputationId"
            case name = "Name"
            case value = "Value"
        }
    }

    public struct TotalAggregationFunction: AWSEncodableShape & AWSDecodableShape {
        /// A built in aggregation function for total values.
        public let simpleTotalAggregationFunction: SimpleTotalAggregationFunction?

        public init(simpleTotalAggregationFunction: SimpleTotalAggregationFunction? = nil) {
            self.simpleTotalAggregationFunction = simpleTotalAggregationFunction
        }

        private enum CodingKeys: String, CodingKey {
            case simpleTotalAggregationFunction = "SimpleTotalAggregationFunction"
        }
    }

    public struct TotalAggregationOption: AWSEncodableShape & AWSDecodableShape {
        /// The field id that's associated with the total aggregation option.
        public let fieldId: String
        /// The total aggregation function that you want to set for a specified field id.
        public let totalAggregationFunction: TotalAggregationFunction

        public init(fieldId: String, totalAggregationFunction: TotalAggregationFunction) {
            self.fieldId = fieldId
            self.totalAggregationFunction = totalAggregationFunction
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "FieldId"
            case totalAggregationFunction = "TotalAggregationFunction"
        }
    }

    public struct TotalOptions: AWSEncodableShape & AWSDecodableShape {
        /// The custom label string for the total cells.
        public let customLabel: String?
        /// The placement (start, end) for the total cells.
        public let placement: TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public let scrollStatus: TableTotalsScrollStatus?
        /// The total aggregation settings for each value field.
        public let totalAggregationOptions: [TotalAggregationOption]?
        /// Cell styling options for the total cells.
        public let totalCellStyle: TableCellStyle?
        /// The visibility configuration for the total cells.
        public let totalsVisibility: Visibility?

        public init(customLabel: String? = nil, placement: TableTotalsPlacement? = nil, scrollStatus: TableTotalsScrollStatus? = nil, totalAggregationOptions: [TotalAggregationOption]? = nil, totalCellStyle: TableCellStyle? = nil, totalsVisibility: Visibility? = nil) {
            self.customLabel = customLabel
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalAggregationOptions = totalAggregationOptions
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
        }

        public func validate(name: String) throws {
            try self.totalAggregationOptions?.forEach {
                try $0.validate(name: "\(name).totalAggregationOptions[]")
            }
            try self.validate(self.totalAggregationOptions, name: "totalAggregationOptions", parent: name, max: 200)
            try self.totalCellStyle?.validate(name: "\(name).totalCellStyle")
        }

        private enum CodingKeys: String, CodingKey {
            case customLabel = "CustomLabel"
            case placement = "Placement"
            case scrollStatus = "ScrollStatus"
            case totalAggregationOptions = "TotalAggregationOptions"
            case totalCellStyle = "TotalCellStyle"
            case totalsVisibility = "TotalsVisibility"
        }
    }

    public struct TreeMapAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The color field well of a tree map. Values are grouped by aggregations based on group by fields.
        public let colors: [MeasureField]?
        /// The group by field well of a tree map. Values are grouped based on group by fields.
        public let groups: [DimensionField]?
        /// The size field well of a tree map. Values are aggregated based on group by fields.
        public let sizes: [MeasureField]?

        public init(colors: [MeasureField]? = nil, groups: [DimensionField]? = nil, sizes: [MeasureField]? = nil) {
            self.colors = colors
            self.groups = groups
            self.sizes = sizes
        }

        public func validate(name: String) throws {
            try self.colors?.forEach {
                try $0.validate(name: "\(name).colors[]")
            }
            try self.validate(self.colors, name: "colors", parent: name, max: 1)
            try self.groups?.forEach {
                try $0.validate(name: "\(name).groups[]")
            }
            try self.validate(self.groups, name: "groups", parent: name, max: 1)
            try self.sizes?.forEach {
                try $0.validate(name: "\(name).sizes[]")
            }
            try self.validate(self.sizes, name: "sizes", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case colors = "Colors"
            case groups = "Groups"
            case sizes = "Sizes"
        }
    }

    public struct TreeMapConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options (label text, label visibility) for the colors displayed in a tree map.
        public let colorLabelOptions: ChartAxisLabelOptions?
        /// The color options (gradient color, point of divergence) of a tree map.
        public let colorScale: ColorScale?
        /// The options that determine if visual data labels are displayed.
        public let dataLabels: DataLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: TreeMapFieldWells?
        /// The label options (label text, label visibility) of the groups that are displayed in a tree map.
        public let groupLabelOptions: ChartAxisLabelOptions?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend display setup of the visual.
        public let legend: LegendOptions?
        /// The label options (label text, label visibility) of the sizes that are displayed in a tree map.
        public let sizeLabelOptions: ChartAxisLabelOptions?
        /// The sort configuration of a tree map.
        public let sortConfiguration: TreeMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public let tooltip: TooltipOptions?

        public init(colorLabelOptions: ChartAxisLabelOptions? = nil, colorScale: ColorScale? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: TreeMapFieldWells? = nil, groupLabelOptions: ChartAxisLabelOptions? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, sizeLabelOptions: ChartAxisLabelOptions? = nil, sortConfiguration: TreeMapSortConfiguration? = nil, tooltip: TooltipOptions? = nil) {
            self.colorLabelOptions = colorLabelOptions
            self.colorScale = colorScale
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.groupLabelOptions = groupLabelOptions
            self.interactions = interactions
            self.legend = legend
            self.sizeLabelOptions = sizeLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }

        public func validate(name: String) throws {
            try self.colorLabelOptions?.validate(name: "\(name).colorLabelOptions")
            try self.colorScale?.validate(name: "\(name).colorScale")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.groupLabelOptions?.validate(name: "\(name).groupLabelOptions")
            try self.legend?.validate(name: "\(name).legend")
            try self.sizeLabelOptions?.validate(name: "\(name).sizeLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.tooltip?.validate(name: "\(name).tooltip")
        }

        private enum CodingKeys: String, CodingKey {
            case colorLabelOptions = "ColorLabelOptions"
            case colorScale = "ColorScale"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case groupLabelOptions = "GroupLabelOptions"
            case interactions = "Interactions"
            case legend = "Legend"
            case sizeLabelOptions = "SizeLabelOptions"
            case sortConfiguration = "SortConfiguration"
            case tooltip = "Tooltip"
        }
    }

    public struct TreeMapFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a tree map.
        public let treeMapAggregatedFieldWells: TreeMapAggregatedFieldWells?

        public init(treeMapAggregatedFieldWells: TreeMapAggregatedFieldWells? = nil) {
            self.treeMapAggregatedFieldWells = treeMapAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.treeMapAggregatedFieldWells?.validate(name: "\(name).treeMapAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case treeMapAggregatedFieldWells = "TreeMapAggregatedFieldWells"
        }
    }

    public struct TreeMapSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of groups that are displayed.
        public let treeMapGroupItemsLimitConfiguration: ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public let treeMapSort: [FieldSortOptions]?

        public init(treeMapGroupItemsLimitConfiguration: ItemsLimitConfiguration? = nil, treeMapSort: [FieldSortOptions]? = nil) {
            self.treeMapGroupItemsLimitConfiguration = treeMapGroupItemsLimitConfiguration
            self.treeMapSort = treeMapSort
        }

        public func validate(name: String) throws {
            try self.treeMapSort?.forEach {
                try $0.validate(name: "\(name).treeMapSort[]")
            }
            try self.validate(self.treeMapSort, name: "treeMapSort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case treeMapGroupItemsLimitConfiguration = "TreeMapGroupItemsLimitConfiguration"
            case treeMapSort = "TreeMapSort"
        }
    }

    public struct TreeMapVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: TreeMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: TreeMapConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct TrendArrowOptions: AWSEncodableShape & AWSDecodableShape {
        /// The visibility of the trend arrows.
        public let visibility: Visibility?

        public init(visibility: Visibility? = nil) {
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case visibility = "Visibility"
        }
    }

    public struct TrinoParameters: AWSEncodableShape & AWSDecodableShape {
        /// The catalog name for the Trino data source.
        public let catalog: String
        /// The host name of the Trino data source.
        public let host: String
        /// The port for the Trino data source.
        public let port: Int

        public init(catalog: String, host: String, port: Int) {
            self.catalog = catalog
            self.host = host
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 128)
            try self.validate(self.host, name: "host", parent: name, max: 256)
            try self.validate(self.host, name: "host", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case host = "Host"
            case port = "Port"
        }
    }

    public struct TwitterParameters: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of rows to query Twitter.
        public let maxRows: Int
        /// Twitter query string.
        public let query: String

        public init(maxRows: Int, query: String) {
            self.maxRows = maxRows
            self.query = query
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRows, name: "maxRows", parent: name, min: 1)
            try self.validate(self.query, name: "query", parent: name, max: 256)
            try self.validate(self.query, name: "query", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRows = "MaxRows"
            case query = "Query"
        }
    }

    public struct Typography: AWSEncodableShape & AWSDecodableShape {
        /// Determines the list of font families.
        public let fontFamilies: [Font]?

        public init(fontFamilies: [Font]? = nil) {
            self.fontFamilies = fontFamilies
        }

        public func validate(name: String) throws {
            try self.validate(self.fontFamilies, name: "fontFamilies", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case fontFamilies = "FontFamilies"
        }
    }

    public struct UIColorPalette: AWSEncodableShape & AWSDecodableShape {
        /// This color is that applies to selected states and buttons.
        public let accent: String?
        /// The foreground color that applies to any text or other elements that appear over the accent color.
        public let accentForeground: String?
        /// The color that applies to error messages.
        public let danger: String?
        /// The foreground color that applies to any text or other elements that appear over the error color.
        public let dangerForeground: String?
        /// The color that applies to the names of fields that are identified as dimensions.
        public let dimension: String?
        /// The foreground color that applies to any text or other elements that appear over the dimension color.
        public let dimensionForeground: String?
        /// The color that applies to the names of fields that are identified as measures.
        public let measure: String?
        /// The foreground color that applies to any text or other elements that appear over the measure color.
        public let measureForeground: String?
        /// The background color that applies to visuals and other high emphasis UI.
        public let primaryBackground: String?
        /// The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        public let primaryForeground: String?
        /// The background color that applies to the sheet background and sheet controls.
        public let secondaryBackground: String?
        /// The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        public let secondaryForeground: String?
        /// The color that applies to success messages, for example the check mark for a successful download.
        public let success: String?
        /// The foreground color that applies to any text or other elements that appear over the success color.
        public let successForeground: String?
        /// This color that applies to warning and informational messages.
        public let warning: String?
        /// The foreground color that applies to any text or other elements that appear over the warning color.
        public let warningForeground: String?

        public init(accent: String? = nil, accentForeground: String? = nil, danger: String? = nil, dangerForeground: String? = nil, dimension: String? = nil, dimensionForeground: String? = nil, measure: String? = nil, measureForeground: String? = nil, primaryBackground: String? = nil, primaryForeground: String? = nil, secondaryBackground: String? = nil, secondaryForeground: String? = nil, success: String? = nil, successForeground: String? = nil, warning: String? = nil, warningForeground: String? = nil) {
            self.accent = accent
            self.accentForeground = accentForeground
            self.danger = danger
            self.dangerForeground = dangerForeground
            self.dimension = dimension
            self.dimensionForeground = dimensionForeground
            self.measure = measure
            self.measureForeground = measureForeground
            self.primaryBackground = primaryBackground
            self.primaryForeground = primaryForeground
            self.secondaryBackground = secondaryBackground
            self.secondaryForeground = secondaryForeground
            self.success = success
            self.successForeground = successForeground
            self.warning = warning
            self.warningForeground = warningForeground
        }

        public func validate(name: String) throws {
            try self.validate(self.accent, name: "accent", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.accentForeground, name: "accentForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.danger, name: "danger", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dangerForeground, name: "dangerForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dimension, name: "dimension", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.dimensionForeground, name: "dimensionForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.measure, name: "measure", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.measureForeground, name: "measureForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.primaryBackground, name: "primaryBackground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.primaryForeground, name: "primaryForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.secondaryBackground, name: "secondaryBackground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.secondaryForeground, name: "secondaryForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.success, name: "success", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.successForeground, name: "successForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.warning, name: "warning", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.warningForeground, name: "warningForeground", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accent = "Accent"
            case accentForeground = "AccentForeground"
            case danger = "Danger"
            case dangerForeground = "DangerForeground"
            case dimension = "Dimension"
            case dimensionForeground = "DimensionForeground"
            case measure = "Measure"
            case measureForeground = "MeasureForeground"
            case primaryBackground = "PrimaryBackground"
            case primaryForeground = "PrimaryForeground"
            case secondaryBackground = "SecondaryBackground"
            case secondaryForeground = "SecondaryForeground"
            case success = "Success"
            case successForeground = "SuccessForeground"
            case warning = "Warning"
            case warningForeground = "WarningForeground"
        }
    }

    public struct UnaggregatedField: AWSEncodableShape & AWSDecodableShape {
        /// The column that is used in the UnaggregatedField.
        public let column: ColumnIdentifier
        /// The custom field ID.
        public let fieldId: String
        /// The format configuration of the field.
        public let formatConfiguration: FormatConfiguration?

        public init(column: ColumnIdentifier, fieldId: String, formatConfiguration: FormatConfiguration? = nil) {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }

        public func validate(name: String) throws {
            try self.column.validate(name: "\(name).column")
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 512)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.formatConfiguration?.validate(name: "\(name).formatConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case fieldId = "FieldId"
            case formatConfiguration = "FormatConfiguration"
        }
    }

    public struct UniqueValuesComputation: AWSEncodableShape & AWSDecodableShape {
        /// The category field that is used in a computation.
        public let category: DimensionField?
        /// The ID for a computation.
        public let computationId: String
        /// The name of a computation.
        public let name: String?

        public init(category: DimensionField? = nil, computationId: String, name: String? = nil) {
            self.category = category
            self.computationId = computationId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.category?.validate(name: "\(name).category")
            try self.validate(self.computationId, name: "computationId", parent: name, max: 512)
            try self.validate(self.computationId, name: "computationId", parent: name, min: 1)
            try self.validate(self.computationId, name: "computationId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case computationId = "ComputationId"
            case name = "Name"
        }
    }

    public struct UntagColumnOperation: AWSEncodableShape & AWSDecodableShape {
        /// The column that this operation acts on.
        public let columnName: String
        /// The column tags to remove from this column.
        public let tagNames: [ColumnTagName]

        public init(columnName: String, tagNames: [ColumnTagName]) {
            self.columnName = columnName
            self.tagNames = tagNames
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case tagNames = "TagNames"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The keys of the key-value pairs for the resource tag or tags assigned to the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "keys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct UpdateAccountCustomizationRequest: AWSEncodableShape {
        /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization
        /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
        public let awsAccountId: String
        /// The namespace that you want to update Amazon QuickSight customizations for.
        public let namespace: String?

        public init(accountCustomization: AccountCustomization, awsAccountId: String, namespace: String? = nil) {
            self.accountCustomization = accountCustomization
            self.awsAccountId = awsAccountId
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.accountCustomization, forKey: .accountCustomization)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodeQuery(self.namespace, key: "namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
        }
    }

    public struct UpdateAccountCustomizationResponse: AWSDecodableShape {
        /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
        public let accountCustomization: AccountCustomization?
        /// The Amazon Resource Name (ARN) for the updated customization for this Amazon Web Services account.
        public let arn: String?
        /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
        public let awsAccountId: String?
        /// The namespace associated with the customization that you're updating.
        public let namespace: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(accountCustomization: AccountCustomization? = nil, arn: String? = nil, awsAccountId: String? = nil, namespace: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.accountCustomization = accountCustomization
            self.arn = arn
            self.awsAccountId = awsAccountId
            self.namespace = namespace
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accountCustomization = try container.decodeIfPresent(AccountCustomization.self, forKey: .accountCustomization)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.awsAccountId = try container.decodeIfPresent(String.self, forKey: .awsAccountId)
            self.namespace = try container.decodeIfPresent(String.self, forKey: .namespace)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case accountCustomization = "AccountCustomization"
            case arn = "Arn"
            case awsAccountId = "AwsAccountId"
            case namespace = "Namespace"
            case requestId = "RequestId"
        }
    }

    public struct UpdateAccountSettingsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the Amazon QuickSight settings that you want to list.
        public let awsAccountId: String
        /// The default namespace for this Amazon Web Services account. Currently, the default is default. IAM users that register for the first time with Amazon QuickSight provide an email address that becomes associated with the default namespace.
        public let defaultNamespace: String
        /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon Web Services account or Amazon QuickSight subscription.
        public let notificationEmail: String?
        /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubscription request. A False value will allow the account to be deleted.
        public let terminationProtectionEnabled: Bool?

        public init(awsAccountId: String, defaultNamespace: String, notificationEmail: String? = nil, terminationProtectionEnabled: Bool? = nil) {
            self.awsAccountId = awsAccountId
            self.defaultNamespace = defaultNamespace
            self.notificationEmail = notificationEmail
            self.terminationProtectionEnabled = terminationProtectionEnabled
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.defaultNamespace, forKey: .defaultNamespace)
            try container.encodeIfPresent(self.notificationEmail, forKey: .notificationEmail)
            try container.encodeIfPresent(self.terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.defaultNamespace, name: "defaultNamespace", parent: name, max: 64)
            try self.validate(self.defaultNamespace, name: "defaultNamespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultNamespace = "DefaultNamespace"
            case notificationEmail = "NotificationEmail"
            case terminationProtectionEnabled = "TerminationProtectionEnabled"
        }
    }

    public struct UpdateAccountSettingsResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct UpdateAnalysisPermissionsRequest: AWSEncodableShape {
        /// The ID of the analysis whose permissions you're updating. The ID is part of the analysis URL.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're updating. You must be using the Amazon Web Services account that the analysis is in.
        public let awsAccountId: String
        /// A structure that describes the permissions to add and the principal to add them to.
        public let grantPermissions: [ResourcePermission]?
        /// A structure that describes the permissions to remove and the principal to remove them from.
        public let revokePermissions: [ResourcePermission]?

        public init(analysisId: String, awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateAnalysisPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis that you updated.
        public let analysisArn: String?
        /// The ID of the analysis that you updated permissions for.
        public let analysisId: String?
        /// A structure that describes the principals and the resource-level permissions on an analysis.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(analysisArn: String? = nil, analysisId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.analysisArn = analysisArn
            self.analysisId = analysisId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisArn = try container.decodeIfPresent(String.self, forKey: .analysisArn)
            self.analysisId = try container.decodeIfPresent(String.self, forKey: .analysisId)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case analysisArn = "AnalysisArn"
            case analysisId = "AnalysisId"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct UpdateAnalysisRequest: AWSEncodableShape {
        /// The ID for the analysis that you're updating. This ID displays in the URL of the analysis.
        public let analysisId: String
        /// The ID of the Amazon Web Services account that contains the analysis that you're updating.
        public let awsAccountId: String
        /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: AnalysisDefinition?
        /// A descriptive name for the analysis that you're updating. This name displays for the analysis in the Amazon QuickSight console.
        public let name: String
        /// The parameter names and override values that you want to use. An analysis can have  any parameter type, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// A source entity to use for the analysis that you're updating. This metadata structure contains details that describe a source template and one or more datasets.
        public let sourceEntity: AnalysisSourceEntity?
        /// The Amazon Resource Name (ARN) for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
        public let themeArn: String?
        /// The option to relax the validation needed to update an analysis with definition objects. This skips the validation step for specific errors.
        public let validationStrategy: ValidationStrategy?

        public init(analysisId: String, awsAccountId: String, definition: AnalysisDefinition? = nil, name: String, parameters: Parameters? = nil, sourceEntity: AnalysisSourceEntity? = nil, themeArn: String? = nil, validationStrategy: ValidationStrategy? = nil) {
            self.analysisId = analysisId
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.name = name
            self.parameters = parameters
            self.sourceEntity = sourceEntity
            self.themeArn = themeArn
            self.validationStrategy = validationStrategy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisId, key: "AnalysisId")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.sourceEntity, forKey: .sourceEntity)
            try container.encodeIfPresent(self.themeArn, forKey: .themeArn)
            try container.encodeIfPresent(self.validationStrategy, forKey: .validationStrategy)
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisId, name: "analysisId", parent: name, max: 512)
            try self.validate(self.analysisId, name: "analysisId", parent: name, min: 1)
            try self.validate(self.analysisId, name: "analysisId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case name = "Name"
            case parameters = "Parameters"
            case sourceEntity = "SourceEntity"
            case themeArn = "ThemeArn"
            case validationStrategy = "ValidationStrategy"
        }
    }

    public struct UpdateAnalysisResponse: AWSDecodableShape {
        /// The ID of the analysis.
        public let analysisId: String?
        /// The ARN of the analysis that you're updating.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The update status of the last update that was made to the analysis.
        public let updateStatus: ResourceStatus?

        public init(analysisId: String? = nil, arn: String? = nil, requestId: String? = nil, status: Int? = nil, updateStatus: ResourceStatus? = nil) {
            self.analysisId = analysisId
            self.arn = arn
            self.requestId = requestId
            self.status = status
            self.updateStatus = updateStatus
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.analysisId = try container.decodeIfPresent(String.self, forKey: .analysisId)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.updateStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .updateStatus)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisId = "AnalysisId"
            case arn = "Arn"
            case requestId = "RequestId"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct UpdateDashboardLinksRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboard whose links you want to update.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        ///  list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
        public let linkEntities: [String]

        public init(awsAccountId: String, dashboardId: String, linkEntities: [String]) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.linkEntities = linkEntities
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            try container.encode(self.linkEntities, forKey: .linkEntities)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.linkEntities.forEach {
                try validate($0, name: "linkEntities[]", parent: name, max: 1024)
                try validate($0, name: "linkEntities[]", parent: name, min: 1)
                try validate($0, name: "linkEntities[]", parent: name, pattern: "^arn:aws[\\w\\-]*:quicksight:[\\w\\-]+:\\d+:analysis/[\\w\\-]{1,512}$")
            }
            try self.validate(self.linkEntities, name: "linkEntities", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case linkEntities = "LinkEntities"
        }
    }

    public struct UpdateDashboardLinksResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// A list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
        public let linkEntities: [String]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, linkEntities: [String]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.linkEntities = linkEntities
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardArn = try container.decodeIfPresent(String.self, forKey: .dashboardArn)
            self.linkEntities = try container.decodeIfPresent([String].self, forKey: .linkEntities)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case linkEntities = "LinkEntities"
            case requestId = "RequestId"
        }
    }

    public struct UpdateDashboardPermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboard whose permissions you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// Grants link permissions to all users in a defined namespace.
        public let grantLinkPermissions: [ResourcePermission]?
        /// The permissions that you want to grant on this resource.
        public let grantPermissions: [ResourcePermission]?
        /// Revokes link permissions from all users in a defined namespace.
        public let revokeLinkPermissions: [ResourcePermission]?
        /// The permissions that you want to revoke from this resource.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dashboardId: String, grantLinkPermissions: [ResourcePermission]? = nil, grantPermissions: [ResourcePermission]? = nil, revokeLinkPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.grantLinkPermissions = grantLinkPermissions
            self.grantPermissions = grantPermissions
            self.revokeLinkPermissions = revokeLinkPermissions
            self.revokePermissions = revokePermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            try container.encodeIfPresent(self.grantLinkPermissions, forKey: .grantLinkPermissions)
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokeLinkPermissions, forKey: .revokeLinkPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.grantLinkPermissions?.forEach {
                try $0.validate(name: "\(name).grantLinkPermissions[]")
            }
            try self.validate(self.grantLinkPermissions, name: "grantLinkPermissions", parent: name, max: 100)
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokeLinkPermissions?.forEach {
                try $0.validate(name: "\(name).revokeLinkPermissions[]")
            }
            try self.validate(self.revokeLinkPermissions, name: "revokeLinkPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case grantLinkPermissions = "GrantLinkPermissions"
            case grantPermissions = "GrantPermissions"
            case revokeLinkPermissions = "RevokeLinkPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDashboardPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// Updates the permissions of a shared link to an Amazon QuickSight dashboard.
        public let linkSharingConfiguration: LinkSharingConfiguration?
        /// Information about the permissions on the dashboard.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, linkSharingConfiguration: LinkSharingConfiguration? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.linkSharingConfiguration = linkSharingConfiguration
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardArn = try container.decodeIfPresent(String.self, forKey: .dashboardArn)
            self.dashboardId = try container.decodeIfPresent(String.self, forKey: .dashboardId)
            self.linkSharingConfiguration = try container.decodeIfPresent(LinkSharingConfiguration.self, forKey: .linkSharingConfiguration)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case linkSharingConfiguration = "LinkSharingConfiguration"
            case permissions = "Permissions"
            case requestId = "RequestId"
        }
    }

    public struct UpdateDashboardPublishedVersionRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// The version number of the dashboard.
        public let versionNumber: Int64

        public init(awsAccountId: String, dashboardId: String, versionNumber: Int64) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.versionNumber = versionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            request.encodePath(self.versionNumber, key: "VersionNumber")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateDashboardPublishedVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dashboard.
        public let dashboardArn: String?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dashboardArn: String? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dashboardArn = try container.decodeIfPresent(String.self, forKey: .dashboardArn)
            self.dashboardId = try container.decodeIfPresent(String.self, forKey: .dashboardId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "DashboardArn"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
        public let awsAccountId: String
        /// The ID for the dashboard.
        public let dashboardId: String
        /// Options for publishing the dashboard when you create it:    AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.     AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.     VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
        public let dashboardPublishOptions: DashboardPublishOptions?
        /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: DashboardVersionDefinition?
        /// The display name of the dashboard.
        public let name: String
        /// A structure that contains the parameters of the dashboard. These are parameter overrides for a dashboard. A dashboard can have any type of parameters, and some parameters might accept multiple values.
        public let parameters: Parameters?
        /// The entity that you are using as a source when you update the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only update a dashboard from a template, so you use a SourceTemplate entity. If you need to update a dashboard from an analysis, first convert the analysis to a template by using the  CreateTemplate API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region.  Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: DashboardSourceEntity?
        /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that was originally associated with the entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
        public let themeArn: String?
        /// The option to relax the validation needed to update a dashboard with definition objects. This skips the validation step for specific errors.
        public let validationStrategy: ValidationStrategy?
        /// A description for the first version of the dashboard being created.
        public let versionDescription: String?

        public init(awsAccountId: String, dashboardId: String, dashboardPublishOptions: DashboardPublishOptions? = nil, definition: DashboardVersionDefinition? = nil, name: String, parameters: Parameters? = nil, sourceEntity: DashboardSourceEntity? = nil, themeArn: String? = nil, validationStrategy: ValidationStrategy? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.dashboardId = dashboardId
            self.dashboardPublishOptions = dashboardPublishOptions
            self.definition = definition
            self.name = name
            self.parameters = parameters
            self.sourceEntity = sourceEntity
            self.themeArn = themeArn
            self.validationStrategy = validationStrategy
            self.versionDescription = versionDescription
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dashboardId, key: "DashboardId")
            try container.encodeIfPresent(self.dashboardPublishOptions, forKey: .dashboardPublishOptions)
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encodeIfPresent(self.sourceEntity, forKey: .sourceEntity)
            try container.encodeIfPresent(self.themeArn, forKey: .themeArn)
            try container.encodeIfPresent(self.validationStrategy, forKey: .validationStrategy)
            try container.encodeIfPresent(self.versionDescription, forKey: .versionDescription)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 512)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 1)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[\\w\\-]+$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.parameters?.validate(name: "\(name).parameters")
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardPublishOptions = "DashboardPublishOptions"
            case definition = "Definition"
            case name = "Name"
            case parameters = "Parameters"
            case sourceEntity = "SourceEntity"
            case themeArn = "ThemeArn"
            case validationStrategy = "ValidationStrategy"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The creation status of the request.
        public let creationStatus: ResourceStatus?
        /// The ID for the dashboard.
        public let dashboardId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ARN of the dashboard, including the version number.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, dashboardId: String? = nil, requestId: String? = nil, status: Int? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.dashboardId = dashboardId
            self.requestId = requestId
            self.status = status
            self.versionArn = versionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case dashboardId = "DashboardId"
            case requestId = "RequestId"
            case status = "Status"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateDataSetPermissionsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID for the dataset whose permissions you want to update. This ID is unique per
        /// 			Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String
        /// The resource permissions that you want to grant to the dataset.
        public let grantPermissions: [ResourcePermission]?
        /// The resource permissions that you want to revoke from the dataset.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dataSetId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDataSetPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let dataSetArn: String?
        /// The ID for the dataset whose permissions you want to update. This ID is unique per
        /// 			Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSetArn: String? = nil, dataSetId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSetArn = dataSetArn
            self.dataSetId = dataSetId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSetArn = try container.decodeIfPresent(String.self, forKey: .dataSetArn)
            self.dataSetId = try container.decodeIfPresent(String.self, forKey: .dataSetId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetArn = "DataSetArn"
            case dataSetId = "DataSetId"
            case requestId = "RequestId"
        }
    }

    public struct UpdateDataSetRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public let columnGroups: [ColumnGroup]?
        /// A set of one or more definitions of a  ColumnLevelPermissionRule .
        public let columnLevelPermissionRules: [ColumnLevelPermissionRule]?
        /// The ID for the dataset that you want to update. This ID is unique per Amazon Web Services Region for each
        /// 			Amazon Web Services account.
        public let dataSetId: String
        /// The parameter declarations of the dataset.
        public let datasetParameters: [DatasetParameter]?
        public let dataSetUsageConfiguration: DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public let fieldFolders: [String: FieldFolder]?
        /// Indicates whether you want to import the data into SPICE.
        public let importMode: DataSetImportMode
        /// Configures the combination and transformation of the data from the physical tables.
        public let logicalTableMap: [String: LogicalTable]?
        /// The display name for the dataset.
        public let name: String
        /// Declares the physical tables that are available in the underlying data sources.
        public let physicalTableMap: [String: PhysicalTable]
        /// The row-level security configuration for the data you want to create.
        public let rowLevelPermissionDataSet: RowLevelPermissionDataSet?
        /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
        public let rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration?

        public init(awsAccountId: String, columnGroups: [ColumnGroup]? = nil, columnLevelPermissionRules: [ColumnLevelPermissionRule]? = nil, dataSetId: String, datasetParameters: [DatasetParameter]? = nil, dataSetUsageConfiguration: DataSetUsageConfiguration? = nil, fieldFolders: [String: FieldFolder]? = nil, importMode: DataSetImportMode, logicalTableMap: [String: LogicalTable]? = nil, name: String, physicalTableMap: [String: PhysicalTable], rowLevelPermissionDataSet: RowLevelPermissionDataSet? = nil, rowLevelPermissionTagConfiguration: RowLevelPermissionTagConfiguration? = nil) {
            self.awsAccountId = awsAccountId
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.dataSetId = dataSetId
            self.datasetParameters = datasetParameters
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.columnGroups, forKey: .columnGroups)
            try container.encodeIfPresent(self.columnLevelPermissionRules, forKey: .columnLevelPermissionRules)
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encodeIfPresent(self.datasetParameters, forKey: .datasetParameters)
            try container.encodeIfPresent(self.dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
            try container.encodeIfPresent(self.fieldFolders, forKey: .fieldFolders)
            try container.encode(self.importMode, forKey: .importMode)
            try container.encodeIfPresent(self.logicalTableMap, forKey: .logicalTableMap)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.physicalTableMap, forKey: .physicalTableMap)
            try container.encodeIfPresent(self.rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
            try container.encodeIfPresent(self.rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.columnGroups?.forEach {
                try $0.validate(name: "\(name).columnGroups[]")
            }
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, max: 8)
            try self.validate(self.columnGroups, name: "columnGroups", parent: name, min: 1)
            try self.columnLevelPermissionRules?.forEach {
                try $0.validate(name: "\(name).columnLevelPermissionRules[]")
            }
            try self.validate(self.columnLevelPermissionRules, name: "columnLevelPermissionRules", parent: name, min: 1)
            try self.datasetParameters?.forEach {
                try $0.validate(name: "\(name).datasetParameters[]")
            }
            try self.validate(self.datasetParameters, name: "datasetParameters", parent: name, max: 32)
            try self.validate(self.datasetParameters, name: "datasetParameters", parent: name, min: 1)
            try self.fieldFolders?.forEach {
                try validate($0.key, name: "fieldFolders.key", parent: name, max: 1000)
                try validate($0.key, name: "fieldFolders.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).fieldFolders[\"\($0.key)\"]")
            }
            try self.logicalTableMap?.forEach {
                try validate($0.key, name: "logicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "logicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "logicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).logicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, max: 64)
            try self.validate(self.logicalTableMap, name: "logicalTableMap", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.physicalTableMap.forEach {
                try validate($0.key, name: "physicalTableMap.key", parent: name, max: 64)
                try validate($0.key, name: "physicalTableMap.key", parent: name, min: 1)
                try validate($0.key, name: "physicalTableMap.key", parent: name, pattern: "^[0-9a-zA-Z-]*$")
                try $0.value.validate(name: "\(name).physicalTableMap[\"\($0.key)\"]")
            }
            try self.validate(self.physicalTableMap, name: "physicalTableMap", parent: name, max: 32)
            try self.rowLevelPermissionDataSet?.validate(name: "\(name).rowLevelPermissionDataSet")
            try self.rowLevelPermissionTagConfiguration?.validate(name: "\(name).rowLevelPermissionTagConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case columnGroups = "ColumnGroups"
            case columnLevelPermissionRules = "ColumnLevelPermissionRules"
            case datasetParameters = "DatasetParameters"
            case dataSetUsageConfiguration = "DataSetUsageConfiguration"
            case fieldFolders = "FieldFolders"
            case importMode = "ImportMode"
            case logicalTableMap = "LogicalTableMap"
            case name = "Name"
            case physicalTableMap = "PhysicalTableMap"
            case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
            case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        }
    }

    public struct UpdateDataSetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let arn: String?
        /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSetId: String?
        /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionArn: String?
        /// The ID of the ingestion, which is triggered as a result of dataset creation if the import
        /// 			mode is SPICE.
        public let ingestionId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, dataSetId: String? = nil, ingestionArn: String? = nil, ingestionId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.dataSetId = dataSetId
            self.ingestionArn = ingestionArn
            self.ingestionId = ingestionId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.dataSetId = try container.decodeIfPresent(String.self, forKey: .dataSetId)
            self.ingestionArn = try container.decodeIfPresent(String.self, forKey: .ingestionArn)
            self.ingestionId = try container.decodeIfPresent(String.self, forKey: .ingestionId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSetId = "DataSetId"
            case ingestionArn = "IngestionArn"
            case ingestionId = "IngestionId"
            case requestId = "RequestId"
        }
    }

    public struct UpdateDataSourcePermissionsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String
        /// A list of resource permissions that you want to grant on the data source.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions that you want to revoke on the data source.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, dataSourceId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.dataSourceId = dataSourceId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSourceId, key: "DataSourceId")
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateDataSourcePermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.dataSourceArn = try container.decodeIfPresent(String.self, forKey: .dataSourceArn)
            self.dataSourceId = try container.decodeIfPresent(String.self, forKey: .dataSourceId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "DataSourceArn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The credentials that Amazon QuickSight that uses to connect to your underlying source. Currently,
        /// 			only credentials based on user name and password are supported.
        public let credentials: DataSourceCredentials?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String
        /// The parameters that Amazon QuickSight uses to connect to your underlying source.
        public let dataSourceParameters: DataSourceParameters?
        /// A display name for the data source.
        public let name: String
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying
        /// 			source.
        public let sslProperties: SslProperties?
        /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to
        /// 			your underlying source.
        public let vpcConnectionProperties: VpcConnectionProperties?

        public init(awsAccountId: String, credentials: DataSourceCredentials? = nil, dataSourceId: String, dataSourceParameters: DataSourceParameters? = nil, name: String, sslProperties: SslProperties? = nil, vpcConnectionProperties: VpcConnectionProperties? = nil) {
            self.awsAccountId = awsAccountId
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.name = name
            self.sslProperties = sslProperties
            self.vpcConnectionProperties = vpcConnectionProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.credentials, forKey: .credentials)
            request.encodePath(self.dataSourceId, key: "DataSourceId")
            try container.encodeIfPresent(self.dataSourceParameters, forKey: .dataSourceParameters)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.sslProperties, forKey: .sslProperties)
            try container.encodeIfPresent(self.vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.credentials?.validate(name: "\(name).credentials")
            try self.dataSourceParameters?.validate(name: "\(name).dataSourceParameters")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case dataSourceParameters = "DataSourceParameters"
            case name = "Name"
            case sslProperties = "SslProperties"
            case vpcConnectionProperties = "VpcConnectionProperties"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data source.
        public let arn: String?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let dataSourceId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The update status of the data source's last update.
        public let updateStatus: ResourceStatus?

        public init(arn: String? = nil, dataSourceId: String? = nil, requestId: String? = nil, status: Int? = nil, updateStatus: ResourceStatus? = nil) {
            self.arn = arn
            self.dataSourceId = dataSourceId
            self.requestId = requestId
            self.status = status
            self.updateStatus = updateStatus
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.dataSourceId = try container.decodeIfPresent(String.self, forKey: .dataSourceId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.updateStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .updateStatus)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case dataSourceId = "DataSourceId"
            case requestId = "RequestId"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct UpdateFolderPermissionsRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder to update.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The permissions that you want to grant on a resource. Namespace ARNs are not supported Principal values for folder permissions.
        public let grantPermissions: [ResourcePermission]?
        /// The permissions that you want to revoke from a resource.  Namespace ARNs are not supported Principal values for folder permissions.
        public let revokePermissions: [ResourcePermission]?

        public init(awsAccountId: String, folderId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 64)
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, min: 1)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 64)
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateFolderPermissionsResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// Information about the permissions for the folder.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case permissions = "Permissions"
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateFolderRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that contains the folder to update.
        public let awsAccountId: String
        /// The ID of the folder.
        public let folderId: String
        /// The name of the folder.
        public let name: String

        public init(awsAccountId: String, folderId: String, name: String) {
            self.awsAccountId = awsAccountId
            self.folderId = folderId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.folderId, key: "FolderId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.folderId, name: "folderId", parent: name, max: 2048)
            try self.validate(self.folderId, name: "folderId", parent: name, min: 1)
            try self.validate(self.folderId, name: "folderId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateFolderResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the folder.
        public let arn: String?
        /// The ID of the folder.
        public let folderId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, folderId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.folderId = folderId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.folderId = try container.decodeIfPresent(String.self, forKey: .folderId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case folderId = "FolderId"
            case requestId = "RequestId"
        }
    }

    public struct UpdateGroupRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The description for the group that you want to update.
        public let description: String?
        /// The name of the group that you want to update.
        public let groupName: String
        /// The namespace of the group that you want to update.
        public let namespace: String

        public init(awsAccountId: String, description: String? = nil, groupName: String, namespace: String) {
            self.awsAccountId = awsAccountId
            self.description = description
            self.groupName = groupName
            self.namespace = namespace
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.groupName, key: "GroupName")
            request.encodePath(self.namespace, key: "Namespace")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateGroupResponse: AWSDecodableShape {
        /// The name of the group.
        public let group: Group?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(group: Group? = nil, requestId: String? = nil, status: Int? = nil) {
            self.group = group
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.group = try container.decodeIfPresent(Group.self, forKey: .group)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
            case requestId = "RequestId"
        }
    }

    public struct UpdateIAMPolicyAssignmentRequest: AWSEncodableShape {
        /// The name of the assignment, also called a rule.
        /// 			The
        /// 			name must be unique within the
        /// 			Amazon Web Services account.
        public let assignmentName: String
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when
        /// 					creating the data source.    DISABLED - This assignment isn't used when creating the data
        /// 					source.    DRAFT - This assignment is an unfinished draft and isn't used
        /// 					when creating the data source.
        public let assignmentStatus: AssignmentStatus?
        /// The ID of the Amazon Web Services account that contains the IAM policy
        /// 			assignment.
        public let awsAccountId: String
        /// The Amazon QuickSight users, groups, or both that you want to assign the policy
        /// 			to.
        public let identities: [String: [String]]?
        /// The namespace of the assignment.
        public let namespace: String
        /// The ARN for the IAM policy to apply to the Amazon QuickSight users and
        /// 			groups specified in this assignment.
        public let policyArn: String?

        public init(assignmentName: String, assignmentStatus: AssignmentStatus? = nil, awsAccountId: String, identities: [String: [String]]? = nil, namespace: String, policyArn: String? = nil) {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.namespace = namespace
            self.policyArn = policyArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assignmentName, key: "AssignmentName")
            try container.encodeIfPresent(self.assignmentStatus, forKey: .assignmentStatus)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.identities, forKey: .identities)
            request.encodePath(self.namespace, key: "Namespace")
            try container.encodeIfPresent(self.policyArn, forKey: .policyArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, min: 1)
            try self.validate(self.assignmentName, name: "assignmentName", parent: name, pattern: "^(?=^.{2,256}$)(?!.*\\s)[0-9a-zA-Z-_.:=+@]*$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
        }
    }

    public struct UpdateIAMPolicyAssignmentResponse: AWSDecodableShape {
        /// The ID of the assignment.
        public let assignmentId: String?
        /// The name of the assignment or rule.
        public let assignmentName: String?
        /// The status of the assignment. Possible values are as follows:    ENABLED - Anything specified in this assignment is used when
        /// 					creating the data source.    DISABLED - This assignment isn't used when creating the data
        /// 					source.    DRAFT - This assignment is an unfinished draft and isn't used
        /// 					when creating the data source.
        public let assignmentStatus: AssignmentStatus?
        /// The Amazon QuickSight users, groups, or both that the IAM policy is
        /// 			assigned to.
        public let identities: [String: [String]]?
        /// The ARN for the IAM policy applied to the Amazon QuickSight users and
        /// 			groups specified in this assignment.
        public let policyArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(assignmentId: String? = nil, assignmentName: String? = nil, assignmentStatus: AssignmentStatus? = nil, identities: [String: [String]]? = nil, policyArn: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.identities = identities
            self.policyArn = policyArn
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.assignmentId = try container.decodeIfPresent(String.self, forKey: .assignmentId)
            self.assignmentName = try container.decodeIfPresent(String.self, forKey: .assignmentName)
            self.assignmentStatus = try container.decodeIfPresent(AssignmentStatus.self, forKey: .assignmentStatus)
            self.identities = try container.decodeIfPresent([String: [String]].self, forKey: .identities)
            self.policyArn = try container.decodeIfPresent(String.self, forKey: .policyArn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case assignmentId = "AssignmentId"
            case assignmentName = "AssignmentName"
            case assignmentStatus = "AssignmentStatus"
            case identities = "Identities"
            case policyArn = "PolicyArn"
            case requestId = "RequestId"
        }
    }

    public struct UpdateIdentityPropagationConfigRequest: AWSEncodableShape {
        /// Specifies a list of application ARNs that represent the authorized targets for a service.
        public let authorizedTargets: [String]?
        /// The ID of the Amazon Web Services account that contains the identity propagation configuration that you want to update.
        public let awsAccountId: String
        /// The name of the Amazon Web Services service that contains the authorized targets that you want to add or update.
        public let service: ServiceType

        public init(authorizedTargets: [String]? = nil, awsAccountId: String, service: ServiceType) {
            self.authorizedTargets = authorizedTargets
            self.awsAccountId = awsAccountId
            self.service = service
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authorizedTargets, forKey: .authorizedTargets)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.service, key: "Service")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedTargets = "AuthorizedTargets"
        }
    }

    public struct UpdateIdentityPropagationConfigResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct UpdateIpRestrictionRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String
        /// A value that specifies whether IP rules are turned on.
        public let enabled: Bool?
        /// A map that describes the updated IP rules with CIDR ranges and descriptions.
        public let ipRestrictionRuleMap: [String: String]?
        /// A map of allowed VPC endpoint IDs and their corresponding rule descriptions.
        public let vpcEndpointIdRestrictionRuleMap: [String: String]?
        /// A map of VPC IDs and their corresponding rules. When you configure this parameter, traffic from all VPC endpoints that are present in the specified VPC is allowed.
        public let vpcIdRestrictionRuleMap: [String: String]?

        public init(awsAccountId: String, enabled: Bool? = nil, ipRestrictionRuleMap: [String: String]? = nil, vpcEndpointIdRestrictionRuleMap: [String: String]? = nil, vpcIdRestrictionRuleMap: [String: String]? = nil) {
            self.awsAccountId = awsAccountId
            self.enabled = enabled
            self.ipRestrictionRuleMap = ipRestrictionRuleMap
            self.vpcEndpointIdRestrictionRuleMap = vpcEndpointIdRestrictionRuleMap
            self.vpcIdRestrictionRuleMap = vpcIdRestrictionRuleMap
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.enabled, forKey: .enabled)
            try container.encodeIfPresent(self.ipRestrictionRuleMap, forKey: .ipRestrictionRuleMap)
            try container.encodeIfPresent(self.vpcEndpointIdRestrictionRuleMap, forKey: .vpcEndpointIdRestrictionRuleMap)
            try container.encodeIfPresent(self.vpcIdRestrictionRuleMap, forKey: .vpcIdRestrictionRuleMap)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.ipRestrictionRuleMap?.forEach {
                try validate($0.key, name: "ipRestrictionRuleMap.key", parent: name, pattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[1-9]))$")
                try validate($0.value, name: "ipRestrictionRuleMap[\"\($0.key)\"]", parent: name, max: 150)
            }
            try self.vpcEndpointIdRestrictionRuleMap?.forEach {
                try validate($0.key, name: "vpcEndpointIdRestrictionRuleMap.key", parent: name, max: 255)
                try validate($0.key, name: "vpcEndpointIdRestrictionRuleMap.key", parent: name, min: 1)
                try validate($0.key, name: "vpcEndpointIdRestrictionRuleMap.key", parent: name, pattern: "^vpce-[0-9a-z]*$")
                try validate($0.value, name: "vpcEndpointIdRestrictionRuleMap[\"\($0.key)\"]", parent: name, max: 150)
            }
            try self.vpcIdRestrictionRuleMap?.forEach {
                try validate($0.key, name: "vpcIdRestrictionRuleMap.key", parent: name, max: 255)
                try validate($0.key, name: "vpcIdRestrictionRuleMap.key", parent: name, min: 1)
                try validate($0.key, name: "vpcIdRestrictionRuleMap.key", parent: name, pattern: "^vpc-[0-9a-z]*$")
                try validate($0.value, name: "vpcIdRestrictionRuleMap[\"\($0.key)\"]", parent: name, max: 150)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case ipRestrictionRuleMap = "IpRestrictionRuleMap"
            case vpcEndpointIdRestrictionRuleMap = "VpcEndpointIdRestrictionRuleMap"
            case vpcIdRestrictionRuleMap = "VpcIdRestrictionRuleMap"
        }
    }

    public struct UpdateIpRestrictionResponse: AWSDecodableShape {
        /// The ID of the Amazon Web Services account that contains the IP rules.
        public let awsAccountId: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(awsAccountId: String? = nil, requestId: String? = nil, status: Int? = nil) {
            self.awsAccountId = awsAccountId
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.awsAccountId = try container.decodeIfPresent(String.self, forKey: .awsAccountId)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case requestId = "RequestId"
        }
    }

    public struct UpdatePublicSharingSettingsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID associated with your Amazon QuickSight subscription.
        public let awsAccountId: String
        /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account.
        public let publicSharingEnabled: Bool?

        public init(awsAccountId: String, publicSharingEnabled: Bool? = nil) {
            self.awsAccountId = awsAccountId
            self.publicSharingEnabled = publicSharingEnabled
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.publicSharingEnabled, forKey: .publicSharingEnabled)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case publicSharingEnabled = "PublicSharingEnabled"
        }
    }

    public struct UpdatePublicSharingSettingsResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
        }
    }

    public struct UpdateRefreshScheduleRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let dataSetId: String
        /// The refresh schedule.
        public let schedule: RefreshSchedule

        public init(awsAccountId: String, dataSetId: String, schedule: RefreshSchedule) {
            self.awsAccountId = awsAccountId
            self.dataSetId = dataSetId
            self.schedule = schedule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.dataSetId, key: "DataSetId")
            try container.encode(self.schedule, forKey: .schedule)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.schedule.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "Schedule"
        }
    }

    public struct UpdateRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the refresh schedule.
        public let arn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The ID of the refresh schedule.
        public let scheduleId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(arn: String? = nil, requestId: String? = nil, scheduleId: String? = nil, status: Int? = nil) {
            self.arn = arn
            self.requestId = requestId
            self.scheduleId = scheduleId
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.scheduleId = try container.decodeIfPresent(String.self, forKey: .scheduleId)
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case requestId = "RequestId"
            case scheduleId = "ScheduleId"
        }
    }

    public struct UpdateRoleCustomPermissionRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The name of the custom permission that you want to update the role with.
        public let customPermissionsName: String
        /// The namespace that contains the role that you want to update.
        public let namespace: String
        /// The name of role tht you want to update.
        public let role: Role

        public init(awsAccountId: String, customPermissionsName: String, namespace: String, role: Role) {
            self.awsAccountId = awsAccountId
            self.customPermissionsName = customPermissionsName
            self.namespace = namespace
            self.role = role
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.customPermissionsName, forKey: .customPermissionsName)
            request.encodePath(self.namespace, key: "Namespace")
            request.encodePath(self.role, key: "Role")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, max: 64)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, min: 1)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, pattern: "^[a-zA-Z0-9+=,.@_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case customPermissionsName = "CustomPermissionsName"
        }
    }

    public struct UpdateRoleCustomPermissionResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?

        public init(requestId: String? = nil, status: Int? = nil) {
            self.requestId = requestId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case status = "Status"
        }
    }

    public struct UpdateTemplateAliasRequest: AWSEncodableShape {
        /// The alias of the template that you want to update. If you name a specific alias, you update
        /// 			the version that the alias points to. You can specify the latest version of the template
        /// 			by providing the keyword $LATEST in the AliasName parameter.
        /// 			The keyword $PUBLISHED doesn't apply to templates.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the template alias that you're updating.
        public let awsAccountId: String
        /// The ID for the template.
        public let templateId: String
        /// The version number of the template.
        public let templateVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, templateId: String, templateVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.templateId = templateId
            self.templateVersionNumber = templateVersionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.templateId, key: "TemplateId")
            try container.encode(self.templateVersionNumber, forKey: .templateVersionNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.templateVersionNumber, name: "templateVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateVersionNumber = "TemplateVersionNumber"
        }
    }

    public struct UpdateTemplateAliasResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The template alias.
        public let templateAlias: TemplateAlias?

        public init(requestId: String? = nil, status: Int? = nil, templateAlias: TemplateAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.templateAlias = templateAlias
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateAlias = try container.decodeIfPresent(TemplateAlias.self, forKey: .templateAlias)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case templateAlias = "TemplateAlias"
        }
    }

    public struct UpdateTemplatePermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the template.
        public let awsAccountId: String
        /// A list of resource permissions to be granted on the template.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions to be revoked from the template.
        public let revokePermissions: [ResourcePermission]?
        /// The ID for the template.
        public let templateId: String

        public init(awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil, templateId: String) {
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
            request.encodePath(self.templateId, key: "TemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateTemplatePermissionsResponse: AWSDecodableShape {
        /// A list of resource permissions to be set on the template.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String?
        /// The ID for the template.
        public let templateId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, templateArn: String? = nil, templateId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateArn = try container.decodeIfPresent(String.self, forKey: .templateArn)
            self.templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case templateArn = "TemplateArn"
            case templateId = "TemplateId"
        }
    }

    public struct UpdateTemplateRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the template that you're updating.
        public let awsAccountId: String
        /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
        public let definition: TemplateVersionDefinition?
        /// The name for the template.
        public let name: String?
        /// The entity that you are using as a source when you update the template. In
        /// 			SourceEntity, you specify the type of object you're using as source:
        /// 			SourceTemplate for a template or SourceAnalysis for an
        /// 			analysis. Both of these require an Amazon Resource Name (ARN). For
        /// 			SourceTemplate, specify the ARN of the source template. For
        /// 			SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate
        /// 			ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region;.  Use the DataSetReferences entity within SourceTemplate or
        /// 			SourceAnalysis to list the replacement datasets for the placeholders listed
        /// 			in the original. The schema in each dataset must match its placeholder.
        public let sourceEntity: TemplateSourceEntity?
        /// The ID for the template.
        public let templateId: String
        /// The option to relax the validation needed to update a template with definition objects. This skips the validation step for specific errors.
        public let validationStrategy: ValidationStrategy?
        /// A description of the current template version that is being updated. Every time you call
        /// 				UpdateTemplate, you create a new version of the template. Each version
        /// 			of the template maintains a description of the version in the
        /// 				VersionDescription field.
        public let versionDescription: String?

        public init(awsAccountId: String, definition: TemplateVersionDefinition? = nil, name: String? = nil, sourceEntity: TemplateSourceEntity? = nil, templateId: String, validationStrategy: ValidationStrategy? = nil, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.definition = definition
            self.name = name
            self.sourceEntity = sourceEntity
            self.templateId = templateId
            self.validationStrategy = validationStrategy
            self.versionDescription = versionDescription
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.sourceEntity, forKey: .sourceEntity)
            request.encodePath(self.templateId, key: "TemplateId")
            try container.encodeIfPresent(self.validationStrategy, forKey: .validationStrategy)
            try container.encodeIfPresent(self.versionDescription, forKey: .versionDescription)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.sourceEntity?.validate(name: "\(name).sourceEntity")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 512)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case name = "Name"
            case sourceEntity = "SourceEntity"
            case validationStrategy = "ValidationStrategy"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the template.
        public let arn: String?
        /// The creation status of the template.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the template.
        public let templateId: String?
        /// The ARN for the template, including the version information of the first version.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, templateId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.templateId = templateId
            self.versionArn = versionArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.creationStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
            self.versionArn = try container.decodeIfPresent(String.self, forKey: .versionArn)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case templateId = "TemplateId"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateThemeAliasRequest: AWSEncodableShape {
        /// The name of the theme alias that you want to update.
        public let aliasName: String
        /// The ID of the Amazon Web Services account that contains the theme alias that you're updating.
        public let awsAccountId: String
        /// The ID for the theme.
        public let themeId: String
        /// The version number of the theme that the alias should reference.
        public let themeVersionNumber: Int64

        public init(aliasName: String, awsAccountId: String, themeId: String, themeVersionNumber: Int64) {
            self.aliasName = aliasName
            self.awsAccountId = awsAccountId
            self.themeId = themeId
            self.themeVersionNumber = themeVersionNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.aliasName, key: "AliasName")
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.themeId, key: "ThemeId")
            try container.encode(self.themeVersionNumber, forKey: .themeVersionNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasName, name: "aliasName", parent: name, max: 2048)
            try self.validate(self.aliasName, name: "aliasName", parent: name, min: 1)
            try self.validate(self.aliasName, name: "aliasName", parent: name, pattern: "^[\\w\\-]+|(\\$LATEST)|(\\$PUBLISHED)$")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.themeVersionNumber, name: "themeVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case themeVersionNumber = "ThemeVersionNumber"
        }
    }

    public struct UpdateThemeAliasResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// Information about the theme alias.
        public let themeAlias: ThemeAlias?

        public init(requestId: String? = nil, status: Int? = nil, themeAlias: ThemeAlias? = nil) {
            self.requestId = requestId
            self.status = status
            self.themeAlias = themeAlias
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeAlias = try container.decodeIfPresent(ThemeAlias.self, forKey: .themeAlias)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case themeAlias = "ThemeAlias"
        }
    }

    public struct UpdateThemePermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the theme.
        public let awsAccountId: String
        /// A list of resource permissions to be granted for the theme.
        public let grantPermissions: [ResourcePermission]?
        /// A list of resource permissions to be revoked from the theme.
        public let revokePermissions: [ResourcePermission]?
        /// The ID for the theme.
        public let themeId: String

        public init(awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil, themeId: String) {
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
            self.themeId = themeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
            request.encodePath(self.themeId, key: "ThemeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateThemePermissionsResponse: AWSDecodableShape {
        /// The resulting list of resource permissions for the theme.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the theme.
        public let themeArn: String?
        /// The ID for the theme.
        public let themeId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, themeArn: String? = nil, themeId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.themeArn = themeArn
            self.themeId = themeId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeArn = try container.decodeIfPresent(String.self, forKey: .themeArn)
            self.themeId = try container.decodeIfPresent(String.self, forKey: .themeId)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case themeArn = "ThemeArn"
            case themeId = "ThemeId"
        }
    }

    public struct UpdateThemeRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the theme that you're updating.
        public let awsAccountId: String
        /// The theme ID, defined by Amazon QuickSight, that a custom theme inherits from.
        /// 		All themes initially inherit from a default Amazon QuickSight theme.
        public let baseThemeId: String
        /// The theme configuration, which contains the theme display properties.
        public let configuration: ThemeConfiguration?
        /// The name for the theme.
        public let name: String?
        /// The ID for the theme.
        public let themeId: String
        /// A description of the theme version that you're updating Every time that you call
        /// 				UpdateTheme, you create a new version of the theme. Each version of the
        /// 			theme maintains a description of the version in VersionDescription.
        public let versionDescription: String?

        public init(awsAccountId: String, baseThemeId: String, configuration: ThemeConfiguration? = nil, name: String? = nil, themeId: String, versionDescription: String? = nil) {
            self.awsAccountId = awsAccountId
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.name = name
            self.themeId = themeId
            self.versionDescription = versionDescription
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.baseThemeId, forKey: .baseThemeId)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.themeId, key: "ThemeId")
            try container.encodeIfPresent(self.versionDescription, forKey: .versionDescription)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, max: 512)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, min: 1)
            try self.validate(self.baseThemeId, name: "baseThemeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, max: 512)
            try self.validate(self.themeId, name: "themeId", parent: name, min: 1)
            try self.validate(self.themeId, name: "themeId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 512)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseThemeId = "BaseThemeId"
            case configuration = "Configuration"
            case name = "Name"
            case versionDescription = "VersionDescription"
        }
    }

    public struct UpdateThemeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the theme.
        public let arn: String?
        /// The creation status of the theme.
        public let creationStatus: ResourceStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID for the theme.
        public let themeId: String?
        /// The Amazon Resource Name (ARN) for the new version of the theme.
        public let versionArn: String?

        public init(arn: String? = nil, creationStatus: ResourceStatus? = nil, requestId: String? = nil, status: Int? = nil, themeId: String? = nil, versionArn: String? = nil) {
            self.arn = arn
            self.creationStatus = creationStatus
            self.requestId = requestId
            self.status = status
            self.themeId = themeId
            self.versionArn = versionArn
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.creationStatus = try container.decodeIfPresent(ResourceStatus.self, forKey: .creationStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.themeId = try container.decodeIfPresent(String.self, forKey: .themeId)
            self.versionArn = try container.decodeIfPresent(String.self, forKey: .versionArn)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationStatus = "CreationStatus"
            case requestId = "RequestId"
            case themeId = "ThemeId"
            case versionArn = "VersionArn"
        }
    }

    public struct UpdateTopicPermissionsRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic that you want to update the permissions for.
        public let awsAccountId: String
        /// The resource permissions that you want to grant to the topic.
        public let grantPermissions: [ResourcePermission]?
        /// The resource permissions that you want to revoke from the topic.
        public let revokePermissions: [ResourcePermission]?
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, grantPermissions: [ResourcePermission]? = nil, revokePermissions: [ResourcePermission]? = nil, topicId: String) {
            self.awsAccountId = awsAccountId
            self.grantPermissions = grantPermissions
            self.revokePermissions = revokePermissions
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.grantPermissions, forKey: .grantPermissions)
            try container.encodeIfPresent(self.revokePermissions, forKey: .revokePermissions)
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.grantPermissions?.forEach {
                try $0.validate(name: "\(name).grantPermissions[]")
            }
            try self.validate(self.grantPermissions, name: "grantPermissions", parent: name, max: 100)
            try self.revokePermissions?.forEach {
                try $0.validate(name: "\(name).revokePermissions[]")
            }
            try self.validate(self.revokePermissions, name: "revokePermissions", parent: name, max: 100)
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case grantPermissions = "GrantPermissions"
            case revokePermissions = "RevokePermissions"
        }
    }

    public struct UpdateTopicPermissionsResponse: AWSDecodableShape {
        /// A list of resource permissions on the topic.
        public let permissions: [ResourcePermission]?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the topic.
        public let topicArn: String?
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(permissions: [ResourcePermission]? = nil, requestId: String? = nil, status: Int? = nil, topicArn: String? = nil, topicId: String? = nil) {
            self.permissions = permissions
            self.requestId = requestId
            self.status = status
            self.topicArn = topicArn
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.permissions = try container.decodeIfPresent([ResourcePermission].self, forKey: .permissions)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicArn = try container.decodeIfPresent(String.self, forKey: .topicArn)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case requestId = "RequestId"
            case topicArn = "TopicArn"
            case topicId = "TopicId"
        }
    }

    public struct UpdateTopicRefreshScheduleRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic whose refresh schedule you want to update.
        public let awsAccountId: String
        /// The ID of the dataset.
        public let datasetId: String
        /// The definition of a refresh schedule.
        public let refreshSchedule: TopicRefreshSchedule
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, datasetId: String, refreshSchedule: TopicRefreshSchedule, topicId: String) {
            self.awsAccountId = awsAccountId
            self.datasetId = datasetId
            self.refreshSchedule = refreshSchedule
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            request.encodePath(self.datasetId, key: "DatasetId")
            try container.encode(self.refreshSchedule, forKey: .refreshSchedule)
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.refreshSchedule.validate(name: "\(name).refreshSchedule")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchedule = "RefreshSchedule"
        }
    }

    public struct UpdateTopicRefreshScheduleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon Resource Name (ARN) of the topic.
        public let topicArn: String?
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(datasetArn: String? = nil, requestId: String? = nil, status: Int? = nil, topicArn: String? = nil, topicId: String? = nil) {
            self.datasetArn = datasetArn
            self.requestId = requestId
            self.status = status
            self.topicArn = topicArn
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.datasetArn = try container.decodeIfPresent(String.self, forKey: .datasetArn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicArn = try container.decodeIfPresent(String.self, forKey: .topicArn)
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case requestId = "RequestId"
            case topicArn = "TopicArn"
            case topicId = "TopicId"
        }
    }

    public struct UpdateTopicRequest: AWSEncodableShape {
        /// The ID of the Amazon Web Services account that contains the topic that you want to update.
        public let awsAccountId: String
        /// The definition of the topic that you want to update.
        public let topic: TopicDetails
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String

        public init(awsAccountId: String, topic: TopicDetails, topicId: String) {
            self.awsAccountId = awsAccountId
            self.topic = topic
            self.topicId = topicId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encode(self.topic, forKey: .topic)
            request.encodePath(self.topicId, key: "TopicId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.topic.validate(name: "\(name).topic")
            try self.validate(self.topicId, name: "topicId", parent: name, max: 256)
            try self.validate(self.topicId, name: "topicId", parent: name, pattern: "^[A-Za-z0-9-_.\\\\+]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case topic = "Topic"
        }
    }

    public struct UpdateTopicResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the topic.
        public let arn: String?
        /// The Amazon Resource Name (ARN) of the topic refresh.
        public let refreshArn: String?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public let topicId: String?

        public init(arn: String? = nil, refreshArn: String? = nil, requestId: String? = nil, status: Int? = nil, topicId: String? = nil) {
            self.arn = arn
            self.refreshArn = refreshArn
            self.requestId = requestId
            self.status = status
            self.topicId = topicId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.refreshArn = try container.decodeIfPresent(String.self, forKey: .refreshArn)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.topicId = try container.decodeIfPresent(String.self, forKey: .topicId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case refreshArn = "RefreshArn"
            case requestId = "RequestId"
            case topicId = "TopicId"
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the
        /// 			Amazon Web Services account that contains your Amazon QuickSight account.
        public let awsAccountId: String
        /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
        public let customFederationProviderUrl: String?
        /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:   Create and update data sources   Create and update datasets   Create and update email reports   Subscribe to email reports   A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user.  Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
        public let customPermissionsName: String?
        /// The email address of the user that you want to update.
        public let email: String
        /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, don’t use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.    NONE: This clears all the previously saved external login information for a user. Use the  DescribeUser  API operation to check the external login information.
        public let externalLoginFederationProviderType: String?
        /// The identity ID for a user in the external login provider.
        public let externalLoginId: String?
        /// The namespace. Currently, you should set this to default.
        public let namespace: String
        /// The Amazon QuickSight role of the user. The role can be one of the
        /// 			following default security cohorts:    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and
        /// 					dashboards.    ADMIN: A user who is an author, who can also manage Amazon QuickSight
        /// 					settings.   The name of the Amazon QuickSight role is invisible to the user except for the console
        /// 	        screens dealing with permissions.
        public let role: UserRole
        /// A flag that you use to indicate that you want to remove all custom permissions from this user. Using this parameter resets the user to the state it was in before a custom permissions profile was applied. This parameter defaults to NULL and it doesn't accept any other value.
        public let unapplyCustomPermissions: Bool?
        /// The Amazon QuickSight user name that you want to update.
        public let userName: String

        public init(awsAccountId: String, customFederationProviderUrl: String? = nil, customPermissionsName: String? = nil, email: String, externalLoginFederationProviderType: String? = nil, externalLoginId: String? = nil, namespace: String, role: UserRole, unapplyCustomPermissions: Bool? = nil, userName: String) {
            self.awsAccountId = awsAccountId
            self.customFederationProviderUrl = customFederationProviderUrl
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginId = externalLoginId
            self.namespace = namespace
            self.role = role
            self.unapplyCustomPermissions = unapplyCustomPermissions
            self.userName = userName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.customFederationProviderUrl, forKey: .customFederationProviderUrl)
            try container.encodeIfPresent(self.customPermissionsName, forKey: .customPermissionsName)
            try container.encode(self.email, forKey: .email)
            try container.encodeIfPresent(self.externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
            try container.encodeIfPresent(self.externalLoginId, forKey: .externalLoginId)
            request.encodePath(self.namespace, key: "Namespace")
            try container.encode(self.role, forKey: .role)
            try container.encodeIfPresent(self.unapplyCustomPermissions, forKey: .unapplyCustomPermissions)
            request.encodePath(self.userName, key: "UserName")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, max: 64)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, min: 1)
            try self.validate(self.customPermissionsName, name: "customPermissionsName", parent: name, pattern: "^[a-zA-Z0-9+=,.@_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 64)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
            try self.validate(self.userName, name: "userName", parent: name, min: 1)
            try self.validate(self.userName, name: "userName", parent: name, pattern: "^[\\u0020-\\u00FF]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customFederationProviderUrl = "CustomFederationProviderUrl"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginId = "ExternalLoginId"
            case role = "Role"
            case unapplyCustomPermissions = "UnapplyCustomPermissions"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The Amazon QuickSight user.
        public let user: User?

        public init(requestId: String? = nil, status: Int? = nil, user: User? = nil) {
            self.requestId = requestId
            self.status = status
            self.user = user
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.user = try container.decodeIfPresent(User.self, forKey: .user)
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case user = "User"
        }
    }

    public struct UpdateVPCConnectionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the account that contains the VPC connection that
        /// 			you want to update.
        public let awsAccountId: String
        /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
        public let dnsResolvers: [String]?
        /// The display name for the VPC connection.
        public let name: String
        /// An IAM role associated with the VPC connection.
        public let roleArn: String
        /// A list of security group IDs for the VPC connection.
        public let securityGroupIds: [String]
        /// A list of subnet IDs for the VPC connection.
        public let subnetIds: [String]
        /// The ID of the VPC connection that
        /// 			you're updating. This ID is a unique identifier for each Amazon Web Services Region in an
        /// 				Amazon Web Services account.
        public let vpcConnectionId: String

        public init(awsAccountId: String, dnsResolvers: [String]? = nil, name: String, roleArn: String, securityGroupIds: [String], subnetIds: [String], vpcConnectionId: String) {
            self.awsAccountId = awsAccountId
            self.dnsResolvers = dnsResolvers
            self.name = name
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcConnectionId = vpcConnectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.awsAccountId, key: "AwsAccountId")
            try container.encodeIfPresent(self.dnsResolvers, forKey: .dnsResolvers)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.securityGroupIds, forKey: .securityGroupIds)
            try container.encode(self.subnetIds, forKey: .subnetIds)
            request.encodePath(self.vpcConnectionId, key: "VPCConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, min: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^[0-9]{12}$")
            try self.dnsResolvers?.forEach {
                try validate($0, name: "dnsResolvers[]", parent: name, max: 15)
                try validate($0, name: "dnsResolvers[]", parent: name, min: 7)
            }
            try self.validate(self.dnsResolvers, name: "dnsResolvers", parent: name, max: 15)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-z]*$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 16)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 255)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[0-9a-z]*$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 15)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 2)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, max: 1000)
            try self.validate(self.vpcConnectionId, name: "vpcConnectionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dnsResolvers = "DnsResolvers"
            case name = "Name"
            case roleArn = "RoleArn"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct UpdateVPCConnectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public let arn: String?
        /// The availability status of the VPC connection.
        public let availabilityStatus: VPCConnectionAvailabilityStatus?
        /// The Amazon Web Services request ID for this operation.
        public let requestId: String?
        /// The HTTP status of the request.
        public let status: Int?
        /// The update status of the VPC connection's last update.
        public let updateStatus: VPCConnectionResourceStatus?
        /// The ID of the VPC connection that you are updating. This ID is a unique identifier for each Amazon Web Services Region in anAmazon Web Services account.
        public let vpcConnectionId: String?

        public init(arn: String? = nil, availabilityStatus: VPCConnectionAvailabilityStatus? = nil, requestId: String? = nil, status: Int? = nil, updateStatus: VPCConnectionResourceStatus? = nil, vpcConnectionId: String? = nil) {
            self.arn = arn
            self.availabilityStatus = availabilityStatus
            self.requestId = requestId
            self.status = status
            self.updateStatus = updateStatus
            self.vpcConnectionId = vpcConnectionId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.arn = try container.decodeIfPresent(String.self, forKey: .arn)
            self.availabilityStatus = try container.decodeIfPresent(VPCConnectionAvailabilityStatus.self, forKey: .availabilityStatus)
            self.requestId = try container.decodeIfPresent(String.self, forKey: .requestId)
            self.status = response.decodeStatus()
            self.updateStatus = try container.decodeIfPresent(VPCConnectionResourceStatus.self, forKey: .updateStatus)
            self.vpcConnectionId = try container.decodeIfPresent(String.self, forKey: .vpcConnectionId)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case availabilityStatus = "AvailabilityStatus"
            case requestId = "RequestId"
            case updateStatus = "UpdateStatus"
            case vpcConnectionId = "VPCConnectionId"
        }
    }

    public struct UploadSettings: AWSEncodableShape & AWSDecodableShape {
        /// Whether the file has a header row, or the files each have a header row.
        public let containsHeader: Bool?
        /// The delimiter between values in the file.
        public let delimiter: String?
        /// File format.
        public let format: FileFormat?
        /// A row number to start reading data from.
        public let startFromRow: Int?
        /// Text qualifier.
        public let textQualifier: TextQualifier?

        public init(containsHeader: Bool? = nil, delimiter: String? = nil, format: FileFormat? = nil, startFromRow: Int? = nil, textQualifier: TextQualifier? = nil) {
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.format = format
            self.startFromRow = startFromRow
            self.textQualifier = textQualifier
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.startFromRow, name: "startFromRow", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case format = "Format"
            case startFromRow = "StartFromRow"
            case textQualifier = "TextQualifier"
        }
    }

    public struct User: AWSDecodableShape {
        /// The active status of user. When you create an Amazon QuickSight user that's not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.
        public let active: Bool?
        /// The Amazon Resource Name (ARN) for the user.
        public let arn: String?
        /// The custom permissions profile associated with this user.
        public let customPermissionsName: String?
        /// The user's email address.
        public let email: String?
        /// The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.    COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.    CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider.
        public let externalLoginFederationProviderType: String?
        /// The URL of the external login provider.
        public let externalLoginFederationProviderUrl: String?
        /// The identity ID for the user in the external login provider.
        public let externalLoginId: String?
        /// The type of identity authentication used by the user.
        public let identityType: IdentityType?
        /// The principal ID of the user.
        public let principalId: String?
        /// The Amazon QuickSight role for the user. The user role can be one of the following:.    READER: A user who has read-only access to dashboards.    AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.    ADMIN: A user who is an author, who can also manage Amazon Amazon QuickSight settings.    RESTRICTED_READER: This role isn't currently available for use.    RESTRICTED_AUTHOR: This role isn't currently available for use.
        public let role: UserRole?
        /// The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for UserName is N/A when the value for IdentityType is IAM and the corresponding IAM user is deleted.
        public let userName: String?

        public init(active: Bool? = nil, arn: String? = nil, customPermissionsName: String? = nil, email: String? = nil, externalLoginFederationProviderType: String? = nil, externalLoginFederationProviderUrl: String? = nil, externalLoginId: String? = nil, identityType: IdentityType? = nil, principalId: String? = nil, role: UserRole? = nil, userName: String? = nil) {
            self.active = active
            self.arn = arn
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginFederationProviderUrl = externalLoginFederationProviderUrl
            self.externalLoginId = externalLoginId
            self.identityType = identityType
            self.principalId = principalId
            self.role = role
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case active = "Active"
            case arn = "Arn"
            case customPermissionsName = "CustomPermissionsName"
            case email = "Email"
            case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
            case externalLoginFederationProviderUrl = "ExternalLoginFederationProviderUrl"
            case externalLoginId = "ExternalLoginId"
            case identityType = "IdentityType"
            case principalId = "PrincipalId"
            case role = "Role"
            case userName = "UserName"
        }
    }

    public struct VPCConnection: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public let arn: String?
        /// The availability status of the VPC connection.
        public let availabilityStatus: VPCConnectionAvailabilityStatus?
        /// The time that the VPC connection was created.
        public let createdTime: Date?
        /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
        public let dnsResolvers: [String]?
        /// The time that the VPC connection was last updated.
        public let lastUpdatedTime: Date?
        /// The display name for the VPC connection.
        public let name: String?
        /// A list of network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        /// The ARN of the IAM role associated with the VPC connection.
        public let roleArn: String?
        /// The Amazon EC2 security group IDs associated with the VPC connection.
        public let securityGroupIds: [String]?
        /// The status of the VPC connection.
        public let status: VPCConnectionResourceStatus?
        /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
        public let vpcConnectionId: String?
        /// The Amazon EC2 VPC ID associated with the VPC connection.
        public let vpcId: String?

        public init(arn: String? = nil, availabilityStatus: VPCConnectionAvailabilityStatus? = nil, createdTime: Date? = nil, dnsResolvers: [String]? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, networkInterfaces: [NetworkInterface]? = nil, roleArn: String? = nil, securityGroupIds: [String]? = nil, status: VPCConnectionResourceStatus? = nil, vpcConnectionId: String? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.availabilityStatus = availabilityStatus
            self.createdTime = createdTime
            self.dnsResolvers = dnsResolvers
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.networkInterfaces = networkInterfaces
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.vpcConnectionId = vpcConnectionId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case availabilityStatus = "AvailabilityStatus"
            case createdTime = "CreatedTime"
            case dnsResolvers = "DnsResolvers"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case networkInterfaces = "NetworkInterfaces"
            case roleArn = "RoleArn"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case vpcConnectionId = "VPCConnectionId"
            case vpcId = "VPCId"
        }
    }

    public struct VPCConnectionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public let arn: String?
        /// The availability status of the VPC connection.
        public let availabilityStatus: VPCConnectionAvailabilityStatus?
        /// The time that the VPC connection was created.
        public let createdTime: Date?
        /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
        public let dnsResolvers: [String]?
        /// The time that the VPC connection was last updated.
        public let lastUpdatedTime: Date?
        /// The display name for the VPC connection.
        public let name: String?
        /// A list of network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        /// The ARN of the IAM role associated with the VPC connection.
        public let roleArn: String?
        /// The Amazon EC2 security group IDs associated with the VPC connection.
        public let securityGroupIds: [String]?
        /// The status of the VPC connection.
        public let status: VPCConnectionResourceStatus?
        /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
        public let vpcConnectionId: String?
        /// The Amazon EC2 VPC ID associated with the VPC connection.
        public let vpcId: String?

        public init(arn: String? = nil, availabilityStatus: VPCConnectionAvailabilityStatus? = nil, createdTime: Date? = nil, dnsResolvers: [String]? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, networkInterfaces: [NetworkInterface]? = nil, roleArn: String? = nil, securityGroupIds: [String]? = nil, status: VPCConnectionResourceStatus? = nil, vpcConnectionId: String? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.availabilityStatus = availabilityStatus
            self.createdTime = createdTime
            self.dnsResolvers = dnsResolvers
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.networkInterfaces = networkInterfaces
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.vpcConnectionId = vpcConnectionId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case availabilityStatus = "AvailabilityStatus"
            case createdTime = "CreatedTime"
            case dnsResolvers = "DnsResolvers"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case networkInterfaces = "NetworkInterfaces"
            case roleArn = "RoleArn"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case vpcConnectionId = "VPCConnectionId"
            case vpcId = "VPCId"
        }
    }

    public struct ValidationStrategy: AWSEncodableShape {
        /// The mode of validation for the asset to be created or updated. When you set this value to STRICT, strict validation for every error is enforced. When you set this value to LENIENT, validation is skipped for specific UI errors.
        public let mode: ValidationStrategyMode

        public init(mode: ValidationStrategyMode) {
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct VisibleRangeOptions: AWSEncodableShape & AWSDecodableShape {
        /// The percent range in the visible range.
        public let percentRange: PercentVisibleRange?

        public init(percentRange: PercentVisibleRange? = nil) {
            self.percentRange = percentRange
        }

        public func validate(name: String) throws {
            try self.percentRange?.validate(name: "\(name).percentRange")
        }

        private enum CodingKeys: String, CodingKey {
            case percentRange = "PercentRange"
        }
    }

    public struct Visual: AWSEncodableShape & AWSDecodableShape {
        /// A bar chart. For more information, see Using bar charts in the Amazon QuickSight User Guide.
        public let barChartVisual: BarChartVisual?
        /// A box plot. For more information, see Using box plots in the Amazon QuickSight User Guide.
        public let boxPlotVisual: BoxPlotVisual?
        /// A combo chart. For more information, see Using combo charts in the Amazon QuickSight User Guide.
        public let comboChartVisual: ComboChartVisual?
        /// A visual that contains custom content. For more information, see Using custom visual content in the Amazon QuickSight User Guide.
        public let customContentVisual: CustomContentVisual?
        /// An empty visual.
        public let emptyVisual: EmptyVisual?
        /// A filled map. For more information, see Creating filled maps in the Amazon QuickSight User Guide.
        public let filledMapVisual: FilledMapVisual?
        /// A funnel chart. For more information, see Using funnel charts in the Amazon QuickSight User Guide.
        public let funnelChartVisual: FunnelChartVisual?
        /// A gauge chart. For more information, see Using gauge charts in the Amazon QuickSight User Guide.
        public let gaugeChartVisual: GaugeChartVisual?
        /// A geospatial map or a points on map visual. For more information, see Creating point maps in the Amazon QuickSight User Guide.
        public let geospatialMapVisual: GeospatialMapVisual?
        /// A heat map. For more information, see Using heat maps in the Amazon QuickSight User Guide.
        public let heatMapVisual: HeatMapVisual?
        /// A histogram. For more information, see Using histograms in the Amazon QuickSight User Guide.
        public let histogramVisual: HistogramVisual?
        /// An insight visual. For more information, see Working with insights in the Amazon QuickSight User Guide.
        public let insightVisual: InsightVisual?
        /// A key performance indicator (KPI). For more information, see Using KPIs in the Amazon QuickSight User Guide.
        public let kpiVisual: KPIVisual?
        /// A line chart. For more information, see Using line charts in the Amazon QuickSight User Guide.
        public let lineChartVisual: LineChartVisual?
        /// A pie or donut chart. For more information, see Using pie charts in the Amazon QuickSight User Guide.
        public let pieChartVisual: PieChartVisual?
        /// A pivot table. For more information, see Using pivot tables in the Amazon QuickSight User Guide.
        public let pivotTableVisual: PivotTableVisual?
        /// A radar chart visual. For more information, see Using radar charts in the Amazon QuickSight User Guide.
        public let radarChartVisual: RadarChartVisual?
        /// A sankey diagram. For more information, see Using Sankey diagrams in the Amazon QuickSight User Guide.
        public let sankeyDiagramVisual: SankeyDiagramVisual?
        /// A scatter plot. For more information, see Using scatter plots in the Amazon QuickSight User Guide.
        public let scatterPlotVisual: ScatterPlotVisual?
        /// A table visual. For more information, see Using tables as visuals in the Amazon QuickSight User Guide.
        public let tableVisual: TableVisual?
        /// A tree map. For more information, see Using tree maps in the Amazon QuickSight User Guide.
        public let treeMapVisual: TreeMapVisual?
        /// A waterfall chart. For more information, see Using waterfall charts in the Amazon QuickSight User Guide.
        public let waterfallVisual: WaterfallVisual?
        /// A word cloud. For more information, see Using word clouds in the Amazon QuickSight User Guide.
        public let wordCloudVisual: WordCloudVisual?

        public init(barChartVisual: BarChartVisual? = nil, boxPlotVisual: BoxPlotVisual? = nil, comboChartVisual: ComboChartVisual? = nil, customContentVisual: CustomContentVisual? = nil, emptyVisual: EmptyVisual? = nil, filledMapVisual: FilledMapVisual? = nil, funnelChartVisual: FunnelChartVisual? = nil, gaugeChartVisual: GaugeChartVisual? = nil, geospatialMapVisual: GeospatialMapVisual? = nil, heatMapVisual: HeatMapVisual? = nil, histogramVisual: HistogramVisual? = nil, insightVisual: InsightVisual? = nil, kpiVisual: KPIVisual? = nil, lineChartVisual: LineChartVisual? = nil, pieChartVisual: PieChartVisual? = nil, pivotTableVisual: PivotTableVisual? = nil, radarChartVisual: RadarChartVisual? = nil, sankeyDiagramVisual: SankeyDiagramVisual? = nil, scatterPlotVisual: ScatterPlotVisual? = nil, tableVisual: TableVisual? = nil, treeMapVisual: TreeMapVisual? = nil, waterfallVisual: WaterfallVisual? = nil, wordCloudVisual: WordCloudVisual? = nil) {
            self.barChartVisual = barChartVisual
            self.boxPlotVisual = boxPlotVisual
            self.comboChartVisual = comboChartVisual
            self.customContentVisual = customContentVisual
            self.emptyVisual = emptyVisual
            self.filledMapVisual = filledMapVisual
            self.funnelChartVisual = funnelChartVisual
            self.gaugeChartVisual = gaugeChartVisual
            self.geospatialMapVisual = geospatialMapVisual
            self.heatMapVisual = heatMapVisual
            self.histogramVisual = histogramVisual
            self.insightVisual = insightVisual
            self.kpiVisual = kpiVisual
            self.lineChartVisual = lineChartVisual
            self.pieChartVisual = pieChartVisual
            self.pivotTableVisual = pivotTableVisual
            self.radarChartVisual = radarChartVisual
            self.sankeyDiagramVisual = sankeyDiagramVisual
            self.scatterPlotVisual = scatterPlotVisual
            self.tableVisual = tableVisual
            self.treeMapVisual = treeMapVisual
            self.waterfallVisual = waterfallVisual
            self.wordCloudVisual = wordCloudVisual
        }

        public func validate(name: String) throws {
            try self.barChartVisual?.validate(name: "\(name).barChartVisual")
            try self.boxPlotVisual?.validate(name: "\(name).boxPlotVisual")
            try self.comboChartVisual?.validate(name: "\(name).comboChartVisual")
            try self.customContentVisual?.validate(name: "\(name).customContentVisual")
            try self.emptyVisual?.validate(name: "\(name).emptyVisual")
            try self.filledMapVisual?.validate(name: "\(name).filledMapVisual")
            try self.funnelChartVisual?.validate(name: "\(name).funnelChartVisual")
            try self.gaugeChartVisual?.validate(name: "\(name).gaugeChartVisual")
            try self.geospatialMapVisual?.validate(name: "\(name).geospatialMapVisual")
            try self.heatMapVisual?.validate(name: "\(name).heatMapVisual")
            try self.histogramVisual?.validate(name: "\(name).histogramVisual")
            try self.insightVisual?.validate(name: "\(name).insightVisual")
            try self.kpiVisual?.validate(name: "\(name).kpiVisual")
            try self.lineChartVisual?.validate(name: "\(name).lineChartVisual")
            try self.pieChartVisual?.validate(name: "\(name).pieChartVisual")
            try self.pivotTableVisual?.validate(name: "\(name).pivotTableVisual")
            try self.radarChartVisual?.validate(name: "\(name).radarChartVisual")
            try self.sankeyDiagramVisual?.validate(name: "\(name).sankeyDiagramVisual")
            try self.scatterPlotVisual?.validate(name: "\(name).scatterPlotVisual")
            try self.tableVisual?.validate(name: "\(name).tableVisual")
            try self.treeMapVisual?.validate(name: "\(name).treeMapVisual")
            try self.waterfallVisual?.validate(name: "\(name).waterfallVisual")
            try self.wordCloudVisual?.validate(name: "\(name).wordCloudVisual")
        }

        private enum CodingKeys: String, CodingKey {
            case barChartVisual = "BarChartVisual"
            case boxPlotVisual = "BoxPlotVisual"
            case comboChartVisual = "ComboChartVisual"
            case customContentVisual = "CustomContentVisual"
            case emptyVisual = "EmptyVisual"
            case filledMapVisual = "FilledMapVisual"
            case funnelChartVisual = "FunnelChartVisual"
            case gaugeChartVisual = "GaugeChartVisual"
            case geospatialMapVisual = "GeospatialMapVisual"
            case heatMapVisual = "HeatMapVisual"
            case histogramVisual = "HistogramVisual"
            case insightVisual = "InsightVisual"
            case kpiVisual = "KPIVisual"
            case lineChartVisual = "LineChartVisual"
            case pieChartVisual = "PieChartVisual"
            case pivotTableVisual = "PivotTableVisual"
            case radarChartVisual = "RadarChartVisual"
            case sankeyDiagramVisual = "SankeyDiagramVisual"
            case scatterPlotVisual = "ScatterPlotVisual"
            case tableVisual = "TableVisual"
            case treeMapVisual = "TreeMapVisual"
            case waterfallVisual = "WaterfallVisual"
            case wordCloudVisual = "WordCloudVisual"
        }
    }

    public struct VisualAxisSortOption: AWSEncodableShape & AWSDecodableShape {
        /// The availaiblity status of a visual's axis sort options.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct VisualCustomAction: AWSEncodableShape & AWSDecodableShape {
        /// A list of VisualCustomActionOperations. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        public let actionOperations: [VisualCustomActionOperation]
        /// The ID of the VisualCustomAction.
        public let customActionId: String
        /// The name of the VisualCustomAction.
        public let name: String
        /// The status of the VisualCustomAction.
        public let status: WidgetStatus?
        /// The trigger of the VisualCustomAction. Valid values are defined as follows:    DATA_POINT_CLICK: Initiates a custom action by a left pointer click on a data point.    DATA_POINT_MENU: Initiates a custom action by right pointer click from the menu.
        public let trigger: VisualCustomActionTrigger

        public init(actionOperations: [VisualCustomActionOperation], customActionId: String, name: String, status: WidgetStatus? = nil, trigger: VisualCustomActionTrigger) {
            self.actionOperations = actionOperations
            self.customActionId = customActionId
            self.name = name
            self.status = status
            self.trigger = trigger
        }

        public func validate(name: String) throws {
            try self.actionOperations.forEach {
                try $0.validate(name: "\(name).actionOperations[]")
            }
            try self.validate(self.actionOperations, name: "actionOperations", parent: name, max: 2)
            try self.validate(self.actionOperations, name: "actionOperations", parent: name, min: 1)
            try self.validate(self.customActionId, name: "customActionId", parent: name, max: 512)
            try self.validate(self.customActionId, name: "customActionId", parent: name, min: 1)
            try self.validate(self.customActionId, name: "customActionId", parent: name, pattern: "^[\\w\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionOperations = "ActionOperations"
            case customActionId = "CustomActionId"
            case name = "Name"
            case status = "Status"
            case trigger = "Trigger"
        }
    }

    public struct VisualCustomActionOperation: AWSEncodableShape & AWSDecodableShape {
        /// The filter operation that filters data included in a visual or in an entire sheet.
        public let filterOperation: CustomActionFilterOperation?
        /// The navigation operation that navigates between different sheets in the same analysis.
        public let navigationOperation: CustomActionNavigationOperation?
        /// The set parameter operation that sets parameters in custom action.
        public let setParametersOperation: CustomActionSetParametersOperation?
        /// The URL operation that opens a link to another webpage.
        public let urlOperation: CustomActionURLOperation?

        public init(filterOperation: CustomActionFilterOperation? = nil, navigationOperation: CustomActionNavigationOperation? = nil, setParametersOperation: CustomActionSetParametersOperation? = nil, urlOperation: CustomActionURLOperation? = nil) {
            self.filterOperation = filterOperation
            self.navigationOperation = navigationOperation
            self.setParametersOperation = setParametersOperation
            self.urlOperation = urlOperation
        }

        public func validate(name: String) throws {
            try self.filterOperation?.validate(name: "\(name).filterOperation")
            try self.navigationOperation?.validate(name: "\(name).navigationOperation")
            try self.setParametersOperation?.validate(name: "\(name).setParametersOperation")
            try self.urlOperation?.validate(name: "\(name).urlOperation")
        }

        private enum CodingKeys: String, CodingKey {
            case filterOperation = "FilterOperation"
            case navigationOperation = "NavigationOperation"
            case setParametersOperation = "SetParametersOperation"
            case urlOperation = "URLOperation"
        }
    }

    public struct VisualInteractionOptions: AWSEncodableShape & AWSDecodableShape {
        /// The context menu options for a visual.
        public let contextMenuOption: ContextMenuOption?
        /// The on-visual menu options for a visual.
        public let visualMenuOption: VisualMenuOption?

        public init(contextMenuOption: ContextMenuOption? = nil, visualMenuOption: VisualMenuOption? = nil) {
            self.contextMenuOption = contextMenuOption
            self.visualMenuOption = visualMenuOption
        }

        private enum CodingKeys: String, CodingKey {
            case contextMenuOption = "ContextMenuOption"
            case visualMenuOption = "VisualMenuOption"
        }
    }

    public struct VisualMenuOption: AWSEncodableShape & AWSDecodableShape {
        /// The availaiblity status of a visual's menu options.
        public let availabilityStatus: DashboardBehavior?

        public init(availabilityStatus: DashboardBehavior? = nil) {
            self.availabilityStatus = availabilityStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityStatus = "AvailabilityStatus"
        }
    }

    public struct VisualPalette: AWSEncodableShape & AWSDecodableShape {
        /// The chart color options for the visual palette.
        public let chartColor: String?
        /// The color map options for the visual palette.
        public let colorMap: [DataPathColor]?

        public init(chartColor: String? = nil, colorMap: [DataPathColor]? = nil) {
            self.chartColor = chartColor
            self.colorMap = colorMap
        }

        public func validate(name: String) throws {
            try self.validate(self.chartColor, name: "chartColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.colorMap?.forEach {
                try $0.validate(name: "\(name).colorMap[]")
            }
            try self.validate(self.colorMap, name: "colorMap", parent: name, max: 5000)
        }

        private enum CodingKeys: String, CodingKey {
            case chartColor = "ChartColor"
            case colorMap = "ColorMap"
        }
    }

    public struct VisualSubtitleLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The long text format of the subtitle label, such as plain text or rich text.
        public let formatText: LongFormatText?
        /// The visibility of the subtitle label.
        public let visibility: Visibility?

        public init(formatText: LongFormatText? = nil, visibility: Visibility? = nil) {
            self.formatText = formatText
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.formatText?.validate(name: "\(name).formatText")
        }

        private enum CodingKeys: String, CodingKey {
            case formatText = "FormatText"
            case visibility = "Visibility"
        }
    }

    public struct VisualTitleLabelOptions: AWSEncodableShape & AWSDecodableShape {
        /// The short text format of the title label, such as plain text or rich text.
        public let formatText: ShortFormatText?
        /// The visibility of the title label.
        public let visibility: Visibility?

        public init(formatText: ShortFormatText? = nil, visibility: Visibility? = nil) {
            self.formatText = formatText
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.formatText?.validate(name: "\(name).formatText")
        }

        private enum CodingKeys: String, CodingKey {
            case formatText = "FormatText"
            case visibility = "Visibility"
        }
    }

    public struct VpcConnectionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the VPC connection.
        public let vpcConnectionArn: String

        public init(vpcConnectionArn: String) {
            self.vpcConnectionArn = vpcConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConnectionArn = "VpcConnectionArn"
        }
    }

    public struct WaterfallChartAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The breakdown field wells of a waterfall visual.
        public let breakdowns: [DimensionField]?
        /// The category field wells of a waterfall visual.
        public let categories: [DimensionField]?
        /// The value field wells of a waterfall visual.
        public let values: [MeasureField]?

        public init(breakdowns: [DimensionField]? = nil, categories: [DimensionField]? = nil, values: [MeasureField]? = nil) {
            self.breakdowns = breakdowns
            self.categories = categories
            self.values = values
        }

        public func validate(name: String) throws {
            try self.breakdowns?.forEach {
                try $0.validate(name: "\(name).breakdowns[]")
            }
            try self.validate(self.breakdowns, name: "breakdowns", parent: name, max: 200)
            try self.categories?.forEach {
                try $0.validate(name: "\(name).categories[]")
            }
            try self.validate(self.categories, name: "categories", parent: name, max: 200)
            try self.values?.forEach {
                try $0.validate(name: "\(name).values[]")
            }
            try self.validate(self.values, name: "values", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case breakdowns = "Breakdowns"
            case categories = "Categories"
            case values = "Values"
        }
    }

    public struct WaterfallChartColorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The color configuration for individual groups within a waterfall visual.
        public let groupColorConfiguration: WaterfallChartGroupColorConfiguration?

        public init(groupColorConfiguration: WaterfallChartGroupColorConfiguration? = nil) {
            self.groupColorConfiguration = groupColorConfiguration
        }

        public func validate(name: String) throws {
            try self.groupColorConfiguration?.validate(name: "\(name).groupColorConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case groupColorConfiguration = "GroupColorConfiguration"
        }
    }

    public struct WaterfallChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The options that determine the presentation of the category axis.
        public let categoryAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the category axis label.
        public let categoryAxisLabelOptions: ChartAxisLabelOptions?
        /// The color configuration of a waterfall visual.
        public let colorConfiguration: WaterfallChartColorConfiguration?
        /// The data label configuration of a waterfall visual.
        public let dataLabels: DataLabelOptions?
        /// The field well configuration of a waterfall visual.
        public let fieldWells: WaterfallChartFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The legend configuration of a waterfall visual.
        public let legend: LegendOptions?
        /// The options that determine the presentation of the y-axis.
        public let primaryYAxisDisplayOptions: AxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public let primaryYAxisLabelOptions: ChartAxisLabelOptions?
        /// The sort configuration of a waterfall visual.
        public let sortConfiguration: WaterfallChartSortConfiguration?
        /// The visual palette configuration of a waterfall visual.
        public let visualPalette: VisualPalette?
        /// The options that determine the presentation of a waterfall visual.
        public let waterfallChartOptions: WaterfallChartOptions?

        public init(categoryAxisDisplayOptions: AxisDisplayOptions? = nil, categoryAxisLabelOptions: ChartAxisLabelOptions? = nil, colorConfiguration: WaterfallChartColorConfiguration? = nil, dataLabels: DataLabelOptions? = nil, fieldWells: WaterfallChartFieldWells? = nil, interactions: VisualInteractionOptions? = nil, legend: LegendOptions? = nil, primaryYAxisDisplayOptions: AxisDisplayOptions? = nil, primaryYAxisLabelOptions: ChartAxisLabelOptions? = nil, sortConfiguration: WaterfallChartSortConfiguration? = nil, visualPalette: VisualPalette? = nil, waterfallChartOptions: WaterfallChartOptions? = nil) {
            self.categoryAxisDisplayOptions = categoryAxisDisplayOptions
            self.categoryAxisLabelOptions = categoryAxisLabelOptions
            self.colorConfiguration = colorConfiguration
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.sortConfiguration = sortConfiguration
            self.visualPalette = visualPalette
            self.waterfallChartOptions = waterfallChartOptions
        }

        public func validate(name: String) throws {
            try self.categoryAxisDisplayOptions?.validate(name: "\(name).categoryAxisDisplayOptions")
            try self.categoryAxisLabelOptions?.validate(name: "\(name).categoryAxisLabelOptions")
            try self.colorConfiguration?.validate(name: "\(name).colorConfiguration")
            try self.dataLabels?.validate(name: "\(name).dataLabels")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.legend?.validate(name: "\(name).legend")
            try self.primaryYAxisDisplayOptions?.validate(name: "\(name).primaryYAxisDisplayOptions")
            try self.primaryYAxisLabelOptions?.validate(name: "\(name).primaryYAxisLabelOptions")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.visualPalette?.validate(name: "\(name).visualPalette")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryAxisDisplayOptions = "CategoryAxisDisplayOptions"
            case categoryAxisLabelOptions = "CategoryAxisLabelOptions"
            case colorConfiguration = "ColorConfiguration"
            case dataLabels = "DataLabels"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case legend = "Legend"
            case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
            case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
            case sortConfiguration = "SortConfiguration"
            case visualPalette = "VisualPalette"
            case waterfallChartOptions = "WaterfallChartOptions"
        }
    }

    public struct WaterfallChartFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The field well configuration of a waterfall visual.
        public let waterfallChartAggregatedFieldWells: WaterfallChartAggregatedFieldWells?

        public init(waterfallChartAggregatedFieldWells: WaterfallChartAggregatedFieldWells? = nil) {
            self.waterfallChartAggregatedFieldWells = waterfallChartAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.waterfallChartAggregatedFieldWells?.validate(name: "\(name).waterfallChartAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case waterfallChartAggregatedFieldWells = "WaterfallChartAggregatedFieldWells"
        }
    }

    public struct WaterfallChartGroupColorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the color for the negative bars of a waterfall chart.
        public let negativeBarColor: String?
        /// Defines the color for the positive bars of a waterfall chart.
        public let positiveBarColor: String?
        /// Defines the color for the total bars of a waterfall chart.
        public let totalBarColor: String?

        public init(negativeBarColor: String? = nil, positiveBarColor: String? = nil, totalBarColor: String? = nil) {
            self.negativeBarColor = negativeBarColor
            self.positiveBarColor = positiveBarColor
            self.totalBarColor = totalBarColor
        }

        public func validate(name: String) throws {
            try self.validate(self.negativeBarColor, name: "negativeBarColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.positiveBarColor, name: "positiveBarColor", parent: name, pattern: "^#[A-F0-9]{6}$")
            try self.validate(self.totalBarColor, name: "totalBarColor", parent: name, pattern: "^#[A-F0-9]{6}$")
        }

        private enum CodingKeys: String, CodingKey {
            case negativeBarColor = "NegativeBarColor"
            case positiveBarColor = "PositiveBarColor"
            case totalBarColor = "TotalBarColor"
        }
    }

    public struct WaterfallChartOptions: AWSEncodableShape & AWSDecodableShape {
        /// This option determines the total bar label of a waterfall visual.
        public let totalBarLabel: String?

        public init(totalBarLabel: String? = nil) {
            self.totalBarLabel = totalBarLabel
        }

        private enum CodingKeys: String, CodingKey {
            case totalBarLabel = "TotalBarLabel"
        }
    }

    public struct WaterfallChartSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of bar groups that are displayed.
        public let breakdownItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public let categorySort: [FieldSortOptions]?

        public init(breakdownItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil) {
            self.breakdownItemsLimit = breakdownItemsLimit
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case breakdownItemsLimit = "BreakdownItemsLimit"
            case categorySort = "CategorySort"
        }
    }

    public struct WaterfallVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration for a waterfall visual.
        public let chartConfiguration: WaterfallChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: WaterfallChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct WhatIfPointScenario: AWSEncodableShape & AWSDecodableShape {
        /// The date that you need the forecast results for.
        public let date: Date
        /// The target value that you want to meet for the provided date.
        public let value: Double

        public init(date: Date, value: Double) {
            self.date = date
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case value = "Value"
        }
    }

    public struct WhatIfRangeScenario: AWSEncodableShape & AWSDecodableShape {
        /// The end date in the date range that you need the forecast results for.
        public let endDate: Date
        /// The start date in the date range that you need the forecast results for.
        public let startDate: Date
        /// The target value that you want to meet for the provided date range.
        public let value: Double

        public init(endDate: Date, startDate: Date, value: Double) {
            self.endDate = endDate
            self.startDate = startDate
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case startDate = "StartDate"
            case value = "Value"
        }
    }

    public struct WordCloudAggregatedFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The group by field well of a word cloud. Values are grouped by group by fields.
        public let groupBy: [DimensionField]?
        /// The size field well of a word cloud. Values are aggregated based on group by fields.
        public let size: [MeasureField]?

        public init(groupBy: [DimensionField]? = nil, size: [MeasureField]? = nil) {
            self.groupBy = groupBy
            self.size = size
        }

        public func validate(name: String) throws {
            try self.groupBy?.forEach {
                try $0.validate(name: "\(name).groupBy[]")
            }
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 10)
            try self.size?.forEach {
                try $0.validate(name: "\(name).size[]")
            }
            try self.validate(self.size, name: "size", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case size = "Size"
        }
    }

    public struct WordCloudChartConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The label options (label text, label visibility, and sort icon visibility) for the word cloud category.
        public let categoryLabelOptions: ChartAxisLabelOptions?
        /// The field wells of the visual.
        public let fieldWells: WordCloudFieldWells?
        /// The general visual interactions setup for a visual.
        public let interactions: VisualInteractionOptions?
        /// The sort configuration of a word cloud visual.
        public let sortConfiguration: WordCloudSortConfiguration?
        /// The options for a word cloud visual.
        public let wordCloudOptions: WordCloudOptions?

        public init(categoryLabelOptions: ChartAxisLabelOptions? = nil, fieldWells: WordCloudFieldWells? = nil, interactions: VisualInteractionOptions? = nil, sortConfiguration: WordCloudSortConfiguration? = nil, wordCloudOptions: WordCloudOptions? = nil) {
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.sortConfiguration = sortConfiguration
            self.wordCloudOptions = wordCloudOptions
        }

        public func validate(name: String) throws {
            try self.categoryLabelOptions?.validate(name: "\(name).categoryLabelOptions")
            try self.fieldWells?.validate(name: "\(name).fieldWells")
            try self.sortConfiguration?.validate(name: "\(name).sortConfiguration")
            try self.wordCloudOptions?.validate(name: "\(name).wordCloudOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case categoryLabelOptions = "CategoryLabelOptions"
            case fieldWells = "FieldWells"
            case interactions = "Interactions"
            case sortConfiguration = "SortConfiguration"
            case wordCloudOptions = "WordCloudOptions"
        }
    }

    public struct WordCloudFieldWells: AWSEncodableShape & AWSDecodableShape {
        /// The aggregated field wells of a word cloud.
        public let wordCloudAggregatedFieldWells: WordCloudAggregatedFieldWells?

        public init(wordCloudAggregatedFieldWells: WordCloudAggregatedFieldWells? = nil) {
            self.wordCloudAggregatedFieldWells = wordCloudAggregatedFieldWells
        }

        public func validate(name: String) throws {
            try self.wordCloudAggregatedFieldWells?.validate(name: "\(name).wordCloudAggregatedFieldWells")
        }

        private enum CodingKeys: String, CodingKey {
            case wordCloudAggregatedFieldWells = "WordCloudAggregatedFieldWells"
        }
    }

    public struct WordCloudOptions: AWSEncodableShape & AWSDecodableShape {
        /// The cloud layout options (fluid, normal) of a word cloud.
        public let cloudLayout: WordCloudCloudLayout?
        /// The length limit of each word from 1-100.
        public let maximumStringLength: Int?
        /// The word casing options (lower_case, existing_case) for the words in a word cloud.
        public let wordCasing: WordCloudWordCasing?
        /// The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.
        public let wordOrientation: WordCloudWordOrientation?
        /// The word padding options (none, small, medium, large) for the words in a word cloud.
        public let wordPadding: WordCloudWordPadding?
        /// The word scaling options (emphasize, normal) for the words in a word cloud.
        public let wordScaling: WordCloudWordScaling?

        public init(cloudLayout: WordCloudCloudLayout? = nil, maximumStringLength: Int? = nil, wordCasing: WordCloudWordCasing? = nil, wordOrientation: WordCloudWordOrientation? = nil, wordPadding: WordCloudWordPadding? = nil, wordScaling: WordCloudWordScaling? = nil) {
            self.cloudLayout = cloudLayout
            self.maximumStringLength = maximumStringLength
            self.wordCasing = wordCasing
            self.wordOrientation = wordOrientation
            self.wordPadding = wordPadding
            self.wordScaling = wordScaling
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumStringLength, name: "maximumStringLength", parent: name, max: 100)
            try self.validate(self.maximumStringLength, name: "maximumStringLength", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cloudLayout = "CloudLayout"
            case maximumStringLength = "MaximumStringLength"
            case wordCasing = "WordCasing"
            case wordOrientation = "WordOrientation"
            case wordPadding = "WordPadding"
            case wordScaling = "WordScaling"
        }
    }

    public struct WordCloudSortConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The limit on the number of groups that are displayed in a word cloud.
        public let categoryItemsLimit: ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public let categorySort: [FieldSortOptions]?

        public init(categoryItemsLimit: ItemsLimitConfiguration? = nil, categorySort: [FieldSortOptions]? = nil) {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }

        public func validate(name: String) throws {
            try self.categorySort?.forEach {
                try $0.validate(name: "\(name).categorySort[]")
            }
            try self.validate(self.categorySort, name: "categorySort", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryItemsLimit = "CategoryItemsLimit"
            case categorySort = "CategorySort"
        }
    }

    public struct WordCloudVisual: AWSEncodableShape & AWSDecodableShape {
        /// The list of custom actions that are configured for a visual.
        public let actions: [VisualCustomAction]?
        /// The configuration settings of the visual.
        public let chartConfiguration: WordCloudChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public let columnHierarchies: [ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public let subtitle: VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public let title: VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        public let visualId: String

        public init(actions: [VisualCustomAction]? = nil, chartConfiguration: WordCloudChartConfiguration? = nil, columnHierarchies: [ColumnHierarchy]? = nil, subtitle: VisualSubtitleLabelOptions? = nil, title: VisualTitleLabelOptions? = nil, visualId: String) {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.chartConfiguration?.validate(name: "\(name).chartConfiguration")
            try self.columnHierarchies?.forEach {
                try $0.validate(name: "\(name).columnHierarchies[]")
            }
            try self.validate(self.columnHierarchies, name: "columnHierarchies", parent: name, max: 2)
            try self.subtitle?.validate(name: "\(name).subtitle")
            try self.title?.validate(name: "\(name).title")
            try self.validate(self.visualId, name: "visualId", parent: name, max: 512)
            try self.validate(self.visualId, name: "visualId", parent: name, min: 1)
            try self.validate(self.visualId, name: "visualId", parent: name, pattern: "^[\\w\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case chartConfiguration = "ChartConfiguration"
            case columnHierarchies = "ColumnHierarchies"
            case subtitle = "Subtitle"
            case title = "Title"
            case visualId = "VisualId"
        }
    }

    public struct YAxisOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Y axis type to be used in the chart. If you choose PRIMARY_Y_AXIS, the primary Y Axis is located on the leftmost vertical axis of the chart.
        public let yAxis: SingleYAxisOption

        public init(yAxis: SingleYAxisOption) {
            self.yAxis = yAxis
        }

        private enum CodingKeys: String, CodingKey {
            case yAxis = "YAxis"
        }
    }
}

// MARK: - Errors

/// Error enum for QuickSight
public struct QuickSightErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case concurrentUpdatingException = "ConcurrentUpdatingException"
        case conflictException = "ConflictException"
        case domainNotWhitelistedException = "DomainNotWhitelistedException"
        case identityTypeNotSupportedException = "IdentityTypeNotSupportedException"
        case internalFailureException = "InternalFailureException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case preconditionNotMetException = "PreconditionNotMetException"
        case quickSightUserNotFoundException = "QuickSightUserNotFoundException"
        case resourceExistsException = "ResourceExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceUnavailableException = "ResourceUnavailableException"
        case sessionLifetimeInMinutesInvalidException = "SessionLifetimeInMinutesInvalidException"
        case throttlingException = "ThrottlingException"
        case unsupportedPricingPlanException = "UnsupportedPricingPlanException"
        case unsupportedUserEditionException = "UnsupportedUserEditionException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QuickSight
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have access to this item. The provided credentials couldn't be
    /// 			validated. You might not be authorized to carry out the request. Make sure that your
    /// 			account is authorized to use the Amazon QuickSight service, that your policies have the
    /// 			correct permissions, and that you are using the correct credentials.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A resource is already in a state that indicates an operation is happening that must complete
    /// 			before a new update can be applied.
    public static var concurrentUpdatingException: Self { .init(.concurrentUpdatingException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// The domain specified isn't on the allow list. All domains for embedded dashboards must be
    /// 			added to the approved list by an Amazon QuickSight admin.
    public static var domainNotWhitelistedException: Self { .init(.domainNotWhitelistedException) }
    /// The identity type specified isn't supported. Supported identity types include
    /// 				IAM and QUICKSIGHT.
    public static var identityTypeNotSupportedException: Self { .init(.identityTypeNotSupportedException) }
    /// An internal failure occurred.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// The NextToken value isn't valid.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// One or more parameters has a value that isn't valid.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// You don't have this feature activated for your account. To fix this issue, contact Amazon Web Services support.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// A limit is exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// One or more preconditions aren't met.
    public static var preconditionNotMetException: Self { .init(.preconditionNotMetException) }
    /// The user with the provided name isn't found. This error can happen in any operation
    /// 			that requires finding a user based on a provided user name, such as
    /// 				DeleteUser, DescribeUser, and so on.
    public static var quickSightUserNotFoundException: Self { .init(.quickSightUserNotFoundException) }
    /// The resource specified already exists.
    public static var resourceExistsException: Self { .init(.resourceExistsException) }
    /// One or more resources can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This resource is currently unavailable.
    public static var resourceUnavailableException: Self { .init(.resourceUnavailableException) }
    /// The number of minutes specified for the lifetime of a session isn't valid. The session
    /// 			lifetime must be 15-600 minutes.
    public static var sessionLifetimeInMinutesInvalidException: Self { .init(.sessionLifetimeInMinutesInvalidException) }
    /// Access is throttled.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This error indicates that you are calling an embedding operation in Amazon QuickSight
    /// 			without the required pricing plan on your Amazon Web Services account. Before you can use embedding
    /// 			for anonymous users, a QuickSight administrator needs to add capacity pricing to Amazon QuickSight. You
    /// 		    can do this on the Manage Amazon QuickSight page.  After capacity pricing is added, you can use the   GetDashboardEmbedUrl API operation with the  --identity-type ANONYMOUS option.
    public static var unsupportedPricingPlanException: Self { .init(.unsupportedPricingPlanException) }
    /// This error indicates that you are calling an operation on an Amazon QuickSight
    /// 			subscription where the edition doesn't include support for that operation. Amazon
    /// 			Amazon QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and
    /// 			capability is available in every edition.
    public static var unsupportedUserEditionException: Self { .init(.unsupportedUserEditionException) }
}

extension QuickSightErrorType: Equatable {
    public static func == (lhs: QuickSightErrorType, rhs: QuickSightErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QuickSightErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
