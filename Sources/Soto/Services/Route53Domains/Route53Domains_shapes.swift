//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Route53Domains {
    // MARK: Enums

    public enum ContactType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case association = "ASSOCIATION"
        case company = "COMPANY"
        case person = "PERSON"
        case publicBody = "PUBLIC_BODY"
        case reseller = "RESELLER"
        public var description: String { return self.rawValue }
    }

    public enum CountryCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `as` = "AS"
        case `do` = "DO"
        case `in` = "IN"
        case `is` = "IS"
        case ac = "AC"
        case ad = "AD"
        case ae = "AE"
        case af = "AF"
        case ag = "AG"
        case ai = "AI"
        case al = "AL"
        case am = "AM"
        case an = "AN"
        case ao = "AO"
        case aq = "AQ"
        case ar = "AR"
        case at = "AT"
        case au = "AU"
        case aw = "AW"
        case ax = "AX"
        case az = "AZ"
        case ba = "BA"
        case bb = "BB"
        case bd = "BD"
        case be = "BE"
        case bf = "BF"
        case bg = "BG"
        case bh = "BH"
        case bi = "BI"
        case bj = "BJ"
        case bl = "BL"
        case bm = "BM"
        case bn = "BN"
        case bo = "BO"
        case bq = "BQ"
        case br = "BR"
        case bs = "BS"
        case bt = "BT"
        case bv = "BV"
        case bw = "BW"
        case by = "BY"
        case bz = "BZ"
        case ca = "CA"
        case cc = "CC"
        case cd = "CD"
        case cf = "CF"
        case cg = "CG"
        case ch = "CH"
        case ci = "CI"
        case ck = "CK"
        case cl = "CL"
        case cm = "CM"
        case cn = "CN"
        case co = "CO"
        case cr = "CR"
        case cu = "CU"
        case cv = "CV"
        case cw = "CW"
        case cx = "CX"
        case cy = "CY"
        case cz = "CZ"
        case de = "DE"
        case dj = "DJ"
        case dk = "DK"
        case dm = "DM"
        case dz = "DZ"
        case ec = "EC"
        case ee = "EE"
        case eg = "EG"
        case eh = "EH"
        case er = "ER"
        case es = "ES"
        case et = "ET"
        case fi = "FI"
        case fj = "FJ"
        case fk = "FK"
        case fm = "FM"
        case fo = "FO"
        case fr = "FR"
        case ga = "GA"
        case gb = "GB"
        case gd = "GD"
        case ge = "GE"
        case gf = "GF"
        case gg = "GG"
        case gh = "GH"
        case gi = "GI"
        case gl = "GL"
        case gm = "GM"
        case gn = "GN"
        case gp = "GP"
        case gq = "GQ"
        case gr = "GR"
        case gs = "GS"
        case gt = "GT"
        case gu = "GU"
        case gw = "GW"
        case gy = "GY"
        case hk = "HK"
        case hm = "HM"
        case hn = "HN"
        case hr = "HR"
        case ht = "HT"
        case hu = "HU"
        case id = "ID"
        case ie = "IE"
        case il = "IL"
        case im = "IM"
        case io = "IO"
        case iq = "IQ"
        case ir = "IR"
        case it = "IT"
        case je = "JE"
        case jm = "JM"
        case jo = "JO"
        case jp = "JP"
        case ke = "KE"
        case kg = "KG"
        case kh = "KH"
        case ki = "KI"
        case km = "KM"
        case kn = "KN"
        case kp = "KP"
        case kr = "KR"
        case kw = "KW"
        case ky = "KY"
        case kz = "KZ"
        case la = "LA"
        case lb = "LB"
        case lc = "LC"
        case li = "LI"
        case lk = "LK"
        case lr = "LR"
        case ls = "LS"
        case lt = "LT"
        case lu = "LU"
        case lv = "LV"
        case ly = "LY"
        case ma = "MA"
        case mc = "MC"
        case md = "MD"
        case me = "ME"
        case mf = "MF"
        case mg = "MG"
        case mh = "MH"
        case mk = "MK"
        case ml = "ML"
        case mm = "MM"
        case mn = "MN"
        case mo = "MO"
        case mp = "MP"
        case mq = "MQ"
        case mr = "MR"
        case ms = "MS"
        case mt = "MT"
        case mu = "MU"
        case mv = "MV"
        case mw = "MW"
        case mx = "MX"
        case my = "MY"
        case mz = "MZ"
        case na = "NA"
        case nc = "NC"
        case ne = "NE"
        case nf = "NF"
        case ng = "NG"
        case ni = "NI"
        case nl = "NL"
        case no = "NO"
        case np = "NP"
        case nr = "NR"
        case nu = "NU"
        case nz = "NZ"
        case om = "OM"
        case pa = "PA"
        case pe = "PE"
        case pf = "PF"
        case pg = "PG"
        case ph = "PH"
        case pk = "PK"
        case pl = "PL"
        case pm = "PM"
        case pn = "PN"
        case pr = "PR"
        case ps = "PS"
        case pt = "PT"
        case pw = "PW"
        case py = "PY"
        case qa = "QA"
        case re = "RE"
        case ro = "RO"
        case rs = "RS"
        case ru = "RU"
        case rw = "RW"
        case sa = "SA"
        case sb = "SB"
        case sc = "SC"
        case sd = "SD"
        case se = "SE"
        case sg = "SG"
        case sh = "SH"
        case si = "SI"
        case sj = "SJ"
        case sk = "SK"
        case sl = "SL"
        case sm = "SM"
        case sn = "SN"
        case so = "SO"
        case sr = "SR"
        case ss = "SS"
        case st = "ST"
        case sv = "SV"
        case sx = "SX"
        case sy = "SY"
        case sz = "SZ"
        case tc = "TC"
        case td = "TD"
        case tf = "TF"
        case tg = "TG"
        case th = "TH"
        case tj = "TJ"
        case tk = "TK"
        case tl = "TL"
        case tm = "TM"
        case tn = "TN"
        case to = "TO"
        case tp = "TP"
        case tr = "TR"
        case tt = "TT"
        case tv = "TV"
        case tw = "TW"
        case tz = "TZ"
        case ua = "UA"
        case ug = "UG"
        case us = "US"
        case uy = "UY"
        case uz = "UZ"
        case va = "VA"
        case vc = "VC"
        case ve = "VE"
        case vg = "VG"
        case vi = "VI"
        case vn = "VN"
        case vu = "VU"
        case wf = "WF"
        case ws = "WS"
        case ye = "YE"
        case yt = "YT"
        case za = "ZA"
        case zm = "ZM"
        case zw = "ZW"
        public var description: String { return self.rawValue }
    }

    public enum DomainAvailability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case availablePreorder = "AVAILABLE_PREORDER"
        case availableReserved = "AVAILABLE_RESERVED"
        case dontKnow = "DONT_KNOW"
        case invalidNameForTld = "INVALID_NAME_FOR_TLD"
        case pending = "PENDING"
        case reserved = "RESERVED"
        case unavailable = "UNAVAILABLE"
        case unavailablePremium = "UNAVAILABLE_PREMIUM"
        case unavailableRestricted = "UNAVAILABLE_RESTRICTED"
        public var description: String { return self.rawValue }
    }

    public enum ExtraParamName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auIdNumber = "AU_ID_NUMBER"
        case auIdType = "AU_ID_TYPE"
        case auPriorityToken = "AU_PRIORITY_TOKEN"
        case birthCity = "BIRTH_CITY"
        case birthCountry = "BIRTH_COUNTRY"
        case birthDateInYyyyMmDd = "BIRTH_DATE_IN_YYYY_MM_DD"
        case birthDepartment = "BIRTH_DEPARTMENT"
        case brandNumber = "BRAND_NUMBER"
        case caBusinessEntityType = "CA_BUSINESS_ENTITY_TYPE"
        case caLegalRepresentative = "CA_LEGAL_REPRESENTATIVE"
        case caLegalRepresentativeCapacity = "CA_LEGAL_REPRESENTATIVE_CAPACITY"
        case caLegalType = "CA_LEGAL_TYPE"
        case documentNumber = "DOCUMENT_NUMBER"
        case dunsNumber = "DUNS_NUMBER"
        case esIdentification = "ES_IDENTIFICATION"
        case esIdentificationType = "ES_IDENTIFICATION_TYPE"
        case esLegalForm = "ES_LEGAL_FORM"
        case euCountryOfCitizenship = "EU_COUNTRY_OF_CITIZENSHIP"
        case fiBusinessNumber = "FI_BUSINESS_NUMBER"
        case fiNationality = "FI_NATIONALITY"
        case fiOrganizationType = "FI_ORGANIZATION_TYPE"
        case itNationality = "IT_NATIONALITY"
        case itPin = "IT_PIN"
        case itRegistrantEntityType = "IT_REGISTRANT_ENTITY_TYPE"
        case onwerFiIdNumber = "FI_ID_NUMBER"
        case ruPassportData = "RU_PASSPORT_DATA"
        case seIdNumber = "SE_ID_NUMBER"
        case sgIdNumber = "SG_ID_NUMBER"
        case ukCompanyNumber = "UK_COMPANY_NUMBER"
        case ukContactType = "UK_CONTACT_TYPE"
        case vatNumber = "VAT_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum ListDomainsAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domainName = "DomainName"
        case expiry = "Expiry"
        public var description: String { return self.rawValue }
    }

    public enum ListOperationsSortAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case submittedDate = "SubmittedDate"
        public var description: String { return self.rawValue }
    }

    public enum OperationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum OperationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addDnssec = "ADD_DNSSEC"
        case changeDomainOwner = "CHANGE_DOMAIN_OWNER"
        case changePrivacyProtection = "CHANGE_PRIVACY_PROTECTION"
        case deleteDomain = "DELETE_DOMAIN"
        case disableAutorenew = "DISABLE_AUTORENEW"
        case domainLock = "DOMAIN_LOCK"
        case enableAutorenew = "ENABLE_AUTORENEW"
        case expireDomain = "EXPIRE_DOMAIN"
        case internalTransferInDomain = "INTERNAL_TRANSFER_IN_DOMAIN"
        case internalTransferOutDomain = "INTERNAL_TRANSFER_OUT_DOMAIN"
        case pushDomain = "PUSH_DOMAIN"
        case registerDomain = "REGISTER_DOMAIN"
        case releaseToGandi = "RELEASE_TO_GANDI"
        case removeDnssec = "REMOVE_DNSSEC"
        case renewDomain = "RENEW_DOMAIN"
        case restoreDomain = "RESTORE_DOMAIN"
        case transferInDomain = "TRANSFER_IN_DOMAIN"
        case transferOnRenew = "TRANSFER_ON_RENEW"
        case transferOutDomain = "TRANSFER_OUT_DOMAIN"
        case updateDomainContact = "UPDATE_DOMAIN_CONTACT"
        case updateNameserver = "UPDATE_NAMESERVER"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case beginsWith = "BEGINS_WITH"
        case ge = "GE"
        case le = "LE"
        public var description: String { return self.rawValue }
    }

    public enum ReachabilityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case done = "DONE"
        case expired = "EXPIRED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum StatusFlag: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pendingAcceptance = "PENDING_ACCEPTANCE"
        case pendingAuthorization = "PENDING_AUTHORIZATION"
        case pendingCustomerAction = "PENDING_CUSTOMER_ACTION"
        case pendingPaymentVerification = "PENDING_PAYMENT_VERIFICATION"
        case pendingSupportCase = "PENDING_SUPPORT_CASE"
        public var description: String { return self.rawValue }
    }

    public enum Transferable: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domainInAnotherAccount = "DOMAIN_IN_ANOTHER_ACCOUNT"
        case domainInOwnAccount = "DOMAIN_IN_OWN_ACCOUNT"
        case dontKnow = "DONT_KNOW"
        case premiumDomain = "PREMIUM_DOMAIN"
        case transferable = "TRANSFERABLE"
        case untransferable = "UNTRANSFERABLE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptDomainTransferFromAnotherAwsAccountRequest: AWSEncodableShape {
        /// The name of the domain that was specified when another Amazon Web Services account
        /// 			submitted a TransferDomainToAnotherAwsAccount request.
        public let domainName: String
        /// The password that was returned by the TransferDomainToAnotherAwsAccount request.
        public let password: String

        @inlinable
        public init(domainName: String, password: String) {
            self.domainName = domainName
            self.password = password
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case password = "Password"
        }
    }

    public struct AcceptDomainTransferFromAnotherAwsAccountResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct AssociateDelegationSignerToDomainRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String
        /// The information about a key, including the algorithm, public key-value, and
        /// 			flags.
        public let signingAttributes: DnssecSigningAttributes

        @inlinable
        public init(domainName: String, signingAttributes: DnssecSigningAttributes) {
            self.domainName = domainName
            self.signingAttributes = signingAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.signingAttributes.validate(name: "\(name).signingAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case signingAttributes = "SigningAttributes"
        }
    }

    public struct AssociateDelegationSignerToDomainResponse: AWSDecodableShape {
        /// The identifier for tracking the progress of the request. To query the operation
        /// 			status, use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct BillingRecord: AWSDecodableShape {
        /// The date that the operation was billed, in Unix format.
        public let billDate: Date?
        /// The name of the domain that the billing record applies to. If the domain name contains
        /// 			characters other than a-z, 0-9, and - (hyphen), such as an internationalized domain
        /// 			name, then this value is in Punycode. For more information, see DNS
        /// 				Domain Name Format in the Amazon Route 53 Developer
        /// 				Guide.
        public let domainName: String?
        /// Deprecated property. This field is retained in report structure for backwards compatibility, but will appear blank.
        public let invoiceId: String?
        /// The operation that you were charged for.
        public let operation: OperationType?
        /// The price that you were charged for the operation, in US dollars. Example value: 12.0
        public let price: Double?

        @inlinable
        public init(billDate: Date? = nil, domainName: String? = nil, invoiceId: String? = nil, operation: OperationType? = nil, price: Double? = nil) {
            self.billDate = billDate
            self.domainName = domainName
            self.invoiceId = invoiceId
            self.operation = operation
            self.price = price
        }

        private enum CodingKeys: String, CodingKey {
            case billDate = "BillDate"
            case domainName = "DomainName"
            case invoiceId = "InvoiceId"
            case operation = "Operation"
            case price = "Price"
        }
    }

    public struct CancelDomainTransferToAnotherAwsAccountRequest: AWSEncodableShape {
        /// The name of the domain for which you want to cancel the transfer to another Amazon Web Services account.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct CancelDomainTransferToAnotherAwsAccountResponse: AWSDecodableShape {
        /// The identifier that TransferDomainToAnotherAwsAccount returned to track
        /// 			the progress of the request. Because the transfer request was canceled, the value is no
        /// 			longer valid, and you can't use GetOperationDetail to query the operation
        /// 			status.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct CheckDomainAvailabilityRequest: AWSEncodableShape {
        /// The name of the domain that you want to get availability for. The top-level domain
        /// 			(TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs,
        /// 			see Domains that You Can
        /// 				Register with Amazon Route 53 in the Amazon Route 53 Developer
        /// 				Guide. The domain name can contain only the following characters:   Letters a through z. Domain names are not case sensitive.   Numbers 0 through 9.   Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
        /// 				   Period (.) to separate the labels in the name, such as the . in
        /// 						example.com.   Internationalized domain names are not supported for some top-level domains. To
        /// 			determine whether the TLD that you want to use supports internationalized domain names,
        /// 			see Domains that You Can
        /// 				Register with Amazon Route 53. For more information, see Formatting Internationalized Domain Names.
        public let domainName: String
        /// Reserved for future use.
        public let idnLangCode: String?

        @inlinable
        public init(domainName: String, idnLangCode: String? = nil) {
            self.domainName = domainName
            self.idnLangCode = idnLangCode
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.idnLangCode, name: "idnLangCode", parent: name, pattern: "^|[A-Za-z]{2,3}$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case idnLangCode = "IdnLangCode"
        }
    }

    public struct CheckDomainAvailabilityResponse: AWSDecodableShape {
        /// Whether the domain name is available for registering.  You can register only domains designated as AVAILABLE.  Valid values:  AVAILABLE  The domain name is available.  AVAILABLE_RESERVED  The domain name is reserved under specific conditions.  AVAILABLE_PREORDER  The domain name is available and can be preordered.  DONT_KNOW  The TLD registry didn't reply with a definitive answer about whether the
        /// 						domain name is available. Route 53 can return this response for a variety of
        /// 						reasons, for example, the registry is performing maintenance. Try again
        /// 						later.  INVALID_NAME_FOR_TLD  The TLD isn't valid. For example, it can contain characters that aren't allowed.  PENDING  The TLD registry didn't return a response in the expected amount of time.
        /// 						When the response is delayed, it usually takes just a few extra seconds. You
        /// 						can resubmit the request immediately.  RESERVED  The domain name has been reserved for another person or
        /// 						organization.  UNAVAILABLE  The domain name is not available.  UNAVAILABLE_PREMIUM  The domain name is not available.  UNAVAILABLE_RESTRICTED  The domain name is forbidden.
        public let availability: DomainAvailability?

        @inlinable
        public init(availability: DomainAvailability? = nil) {
            self.availability = availability
        }

        private enum CodingKeys: String, CodingKey {
            case availability = "Availability"
        }
    }

    public struct CheckDomainTransferabilityRequest: AWSEncodableShape {
        /// If the registrar for the top-level domain (TLD) requires an authorization code to
        /// 			transfer the domain, the code that you got from the current registrar for the
        /// 			domain.
        public let authCode: String?
        /// The name of the domain that you want to transfer to Route 53. The top-level domain
        /// 			(TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs,
        /// 			see Domains that You Can
        /// 				Register with Amazon Route 53 in the Amazon Route 53 Developer
        /// 				Guide. The domain name can contain only the following characters:   Letters a through z. Domain names are not case sensitive.   Numbers 0 through 9.   Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
        /// 				   Period (.) to separate the labels in the name, such as the . in
        /// 						example.com.
        public let domainName: String

        @inlinable
        public init(authCode: String? = nil, domainName: String) {
            self.authCode = authCode
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.authCode, name: "authCode", parent: name, max: 1024)
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case authCode = "AuthCode"
            case domainName = "DomainName"
        }
    }

    public struct CheckDomainTransferabilityResponse: AWSDecodableShape {
        /// Provides an explanation for when a domain can't be transferred.
        public let message: String?
        /// A complex type that contains information about whether the specified domain can be
        /// 			transferred to Route 53.
        public let transferability: DomainTransferability?

        @inlinable
        public init(message: String? = nil, transferability: DomainTransferability? = nil) {
            self.message = message
            self.transferability = transferability
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case transferability = "Transferability"
        }
    }

    public struct Consent: AWSEncodableShape {
        ///  Currency for the MaxPrice.
        public let currency: String
        ///  Maximum amount the customer agreed to accept.
        public let maxPrice: Double

        @inlinable
        public init(currency: String, maxPrice: Double = 0) {
            self.currency = currency
            self.maxPrice = maxPrice
        }

        public func validate(name: String) throws {
            try self.validate(self.currency, name: "currency", parent: name, max: 3)
            try self.validate(self.currency, name: "currency", parent: name, min: 3)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case currency = "Currency"
            case maxPrice = "MaxPrice"
        }
    }

    public struct ContactDetail: AWSEncodableShape & AWSDecodableShape {
        /// First line of the contact's address.
        public let addressLine1: String?
        /// Second line of contact's address, if any.
        public let addressLine2: String?
        /// The city of the contact's address.
        public let city: String?
        /// Indicates whether the contact is a person, company, association, or public
        /// 			organization. Note the following:   If you specify a value other than PERSON, you must also specify a
        /// 					value for OrganizationName.   For some TLDs, the privacy protection available depends on the value that you
        /// 					specify for Contact Type. For the privacy protection settings for
        /// 					your TLD, see Domains that You
        /// 						Can Register with Amazon Route 53 in the Amazon Route 53
        /// 						Developer Guide    For .es domains, the value of ContactType must be
        /// 						PERSON for all three contacts.
        public let contactType: ContactType?
        /// Code for the country of the contact's address.
        public let countryCode: CountryCode?
        /// Email address of the contact.
        public let email: String?
        /// A list of name-value pairs for parameters required by certain top-level
        /// 			domains.
        public let extraParams: [ExtraParam]?
        /// Fax number of the contact. Constraints: Phone number must be specified in the format "+[country dialing
        /// 			code].[number including any area code]". For example, a US phone number might appear as
        /// 				"+1.1234567890".
        public let fax: String?
        /// First name of contact.
        public let firstName: String?
        /// Last name of contact.
        public let lastName: String?
        /// Name of the organization for contact types other than PERSON.
        public let organizationName: String?
        /// The phone number of the contact. Constraints: Phone number must be specified in the format "+[country dialing
        /// 			code].[number including any area code>]". For example, a US phone number might appear
        /// 			as "+1.1234567890".
        public let phoneNumber: String?
        /// The state or province of the contact's city.
        public let state: String?
        /// The zip or postal code of the contact's address.
        public let zipCode: String?

        @inlinable
        public init(addressLine1: String? = nil, addressLine2: String? = nil, city: String? = nil, contactType: ContactType? = nil, countryCode: CountryCode? = nil, email: String? = nil, extraParams: [ExtraParam]? = nil, fax: String? = nil, firstName: String? = nil, lastName: String? = nil, organizationName: String? = nil, phoneNumber: String? = nil, state: String? = nil, zipCode: String? = nil) {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.city = city
            self.contactType = contactType
            self.countryCode = countryCode
            self.email = email
            self.extraParams = extraParams
            self.fax = fax
            self.firstName = firstName
            self.lastName = lastName
            self.organizationName = organizationName
            self.phoneNumber = phoneNumber
            self.state = state
            self.zipCode = zipCode
        }

        public func validate(name: String) throws {
            try self.validate(self.addressLine1, name: "addressLine1", parent: name, max: 255)
            try self.validate(self.addressLine2, name: "addressLine2", parent: name, max: 255)
            try self.validate(self.city, name: "city", parent: name, max: 255)
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.extraParams?.forEach {
                try $0.validate(name: "\(name).extraParams[]")
            }
            try self.validate(self.fax, name: "fax", parent: name, max: 30)
            try self.validate(self.firstName, name: "firstName", parent: name, max: 255)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 255)
            try self.validate(self.organizationName, name: "organizationName", parent: name, max: 255)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 30)
            try self.validate(self.state, name: "state", parent: name, max: 255)
            try self.validate(self.zipCode, name: "zipCode", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case addressLine1 = "AddressLine1"
            case addressLine2 = "AddressLine2"
            case city = "City"
            case contactType = "ContactType"
            case countryCode = "CountryCode"
            case email = "Email"
            case extraParams = "ExtraParams"
            case fax = "Fax"
            case firstName = "FirstName"
            case lastName = "LastName"
            case organizationName = "OrganizationName"
            case phoneNumber = "PhoneNumber"
            case state = "State"
            case zipCode = "ZipCode"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        /// Name of the domain to be deleted.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct DeleteTagsForDomainRequest: AWSEncodableShape {
        /// The domain for which you want to delete one or more tags.
        public let domainName: String
        /// A list of tag keys to delete.
        public let tagsToDelete: [String]

        @inlinable
        public init(domainName: String, tagsToDelete: [String]) {
            self.domainName = domainName
            self.tagsToDelete = tagsToDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.tagsToDelete.forEach {
                try validate($0, name: "tagsToDelete[]", parent: name, max: 128)
                try validate($0, name: "tagsToDelete[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case tagsToDelete = "TagsToDelete"
        }
    }

    public struct DeleteTagsForDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisableDomainAutoRenewRequest: AWSEncodableShape {
        /// The name of the domain that you want to disable automatic renewal for.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct DisableDomainAutoRenewResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisableDomainTransferLockRequest: AWSEncodableShape {
        /// The name of the domain that you want to remove the transfer lock for.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct DisableDomainTransferLockResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct DisassociateDelegationSignerFromDomainRequest: AWSEncodableShape {
        /// Name of the domain.
        public let domainName: String
        /// An internal identification number assigned to each DS record after it’s created. You
        /// 			can retrieve it as part of DNSSEC information returned by GetDomainDetail.
        public let id: String

        @inlinable
        public init(domainName: String, id: String) {
            self.domainName = domainName
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case id = "Id"
        }
    }

    public struct DisassociateDelegationSignerFromDomainResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct DnssecKey: AWSDecodableShape {
        /// The number of the public key’s cryptographic algorithm according to an IANA assignment.  If Route 53 is your DNS service, set this to 13. For more information about enabling DNSSEC signing, see Enabling DNSSEC signing and establishing a chain of trust.
        public let algorithm: Int?
        ///  The delegation signer digest. Digest is calculated from the public key provided using specified digest algorithm and
        /// 			this digest is the actual value returned from the registry nameservers as the value of
        /// 			DS records.
        public let digest: String?
        ///  The number of the DS digest algorithm according to an IANA assignment. For more information, see IANA
        /// 			for DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms.
        public let digestType: Int?
        /// Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK
        /// 			(zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS
        /// 			provider isn't Route 53 and you don’t have KSK available. If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS)
        /// 			record. If you have ZSK keys only – use ZSK to create a DS record.
        public let flags: Int?
        ///  An ID assigned to each DS record created by AssociateDelegationSignerToDomain.
        public let id: String?
        ///  A numeric identification of the DNSKEY record referred to by this DS record.
        public let keyTag: Int?
        /// The base64-encoded public key part of the key pair that is passed to the registry
        /// 			.
        public let publicKey: String?

        @inlinable
        public init(algorithm: Int? = nil, digest: String? = nil, digestType: Int? = nil, flags: Int? = nil, id: String? = nil, keyTag: Int? = nil, publicKey: String? = nil) {
            self.algorithm = algorithm
            self.digest = digest
            self.digestType = digestType
            self.flags = flags
            self.id = id
            self.keyTag = keyTag
            self.publicKey = publicKey
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "Algorithm"
            case digest = "Digest"
            case digestType = "DigestType"
            case flags = "Flags"
            case id = "Id"
            case keyTag = "KeyTag"
            case publicKey = "PublicKey"
        }
    }

    public struct DnssecSigningAttributes: AWSEncodableShape {
        ///  Algorithm which was used to generate the digest from the public key.
        public let algorithm: Int?
        /// Defines the type of key. It can be either a KSK (key-signing-key, value 257) or ZSK
        /// 			(zone-signing-key, value 256). Using KSK is always encouraged. Only use ZSK if your DNS
        /// 			provider isn't Route 53 and you don’t have KSK available. If you have KSK and ZSK keys, always use KSK to create a delegations signer (DS)
        /// 			record. If you have ZSK keys only – use ZSK to create a DS record.
        public let flags: Int?
        ///  The base64-encoded public key part of the key pair that is passed to the registry.
        ///
        public let publicKey: String?

        @inlinable
        public init(algorithm: Int? = nil, flags: Int? = nil, publicKey: String? = nil) {
            self.algorithm = algorithm
            self.flags = flags
            self.publicKey = publicKey
        }

        public func validate(name: String) throws {
            try self.validate(self.publicKey, name: "publicKey", parent: name, max: 32768)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "Algorithm"
            case flags = "Flags"
            case publicKey = "PublicKey"
        }
    }

    public struct DomainPrice: AWSDecodableShape {
        /// The price for changing domain ownership.
        public let changeOwnershipPrice: PriceWithCurrency?
        /// The name of the TLD for which the prices apply.
        public let name: String?
        /// The price for domain registration with Route 53.
        public let registrationPrice: PriceWithCurrency?
        /// The price for renewing domain registration with Route 53.
        public let renewalPrice: PriceWithCurrency?
        /// The price for restoring the domain with Route 53.
        public let restorationPrice: PriceWithCurrency?
        /// The price for transferring the domain registration to Route 53.
        public let transferPrice: PriceWithCurrency?

        @inlinable
        public init(changeOwnershipPrice: PriceWithCurrency? = nil, name: String? = nil, registrationPrice: PriceWithCurrency? = nil, renewalPrice: PriceWithCurrency? = nil, restorationPrice: PriceWithCurrency? = nil, transferPrice: PriceWithCurrency? = nil) {
            self.changeOwnershipPrice = changeOwnershipPrice
            self.name = name
            self.registrationPrice = registrationPrice
            self.renewalPrice = renewalPrice
            self.restorationPrice = restorationPrice
            self.transferPrice = transferPrice
        }

        private enum CodingKeys: String, CodingKey {
            case changeOwnershipPrice = "ChangeOwnershipPrice"
            case name = "Name"
            case registrationPrice = "RegistrationPrice"
            case renewalPrice = "RenewalPrice"
            case restorationPrice = "RestorationPrice"
            case transferPrice = "TransferPrice"
        }
    }

    public struct DomainSuggestion: AWSDecodableShape {
        /// Whether the domain name is available for registering.  You can register only the domains that are designated as
        /// 				AVAILABLE.  Valid values:  AVAILABLE  The domain name is available.  AVAILABLE_RESERVED  The domain name is reserved under specific conditions.  AVAILABLE_PREORDER  The domain name is available and can be preordered.  DONT_KNOW  The TLD registry didn't reply with a definitive answer about whether the
        /// 						domain name is available. Route 53 can return this response for a variety of
        /// 						reasons, for example, the registry is performing maintenance. Try again
        /// 						later.  PENDING  The TLD registry didn't return a response in the expected amount of time.
        /// 						When the response is delayed, it usually takes just a few extra seconds. You
        /// 						can resubmit the request immediately.  RESERVED  The domain name has been reserved for another person or
        /// 						organization.  UNAVAILABLE  The domain name is not available.  UNAVAILABLE_PREMIUM  The domain name is not available.  UNAVAILABLE_RESTRICTED  The domain name is forbidden.
        public let availability: String?
        /// A suggested domain name.
        public let domainName: String?

        @inlinable
        public init(availability: String? = nil, domainName: String? = nil) {
            self.availability = availability
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case availability = "Availability"
            case domainName = "DomainName"
        }
    }

    public struct DomainSummary: AWSDecodableShape {
        /// Indicates whether the domain is automatically renewed upon expiration.
        public let autoRenew: Bool?
        /// The name of the domain that the summary information applies to.
        public let domainName: String?
        /// Expiration date of the domain in Unix time format and Coordinated Universal Time
        /// 			(UTC).
        public let expiry: Date?
        /// Indicates whether a domain is locked from unauthorized transfer to another
        /// 			party.
        public let transferLock: Bool?

        @inlinable
        public init(autoRenew: Bool? = nil, domainName: String? = nil, expiry: Date? = nil, transferLock: Bool? = nil) {
            self.autoRenew = autoRenew
            self.domainName = domainName
            self.expiry = expiry
            self.transferLock = transferLock
        }

        private enum CodingKeys: String, CodingKey {
            case autoRenew = "AutoRenew"
            case domainName = "DomainName"
            case expiry = "Expiry"
            case transferLock = "TransferLock"
        }
    }

    public struct DomainTransferability: AWSDecodableShape {
        public let transferable: Transferable?

        @inlinable
        public init(transferable: Transferable? = nil) {
            self.transferable = transferable
        }

        private enum CodingKeys: String, CodingKey {
            case transferable = "Transferable"
        }
    }

    public struct DuplicateRequest: AWSErrorShape {
        /// The request is already in progress for the domain.
        public let message: String?
        /// ID of the request operation.
        public let requestId: String?

        @inlinable
        public init(message: String? = nil, requestId: String? = nil) {
            self.message = message
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case requestId = "requestId"
        }
    }

    public struct EnableDomainAutoRenewRequest: AWSEncodableShape {
        /// The name of the domain that you want to enable automatic renewal for.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct EnableDomainAutoRenewResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EnableDomainTransferLockRequest: AWSEncodableShape {
        /// The name of the domain that you want to set the transfer lock for.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct EnableDomainTransferLockResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To use this ID to query the
        /// 			operation status, use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct ExtraParam: AWSEncodableShape & AWSDecodableShape {
        /// The name of an additional parameter that is required by a top-level domain. Here are
        /// 			the top-level domains that require additional parameters and the names of the parameters
        /// 			that they require:  .com.au and .net.au     AU_ID_NUMBER     AU_ID_TYPE  Valid values include the following:    ABN (Australian business number)    ACN (Australian company number)    TM (Trademark number)      .ca     BRAND_NUMBER     CA_BUSINESS_ENTITY_TYPE  Valid values include the following:    BANK (Bank)    COMMERCIAL_COMPANY (Commercial
        /// 										company)    COMPANY (Company)    COOPERATION (Cooperation)    COOPERATIVE (Cooperative)    COOPRIX (Cooprix)    CORP (Corporation)    CREDIT_UNION (Credit union)    FOMIA (Federation of mutual insurance
        /// 										associations)    INC (Incorporated)    LTD (Limited)    LTEE (Limitée)    LLC (Limited liability corporation)    LLP (Limited liability partnership)    LTE (Lte.)    MBA (Mutual benefit association)    MIC (Mutual insurance company)    NFP (Not-for-profit corporation)    SA (S.A.)    SAVINGS_COMPANY (Savings company)    SAVINGS_UNION (Savings union)    SARL (Société à responsabilité
        /// 										limitée)    TRUST (Trust)    ULC (Unlimited liability corporation)      CA_LEGAL_TYPE  When ContactType is PERSON, valid values
        /// 								include the following:    ABO (Aboriginal Peoples indigenous to
        /// 										Canada)    CCT (Canadian citizen)    LGR (Legal Representative of a Canadian
        /// 										Citizen or Permanent Resident)    RES (Permanent resident of Canada)   When ContactType is a value other than
        /// 									PERSON, valid values include the following:    ASS (Canadian unincorporated
        /// 										association)    CCO (Canadian corporation)    EDU (Canadian educational institution)    GOV (Government or government entity in
        /// 										Canada)    HOP (Canadian Hospital)    INB (Indian Band recognized by the Indian Act
        /// 										of Canada)    LAM (Canadian Library, Archive, or
        /// 										Museum)    MAJ (Her/His Majesty the Queen/King)    OMK (Official mark registered in
        /// 										Canada)    PLT (Canadian Political Party)    PRT (Partnership Registered in Canada)    TDM (Trademark registered in Canada)    TRD (Canadian Trade Union)    TRS (Trust established in Canada)      .es     ES_IDENTIFICATION  The value of ES_IDENTIFICATION depends on the
        /// 								following values:   The value of ES_LEGAL_FORM    The value of ES_IDENTIFICATION_TYPE     If ES_LEGAL_FORM is any value
        /// 									other than INDIVIDUAL:    Specify 1 letter + 8 numbers (CIF [Certificado de
        /// 										Identificación Fiscal])   Example: B12345678    If ES_LEGAL_FORM is
        /// 										INDIVIDUAL, the value that you specify for
        /// 										ES_IDENTIFICATION depends on the value of
        /// 										ES_IDENTIFICATION_TYPE:    If ES_IDENTIFICATION_TYPE is
        /// 											DNI_AND_NIF (for Spanish contacts):   Specify 8 numbers + 1 letter (DNI [Documento
        /// 												Nacional de Identidad], NIF [Número de
        /// 												Identificación Fiscal])   Example: 12345678M     If ES_IDENTIFICATION_TYPE is NIE
        /// 										(for foreigners with legal residence):   Specify 1 letter + 7 numbers + 1 letter ( NIE
        /// 												[Número de Identidad de Extranjero])   Example: Y1234567X     If ES_IDENTIFICATION_TYPE is
        /// 											OTHER (for contacts outside of
        /// 										Spain):   Specify a passport number, drivers license number,
        /// 												or national identity card number        ES_IDENTIFICATION_TYPE  Valid values include the following:    DNI_AND_NIF (For Spanish contacts)    NIE (For foreigners with legal
        /// 										residence)    OTHER (For contacts outside of Spain)      ES_LEGAL_FORM  Valid values include the following:    ASSOCIATION     CENTRAL_GOVERNMENT_BODY     CIVIL_SOCIETY     COMMUNITY_OF_OWNERS     COMMUNITY_PROPERTY     CONSULATE     COOPERATIVE     DESIGNATION_OF_ORIGIN_SUPERVISORY_COUNCIL     ECONOMIC_INTEREST_GROUP     EMBASSY     ENTITY_MANAGING_NATURAL_AREAS     FARM_PARTNERSHIP     FOUNDATION     GENERAL_AND_LIMITED_PARTNERSHIP     GENERAL_PARTNERSHIP     INDIVIDUAL     LIMITED_COMPANY     LOCAL_AUTHORITY     LOCAL_PUBLIC_ENTITY     MUTUAL_INSURANCE_COMPANY     NATIONAL_PUBLIC_ENTITY     ORDER_OR_RELIGIOUS_INSTITUTION     OTHERS (Only for contacts outside of
        /// 										Spain)     POLITICAL_PARTY     PROFESSIONAL_ASSOCIATION     PUBLIC_LAW_ASSOCIATION     PUBLIC_LIMITED_COMPANY     REGIONAL_GOVERNMENT_BODY     REGIONAL_PUBLIC_ENTITY     SAVINGS_BANK     SPANISH_OFFICE     SPORTS_ASSOCIATION     SPORTS_FEDERATION     SPORTS_LIMITED_COMPANY     TEMPORARY_ALLIANCE_OF_ENTERPRISES     TRADE_UNION     WORKER_OWNED_COMPANY     WORKER_OWNED_LIMITED_COMPANY       .eu     EU_COUNTRY_OF_CITIZENSHIP     .fi     BIRTH_DATE_IN_YYYY_MM_DD     FI_BUSINESS_NUMBER     FI_ID_NUMBER     FI_NATIONALITY  Valid values include the following:    FINNISH     NOT_FINNISH       FI_ORGANIZATION_TYPE  Valid values include the following:    COMPANY     CORPORATION     GOVERNMENT     INSTITUTION     POLITICAL_PARTY     PUBLIC_COMMUNITY     TOWNSHIP       .it     IT_NATIONALITY     IT_PIN     IT_REGISTRANT_ENTITY_TYPE  Valid values include the following:    FOREIGNERS     FREELANCE_WORKERS (Freelance workers and
        /// 										professionals)    ITALIAN_COMPANIES (Italian companies and
        /// 										one-person companies)    NON_PROFIT_ORGANIZATIONS     OTHER_SUBJECTS     PUBLIC_ORGANIZATIONS       .ru     BIRTH_DATE_IN_YYYY_MM_DD     RU_PASSPORT_DATA     .se     BIRTH_COUNTRY     SE_ID_NUMBER     .sg     SG_ID_NUMBER     .uk, .co.uk, .me.uk, and .org.uk     UK_CONTACT_TYPE  Valid values include the following:    CRC (UK Corporation by Royal Charter)    FCORP (Non-UK Corporation)    FIND (Non-UK Individual, representing
        /// 										self)    FOTHER (Non-UK Entity that does not fit into
        /// 										any other category)    GOV (UK Government Body)    IND (UK Individual (representing
        /// 										self))    IP (UK Industrial/Provident Registered
        /// 										Company)    LLP (UK Limited Liability Partnership)    LTD (UK Limited Company)    OTHER (UK Entity that does not fit into any
        /// 										other category)    PLC (UK Public Limited Company)    PTNR (UK Partnership)    RCHAR (UK Registered Charity)    SCH (UK School)    STAT (UK Statutory Body)    STRA (UK Sole Trader)      UK_COMPANY_NUMBER      In addition, many TLDs require a VAT_NUMBER.
        public let name: ExtraParamName
        /// The value that corresponds with the name of an extra parameter.
        public let value: String

        @inlinable
        public init(name: ExtraParamName, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct FilterCondition: AWSEncodableShape {
        /// Name of the field which should be used for filtering the list of domains.
        public let name: ListDomainsAttributeName
        /// The operator values for filtering domain names. The values can be:    LE: Less than, or equal to    GE: Greater than, or equal to    BEGINS_WITH: Begins with
        public let `operator`: Operator
        ///  An array of strings presenting values to compare. Only 1 item in the list is
        /// 			currently supported.
        public let values: [String]

        @inlinable
        public init(name: ListDomainsAttributeName, operator: Operator, values: [String]) {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct GetContactReachabilityStatusRequest: AWSEncodableShape {
        /// The name of the domain for which you want to know whether the registrant contact has
        /// 			confirmed that the email address is valid.
        public let domainName: String?

        @inlinable
        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
        }
    }

    public struct GetContactReachabilityStatusResponse: AWSDecodableShape {
        /// The domain name for which you requested the reachability status.
        public let domainName: String?
        /// Whether the registrant contact has responded. Values include the following:  PENDING  We sent the confirmation email and haven't received a response yet.  DONE  We sent the email and got confirmation from the registrant contact.  EXPIRED  The time limit expired before the registrant contact responded.
        public let status: ReachabilityStatus?

        @inlinable
        public init(domainName: String? = nil, status: ReachabilityStatus? = nil) {
            self.domainName = domainName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case status = "status"
        }
    }

    public struct GetDomainDetailRequest: AWSEncodableShape {
        /// The name of the domain that you want to get detailed information about.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct GetDomainDetailResponse: AWSDecodableShape {
        /// Email address to contact to report incorrect contact information for a domain, to
        /// 			report that the domain is being used to send spam, to report that someone is
        /// 			cybersquatting on a domain name, or report some other type of abuse.
        public let abuseContactEmail: String?
        /// Phone number for reporting abuse.
        public let abuseContactPhone: String?
        /// Provides details about the domain administrative contact.
        public let adminContact: ContactDetail?
        /// Specifies whether contact information is concealed from WHOIS queries. If the value is
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If the value is false, WHOIS queries return the
        /// 			information that you entered for the admin contact.
        public let adminPrivacy: Bool?
        /// Specifies whether the domain registration is set to renew automatically.
        public let autoRenew: Bool?
        /// Provides details about the domain billing contact.
        public let billingContact: ContactDetail?
        /// Specifies whether contact information is concealed from WHOIS queries. If the value is
        /// 		true, WHOIS ("who is") queries return contact information either for
        /// 		Amazon Registrar or for our registrar associate,
        /// 		Gandi. If the value is false, WHOIS queries return the
        /// 		information that you entered for the billing contact.
        public let billingPrivacy: Bool?
        /// The date when the domain was created as found in the response to a WHOIS query. The
        /// 			date and time is in Unix time format and Coordinated Universal time (UTC).
        public let creationDate: Date?
        /// Deprecated.
        public let dnsSec: String?
        /// A complex type that contains information about the DNSSEC configuration.
        public let dnssecKeys: [DnssecKey]?
        /// The name of a domain.
        public let domainName: String?
        /// The date when the registration for the domain is set to expire. The date and time is
        /// 			in Unix time format and Coordinated Universal time (UTC).
        public let expirationDate: Date?
        /// The name servers of the domain.
        public let nameservers: [Nameserver]?
        /// Provides details about the domain registrant.
        public let registrantContact: ContactDetail?
        /// Specifies whether contact information is concealed from WHOIS queries. If the value is
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If the value is false, WHOIS queries return the
        /// 			information that you entered for the registrant contact (domain owner).
        public let registrantPrivacy: Bool?
        /// Name of the registrar of the domain as identified in the registry.
        public let registrarName: String?
        /// Web address of the registrar.
        public let registrarUrl: String?
        /// Reserved for future use.
        public let registryDomainId: String?
        /// Reseller of the domain. Domains registered or transferred using Route 53 domains will
        /// 			have "Amazon" as the reseller.
        public let reseller: String?
        /// An array of domain name status codes, also known as Extensible Provisioning Protocol
        /// 			(EPP) status codes. ICANN, the organization that maintains a central database of domain names, has
        /// 			developed a set of domain name status codes that tell you the status of a variety of
        /// 			operations on a domain name, for example, registering a domain name, transferring a
        /// 			domain name to another registrar, renewing the registration for a domain name, and so
        /// 			on. All registrars use this same set of status codes. For a current list of domain name status codes and an explanation of what each code
        /// 			means, go to the ICANN website and search
        /// 			for epp status codes. (Search on the ICANN website; web searches sometimes
        /// 			return an old version of the document.)
        public let statusList: [String]?
        /// Provides details about the domain technical contact.
        public let techContact: ContactDetail?
        /// Specifies whether contact information is concealed from WHOIS queries. If the value is
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If the value is false, WHOIS queries return the
        /// 			information that you entered for the technical contact.
        public let techPrivacy: Bool?
        /// The last updated date of the domain as found in the response to a WHOIS query. The
        /// 			date and time is in Unix time format and Coordinated Universal time (UTC).
        public let updatedDate: Date?
        /// The fully qualified name of the WHOIS server that can answer the WHOIS query for the
        /// 			domain.
        public let whoIsServer: String?

        @inlinable
        public init(abuseContactEmail: String? = nil, abuseContactPhone: String? = nil, adminContact: ContactDetail? = nil, adminPrivacy: Bool? = nil, autoRenew: Bool? = nil, billingContact: ContactDetail? = nil, billingPrivacy: Bool? = nil, creationDate: Date? = nil, dnsSec: String? = nil, dnssecKeys: [DnssecKey]? = nil, domainName: String? = nil, expirationDate: Date? = nil, nameservers: [Nameserver]? = nil, registrantContact: ContactDetail? = nil, registrantPrivacy: Bool? = nil, registrarName: String? = nil, registrarUrl: String? = nil, registryDomainId: String? = nil, reseller: String? = nil, statusList: [String]? = nil, techContact: ContactDetail? = nil, techPrivacy: Bool? = nil, updatedDate: Date? = nil, whoIsServer: String? = nil) {
            self.abuseContactEmail = abuseContactEmail
            self.abuseContactPhone = abuseContactPhone
            self.adminContact = adminContact
            self.adminPrivacy = adminPrivacy
            self.autoRenew = autoRenew
            self.billingContact = billingContact
            self.billingPrivacy = billingPrivacy
            self.creationDate = creationDate
            self.dnsSec = dnsSec
            self.dnssecKeys = dnssecKeys
            self.domainName = domainName
            self.expirationDate = expirationDate
            self.nameservers = nameservers
            self.registrantContact = registrantContact
            self.registrantPrivacy = registrantPrivacy
            self.registrarName = registrarName
            self.registrarUrl = registrarUrl
            self.registryDomainId = registryDomainId
            self.reseller = reseller
            self.statusList = statusList
            self.techContact = techContact
            self.techPrivacy = techPrivacy
            self.updatedDate = updatedDate
            self.whoIsServer = whoIsServer
        }

        private enum CodingKeys: String, CodingKey {
            case abuseContactEmail = "AbuseContactEmail"
            case abuseContactPhone = "AbuseContactPhone"
            case adminContact = "AdminContact"
            case adminPrivacy = "AdminPrivacy"
            case autoRenew = "AutoRenew"
            case billingContact = "BillingContact"
            case billingPrivacy = "BillingPrivacy"
            case creationDate = "CreationDate"
            case dnsSec = "DnsSec"
            case dnssecKeys = "DnssecKeys"
            case domainName = "DomainName"
            case expirationDate = "ExpirationDate"
            case nameservers = "Nameservers"
            case registrantContact = "RegistrantContact"
            case registrantPrivacy = "RegistrantPrivacy"
            case registrarName = "RegistrarName"
            case registrarUrl = "RegistrarUrl"
            case registryDomainId = "RegistryDomainId"
            case reseller = "Reseller"
            case statusList = "StatusList"
            case techContact = "TechContact"
            case techPrivacy = "TechPrivacy"
            case updatedDate = "UpdatedDate"
            case whoIsServer = "WhoIsServer"
        }
    }

    public struct GetDomainSuggestionsRequest: AWSEncodableShape {
        /// A domain name that you want to use as the basis for a list of possible domain names.
        /// 			The top-level domain (TLD), such as .com, must be a TLD that Route 53 supports. For a
        /// 			list of supported TLDs, see Domains that You Can
        /// 				Register with Amazon Route 53 in the Amazon Route 53 Developer
        /// 				Guide. The domain name can contain only the following characters:   Letters a through z. Domain names are not case sensitive.   Numbers 0 through 9.   Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
        /// 				   Period (.) to separate the labels in the name, such as the . in
        /// 						example.com.   Internationalized domain names are not supported for some top-level domains. To
        /// 			determine whether the TLD that you want to use supports internationalized domain names,
        /// 			see Domains that You Can
        /// 				Register with Amazon Route 53.
        public let domainName: String
        /// If OnlyAvailable is true, Route 53 returns only domain names
        /// 			that are available. If OnlyAvailable is false, Route 53
        /// 			returns domain names without checking whether they're available to be registered. To
        /// 			determine whether the domain is available, you can call
        /// 				checkDomainAvailability for each suggestion.
        public let onlyAvailable: Bool
        /// The number of suggested domain names that you want Route 53 to return. Specify a value
        /// 			between 1 and 50.
        public let suggestionCount: Int

        @inlinable
        public init(domainName: String, onlyAvailable: Bool, suggestionCount: Int = 0) {
            self.domainName = domainName
            self.onlyAvailable = onlyAvailable
            self.suggestionCount = suggestionCount
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case onlyAvailable = "OnlyAvailable"
            case suggestionCount = "SuggestionCount"
        }
    }

    public struct GetDomainSuggestionsResponse: AWSDecodableShape {
        /// A list of possible domain names. If you specified true for
        /// 				OnlyAvailable in the request, the list contains only domains that are
        /// 			available for registration.
        public let suggestionsList: [DomainSuggestion]?

        @inlinable
        public init(suggestionsList: [DomainSuggestion]? = nil) {
            self.suggestionsList = suggestionsList
        }

        private enum CodingKeys: String, CodingKey {
            case suggestionsList = "SuggestionsList"
        }
    }

    public struct GetOperationDetailRequest: AWSEncodableShape {
        /// The identifier for the operation for which you want to get the status. Route 53
        /// 			returned the identifier in the response to the original request.
        public let operationId: String

        @inlinable
        public init(operationId: String) {
            self.operationId = operationId
        }

        public func validate(name: String) throws {
            try self.validate(self.operationId, name: "operationId", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct GetOperationDetailResponse: AWSDecodableShape {
        /// The name of a domain.
        public let domainName: String?
        ///  The date when the operation was last updated.
        public let lastUpdatedDate: Date?
        /// Detailed information on the status including possible errors.
        public let message: String?
        /// The identifier for the operation.
        public let operationId: String?
        /// The current status of the requested operation in the system.
        public let status: OperationStatus?
        ///  Lists any outstanding operations that require customer action. Valid values
        /// 			are:    PENDING_ACCEPTANCE: The operation is waiting for acceptance from
        /// 					the account that is receiving the domain.    PENDING_CUSTOMER_ACTION: The operation is waiting for customer
        /// 					action, for example, returning an email.    PENDING_AUTHORIZATION: The operation is waiting for the form of
        /// 					authorization. For more information, see ResendOperationAuthorization.    PENDING_PAYMENT_VERIFICATION: The operation is waiting for the
        /// 					payment method to validate.    PENDING_SUPPORT_CASE: The operation includes a support case and
        /// 					is waiting for its resolution.
        public let statusFlag: StatusFlag?
        /// The date when the request was submitted.
        public let submittedDate: Date?
        /// The type of operation that was requested.
        public let type: OperationType?

        @inlinable
        public init(domainName: String? = nil, lastUpdatedDate: Date? = nil, message: String? = nil, operationId: String? = nil, status: OperationStatus? = nil, statusFlag: StatusFlag? = nil, submittedDate: Date? = nil, type: OperationType? = nil) {
            self.domainName = domainName
            self.lastUpdatedDate = lastUpdatedDate
            self.message = message
            self.operationId = operationId
            self.status = status
            self.statusFlag = statusFlag
            self.submittedDate = submittedDate
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case lastUpdatedDate = "LastUpdatedDate"
            case message = "Message"
            case operationId = "OperationId"
            case status = "Status"
            case statusFlag = "StatusFlag"
            case submittedDate = "SubmittedDate"
            case type = "Type"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        /// A complex type that contains information about the filters applied during the
        /// 				ListDomains request. The filter conditions can include domain name and
        /// 			domain expiration.
        public let filterConditions: [FilterCondition]?
        /// For an initial request for a list of domains, omit this element. If the number of
        /// 			domains that are associated with the current Amazon Web Services account is greater than
        /// 			the value that you specified for MaxItems, you can use Marker
        /// 			to return additional domains. Get the value of NextPageMarker from the
        /// 			previous response, and submit another request that includes the value of
        /// 				NextPageMarker in the Marker element. Constraints: The marker must match the value specified in the previous request.
        public let marker: String?
        /// Number of domains to be returned. Default: 20
        public let maxItems: Int?
        /// A complex type that contains information about the requested ordering of domains in
        /// 			the returned list.
        public let sortCondition: SortCondition?

        @inlinable
        public init(filterConditions: [FilterCondition]? = nil, marker: String? = nil, maxItems: Int? = nil, sortCondition: SortCondition? = nil) {
            self.filterConditions = filterConditions
            self.marker = marker
            self.maxItems = maxItems
            self.sortCondition = sortCondition
        }

        public func validate(name: String) throws {
            try self.filterConditions?.forEach {
                try $0.validate(name: "\(name).filterConditions[]")
            }
            try self.validate(self.marker, name: "marker", parent: name, max: 4096)
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case filterConditions = "FilterConditions"
            case marker = "Marker"
            case maxItems = "MaxItems"
            case sortCondition = "SortCondition"
        }
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// A list of domains.
        public let domains: [DomainSummary]?
        /// If there are more domains than you specified for MaxItems in the request,
        /// 			submit another request and include the value of NextPageMarker in the value
        /// 			of Marker.
        public let nextPageMarker: String?

        @inlinable
        public init(domains: [DomainSummary]? = nil, nextPageMarker: String? = nil) {
            self.domains = domains
            self.nextPageMarker = nextPageMarker
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "Domains"
            case nextPageMarker = "NextPageMarker"
        }
    }

    public struct ListOperationsRequest: AWSEncodableShape {
        /// For an initial request for a list of operations, omit this element. If the number of
        /// 			operations that are not yet complete is greater than the value that you specified for
        /// 				MaxItems, you can use Marker to return additional
        /// 			operations. Get the value of NextPageMarker from the previous response, and
        /// 			submit another request that includes the value of NextPageMarker in the
        /// 				Marker element.
        public let marker: String?
        /// Number of domains to be returned. Default: 20
        public let maxItems: Int?
        ///  The sort type for returned values.
        public let sortBy: ListOperationsSortAttributeName?
        ///  The sort order for returned values, either ascending or descending.
        public let sortOrder: SortOrder?
        ///  The status of the operations.
        public let status: [OperationStatus]?
        /// An optional parameter that lets you get information about all the operations that you
        /// 			submitted after a specified date and time. Specify the date and time in Unix time format
        /// 			and Coordinated Universal time (UTC).
        public let submittedSince: Date?
        ///  An arrays of the domains operation types.
        public let type: [OperationType]?

        @inlinable
        public init(marker: String? = nil, maxItems: Int? = nil, sortBy: ListOperationsSortAttributeName? = nil, sortOrder: SortOrder? = nil, status: [OperationStatus]? = nil, submittedSince: Date? = nil, type: [OperationType]? = nil) {
            self.marker = marker
            self.maxItems = maxItems
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.status = status
            self.submittedSince = submittedSince
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.marker, name: "marker", parent: name, max: 4096)
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
            try self.validate(self.status, name: "status", parent: name, max: 5)
            try self.validate(self.type, name: "type", parent: name, max: 21)
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxItems = "MaxItems"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case status = "Status"
            case submittedSince = "SubmittedSince"
            case type = "Type"
        }
    }

    public struct ListOperationsResponse: AWSDecodableShape {
        /// If there are more operations than you specified for MaxItems in the
        /// 			request, submit another request and include the value of NextPageMarker in
        /// 			the value of Marker.
        public let nextPageMarker: String?
        /// Lists summaries of the operations.
        public let operations: [OperationSummary]?

        @inlinable
        public init(nextPageMarker: String? = nil, operations: [OperationSummary]? = nil) {
            self.nextPageMarker = nextPageMarker
            self.operations = operations
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageMarker = "NextPageMarker"
            case operations = "Operations"
        }
    }

    public struct ListPricesRequest: AWSEncodableShape {
        /// For an initial request for a list of prices, omit this element. If the number of
        /// 			prices that are not yet complete is greater than the value that you specified for
        /// 				MaxItems, you can use Marker to return additional prices.
        /// 			Get the value of NextPageMarker from the previous response, and submit
        /// 			another request that includes the value of NextPageMarker in the
        /// 				Marker element.  Used only for all TLDs. If you specify a TLD, don't specify a
        /// 			Marker.
        public let marker: String?
        /// Number of Prices to be returned. Used only for all TLDs. If you specify a TLD, don't specify a
        /// 			MaxItems.
        public let maxItems: Int?
        /// The TLD for which you want to receive the pricing information. For example.
        /// 				.net. If a Tld value is not provided, a list of prices for all TLDs supported
        /// 			by Route 53 is returned.
        public let tld: String?

        @inlinable
        public init(marker: String? = nil, maxItems: Int? = nil, tld: String? = nil) {
            self.marker = marker
            self.maxItems = maxItems
            self.tld = tld
        }

        public func validate(name: String) throws {
            try self.validate(self.marker, name: "marker", parent: name, max: 4096)
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 1000)
            try self.validate(self.tld, name: "tld", parent: name, max: 255)
            try self.validate(self.tld, name: "tld", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxItems = "MaxItems"
            case tld = "Tld"
        }
    }

    public struct ListPricesResponse: AWSDecodableShape {
        /// If there are more prices than you specified for MaxItems in the request,
        /// 			submit another request and include the value of NextPageMarker in the value
        /// 			of Marker.  Used only for all TLDs. If you specify a TLD, don't specify a
        /// 				NextPageMarker.
        public let nextPageMarker: String?
        /// A complex type that includes all the pricing information. If you specify a TLD, this
        /// 			array contains only the pricing for that TLD.
        public let prices: [DomainPrice]?

        @inlinable
        public init(nextPageMarker: String? = nil, prices: [DomainPrice]? = nil) {
            self.nextPageMarker = nextPageMarker
            self.prices = prices
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageMarker = "NextPageMarker"
            case prices = "Prices"
        }
    }

    public struct ListTagsForDomainRequest: AWSEncodableShape {
        /// The domain for which you want to get a list of tags.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct ListTagsForDomainResponse: AWSDecodableShape {
        /// A list of the tags that are associated with the specified domain.
        public let tagList: [Tag]?

        @inlinable
        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct Nameserver: AWSEncodableShape & AWSDecodableShape {
        /// Glue IP address of a name server entry. Glue IP addresses are required only when the
        /// 			name of the name server is a subdomain of the domain. For example, if your domain is
        /// 			example.com and the name server for the domain is ns.example.com, you need to specify
        /// 			the IP address for ns.example.com. Constraints: The list can contain only one IPv4 and one IPv6 address.
        public let glueIps: [String]?
        /// The fully qualified host name of the name server. Constraint: Maximum 255 characters
        public let name: String

        @inlinable
        public init(glueIps: [String]? = nil, name: String) {
            self.glueIps = glueIps
            self.name = name
        }

        public func validate(name: String) throws {
            try self.glueIps?.forEach {
                try validate($0, name: "glueIps[]", parent: name, max: 45)
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case glueIps = "GlueIps"
            case name = "Name"
        }
    }

    public struct OperationSummary: AWSDecodableShape {
        ///  Name of the domain.
        public let domainName: String?
        ///  The date when the last change was made in Unix time format and Coordinated Universal
        /// 			Time (UTC).
        public let lastUpdatedDate: Date?
        ///  Message about the operation.
        public let message: String?
        /// Identifier returned to track the requested action.
        public let operationId: String?
        /// The current status of the requested operation in the system.
        public let status: OperationStatus?
        ///  Automatically checks whether there are no outstanding operations on domains that need
        /// 			customer attention.  Valid values are:    PENDING_ACCEPTANCE: The operation is waiting for acceptance from
        /// 					the account that is receiving the domain.    PENDING_CUSTOMER_ACTION: The operation is waiting for customer
        /// 					action, for example, returning an email.    PENDING_AUTHORIZATION: The operation is waiting for the form of
        /// 					authorization. For more information, see ResendOperationAuthorization.    PENDING_PAYMENT_VERIFICATION: The operation is waiting for the
        /// 					payment method to validate.    PENDING_SUPPORT_CASE: The operation includes a support case and
        /// 					is waiting for its resolution.
        public let statusFlag: StatusFlag?
        /// The date when the request was submitted.
        public let submittedDate: Date?
        /// Type of the action requested.
        public let type: OperationType?

        @inlinable
        public init(domainName: String? = nil, lastUpdatedDate: Date? = nil, message: String? = nil, operationId: String? = nil, status: OperationStatus? = nil, statusFlag: StatusFlag? = nil, submittedDate: Date? = nil, type: OperationType? = nil) {
            self.domainName = domainName
            self.lastUpdatedDate = lastUpdatedDate
            self.message = message
            self.operationId = operationId
            self.status = status
            self.statusFlag = statusFlag
            self.submittedDate = submittedDate
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case lastUpdatedDate = "LastUpdatedDate"
            case message = "Message"
            case operationId = "OperationId"
            case status = "Status"
            case statusFlag = "StatusFlag"
            case submittedDate = "SubmittedDate"
            case type = "Type"
        }
    }

    public struct PriceWithCurrency: AWSDecodableShape {
        /// The currency specifier.
        public let currency: String
        /// The price of a domain, in a specific currency.
        public let price: Double

        @inlinable
        public init(currency: String, price: Double) {
            self.currency = currency
            self.price = price
        }

        private enum CodingKeys: String, CodingKey {
            case currency = "Currency"
            case price = "Price"
        }
    }

    public struct PushDomainRequest: AWSEncodableShape {
        ///  Name of the domain.
        public let domainName: String
        ///  New IPS tag for the domain.
        public let target: String

        @inlinable
        public init(domainName: String, target: String) {
            self.domainName = domainName
            self.target = target
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.target, name: "target", parent: name, max: 255)
            try self.validate(self.target, name: "target", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case target = "Target"
        }
    }

    public struct RegisterDomainRequest: AWSEncodableShape {
        /// Provides detailed contact information. For information about the values that you
        /// 			specify for each element, see ContactDetail.
        public let adminContact: ContactDetail
        /// Indicates whether the domain will be automatically renewed (true) or not
        /// 				(false). Auto renewal only takes effect after the account is
        /// 			charged. Default: true
        public let autoRenew: Bool?
        /// Provides detailed contact information. For information about the values that you
        /// 			specify for each element, see ContactDetail.
        public let billingContact: ContactDetail?
        /// The domain name that you want to register. The top-level domain (TLD), such as .com,
        /// 			must be a TLD that Route 53 supports. For a list of supported TLDs, see Domains that You Can Register with Amazon Route 53 in the Amazon
        /// 				Route 53 Developer Guide. The domain name can contain only the following characters:   Letters a through z. Domain names are not case sensitive.   Numbers 0 through 9.   Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
        /// 				   Period (.) to separate the labels in the name, such as the . in
        /// 						example.com.   Internationalized domain names are not supported for some top-level domains. To
        /// 			determine whether the TLD that you want to use supports internationalized domain names,
        /// 			see Domains that You Can
        /// 				Register with Amazon Route 53. For more information, see Formatting Internationalized Domain Names.
        public let domainName: String
        /// The number of years that you want to register the domain for. Domains are registered
        /// 			for a minimum of one year. The maximum period depends on the top-level domain. For the
        /// 			range of valid values for your domain, see Domains that You Can
        /// 				Register with Amazon Route 53 in the Amazon Route 53 Developer
        /// 				Guide. Default: 1
        public let durationInYears: Int
        /// Reserved for future use.
        public let idnLangCode: String?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the admin contact.  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.  Default: true
        public let privacyProtectAdminContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 			true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the billing contact.  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.
        public let privacyProtectBillingContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the registrant contact (the domain owner).  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.  Default: true
        public let privacyProtectRegistrantContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the technical contact.  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.  Default: true
        public let privacyProtectTechContact: Bool?
        /// Provides detailed contact information. For information about the values that you
        /// 			specify for each element, see ContactDetail.
        public let registrantContact: ContactDetail
        /// Provides detailed contact information. For information about the values that you
        /// 			specify for each element, see ContactDetail.
        public let techContact: ContactDetail

        @inlinable
        public init(adminContact: ContactDetail, autoRenew: Bool? = nil, billingContact: ContactDetail? = nil, domainName: String, durationInYears: Int, idnLangCode: String? = nil, privacyProtectAdminContact: Bool? = nil, privacyProtectBillingContact: Bool? = nil, privacyProtectRegistrantContact: Bool? = nil, privacyProtectTechContact: Bool? = nil, registrantContact: ContactDetail, techContact: ContactDetail) {
            self.adminContact = adminContact
            self.autoRenew = autoRenew
            self.billingContact = billingContact
            self.domainName = domainName
            self.durationInYears = durationInYears
            self.idnLangCode = idnLangCode
            self.privacyProtectAdminContact = privacyProtectAdminContact
            self.privacyProtectBillingContact = privacyProtectBillingContact
            self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
            self.privacyProtectTechContact = privacyProtectTechContact
            self.registrantContact = registrantContact
            self.techContact = techContact
        }

        public func validate(name: String) throws {
            try self.adminContact.validate(name: "\(name).adminContact")
            try self.billingContact?.validate(name: "\(name).billingContact")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.durationInYears, name: "durationInYears", parent: name, max: 10)
            try self.validate(self.durationInYears, name: "durationInYears", parent: name, min: 1)
            try self.validate(self.idnLangCode, name: "idnLangCode", parent: name, pattern: "^|[A-Za-z]{2,3}$")
            try self.registrantContact.validate(name: "\(name).registrantContact")
            try self.techContact.validate(name: "\(name).techContact")
        }

        private enum CodingKeys: String, CodingKey {
            case adminContact = "AdminContact"
            case autoRenew = "AutoRenew"
            case billingContact = "BillingContact"
            case domainName = "DomainName"
            case durationInYears = "DurationInYears"
            case idnLangCode = "IdnLangCode"
            case privacyProtectAdminContact = "PrivacyProtectAdminContact"
            case privacyProtectBillingContact = "PrivacyProtectBillingContact"
            case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
            case privacyProtectTechContact = "PrivacyProtectTechContact"
            case registrantContact = "RegistrantContact"
            case techContact = "TechContact"
        }
    }

    public struct RegisterDomainResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct RejectDomainTransferFromAnotherAwsAccountRequest: AWSEncodableShape {
        /// The name of the domain that was specified when another Amazon Web Services account
        /// 			submitted a TransferDomainToAnotherAwsAccount request.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct RejectDomainTransferFromAnotherAwsAccountResponse: AWSDecodableShape {
        /// The identifier that TransferDomainToAnotherAwsAccount returned to track
        /// 			the progress of the request. Because the transfer request was rejected, the value is no
        /// 			longer valid, and you can't use GetOperationDetail to query the operation
        /// 			status.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct RenewDomainRequest: AWSEncodableShape {
        /// The year when the registration for the domain is set to expire. This value must match
        /// 			the current expiration date for the domain.
        public let currentExpiryYear: Int
        /// The name of the domain that you want to renew.
        public let domainName: String
        /// The number of years that you want to renew the domain for. The maximum number of years
        /// 			depends on the top-level domain. For the range of valid values for your domain, see
        /// 				Domains that You Can
        /// 				Register with Amazon Route 53 in the Amazon Route 53 Developer
        /// 				Guide. Default: 1
        public let durationInYears: Int?

        @inlinable
        public init(currentExpiryYear: Int = 0, domainName: String, durationInYears: Int? = nil) {
            self.currentExpiryYear = currentExpiryYear
            self.domainName = domainName
            self.durationInYears = durationInYears
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.durationInYears, name: "durationInYears", parent: name, max: 10)
            try self.validate(self.durationInYears, name: "durationInYears", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentExpiryYear = "CurrentExpiryYear"
            case domainName = "DomainName"
            case durationInYears = "DurationInYears"
        }
    }

    public struct RenewDomainResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct ResendContactReachabilityEmailRequest: AWSEncodableShape {
        /// The name of the domain for which you want Route 53 to resend a confirmation email to
        /// 			the registrant contact.
        public let domainName: String?

        @inlinable
        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
        }
    }

    public struct ResendContactReachabilityEmailResponse: AWSDecodableShape {
        /// The domain name for which you requested a confirmation email.
        public let domainName: String?
        /// The email address for the registrant contact at the time that we sent the verification
        /// 			email.
        public let emailAddress: String?
        ///  True if the email address for the registrant contact has already been
        /// 			verified, and false otherwise. If the email address has already been
        /// 			verified, we don't send another confirmation email.
        public let isAlreadyVerified: Bool?

        @inlinable
        public init(domainName: String? = nil, emailAddress: String? = nil, isAlreadyVerified: Bool? = nil) {
            self.domainName = domainName
            self.emailAddress = emailAddress
            self.isAlreadyVerified = isAlreadyVerified
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case emailAddress = "emailAddress"
            case isAlreadyVerified = "isAlreadyVerified"
        }
    }

    public struct ResendOperationAuthorizationRequest: AWSEncodableShape {
        ///  Operation ID.
        public let operationId: String

        @inlinable
        public init(operationId: String) {
            self.operationId = operationId
        }

        public func validate(name: String) throws {
            try self.validate(self.operationId, name: "operationId", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct RetrieveDomainAuthCodeRequest: AWSEncodableShape {
        /// The name of the domain that you want to get an authorization code for.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct RetrieveDomainAuthCodeResponse: AWSDecodableShape {
        /// The authorization code for the domain.
        public let authCode: String?

        @inlinable
        public init(authCode: String? = nil) {
            self.authCode = authCode
        }

        private enum CodingKeys: String, CodingKey {
            case authCode = "AuthCode"
        }
    }

    public struct SortCondition: AWSEncodableShape {
        /// Field to be used for sorting the list of domains. It can be either the name or the
        /// 			expiration for a domain. Note that if filterCondition is used in the same
        /// 				ListDomains
        /// 			call, the field used for sorting has to be the same as the field used for
        /// 			filtering.
        public let name: ListDomainsAttributeName
        /// The sort order for a list of domains. Either ascending (ASC) or descending
        /// 			(DES).
        public let sortOrder: SortOrder

        @inlinable
        public init(name: ListDomainsAttributeName, sortOrder: SortOrder) {
            self.name = name
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case sortOrder = "SortOrder"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key (name) of a tag. Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each key can be 1-128 characters long.
        public let key: String?
        /// The value of a tag. Valid values: A-Z, a-z, 0-9, space, ".:/=+\-@" Constraints: Each value can be 0-256 characters long.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TransferDomainRequest: AWSEncodableShape {
        /// Provides detailed contact information.
        public let adminContact: ContactDetail
        /// The authorization code for the domain. You get this value from the current
        /// 			registrar.
        public let authCode: String?
        /// Indicates whether the domain will be automatically renewed (true) or not (false). Auto
        /// 			renewal only takes effect after the account is charged. Default: true
        public let autoRenew: Bool?
        /// Provides detailed contact information.
        public let billingContact: ContactDetail?
        /// The name of the domain that you want to transfer to Route 53. The top-level domain
        /// 			(TLD), such as .com, must be a TLD that Route 53 supports. For a list of supported TLDs,
        /// 			see Domains that You Can
        /// 				Register with Amazon Route 53 in the Amazon Route 53 Developer
        /// 				Guide. The domain name can contain only the following characters:   Letters a through z. Domain names are not case sensitive.   Numbers 0 through 9.   Hyphen (-). You can't specify a hyphen at the beginning or end of a label.
        /// 				   Period (.) to separate the labels in the name, such as the . in
        /// 						example.com.
        public let domainName: String
        /// The number of years that you want to register the domain for. Domains are registered
        /// 			for a minimum of one year. The maximum period depends on the top-level domain. Default: 1
        public let durationInYears: Int
        /// Reserved for future use.
        public let idnLangCode: String?
        /// Contains details for the host and glue IP addresses.
        public let nameservers: [Nameserver]?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 				true, WHOIS ("who is") queries return contact information for the
        /// 			registrar, the phrase "REDACTED FOR PRIVACY", or "On behalf of
        /// 			owner.".  While some domains may allow different privacy settings per contact, we recommend
        /// 				specifying the same privacy setting for all contacts.  Default: true
        public let privacyProtectAdminContact: Bool?
        /// 			Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 			true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the billing contact.
        /// 		  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.
        public let privacyProtectBillingContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the registrant contact (domain owner).  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.  Default: true
        public let privacyProtectRegistrantContact: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the technical contact.  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.  Default: true
        public let privacyProtectTechContact: Bool?
        /// Provides detailed contact information.
        public let registrantContact: ContactDetail
        /// Provides detailed contact information.
        public let techContact: ContactDetail

        @inlinable
        public init(adminContact: ContactDetail, authCode: String? = nil, autoRenew: Bool? = nil, billingContact: ContactDetail? = nil, domainName: String, durationInYears: Int, idnLangCode: String? = nil, nameservers: [Nameserver]? = nil, privacyProtectAdminContact: Bool? = nil, privacyProtectBillingContact: Bool? = nil, privacyProtectRegistrantContact: Bool? = nil, privacyProtectTechContact: Bool? = nil, registrantContact: ContactDetail, techContact: ContactDetail) {
            self.adminContact = adminContact
            self.authCode = authCode
            self.autoRenew = autoRenew
            self.billingContact = billingContact
            self.domainName = domainName
            self.durationInYears = durationInYears
            self.idnLangCode = idnLangCode
            self.nameservers = nameservers
            self.privacyProtectAdminContact = privacyProtectAdminContact
            self.privacyProtectBillingContact = privacyProtectBillingContact
            self.privacyProtectRegistrantContact = privacyProtectRegistrantContact
            self.privacyProtectTechContact = privacyProtectTechContact
            self.registrantContact = registrantContact
            self.techContact = techContact
        }

        public func validate(name: String) throws {
            try self.adminContact.validate(name: "\(name).adminContact")
            try self.validate(self.authCode, name: "authCode", parent: name, max: 1024)
            try self.billingContact?.validate(name: "\(name).billingContact")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.durationInYears, name: "durationInYears", parent: name, max: 10)
            try self.validate(self.durationInYears, name: "durationInYears", parent: name, min: 1)
            try self.validate(self.idnLangCode, name: "idnLangCode", parent: name, pattern: "^|[A-Za-z]{2,3}$")
            try self.nameservers?.forEach {
                try $0.validate(name: "\(name).nameservers[]")
            }
            try self.registrantContact.validate(name: "\(name).registrantContact")
            try self.techContact.validate(name: "\(name).techContact")
        }

        private enum CodingKeys: String, CodingKey {
            case adminContact = "AdminContact"
            case authCode = "AuthCode"
            case autoRenew = "AutoRenew"
            case billingContact = "BillingContact"
            case domainName = "DomainName"
            case durationInYears = "DurationInYears"
            case idnLangCode = "IdnLangCode"
            case nameservers = "Nameservers"
            case privacyProtectAdminContact = "PrivacyProtectAdminContact"
            case privacyProtectBillingContact = "PrivacyProtectBillingContact"
            case privacyProtectRegistrantContact = "PrivacyProtectRegistrantContact"
            case privacyProtectTechContact = "PrivacyProtectTechContact"
            case registrantContact = "RegistrantContact"
            case techContact = "TechContact"
        }
    }

    public struct TransferDomainResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct TransferDomainToAnotherAwsAccountRequest: AWSEncodableShape {
        /// The account ID of the Amazon Web Services account that you want to transfer the domain
        /// 			to, for example, 111122223333.
        public let accountId: String
        /// The name of the domain that you want to transfer from the current Amazon Web Services account to another account.
        public let domainName: String

        @inlinable
        public init(accountId: String, domainName: String) {
            self.accountId = accountId
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^(\\d{12})$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case domainName = "DomainName"
        }
    }

    public struct TransferDomainToAnotherAwsAccountResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?
        /// To finish transferring a domain to another Amazon Web Services account, the account
        /// 			that the domain is being transferred to must submit an AcceptDomainTransferFromAnotherAwsAccount request. The request must include
        /// 			the value of the Password element that was returned in the
        /// 				TransferDomainToAnotherAwsAccount response.
        public let password: String?

        @inlinable
        public init(operationId: String? = nil, password: String? = nil) {
            self.operationId = operationId
            self.password = password
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
            case password = "Password"
        }
    }

    public struct UpdateDomainContactPrivacyRequest: AWSEncodableShape {
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 			true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the admin contact.  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.
        public let adminPrivacy: Bool?
        /// 			Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 			true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the billing contact.
        /// 		  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.
        public let billingPrivacy: Bool?
        /// The name of the domain that you want to update the privacy setting for.
        public let domainName: String
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 			true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the registrant contact (domain owner).  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.
        public let registrantPrivacy: Bool?
        /// Whether you want to conceal contact information from WHOIS queries. If you specify
        /// 				true, WHOIS ("who is") queries return contact information either for
        /// 			Amazon Registrar or for our registrar associate,
        /// 			Gandi. If you specify false, WHOIS queries return the
        /// 			information that you entered for the technical contact.  You must specify the same privacy setting for the administrative, billing, registrant, and
        /// 				technical contacts.
        public let techPrivacy: Bool?

        @inlinable
        public init(adminPrivacy: Bool? = nil, billingPrivacy: Bool? = nil, domainName: String, registrantPrivacy: Bool? = nil, techPrivacy: Bool? = nil) {
            self.adminPrivacy = adminPrivacy
            self.billingPrivacy = billingPrivacy
            self.domainName = domainName
            self.registrantPrivacy = registrantPrivacy
            self.techPrivacy = techPrivacy
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case adminPrivacy = "AdminPrivacy"
            case billingPrivacy = "BillingPrivacy"
            case domainName = "DomainName"
            case registrantPrivacy = "RegistrantPrivacy"
            case techPrivacy = "TechPrivacy"
        }
    }

    public struct UpdateDomainContactPrivacyResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To use this ID to query the
        /// 			operation status, use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct UpdateDomainContactRequest: AWSEncodableShape {
        /// Provides detailed contact information.
        public let adminContact: ContactDetail?
        /// Provides detailed contact information.
        public let billingContact: ContactDetail?
        ///  Customer's consent for the owner change request. Required if the domain is not free (consent price is more than $0.00).
        public let consent: Consent?
        /// The name of the domain that you want to update contact information for.
        public let domainName: String
        /// Provides detailed contact information.
        public let registrantContact: ContactDetail?
        /// Provides detailed contact information.
        public let techContact: ContactDetail?

        @inlinable
        public init(adminContact: ContactDetail? = nil, billingContact: ContactDetail? = nil, consent: Consent? = nil, domainName: String, registrantContact: ContactDetail? = nil, techContact: ContactDetail? = nil) {
            self.adminContact = adminContact
            self.billingContact = billingContact
            self.consent = consent
            self.domainName = domainName
            self.registrantContact = registrantContact
            self.techContact = techContact
        }

        public func validate(name: String) throws {
            try self.adminContact?.validate(name: "\(name).adminContact")
            try self.billingContact?.validate(name: "\(name).billingContact")
            try self.consent?.validate(name: "\(name).consent")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.registrantContact?.validate(name: "\(name).registrantContact")
            try self.techContact?.validate(name: "\(name).techContact")
        }

        private enum CodingKeys: String, CodingKey {
            case adminContact = "AdminContact"
            case billingContact = "BillingContact"
            case consent = "Consent"
            case domainName = "DomainName"
            case registrantContact = "RegistrantContact"
            case techContact = "TechContact"
        }
    }

    public struct UpdateDomainContactResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct UpdateDomainNameserversRequest: AWSEncodableShape {
        /// The name of the domain that you want to change name servers for.
        public let domainName: String
        /// The authorization key for .fi domains
        public let fiAuthKey: String?
        /// A list of new name servers for the domain.
        public let nameservers: [Nameserver]

        @inlinable
        public init(domainName: String, nameservers: [Nameserver]) {
            self.domainName = domainName
            self.fiAuthKey = nil
            self.nameservers = nameservers
        }

        @available(*, deprecated, message: "Members fiAuthKey have been deprecated")
        @inlinable
        public init(domainName: String, fiAuthKey: String? = nil, nameservers: [Nameserver]) {
            self.domainName = domainName
            self.fiAuthKey = fiAuthKey
            self.nameservers = nameservers
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.fiAuthKey, name: "fiAuthKey", parent: name, max: 255)
            try self.nameservers.forEach {
                try $0.validate(name: "\(name).nameservers[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case fiAuthKey = "FIAuthKey"
            case nameservers = "Nameservers"
        }
    }

    public struct UpdateDomainNameserversResponse: AWSDecodableShape {
        /// Identifier for tracking the progress of the request. To query the operation status,
        /// 			use GetOperationDetail.
        public let operationId: String?

        @inlinable
        public init(operationId: String? = nil) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct UpdateTagsForDomainRequest: AWSEncodableShape {
        /// The domain for which you want to add or update tags.
        public let domainName: String
        /// A list of the tag keys and values that you want to add or update. If you specify a key
        /// 			that already exists, the corresponding value will be replaced.
        public let tagsToUpdate: [Tag]?

        @inlinable
        public init(domainName: String, tagsToUpdate: [Tag]? = nil) {
            self.domainName = domainName
            self.tagsToUpdate = tagsToUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.tagsToUpdate?.forEach {
                try $0.validate(name: "\(name).tagsToUpdate[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case tagsToUpdate = "TagsToUpdate"
        }
    }

    public struct UpdateTagsForDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ViewBillingRequest: AWSEncodableShape {
        /// The end date and time for the time period for which you want a list of billing
        /// 			records. Specify the date and time in Unix time format and Coordinated Universal time
        /// 			(UTC).
        public let end: Date?
        /// For an initial request for a list of billing records, omit this element. If the number
        /// 			of billing records that are associated with the current Amazon Web Services account
        /// 			during the specified period is greater than the value that you specified for
        /// 				MaxItems, you can use Marker to return additional billing
        /// 			records. Get the value of NextPageMarker from the previous response, and
        /// 			submit another request that includes the value of NextPageMarker in the
        /// 				Marker element.  Constraints: The marker must match the value of NextPageMarker that was
        /// 			returned in the previous response.
        public let marker: String?
        /// The number of billing records to be returned. Default: 20
        public let maxItems: Int?
        /// The beginning date and time for the time period for which you want a list of billing
        /// 			records. Specify the date and time in Unix time format and Coordinated Universal time
        /// 			(UTC).
        public let start: Date?

        @inlinable
        public init(end: Date? = nil, marker: String? = nil, maxItems: Int? = nil, start: Date? = nil) {
            self.end = end
            self.marker = marker
            self.maxItems = maxItems
            self.start = start
        }

        public func validate(name: String) throws {
            try self.validate(self.marker, name: "marker", parent: name, max: 4096)
            try self.validate(self.maxItems, name: "maxItems", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case marker = "Marker"
            case maxItems = "MaxItems"
            case start = "Start"
        }
    }

    public struct ViewBillingResponse: AWSDecodableShape {
        /// A summary of billing records.
        public let billingRecords: [BillingRecord]?
        /// If there are more billing records than you specified for MaxItems in the
        /// 			request, submit another request and include the value of NextPageMarker in
        /// 			the value of Marker.
        public let nextPageMarker: String?

        @inlinable
        public init(billingRecords: [BillingRecord]? = nil, nextPageMarker: String? = nil) {
            self.billingRecords = billingRecords
            self.nextPageMarker = nextPageMarker
        }

        private enum CodingKeys: String, CodingKey {
            case billingRecords = "BillingRecords"
            case nextPageMarker = "NextPageMarker"
        }
    }
}

// MARK: - Errors

/// Error enum for Route53Domains
public struct Route53DomainsErrorType: AWSErrorType {
    enum Code: String {
        case dnssecLimitExceeded = "DnssecLimitExceeded"
        case domainLimitExceeded = "DomainLimitExceeded"
        case duplicateRequest = "DuplicateRequest"
        case invalidInput = "InvalidInput"
        case operationLimitExceeded = "OperationLimitExceeded"
        case tldRulesViolation = "TLDRulesViolation"
        case unsupportedTLD = "UnsupportedTLD"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Route53Domains
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  This error is returned if you call AssociateDelegationSignerToDomain
    /// 			when the specified domain has reached the maximum number of DS records. You can't add
    /// 			any additional DS records unless you delete an existing one first.
    public static var dnssecLimitExceeded: Self { .init(.dnssecLimitExceeded) }
    /// The number of domains has exceeded the allowed threshold for the account.
    public static var domainLimitExceeded: Self { .init(.domainLimitExceeded) }
    /// The request is already in progress for the domain.
    public static var duplicateRequest: Self { .init(.duplicateRequest) }
    /// The requested item is not acceptable. For example, for APIs that accept a domain name,
    /// 			the request might specify a domain name that doesn't belong to the account that
    /// 			submitted the request. For AcceptDomainTransferFromAnotherAwsAccount, the
    /// 			password might be invalid.
    public static var invalidInput: Self { .init(.invalidInput) }
    /// The number of operations or jobs running exceeded the allowed threshold for the
    /// 			account.
    public static var operationLimitExceeded: Self { .init(.operationLimitExceeded) }
    /// The top-level domain does not support this operation.
    public static var tldRulesViolation: Self { .init(.tldRulesViolation) }
    /// Amazon Route 53 does not support this top-level domain (TLD).
    public static var unsupportedTLD: Self { .init(.unsupportedTLD) }
}

extension Route53DomainsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "DuplicateRequest": Route53Domains.DuplicateRequest.self
    ]
}

extension Route53DomainsErrorType: Equatable {
    public static func == (lhs: Route53DomainsErrorType, rhs: Route53DomainsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension Route53DomainsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
