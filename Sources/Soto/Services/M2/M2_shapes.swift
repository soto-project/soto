//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension M2 {
    // MARK: Enums

    public enum ApplicationDeploymentLifecycle: String, CustomStringConvertible, Codable, _SotoSendable {
        case deployed = "Deployed"
        case deploying = "Deploying"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationLifecycle: String, CustomStringConvertible, Codable, _SotoSendable {
        case available = "Available"
        case created = "Created"
        case creating = "Creating"
        case deleting = "Deleting"
        case deletingFromEnvironment = "Deleting From Environment"
        case failed = "Failed"
        case ready = "Ready"
        case running = "Running"
        case starting = "Starting"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationVersionLifecycle: String, CustomStringConvertible, Codable, _SotoSendable {
        case available = "Available"
        case creating = "Creating"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public enum BatchJobExecutionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "Cancelled"
        case cancelling = "Cancelling"
        case dispatching = "Dispatching"
        case failed = "Failed"
        case holding = "Holding"
        case running = "Running"
        case submitting = "Submitting"
        case succeeded = "Succeeded"
        case succeededWithWarning = "Succeeded With Warning"
        public var description: String { return self.rawValue }
    }

    public enum BatchJobType: String, CustomStringConvertible, Codable, _SotoSendable {
        case jes2 = "JES2"
        case jes3 = "JES3"
        case vse = "VSE"
        public var description: String { return self.rawValue }
    }

    public enum DataSetTaskLifecycle: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "Completed"
        case creating = "Creating"
        case running = "Running"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentLifecycle: String, CustomStringConvertible, Codable, _SotoSendable {
        case deploying = "Deploying"
        case failed = "Failed"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum EngineType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bluage
        case microfocus
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentLifecycle: String, CustomStringConvertible, Codable, _SotoSendable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum BatchJobDefinition: AWSDecodableShape, _SotoSendable {
        /// Specifies a file containing a batch job definition.
        case fileBatchJobDefinition(FileBatchJobDefinition)
        /// A script containing a batch job definition.
        case scriptBatchJobDefinition(ScriptBatchJobDefinition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileBatchJobDefinition:
                let value = try container.decode(FileBatchJobDefinition.self, forKey: .fileBatchJobDefinition)
                self = .fileBatchJobDefinition(value)
            case .scriptBatchJobDefinition:
                let value = try container.decode(ScriptBatchJobDefinition.self, forKey: .scriptBatchJobDefinition)
                self = .scriptBatchJobDefinition(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileBatchJobDefinition
            case scriptBatchJobDefinition
        }
    }

    public enum BatchJobIdentifier: AWSEncodableShape, _SotoSendable {
        /// Specifies a file associated with a specific batch job.
        case fileBatchJobIdentifier(FileBatchJobIdentifier)
        /// A batch job identifier in which the batch job to run is identified by the script name.
        case scriptBatchJobIdentifier(ScriptBatchJobIdentifier)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fileBatchJobIdentifier(let value):
                try container.encode(value, forKey: .fileBatchJobIdentifier)
            case .scriptBatchJobIdentifier(let value):
                try container.encode(value, forKey: .scriptBatchJobIdentifier)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileBatchJobIdentifier
            case scriptBatchJobIdentifier
        }
    }

    public enum DataSetImportConfig: AWSEncodableShape, _SotoSendable {
        /// The data sets.
        case dataSets([DataSetImportItem])
        /// The Amazon S3 location of the data sets.
        case s3Location(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dataSets(let value):
                try container.encode(value, forKey: .dataSets)
            case .s3Location(let value):
                try container.encode(value, forKey: .s3Location)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dataSets(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).dataSets[]")
                }
                try self.validate(value, name: "dataSets", parent: name, max: 100)
                try self.validate(value, name: "dataSets", parent: name, min: 1)
            case .s3Location(let value):
                try self.validate(value, name: "s3Location", parent: name, pattern: "^\\S{1,2000}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dataSets
            case s3Location
        }
    }

    public enum DatasetDetailOrgAttributes: AWSDecodableShape, _SotoSendable {
        /// The generation data group of the data set.
        case gdg(GdgDetailAttributes)
        /// The details of a VSAM data set.
        case vsam(VsamDetailAttributes)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .gdg:
                let value = try container.decode(GdgDetailAttributes.self, forKey: .gdg)
                self = .gdg(value)
            case .vsam:
                let value = try container.decode(VsamDetailAttributes.self, forKey: .vsam)
                self = .vsam(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gdg
            case vsam
        }
    }

    public enum DatasetOrgAttributes: AWSEncodableShape, _SotoSendable {
        /// The generation data group of the data set.
        case gdg(GdgAttributes)
        /// The details of a VSAM data set.
        case vsam(VsamAttributes)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .gdg(let value):
                try container.encode(value, forKey: .gdg)
            case .vsam(let value):
                try container.encode(value, forKey: .vsam)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gdg
            case vsam
        }
    }

    public enum Definition: AWSEncodableShape, _SotoSendable {
        /// The content of the application definition. This is a JSON object that contains the resource configuration/definitions that identify an application.
        case content(String)
        /// The S3 bucket that contains the application definition.
        case s3Location(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .content(let value):
                try container.encode(value, forKey: .content)
            case .s3Location(let value):
                try container.encode(value, forKey: .s3Location)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .content(let value):
                try self.validate(value, name: "content", parent: name, max: 65000)
                try self.validate(value, name: "content", parent: name, min: 1)
            case .s3Location(let value):
                try self.validate(value, name: "s3Location", parent: name, pattern: "^\\S{1,2000}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case s3Location
        }
    }

    public enum StorageConfiguration: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// Defines the storage configuration for an Amazon EFS file system.
        case efs(EfsStorageConfiguration)
        /// Defines the storage configuration for an Amazon FSx file system.
        case fsx(FsxStorageConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .efs:
                let value = try container.decode(EfsStorageConfiguration.self, forKey: .efs)
                self = .efs(value)
            case .fsx:
                let value = try container.decode(FsxStorageConfiguration.self, forKey: .fsx)
                self = .fsx(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .efs(let value):
                try container.encode(value, forKey: .efs)
            case .fsx(let value):
                try container.encode(value, forKey: .fsx)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .efs(let value):
                try value.validate(name: "\(name).efs")
            case .fsx(let value):
                try value.validate(name: "\(name).fsx")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case efs
            case fsx
        }
    }

    // MARK: Shapes

    public struct AlternateKey: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the alternate key values are supposed to be unique for the given data set.
        public let allowDuplicates: Bool?
        /// A strictly positive integer value representing the length of the alternate key.
        public let length: Int
        /// The name of the alternate key.
        public let name: String?
        /// A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.
        public let offset: Int

        public init(allowDuplicates: Bool? = nil, length: Int, name: String? = nil, offset: Int) {
            self.allowDuplicates = allowDuplicates
            self.length = length
            self.name = name
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case allowDuplicates
            case length
            case name
            case offset
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationArn: String
        /// The unique identifier of the application.
        public let applicationId: String
        /// The version of the application.
        public let applicationVersion: Int
        /// The timestamp when the application was created.
        public let creationTime: Date
        /// Indicates either an ongoing deployment or if the application has ever deployed successfully.
        public let deploymentStatus: ApplicationDeploymentLifecycle?
        /// The description of the application.
        public let description: String?
        /// The type of the target platform for this application.
        public let engineType: EngineType
        /// The unique identifier of the runtime environment that hosts this application.
        public let environmentId: String?
        /// The timestamp when you last started the application. Null until the application runs for the first time.
        public let lastStartTime: Date?
        /// The name of the application.
        public let name: String
        /// The status of the application.
        public let status: ApplicationLifecycle
        /// Indicates the status of the latest version of the application.
        public let versionStatus: ApplicationVersionLifecycle?

        public init(applicationArn: String, applicationId: String, applicationVersion: Int, creationTime: Date, deploymentStatus: ApplicationDeploymentLifecycle? = nil, description: String? = nil, engineType: EngineType, environmentId: String? = nil, lastStartTime: Date? = nil, name: String, status: ApplicationLifecycle, versionStatus: ApplicationVersionLifecycle? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.description = description
            self.engineType = engineType
            self.environmentId = environmentId
            self.lastStartTime = lastStartTime
            self.name = name
            self.status = status
            self.versionStatus = versionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn
            case applicationId
            case applicationVersion
            case creationTime
            case deploymentStatus
            case description
            case engineType
            case environmentId
            case lastStartTime
            case name
            case status
            case versionStatus
        }
    }

    public struct ApplicationVersionSummary: AWSDecodableShape {
        /// The application version.
        public let applicationVersion: Int
        /// The timestamp when the application version was created.
        public let creationTime: Date
        /// The status of the application.
        public let status: ApplicationVersionLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationVersion: Int, creationTime: Date, status: ApplicationVersionLifecycle, statusReason: String? = nil) {
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion
            case creationTime
            case status
            case statusReason
        }
    }

    public struct BatchJobExecutionSummary: AWSDecodableShape {
        /// The unique identifier of the application that hosts this batch job.
        public let applicationId: String
        /// The timestamp when this batch job execution ended.
        public let endTime: Date?
        /// The unique identifier of this execution of the batch job.
        public let executionId: String
        /// The unique identifier of a particular batch job.
        public let jobId: String?
        /// The name of a particular batch job.
        public let jobName: String?
        /// The type of a particular batch job execution.
        public let jobType: BatchJobType?
        /// The timestamp when a particular batch job execution started.
        public let startTime: Date
        /// The status of a particular batch job execution.
        public let status: BatchJobExecutionStatus

        public init(applicationId: String, endTime: Date? = nil, executionId: String, jobId: String? = nil, jobName: String? = nil, jobType: BatchJobType? = nil, startTime: Date, status: BatchJobExecutionStatus) {
            self.applicationId = applicationId
            self.endTime = endTime
            self.executionId = executionId
            self.jobId = jobId
            self.jobName = jobName
            self.jobType = jobType
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case endTime
            case executionId
            case jobId
            case jobName
            case jobType
            case startTime
            case status
        }
    }

    public struct CancelBatchJobExecutionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "executionId", location: .uri("executionId"))
        ]

        /// The unique identifier of the application.
        public let applicationId: String
        /// The unique identifier of the batch job execution.
        public let executionId: String

        public init(applicationId: String, executionId: String) {
            self.applicationId = applicationId
            self.executionId = executionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.executionId, name: "executionId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelBatchJobExecutionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier the service generates to ensure the idempotency of the request to create an application. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
        public let definition: Definition
        /// The description of the application.
        public let description: String?
        /// The type of the target platform for this application.
        public let engineType: EngineType
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The unique identifier of the application.
        public let name: String
        /// A list of tags to apply to the application.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateApplicationRequest.idempotencyToken(), definition: Definition, description: String? = nil, engineType: EngineType, kmsKeyId: String? = nil, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.definition = definition
            self.description = description
            self.engineType = engineType
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case definition
            case description
            case engineType
            case kmsKeyId
            case name
            case tags
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationArn: String
        /// The unique application identifier.
        public let applicationId: String
        /// The version number of the application.
        public let applicationVersion: Int

        public init(applicationArn: String, applicationId: String, applicationVersion: Int) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn
            case applicationId
            case applicationVersion
        }
    }

    public struct CreateDataSetImportTaskRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The unique identifier of the application for which you want to import data sets.
        public let applicationId: String
        ///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a data set import. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The data set import task configuration.
        public let importConfig: DataSetImportConfig

        public init(applicationId: String, clientToken: String? = CreateDataSetImportTaskRequest.idempotencyToken(), importConfig: DataSetImportConfig) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.importConfig = importConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.importConfig.validate(name: "\(name).importConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case importConfig
        }
    }

    public struct CreateDataSetImportTaskResponse: AWSDecodableShape {
        /// The task identifier. This operation is asynchronous. Use this identifier with the GetDataSetImportTask operation to obtain the status of this task.
        public let taskId: String

        public init(taskId: String) {
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case taskId
        }
    }

    public struct CreateDeploymentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The application identifier.
        public let applicationId: String
        /// The version of the application to deploy.
        public let applicationVersion: Int
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a deployment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The identifier of the runtime environment where you want to deploy this application.
        public let environmentId: String

        public init(applicationId: String, applicationVersion: Int, clientToken: String? = CreateDeploymentRequest.idempotencyToken(), environmentId: String) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.clientToken = clientToken
            self.environmentId = environmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion
            case clientToken
            case environmentId
        }
    }

    public struct CreateDeploymentResponse: AWSDecodableShape {
        /// The unique identifier of the deployment.
        public let deploymentId: String

        public init(deploymentId: String) {
            self.deploymentId = deploymentId
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId
        }
    }

    public struct CreateEnvironmentRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create an environment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The description of the runtime environment.
        public let description: String?
        /// The engine type for the runtime environment.
        public let engineType: EngineType
        /// The version of the engine type for the runtime environment.
        public let engineVersion: String?
        /// The details of a high availability configuration for this runtime environment.
        public let highAvailabilityConfig: HighAvailabilityConfig?
        /// The type of instance for the runtime environment.
        public let instanceType: String
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The name of the runtime environment. Must be unique within the account.
        public let name: String
        /// Configures the maintenance window you want for the runtime environment. If you do not provide a value, a random system-generated value will be assigned.
        public let preferredMaintenanceWindow: String?
        /// Specifies whether the runtime environment is publicly accessible.
        public let publiclyAccessible: Bool?
        /// The list of security groups for the VPC associated with this runtime environment.
        public let securityGroupIds: [String]?
        /// Optional. The storage configurations for this runtime environment.
        public let storageConfigurations: [StorageConfiguration]?
        /// The list of subnets associated with the VPC for this runtime environment.
        public let subnetIds: [String]?
        /// The tags for the runtime environment.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateEnvironmentRequest.idempotencyToken(), description: String? = nil, engineType: EngineType, engineVersion: String? = nil, highAvailabilityConfig: HighAvailabilityConfig? = nil, instanceType: String, kmsKeyId: String? = nil, name: String, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, securityGroupIds: [String]? = nil, storageConfigurations: [StorageConfiguration]? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.highAvailabilityConfig = highAvailabilityConfig
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.storageConfigurations = storageConfigurations
            self.subnetIds = subnetIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^\\S{1,10}$")
            try self.highAvailabilityConfig?.validate(name: "\(name).highAvailabilityConfig")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^\\S{1,20}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "^\\S{1,50}$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^\\S{1,50}$")
            }
            try self.storageConfigurations?.forEach {
                try $0.validate(name: "\(name).storageConfigurations[]")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^\\S{1,50}$")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case engineType
            case engineVersion
            case highAvailabilityConfig
            case instanceType
            case kmsKeyId
            case name
            case preferredMaintenanceWindow
            case publiclyAccessible
            case securityGroupIds
            case storageConfigurations
            case subnetIds
            case tags
        }
    }

    public struct CreateEnvironmentResponse: AWSDecodableShape {
        /// The unique identifier of the runtime environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId
        }
    }

    public struct DataSet: AWSEncodableShape {
        /// The logical identifier for a specific data set (in mainframe format).
        public let datasetName: String
        /// The type of dataset. The only supported value is VSAM.
        public let datasetOrg: DatasetOrgAttributes
        /// The length of a record.
        public let recordLength: RecordLength
        /// The relative location of the data set in the database or file system.
        public let relativePath: String?
        /// The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam.
        public let storageType: String?

        public init(datasetName: String, datasetOrg: DatasetOrgAttributes, recordLength: RecordLength, relativePath: String? = nil, storageType: String? = nil) {
            self.datasetName = datasetName
            self.datasetOrg = datasetOrg
            self.recordLength = recordLength
            self.relativePath = relativePath
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case datasetName
            case datasetOrg
            case recordLength
            case relativePath
            case storageType
        }
    }

    public struct DataSetImportItem: AWSEncodableShape {
        /// The data set.
        public let dataSet: DataSet
        /// The location of the data set.
        public let externalLocation: ExternalLocation

        public init(dataSet: DataSet, externalLocation: ExternalLocation) {
            self.dataSet = dataSet
            self.externalLocation = externalLocation
        }

        public func validate(name: String) throws {
            try self.externalLocation.validate(name: "\(name).externalLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSet
            case externalLocation
        }
    }

    public struct DataSetImportSummary: AWSDecodableShape {
        /// The number of data set imports that have failed.
        public let failed: Int
        /// The number of data set imports that are in progress.
        public let inProgress: Int
        /// The number of data set imports that are pending.
        public let pending: Int
        /// The number of data set imports that have succeeded.
        public let succeeded: Int
        /// The total number of data set imports.
        public let total: Int

        public init(failed: Int, inProgress: Int, pending: Int, succeeded: Int, total: Int) {
            self.failed = failed
            self.inProgress = inProgress
            self.pending = pending
            self.succeeded = succeeded
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case failed
            case inProgress
            case pending
            case succeeded
            case total
        }
    }

    public struct DataSetImportTask: AWSDecodableShape {
        /// The status of the data set import task.
        public let status: DataSetTaskLifecycle
        /// A summary of the data set import task.
        public let summary: DataSetImportSummary
        /// The identifier of the data set import task.
        public let taskId: String

        public init(status: DataSetTaskLifecycle, summary: DataSetImportSummary, taskId: String) {
            self.status = status
            self.summary = summary
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case status
            case summary
            case taskId
        }
    }

    public struct DataSetSummary: AWSDecodableShape {
        /// The timestamp when the data set was created.
        public let creationTime: Date?
        /// The name of the data set.
        public let dataSetName: String
        /// The type of data set. The only supported value is VSAM.
        public let dataSetOrg: String?
        /// The format of the data set.
        public let format: String?
        /// The last time the data set was referenced.
        public let lastReferencedTime: Date?
        /// The last time the data set was updated.
        public let lastUpdatedTime: Date?

        public init(creationTime: Date? = nil, dataSetName: String, dataSetOrg: String? = nil, format: String? = nil, lastReferencedTime: Date? = nil, lastUpdatedTime: Date? = nil) {
            self.creationTime = creationTime
            self.dataSetName = dataSetName
            self.dataSetOrg = dataSetOrg
            self.format = format
            self.lastReferencedTime = lastReferencedTime
            self.lastUpdatedTime = lastUpdatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case dataSetName
            case dataSetOrg
            case format
            case lastReferencedTime
            case lastUpdatedTime
        }
    }

    public struct DeleteApplicationFromEnvironmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "environmentId", location: .uri("environmentId"))
        ]

        /// The unique identifier of the application you want to delete.
        public let applicationId: String
        /// The unique identifier of the runtime environment where the application was previously deployed.
        public let environmentId: String

        public init(applicationId: String, environmentId: String) {
            self.applicationId = applicationId
            self.environmentId = environmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationFromEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The unique identifier of the application you want to delete.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEnvironmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "environmentId", location: .uri("environmentId"))
        ]

        /// The unique identifier of the runtime environment you want to delete.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeployedVersionSummary: AWSDecodableShape {
        /// The version of the deployed application.
        public let applicationVersion: Int
        /// The status of the deployment.
        public let status: DeploymentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationVersion: Int, status: DeploymentLifecycle, statusReason: String? = nil) {
            self.applicationVersion = applicationVersion
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion
            case status
            case statusReason
        }
    }

    public struct DeploymentSummary: AWSDecodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The version of the application.
        public let applicationVersion: Int
        /// The timestamp when the deployment was created.
        public let creationTime: Date
        /// The unique identifier of the deployment.
        public let deploymentId: String
        /// The unique identifier of the runtime environment.
        public let environmentId: String
        /// The current status of the deployment.
        public let status: DeploymentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationId: String, applicationVersion: Int, creationTime: Date, deploymentId: String, environmentId: String, status: DeploymentLifecycle, statusReason: String? = nil) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentId = deploymentId
            self.environmentId = environmentId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case applicationVersion
            case creationTime
            case deploymentId
            case environmentId
            case status
            case statusReason
        }
    }

    public struct EfsStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The file system identifier.
        public let fileSystemId: String
        /// The mount point for the file system.
        public let mountPoint: String

        public init(fileSystemId: String, mountPoint: String) {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^\\S{1,200}$")
            try self.validate(self.mountPoint, name: "mountPoint", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemId = "file-system-id"
            case mountPoint = "mount-point"
        }
    }

    public struct EngineVersionsSummary: AWSDecodableShape {
        /// The type of target platform for the application.
        public let engineType: String
        /// The version of the engine type used by the application.
        public let engineVersion: String

        public init(engineType: String, engineVersion: String) {
            self.engineType = engineType
            self.engineVersion = engineVersion
        }

        private enum CodingKeys: String, CodingKey {
            case engineType
            case engineVersion
        }
    }

    public struct EnvironmentSummary: AWSDecodableShape {
        /// The timestamp when the runtime environment was created.
        public let creationTime: Date
        /// The target platform for the runtime environment.
        public let engineType: EngineType
        /// The version of the runtime engine.
        public let engineVersion: String
        /// The Amazon Resource Name (ARN) of a particular runtime environment.
        public let environmentArn: String
        /// The unique identifier of a particular runtime environment.
        public let environmentId: String
        /// The instance type of the runtime environment.
        public let instanceType: String
        /// The name of the runtime environment.
        public let name: String
        /// The status of the runtime environment
        public let status: EnvironmentLifecycle

        public init(creationTime: Date, engineType: EngineType, engineVersion: String, environmentArn: String, environmentId: String, instanceType: String, name: String, status: EnvironmentLifecycle) {
            self.creationTime = creationTime
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.instanceType = instanceType
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case engineType
            case engineVersion
            case environmentArn
            case environmentId
            case instanceType
            case name
            case status
        }
    }

    public struct FileBatchJobDefinition: AWSDecodableShape {
        /// The name of the file containing the batch job definition.
        public let fileName: String
        /// The path to the file containing the batch job definition.
        public let folderPath: String?

        public init(fileName: String, folderPath: String? = nil) {
            self.fileName = fileName
            self.folderPath = folderPath
        }

        private enum CodingKeys: String, CodingKey {
            case fileName
            case folderPath
        }
    }

    public struct FileBatchJobIdentifier: AWSEncodableShape {
        /// The file name for the batch job identifier.
        public let fileName: String
        /// The relative path to the file name for the batch job identifier.
        public let folderPath: String?

        public init(fileName: String, folderPath: String? = nil) {
            self.fileName = fileName
            self.folderPath = folderPath
        }

        private enum CodingKeys: String, CodingKey {
            case fileName
            case folderPath
        }
    }

    public struct FsxStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The file system identifier.
        public let fileSystemId: String
        /// The mount point for the file system.
        public let mountPoint: String

        public init(fileSystemId: String, mountPoint: String) {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^\\S{1,200}$")
            try self.validate(self.mountPoint, name: "mountPoint", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemId = "file-system-id"
            case mountPoint = "mount-point"
        }
    }

    public struct GdgAttributes: AWSEncodableShape {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public let limit: Int?
        /// The disposition of the data set in the catalog.
        public let rollDisposition: String?

        public init(limit: Int? = nil, rollDisposition: String? = nil) {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }

        private enum CodingKeys: String, CodingKey {
            case limit
            case rollDisposition
        }
    }

    public struct GdgDetailAttributes: AWSDecodableShape {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public let limit: Int?
        /// The disposition of the data set in the catalog.
        public let rollDisposition: String?

        public init(limit: Int? = nil, rollDisposition: String? = nil) {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }

        private enum CodingKeys: String, CodingKey {
            case limit
            case rollDisposition
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The identifier of the application.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationArn: String
        /// The identifier of the application.
        public let applicationId: String
        /// The timestamp when this application was created.
        public let creationTime: Date
        /// The version of the application that is deployed.
        public let deployedVersion: DeployedVersionSummary?
        /// The description of the application.
        public let description: String?
        /// The type of the target platform for the application.
        public let engineType: EngineType
        /// The identifier of the runtime environment where you want to deploy the application.
        public let environmentId: String?
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The timestamp when you last started the application. Null until the application runs for the first time.
        public let lastStartTime: Date?
        /// The latest version of the application.
        public let latestVersion: ApplicationVersionSummary
        /// The Amazon Resource Name (ARN) for the network load balancer listener created in your Amazon Web Services account. Amazon Web Services Mainframe Modernization creates this listener for you the first time you deploy an application.
        public let listenerArns: [String]?
        /// The port associated with the network load balancer listener created in your Amazon Web Services account.
        public let listenerPorts: [Int]?
        /// The public DNS name of the load balancer created in your Amazon Web Services account.
        public let loadBalancerDnsName: String?
        /// The list of log summaries. Each log summary includes the log type as well as the log group identifier. These are CloudWatch logs. Amazon Web Services Mainframe Modernization pushes the application log to CloudWatch under the customer's account.
        public let logGroups: [LogGroupSummary]?
        /// The unique identifier of the application.
        public let name: String
        /// The status of the application.
        public let status: ApplicationLifecycle
        /// The reason for the reported status.
        public let statusReason: String?
        /// A list of tags associated with the application.
        public let tags: [String: String]?
        /// Returns the Amazon Resource Names (ARNs) of the target groups that are attached to the network load balancer.
        public let targetGroupArns: [String]?

        public init(applicationArn: String, applicationId: String, creationTime: Date, deployedVersion: DeployedVersionSummary? = nil, description: String? = nil, engineType: EngineType, environmentId: String? = nil, kmsKeyId: String? = nil, lastStartTime: Date? = nil, latestVersion: ApplicationVersionSummary, listenerArns: [String]? = nil, listenerPorts: [Int]? = nil, loadBalancerDnsName: String? = nil, logGroups: [LogGroupSummary]? = nil, name: String, status: ApplicationLifecycle, statusReason: String? = nil, tags: [String: String]? = nil, targetGroupArns: [String]? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.deployedVersion = deployedVersion
            self.description = description
            self.engineType = engineType
            self.environmentId = environmentId
            self.kmsKeyId = kmsKeyId
            self.lastStartTime = lastStartTime
            self.latestVersion = latestVersion
            self.listenerArns = listenerArns
            self.listenerPorts = listenerPorts
            self.loadBalancerDnsName = loadBalancerDnsName
            self.logGroups = logGroups
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.targetGroupArns = targetGroupArns
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn
            case applicationId
            case creationTime
            case deployedVersion
            case description
            case engineType
            case environmentId
            case kmsKeyId
            case lastStartTime
            case latestVersion
            case listenerArns
            case listenerPorts
            case loadBalancerDnsName
            case logGroups
            case name
            case status
            case statusReason
            case tags
            case targetGroupArns
        }
    }

    public struct GetApplicationVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "applicationVersion", location: .uri("applicationVersion"))
        ]

        /// The unique identifier of the application.
        public let applicationId: String
        /// The specific version of the application.
        public let applicationVersion: Int

        public init(applicationId: String, applicationVersion: Int) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationVersionResponse: AWSDecodableShape {
        /// The specific version of the application.
        public let applicationVersion: Int
        /// The timestamp when the application version was created.
        public let creationTime: Date
        /// The content of the application definition. This is a JSON object that contains the resource configuration and definitions that identify an application.
        public let definitionContent: String
        /// The application description.
        public let description: String?
        /// The name of the application version.
        public let name: String
        /// The status of the application version.
        public let status: ApplicationVersionLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationVersion: Int, creationTime: Date, definitionContent: String, description: String? = nil, name: String, status: ApplicationVersionLifecycle, statusReason: String? = nil) {
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.definitionContent = definitionContent
            self.description = description
            self.name = name
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion
            case creationTime
            case definitionContent
            case description
            case name
            case status
            case statusReason
        }
    }

    public struct GetBatchJobExecutionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "executionId", location: .uri("executionId"))
        ]

        /// The identifier of the application.
        public let applicationId: String
        /// The unique identifier of the batch job execution.
        public let executionId: String

        public init(applicationId: String, executionId: String) {
            self.applicationId = applicationId
            self.executionId = executionId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.executionId, name: "executionId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBatchJobExecutionResponse: AWSDecodableShape {
        /// The identifier of the application.
        public let applicationId: String
        /// The timestamp when the batch job execution ended.
        public let endTime: Date?
        /// The unique identifier for this batch job execution.
        public let executionId: String
        /// The unique identifier for this batch job.
        public let jobId: String?
        /// The name of this batch job.
        public let jobName: String?
        /// The type of job.
        public let jobType: BatchJobType?
        /// The user for the job.
        public let jobUser: String?
        /// The timestamp when the batch job execution started.
        public let startTime: Date
        /// The status of the batch job execution.
        public let status: BatchJobExecutionStatus
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationId: String, endTime: Date? = nil, executionId: String, jobId: String? = nil, jobName: String? = nil, jobType: BatchJobType? = nil, jobUser: String? = nil, startTime: Date, status: BatchJobExecutionStatus, statusReason: String? = nil) {
            self.applicationId = applicationId
            self.endTime = endTime
            self.executionId = executionId
            self.jobId = jobId
            self.jobName = jobName
            self.jobType = jobType
            self.jobUser = jobUser
            self.startTime = startTime
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case endTime
            case executionId
            case jobId
            case jobName
            case jobType
            case jobUser
            case startTime
            case status
            case statusReason
        }
    }

    public struct GetDataSetDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "dataSetName", location: .uri("dataSetName"))
        ]

        /// The unique identifier of the application that this data set is associated with.
        public let applicationId: String
        /// The name of the data set.
        public let dataSetName: String

        public init(applicationId: String, dataSetName: String) {
            self.applicationId = applicationId
            self.dataSetName = dataSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSetDetailsResponse: AWSDecodableShape {
        /// The size of the block on disk.
        public let blocksize: Int?
        /// The timestamp when the data set was created.
        public let creationTime: Date?
        /// The name of the data set.
        public let dataSetName: String
        /// The type of data set. The only supported value is VSAM.
        public let dataSetOrg: DatasetDetailOrgAttributes?
        /// The last time the data set was referenced.
        public let lastReferencedTime: Date?
        /// The last time the data set was updated.
        public let lastUpdatedTime: Date?
        /// The location where the data set is stored.
        public let location: String?
        /// The length of records in the data set.
        public let recordLength: Int?

        public init(blocksize: Int? = nil, creationTime: Date? = nil, dataSetName: String, dataSetOrg: DatasetDetailOrgAttributes? = nil, lastReferencedTime: Date? = nil, lastUpdatedTime: Date? = nil, location: String? = nil, recordLength: Int? = nil) {
            self.blocksize = blocksize
            self.creationTime = creationTime
            self.dataSetName = dataSetName
            self.dataSetOrg = dataSetOrg
            self.lastReferencedTime = lastReferencedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.location = location
            self.recordLength = recordLength
        }

        private enum CodingKeys: String, CodingKey {
            case blocksize
            case creationTime
            case dataSetName
            case dataSetOrg
            case lastReferencedTime
            case lastUpdatedTime
            case location
            case recordLength
        }
    }

    public struct GetDataSetImportTaskRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "taskId", location: .uri("taskId"))
        ]

        /// The application identifier.
        public let applicationId: String
        /// The task identifier returned by the CreateDataSetImportTask operation.
        public let taskId: String

        public init(applicationId: String, taskId: String) {
            self.applicationId = applicationId
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSetImportTaskResponse: AWSDecodableShape {
        /// The status of the task.
        public let status: DataSetTaskLifecycle
        /// A summary of the status of the task.
        public let summary: DataSetImportSummary?
        /// The task identifier.
        public let taskId: String

        public init(status: DataSetTaskLifecycle, summary: DataSetImportSummary? = nil, taskId: String) {
            self.status = status
            self.summary = summary
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case status
            case summary
            case taskId
        }
    }

    public struct GetDeploymentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "deploymentId", location: .uri("deploymentId"))
        ]

        /// The unique identifier of the application.
        public let applicationId: String
        /// The unique identifier for the deployment.
        public let deploymentId: String

        public init(applicationId: String, deploymentId: String) {
            self.applicationId = applicationId
            self.deploymentId = deploymentId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeploymentResponse: AWSDecodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The application version.
        public let applicationVersion: Int
        /// The timestamp when the deployment was created.
        public let creationTime: Date
        /// The unique identifier of the deployment.
        public let deploymentId: String
        /// The unique identifier of the runtime environment.
        public let environmentId: String
        /// The status of the deployment.
        public let status: DeploymentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationId: String, applicationVersion: Int, creationTime: Date, deploymentId: String, environmentId: String, status: DeploymentLifecycle, statusReason: String? = nil) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentId = deploymentId
            self.environmentId = environmentId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId
            case applicationVersion
            case creationTime
            case deploymentId
            case environmentId
            case status
            case statusReason
        }
    }

    public struct GetEnvironmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "environmentId", location: .uri("environmentId"))
        ]

        /// The unique identifier of the runtime environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentResponse: AWSDecodableShape {
        /// The number of instances included in the runtime environment. A standalone runtime environment has a maxiumum of one instance. Currently, a high availability runtime environment has a maximum of two instances.
        public let actualCapacity: Int?
        /// The timestamp when the runtime environment was created.
        public let creationTime: Date
        /// The description of the runtime environment.
        public let description: String?
        /// The target platform for the runtime environment.
        public let engineType: EngineType
        /// The version of the runtime engine.
        public let engineVersion: String
        /// The Amazon Resource Name (ARN) of the runtime environment.
        public let environmentArn: String
        /// The unique identifier of the runtime environment.
        public let environmentId: String
        /// The desired capacity of the high availability configuration for the runtime environment.
        public let highAvailabilityConfig: HighAvailabilityConfig?
        /// The type of instance underlying the runtime environment.
        public let instanceType: String
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The Amazon Resource Name (ARN) for the load balancer used with the runtime environment.
        public let loadBalancerArn: String?
        /// The name of the runtime environment. Must be unique within the account.
        public let name: String
        /// Indicates the pending maintenance scheduled on this environment.
        public let pendingMaintenance: PendingMaintenance?
        /// Configures the maintenance window you want for the runtime environment. If you do not provide a value, a random system-generated value will be assigned.
        public let preferredMaintenanceWindow: String?
        /// Whether applications running in this runtime environment are publicly accessible.
        public let publiclyAccessible: Bool?
        /// The unique identifiers of the security groups assigned to this runtime environment.
        public let securityGroupIds: [String]
        /// The status of the runtime environment.
        public let status: EnvironmentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?
        /// The storage configurations defined for the runtime environment.
        public let storageConfigurations: [StorageConfiguration]?
        /// The unique identifiers of the subnets assigned to this runtime environment.
        public let subnetIds: [String]
        /// The tags defined for this runtime environment.
        public let tags: [String: String]?
        /// The unique identifier for the VPC used with this runtime environment.
        public let vpcId: String

        public init(actualCapacity: Int? = nil, creationTime: Date, description: String? = nil, engineType: EngineType, engineVersion: String, environmentArn: String, environmentId: String, highAvailabilityConfig: HighAvailabilityConfig? = nil, instanceType: String, kmsKeyId: String? = nil, loadBalancerArn: String? = nil, name: String, pendingMaintenance: PendingMaintenance? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, securityGroupIds: [String], status: EnvironmentLifecycle, statusReason: String? = nil, storageConfigurations: [StorageConfiguration]? = nil, subnetIds: [String], tags: [String: String]? = nil, vpcId: String) {
            self.actualCapacity = actualCapacity
            self.creationTime = creationTime
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.highAvailabilityConfig = highAvailabilityConfig
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.loadBalancerArn = loadBalancerArn
            self.name = name
            self.pendingMaintenance = pendingMaintenance
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.statusReason = statusReason
            self.storageConfigurations = storageConfigurations
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case actualCapacity
            case creationTime
            case description
            case engineType
            case engineVersion
            case environmentArn
            case environmentId
            case highAvailabilityConfig
            case instanceType
            case kmsKeyId
            case loadBalancerArn
            case name
            case pendingMaintenance
            case preferredMaintenanceWindow
            case publiclyAccessible
            case securityGroupIds
            case status
            case statusReason
            case storageConfigurations
            case subnetIds
            case tags
            case vpcId
        }
    }

    public struct HighAvailabilityConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances in a high availability configuration.
        public let desiredCapacity: Int

        public init(desiredCapacity: Int) {
            self.desiredCapacity = desiredCapacity
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredCapacity, name: "desiredCapacity", parent: name, max: 100)
            try self.validate(self.desiredCapacity, name: "desiredCapacity", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case desiredCapacity
        }
    }

    public struct ListApplicationVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier of the application.
        public let applicationId: String
        /// The maximum number of application versions to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationVersionsResponse: AWSDecodableShape {
        /// The list of application versions.
        public let applicationVersions: [ApplicationVersionSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(applicationVersions: [ApplicationVersionSummary], nextToken: String? = nil) {
            self.applicationVersions = applicationVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersions
            case nextToken
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "environmentId", location: .querystring("environmentId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "names", location: .querystring("names")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier of the runtime environment where the applications are deployed.
        public let environmentId: String?
        /// The maximum number of applications to return.
        public let maxResults: Int?
        /// The names of the applications.
        public let names: [String]?
        /// A pagination token to control the number of applications displayed in the list.
        public let nextToken: String?

        public init(environmentId: String? = nil, maxResults: Int? = nil, names: [String]? = nil, nextToken: String? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.names = names
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 10)
            try self.validate(self.names, name: "names", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// Returns a list of summary details for all the applications in a runtime environment.
        public let applications: [ApplicationSummary]
        /// A pagination token that's returned when the response doesn't contain all applications.
        public let nextToken: String?

        public init(applications: [ApplicationSummary], nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications
            case nextToken
        }
    }

    public struct ListBatchJobDefinitionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "prefix", location: .querystring("prefix"))
        ]

        /// The identifier of the application.
        public let applicationId: String
        /// The maximum number of batch job definitions to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?
        /// If the batch job definition is a FileBatchJobDefinition, the prefix allows you to search on the file names of FileBatchJobDefinitions.
        public let prefix: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil, prefix: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBatchJobDefinitionsResponse: AWSDecodableShape {
        /// The list of batch job definitions.
        public let batchJobDefinitions: [BatchJobDefinition]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(batchJobDefinitions: [BatchJobDefinition], nextToken: String? = nil) {
            self.batchJobDefinitions = batchJobDefinitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobDefinitions
            case nextToken
        }
    }

    public struct ListBatchJobExecutionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "executionIds", location: .querystring("executionIds")),
            AWSMemberEncoding(label: "jobName", location: .querystring("jobName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "startedAfter", location: .querystring("startedAfter")),
            AWSMemberEncoding(label: "startedBefore", location: .querystring("startedBefore")),
            AWSMemberEncoding(label: "status", location: .querystring("status"))
        ]

        /// The unique identifier of the application.
        public let applicationId: String
        /// The unique identifier of each batch job execution.
        public let executionIds: [String]?
        /// The name of each batch job execution.
        public let jobName: String?
        /// The maximum number of batch job executions to return.
        public let maxResults: Int?
        /// A pagination token to control the number of batch job executions displayed in the list.
        public let nextToken: String?
        /// The time after which the batch job executions started.
        public let startedAfter: Date?
        /// The time before the batch job executions started.
        public let startedBefore: Date?
        /// The status of the batch job executions.
        public let status: BatchJobExecutionStatus?

        public init(applicationId: String, executionIds: [String]? = nil, jobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, startedAfter: Date? = nil, startedBefore: Date? = nil, status: BatchJobExecutionStatus? = nil) {
            self.applicationId = applicationId
            self.executionIds = executionIds
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.executionIds?.forEach {
                try validate($0, name: "executionIds[]", parent: name, pattern: "^\\S{1,80}$")
            }
            try self.validate(self.executionIds, name: "executionIds", parent: name, max: 10)
            try self.validate(self.executionIds, name: "executionIds", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^\\S{1,100}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBatchJobExecutionsResponse: AWSDecodableShape {
        /// Returns a list of batch job executions for an application.
        public let batchJobExecutions: [BatchJobExecutionSummary]
        /// A pagination token that's returned when the response doesn't contain all batch job executions.
        public let nextToken: String?

        public init(batchJobExecutions: [BatchJobExecutionSummary], nextToken: String? = nil) {
            self.batchJobExecutions = batchJobExecutions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobExecutions
            case nextToken
        }
    }

    public struct ListDataSetImportHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier of the application.
        public let applicationId: String
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetImportHistoryResponse: AWSDecodableShape {
        /// The data set import tasks.
        public let dataSetImportTasks: [DataSetImportTask]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(dataSetImportTasks: [DataSetImportTask], nextToken: String? = nil) {
            self.dataSetImportTasks = dataSetImportTasks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetImportTasks
            case nextToken
        }
    }

    public struct ListDataSetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "prefix", location: .querystring("prefix"))
        ]

        /// The unique identifier of the application for which you want to list the associated data sets.
        public let applicationId: String
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?
        /// The prefix of the data set name, which you can use to filter the list of data sets.
        public let prefix: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil, prefix: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetsResponse: AWSDecodableShape {
        /// The list of data sets, containing information including the creation time, the data set name, the data set organization, the data set format, and the last time the data set was referenced or updated.
        public let dataSets: [DataSetSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(dataSets: [DataSetSummary], nextToken: String? = nil) {
            self.dataSets = dataSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSets
            case nextToken
        }
    }

    public struct ListDeploymentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The application identifier.
        public let applicationId: String
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeploymentsResponse: AWSDecodableShape {
        /// The list of deployments that is returned.
        public let deployments: [DeploymentSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(deployments: [DeploymentSummary], nextToken: String? = nil) {
            self.deployments = deployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deployments
            case nextToken
        }
    }

    public struct ListEngineVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "engineType", location: .querystring("engineType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The type of target platform.
        public let engineType: EngineType?
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(engineType: EngineType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.engineType = engineType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEngineVersionsResponse: AWSDecodableShape {
        /// Returns the engine versions.
        public let engineVersions: [EngineVersionsSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(engineVersions: [EngineVersionsSummary], nextToken: String? = nil) {
            self.engineVersions = engineVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case engineVersions
            case nextToken
        }
    }

    public struct ListEnvironmentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "engineType", location: .querystring("engineType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "names", location: .querystring("names")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The engine type for the runtime environment.
        public let engineType: EngineType?
        /// The maximum number of runtime environments to return.
        public let maxResults: Int?
        /// The names of the runtime environments. Must be unique within the account.
        public let names: [String]?
        /// A pagination token to control the number of runtime environments displayed in the list.
        public let nextToken: String?

        public init(engineType: EngineType? = nil, maxResults: Int? = nil, names: [String]? = nil, nextToken: String? = nil) {
            self.engineType = engineType
            self.maxResults = maxResults
            self.names = names
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 10)
            try self.validate(self.names, name: "names", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsResponse: AWSDecodableShape {
        /// Returns a list of summary details for all the runtime environments in your account.
        public let environments: [EnvironmentSummary]
        /// A pagination token that's returned when the response doesn't contain all the runtime environments.
        public let nextToken: String?

        public init(environments: [EnvironmentSummary], nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct LogGroupSummary: AWSDecodableShape {
        /// The name of the log group.
        public let logGroupName: String
        /// The type of log.
        public let logType: String

        public init(logGroupName: String, logType: String) {
            self.logGroupName = logGroupName
            self.logType = logType
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName
            case logType
        }
    }

    public struct MaintenanceSchedule: AWSDecodableShape {
        /// The time the scheduled maintenance is to end.
        public let endTime: Date?
        /// The time the scheduled maintenance is to start.
        public let startTime: Date?

        public init(endTime: Date? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case startTime
        }
    }

    public struct PendingMaintenance: AWSDecodableShape {
        /// The specific runtime engine that the maintenance schedule applies to.
        public let engineVersion: String?
        /// The maintenance schedule for the runtime engine version.
        public let schedule: MaintenanceSchedule?

        public init(engineVersion: String? = nil, schedule: MaintenanceSchedule? = nil) {
            self.engineVersion = engineVersion
            self.schedule = schedule
        }

        private enum CodingKeys: String, CodingKey {
            case engineVersion
            case schedule
        }
    }

    public struct PrimaryKey: AWSEncodableShape & AWSDecodableShape {
        /// A strictly positive integer value representing the length of the primary key.
        public let length: Int
        /// A name for the Primary Key.
        public let name: String?
        /// A positive integer value representing the offset to mark the start of the primary key in the record byte array.
        public let offset: Int

        public init(length: Int, name: String? = nil, offset: Int) {
            self.length = length
            self.name = name
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case length
            case name
            case offset
        }
    }

    public struct RecordLength: AWSEncodableShape {
        /// The maximum record length. In case of fixed, both minimum and maximum are the same.
        public let max: Int
        /// The minimum record length of a record.
        public let min: Int

        public init(max: Int = 0, min: Int = 0) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max
            case min
        }
    }

    public struct ScriptBatchJobDefinition: AWSDecodableShape {
        /// The name of the script containing the batch job definition.
        public let scriptName: String

        public init(scriptName: String) {
            self.scriptName = scriptName
        }

        private enum CodingKeys: String, CodingKey {
            case scriptName
        }
    }

    public struct ScriptBatchJobIdentifier: AWSEncodableShape {
        /// The name of the script containing the batch job definition.
        public let scriptName: String

        public init(scriptName: String) {
            self.scriptName = scriptName
        }

        private enum CodingKeys: String, CodingKey {
            case scriptName
        }
    }

    public struct StartApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The unique identifier of the application you want to start.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartBatchJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The unique identifier of the application associated with this batch job.
        public let applicationId: String
        /// The unique identifier of the batch job.
        public let batchJobIdentifier: BatchJobIdentifier
        /// The collection of batch job parameters. For details about limits for keys and values, see Coding variables in JCL.
        public let jobParams: [String: String]?

        public init(applicationId: String, batchJobIdentifier: BatchJobIdentifier, jobParams: [String: String]? = nil) {
            self.applicationId = applicationId
            self.batchJobIdentifier = batchJobIdentifier
            self.jobParams = jobParams
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.jobParams?.forEach {
                try validate($0.key, name: "jobParams.key", parent: name, max: 8)
                try validate($0.key, name: "jobParams.key", parent: name, min: 1)
                try validate($0.key, name: "jobParams.key", parent: name, pattern: "^[A-Za-z][A-Za-z0-9]{1,7}$")
                try validate($0.value, name: "jobParams[\"\($0.key)\"]", parent: name, max: 44)
            }
            try self.validate(self.jobParams, name: "jobParams", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobIdentifier
            case jobParams
        }
    }

    public struct StartBatchJobResponse: AWSDecodableShape {
        /// The unique identifier of this execution of the batch job.
        public let executionId: String

        public init(executionId: String) {
            self.executionId = executionId
        }

        private enum CodingKeys: String, CodingKey {
            case executionId
        }
    }

    public struct StopApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The unique identifier of the application you want to stop.
        public let applicationId: String
        /// Stopping an application process can take a long time. Setting this parameter to true lets you force stop the application so you don't need to wait until the process finishes to apply another action on the application. The default value is false.
        public let forceStop: Bool?

        public init(applicationId: String, forceStop: Bool? = nil) {
            self.applicationId = applicationId
            self.forceStop = forceStop
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: String, CodingKey {
            case forceStop
        }
    }

    public struct StopApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The keys of the tags to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).+$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationId", location: .uri("applicationId"))
        ]

        /// The unique identifier of the application you want to update.
        public let applicationId: String
        /// The current version of the application to update.
        public let currentApplicationVersion: Int
        /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
        public let definition: Definition?
        /// The description of the application to update.
        public let description: String?

        public init(applicationId: String, currentApplicationVersion: Int, definition: Definition? = nil, description: String? = nil) {
            self.applicationId = applicationId
            self.currentApplicationVersion = currentApplicationVersion
            self.definition = definition
            self.description = description
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.currentApplicationVersion, name: "currentApplicationVersion", parent: name, min: 1)
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case currentApplicationVersion
            case definition
            case description
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        /// The new version of the application.
        public let applicationVersion: Int

        public init(applicationVersion: Int) {
            self.applicationVersion = applicationVersion
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion
        }
    }

    public struct UpdateEnvironmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "environmentId", location: .uri("environmentId"))
        ]

        /// Indicates whether to update the runtime environment during the maintenance window. The default is false. Currently, Amazon Web Services Mainframe Modernization accepts the engineVersion parameter only if applyDuringMaintenanceWindow is true. If any parameter other than engineVersion is provided in UpdateEnvironmentRequest, it will fail if applyDuringMaintenanceWindow is set to true.
        public let applyDuringMaintenanceWindow: Bool?
        /// The desired capacity for the runtime environment to update.
        public let desiredCapacity: Int?
        /// The version of the runtime engine for the runtime environment.
        public let engineVersion: String?
        /// The unique identifier of the runtime environment that you want to update.
        public let environmentId: String
        /// The instance type for the runtime environment to update.
        public let instanceType: String?
        /// Configures the maintenance window you want for the runtime environment. If you do not provide a value, a random system-generated value will be assigned.
        public let preferredMaintenanceWindow: String?

        public init(applyDuringMaintenanceWindow: Bool? = nil, desiredCapacity: Int? = nil, engineVersion: String? = nil, environmentId: String, instanceType: String? = nil, preferredMaintenanceWindow: String? = nil) {
            self.applyDuringMaintenanceWindow = applyDuringMaintenanceWindow
            self.desiredCapacity = desiredCapacity
            self.engineVersion = engineVersion
            self.environmentId = environmentId
            self.instanceType = instanceType
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredCapacity, name: "desiredCapacity", parent: name, max: 100)
            try self.validate(self.desiredCapacity, name: "desiredCapacity", parent: name, min: 1)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^\\S{1,10}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^\\S{1,20}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyDuringMaintenanceWindow
            case desiredCapacity
            case engineVersion
            case instanceType
            case preferredMaintenanceWindow
        }
    }

    public struct UpdateEnvironmentResponse: AWSDecodableShape {
        /// The unique identifier of the runtime environment that was updated.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId
        }
    }

    public struct VsamAttributes: AWSEncodableShape {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public let alternateKeys: [AlternateKey]?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.
        public let compressed: Bool?
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public let encoding: String?
        /// The record format of the data set.
        public let format: String
        /// The primary key of the data set.
        public let primaryKey: PrimaryKey?

        public init(alternateKeys: [AlternateKey]? = nil, compressed: Bool? = nil, encoding: String? = nil, format: String, primaryKey: PrimaryKey? = nil) {
            self.alternateKeys = alternateKeys
            self.compressed = compressed
            self.encoding = encoding
            self.format = format
            self.primaryKey = primaryKey
        }

        private enum CodingKeys: String, CodingKey {
            case alternateKeys
            case compressed
            case encoding
            case format
            case primaryKey
        }
    }

    public struct VsamDetailAttributes: AWSDecodableShape {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public let alternateKeys: [AlternateKey]?
        /// If set to True, enforces loading the data set into cache before it’s used by the application.
        public let cacheAtStartup: Bool?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.
        public let compressed: Bool?
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public let encoding: String?
        /// The primary key of the data set.
        public let primaryKey: PrimaryKey?
        /// The record format of the data set.
        public let recordFormat: String?

        public init(alternateKeys: [AlternateKey]? = nil, cacheAtStartup: Bool? = nil, compressed: Bool? = nil, encoding: String? = nil, primaryKey: PrimaryKey? = nil, recordFormat: String? = nil) {
            self.alternateKeys = alternateKeys
            self.cacheAtStartup = cacheAtStartup
            self.compressed = compressed
            self.encoding = encoding
            self.primaryKey = primaryKey
            self.recordFormat = recordFormat
        }

        private enum CodingKeys: String, CodingKey {
            case alternateKeys
            case cacheAtStartup
            case compressed
            case encoding
            case primaryKey
            case recordFormat
        }
    }

    public struct ExternalLocation: AWSEncodableShape {
        /// The URI of the Amazon S3 bucket.
        public let s3Location: String?

        public init(s3Location: String? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Location, name: "s3Location", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }
}

// MARK: - Errors

/// Error enum for M2
public struct M2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize M2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The account or role doesn&#39;t have the right permissions to make the request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The parameters provided in the request conflict with existing resources.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred during the processing of the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// One or more quotas for Amazon Web Services Mainframe Modernization exceeds the limit.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests made exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One or more parameters provided in the request is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension M2ErrorType: Equatable {
    public static func == (lhs: M2ErrorType, rhs: M2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension M2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
