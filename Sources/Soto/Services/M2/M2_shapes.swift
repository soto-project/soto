//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension M2 {
    // MARK: Enums

    public enum ApplicationDeploymentLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deployed = "Deployed"
        case deploying = "Deploying"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case created = "Created"
        case creating = "Creating"
        case deleting = "Deleting"
        case deletingFromEnvironment = "Deleting From Environment"
        case failed = "Failed"
        case ready = "Ready"
        case running = "Running"
        case starting = "Starting"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationVersionLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case creating = "Creating"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public enum BatchJobExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "Cancelled"
        case cancelling = "Cancelling"
        case dispatching = "Dispatching"
        case failed = "Failed"
        case holding = "Holding"
        case running = "Running"
        case submitting = "Submitting"
        case succeeded = "Succeeded"
        case succeededWithWarning = "Succeeded With Warning"
        public var description: String { return self.rawValue }
    }

    public enum BatchJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jes2 = "JES2"
        case jes3 = "JES3"
        case vse = "VSE"
        public var description: String { return self.rawValue }
    }

    public enum DataSetTaskLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case creating = "Creating"
        case failed = "Failed"
        case running = "Running"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deploying = "Deploying"
        case failed = "Failed"
        case succeeded = "Succeeded"
        case updatingDeployment = "Updating Deployment"
        public var description: String { return self.rawValue }
    }

    public enum EngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bluage = "bluage"
        case microfocus = "microfocus"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum BatchJobDefinition: AWSDecodableShape, Sendable {
        /// Specifies a file containing a batch job definition.
        case fileBatchJobDefinition(FileBatchJobDefinition)
        /// A script containing a batch job definition.
        case scriptBatchJobDefinition(ScriptBatchJobDefinition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileBatchJobDefinition:
                let value = try container.decode(FileBatchJobDefinition.self, forKey: .fileBatchJobDefinition)
                self = .fileBatchJobDefinition(value)
            case .scriptBatchJobDefinition:
                let value = try container.decode(ScriptBatchJobDefinition.self, forKey: .scriptBatchJobDefinition)
                self = .scriptBatchJobDefinition(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileBatchJobDefinition = "fileBatchJobDefinition"
            case scriptBatchJobDefinition = "scriptBatchJobDefinition"
        }
    }

    public enum BatchJobIdentifier: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Specifies a file associated with a specific batch job.
        case fileBatchJobIdentifier(FileBatchJobIdentifier)
        /// Specifies an Amazon S3 location that identifies the batch jobs that you want to run. Use this identifier to run ad hoc batch jobs.
        case s3BatchJobIdentifier(S3BatchJobIdentifier)
        /// A batch job identifier in which the batch job to run is identified by the script name.
        case scriptBatchJobIdentifier(ScriptBatchJobIdentifier)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileBatchJobIdentifier:
                let value = try container.decode(FileBatchJobIdentifier.self, forKey: .fileBatchJobIdentifier)
                self = .fileBatchJobIdentifier(value)
            case .s3BatchJobIdentifier:
                let value = try container.decode(S3BatchJobIdentifier.self, forKey: .s3BatchJobIdentifier)
                self = .s3BatchJobIdentifier(value)
            case .scriptBatchJobIdentifier:
                let value = try container.decode(ScriptBatchJobIdentifier.self, forKey: .scriptBatchJobIdentifier)
                self = .scriptBatchJobIdentifier(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fileBatchJobIdentifier(let value):
                try container.encode(value, forKey: .fileBatchJobIdentifier)
            case .s3BatchJobIdentifier(let value):
                try container.encode(value, forKey: .s3BatchJobIdentifier)
            case .scriptBatchJobIdentifier(let value):
                try container.encode(value, forKey: .scriptBatchJobIdentifier)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileBatchJobIdentifier = "fileBatchJobIdentifier"
            case s3BatchJobIdentifier = "s3BatchJobIdentifier"
            case scriptBatchJobIdentifier = "scriptBatchJobIdentifier"
        }
    }

    public enum DataSetImportConfig: AWSEncodableShape, Sendable {
        /// The data sets.
        case dataSets([DataSetImportItem])
        /// The Amazon S3 location of the data sets.
        case s3Location(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dataSets(let value):
                try container.encode(value, forKey: .dataSets)
            case .s3Location(let value):
                try container.encode(value, forKey: .s3Location)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dataSets(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).dataSets[]")
                }
                try self.validate(value, name: "dataSets", parent: name, max: 100)
                try self.validate(value, name: "dataSets", parent: name, min: 1)
            case .s3Location(let value):
                try self.validate(value, name: "s3Location", parent: name, pattern: "^\\S{1,2000}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dataSets = "dataSets"
            case s3Location = "s3Location"
        }
    }

    public enum DatasetDetailOrgAttributes: AWSDecodableShape, Sendable {
        /// The generation data group of the data set.
        case gdg(GdgDetailAttributes)
        /// The details of a PO type data set.
        case po(PoDetailAttributes)
        /// The details of a PS type data set.
        case ps(PsDetailAttributes)
        /// The details of a VSAM data set.
        case vsam(VsamDetailAttributes)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .gdg:
                let value = try container.decode(GdgDetailAttributes.self, forKey: .gdg)
                self = .gdg(value)
            case .po:
                let value = try container.decode(PoDetailAttributes.self, forKey: .po)
                self = .po(value)
            case .ps:
                let value = try container.decode(PsDetailAttributes.self, forKey: .ps)
                self = .ps(value)
            case .vsam:
                let value = try container.decode(VsamDetailAttributes.self, forKey: .vsam)
                self = .vsam(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gdg = "gdg"
            case po = "po"
            case ps = "ps"
            case vsam = "vsam"
        }
    }

    public enum DatasetOrgAttributes: AWSEncodableShape, Sendable {
        /// The generation data group of the data set.
        case gdg(GdgAttributes)
        /// The details of a PO type data set.
        case po(PoAttributes)
        /// The details of a PS type data set.
        case ps(PsAttributes)
        /// The details of a VSAM data set.
        case vsam(VsamAttributes)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .gdg(let value):
                try container.encode(value, forKey: .gdg)
            case .po(let value):
                try container.encode(value, forKey: .po)
            case .ps(let value):
                try container.encode(value, forKey: .ps)
            case .vsam(let value):
                try container.encode(value, forKey: .vsam)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .po(let value):
                try value.validate(name: "\(name).po")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gdg = "gdg"
            case po = "po"
            case ps = "ps"
            case vsam = "vsam"
        }
    }

    public enum Definition: AWSEncodableShape, Sendable {
        /// The content of the application definition. This is a JSON object that contains the resource configuration/definitions that identify an application.
        case content(String)
        /// The S3 bucket that contains the application definition.
        case s3Location(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .content(let value):
                try container.encode(value, forKey: .content)
            case .s3Location(let value):
                try container.encode(value, forKey: .s3Location)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .content(let value):
                try self.validate(value, name: "content", parent: name, max: 65000)
                try self.validate(value, name: "content", parent: name, min: 1)
            case .s3Location(let value):
                try self.validate(value, name: "s3Location", parent: name, pattern: "^\\S{1,2000}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case s3Location = "s3Location"
        }
    }

    public enum JobIdentifier: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The name of the file that contains the batch job definition.
        case fileName(String)
        /// The name of the script that contains the batch job definition.
        case scriptName(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fileName:
                let value = try container.decode(String.self, forKey: .fileName)
                self = .fileName(value)
            case .scriptName:
                let value = try container.decode(String.self, forKey: .scriptName)
                self = .scriptName(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fileName(let value):
                try container.encode(value, forKey: .fileName)
            case .scriptName(let value):
                try container.encode(value, forKey: .scriptName)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "fileName"
            case scriptName = "scriptName"
        }
    }

    public enum StorageConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Defines the storage configuration for an Amazon EFS file system.
        case efs(EfsStorageConfiguration)
        /// Defines the storage configuration for an Amazon FSx file system.
        case fsx(FsxStorageConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .efs:
                let value = try container.decode(EfsStorageConfiguration.self, forKey: .efs)
                self = .efs(value)
            case .fsx:
                let value = try container.decode(FsxStorageConfiguration.self, forKey: .fsx)
                self = .fsx(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .efs(let value):
                try container.encode(value, forKey: .efs)
            case .fsx(let value):
                try container.encode(value, forKey: .fsx)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .efs(let value):
                try value.validate(name: "\(name).efs")
            case .fsx(let value):
                try value.validate(name: "\(name).fsx")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case efs = "efs"
            case fsx = "fsx"
        }
    }

    // MARK: Shapes

    public struct AlternateKey: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the alternate key values are supposed to be unique for the given data set.
        public let allowDuplicates: Bool?
        /// A strictly positive integer value representing the length of the alternate key.
        public let length: Int
        /// The name of the alternate key.
        public let name: String?
        /// A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.
        public let offset: Int

        public init(allowDuplicates: Bool? = nil, length: Int, name: String? = nil, offset: Int) {
            self.allowDuplicates = allowDuplicates
            self.length = length
            self.name = name
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case allowDuplicates = "allowDuplicates"
            case length = "length"
            case name = "name"
            case offset = "offset"
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationArn: String
        /// The unique identifier of the application.
        public let applicationId: String
        /// The version of the application.
        public let applicationVersion: Int
        /// The timestamp when the application was created.
        public let creationTime: Date
        /// Indicates either an ongoing deployment or if the application has ever deployed successfully.
        public let deploymentStatus: ApplicationDeploymentLifecycle?
        /// The description of the application.
        public let description: String?
        /// The type of the target platform for this application.
        public let engineType: EngineType
        /// The unique identifier of the runtime environment that hosts this application.
        public let environmentId: String?
        /// The timestamp when you last started the application. Null until the application runs for the first time.
        public let lastStartTime: Date?
        /// The name of the application.
        public let name: String
        /// The Amazon Resource Name (ARN) of the role associated with the application.
        public let roleArn: String?
        /// The status of the application.
        public let status: ApplicationLifecycle
        /// Indicates the status of the latest version of the application.
        public let versionStatus: ApplicationVersionLifecycle?

        public init(applicationArn: String, applicationId: String, applicationVersion: Int, creationTime: Date, deploymentStatus: ApplicationDeploymentLifecycle? = nil, description: String? = nil, engineType: EngineType, environmentId: String? = nil, lastStartTime: Date? = nil, name: String, roleArn: String? = nil, status: ApplicationLifecycle, versionStatus: ApplicationVersionLifecycle? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.description = description
            self.engineType = engineType
            self.environmentId = environmentId
            self.lastStartTime = lastStartTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.versionStatus = versionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationId = "applicationId"
            case applicationVersion = "applicationVersion"
            case creationTime = "creationTime"
            case deploymentStatus = "deploymentStatus"
            case description = "description"
            case engineType = "engineType"
            case environmentId = "environmentId"
            case lastStartTime = "lastStartTime"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
            case versionStatus = "versionStatus"
        }
    }

    public struct ApplicationVersionSummary: AWSDecodableShape {
        /// The application version.
        public let applicationVersion: Int
        /// The timestamp when the application version was created.
        public let creationTime: Date
        /// The status of the application.
        public let status: ApplicationVersionLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationVersion: Int, creationTime: Date, status: ApplicationVersionLifecycle, statusReason: String? = nil) {
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion = "applicationVersion"
            case creationTime = "creationTime"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct BatchJobExecutionSummary: AWSDecodableShape {
        /// The unique identifier of the application that hosts this batch job.
        public let applicationId: String
        /// The unique identifier of this batch job.
        public let batchJobIdentifier: BatchJobIdentifier?
        /// The timestamp when this batch job execution ended.
        public let endTime: Date?
        /// The unique identifier of this execution of the batch job.
        public let executionId: String
        /// The unique identifier of a particular batch job.
        public let jobId: String?
        /// The name of a particular batch job.
        public let jobName: String?
        /// The type of a particular batch job execution.
        public let jobType: BatchJobType?
        /// The batch job return code from either the Blu Age or Micro Focus runtime engines. For more information, see Batch return codes in the IBM WebSphere Application Server documentation.
        public let returnCode: String?
        /// The timestamp when a particular batch job execution started.
        public let startTime: Date
        /// The status of a particular batch job execution.
        public let status: BatchJobExecutionStatus

        public init(applicationId: String, batchJobIdentifier: BatchJobIdentifier? = nil, endTime: Date? = nil, executionId: String, jobId: String? = nil, jobName: String? = nil, jobType: BatchJobType? = nil, returnCode: String? = nil, startTime: Date, status: BatchJobExecutionStatus) {
            self.applicationId = applicationId
            self.batchJobIdentifier = batchJobIdentifier
            self.endTime = endTime
            self.executionId = executionId
            self.jobId = jobId
            self.jobName = jobName
            self.jobType = jobType
            self.returnCode = returnCode
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case batchJobIdentifier = "batchJobIdentifier"
            case endTime = "endTime"
            case executionId = "executionId"
            case jobId = "jobId"
            case jobName = "jobName"
            case jobType = "jobType"
            case returnCode = "returnCode"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct CancelBatchJobExecutionRequest: AWSEncodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The unique identifier of the batch job execution.
        public let executionId: String

        public init(applicationId: String, executionId: String) {
            self.applicationId = applicationId
            self.executionId = executionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.executionId, key: "executionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.executionId, name: "executionId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelBatchJobExecutionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier the service generates to ensure the idempotency of the request to create an application. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
        public let definition: Definition
        /// The description of the application.
        public let description: String?
        /// The type of the target platform for this application.
        public let engineType: EngineType
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The unique identifier of the application.
        public let name: String
        /// The Amazon Resource Name (ARN) that identifies a role that the application uses to access Amazon Web Services resources that are not part of the application or are in a different Amazon Web Services account.
        public let roleArn: String?
        /// A list of tags to apply to the application.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateApplicationRequest.idempotencyToken(), definition: Definition, description: String? = nil, engineType: EngineType, kmsKeyId: String? = nil, name: String, roleArn: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.definition = definition
            self.description = description
            self.engineType = engineType
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.definition.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]|):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case definition = "definition"
            case description = "description"
            case engineType = "engineType"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationArn: String
        /// The unique application identifier.
        public let applicationId: String
        /// The version number of the application.
        public let applicationVersion: Int

        public init(applicationArn: String, applicationId: String, applicationVersion: Int) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationId = "applicationId"
            case applicationVersion = "applicationVersion"
        }
    }

    public struct CreateDataSetImportTaskRequest: AWSEncodableShape {
        /// The unique identifier of the application for which you want to import data sets.
        public let applicationId: String
        ///  Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a data set import. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The data set import task configuration.
        public let importConfig: DataSetImportConfig

        public init(applicationId: String, clientToken: String? = CreateDataSetImportTaskRequest.idempotencyToken(), importConfig: DataSetImportConfig) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.importConfig = importConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.importConfig, forKey: .importConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.importConfig.validate(name: "\(name).importConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case importConfig = "importConfig"
        }
    }

    public struct CreateDataSetImportTaskResponse: AWSDecodableShape {
        /// The task identifier. This operation is asynchronous. Use this identifier with the GetDataSetImportTask operation to obtain the status of this task.
        public let taskId: String

        public init(taskId: String) {
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case taskId = "taskId"
        }
    }

    public struct CreateDeploymentRequest: AWSEncodableShape {
        /// The application identifier.
        public let applicationId: String
        /// The version of the application to deploy.
        public let applicationVersion: Int
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a deployment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The identifier of the runtime environment where you want to deploy this application.
        public let environmentId: String

        public init(applicationId: String, applicationVersion: Int, clientToken: String? = CreateDeploymentRequest.idempotencyToken(), environmentId: String) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.clientToken = clientToken
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encode(self.applicationVersion, forKey: .applicationVersion)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.environmentId, forKey: .environmentId)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion = "applicationVersion"
            case clientToken = "clientToken"
            case environmentId = "environmentId"
        }
    }

    public struct CreateDeploymentResponse: AWSDecodableShape {
        /// The unique identifier of the deployment.
        public let deploymentId: String

        public init(deploymentId: String) {
            self.deploymentId = deploymentId
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
        }
    }

    public struct CreateEnvironmentRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create an environment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
        public let clientToken: String?
        /// The description of the runtime environment.
        public let description: String?
        /// The engine type for the runtime environment.
        public let engineType: EngineType
        /// The version of the engine type for the runtime environment.
        public let engineVersion: String?
        /// The details of a high availability configuration for this runtime environment.
        public let highAvailabilityConfig: HighAvailabilityConfig?
        /// The type of instance for the runtime environment.
        public let instanceType: String
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The name of the runtime environment. Must be unique within the account.
        public let name: String
        /// Configures the maintenance window that you want for the runtime environment. The maintenance window must have the format ddd:hh24:mi-ddd:hh24:mi and must be less than 24 hours. The following two examples are valid maintenance windows: sun:23:45-mon:00:15 or sat:01:00-sat:03:00.  If you do not provide a value, a random system-generated value will be assigned.
        public let preferredMaintenanceWindow: String?
        /// Specifies whether the runtime environment is publicly accessible.
        public let publiclyAccessible: Bool?
        /// The list of security groups for the VPC associated with this runtime environment.
        public let securityGroupIds: [String]?
        /// Optional. The storage configurations for this runtime environment.
        public let storageConfigurations: [StorageConfiguration]?
        /// The list of subnets associated with the VPC for this runtime environment.
        public let subnetIds: [String]?
        /// The tags for the runtime environment.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateEnvironmentRequest.idempotencyToken(), description: String? = nil, engineType: EngineType, engineVersion: String? = nil, highAvailabilityConfig: HighAvailabilityConfig? = nil, instanceType: String, kmsKeyId: String? = nil, name: String, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, securityGroupIds: [String]? = nil, storageConfigurations: [StorageConfiguration]? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.highAvailabilityConfig = highAvailabilityConfig
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.storageConfigurations = storageConfigurations
            self.subnetIds = subnetIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^\\S{1,10}$")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^\\S{1,20}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "^\\S{1,50}$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^\\S{1,50}$")
            }
            try self.storageConfigurations?.forEach {
                try $0.validate(name: "\(name).storageConfigurations[]")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^\\S{1,50}$")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case highAvailabilityConfig = "highAvailabilityConfig"
            case instanceType = "instanceType"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case preferredMaintenanceWindow = "preferredMaintenanceWindow"
            case publiclyAccessible = "publiclyAccessible"
            case securityGroupIds = "securityGroupIds"
            case storageConfigurations = "storageConfigurations"
            case subnetIds = "subnetIds"
            case tags = "tags"
        }
    }

    public struct CreateEnvironmentResponse: AWSDecodableShape {
        /// The unique identifier of the runtime environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct DataSet: AWSEncodableShape {
        /// The logical identifier for a specific data set (in mainframe format).
        public let datasetName: String
        /// The type of dataset. The only supported value is VSAM.
        public let datasetOrg: DatasetOrgAttributes
        /// The length of a record.
        public let recordLength: RecordLength
        /// The relative location of the data set in the database or file system.
        public let relativePath: String?
        /// The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam.
        public let storageType: String?

        public init(datasetName: String, datasetOrg: DatasetOrgAttributes, recordLength: RecordLength, relativePath: String? = nil, storageType: String? = nil) {
            self.datasetName = datasetName
            self.datasetOrg = datasetOrg
            self.recordLength = recordLength
            self.relativePath = relativePath
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.datasetOrg.validate(name: "\(name).datasetOrg")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetName = "datasetName"
            case datasetOrg = "datasetOrg"
            case recordLength = "recordLength"
            case relativePath = "relativePath"
            case storageType = "storageType"
        }
    }

    public struct DataSetImportItem: AWSEncodableShape {
        /// The data set.
        public let dataSet: DataSet
        /// The location of the data set.
        public let externalLocation: ExternalLocation

        public init(dataSet: DataSet, externalLocation: ExternalLocation) {
            self.dataSet = dataSet
            self.externalLocation = externalLocation
        }

        public func validate(name: String) throws {
            try self.dataSet.validate(name: "\(name).dataSet")
            try self.externalLocation.validate(name: "\(name).externalLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSet = "dataSet"
            case externalLocation = "externalLocation"
        }
    }

    public struct DataSetImportSummary: AWSDecodableShape {
        /// The number of data set imports that have failed.
        public let failed: Int
        /// The number of data set imports that are in progress.
        public let inProgress: Int
        /// The number of data set imports that are pending.
        public let pending: Int
        /// The number of data set imports that have succeeded.
        public let succeeded: Int
        /// The total number of data set imports.
        public let total: Int

        public init(failed: Int, inProgress: Int, pending: Int, succeeded: Int, total: Int) {
            self.failed = failed
            self.inProgress = inProgress
            self.pending = pending
            self.succeeded = succeeded
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case failed = "failed"
            case inProgress = "inProgress"
            case pending = "pending"
            case succeeded = "succeeded"
            case total = "total"
        }
    }

    public struct DataSetImportTask: AWSDecodableShape {
        /// The status of the data set import task.
        public let status: DataSetTaskLifecycle
        /// If dataset import failed, the failure reason will show here.
        public let statusReason: String?
        /// A summary of the data set import task.
        public let summary: DataSetImportSummary
        /// The identifier of the data set import task.
        public let taskId: String

        public init(status: DataSetTaskLifecycle, statusReason: String? = nil, summary: DataSetImportSummary, taskId: String) {
            self.status = status
            self.statusReason = statusReason
            self.summary = summary
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusReason = "statusReason"
            case summary = "summary"
            case taskId = "taskId"
        }
    }

    public struct DataSetSummary: AWSDecodableShape {
        /// The timestamp when the data set was created.
        public let creationTime: Date?
        /// The name of the data set.
        public let dataSetName: String
        /// The type of data set. The only supported value is VSAM.
        public let dataSetOrg: String?
        /// The format of the data set.
        public let format: String?
        /// The last time the data set was referenced.
        public let lastReferencedTime: Date?
        /// The last time the data set was updated.
        public let lastUpdatedTime: Date?

        public init(creationTime: Date? = nil, dataSetName: String, dataSetOrg: String? = nil, format: String? = nil, lastReferencedTime: Date? = nil, lastUpdatedTime: Date? = nil) {
            self.creationTime = creationTime
            self.dataSetName = dataSetName
            self.dataSetOrg = dataSetOrg
            self.format = format
            self.lastReferencedTime = lastReferencedTime
            self.lastUpdatedTime = lastUpdatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case dataSetName = "dataSetName"
            case dataSetOrg = "dataSetOrg"
            case format = "format"
            case lastReferencedTime = "lastReferencedTime"
            case lastUpdatedTime = "lastUpdatedTime"
        }
    }

    public struct DeleteApplicationFromEnvironmentRequest: AWSEncodableShape {
        /// The unique identifier of the application you want to delete.
        public let applicationId: String
        /// The unique identifier of the runtime environment where the application was previously deployed.
        public let environmentId: String

        public init(applicationId: String, environmentId: String) {
            self.applicationId = applicationId
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationFromEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The unique identifier of the application you want to delete.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEnvironmentRequest: AWSEncodableShape {
        /// The unique identifier of the runtime environment you want to delete.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeployedVersionSummary: AWSDecodableShape {
        /// The version of the deployed application.
        public let applicationVersion: Int
        /// The status of the deployment.
        public let status: DeploymentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationVersion: Int, status: DeploymentLifecycle, statusReason: String? = nil) {
            self.applicationVersion = applicationVersion
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion = "applicationVersion"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct DeploymentSummary: AWSDecodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The version of the application.
        public let applicationVersion: Int
        /// The timestamp when the deployment was created.
        public let creationTime: Date
        /// The unique identifier of the deployment.
        public let deploymentId: String
        /// The unique identifier of the runtime environment.
        public let environmentId: String
        /// The current status of the deployment.
        public let status: DeploymentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationId: String, applicationVersion: Int, creationTime: Date, deploymentId: String, environmentId: String, status: DeploymentLifecycle, statusReason: String? = nil) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentId = deploymentId
            self.environmentId = environmentId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case applicationVersion = "applicationVersion"
            case creationTime = "creationTime"
            case deploymentId = "deploymentId"
            case environmentId = "environmentId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct EfsStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The file system identifier.
        public let fileSystemId: String
        /// The mount point for the file system.
        public let mountPoint: String

        public init(fileSystemId: String, mountPoint: String) {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^\\S{1,200}$")
            try self.validate(self.mountPoint, name: "mountPoint", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemId = "file-system-id"
            case mountPoint = "mount-point"
        }
    }

    public struct EngineVersionsSummary: AWSDecodableShape {
        /// The type of target platform for the application.
        public let engineType: String
        /// The version of the engine type used by the application.
        public let engineVersion: String

        public init(engineType: String, engineVersion: String) {
            self.engineType = engineType
            self.engineVersion = engineVersion
        }

        private enum CodingKeys: String, CodingKey {
            case engineType = "engineType"
            case engineVersion = "engineVersion"
        }
    }

    public struct EnvironmentSummary: AWSDecodableShape {
        /// The timestamp when the runtime environment was created.
        public let creationTime: Date
        /// The target platform for the runtime environment.
        public let engineType: EngineType
        /// The version of the runtime engine.
        public let engineVersion: String
        /// The Amazon Resource Name (ARN) of a particular runtime environment.
        public let environmentArn: String
        /// The unique identifier of a particular runtime environment.
        public let environmentId: String
        /// The instance type of the runtime environment.
        public let instanceType: String
        /// The name of the runtime environment.
        public let name: String
        /// The status of the runtime environment
        public let status: EnvironmentLifecycle

        public init(creationTime: Date, engineType: EngineType, engineVersion: String, environmentArn: String, environmentId: String, instanceType: String, name: String, status: EnvironmentLifecycle) {
            self.creationTime = creationTime
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.instanceType = instanceType
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case instanceType = "instanceType"
            case name = "name"
            case status = "status"
        }
    }

    public struct FileBatchJobDefinition: AWSDecodableShape {
        /// The name of the file containing the batch job definition.
        public let fileName: String
        /// The path to the file containing the batch job definition.
        public let folderPath: String?

        public init(fileName: String, folderPath: String? = nil) {
            self.fileName = fileName
            self.folderPath = folderPath
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "fileName"
            case folderPath = "folderPath"
        }
    }

    public struct FileBatchJobIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The file name for the batch job identifier.
        public let fileName: String
        /// The relative path to the file name for the batch job identifier.
        public let folderPath: String?

        public init(fileName: String, folderPath: String? = nil) {
            self.fileName = fileName
            self.folderPath = folderPath
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "fileName"
            case folderPath = "folderPath"
        }
    }

    public struct FsxStorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The file system identifier.
        public let fileSystemId: String
        /// The mount point for the file system.
        public let mountPoint: String

        public init(fileSystemId: String, mountPoint: String) {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "^\\S{1,200}$")
            try self.validate(self.mountPoint, name: "mountPoint", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemId = "file-system-id"
            case mountPoint = "mount-point"
        }
    }

    public struct GdgAttributes: AWSEncodableShape {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public let limit: Int?
        /// The disposition of the data set in the catalog.
        public let rollDisposition: String?

        public init(limit: Int? = nil, rollDisposition: String? = nil) {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case rollDisposition = "rollDisposition"
        }
    }

    public struct GdgDetailAttributes: AWSDecodableShape {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public let limit: Int?
        /// The disposition of the data set in the catalog.
        public let rollDisposition: String?

        public init(limit: Int? = nil, rollDisposition: String? = nil) {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case rollDisposition = "rollDisposition"
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        /// The identifier of the application.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the application.
        public let applicationArn: String
        /// The identifier of the application.
        public let applicationId: String
        /// The timestamp when this application was created.
        public let creationTime: Date
        /// The version of the application that is deployed.
        public let deployedVersion: DeployedVersionSummary?
        /// The description of the application.
        public let description: String?
        /// The type of the target platform for the application.
        public let engineType: EngineType
        /// The identifier of the runtime environment where you want to deploy the application.
        public let environmentId: String?
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The timestamp when you last started the application. Null until the application runs for the first time.
        public let lastStartTime: Date?
        /// The latest version of the application.
        public let latestVersion: ApplicationVersionSummary
        /// The Amazon Resource Name (ARN) for the network load balancer listener created in your Amazon Web Services account. Amazon Web Services Mainframe Modernization creates this listener for you the first time you deploy an application.
        public let listenerArns: [String]?
        /// The port associated with the network load balancer listener created in your Amazon Web Services account.
        public let listenerPorts: [Int]?
        /// The public DNS name of the load balancer created in your Amazon Web Services account.
        public let loadBalancerDnsName: String?
        /// The list of log summaries. Each log summary includes the log type as well as the log group identifier. These are CloudWatch logs. Amazon Web Services Mainframe Modernization pushes the application log to CloudWatch under the customer's account.
        public let logGroups: [LogGroupSummary]?
        /// The unique identifier of the application.
        public let name: String
        /// The Amazon Resource Name (ARN) of the role associated with the application.
        public let roleArn: String?
        /// The status of the application.
        public let status: ApplicationLifecycle
        /// The reason for the reported status.
        public let statusReason: String?
        /// A list of tags associated with the application.
        public let tags: [String: String]?
        /// Returns the Amazon Resource Names (ARNs) of the target groups that are attached to the network load balancer.
        public let targetGroupArns: [String]?

        public init(applicationArn: String, applicationId: String, creationTime: Date, deployedVersion: DeployedVersionSummary? = nil, description: String? = nil, engineType: EngineType, environmentId: String? = nil, kmsKeyId: String? = nil, lastStartTime: Date? = nil, latestVersion: ApplicationVersionSummary, listenerArns: [String]? = nil, listenerPorts: [Int]? = nil, loadBalancerDnsName: String? = nil, logGroups: [LogGroupSummary]? = nil, name: String, roleArn: String? = nil, status: ApplicationLifecycle, statusReason: String? = nil, tags: [String: String]? = nil, targetGroupArns: [String]? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.deployedVersion = deployedVersion
            self.description = description
            self.engineType = engineType
            self.environmentId = environmentId
            self.kmsKeyId = kmsKeyId
            self.lastStartTime = lastStartTime
            self.latestVersion = latestVersion
            self.listenerArns = listenerArns
            self.listenerPorts = listenerPorts
            self.loadBalancerDnsName = loadBalancerDnsName
            self.logGroups = logGroups
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.targetGroupArns = targetGroupArns
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationId = "applicationId"
            case creationTime = "creationTime"
            case deployedVersion = "deployedVersion"
            case description = "description"
            case engineType = "engineType"
            case environmentId = "environmentId"
            case kmsKeyId = "kmsKeyId"
            case lastStartTime = "lastStartTime"
            case latestVersion = "latestVersion"
            case listenerArns = "listenerArns"
            case listenerPorts = "listenerPorts"
            case loadBalancerDnsName = "loadBalancerDnsName"
            case logGroups = "logGroups"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
            case targetGroupArns = "targetGroupArns"
        }
    }

    public struct GetApplicationVersionRequest: AWSEncodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The specific version of the application.
        public let applicationVersion: Int

        public init(applicationId: String, applicationVersion: Int) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.applicationVersion, key: "applicationVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.applicationVersion, name: "applicationVersion", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationVersionResponse: AWSDecodableShape {
        /// The specific version of the application.
        public let applicationVersion: Int
        /// The timestamp when the application version was created.
        public let creationTime: Date
        /// The content of the application definition. This is a JSON object that contains the resource configuration and definitions that identify an application.
        public let definitionContent: String
        /// The application description.
        public let description: String?
        /// The name of the application version.
        public let name: String
        /// The status of the application version.
        public let status: ApplicationVersionLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationVersion: Int, creationTime: Date, definitionContent: String, description: String? = nil, name: String, status: ApplicationVersionLifecycle, statusReason: String? = nil) {
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.definitionContent = definitionContent
            self.description = description
            self.name = name
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion = "applicationVersion"
            case creationTime = "creationTime"
            case definitionContent = "definitionContent"
            case description = "description"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct GetBatchJobExecutionRequest: AWSEncodableShape {
        /// The identifier of the application.
        public let applicationId: String
        /// The unique identifier of the batch job execution.
        public let executionId: String

        public init(applicationId: String, executionId: String) {
            self.applicationId = applicationId
            self.executionId = executionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.executionId, key: "executionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.executionId, name: "executionId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBatchJobExecutionResponse: AWSDecodableShape {
        /// The identifier of the application.
        public let applicationId: String
        /// The unique identifier of this batch job.
        public let batchJobIdentifier: BatchJobIdentifier?
        /// The timestamp when the batch job execution ended.
        public let endTime: Date?
        /// The unique identifier for this batch job execution.
        public let executionId: String
        /// The unique identifier for this batch job.
        public let jobId: String?
        /// The name of this batch job.
        public let jobName: String?
        /// The type of job.
        public let jobType: BatchJobType?
        /// The user for the job.
        public let jobUser: String?
        /// The batch job return code from either the Blu Age or Micro Focus runtime engines. For more information, see Batch return codes in the IBM WebSphere Application Server documentation.
        public let returnCode: String?
        /// The timestamp when the batch job execution started.
        public let startTime: Date
        /// The status of the batch job execution.
        public let status: BatchJobExecutionStatus
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationId: String, batchJobIdentifier: BatchJobIdentifier? = nil, endTime: Date? = nil, executionId: String, jobId: String? = nil, jobName: String? = nil, jobType: BatchJobType? = nil, jobUser: String? = nil, returnCode: String? = nil, startTime: Date, status: BatchJobExecutionStatus, statusReason: String? = nil) {
            self.applicationId = applicationId
            self.batchJobIdentifier = batchJobIdentifier
            self.endTime = endTime
            self.executionId = executionId
            self.jobId = jobId
            self.jobName = jobName
            self.jobType = jobType
            self.jobUser = jobUser
            self.returnCode = returnCode
            self.startTime = startTime
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case batchJobIdentifier = "batchJobIdentifier"
            case endTime = "endTime"
            case executionId = "executionId"
            case jobId = "jobId"
            case jobName = "jobName"
            case jobType = "jobType"
            case jobUser = "jobUser"
            case returnCode = "returnCode"
            case startTime = "startTime"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct GetDataSetDetailsRequest: AWSEncodableShape {
        /// The unique identifier of the application that this data set is associated with.
        public let applicationId: String
        /// The name of the data set.
        public let dataSetName: String

        public init(applicationId: String, dataSetName: String) {
            self.applicationId = applicationId
            self.dataSetName = dataSetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSetName, key: "dataSetName")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.dataSetName, name: "dataSetName", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSetDetailsResponse: AWSDecodableShape {
        /// The size of the block on disk.
        public let blocksize: Int?
        /// The timestamp when the data set was created.
        public let creationTime: Date?
        /// The name of the data set.
        public let dataSetName: String
        /// The type of data set. The only supported value is VSAM.
        public let dataSetOrg: DatasetDetailOrgAttributes?
        /// File size of the dataset.
        public let fileSize: Int64?
        /// The last time the data set was referenced.
        public let lastReferencedTime: Date?
        /// The last time the data set was updated.
        public let lastUpdatedTime: Date?
        /// The location where the data set is stored.
        public let location: String?
        /// The length of records in the data set.
        public let recordLength: Int?

        public init(blocksize: Int? = nil, creationTime: Date? = nil, dataSetName: String, dataSetOrg: DatasetDetailOrgAttributes? = nil, fileSize: Int64? = nil, lastReferencedTime: Date? = nil, lastUpdatedTime: Date? = nil, location: String? = nil, recordLength: Int? = nil) {
            self.blocksize = blocksize
            self.creationTime = creationTime
            self.dataSetName = dataSetName
            self.dataSetOrg = dataSetOrg
            self.fileSize = fileSize
            self.lastReferencedTime = lastReferencedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.location = location
            self.recordLength = recordLength
        }

        private enum CodingKeys: String, CodingKey {
            case blocksize = "blocksize"
            case creationTime = "creationTime"
            case dataSetName = "dataSetName"
            case dataSetOrg = "dataSetOrg"
            case fileSize = "fileSize"
            case lastReferencedTime = "lastReferencedTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case location = "location"
            case recordLength = "recordLength"
        }
    }

    public struct GetDataSetImportTaskRequest: AWSEncodableShape {
        /// The application identifier.
        public let applicationId: String
        /// The task identifier returned by the CreateDataSetImportTask operation.
        public let taskId: String

        public init(applicationId: String, taskId: String) {
            self.applicationId = applicationId
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSetImportTaskResponse: AWSDecodableShape {
        /// The status of the task.
        public let status: DataSetTaskLifecycle
        /// A summary of the status of the task.
        public let summary: DataSetImportSummary?
        /// The task identifier.
        public let taskId: String

        public init(status: DataSetTaskLifecycle, summary: DataSetImportSummary? = nil, taskId: String) {
            self.status = status
            self.summary = summary
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case summary = "summary"
            case taskId = "taskId"
        }
    }

    public struct GetDeploymentRequest: AWSEncodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The unique identifier for the deployment.
        public let deploymentId: String

        public init(applicationId: String, deploymentId: String) {
            self.applicationId = applicationId
            self.deploymentId = deploymentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.deploymentId, key: "deploymentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeploymentResponse: AWSDecodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The application version.
        public let applicationVersion: Int
        /// The timestamp when the deployment was created.
        public let creationTime: Date
        /// The unique identifier of the deployment.
        public let deploymentId: String
        /// The unique identifier of the runtime environment.
        public let environmentId: String
        /// The status of the deployment.
        public let status: DeploymentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?

        public init(applicationId: String, applicationVersion: Int, creationTime: Date, deploymentId: String, environmentId: String, status: DeploymentLifecycle, statusReason: String? = nil) {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentId = deploymentId
            self.environmentId = environmentId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case applicationVersion = "applicationVersion"
            case creationTime = "creationTime"
            case deploymentId = "deploymentId"
            case environmentId = "environmentId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct GetEnvironmentRequest: AWSEncodableShape {
        /// The unique identifier of the runtime environment.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.environmentId, key: "environmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentResponse: AWSDecodableShape {
        /// The number of instances included in the runtime environment. A standalone runtime environment has a maximum of one instance. Currently, a high availability runtime environment has a maximum of two instances.
        public let actualCapacity: Int?
        /// The timestamp when the runtime environment was created.
        public let creationTime: Date
        /// The description of the runtime environment.
        public let description: String?
        /// The target platform for the runtime environment.
        public let engineType: EngineType
        /// The version of the runtime engine.
        public let engineVersion: String
        /// The Amazon Resource Name (ARN) of the runtime environment.
        public let environmentArn: String
        /// The unique identifier of the runtime environment.
        public let environmentId: String
        /// The desired capacity of the high availability configuration for the runtime environment.
        public let highAvailabilityConfig: HighAvailabilityConfig?
        /// The type of instance underlying the runtime environment.
        public let instanceType: String
        /// The identifier of a customer managed key.
        public let kmsKeyId: String?
        /// The Amazon Resource Name (ARN) for the load balancer used with the runtime environment.
        public let loadBalancerArn: String?
        /// The name of the runtime environment. Must be unique within the account.
        public let name: String
        /// Indicates the pending maintenance scheduled on this environment.
        public let pendingMaintenance: PendingMaintenance?
        /// The maintenance window for the runtime environment. If you don't provide a value for the maintenance window, the service assigns a random value.
        public let preferredMaintenanceWindow: String?
        /// Whether applications running in this runtime environment are publicly accessible.
        public let publiclyAccessible: Bool?
        /// The unique identifiers of the security groups assigned to this runtime environment.
        public let securityGroupIds: [String]
        /// The status of the runtime environment.
        public let status: EnvironmentLifecycle
        /// The reason for the reported status.
        public let statusReason: String?
        /// The storage configurations defined for the runtime environment.
        public let storageConfigurations: [StorageConfiguration]?
        /// The unique identifiers of the subnets assigned to this runtime environment.
        public let subnetIds: [String]
        /// The tags defined for this runtime environment.
        public let tags: [String: String]?
        /// The unique identifier for the VPC used with this runtime environment.
        public let vpcId: String

        public init(actualCapacity: Int? = nil, creationTime: Date, description: String? = nil, engineType: EngineType, engineVersion: String, environmentArn: String, environmentId: String, highAvailabilityConfig: HighAvailabilityConfig? = nil, instanceType: String, kmsKeyId: String? = nil, loadBalancerArn: String? = nil, name: String, pendingMaintenance: PendingMaintenance? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, securityGroupIds: [String], status: EnvironmentLifecycle, statusReason: String? = nil, storageConfigurations: [StorageConfiguration]? = nil, subnetIds: [String], tags: [String: String]? = nil, vpcId: String) {
            self.actualCapacity = actualCapacity
            self.creationTime = creationTime
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.highAvailabilityConfig = highAvailabilityConfig
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.loadBalancerArn = loadBalancerArn
            self.name = name
            self.pendingMaintenance = pendingMaintenance
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.statusReason = statusReason
            self.storageConfigurations = storageConfigurations
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case actualCapacity = "actualCapacity"
            case creationTime = "creationTime"
            case description = "description"
            case engineType = "engineType"
            case engineVersion = "engineVersion"
            case environmentArn = "environmentArn"
            case environmentId = "environmentId"
            case highAvailabilityConfig = "highAvailabilityConfig"
            case instanceType = "instanceType"
            case kmsKeyId = "kmsKeyId"
            case loadBalancerArn = "loadBalancerArn"
            case name = "name"
            case pendingMaintenance = "pendingMaintenance"
            case preferredMaintenanceWindow = "preferredMaintenanceWindow"
            case publiclyAccessible = "publiclyAccessible"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case statusReason = "statusReason"
            case storageConfigurations = "storageConfigurations"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcId = "vpcId"
        }
    }

    public struct GetSignedBluinsightsUrlResponse: AWSDecodableShape {
        /// Single sign-on AWS Blu Insights URL.
        public let signedBiUrl: String

        public init(signedBiUrl: String) {
            self.signedBiUrl = signedBiUrl
        }

        private enum CodingKeys: String, CodingKey {
            case signedBiUrl = "signedBiUrl"
        }
    }

    public struct HighAvailabilityConfig: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances in a high availability configuration. The minimum possible value is 1 and the maximum is 100.
        public let desiredCapacity: Int

        public init(desiredCapacity: Int) {
            self.desiredCapacity = desiredCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case desiredCapacity = "desiredCapacity"
        }
    }

    public struct ListApplicationVersionsRequest: AWSEncodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The maximum number of application versions to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationVersionsResponse: AWSDecodableShape {
        /// The list of application versions.
        public let applicationVersions: [ApplicationVersionSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(applicationVersions: [ApplicationVersionSummary], nextToken: String? = nil) {
            self.applicationVersions = applicationVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersions = "applicationVersions"
            case nextToken = "nextToken"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The unique identifier of the runtime environment where the applications are deployed.
        public let environmentId: String?
        /// The maximum number of applications to return.
        public let maxResults: Int?
        /// The names of the applications.
        public let names: [String]?
        /// A pagination token to control the number of applications displayed in the list.
        public let nextToken: String?

        public init(environmentId: String? = nil, maxResults: Int? = nil, names: [String]? = nil, nextToken: String? = nil) {
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.names = names
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.names, key: "names")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 10)
            try self.validate(self.names, name: "names", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// Returns a list of summary details for all the applications in a runtime environment.
        public let applications: [ApplicationSummary]
        /// A pagination token that's returned when the response doesn't contain all applications.
        public let nextToken: String?

        public init(applications: [ApplicationSummary], nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "applications"
            case nextToken = "nextToken"
        }
    }

    public struct ListBatchJobDefinitionsRequest: AWSEncodableShape {
        /// The identifier of the application.
        public let applicationId: String
        /// The maximum number of batch job definitions to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?
        /// If the batch job definition is a FileBatchJobDefinition, the prefix allows you to search on the file names of FileBatchJobDefinitions.
        public let prefix: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil, prefix: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.prefix = prefix
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.prefix, key: "prefix")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBatchJobDefinitionsResponse: AWSDecodableShape {
        /// The list of batch job definitions.
        public let batchJobDefinitions: [BatchJobDefinition]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(batchJobDefinitions: [BatchJobDefinition], nextToken: String? = nil) {
            self.batchJobDefinitions = batchJobDefinitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobDefinitions = "batchJobDefinitions"
            case nextToken = "nextToken"
        }
    }

    public struct ListBatchJobExecutionsRequest: AWSEncodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The unique identifier of each batch job execution.
        public let executionIds: [String]?
        /// The name of each batch job execution.
        public let jobName: String?
        /// The maximum number of batch job executions to return.
        public let maxResults: Int?
        /// A pagination token to control the number of batch job executions displayed in the list.
        public let nextToken: String?
        /// The time after which the batch job executions started.
        public let startedAfter: Date?
        /// The time before the batch job executions started.
        public let startedBefore: Date?
        /// The status of the batch job executions.
        public let status: BatchJobExecutionStatus?

        public init(applicationId: String, executionIds: [String]? = nil, jobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, startedAfter: Date? = nil, startedBefore: Date? = nil, status: BatchJobExecutionStatus? = nil) {
            self.applicationId = applicationId
            self.executionIds = executionIds
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.executionIds, key: "executionIds")
            request.encodeQuery(self.jobName, key: "jobName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.startedAfter, key: "startedAfter")
            request.encodeQuery(self.startedBefore, key: "startedBefore")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.executionIds?.forEach {
                try validate($0, name: "executionIds[]", parent: name, pattern: "^\\S{1,80}$")
            }
            try self.validate(self.executionIds, name: "executionIds", parent: name, max: 10)
            try self.validate(self.executionIds, name: "executionIds", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^\\S{1,100}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBatchJobExecutionsResponse: AWSDecodableShape {
        /// Returns a list of batch job executions for an application.
        public let batchJobExecutions: [BatchJobExecutionSummary]
        /// A pagination token that's returned when the response doesn't contain all batch job executions.
        public let nextToken: String?

        public init(batchJobExecutions: [BatchJobExecutionSummary], nextToken: String? = nil) {
            self.batchJobExecutions = batchJobExecutions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobExecutions = "batchJobExecutions"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSetImportHistoryRequest: AWSEncodableShape {
        /// The unique identifier of the application.
        public let applicationId: String
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetImportHistoryResponse: AWSDecodableShape {
        /// The data set import tasks.
        public let dataSetImportTasks: [DataSetImportTask]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(dataSetImportTasks: [DataSetImportTask], nextToken: String? = nil) {
            self.dataSetImportTasks = dataSetImportTasks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetImportTasks = "dataSetImportTasks"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSetsRequest: AWSEncodableShape {
        /// The unique identifier of the application for which you want to list the associated data sets.
        public let applicationId: String
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// Filter dataset name matching the specified pattern. Can use * and % as wild cards.
        public let nameFilter: String?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?
        /// The prefix of the data set name, which you can use to filter the list of data sets.
        public let prefix: String?

        public init(applicationId: String, maxResults: Int? = nil, nameFilter: String? = nil, nextToken: String? = nil, prefix: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nameFilter = nameFilter
            self.nextToken = nextToken
            self.prefix = prefix
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameFilter, key: "nameFilter")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.prefix, key: "prefix")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameFilter, name: "nameFilter", parent: name, pattern: "^\\S{1,200}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^\\S{1,200}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSetsResponse: AWSDecodableShape {
        /// The list of data sets, containing information including the creation time, the data set name, the data set organization, the data set format, and the last time the data set was referenced or updated.
        public let dataSets: [DataSetSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(dataSets: [DataSetSummary], nextToken: String? = nil) {
            self.dataSets = dataSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSets = "dataSets"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentsRequest: AWSEncodableShape {
        /// The application identifier.
        public let applicationId: String
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeploymentsResponse: AWSDecodableShape {
        /// The list of deployments that is returned.
        public let deployments: [DeploymentSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(deployments: [DeploymentSummary], nextToken: String? = nil) {
            self.deployments = deployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deployments = "deployments"
            case nextToken = "nextToken"
        }
    }

    public struct ListEngineVersionsRequest: AWSEncodableShape {
        /// The type of target platform.
        public let engineType: EngineType?
        /// The maximum number of objects to return.
        public let maxResults: Int?
        /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
        public let nextToken: String?

        public init(engineType: EngineType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.engineType = engineType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.engineType, key: "engineType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEngineVersionsResponse: AWSDecodableShape {
        /// Returns the engine versions.
        public let engineVersions: [EngineVersionsSummary]
        /// If there are more items to return, this contains a token  that is passed to a subsequent call to this operation to retrieve the next set of items.
        public let nextToken: String?

        public init(engineVersions: [EngineVersionsSummary], nextToken: String? = nil) {
            self.engineVersions = engineVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case engineVersions = "engineVersions"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentsRequest: AWSEncodableShape {
        /// The engine type for the runtime environment.
        public let engineType: EngineType?
        /// The maximum number of runtime environments to return.
        public let maxResults: Int?
        /// The names of the runtime environments. Must be unique within the account.
        public let names: [String]?
        /// A pagination token to control the number of runtime environments displayed in the list.
        public let nextToken: String?

        public init(engineType: EngineType? = nil, maxResults: Int? = nil, names: [String]? = nil, nextToken: String? = nil) {
            self.engineType = engineType
            self.maxResults = maxResults
            self.names = names
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.engineType, key: "engineType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.names, key: "names")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9_\\-]{1,59}$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 10)
            try self.validate(self.names, name: "names", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsResponse: AWSDecodableShape {
        /// Returns a list of summary details for all the runtime environments in your account.
        public let environments: [EnvironmentSummary]
        /// A pagination token that's returned when the response doesn't contain all the runtime environments.
        public let nextToken: String?

        public init(environments: [EnvironmentSummary], nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]|):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LogGroupSummary: AWSDecodableShape {
        /// The name of the log group.
        public let logGroupName: String
        /// The type of log.
        public let logType: String

        public init(logGroupName: String, logType: String) {
            self.logGroupName = logGroupName
            self.logType = logType
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "logGroupName"
            case logType = "logType"
        }
    }

    public struct MaintenanceSchedule: AWSDecodableShape {
        /// The time the scheduled maintenance is to end.
        public let endTime: Date?
        /// The time the scheduled maintenance is to start.
        public let startTime: Date?

        public init(endTime: Date? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct PendingMaintenance: AWSDecodableShape {
        /// The specific runtime engine that the maintenance schedule applies to.
        public let engineVersion: String?
        /// The maintenance schedule for the runtime engine version.
        public let schedule: MaintenanceSchedule?

        public init(engineVersion: String? = nil, schedule: MaintenanceSchedule? = nil) {
            self.engineVersion = engineVersion
            self.schedule = schedule
        }

        private enum CodingKeys: String, CodingKey {
            case engineVersion = "engineVersion"
            case schedule = "schedule"
        }
    }

    public struct PoAttributes: AWSEncodableShape {
        /// The character set encoding of the data set.
        public let encoding: String?
        /// The format of the data set records.
        public let format: String
        /// An array containing one or more filename extensions, allowing you to specify which files to be included as PDS member.
        public let memberFileExtensions: [String]

        public init(encoding: String? = nil, format: String, memberFileExtensions: [String]) {
            self.encoding = encoding
            self.format = format
            self.memberFileExtensions = memberFileExtensions
        }

        public func validate(name: String) throws {
            try self.memberFileExtensions.forEach {
                try validate($0, name: "memberFileExtensions[]", parent: name, pattern: "^\\S{1,20}$")
            }
            try self.validate(self.memberFileExtensions, name: "memberFileExtensions", parent: name, max: 10)
            try self.validate(self.memberFileExtensions, name: "memberFileExtensions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encoding = "encoding"
            case format = "format"
            case memberFileExtensions = "memberFileExtensions"
        }
    }

    public struct PoDetailAttributes: AWSDecodableShape {
        /// The character set encoding of the data set.
        public let encoding: String
        /// The format of the data set records.
        public let format: String

        public init(encoding: String, format: String) {
            self.encoding = encoding
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case encoding = "encoding"
            case format = "format"
        }
    }

    public struct PrimaryKey: AWSEncodableShape & AWSDecodableShape {
        /// A strictly positive integer value representing the length of the primary key.
        public let length: Int
        /// A name for the Primary Key.
        public let name: String?
        /// A positive integer value representing the offset to mark the start of the primary key in the record byte array.
        public let offset: Int

        public init(length: Int, name: String? = nil, offset: Int) {
            self.length = length
            self.name = name
            self.offset = offset
        }

        private enum CodingKeys: String, CodingKey {
            case length = "length"
            case name = "name"
            case offset = "offset"
        }
    }

    public struct PsAttributes: AWSEncodableShape {
        /// The character set encoding of the data set.
        public let encoding: String?
        /// The format of the data set records.
        public let format: String

        public init(encoding: String? = nil, format: String) {
            self.encoding = encoding
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case encoding = "encoding"
            case format = "format"
        }
    }

    public struct PsDetailAttributes: AWSDecodableShape {
        /// The character set encoding of the data set.
        public let encoding: String
        /// The format of the data set records.
        public let format: String

        public init(encoding: String, format: String) {
            self.encoding = encoding
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case encoding = "encoding"
            case format = "format"
        }
    }

    public struct RecordLength: AWSEncodableShape {
        /// The maximum record length. In case of fixed, both minimum and maximum are the same.
        public let max: Int
        /// The minimum record length of a record.
        public let min: Int

        public init(max: Int = 0, min: Int = 0) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "max"
            case min = "min"
        }
    }

    public struct S3BatchJobIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket that contains the batch job definitions.
        public let bucket: String
        /// Identifies the batch job definition. This identifier can also point to any batch job definition that already exists in the application or to one of the batch job definitions within the directory that is specified in keyPrefix.
        public let identifier: JobIdentifier
        /// The key prefix that specifies the path to the folder in the S3 bucket that has the batch job definitions.
        public let keyPrefix: String?

        public init(bucket: String, identifier: JobIdentifier, keyPrefix: String? = nil) {
            self.bucket = bucket
            self.identifier = identifier
            self.keyPrefix = keyPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case identifier = "identifier"
            case keyPrefix = "keyPrefix"
        }
    }

    public struct ScriptBatchJobDefinition: AWSDecodableShape {
        /// The name of the script containing the batch job definition.
        public let scriptName: String

        public init(scriptName: String) {
            self.scriptName = scriptName
        }

        private enum CodingKeys: String, CodingKey {
            case scriptName = "scriptName"
        }
    }

    public struct ScriptBatchJobIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the script containing the batch job definition.
        public let scriptName: String

        public init(scriptName: String) {
            self.scriptName = scriptName
        }

        private enum CodingKeys: String, CodingKey {
            case scriptName = "scriptName"
        }
    }

    public struct StartApplicationRequest: AWSEncodableShape {
        /// The unique identifier of the application you want to start.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartBatchJobRequest: AWSEncodableShape {
        /// The unique identifier of the application associated with this batch job.
        public let applicationId: String
        /// The unique identifier of the batch job.
        public let batchJobIdentifier: BatchJobIdentifier
        /// The collection of batch job parameters. For details about limits for keys and values, see Coding variables in JCL.
        public let jobParams: [String: String]?

        public init(applicationId: String, batchJobIdentifier: BatchJobIdentifier, jobParams: [String: String]? = nil) {
            self.applicationId = applicationId
            self.batchJobIdentifier = batchJobIdentifier
            self.jobParams = jobParams
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encode(self.batchJobIdentifier, forKey: .batchJobIdentifier)
            try container.encodeIfPresent(self.jobParams, forKey: .jobParams)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.jobParams?.forEach {
                try validate($0.key, name: "jobParams.key", parent: name, max: 32)
                try validate($0.key, name: "jobParams.key", parent: name, min: 1)
                try validate($0.key, name: "jobParams.key", parent: name, pattern: "^[A-Za-z][A-Za-z0-9]{1,7}$")
                try validate($0.value, name: "jobParams[\"\($0.key)\"]", parent: name, max: 80)
            }
            try self.validate(self.jobParams, name: "jobParams", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobIdentifier = "batchJobIdentifier"
            case jobParams = "jobParams"
        }
    }

    public struct StartBatchJobResponse: AWSDecodableShape {
        /// The unique identifier of this execution of the batch job.
        public let executionId: String

        public init(executionId: String) {
            self.executionId = executionId
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
        }
    }

    public struct StopApplicationRequest: AWSEncodableShape {
        /// The unique identifier of the application you want to stop.
        public let applicationId: String
        /// Stopping an application process can take a long time. Setting this parameter to true lets you force stop the application so you don't need to wait until the process finishes to apply another action on the application. The default value is false.
        public let forceStop: Bool?

        public init(applicationId: String, forceStop: Bool? = nil) {
            self.applicationId = applicationId
            self.forceStop = forceStop
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.forceStop, forKey: .forceStop)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
        }

        private enum CodingKeys: String, CodingKey {
            case forceStop = "forceStop"
        }
    }

    public struct StopApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]|):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The keys of the tags to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]|):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).+$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// The unique identifier of the application you want to update.
        public let applicationId: String
        /// The current version of the application to update.
        public let currentApplicationVersion: Int
        /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
        public let definition: Definition?
        /// The description of the application to update.
        public let description: String?

        public init(applicationId: String, currentApplicationVersion: Int, definition: Definition? = nil, description: String? = nil) {
            self.applicationId = applicationId
            self.currentApplicationVersion = currentApplicationVersion
            self.definition = definition
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encode(self.currentApplicationVersion, forKey: .currentApplicationVersion)
            try container.encodeIfPresent(self.definition, forKey: .definition)
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.currentApplicationVersion, name: "currentApplicationVersion", parent: name, min: 1)
            try self.definition?.validate(name: "\(name).definition")
            try self.validate(self.description, name: "description", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case currentApplicationVersion = "currentApplicationVersion"
            case definition = "definition"
            case description = "description"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        /// The new version of the application.
        public let applicationVersion: Int

        public init(applicationVersion: Int) {
            self.applicationVersion = applicationVersion
        }

        private enum CodingKeys: String, CodingKey {
            case applicationVersion = "applicationVersion"
        }
    }

    public struct UpdateEnvironmentRequest: AWSEncodableShape {
        /// Indicates whether to update the runtime environment during the maintenance window. The default is false. Currently, Amazon Web Services Mainframe Modernization accepts the engineVersion parameter only if applyDuringMaintenanceWindow is true. If any parameter other than engineVersion is provided in UpdateEnvironmentRequest, it will fail if applyDuringMaintenanceWindow is set to true.
        public let applyDuringMaintenanceWindow: Bool?
        /// The desired capacity for the runtime environment to update. The minimum possible value is 0 and the maximum is 100.
        public let desiredCapacity: Int?
        /// The version of the runtime engine for the runtime environment.
        public let engineVersion: String?
        /// The unique identifier of the runtime environment that you want to update.
        public let environmentId: String
        /// Forces the updates on the environment. This option is needed if the applications in the environment are not stopped or if there are ongoing application-related activities in the environment. If you use this option, be aware that it could lead to data corruption in the applications, and that you might need to perform repair and recovery procedures for the applications. This option is not needed if the attribute being updated is preferredMaintenanceWindow.
        public let forceUpdate: Bool?
        /// The instance type for the runtime environment to update.
        public let instanceType: String?
        /// Configures the maintenance window that you want for the runtime environment. The maintenance window must have the format ddd:hh24:mi-ddd:hh24:mi and must be less than 24 hours. The following two examples are valid maintenance windows: sun:23:45-mon:00:15 or sat:01:00-sat:03:00.  If you do not provide a value, a random system-generated value will be assigned.
        public let preferredMaintenanceWindow: String?

        public init(applyDuringMaintenanceWindow: Bool? = nil, desiredCapacity: Int? = nil, engineVersion: String? = nil, environmentId: String, forceUpdate: Bool? = nil, instanceType: String? = nil, preferredMaintenanceWindow: String? = nil) {
            self.applyDuringMaintenanceWindow = applyDuringMaintenanceWindow
            self.desiredCapacity = desiredCapacity
            self.engineVersion = engineVersion
            self.environmentId = environmentId
            self.forceUpdate = forceUpdate
            self.instanceType = instanceType
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.applyDuringMaintenanceWindow, forKey: .applyDuringMaintenanceWindow)
            try container.encodeIfPresent(self.desiredCapacity, forKey: .desiredCapacity)
            try container.encodeIfPresent(self.engineVersion, forKey: .engineVersion)
            request.encodePath(self.environmentId, key: "environmentId")
            try container.encodeIfPresent(self.forceUpdate, forKey: .forceUpdate)
            try container.encodeIfPresent(self.instanceType, forKey: .instanceType)
            try container.encodeIfPresent(self.preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }

        public func validate(name: String) throws {
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^\\S{1,10}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^\\S{1,80}$")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^\\S{1,20}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyDuringMaintenanceWindow = "applyDuringMaintenanceWindow"
            case desiredCapacity = "desiredCapacity"
            case engineVersion = "engineVersion"
            case forceUpdate = "forceUpdate"
            case instanceType = "instanceType"
            case preferredMaintenanceWindow = "preferredMaintenanceWindow"
        }
    }

    public struct UpdateEnvironmentResponse: AWSDecodableShape {
        /// The unique identifier of the runtime environment that was updated.
        public let environmentId: String

        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct VsamAttributes: AWSEncodableShape {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public let alternateKeys: [AlternateKey]?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.
        public let compressed: Bool?
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public let encoding: String?
        /// The record format of the data set.
        public let format: String
        /// The primary key of the data set.
        public let primaryKey: PrimaryKey?

        public init(alternateKeys: [AlternateKey]? = nil, compressed: Bool? = nil, encoding: String? = nil, format: String, primaryKey: PrimaryKey? = nil) {
            self.alternateKeys = alternateKeys
            self.compressed = compressed
            self.encoding = encoding
            self.format = format
            self.primaryKey = primaryKey
        }

        private enum CodingKeys: String, CodingKey {
            case alternateKeys = "alternateKeys"
            case compressed = "compressed"
            case encoding = "encoding"
            case format = "format"
            case primaryKey = "primaryKey"
        }
    }

    public struct VsamDetailAttributes: AWSDecodableShape {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public let alternateKeys: [AlternateKey]?
        /// If set to True, enforces loading the data set into cache before it’s used by the application.
        public let cacheAtStartup: Bool?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically &gt; 100 Mb), consider setting this flag to True.
        public let compressed: Bool?
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public let encoding: String?
        /// The primary key of the data set.
        public let primaryKey: PrimaryKey?
        /// The record format of the data set.
        public let recordFormat: String?

        public init(alternateKeys: [AlternateKey]? = nil, cacheAtStartup: Bool? = nil, compressed: Bool? = nil, encoding: String? = nil, primaryKey: PrimaryKey? = nil, recordFormat: String? = nil) {
            self.alternateKeys = alternateKeys
            self.cacheAtStartup = cacheAtStartup
            self.compressed = compressed
            self.encoding = encoding
            self.primaryKey = primaryKey
            self.recordFormat = recordFormat
        }

        private enum CodingKeys: String, CodingKey {
            case alternateKeys = "alternateKeys"
            case cacheAtStartup = "cacheAtStartup"
            case compressed = "compressed"
            case encoding = "encoding"
            case primaryKey = "primaryKey"
            case recordFormat = "recordFormat"
        }
    }

    public struct ExternalLocation: AWSEncodableShape {
        /// The URI of the Amazon S3 bucket.
        public let s3Location: String?

        public init(s3Location: String? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Location, name: "s3Location", parent: name, pattern: "^\\S{1,2000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }
}

// MARK: - Errors

/// Error enum for M2
public struct M2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case executionTimeoutException = "ExecutionTimeoutException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize M2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The account or role doesn't have the right permissions to make the request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The parameters provided in the request conflict with existing resources.
    public static var conflictException: Self { .init(.conflictException) }
    ///  Failed to connect to server, or didn’t receive response within expected time period.
    public static var executionTimeoutException: Self { .init(.executionTimeoutException) }
    /// An unexpected error occurred during the processing of the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// One or more quotas for Amazon Web Services Mainframe Modernization exceeds the limit.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Server cannot process the request at the moment.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The number of requests made exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One or more parameters provided in the request is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension M2ErrorType: Equatable {
    public static func == (lhs: M2ErrorType, rhs: M2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension M2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
