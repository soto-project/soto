//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS M2 service.
///
/// Amazon Web Services Mainframe Modernization provides tools and resources to help you plan and implement migration and modernization from mainframes to Amazon Web Services managed runtime environments. It provides tools for analyzing existing mainframe applications, developing or updating mainframe applications using COBOL or PL/I, and implementing an automated pipeline for continuous integration and continuous delivery (CI/CD) of the applications.
public struct M2: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the M2 client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "M2",
            serviceIdentifier: "m2",
            serviceProtocol: .restjson,
            apiVersion: "2021-04-28",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: M2ErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "ca-central-1": "m2-fips.ca-central-1.amazonaws.com",
            "us-east-1": "m2-fips.us-east-1.amazonaws.com",
            "us-east-2": "m2-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "m2-fips.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "m2-fips.us-gov-west-1.amazonaws.com",
            "us-west-1": "m2-fips.us-west-1.amazonaws.com",
            "us-west-2": "m2-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Cancels the running of a specific batch job execution.
    @Sendable
    @inlinable
    public func cancelBatchJobExecution(_ input: CancelBatchJobExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelBatchJobExecutionResponse {
        try await self.client.execute(
            operation: "CancelBatchJobExecution", 
            path: "/applications/{applicationId}/batch-job-executions/{executionId}/cancel", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels the running of a specific batch job execution.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - authSecretsManagerArn: The Amazon Web Services Secrets Manager containing user's credentials for authentication and authorization for Cancel Batch Job Execution operation.
    ///   - executionId: The unique identifier of the batch job execution.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelBatchJobExecution(
        applicationId: String,
        authSecretsManagerArn: String? = nil,
        executionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelBatchJobExecutionResponse {
        let input = CancelBatchJobExecutionRequest(
            applicationId: applicationId, 
            authSecretsManagerArn: authSecretsManagerArn, 
            executionId: executionId
        )
        return try await self.cancelBatchJobExecution(input, logger: logger)
    }

    /// Creates a new application with given parameters. Requires an existing runtime environment and application definition file.
    @Sendable
    @inlinable
    public func createApplication(_ input: CreateApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateApplicationResponse {
        try await self.client.execute(
            operation: "CreateApplication", 
            path: "/applications", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new application with given parameters. Requires an existing runtime environment and application definition file.
    ///
    /// Parameters:
    ///   - clientToken: A client token is a unique, case-sensitive string of up to 128 ASCII characters with ASCII values of 33-126 inclusive. It's generated by the client to ensure idempotent operations, allowing for safe retries without unintended side effects.
    ///   - definition: The application definition for this application. You can specify either inline JSON or an S3 bucket location.
    ///   - description: The description of the application.
    ///   - engineType: The type of the target platform for this application.
    ///   - kmsKeyId: The identifier of a customer managed key.
    ///   - name: The unique identifier of the application.
    ///   - roleArn: The Amazon Resource Name (ARN) that identifies a role that the application uses to access Amazon Web Services resources that are not part of the application or are in a different Amazon Web Services account.
    ///   - tags: A list of tags to apply to the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func createApplication(
        clientToken: String? = CreateApplicationRequest.idempotencyToken(),
        definition: Definition,
        description: String? = nil,
        engineType: EngineType,
        kmsKeyId: String? = nil,
        name: String,
        roleArn: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateApplicationResponse {
        let input = CreateApplicationRequest(
            clientToken: clientToken, 
            definition: definition, 
            description: description, 
            engineType: engineType, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createApplication(input, logger: logger)
    }

    /// Starts a data set import task for a specific application.
    @Sendable
    @inlinable
    public func createDataSetImportTask(_ input: CreateDataSetImportTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDataSetImportTaskResponse {
        try await self.client.execute(
            operation: "CreateDataSetImportTask", 
            path: "/applications/{applicationId}/dataset-import-task", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a data set import task for a specific application.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application for which you want to import data sets.
    ///   - clientToken:  Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a data set import. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    ///   - importConfig: The data set import task configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataSetImportTask(
        applicationId: String,
        clientToken: String? = CreateDataSetImportTaskRequest.idempotencyToken(),
        importConfig: DataSetImportConfig,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDataSetImportTaskResponse {
        let input = CreateDataSetImportTaskRequest(
            applicationId: applicationId, 
            clientToken: clientToken, 
            importConfig: importConfig
        )
        return try await self.createDataSetImportTask(input, logger: logger)
    }

    /// Creates and starts a deployment to deploy an application into a runtime environment.
    @Sendable
    @inlinable
    public func createDeployment(_ input: CreateDeploymentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDeploymentResponse {
        try await self.client.execute(
            operation: "CreateDeployment", 
            path: "/applications/{applicationId}/deployments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates and starts a deployment to deploy an application into a runtime environment.
    ///
    /// Parameters:
    ///   - applicationId: The application identifier.
    ///   - applicationVersion: The version of the application to deploy.
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a deployment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    ///   - environmentId: The identifier of the runtime environment where you want to deploy this application.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDeployment(
        applicationId: String,
        applicationVersion: Int,
        clientToken: String? = CreateDeploymentRequest.idempotencyToken(),
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDeploymentResponse {
        let input = CreateDeploymentRequest(
            applicationId: applicationId, 
            applicationVersion: applicationVersion, 
            clientToken: clientToken, 
            environmentId: environmentId
        )
        return try await self.createDeployment(input, logger: logger)
    }

    /// Creates a runtime environment for a given runtime engine.
    @Sendable
    @inlinable
    public func createEnvironment(_ input: CreateEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEnvironmentResponse {
        try await self.client.execute(
            operation: "CreateEnvironment", 
            path: "/environments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a runtime environment for a given runtime engine.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create an environment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    ///   - description: The description of the runtime environment.
    ///   - engineType: The engine type for the runtime environment.
    ///   - engineVersion: The version of the engine type for the runtime environment.
    ///   - highAvailabilityConfig: The details of a high availability configuration for this runtime environment.
    ///   - instanceType: The type of instance for the runtime environment.
    ///   - kmsKeyId: The identifier of a customer managed key.
    ///   - name: The name of the runtime environment. Must be unique within the account.
    ///   - networkType: The network type required for the runtime environment.
    ///   - preferredMaintenanceWindow: Configures the maintenance window that you want for the runtime environment. The maintenance window must have the format ddd:hh24:mi-ddd:hh24:mi and must be less than 24 hours. The following two examples are valid maintenance windows: sun:23:45-mon:00:15 or sat:01:00-sat:03:00.  If you do not provide a value, a random system-generated value will be assigned.
    ///   - publiclyAccessible: Specifies whether the runtime environment is publicly accessible.
    ///   - securityGroupIds: The list of security groups for the VPC associated with this runtime environment.
    ///   - storageConfigurations: Optional. The storage configurations for this runtime environment.
    ///   - subnetIds: The list of subnets associated with the VPC for this runtime environment.
    ///   - tags: The tags for the runtime environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func createEnvironment(
        clientToken: String? = CreateEnvironmentRequest.idempotencyToken(),
        description: String? = nil,
        engineType: EngineType,
        engineVersion: String? = nil,
        highAvailabilityConfig: HighAvailabilityConfig? = nil,
        instanceType: String,
        kmsKeyId: String? = nil,
        name: String,
        networkType: NetworkType? = nil,
        preferredMaintenanceWindow: String? = nil,
        publiclyAccessible: Bool? = nil,
        securityGroupIds: [String]? = nil,
        storageConfigurations: [StorageConfiguration]? = nil,
        subnetIds: [String]? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEnvironmentResponse {
        let input = CreateEnvironmentRequest(
            clientToken: clientToken, 
            description: description, 
            engineType: engineType, 
            engineVersion: engineVersion, 
            highAvailabilityConfig: highAvailabilityConfig, 
            instanceType: instanceType, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            networkType: networkType, 
            preferredMaintenanceWindow: preferredMaintenanceWindow, 
            publiclyAccessible: publiclyAccessible, 
            securityGroupIds: securityGroupIds, 
            storageConfigurations: storageConfigurations, 
            subnetIds: subnetIds, 
            tags: tags
        )
        return try await self.createEnvironment(input, logger: logger)
    }

    /// Deletes a specific application. You cannot delete a running application.
    @Sendable
    @inlinable
    public func deleteApplication(_ input: DeleteApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteApplicationResponse {
        try await self.client.execute(
            operation: "DeleteApplication", 
            path: "/applications/{applicationId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specific application. You cannot delete a running application.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteApplication(
        applicationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteApplicationResponse {
        let input = DeleteApplicationRequest(
            applicationId: applicationId
        )
        return try await self.deleteApplication(input, logger: logger)
    }

    /// Deletes a specific application from the specific runtime environment where it was previously deployed. You cannot delete a runtime environment using DeleteEnvironment if any application has ever been deployed to it. This API removes the association of the application with the runtime environment so you can delete the environment smoothly.
    @Sendable
    @inlinable
    public func deleteApplicationFromEnvironment(_ input: DeleteApplicationFromEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteApplicationFromEnvironmentResponse {
        try await self.client.execute(
            operation: "DeleteApplicationFromEnvironment", 
            path: "/applications/{applicationId}/environment/{environmentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specific application from the specific runtime environment where it was previously deployed. You cannot delete a runtime environment using DeleteEnvironment if any application has ever been deployed to it. This API removes the association of the application with the runtime environment so you can delete the environment smoothly.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application you want to delete.
    ///   - environmentId: The unique identifier of the runtime environment where the application was previously deployed.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteApplicationFromEnvironment(
        applicationId: String,
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteApplicationFromEnvironmentResponse {
        let input = DeleteApplicationFromEnvironmentRequest(
            applicationId: applicationId, 
            environmentId: environmentId
        )
        return try await self.deleteApplicationFromEnvironment(input, logger: logger)
    }

    /// Deletes a specific runtime environment. The environment cannot contain deployed applications. If it does, you must delete those applications before you delete the environment.
    @Sendable
    @inlinable
    public func deleteEnvironment(_ input: DeleteEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEnvironmentResponse {
        try await self.client.execute(
            operation: "DeleteEnvironment", 
            path: "/environments/{environmentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specific runtime environment. The environment cannot contain deployed applications. If it does, you must delete those applications before you delete the environment.
    ///
    /// Parameters:
    ///   - environmentId: The unique identifier of the runtime environment you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteEnvironment(
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteEnvironmentResponse {
        let input = DeleteEnvironmentRequest(
            environmentId: environmentId
        )
        return try await self.deleteEnvironment(input, logger: logger)
    }

    /// Describes the details of a specific application.
    @Sendable
    @inlinable
    public func getApplication(_ input: GetApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetApplicationResponse {
        try await self.client.execute(
            operation: "GetApplication", 
            path: "/applications/{applicationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the details of a specific application.
    ///
    /// Parameters:
    ///   - applicationId: The identifier of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func getApplication(
        applicationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetApplicationResponse {
        let input = GetApplicationRequest(
            applicationId: applicationId
        )
        return try await self.getApplication(input, logger: logger)
    }

    /// Returns details about a specific version of a specific application.
    @Sendable
    @inlinable
    public func getApplicationVersion(_ input: GetApplicationVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetApplicationVersionResponse {
        try await self.client.execute(
            operation: "GetApplicationVersion", 
            path: "/applications/{applicationId}/versions/{applicationVersion}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns details about a specific version of a specific application.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - applicationVersion: The specific version of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func getApplicationVersion(
        applicationId: String,
        applicationVersion: Int,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetApplicationVersionResponse {
        let input = GetApplicationVersionRequest(
            applicationId: applicationId, 
            applicationVersion: applicationVersion
        )
        return try await self.getApplicationVersion(input, logger: logger)
    }

    /// Gets the details of a specific batch job execution for a specific application.
    @Sendable
    @inlinable
    public func getBatchJobExecution(_ input: GetBatchJobExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBatchJobExecutionResponse {
        try await self.client.execute(
            operation: "GetBatchJobExecution", 
            path: "/applications/{applicationId}/batch-job-executions/{executionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the details of a specific batch job execution for a specific application.
    ///
    /// Parameters:
    ///   - applicationId: The identifier of the application.
    ///   - executionId: The unique identifier of the batch job execution.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBatchJobExecution(
        applicationId: String,
        executionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBatchJobExecutionResponse {
        let input = GetBatchJobExecutionRequest(
            applicationId: applicationId, 
            executionId: executionId
        )
        return try await self.getBatchJobExecution(input, logger: logger)
    }

    /// Gets the details of a specific data set.
    @Sendable
    @inlinable
    public func getDataSetDetails(_ input: GetDataSetDetailsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataSetDetailsResponse {
        try await self.client.execute(
            operation: "GetDataSetDetails", 
            path: "/applications/{applicationId}/datasets/{dataSetName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the details of a specific data set.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application that this data set is associated with.
    ///   - dataSetName: The name of the data set.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataSetDetails(
        applicationId: String,
        dataSetName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataSetDetailsResponse {
        let input = GetDataSetDetailsRequest(
            applicationId: applicationId, 
            dataSetName: dataSetName
        )
        return try await self.getDataSetDetails(input, logger: logger)
    }

    /// Gets the status of a data set import task initiated with the CreateDataSetImportTask operation.
    @Sendable
    @inlinable
    public func getDataSetImportTask(_ input: GetDataSetImportTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataSetImportTaskResponse {
        try await self.client.execute(
            operation: "GetDataSetImportTask", 
            path: "/applications/{applicationId}/dataset-import-tasks/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the status of a data set import task initiated with the CreateDataSetImportTask operation.
    ///
    /// Parameters:
    ///   - applicationId: The application identifier.
    ///   - taskId: The task identifier returned by the CreateDataSetImportTask operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataSetImportTask(
        applicationId: String,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataSetImportTaskResponse {
        let input = GetDataSetImportTaskRequest(
            applicationId: applicationId, 
            taskId: taskId
        )
        return try await self.getDataSetImportTask(input, logger: logger)
    }

    /// Gets details of a specific deployment with a given deployment identifier.
    @Sendable
    @inlinable
    public func getDeployment(_ input: GetDeploymentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDeploymentResponse {
        try await self.client.execute(
            operation: "GetDeployment", 
            path: "/applications/{applicationId}/deployments/{deploymentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets details of a specific deployment with a given deployment identifier.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - deploymentId: The unique identifier for the deployment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDeployment(
        applicationId: String,
        deploymentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDeploymentResponse {
        let input = GetDeploymentRequest(
            applicationId: applicationId, 
            deploymentId: deploymentId
        )
        return try await self.getDeployment(input, logger: logger)
    }

    /// Describes a specific runtime environment.
    @Sendable
    @inlinable
    public func getEnvironment(_ input: GetEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEnvironmentResponse {
        try await self.client.execute(
            operation: "GetEnvironment", 
            path: "/environments/{environmentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a specific runtime environment.
    ///
    /// Parameters:
    ///   - environmentId: The unique identifier of the runtime environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEnvironment(
        environmentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEnvironmentResponse {
        let input = GetEnvironmentRequest(
            environmentId: environmentId
        )
        return try await self.getEnvironment(input, logger: logger)
    }

    /// Gets a single sign-on URL that can be used to connect to AWS Blu Insights.
    @Sendable
    @inlinable
    public func getSignedBluinsightsUrl(logger: Logger = AWSClient.loggingDisabled) async throws -> GetSignedBluinsightsUrlResponse {
        try await self.client.execute(
            operation: "GetSignedBluinsightsUrl", 
            path: "/signed-bi-url", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            logger: logger
        )
    }

    /// Returns a list of the application versions for a specific application.
    @Sendable
    @inlinable
    public func listApplicationVersions(_ input: ListApplicationVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListApplicationVersionsResponse {
        try await self.client.execute(
            operation: "ListApplicationVersions", 
            path: "/applications/{applicationId}/versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the application versions for a specific application.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - maxResults: The maximum number of application versions to return.
    ///   - nextToken: A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApplicationVersions(
        applicationId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListApplicationVersionsResponse {
        let input = ListApplicationVersionsRequest(
            applicationId: applicationId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listApplicationVersions(input, logger: logger)
    }

    /// Lists the applications associated with a specific Amazon Web Services account. You can provide the unique identifier of a specific runtime environment in a query parameter to see all applications associated with that environment.
    @Sendable
    @inlinable
    public func listApplications(_ input: ListApplicationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListApplicationsResponse {
        try await self.client.execute(
            operation: "ListApplications", 
            path: "/applications", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the applications associated with a specific Amazon Web Services account. You can provide the unique identifier of a specific runtime environment in a query parameter to see all applications associated with that environment.
    ///
    /// Parameters:
    ///   - environmentId: The unique identifier of the runtime environment where the applications are deployed.
    ///   - maxResults: The maximum number of applications to return.
    ///   - names: The names of the applications.
    ///   - nextToken: A pagination token to control the number of applications displayed in the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApplications(
        environmentId: String? = nil,
        maxResults: Int? = nil,
        names: [String]? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListApplicationsResponse {
        let input = ListApplicationsRequest(
            environmentId: environmentId, 
            maxResults: maxResults, 
            names: names, 
            nextToken: nextToken
        )
        return try await self.listApplications(input, logger: logger)
    }

    /// Lists all the available batch job definitions based on the batch job resources uploaded during the application creation. You can use the batch job definitions in the list to start a batch job.
    @Sendable
    @inlinable
    public func listBatchJobDefinitions(_ input: ListBatchJobDefinitionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBatchJobDefinitionsResponse {
        try await self.client.execute(
            operation: "ListBatchJobDefinitions", 
            path: "/applications/{applicationId}/batch-job-definitions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the available batch job definitions based on the batch job resources uploaded during the application creation. You can use the batch job definitions in the list to start a batch job.
    ///
    /// Parameters:
    ///   - applicationId: The identifier of the application.
    ///   - maxResults: The maximum number of batch job definitions to return.
    ///   - nextToken: A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
    ///   - prefix: If the batch job definition is a FileBatchJobDefinition, the prefix allows you to search on the file names of FileBatchJobDefinitions.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBatchJobDefinitions(
        applicationId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        prefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBatchJobDefinitionsResponse {
        let input = ListBatchJobDefinitionsRequest(
            applicationId: applicationId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            prefix: prefix
        )
        return try await self.listBatchJobDefinitions(input, logger: logger)
    }

    /// Lists historical, current, and scheduled batch job executions for a specific application.
    @Sendable
    @inlinable
    public func listBatchJobExecutions(_ input: ListBatchJobExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBatchJobExecutionsResponse {
        try await self.client.execute(
            operation: "ListBatchJobExecutions", 
            path: "/applications/{applicationId}/batch-job-executions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists historical, current, and scheduled batch job executions for a specific application.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - executionIds: The unique identifier of each batch job execution.
    ///   - jobName: The name of each batch job execution.
    ///   - maxResults: The maximum number of batch job executions to return.
    ///   - nextToken: A pagination token to control the number of batch job executions displayed in the list.
    ///   - startedAfter: The time after which the batch job executions started.
    ///   - startedBefore: The time before the batch job executions started.
    ///   - status: The status of the batch job executions.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBatchJobExecutions(
        applicationId: String,
        executionIds: [String]? = nil,
        jobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startedAfter: Date? = nil,
        startedBefore: Date? = nil,
        status: BatchJobExecutionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBatchJobExecutionsResponse {
        let input = ListBatchJobExecutionsRequest(
            applicationId: applicationId, 
            executionIds: executionIds, 
            jobName: jobName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            startedAfter: startedAfter, 
            startedBefore: startedBefore, 
            status: status
        )
        return try await self.listBatchJobExecutions(input, logger: logger)
    }

    /// Lists all the job steps for a JCL file to restart a batch job. This is only applicable for Micro Focus engine with versions 8.0.6 and above.
    @Sendable
    @inlinable
    public func listBatchJobRestartPoints(_ input: ListBatchJobRestartPointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBatchJobRestartPointsResponse {
        try await self.client.execute(
            operation: "ListBatchJobRestartPoints", 
            path: "/applications/{applicationId}/batch-job-executions/{executionId}/steps", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the job steps for a JCL file to restart a batch job. This is only applicable for Micro Focus engine with versions 8.0.6 and above.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - authSecretsManagerArn: The Amazon Web Services Secrets Manager containing user's credentials for authentication and authorization for List Batch Job Restart Points operation.
    ///   - executionId: The unique identifier of the batch job execution.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBatchJobRestartPoints(
        applicationId: String,
        authSecretsManagerArn: String? = nil,
        executionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBatchJobRestartPointsResponse {
        let input = ListBatchJobRestartPointsRequest(
            applicationId: applicationId, 
            authSecretsManagerArn: authSecretsManagerArn, 
            executionId: executionId
        )
        return try await self.listBatchJobRestartPoints(input, logger: logger)
    }

    /// Lists the data set imports for the specified application.
    @Sendable
    @inlinable
    public func listDataSetImportHistory(_ input: ListDataSetImportHistoryRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataSetImportHistoryResponse {
        try await self.client.execute(
            operation: "ListDataSetImportHistory", 
            path: "/applications/{applicationId}/dataset-import-tasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the data set imports for the specified application.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - maxResults: The maximum number of objects to return.
    ///   - nextToken: A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataSetImportHistory(
        applicationId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataSetImportHistoryResponse {
        let input = ListDataSetImportHistoryRequest(
            applicationId: applicationId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDataSetImportHistory(input, logger: logger)
    }

    /// Lists the data sets imported for a specific application. In Amazon Web Services Mainframe Modernization, data sets are associated with applications deployed on runtime environments. This is known as importing data sets. Currently, Amazon Web Services Mainframe Modernization can import data sets into catalogs using CreateDataSetImportTask.
    @Sendable
    @inlinable
    public func listDataSets(_ input: ListDataSetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataSetsResponse {
        try await self.client.execute(
            operation: "ListDataSets", 
            path: "/applications/{applicationId}/datasets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the data sets imported for a specific application. In Amazon Web Services Mainframe Modernization, data sets are associated with applications deployed on runtime environments. This is known as importing data sets. Currently, Amazon Web Services Mainframe Modernization can import data sets into catalogs using CreateDataSetImportTask.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application for which you want to list the associated data sets.
    ///   - maxResults: The maximum number of objects to return.
    ///   - nameFilter: Filter dataset name matching the specified pattern. Can use * and % as wild cards.
    ///   - nextToken: A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
    ///   - prefix: The prefix of the data set name, which you can use to filter the list of data sets.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataSets(
        applicationId: String,
        maxResults: Int? = nil,
        nameFilter: String? = nil,
        nextToken: String? = nil,
        prefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataSetsResponse {
        let input = ListDataSetsRequest(
            applicationId: applicationId, 
            maxResults: maxResults, 
            nameFilter: nameFilter, 
            nextToken: nextToken, 
            prefix: prefix
        )
        return try await self.listDataSets(input, logger: logger)
    }

    /// Returns a list of all deployments of a specific application. A deployment is a combination of a specific application and a specific version of that application. Each deployment is mapped to a particular application version.
    @Sendable
    @inlinable
    public func listDeployments(_ input: ListDeploymentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDeploymentsResponse {
        try await self.client.execute(
            operation: "ListDeployments", 
            path: "/applications/{applicationId}/deployments", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all deployments of a specific application. A deployment is a combination of a specific application and a specific version of that application. Each deployment is mapped to a particular application version.
    ///
    /// Parameters:
    ///   - applicationId: The application identifier.
    ///   - maxResults: The maximum number of objects to return.
    ///   - nextToken: A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDeployments(
        applicationId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDeploymentsResponse {
        let input = ListDeploymentsRequest(
            applicationId: applicationId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDeployments(input, logger: logger)
    }

    /// Lists the available engine versions.
    @Sendable
    @inlinable
    public func listEngineVersions(_ input: ListEngineVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEngineVersionsResponse {
        try await self.client.execute(
            operation: "ListEngineVersions", 
            path: "/engine-versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the available engine versions.
    ///
    /// Parameters:
    ///   - engineType: The type of target platform.
    ///   - maxResults: The maximum number of objects to return.
    ///   - nextToken: A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the  list, exclude this parameter.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEngineVersions(
        engineType: EngineType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEngineVersionsResponse {
        let input = ListEngineVersionsRequest(
            engineType: engineType, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listEngineVersions(input, logger: logger)
    }

    /// Lists the runtime environments.
    @Sendable
    @inlinable
    public func listEnvironments(_ input: ListEnvironmentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEnvironmentsResponse {
        try await self.client.execute(
            operation: "ListEnvironments", 
            path: "/environments", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the runtime environments.
    ///
    /// Parameters:
    ///   - engineType: The engine type for the runtime environment.
    ///   - maxResults: The maximum number of runtime environments to return.
    ///   - names: The names of the runtime environments. Must be unique within the account.
    ///   - nextToken: A pagination token to control the number of runtime environments displayed in the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEnvironments(
        engineType: EngineType? = nil,
        maxResults: Int? = nil,
        names: [String]? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEnvironmentsResponse {
        let input = ListEnvironmentsRequest(
            engineType: engineType, 
            maxResults: maxResults, 
            names: names, 
            nextToken: nextToken
        )
        return try await self.listEnvironments(input, logger: logger)
    }

    /// Lists the tags for the specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags for the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Starts an application that is currently stopped.
    @Sendable
    @inlinable
    public func startApplication(_ input: StartApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartApplicationResponse {
        try await self.client.execute(
            operation: "StartApplication", 
            path: "/applications/{applicationId}/start", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an application that is currently stopped.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application you want to start.
    ///   - logger: Logger use during operation
    @inlinable
    public func startApplication(
        applicationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartApplicationResponse {
        let input = StartApplicationRequest(
            applicationId: applicationId
        )
        return try await self.startApplication(input, logger: logger)
    }

    /// Starts a batch job and returns the unique identifier of this execution of the batch job. The associated application must be running in order to start the batch job.
    @Sendable
    @inlinable
    public func startBatchJob(_ input: StartBatchJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartBatchJobResponse {
        try await self.client.execute(
            operation: "StartBatchJob", 
            path: "/applications/{applicationId}/batch-job", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a batch job and returns the unique identifier of this execution of the batch job. The associated application must be running in order to start the batch job.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application associated with this batch job.
    ///   - authSecretsManagerArn: The Amazon Web Services Secrets Manager containing user's credentials for authentication and authorization for Start Batch Job execution operation.
    ///   - batchJobIdentifier: The unique identifier of the batch job.
    ///   - jobParams: The collection of batch job parameters. For details about limits for keys and values, see Coding variables in JCL.
    ///   - logger: Logger use during operation
    @inlinable
    public func startBatchJob(
        applicationId: String,
        authSecretsManagerArn: String? = nil,
        batchJobIdentifier: BatchJobIdentifier,
        jobParams: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartBatchJobResponse {
        let input = StartBatchJobRequest(
            applicationId: applicationId, 
            authSecretsManagerArn: authSecretsManagerArn, 
            batchJobIdentifier: batchJobIdentifier, 
            jobParams: jobParams
        )
        return try await self.startBatchJob(input, logger: logger)
    }

    /// Stops a running application.
    @Sendable
    @inlinable
    public func stopApplication(_ input: StopApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopApplicationResponse {
        try await self.client.execute(
            operation: "StopApplication", 
            path: "/applications/{applicationId}/stop", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a running application.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application you want to stop.
    ///   - forceStop: Stopping an application process can take a long time. Setting this parameter to true lets you force stop the application so you don't need to wait until the process finishes to apply another action on the application. The default value is false.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopApplication(
        applicationId: String,
        forceStop: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopApplicationResponse {
        let input = StopApplicationRequest(
            applicationId: applicationId, 
            forceStop: forceStop
        )
        return try await self.stopApplication(input, logger: logger)
    }

    /// Adds one or more tags to the specified resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds one or more tags to the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - tags: The tags to add to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes one or more tags from the specified resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes one or more tags from the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - tagKeys: The keys of the tags to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates an application and creates a new version.
    @Sendable
    @inlinable
    public func updateApplication(_ input: UpdateApplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateApplicationResponse {
        try await self.client.execute(
            operation: "UpdateApplication", 
            path: "/applications/{applicationId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an application and creates a new version.
    ///
    /// Parameters:
    ///   - applicationId: The unique identifier of the application you want to update.
    ///   - currentApplicationVersion: The current version of the application to update.
    ///   - definition: The application definition for this application. You can specify either inline JSON or an S3 bucket location.
    ///   - description: The description of the application to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateApplication(
        applicationId: String,
        currentApplicationVersion: Int,
        definition: Definition? = nil,
        description: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateApplicationResponse {
        let input = UpdateApplicationRequest(
            applicationId: applicationId, 
            currentApplicationVersion: currentApplicationVersion, 
            definition: definition, 
            description: description
        )
        return try await self.updateApplication(input, logger: logger)
    }

    /// Updates the configuration details for a specific runtime environment.
    @Sendable
    @inlinable
    public func updateEnvironment(_ input: UpdateEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateEnvironmentResponse {
        try await self.client.execute(
            operation: "UpdateEnvironment", 
            path: "/environments/{environmentId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration details for a specific runtime environment.
    ///
    /// Parameters:
    ///   - applyDuringMaintenanceWindow: Indicates whether to update the runtime environment during the maintenance window. The default is false. Currently, Amazon Web Services Mainframe Modernization accepts the engineVersion parameter only if applyDuringMaintenanceWindow is true. If any parameter other than engineVersion is provided in UpdateEnvironmentRequest, it will fail if applyDuringMaintenanceWindow is set to true.
    ///   - desiredCapacity: The desired capacity for the runtime environment to update. The minimum possible value is 0 and the maximum is 100.
    ///   - engineVersion: The version of the runtime engine for the runtime environment.
    ///   - environmentId: The unique identifier of the runtime environment that you want to update.
    ///   - forceUpdate: Forces the updates on the environment. This option is needed if the applications in the environment are not stopped or if there are ongoing application-related activities in the environment. If you use this option, be aware that it could lead to data corruption in the applications, and that you might need to perform repair and recovery procedures for the applications. This option is not needed if the attribute being updated is preferredMaintenanceWindow.
    ///   - instanceType: The instance type for the runtime environment to update.
    ///   - preferredMaintenanceWindow: Configures the maintenance window that you want for the runtime environment. The maintenance window must have the format ddd:hh24:mi-ddd:hh24:mi and must be less than 24 hours. The following two examples are valid maintenance windows: sun:23:45-mon:00:15 or sat:01:00-sat:03:00.  If you do not provide a value, a random system-generated value will be assigned.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateEnvironment(
        applyDuringMaintenanceWindow: Bool? = nil,
        desiredCapacity: Int? = nil,
        engineVersion: String? = nil,
        environmentId: String,
        forceUpdate: Bool? = nil,
        instanceType: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateEnvironmentResponse {
        let input = UpdateEnvironmentRequest(
            applyDuringMaintenanceWindow: applyDuringMaintenanceWindow, 
            desiredCapacity: desiredCapacity, 
            engineVersion: engineVersion, 
            environmentId: environmentId, 
            forceUpdate: forceUpdate, 
            instanceType: instanceType, 
            preferredMaintenanceWindow: preferredMaintenanceWindow
        )
        return try await self.updateEnvironment(input, logger: logger)
    }
}

extension M2 {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: M2, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension M2 {
    /// Return PaginatorSequence for operation ``listApplicationVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationVersionsPaginator(
        _ input: ListApplicationVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListApplicationVersionsRequest, ListApplicationVersionsResponse> {
        return .init(
            input: input,
            command: self.listApplicationVersions,
            inputKey: \ListApplicationVersionsRequest.nextToken,
            outputKey: \ListApplicationVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listApplicationVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - maxResults: The maximum number of application versions to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationVersionsPaginator(
        applicationId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListApplicationVersionsRequest, ListApplicationVersionsResponse> {
        let input = ListApplicationVersionsRequest(
            applicationId: applicationId, 
            maxResults: maxResults
        )
        return self.listApplicationVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listApplications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationsPaginator(
        _ input: ListApplicationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListApplicationsRequest, ListApplicationsResponse> {
        return .init(
            input: input,
            command: self.listApplications,
            inputKey: \ListApplicationsRequest.nextToken,
            outputKey: \ListApplicationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listApplications(_:logger:)``.
    ///
    /// - Parameters:
    ///   - environmentId: The unique identifier of the runtime environment where the applications are deployed.
    ///   - maxResults: The maximum number of applications to return.
    ///   - names: The names of the applications.
    ///   - logger: Logger used for logging
    @inlinable
    public func listApplicationsPaginator(
        environmentId: String? = nil,
        maxResults: Int? = nil,
        names: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListApplicationsRequest, ListApplicationsResponse> {
        let input = ListApplicationsRequest(
            environmentId: environmentId, 
            maxResults: maxResults, 
            names: names
        )
        return self.listApplicationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBatchJobDefinitions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBatchJobDefinitionsPaginator(
        _ input: ListBatchJobDefinitionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBatchJobDefinitionsRequest, ListBatchJobDefinitionsResponse> {
        return .init(
            input: input,
            command: self.listBatchJobDefinitions,
            inputKey: \ListBatchJobDefinitionsRequest.nextToken,
            outputKey: \ListBatchJobDefinitionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBatchJobDefinitions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationId: The identifier of the application.
    ///   - maxResults: The maximum number of batch job definitions to return.
    ///   - prefix: If the batch job definition is a FileBatchJobDefinition, the prefix allows you to search on the file names of FileBatchJobDefinitions.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBatchJobDefinitionsPaginator(
        applicationId: String,
        maxResults: Int? = nil,
        prefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBatchJobDefinitionsRequest, ListBatchJobDefinitionsResponse> {
        let input = ListBatchJobDefinitionsRequest(
            applicationId: applicationId, 
            maxResults: maxResults, 
            prefix: prefix
        )
        return self.listBatchJobDefinitionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBatchJobExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBatchJobExecutionsPaginator(
        _ input: ListBatchJobExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBatchJobExecutionsRequest, ListBatchJobExecutionsResponse> {
        return .init(
            input: input,
            command: self.listBatchJobExecutions,
            inputKey: \ListBatchJobExecutionsRequest.nextToken,
            outputKey: \ListBatchJobExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBatchJobExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - executionIds: The unique identifier of each batch job execution.
    ///   - jobName: The name of each batch job execution.
    ///   - maxResults: The maximum number of batch job executions to return.
    ///   - startedAfter: The time after which the batch job executions started.
    ///   - startedBefore: The time before the batch job executions started.
    ///   - status: The status of the batch job executions.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBatchJobExecutionsPaginator(
        applicationId: String,
        executionIds: [String]? = nil,
        jobName: String? = nil,
        maxResults: Int? = nil,
        startedAfter: Date? = nil,
        startedBefore: Date? = nil,
        status: BatchJobExecutionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBatchJobExecutionsRequest, ListBatchJobExecutionsResponse> {
        let input = ListBatchJobExecutionsRequest(
            applicationId: applicationId, 
            executionIds: executionIds, 
            jobName: jobName, 
            maxResults: maxResults, 
            startedAfter: startedAfter, 
            startedBefore: startedBefore, 
            status: status
        )
        return self.listBatchJobExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataSetImportHistory(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataSetImportHistoryPaginator(
        _ input: ListDataSetImportHistoryRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataSetImportHistoryRequest, ListDataSetImportHistoryResponse> {
        return .init(
            input: input,
            command: self.listDataSetImportHistory,
            inputKey: \ListDataSetImportHistoryRequest.nextToken,
            outputKey: \ListDataSetImportHistoryResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataSetImportHistory(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationId: The unique identifier of the application.
    ///   - maxResults: The maximum number of objects to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataSetImportHistoryPaginator(
        applicationId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataSetImportHistoryRequest, ListDataSetImportHistoryResponse> {
        let input = ListDataSetImportHistoryRequest(
            applicationId: applicationId, 
            maxResults: maxResults
        )
        return self.listDataSetImportHistoryPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataSetsPaginator(
        _ input: ListDataSetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataSetsRequest, ListDataSetsResponse> {
        return .init(
            input: input,
            command: self.listDataSets,
            inputKey: \ListDataSetsRequest.nextToken,
            outputKey: \ListDataSetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationId: The unique identifier of the application for which you want to list the associated data sets.
    ///   - maxResults: The maximum number of objects to return.
    ///   - nameFilter: Filter dataset name matching the specified pattern. Can use * and % as wild cards.
    ///   - prefix: The prefix of the data set name, which you can use to filter the list of data sets.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataSetsPaginator(
        applicationId: String,
        maxResults: Int? = nil,
        nameFilter: String? = nil,
        prefix: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataSetsRequest, ListDataSetsResponse> {
        let input = ListDataSetsRequest(
            applicationId: applicationId, 
            maxResults: maxResults, 
            nameFilter: nameFilter, 
            prefix: prefix
        )
        return self.listDataSetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDeployments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeploymentsPaginator(
        _ input: ListDeploymentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDeploymentsRequest, ListDeploymentsResponse> {
        return .init(
            input: input,
            command: self.listDeployments,
            inputKey: \ListDeploymentsRequest.nextToken,
            outputKey: \ListDeploymentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDeployments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - applicationId: The application identifier.
    ///   - maxResults: The maximum number of objects to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeploymentsPaginator(
        applicationId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDeploymentsRequest, ListDeploymentsResponse> {
        let input = ListDeploymentsRequest(
            applicationId: applicationId, 
            maxResults: maxResults
        )
        return self.listDeploymentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEngineVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEngineVersionsPaginator(
        _ input: ListEngineVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEngineVersionsRequest, ListEngineVersionsResponse> {
        return .init(
            input: input,
            command: self.listEngineVersions,
            inputKey: \ListEngineVersionsRequest.nextToken,
            outputKey: \ListEngineVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEngineVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - engineType: The type of target platform.
    ///   - maxResults: The maximum number of objects to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEngineVersionsPaginator(
        engineType: EngineType? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEngineVersionsRequest, ListEngineVersionsResponse> {
        let input = ListEngineVersionsRequest(
            engineType: engineType, 
            maxResults: maxResults
        )
        return self.listEngineVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEnvironmentsPaginator(
        _ input: ListEnvironmentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEnvironmentsRequest, ListEnvironmentsResponse> {
        return .init(
            input: input,
            command: self.listEnvironments,
            inputKey: \ListEnvironmentsRequest.nextToken,
            outputKey: \ListEnvironmentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - engineType: The engine type for the runtime environment.
    ///   - maxResults: The maximum number of runtime environments to return.
    ///   - names: The names of the runtime environments. Must be unique within the account.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEnvironmentsPaginator(
        engineType: EngineType? = nil,
        maxResults: Int? = nil,
        names: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEnvironmentsRequest, ListEnvironmentsResponse> {
        let input = ListEnvironmentsRequest(
            engineType: engineType, 
            maxResults: maxResults, 
            names: names
        )
        return self.listEnvironmentsPaginator(input, logger: logger)
    }
}

extension M2.ListApplicationVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListApplicationVersionsRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension M2.ListApplicationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListApplicationsRequest {
        return .init(
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            names: self.names,
            nextToken: token
        )
    }
}

extension M2.ListBatchJobDefinitionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListBatchJobDefinitionsRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token,
            prefix: self.prefix
        )
    }
}

extension M2.ListBatchJobExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListBatchJobExecutionsRequest {
        return .init(
            applicationId: self.applicationId,
            executionIds: self.executionIds,
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token,
            startedAfter: self.startedAfter,
            startedBefore: self.startedBefore,
            status: self.status
        )
    }
}

extension M2.ListDataSetImportHistoryRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListDataSetImportHistoryRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension M2.ListDataSetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListDataSetsRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nameFilter: self.nameFilter,
            nextToken: token,
            prefix: self.prefix
        )
    }
}

extension M2.ListDeploymentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListDeploymentsRequest {
        return .init(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension M2.ListEngineVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListEngineVersionsRequest {
        return .init(
            engineType: self.engineType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension M2.ListEnvironmentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> M2.ListEnvironmentsRequest {
        return .init(
            engineType: self.engineType,
            maxResults: self.maxResults,
            names: self.names,
            nextToken: token
        )
    }
}
