//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for CloudDirectory
public struct CloudDirectoryErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case batchWriteException = "BatchWriteException"
        case cannotListParentOfRootException = "CannotListParentOfRootException"
        case directoryAlreadyExistsException = "DirectoryAlreadyExistsException"
        case directoryDeletedException = "DirectoryDeletedException"
        case directoryNotDisabledException = "DirectoryNotDisabledException"
        case directoryNotEnabledException = "DirectoryNotEnabledException"
        case facetAlreadyExistsException = "FacetAlreadyExistsException"
        case facetInUseException = "FacetInUseException"
        case facetNotFoundException = "FacetNotFoundException"
        case facetValidationException = "FacetValidationException"
        case incompatibleSchemaException = "IncompatibleSchemaException"
        case indexedAttributeMissingException = "IndexedAttributeMissingException"
        case internalServiceException = "InternalServiceException"
        case invalidArnException = "InvalidArnException"
        case invalidAttachmentException = "InvalidAttachmentException"
        case invalidFacetUpdateException = "InvalidFacetUpdateException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case invalidRuleException = "InvalidRuleException"
        case invalidSchemaDocException = "InvalidSchemaDocException"
        case invalidTaggingRequestException = "InvalidTaggingRequestException"
        case limitExceededException = "LimitExceededException"
        case linkNameAlreadyInUseException = "LinkNameAlreadyInUseException"
        case notIndexException = "NotIndexException"
        case notNodeException = "NotNodeException"
        case notPolicyException = "NotPolicyException"
        case objectAlreadyDetachedException = "ObjectAlreadyDetachedException"
        case objectNotDetachedException = "ObjectNotDetachedException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case retryableConflictException = "RetryableConflictException"
        case schemaAlreadyExistsException = "SchemaAlreadyExistsException"
        case schemaAlreadyPublishedException = "SchemaAlreadyPublishedException"
        case stillContainsLinksException = "StillContainsLinksException"
        case unsupportedIndexTypeException = "UnsupportedIndexTypeException"
        case validationException = "ValidationException"
    }

    private var error: Code
    public var message: String?

    public init?(errorCode: String, message: String?) {
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.message = message
    }

    internal init(_ error: Code) {
        self.error = error
        self.message = nil
    }

    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    public static var batchWriteException: Self { .init(.batchWriteException) }
    public static var cannotListParentOfRootException: Self { .init(.cannotListParentOfRootException) }
    public static var directoryAlreadyExistsException: Self { .init(.directoryAlreadyExistsException) }
    public static var directoryDeletedException: Self { .init(.directoryDeletedException) }
    public static var directoryNotDisabledException: Self { .init(.directoryNotDisabledException) }
    public static var directoryNotEnabledException: Self { .init(.directoryNotEnabledException) }
    public static var facetAlreadyExistsException: Self { .init(.facetAlreadyExistsException) }
    public static var facetInUseException: Self { .init(.facetInUseException) }
    public static var facetNotFoundException: Self { .init(.facetNotFoundException) }
    public static var facetValidationException: Self { .init(.facetValidationException) }
    public static var incompatibleSchemaException: Self { .init(.incompatibleSchemaException) }
    public static var indexedAttributeMissingException: Self { .init(.indexedAttributeMissingException) }
    public static var internalServiceException: Self { .init(.internalServiceException) }
    public static var invalidArnException: Self { .init(.invalidArnException) }
    public static var invalidAttachmentException: Self { .init(.invalidAttachmentException) }
    public static var invalidFacetUpdateException: Self { .init(.invalidFacetUpdateException) }
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    public static var invalidRuleException: Self { .init(.invalidRuleException) }
    public static var invalidSchemaDocException: Self { .init(.invalidSchemaDocException) }
    public static var invalidTaggingRequestException: Self { .init(.invalidTaggingRequestException) }
    public static var limitExceededException: Self { .init(.limitExceededException) }
    public static var linkNameAlreadyInUseException: Self { .init(.linkNameAlreadyInUseException) }
    public static var notIndexException: Self { .init(.notIndexException) }
    public static var notNodeException: Self { .init(.notNodeException) }
    public static var notPolicyException: Self { .init(.notPolicyException) }
    public static var objectAlreadyDetachedException: Self { .init(.objectAlreadyDetachedException) }
    public static var objectNotDetachedException: Self { .init(.objectNotDetachedException) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    public static var retryableConflictException: Self { .init(.retryableConflictException) }
    public static var schemaAlreadyExistsException: Self { .init(.schemaAlreadyExistsException) }
    public static var schemaAlreadyPublishedException: Self { .init(.schemaAlreadyPublishedException) }
    public static var stillContainsLinksException: Self { .init(.stillContainsLinksException) }
    public static var unsupportedIndexTypeException: Self { .init(.unsupportedIndexTypeException) }
    public static var validationException: Self { .init(.validationException) }
}

extension CloudDirectoryErrorType: Equatable {
    public static func == (lhs: CloudDirectoryErrorType, rhs: CloudDirectoryErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CloudDirectoryErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
