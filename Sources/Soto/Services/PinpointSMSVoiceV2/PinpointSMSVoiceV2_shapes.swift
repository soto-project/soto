//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PinpointSMSVoiceV2 {
    // MARK: Enums

    public enum AccountAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountTier = "ACCOUNT_TIER"
        public var description: String { return self.rawValue }
    }

    public enum AccountLimitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationSets = "CONFIGURATION_SETS"
        case optOutLists = "OPT_OUT_LISTS"
        case phoneNumbers = "PHONE_NUMBERS"
        case pools = "POOLS"
        case registrations = "REGISTRATIONS"
        case registrationAttachments = "REGISTRATION_ATTACHMENTS"
        case senderIds = "SENDER_IDS"
        case verifiedDestinationNumbers = "VERIFIED_DESTINATION_NUMBERS"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case uploadComplete = "UPLOAD_COMPLETE"
        case uploadFailed = "UPLOAD_FAILED"
        case uploadInProgress = "UPLOAD_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentUploadErrorReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationSetFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case defaultMessageType = "default-message-type"
        case defaultSenderId = "default-sender-id"
        case eventDestinationName = "event-destination-name"
        case matchingEventTypes = "matching-event-types"
        public var description: String { return self.rawValue }
    }

    public enum DestinationCountryParameterKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inEntityId = "IN_ENTITY_ID"
        case inTemplateId = "IN_TEMPLATE_ID"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case textAll = "TEXT_ALL"
        case textBlocked = "TEXT_BLOCKED"
        case textCarrierBlocked = "TEXT_CARRIER_BLOCKED"
        case textCarrierUnreachable = "TEXT_CARRIER_UNREACHABLE"
        case textDelivered = "TEXT_DELIVERED"
        case textInvalid = "TEXT_INVALID"
        case textInvalidMessage = "TEXT_INVALID_MESSAGE"
        case textPending = "TEXT_PENDING"
        case textQueued = "TEXT_QUEUED"
        case textSent = "TEXT_SENT"
        case textSpam = "TEXT_SPAM"
        case textSuccessful = "TEXT_SUCCESSFUL"
        case textTtlExpired = "TEXT_TTL_EXPIRED"
        case textUnknown = "TEXT_UNKNOWN"
        case textUnreachable = "TEXT_UNREACHABLE"
        case voiceAll = "VOICE_ALL"
        case voiceAnswered = "VOICE_ANSWERED"
        case voiceBusy = "VOICE_BUSY"
        case voiceCompleted = "VOICE_COMPLETED"
        case voiceFailed = "VOICE_FAILED"
        case voiceInitiated = "VOICE_INITIATED"
        case voiceNoAnswer = "VOICE_NO_ANSWER"
        case voiceRinging = "VOICE_RINGING"
        case voiceTtlExpired = "VOICE_TTL_EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum FieldRequirement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditional = "CONDITIONAL"
        case optional = "OPTIONAL"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum FieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachment = "ATTACHMENT"
        case select = "SELECT"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum KeywordAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automaticResponse = "AUTOMATIC_RESPONSE"
        case optIn = "OPT_IN"
        case optOut = "OPT_OUT"
        public var description: String { return self.rawValue }
    }

    public enum KeywordFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case keywordAction = "keyword-action"
        public var description: String { return self.rawValue }
    }

    public enum LanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deDe = "DE_DE"
        case enGb = "EN_GB"
        case enUs = "EN_US"
        case es419 = "ES_419"
        case esEs = "ES_ES"
        case frCa = "FR_CA"
        case frFr = "FR_FR"
        case itIt = "IT_IT"
        case jaJp = "JA_JP"
        case koKr = "KO_KR"
        case ptBr = "PT_BR"
        case zhCn = "ZH_CN"
        case zhTw = "ZH_TW"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case promotional = "PROMOTIONAL"
        case transactional = "TRANSACTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum NumberCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sms = "SMS"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum NumberStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case associating = "ASSOCIATING"
        case deleted = "DELETED"
        case disassociating = "DISASSOCIATING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum NumberType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case longCode = "LONG_CODE"
        case shortCode = "SHORT_CODE"
        case simulator = "SIMULATOR"
        case tenDlc = "TEN_DLC"
        case tollFree = "TOLL_FREE"
        public var description: String { return self.rawValue }
    }

    public enum OptedOutFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case endUserOptedOut = "end-user-opted-out"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case isoCountryCode = "iso-country-code"
        case messageType = "message-type"
        case numberCapability = "number-capability"
        case numberType = "number-type"
        case optOutListName = "opt-out-list-name"
        case selfManagedOptOutsEnabled = "self-managed-opt-outs-enabled"
        case status = "status"
        case twoWayChannelArn = "two-way-channel-arn"
        case twoWayEnabled = "two-way-enabled"
        public var description: String { return self.rawValue }
    }

    public enum PoolFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case messageType = "message-type"
        case optOutListName = "opt-out-list-name"
        case selfManagedOptOutsEnabled = "self-managed-opt-outs-enabled"
        case sharedRoutesEnabled = "shared-routes-enabled"
        case status = "status"
        case twoWayChannelArn = "two-way-channel-arn"
        case twoWayEnabled = "two-way-enabled"
        public var description: String { return self.rawValue }
    }

    public enum PoolOriginationIdentitiesFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isoCountryCode = "iso-country-code"
        case numberCapability = "number-capability"
        public var description: String { return self.rawValue }
    }

    public enum PoolStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationAssociationBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associateAfterComplete = "ASSOCIATE_AFTER_COMPLETE"
        case associateBeforeSubmit = "ASSOCIATE_BEFORE_SUBMIT"
        case associateOnApproval = "ASSOCIATE_ON_APPROVAL"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationAssociationFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isoCountryCode = "iso-country-code"
        case resourceType = "resource-type"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationAttachmentFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachmentStatus = "attachment-status"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationDisassociationBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteRegistrationDisassociates = "DELETE_REGISTRATION_DISASSOCIATES"
        case disassociateAllAllowsDeleteRegistration = "DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION"
        case disassociateAllClosesRegistration = "DISASSOCIATE_ALL_CLOSES_REGISTRATION"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case registrationStatus = "registration-status"
        case registrationType = "registration-type"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closed = "CLOSED"
        case complete = "COMPLETE"
        case created = "CREATED"
        case deleted = "DELETED"
        case provisioning = "PROVISIONING"
        case requiresUpdates = "REQUIRES_UPDATES"
        case reviewing = "REVIEWING"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationTypeFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case supportedAssociationIsoCountryCode = "supported-association-iso-country-code"
        case supportedAssociationResourceType = "supported-association-resource-type"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationVersionFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case registrationVersionStatus = "registration-version-status"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case archived = "ARCHIVED"
        case denied = "DENIED"
        case discarded = "DISCARDED"
        case draft = "DRAFT"
        case reviewing = "REVIEWING"
        case revoked = "REVOKED"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum RequestableNumberType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case longCode = "LONG_CODE"
        case simulator = "SIMULATOR"
        case tenDlc = "TEN_DLC"
        case tollFree = "TOLL_FREE"
        public var description: String { return self.rawValue }
    }

    public enum SenderIdFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case isoCountryCode = "iso-country-code"
        case messageType = "message-type"
        case registered = "registered"
        case senderId = "sender-id"
        public var description: String { return self.rawValue }
    }

    public enum SpendLimitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case textMessageMonthlySpendLimit = "TEXT_MESSAGE_MONTHLY_SPEND_LIMIT"
        case voiceMessageMonthlySpendLimit = "VOICE_MESSAGE_MONTHLY_SPEND_LIMIT"
        public var description: String { return self.rawValue }
    }

    public enum VerificationChannel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum VerificationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pending = "PENDING"
        case verified = "VERIFIED"
        public var description: String { return self.rawValue }
    }

    public enum VerifiedDestinationNumberFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case status = "status"
        public var description: String { return self.rawValue }
    }

    public enum VoiceId: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amy = "AMY"
        case astrid = "ASTRID"
        case bianca = "BIANCA"
        case brian = "BRIAN"
        case camila = "CAMILA"
        case carla = "CARLA"
        case carmen = "CARMEN"
        case celine = "CELINE"
        case chantal = "CHANTAL"
        case conchita = "CONCHITA"
        case cristiano = "CRISTIANO"
        case dora = "DORA"
        case emma = "EMMA"
        case enrique = "ENRIQUE"
        case ewa = "EWA"
        case filiz = "FILIZ"
        case geraint = "GERAINT"
        case giorgio = "GIORGIO"
        case gwyneth = "GWYNETH"
        case hans = "HANS"
        case ines = "INES"
        case ivy = "IVY"
        case jacek = "JACEK"
        case jan = "JAN"
        case joanna = "JOANNA"
        case joey = "JOEY"
        case justin = "JUSTIN"
        case karl = "KARL"
        case kendra = "KENDRA"
        case kimberly = "KIMBERLY"
        case lea = "LEA"
        case liv = "LIV"
        case lotte = "LOTTE"
        case lucia = "LUCIA"
        case lupe = "LUPE"
        case mads = "MADS"
        case maja = "MAJA"
        case marlene = "MARLENE"
        case mathieu = "MATHIEU"
        case matthew = "MATTHEW"
        case maxim = "MAXIM"
        case mia = "MIA"
        case miguel = "MIGUEL"
        case mizuki = "MIZUKI"
        case naja = "NAJA"
        case nicole = "NICOLE"
        case penelope = "PENELOPE"
        case raveena = "RAVEENA"
        case ricardo = "RICARDO"
        case ruben = "RUBEN"
        case russell = "RUSSELL"
        case salli = "SALLI"
        case seoyeon = "SEOYEON"
        case takumi = "TAKUMI"
        case tatyana = "TATYANA"
        case vicki = "VICKI"
        case vitoria = "VITORIA"
        case zeina = "ZEINA"
        case zhiyu = "ZHIYU"
        public var description: String { return self.rawValue }
    }

    public enum VoiceMessageBodyTextType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ssml = "SSML"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountAttribute: AWSDecodableShape {
        /// The name of the account attribute.
        public let name: AccountAttributeName
        /// The value associated with the account attribute name.
        public let value: String

        public init(name: AccountAttributeName, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AccountLimit: AWSDecodableShape {
        /// The Amazon Web Services set limit for that resource type, in US dollars.
        public let max: Int64
        /// The name of the attribute to apply the account limit to.
        public let name: AccountLimitName
        /// The current amount that has been spent, in US dollars.
        public let used: Int64

        public init(max: Int64, name: AccountLimitName, used: Int64) {
            self.max = max
            self.name = name
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case name = "Name"
            case used = "Used"
        }
    }

    public struct AssociateOriginationIdentityRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the origination identity.
        public let isoCountryCode: String
        /// The origination identity to use, such as PhoneNumberId, PhoneNumberArn, SenderId, or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn, while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String
        /// The pool to update with the new Identity. This value can be either the PoolId or PoolArn, and you can find these values using DescribePools.
        public let poolId: String

        public init(clientToken: String? = AssociateOriginationIdentityRequest.idempotencyToken(), isoCountryCode: String, originationIdentity: String, poolId: String) {
            self.clientToken = clientToken
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case poolId = "PoolId"
        }
    }

    public struct AssociateOriginationIdentityResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The PhoneNumberId or SenderId of the origination identity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or SenderIdArn of the origination identity.
        public let originationIdentityArn: String?
        /// The Amazon Resource Name (ARN) of the pool that is now associated with the origination identity.
        public let poolArn: String?
        /// The PoolId of the pool that is now associated with the origination identity.
        public let poolId: String?

        public init(isoCountryCode: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct CloudWatchLogsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
        public let iamRoleArn: String
        /// The name of the Amazon CloudWatch log group that you want to record events in.
        public let logGroupArn: String

        public init(iamRoleArn: String, logGroupArn: String) {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 2048)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 20)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn:\\S+$")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, max: 2048)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, min: 20)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case logGroupArn = "LogGroupArn"
        }
    }

    public struct ConfigurationSetFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: ConfigurationSetFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: ConfigurationSetFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ConfigurationSetInformation: AWSDecodableShape {
        /// The Resource Name (ARN) of the ConfigurationSet.
        public let configurationSetArn: String
        /// The name of the ConfigurationSet.
        public let configurationSetName: String
        /// The time when the ConfigurationSet was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let defaultMessageType: MessageType?
        /// The default sender ID used by the ConfigurationSet.
        public let defaultSenderId: String?
        /// An array of EventDestination objects that describe any events to log and where to log them.
        public let eventDestinations: [EventDestination]

        public init(configurationSetArn: String, configurationSetName: String, createdTimestamp: Date, defaultMessageType: MessageType? = nil, defaultSenderId: String? = nil, eventDestinations: [EventDestination]) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case defaultMessageType = "DefaultMessageType"
            case defaultSenderId = "DefaultSenderId"
            case eventDestinations = "EventDestinations"
        }
    }

    public struct CreateConfigurationSetRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The name to use for the new configuration set.
        public let configurationSetName: String
        /// An array of key and value pair tags that's associated with the new configuration set.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateConfigurationSetRequest.idempotencyToken(), configurationSetName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.configurationSetName = configurationSetName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 64)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case configurationSetName = "ConfigurationSetName"
            case tags = "Tags"
        }
    }

    public struct CreateConfigurationSetResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created configuration set.
        public let configurationSetArn: String?
        /// The name of the new configuration set.
        public let configurationSetName: String?
        /// The time when the configuration set was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// An array of key and value pair tags that's associated with the configuration set.
        public let tags: [Tag]?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, createdTimestamp: Date? = nil, tags: [Tag]? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case tags = "Tags"
        }
    }

    public struct CreateEventDestinationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// An object that contains information about an event destination for logging to Amazon CloudWatch logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// Either the name of the configuration set or the configuration set ARN to apply event logging to. The ConfigurateSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String
        /// The name that identifies the event destination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log. If "ALL" is used, then Amazon Pinpoint logs every event type.  The TEXT_SENT event type is not supported.
        public let matchingEventTypes: [EventType]
        /// An object that contains information about an event destination for logging to Amazon SNS.
        public let snsDestination: SnsDestination?

        public init(clientToken: String? = CreateEventDestinationRequest.idempotencyToken(), cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, configurationSetName: String, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType], snsDestination: SnsDestination? = nil) {
            self.clientToken = clientToken
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.configurationSetName = configurationSetName
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.cloudWatchLogsDestination?.validate(name: "\(name).cloudWatchLogsDestination")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.kinesisFirehoseDestination?.validate(name: "\(name).kinesisFirehoseDestination")
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, max: 25)
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, min: 1)
            try self.snsDestination?.validate(name: "\(name).snsDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case configurationSetName = "ConfigurationSetName"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct CreateEventDestinationResult: AWSDecodableShape {
        /// The ARN of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The details of the destination where events are logged.
        public let eventDestination: EventDestination?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct CreateOptOutListRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The name of the new OptOutList.
        public let optOutListName: String
        /// An array of tags (key and value pairs) to associate with the new OptOutList.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateOptOutListRequest.idempotencyToken(), optOutListName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.optOutListName = optOutListName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 64)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case optOutListName = "OptOutListName"
            case tags = "Tags"
        }
    }

    public struct CreateOptOutListResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) for the OptOutList.
        public let optOutListArn: String?
        /// The name of the new OptOutList.
        public let optOutListName: String?
        /// An array of tags (key and value pairs) associated with the new OptOutList.
        public let tags: [Tag]?

        public init(createdTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil, tags: [Tag]? = nil) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
            case tags = "Tags"
        }
    }

    public struct CreatePoolRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the pool can't be deleted. You can change this value using the UpdatePool action.
        public let deletionProtectionEnabled: Bool?
        /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the new pool.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String
        /// An array of tags (key and value pairs) associated with the pool.
        public let tags: [Tag]?

        public init(clientToken: String? = CreatePoolRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageType: MessageType, originationIdentity: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.originationIdentity = originationIdentity
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case originationIdentity = "OriginationIdentity"
            case tags = "Tags"
        }
    }

    public struct CreatePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool?
        /// The type of message for the pool to use.
        public let messageType: MessageType?
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String?
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String?
        /// The unique identifier for the pool.
        public let poolId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool.   CREATING: The pool is currently being created and isn't yet available for use.   ACTIVE: The pool is active and available for use.   DELETING: The pool is being deleted.
        public let status: PoolStatus?
        /// An array of tags (key and value pairs) associated with the pool.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, tags: [Tag]? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.tags = tags
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case tags = "Tags"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct CreateRegistrationAssociationRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        public let resourceId: String

        public init(registrationId: String, resourceId: String) {
            self.registrationId = registrationId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
            case resourceId = "ResourceId"
        }
    }

    public struct CreateRegistrationAssociationResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The phone number associated with the registration in E.164 format.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
        public let resourceArn: String
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        public let resourceId: String
        /// The registration type or origination identity type.
        public let resourceType: String

        public init(isoCountryCode: String? = nil, phoneNumber: String? = nil, registrationArn: String, registrationId: String, registrationType: String, resourceArn: String, resourceId: String, resourceType: String) {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationType = registrationType
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case phoneNumber = "PhoneNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationType = "RegistrationType"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateRegistrationAttachmentRequest: AWSEncodableShape {
        /// The registration file to upload. The maximum file size is 1MiB and valid file extensions are PDF, JPEG and PNG.
        public let attachmentBody: AWSBase64Data?
        /// A URL to the required registration file.  For example, you can provide the S3 object URL.
        public let attachmentUrl: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// An array of tags (key and value pairs) to associate with the registration attachment.
        public let tags: [Tag]?

        public init(attachmentBody: AWSBase64Data? = nil, attachmentUrl: String? = nil, clientToken: String? = CreateRegistrationAttachmentRequest.idempotencyToken(), tags: [Tag]? = nil) {
            self.attachmentBody = attachmentBody
            self.attachmentUrl = attachmentUrl
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentBody, name: "attachmentBody", parent: name, max: 1572864)
            try self.validate(self.attachmentBody, name: "attachmentBody", parent: name, min: 1)
            try self.validate(self.attachmentUrl, name: "attachmentUrl", parent: name, max: 2048)
            try self.validate(self.attachmentUrl, name: "attachmentUrl", parent: name, min: 1)
            try self.validate(self.attachmentUrl, name: "attachmentUrl", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentBody = "AttachmentBody"
            case attachmentUrl = "AttachmentUrl"
            case clientToken = "ClientToken"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationAttachmentResult: AWSDecodableShape {
        /// The status of the registration attachment.     UPLOAD_IN_PROGRESS The attachment is being uploaded.    UPLOAD_COMPLETE The attachment has been uploaded.    UPLOAD_FAILED The attachment failed to uploaded.    DELETED The attachment has been deleted..
        public let attachmentStatus: AttachmentStatus
        /// The time when the registration attachment was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) for the registration attachment.
        public let registrationAttachmentArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String
        /// An array of tags (key and value pairs) to associate with the registration attachment.
        public let tags: [Tag]?

        public init(attachmentStatus: AttachmentStatus, createdTimestamp: Date, registrationAttachmentArn: String, registrationAttachmentId: String, tags: [Tag]? = nil) {
            self.attachmentStatus = attachmentStatus
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentStatus = "AttachmentStatus"
            case createdTimestamp = "CreatedTimestamp"
            case registrationAttachmentArn = "RegistrationAttachmentArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The type of registration form to create. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// An array of tags (key and value pairs) to associate with the registration.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateRegistrationRequest.idempotencyToken(), registrationType: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.registrationType = registrationType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.registrationType, name: "registrationType", parent: name, max: 64)
            try self.validate(self.registrationType, name: "registrationType", parent: name, min: 1)
            try self.validate(self.registrationType, name: "registrationType", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case registrationType = "RegistrationType"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationResult: AWSDecodableShape {
        /// Metadata about a given registration which is specific to that registration type.
        public let additionalAttributes: [String: String]?
        /// The time when the registration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The current version number of the registration.
        public let currentVersionNumber: Int64
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    CREATED: Your registration is created but not submitted.    SUBMITTED: Your registration has been submitted and is awaiting review.    REVIEWING: Your registration has been accepted and is being reviewed.    PROVISIONING: Your registration has been approved and your origination identity is being created.    COMPLETE: Your registration has been approved and and your origination identity has been created.    REQUIRES_UPDATES: You must fix your registration and resubmit it.    CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.    DELETED: The registration has been deleted.
        public let registrationStatus: RegistrationStatus
        /// The type of registration form to create. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// An array of tags (key and value pairs) to associate with the registration.
        public let tags: [Tag]?

        public init(additionalAttributes: [String: String]? = nil, createdTimestamp: Date, currentVersionNumber: Int64, registrationArn: String, registrationId: String, registrationStatus: RegistrationStatus, registrationType: String, tags: [Tag]? = nil) {
            self.additionalAttributes = additionalAttributes
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "AdditionalAttributes"
            case createdTimestamp = "CreatedTimestamp"
            case currentVersionNumber = "CurrentVersionNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationStatus = "RegistrationStatus"
            case registrationType = "RegistrationType"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationVersionRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct CreateRegistrationVersionResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    DRAFT: The initial status of a registration version after it’s created.    SUBMITTED: Your registration has been submitted.    REVIEWING: Your registration has been accepted and is being reviewed.    APPROVED: Your registration has been approved.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DENIED: You must fix your registration and resubmit it.    REVOKED: Your previously approved registration has been revoked.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// A RegistrationVersionStatusHistory object that contains timestamps for the registration.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The new version number of the registration.
        public let versionNumber: Int64

        public init(registrationArn: String, registrationId: String, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct CreateVerifiedDestinationNumberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// An array of tags (key and value pairs) to associate with the destination number.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateVerifiedDestinationNumberRequest.idempotencyToken(), destinationPhoneNumber: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.destinationPhoneNumber = destinationPhoneNumber
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case tags = "Tags"
        }
    }

    public struct CreateVerifiedDestinationNumberResult: AWSDecodableShape {
        /// The time when the verified phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// The status of the verified destination phone number.    PENDING: The phone number hasn't been verified yet.    VERIFIED: The phone number is verified and can receive messages.
        public let status: VerificationStatus
        /// An array of tags (key and value pairs) to associate with the destination number.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        public init(createdTimestamp: Date, destinationPhoneNumber: String, status: VerificationStatus, tags: [Tag]? = nil, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.tags = tags
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case status = "Status"
            case tags = "Tags"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct DeleteConfigurationSetRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set ARN that you want to delete. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteConfigurationSetResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted configuration set.
        public let configurationSetArn: String?
        /// The name of the deleted configuration set.
        public let configurationSetName: String?
        /// The time that the deleted configuration set was created in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The default message type of the configuration set that was deleted.
        public let defaultMessageType: MessageType?
        /// The default Sender ID of the configuration set that was deleted.
        public let defaultSenderId: String?
        /// An array of any EventDestination objects that were associated with the deleted configuration set.
        public let eventDestinations: [EventDestination]?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, createdTimestamp: Date? = nil, defaultMessageType: MessageType? = nil, defaultSenderId: String? = nil, eventDestinations: [EventDestination]? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case defaultMessageType = "DefaultMessageType"
            case defaultSenderId = "DefaultSenderId"
            case eventDestinations = "EventDestinations"
        }
    }

    public struct DeleteDefaultMessageTypeRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default message type from. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteDefaultMessageTypeResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The current message type for the configuration set.
        public let messageType: MessageType?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, messageType: MessageType? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct DeleteDefaultSenderIdRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default sender ID from. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteDefaultSenderIdResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The current sender ID for the configuration set.
        public let senderId: String?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, senderId: String? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct DeleteEventDestinationRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set's Amazon Resource Name (ARN) to remove the event destination from. The ConfigurateSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String
        /// The name of the event destination to delete.
        public let eventDestinationName: String

        public init(configurationSetName: String, eventDestinationName: String) {
            self.configurationSetName = configurationSetName
            self.eventDestinationName = eventDestinationName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case eventDestinationName = "EventDestinationName"
        }
    }

    public struct DeleteEventDestinationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set the event destination was deleted from.
        public let configurationSetName: String?
        /// The event destination object that was deleted.
        public let eventDestination: EventDestination?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct DeleteKeywordRequest: AWSEncodableShape {
        /// The keyword to delete.
        public let keyword: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, PoolId or PoolArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn and DescribePools to find the values of PoolId and PoolArn.
        public let originationIdentity: String

        public init(keyword: String, originationIdentity: String) {
            self.keyword = keyword
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct DeleteKeywordResult: AWSDecodableShape {
        /// The keyword that was deleted.
        public let keyword: String?
        /// The action that was associated with the deleted keyword.
        public let keywordAction: KeywordAction?
        /// The message that was associated with the deleted keyword.
        public let keywordMessage: String?
        /// The PhoneNumberId or PoolId that the keyword was associated with.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that the keyword was associated with.
        public let originationIdentityArn: String?

        public init(keyword: String? = nil, keywordAction: KeywordAction? = nil, keywordMessage: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct DeleteOptOutListRequest: AWSEncodableShape {
        /// The OptOutListName or OptOutListArn of the OptOutList to delete. You can use DescribeOptOutLists to find the values for OptOutListName and OptOutListArn.
        public let optOutListName: String

        public init(optOutListName: String) {
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptOutListResult: AWSDecodableShape {
        /// The time when the OptOutList was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the OptOutList that was removed.
        public let optOutListArn: String?
        /// The name of the OptOutList that was removed.
        public let optOutListName: String?

        public init(createdTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptedOutNumberRequest: AWSEncodableShape {
        /// The phone number, in E.164 format, to remove from the OptOutList.
        public let optedOutNumber: String
        /// The OptOutListName or OptOutListArn to remove the phone number from.
        public let optOutListName: String

        public init(optedOutNumber: String, optOutListName: String) {
            self.optedOutNumber = optedOutNumber
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, max: 20)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, min: 1)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optedOutNumber = "OptedOutNumber"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptedOutNumberResult: AWSDecodableShape {
        /// This is true if it was the end user who requested their phone number be removed.
        public let endUserOptedOut: Bool?
        /// The phone number that was removed from the OptOutList.
        public let optedOutNumber: String?
        /// The time that the number was removed at, in UNIX epoch time format.
        public let optedOutTimestamp: Date?
        /// The OptOutListArn that the phone number was removed from.
        public let optOutListArn: String?
        /// The OptOutListName that the phone number was removed from.
        public let optOutListName: String?

        public init(endUserOptedOut: Bool? = nil, optedOutNumber: String? = nil, optedOutTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeletePoolRequest: AWSEncodableShape {
        /// The PoolId or PoolArn of the pool to delete. You can use DescribePools to find the values for PoolId and PoolArn .
        public let poolId: String

        public init(poolId: String) {
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case poolId = "PoolId"
        }
    }

    public struct DeletePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The message type that was associated with the deleted pool.
        public let messageType: MessageType?
        /// The name of the OptOutList that was associated with the deleted pool.
        public let optOutListName: String?
        /// The Amazon Resource Name (ARN) of the pool that was deleted.
        public let poolArn: String?
        /// The PoolId of the pool that was deleted.
        public let poolId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool.   CREATING: The pool is currently being created and isn't yet available for use.   ACTIVE: The pool is active and available for use.   DELETING: The pool is being deleted.
        public let status: PoolStatus?
        /// The Amazon Resource Name (ARN) of the TwoWayChannel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct DeleteRegistrationAttachmentRequest: AWSEncodableShape {
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String

        public init(registrationAttachmentId: String) {
            self.registrationAttachmentId = registrationAttachmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, max: 256)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, min: 1)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationAttachmentId = "RegistrationAttachmentId"
        }
    }

    public struct DeleteRegistrationAttachmentResult: AWSDecodableShape {
        /// The status of the registration attachment.     UPLOAD_IN_PROGRESS The attachment is being uploaded.    UPLOAD_COMPLETE The attachment has been uploaded.    UPLOAD_FAILED The attachment failed to uploaded.    DELETED The attachment has been deleted..
        public let attachmentStatus: AttachmentStatus
        /// The error message if the upload failed.
        public let attachmentUploadErrorReason: AttachmentUploadErrorReason?
        /// The time when the registration attachment was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) for the registration attachment.
        public let registrationAttachmentArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String

        public init(attachmentStatus: AttachmentStatus, attachmentUploadErrorReason: AttachmentUploadErrorReason? = nil, createdTimestamp: Date, registrationAttachmentArn: String, registrationAttachmentId: String) {
            self.attachmentStatus = attachmentStatus
            self.attachmentUploadErrorReason = attachmentUploadErrorReason
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentStatus = "AttachmentStatus"
            case attachmentUploadErrorReason = "AttachmentUploadErrorReason"
            case createdTimestamp = "CreatedTimestamp"
            case registrationAttachmentArn = "RegistrationAttachmentArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
        }
    }

    public struct DeleteRegistrationFieldValueRequest: AWSEncodableShape {
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The unique identifier for the registration.
        public let registrationId: String

        public init(fieldPath: String, registrationId: String) {
            self.fieldPath = fieldPath
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, max: 100)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, min: 1)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationId = "RegistrationId"
        }
    }

    public struct DeleteRegistrationFieldValueResult: AWSDecodableShape {
        /// The path to the registration form field.
        public let fieldPath: String
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?
        /// The version number of the registration.
        public let versionNumber: Int64

        public init(fieldPath: String, registrationArn: String, registrationAttachmentId: String? = nil, registrationId: String, selectChoices: [String]? = nil, textValue: String? = nil, versionNumber: Int64) {
            self.fieldPath = fieldPath
            self.registrationArn = registrationArn
            self.registrationAttachmentId = registrationAttachmentId
            self.registrationId = registrationId
            self.selectChoices = selectChoices
            self.textValue = textValue
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationArn = "RegistrationArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case registrationId = "RegistrationId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DeleteRegistrationRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct DeleteRegistrationResult: AWSDecodableShape {
        /// Metadata about a given registration which is specific to that registration type.
        public let additionalAttributes: [String: String]?
        /// The version number of the registration that was approved.
        public let approvedVersionNumber: Int64?
        /// The time when the registration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The current version number of the registration.
        public let currentVersionNumber: Int64
        /// The latest version number of the registration that was denied.
        public let latestDeniedVersionNumber: Int64?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    CREATED: Your registration is created but not submitted.    SUBMITTED: Your registration has been submitted and is awaiting review.    REVIEWING: Your registration has been accepted and is being reviewed.    PROVISIONING: Your registration has been approved and your origination identity is being created.    COMPLETE: Your registration has been approved and and your origination identity has been created.    REQUIRES_UPDATES: You must fix your registration and resubmit it.    CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.    DELETED: The registration has been deleted.
        public let registrationStatus: RegistrationStatus
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        public init(additionalAttributes: [String: String]? = nil, approvedVersionNumber: Int64? = nil, createdTimestamp: Date, currentVersionNumber: Int64, latestDeniedVersionNumber: Int64? = nil, registrationArn: String, registrationId: String, registrationStatus: RegistrationStatus, registrationType: String) {
            self.additionalAttributes = additionalAttributes
            self.approvedVersionNumber = approvedVersionNumber
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.latestDeniedVersionNumber = latestDeniedVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "AdditionalAttributes"
            case approvedVersionNumber = "ApprovedVersionNumber"
            case createdTimestamp = "CreatedTimestamp"
            case currentVersionNumber = "CurrentVersionNumber"
            case latestDeniedVersionNumber = "LatestDeniedVersionNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationStatus = "RegistrationStatus"
            case registrationType = "RegistrationType"
        }
    }

    public struct DeleteTextMessageSpendLimitOverrideRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteTextMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit, in US dollars.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct DeleteVerifiedDestinationNumberRequest: AWSEncodableShape {
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        public init(verifiedDestinationNumberId: String) {
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, max: 256)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, min: 1)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct DeleteVerifiedDestinationNumberResult: AWSDecodableShape {
        /// The time when the destination phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        public init(createdTimestamp: Date, destinationPhoneNumber: String, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct DeleteVoiceMessageSpendLimitOverrideRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteVoiceMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit, in US dollars.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct DescribeAccountAttributesRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountAttributesResult: AWSDecodableShape {
        /// An array of AccountAttributes objects.
        public let accountAttributes: [AccountAttribute]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        public init(accountAttributes: [AccountAttribute]? = nil, nextToken: String? = nil) {
            self.accountAttributes = accountAttributes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accountAttributes = "AccountAttributes"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountLimitsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountLimitsResult: AWSDecodableShape {
        /// An array of AccountLimit objects that show the current spend limits.
        public let accountLimits: [AccountLimit]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        public init(accountLimits: [AccountLimit]? = nil, nextToken: String? = nil) {
            self.accountLimits = accountLimits
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accountLimits = "AccountLimits"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationSetsRequest: AWSEncodableShape {
        /// An array of strings. Each element can be either a ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetNames: [String]?
        /// An array of filters to apply to the results that are returned.
        public let filters: [ConfigurationSetFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(configurationSetNames: [String]? = nil, filters: [ConfigurationSetFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationSetNames = configurationSetNames
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configurationSetNames?.forEach {
                try validate($0, name: "configurationSetNames[]", parent: name, max: 256)
                try validate($0, name: "configurationSetNames[]", parent: name, min: 1)
                try validate($0, name: "configurationSetNames[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.configurationSetNames, name: "configurationSetNames", parent: name, max: 5)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetNames = "ConfigurationSetNames"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationSetsResult: AWSDecodableShape {
        /// An array of ConfigurationSets objects.
        public let configurationSets: [ConfigurationSetInformation]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        public init(configurationSets: [ConfigurationSetInformation]? = nil, nextToken: String? = nil) {
            self.configurationSets = configurationSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSets = "ConfigurationSets"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeKeywordsRequest: AWSEncodableShape {
        /// An array of keyword filters to filter the results.
        public let filters: [KeywordFilter]?
        /// An array of keywords to search for.
        public let keywords: [String]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String

        public init(filters: [KeywordFilter]? = nil, keywords: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, originationIdentity: String) {
            self.filters = filters
            self.keywords = keywords
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.keywords?.forEach {
                try validate($0, name: "keywords[]", parent: name, max: 30)
                try validate($0, name: "keywords[]", parent: name, min: 1)
                try validate($0, name: "keywords[]", parent: name, pattern: "^[ \\S]+$")
            }
            try self.validate(self.keywords, name: "keywords", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case keywords = "Keywords"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct DescribeKeywordsResult: AWSDecodableShape {
        /// An array of KeywordInformation objects that contain the results.
        public let keywords: [KeywordInformation]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// The PhoneNumberId or PoolId that is associated with the OriginationIdentity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that is associated with the OriginationIdentity.
        public let originationIdentityArn: String?

        public init(keywords: [KeywordInformation]? = nil, nextToken: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keywords = keywords
            self.nextToken = nextToken
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keywords = "Keywords"
            case nextToken = "NextToken"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct DescribeOptOutListsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The OptOutLists to show the details of. This is an array of strings that can be either the OptOutListName or OptOutListArn.
        public let optOutListNames: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, optOutListNames: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.optOutListNames = optOutListNames
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.optOutListNames?.forEach {
                try validate($0, name: "optOutListNames[]", parent: name, max: 256)
                try validate($0, name: "optOutListNames[]", parent: name, min: 1)
                try validate($0, name: "optOutListNames[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.optOutListNames, name: "optOutListNames", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case optOutListNames = "OptOutListNames"
        }
    }

    public struct DescribeOptOutListsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of OptOutListInformation objects that contain the details for the requested OptOutLists.
        public let optOutLists: [OptOutListInformation]?

        public init(nextToken: String? = nil, optOutLists: [OptOutListInformation]? = nil) {
            self.nextToken = nextToken
            self.optOutLists = optOutLists
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case optOutLists = "OptOutLists"
        }
    }

    public struct DescribeOptedOutNumbersRequest: AWSEncodableShape {
        /// An array of OptedOutFilter objects to filter the results on.
        public let filters: [OptedOutFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of phone numbers to search for in the OptOutList.
        public let optedOutNumbers: [String]?
        /// The OptOutListName or OptOutListArn of the OptOutList. You can use DescribeOptOutLists to find the values for OptOutListName and OptOutListArn.
        public let optOutListName: String

        public init(filters: [OptedOutFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, optedOutNumbers: [String]? = nil, optOutListName: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.optedOutNumbers = optedOutNumbers
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.optedOutNumbers?.forEach {
                try validate($0, name: "optedOutNumbers[]", parent: name, max: 20)
                try validate($0, name: "optedOutNumbers[]", parent: name, min: 1)
                try validate($0, name: "optedOutNumbers[]", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            }
            try self.validate(self.optedOutNumbers, name: "optedOutNumbers", parent: name, max: 5)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case optedOutNumbers = "OptedOutNumbers"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DescribeOptedOutNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of OptedOutNumbersInformation objects that provide information about the requested OptedOutNumbers.
        public let optedOutNumbers: [OptedOutNumberInformation]?
        /// The Amazon Resource Name (ARN) of the OptOutList.
        public let optOutListArn: String?
        /// The name of the OptOutList.
        public let optOutListName: String?

        public init(nextToken: String? = nil, optedOutNumbers: [OptedOutNumberInformation]? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.nextToken = nextToken
            self.optedOutNumbers = optedOutNumbers
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case optedOutNumbers = "OptedOutNumbers"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DescribePhoneNumbersRequest: AWSEncodableShape {
        /// An array of PhoneNumberFilter objects to filter the results.
        public let filters: [PhoneNumberFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier of phone numbers to find information about. This is an array of strings that can be either the PhoneNumberId or PhoneNumberArn.
        public let phoneNumberIds: [String]?

        public init(filters: [PhoneNumberFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, phoneNumberIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberIds = phoneNumberIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.phoneNumberIds?.forEach {
                try validate($0, name: "phoneNumberIds[]", parent: name, max: 256)
                try validate($0, name: "phoneNumberIds[]", parent: name, min: 1)
                try validate($0, name: "phoneNumberIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.phoneNumberIds, name: "phoneNumberIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case phoneNumberIds = "PhoneNumberIds"
        }
    }

    public struct DescribePhoneNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of PhoneNumberInformation objects that contain the details for the requested phone numbers.
        public let phoneNumbers: [PhoneNumberInformation]?

        public init(nextToken: String? = nil, phoneNumbers: [PhoneNumberInformation]? = nil) {
            self.nextToken = nextToken
            self.phoneNumbers = phoneNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case phoneNumbers = "PhoneNumbers"
        }
    }

    public struct DescribePoolsRequest: AWSEncodableShape {
        /// An array of PoolFilter objects to filter the results.
        public let filters: [PoolFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier of pools to find. This is an array of strings that can be either the PoolId or PoolArn.
        public let poolIds: [String]?

        public init(filters: [PoolFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, poolIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.poolIds = poolIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.poolIds?.forEach {
                try validate($0, name: "poolIds[]", parent: name, max: 256)
                try validate($0, name: "poolIds[]", parent: name, min: 1)
                try validate($0, name: "poolIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.poolIds, name: "poolIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case poolIds = "PoolIds"
        }
    }

    public struct DescribePoolsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of PoolInformation objects that contain the details for the requested pools.
        public let pools: [PoolInformation]?

        public init(nextToken: String? = nil, pools: [PoolInformation]? = nil) {
            self.nextToken = nextToken
            self.pools = pools
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pools = "Pools"
        }
    }

    public struct DescribeRegistrationAttachmentsRequest: AWSEncodableShape {
        /// An array of RegistrationAttachmentFilter objects to filter the results.
        public let filters: [RegistrationAttachmentFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier of registration attachments to find. This is an array of RegistrationAttachmentId.
        public let registrationAttachmentIds: [String]?

        public init(filters: [RegistrationAttachmentFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationAttachmentIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationAttachmentIds = registrationAttachmentIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.registrationAttachmentIds?.forEach {
                try validate($0, name: "registrationAttachmentIds[]", parent: name, max: 256)
                try validate($0, name: "registrationAttachmentIds[]", parent: name, min: 1)
                try validate($0, name: "registrationAttachmentIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.registrationAttachmentIds, name: "registrationAttachmentIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationAttachmentIds = "RegistrationAttachmentIds"
        }
    }

    public struct DescribeRegistrationAttachmentsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of RegistrationAttachments objects that contain the details for the requested registration attachments.
        public let registrationAttachments: [RegistrationAttachmentsInformation]

        public init(nextToken: String? = nil, registrationAttachments: [RegistrationAttachmentsInformation]) {
            self.nextToken = nextToken
            self.registrationAttachments = registrationAttachments
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationAttachments = "RegistrationAttachments"
        }
    }

    public struct DescribeRegistrationFieldDefinitionsRequest: AWSEncodableShape {
        /// An array of paths to the registration form field.
        public let fieldPaths: [String]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// The path to the section of the registration.
        public let sectionPath: String?

        public init(fieldPaths: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationType: String, sectionPath: String? = nil) {
            self.fieldPaths = fieldPaths
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationType = registrationType
            self.sectionPath = sectionPath
        }

        public func validate(name: String) throws {
            try self.fieldPaths?.forEach {
                try validate($0, name: "fieldPaths[]", parent: name, max: 100)
                try validate($0, name: "fieldPaths[]", parent: name, min: 1)
                try validate($0, name: "fieldPaths[]", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            }
            try self.validate(self.fieldPaths, name: "fieldPaths", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationType, name: "registrationType", parent: name, max: 64)
            try self.validate(self.registrationType, name: "registrationType", parent: name, min: 1)
            try self.validate(self.registrationType, name: "registrationType", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, max: 100)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, min: 1)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, pattern: "^[A-Za-z0-9_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPaths = "FieldPaths"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationType = "RegistrationType"
            case sectionPath = "SectionPath"
        }
    }

    public struct DescribeRegistrationFieldDefinitionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of RegistrationFieldDefinitions objects that contain the details for the requested fields.
        public let registrationFieldDefinitions: [RegistrationFieldDefinition]
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        public init(nextToken: String? = nil, registrationFieldDefinitions: [RegistrationFieldDefinition], registrationType: String) {
            self.nextToken = nextToken
            self.registrationFieldDefinitions = registrationFieldDefinitions
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationFieldDefinitions = "RegistrationFieldDefinitions"
            case registrationType = "RegistrationType"
        }
    }

    public struct DescribeRegistrationFieldValuesRequest: AWSEncodableShape {
        /// An array of paths to the registration form field.
        public let fieldPaths: [String]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The path to the section of the registration.
        public let sectionPath: String?
        /// The version number of the registration.
        public let versionNumber: Int64?

        public init(fieldPaths: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationId: String, sectionPath: String? = nil, versionNumber: Int64? = nil) {
            self.fieldPaths = fieldPaths
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationId = registrationId
            self.sectionPath = sectionPath
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.fieldPaths?.forEach {
                try validate($0, name: "fieldPaths[]", parent: name, max: 100)
                try validate($0, name: "fieldPaths[]", parent: name, min: 1)
                try validate($0, name: "fieldPaths[]", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            }
            try self.validate(self.fieldPaths, name: "fieldPaths", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, max: 100)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, min: 1)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, max: 100000)
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPaths = "FieldPaths"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationId = "RegistrationId"
            case sectionPath = "SectionPath"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DescribeRegistrationFieldValuesResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// An array of RegistrationFieldValues objects that contain the values for the requested registration.
        public let registrationFieldValues: [RegistrationFieldValueInformation]
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The current version of the registration.
        public let versionNumber: Int64

        public init(nextToken: String? = nil, registrationArn: String, registrationFieldValues: [RegistrationFieldValueInformation], registrationId: String, versionNumber: Int64) {
            self.nextToken = nextToken
            self.registrationArn = registrationArn
            self.registrationFieldValues = registrationFieldValues
            self.registrationId = registrationId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationArn = "RegistrationArn"
            case registrationFieldValues = "RegistrationFieldValues"
            case registrationId = "RegistrationId"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DescribeRegistrationSectionDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// An array of paths for the registration form section.
        public let sectionPaths: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, registrationType: String, sectionPaths: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationType = registrationType
            self.sectionPaths = sectionPaths
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationType, name: "registrationType", parent: name, max: 64)
            try self.validate(self.registrationType, name: "registrationType", parent: name, min: 1)
            try self.validate(self.registrationType, name: "registrationType", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.sectionPaths?.forEach {
                try validate($0, name: "sectionPaths[]", parent: name, max: 100)
                try validate($0, name: "sectionPaths[]", parent: name, min: 1)
                try validate($0, name: "sectionPaths[]", parent: name, pattern: "^[A-Za-z0-9_]+$")
            }
            try self.validate(self.sectionPaths, name: "sectionPaths", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationType = "RegistrationType"
            case sectionPaths = "SectionPaths"
        }
    }

    public struct DescribeRegistrationSectionDefinitionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of  RegistrationSectionDefinition objects.
        public let registrationSectionDefinitions: [RegistrationSectionDefinition]
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        public init(nextToken: String? = nil, registrationSectionDefinitions: [RegistrationSectionDefinition], registrationType: String) {
            self.nextToken = nextToken
            self.registrationSectionDefinitions = registrationSectionDefinitions
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationSectionDefinitions = "RegistrationSectionDefinitions"
            case registrationType = "RegistrationType"
        }
    }

    public struct DescribeRegistrationTypeDefinitionsRequest: AWSEncodableShape {
        /// An array of RegistrationFilter objects to filter the results.
        public let filters: [RegistrationTypeFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationTypes: [String]?

        public init(filters: [RegistrationTypeFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationTypes: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationTypes = registrationTypes
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.registrationTypes?.forEach {
                try validate($0, name: "registrationTypes[]", parent: name, max: 64)
                try validate($0, name: "registrationTypes[]", parent: name, min: 1)
                try validate($0, name: "registrationTypes[]", parent: name, pattern: "^[A-Za-z0-9_]+$")
            }
            try self.validate(self.registrationTypes, name: "registrationTypes", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationTypes = "RegistrationTypes"
        }
    }

    public struct DescribeRegistrationTypeDefinitionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationTypeDefinitions: [RegistrationTypeDefinition]

        public init(nextToken: String? = nil, registrationTypeDefinitions: [RegistrationTypeDefinition]) {
            self.nextToken = nextToken
            self.registrationTypeDefinitions = registrationTypeDefinitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationTypeDefinitions = "RegistrationTypeDefinitions"
        }
    }

    public struct DescribeRegistrationVersionsRequest: AWSEncodableShape {
        /// An array of RegistrationVersionFilter objects to filter the results.
        public let filters: [RegistrationVersionFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of registration version numbers.
        public let versionNumbers: [Int64]?

        public init(filters: [RegistrationVersionFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationId: String, versionNumbers: [Int64]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationId = registrationId
            self.versionNumbers = versionNumbers
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.versionNumbers?.forEach {
                try validate($0, name: "versionNumbers[]", parent: name, max: 100000)
                try validate($0, name: "versionNumbers[]", parent: name, min: 1)
            }
            try self.validate(self.versionNumbers, name: "versionNumbers", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationId = "RegistrationId"
            case versionNumbers = "VersionNumbers"
        }
    }

    public struct DescribeRegistrationVersionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of RegistrationVersions objects.
        public let registrationVersions: [RegistrationVersionInformation]

        public init(nextToken: String? = nil, registrationArn: String, registrationId: String, registrationVersions: [RegistrationVersionInformation]) {
            self.nextToken = nextToken
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersions = registrationVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersions = "RegistrationVersions"
        }
    }

    public struct DescribeRegistrationsRequest: AWSEncodableShape {
        /// An array of RegistrationFilter objects to filter the results.
        public let filters: [RegistrationFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of unique identifiers for each registration.
        public let registrationIds: [String]?

        public init(filters: [RegistrationFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationIds = registrationIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.registrationIds?.forEach {
                try validate($0, name: "registrationIds[]", parent: name, max: 256)
                try validate($0, name: "registrationIds[]", parent: name, min: 1)
                try validate($0, name: "registrationIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.registrationIds, name: "registrationIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationIds = "RegistrationIds"
        }
    }

    public struct DescribeRegistrationsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of RegistrationInformation objects.
        public let registrations: [RegistrationInformation]

        public init(nextToken: String? = nil, registrations: [RegistrationInformation]) {
            self.nextToken = nextToken
            self.registrations = registrations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrations = "Registrations"
        }
    }

    public struct DescribeSenderIdsRequest: AWSEncodableShape {
        /// An array of SenderIdFilter objects to filter the results.
        public let filters: [SenderIdFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of SenderIdAndCountry objects to search for.
        public let senderIds: [SenderIdAndCountry]?

        public init(filters: [SenderIdFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, senderIds: [SenderIdAndCountry]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.senderIds = senderIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.senderIds?.forEach {
                try $0.validate(name: "\(name).senderIds[]")
            }
            try self.validate(self.senderIds, name: "senderIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case senderIds = "SenderIds"
        }
    }

    public struct DescribeSenderIdsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of SernderIdInformation objects that contain the details for the requested SenderIds.
        public let senderIds: [SenderIdInformation]?

        public init(nextToken: String? = nil, senderIds: [SenderIdInformation]? = nil) {
            self.nextToken = nextToken
            self.senderIds = senderIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case senderIds = "SenderIds"
        }
    }

    public struct DescribeSpendLimitsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeSpendLimitsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of SpendLimit objects that contain the details for the requested spend limits.
        public let spendLimits: [SpendLimit]?

        public init(nextToken: String? = nil, spendLimits: [SpendLimit]? = nil) {
            self.nextToken = nextToken
            self.spendLimits = spendLimits
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case spendLimits = "SpendLimits"
        }
    }

    public struct DescribeVerifiedDestinationNumbersRequest: AWSEncodableShape {
        /// An array of verified destination phone number, in E.164 format.
        public let destinationPhoneNumbers: [String]?
        /// An array of VerifiedDestinationNumberFilter objects to filter the results.
        public let filters: [VerifiedDestinationNumberFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of VerifiedDestinationNumberid to retreive.
        public let verifiedDestinationNumberIds: [String]?

        public init(destinationPhoneNumbers: [String]? = nil, filters: [VerifiedDestinationNumberFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, verifiedDestinationNumberIds: [String]? = nil) {
            self.destinationPhoneNumbers = destinationPhoneNumbers
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.verifiedDestinationNumberIds = verifiedDestinationNumberIds
        }

        public func validate(name: String) throws {
            try self.destinationPhoneNumbers?.forEach {
                try validate($0, name: "destinationPhoneNumbers[]", parent: name, max: 20)
                try validate($0, name: "destinationPhoneNumbers[]", parent: name, min: 1)
                try validate($0, name: "destinationPhoneNumbers[]", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            }
            try self.validate(self.destinationPhoneNumbers, name: "destinationPhoneNumbers", parent: name, max: 5)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.verifiedDestinationNumberIds?.forEach {
                try validate($0, name: "verifiedDestinationNumberIds[]", parent: name, max: 256)
                try validate($0, name: "verifiedDestinationNumberIds[]", parent: name, min: 1)
                try validate($0, name: "verifiedDestinationNumberIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.verifiedDestinationNumberIds, name: "verifiedDestinationNumberIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPhoneNumbers = "DestinationPhoneNumbers"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case verifiedDestinationNumberIds = "VerifiedDestinationNumberIds"
        }
    }

    public struct DescribeVerifiedDestinationNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of VerifiedDestinationNumberInformation objects
        public let verifiedDestinationNumbers: [VerifiedDestinationNumberInformation]

        public init(nextToken: String? = nil, verifiedDestinationNumbers: [VerifiedDestinationNumberInformation]) {
            self.nextToken = nextToken
            self.verifiedDestinationNumbers = verifiedDestinationNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case verifiedDestinationNumbers = "VerifiedDestinationNumbers"
        }
    }

    public struct DisassociateOriginationIdentityRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers find the values for PhoneNumberId and PhoneNumberArn, or use DescribeSenderIds to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String
        /// The unique identifier for the pool to disassociate with the origination identity. This value can be either the PoolId or PoolArn.
        public let poolId: String

        public init(clientToken: String? = DisassociateOriginationIdentityRequest.idempotencyToken(), isoCountryCode: String, originationIdentity: String, poolId: String) {
            self.clientToken = clientToken
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case poolId = "PoolId"
        }
    }

    public struct DisassociateOriginationIdentityResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The PhoneNumberId or SenderId of the origination identity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or SenderIdArn of the origination identity.
        public let originationIdentityArn: String?
        /// The Amazon Resource Name (ARN) of the pool.
        public let poolArn: String?
        /// The PoolId of the pool no longer associated with the origination identity.
        public let poolId: String?

        public init(isoCountryCode: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct DiscardRegistrationVersionRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct DiscardRegistrationVersionResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration version.    DRAFT: The initial status of a registration version after it’s created.    SUBMITTED: Your registration has been submitted.    REVIEWING: Your registration has been accepted and is being reviewed.    APPROVED: Your registration has been approved.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DENIED: You must fix your registration and resubmit it.    REVOKED: Your previously approved registration has been revoked.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The version number of the registration.
        public let versionNumber: Int64

        public init(registrationArn: String, registrationId: String, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct EventDestination: AWSDecodableShape {
        /// An object that contains information about an event destination that sends logging events to Amazon CloudWatch logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// When set to true events will be logged.
        public let enabled: Bool
        /// The name of the EventDestination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log.  The TEXT_SENT event type is not supported.
        public let matchingEventTypes: [EventType]
        /// An object that contains information about an event destination that sends logging events to Amazon SNS.
        public let snsDestination: SnsDestination?

        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, enabled: Bool, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType], snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case enabled = "Enabled"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct KeywordFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: KeywordFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: KeywordFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct KeywordInformation: AWSDecodableShape {
        /// The keyword as a string.
        public let keyword: String
        /// The action to perform for the keyword.
        public let keywordAction: KeywordAction
        /// A custom message that can be used with the keyword.
        public let keywordMessage: String

        public init(keyword: String, keywordAction: KeywordAction, keywordMessage: String) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
        }
    }

    public struct KinesisFirehoseDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let deliveryStreamArn: String
        /// The ARN of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon Firehose destination.
        public let iamRoleArn: String

        public init(deliveryStreamArn: String, iamRoleArn: String) {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, max: 2048)
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, min: 20)
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, pattern: "^arn:\\S+$")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 2048)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 20)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStreamArn = "DeliveryStreamArn"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct ListPoolOriginationIdentitiesRequest: AWSEncodableShape {
        /// An array of PoolOriginationIdentitiesFilter objects to filter the results..
        public let filters: [PoolOriginationIdentitiesFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the pool. This value can be either the PoolId or PoolArn.
        public let poolId: String

        public init(filters: [PoolOriginationIdentitiesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, poolId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case poolId = "PoolId"
        }
    }

    public struct ListPoolOriginationIdentitiesResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of any OriginationIdentityMetadata objects.
        public let originationIdentities: [OriginationIdentityMetadata]?
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String?
        /// The unique PoolId of the pool.
        public let poolId: String?

        public init(nextToken: String? = nil, originationIdentities: [OriginationIdentityMetadata]? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.nextToken = nextToken
            self.originationIdentities = originationIdentities
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case originationIdentities = "OriginationIdentities"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct ListRegistrationAssociationsRequest: AWSEncodableShape {
        /// An array of RegistrationAssociationFilter to apply to the results that are returned.
        public let filters: [RegistrationAssociationFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the registration.
        public let registrationId: String

        public init(filters: [RegistrationAssociationFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationId = "RegistrationId"
        }
    }

    public struct ListRegistrationAssociationsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// An array of RegistrationAssociationMetadata objects.
        public let registrationAssociations: [RegistrationAssociationMetadata]
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        public init(nextToken: String? = nil, registrationArn: String, registrationAssociations: [RegistrationAssociationMetadata], registrationId: String, registrationType: String) {
            self.nextToken = nextToken
            self.registrationArn = registrationArn
            self.registrationAssociations = registrationAssociations
            self.registrationId = registrationId
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationArn = "RegistrationArn"
            case registrationAssociations = "RegistrationAssociations"
            case registrationId = "RegistrationId"
            case registrationType = "RegistrationType"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to query for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// The ARN of the resource.
        public let resourceArn: String?
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]?

        public init(resourceArn: String? = nil, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct OptOutListInformation: AWSDecodableShape {
        /// The time when the OutOutList was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) of the OptOutList.
        public let optOutListArn: String
        /// The name of the OptOutList.
        public let optOutListName: String

        public init(createdTimestamp: Date, optOutListArn: String, optOutListName: String) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct OptedOutFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: OptedOutFilterName
        /// An array of values to filter for.
        public let values: [String]

        public init(name: OptedOutFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct OptedOutNumberInformation: AWSDecodableShape {
        /// This is set to true if it was the end recipient that opted out.
        public let endUserOptedOut: Bool
        /// The phone number that is opted out.
        public let optedOutNumber: String
        /// The time that the op tout occurred, in UNIX epoch time format.
        public let optedOutTimestamp: Date

        public init(endUserOptedOut: Bool, optedOutNumber: String, optedOutTimestamp: Date) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
        }
    }

    public struct OriginationIdentityMetadata: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        public let numberCapabilities: [NumberCapability]
        /// The unique identifier of the origination identity.
        public let originationIdentity: String
        /// The Amazon Resource Name (ARN) associated with the origination identity.
        public let originationIdentityArn: String
        /// The phone number in E.164 format.
        public let phoneNumber: String?

        public init(isoCountryCode: String, numberCapabilities: [NumberCapability], originationIdentity: String, originationIdentityArn: String, phoneNumber: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.numberCapabilities = numberCapabilities
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.phoneNumber = phoneNumber
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case numberCapabilities = "NumberCapabilities"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct PhoneNumberFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PhoneNumberFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: PhoneNumberFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PhoneNumberInformation: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The price, in US dollars, to lease the phone number.
        public let monthlyLeasingPrice: String
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        public let numberCapabilities: [NumberCapability]
        /// The type of phone number.
        public let numberType: NumberType
        /// The name of the OptOutList associated with the phone number.
        public let optOutListName: String
        /// The phone number in E.164 format.
        public let phoneNumber: String
        /// The Amazon Resource Name (ARN) associated with the phone number.
        public let phoneNumberArn: String
        /// The unique identifier for the phone number.
        public let phoneNumberId: String?
        /// The unique identifier of the pool associated with the phone number.
        public let poolId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// When set to false an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out request. For more information see Self-managed opt-outs
        public let selfManagedOptOutsEnabled: Bool
        /// The current status of the phone number.
        public let status: NumberStatus
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        public let twoWayEnabled: Bool

        public init(createdTimestamp: Date, deletionProtectionEnabled: Bool, isoCountryCode: String, messageType: MessageType, monthlyLeasingPrice: String, numberCapabilities: [NumberCapability], numberType: NumberType, optOutListName: String, phoneNumber: String, phoneNumberArn: String, phoneNumberId: String? = nil, poolId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool, status: NumberStatus, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case poolId = "PoolId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct PoolFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PoolFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: PoolFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PoolInformation: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String
        /// The unique identifier for the pool.
        public let poolId: String
        /// When set to false, an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests. For more information see Self-managed opt-outs
        public let selfManagedOptOutsEnabled: Bool
        /// Allows you to enable shared routes on your pool. By default, this is set to False. If you set this value to True, your messages are sent using phone numbers or sender IDs (depending on the country) that are shared with other Amazon Pinpoint users. In some countries, such as the United States, senders aren't allowed to use shared routes and must use a dedicated phone number or short code.
        public let sharedRoutesEnabled: Bool
        /// The current status of the pool.
        public let status: PoolStatus
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        public let twoWayEnabled: Bool

        public init(createdTimestamp: Date, deletionProtectionEnabled: Bool, messageType: MessageType, optOutListName: String, poolArn: String, poolId: String, selfManagedOptOutsEnabled: Bool, sharedRoutesEnabled: Bool, status: PoolStatus, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct PoolOriginationIdentitiesFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PoolOriginationIdentitiesFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: PoolOriginationIdentitiesFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PutKeywordRequest: AWSEncodableShape {
        /// The new keyword to add.
        public let keyword: String
        /// The action to perform for the new keyword when it is received.   AUTOMATIC_RESPONSE: A message is sent to the recipient.   OPT_OUT: Keeps the recipient from receiving future messages.   OPT_IN: The recipient wants to receive future messages.
        public let keywordAction: KeywordAction?
        /// The message associated with the keyword.
        public let keywordMessage: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers get the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String

        public init(keyword: String, keywordAction: KeywordAction? = nil, keywordMessage: String, originationIdentity: String) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, max: 1600)
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, min: 1)
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct PutKeywordResult: AWSDecodableShape {
        /// The keyword that was added.
        public let keyword: String?
        /// The action to perform when the keyword is used.
        public let keywordAction: KeywordAction?
        /// The message associated with the keyword.
        public let keywordMessage: String?
        /// The PhoneNumberId or PoolId that the keyword was associated with.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that the keyword was associated with.
        public let originationIdentityArn: String?

        public init(keyword: String? = nil, keywordAction: KeywordAction? = nil, keywordMessage: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct PutOptedOutNumberRequest: AWSEncodableShape {
        /// The phone number to add to the OptOutList in E.164 format.
        public let optedOutNumber: String
        /// The OptOutListName or OptOutListArn to add the phone number to.
        public let optOutListName: String

        public init(optedOutNumber: String, optOutListName: String) {
            self.optedOutNumber = optedOutNumber
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, max: 20)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, min: 1)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optedOutNumber = "OptedOutNumber"
            case optOutListName = "OptOutListName"
        }
    }

    public struct PutOptedOutNumberResult: AWSDecodableShape {
        /// This is true if it was the end user who requested their phone number be removed.
        public let endUserOptedOut: Bool?
        /// The phone number that was added to the OptOutList.
        public let optedOutNumber: String?
        /// The time that the phone number was added to the OptOutList, in UNIX epoch time format.
        public let optedOutTimestamp: Date?
        /// The OptOutListArn that the phone number was removed from.
        public let optOutListArn: String?
        /// The OptOutListName that the phone number was removed from.
        public let optOutListName: String?

        public init(endUserOptedOut: Bool? = nil, optedOutNumber: String? = nil, optedOutTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct PutRegistrationFieldValueRequest: AWSEncodableShape {
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?

        public init(fieldPath: String, registrationAttachmentId: String? = nil, registrationId: String, selectChoices: [String]? = nil, textValue: String? = nil) {
            self.fieldPath = fieldPath
            self.registrationAttachmentId = registrationAttachmentId
            self.registrationId = registrationId
            self.selectChoices = selectChoices
            self.textValue = textValue
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, max: 100)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, min: 1)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, max: 256)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, min: 1)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.selectChoices?.forEach {
                try validate($0, name: "selectChoices[]", parent: name, max: 256)
                try validate($0, name: "selectChoices[]", parent: name, min: 1)
            }
            try self.validate(self.selectChoices, name: "selectChoices", parent: name, max: 100)
            try self.validate(self.textValue, name: "textValue", parent: name, max: 2048)
            try self.validate(self.textValue, name: "textValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case registrationId = "RegistrationId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
        }
    }

    public struct PutRegistrationFieldValueResult: AWSDecodableShape {
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?
        /// The version number of the registration.
        public let versionNumber: Int64

        public init(fieldPath: String, registrationArn: String, registrationAttachmentId: String? = nil, registrationId: String, selectChoices: [String]? = nil, textValue: String? = nil, versionNumber: Int64) {
            self.fieldPath = fieldPath
            self.registrationArn = registrationArn
            self.registrationAttachmentId = registrationAttachmentId
            self.registrationId = registrationId
            self.selectChoices = selectChoices
            self.textValue = textValue
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationArn = "RegistrationArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case registrationId = "RegistrationId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
            case versionNumber = "VersionNumber"
        }
    }

    public struct RegistrationAssociationFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationAssociationFilterName
        /// An array of values to filter for.
        public let values: [String]

        public init(name: RegistrationAssociationFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationAssociationMetadata: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The phone number associated with the registration in E.164 format.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
        public let resourceArn: String
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        public let resourceId: String
        /// The origination identity type.
        public let resourceType: String

        public init(isoCountryCode: String? = nil, phoneNumber: String? = nil, resourceArn: String, resourceId: String, resourceType: String) {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case phoneNumber = "PhoneNumber"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RegistrationAttachmentFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationAttachmentFilterName
        /// An array of values to filter on.
        public let values: [String]

        public init(name: RegistrationAttachmentFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationAttachmentsInformation: AWSDecodableShape {
        /// The status of the registration attachment.     UPLOAD_IN_PROGRESS The attachment is being uploaded.    UPLOAD_COMPLETE The attachment has been uploaded.    UPLOAD_FAILED The attachment failed to uploaded.    DELETED The attachment has been deleted..
        public let attachmentStatus: AttachmentStatus
        /// A description of why the upload didn't successfully complete.
        public let attachmentUploadErrorReason: AttachmentUploadErrorReason?
        /// The time when the registration attachment was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) for the registration attachment.
        public let registrationAttachmentArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String

        public init(attachmentStatus: AttachmentStatus, attachmentUploadErrorReason: AttachmentUploadErrorReason? = nil, createdTimestamp: Date, registrationAttachmentArn: String, registrationAttachmentId: String) {
            self.attachmentStatus = attachmentStatus
            self.attachmentUploadErrorReason = attachmentUploadErrorReason
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentStatus = "AttachmentStatus"
            case attachmentUploadErrorReason = "AttachmentUploadErrorReason"
            case createdTimestamp = "CreatedTimestamp"
            case registrationAttachmentArn = "RegistrationAttachmentArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
        }
    }

    public struct RegistrationDeniedReasonInformation: AWSDecodableShape {
        /// The link to the document.
        public let documentationLink: String?
        /// The title of the document.
        public let documentationTitle: String?
        /// A long description of the rejection reason.
        public let longDescription: String?
        /// The reason a registration was rejected.
        public let reason: String
        /// A short description of the rejection reason.
        public let shortDescription: String

        public init(documentationLink: String? = nil, documentationTitle: String? = nil, longDescription: String? = nil, reason: String, shortDescription: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.reason = reason
            self.shortDescription = shortDescription
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case longDescription = "LongDescription"
            case reason = "Reason"
            case shortDescription = "ShortDescription"
        }
    }

    public struct RegistrationFieldDefinition: AWSDecodableShape {
        /// An array of RegistrationFieldDisplayHints objects for the field.
        public let displayHints: RegistrationFieldDisplayHints
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// Specifies if the field for the registration form is required, conditional or optional.
        public let fieldRequirement: FieldRequirement
        /// The type of field.
        public let fieldType: FieldType
        /// The section path of the field.
        public let sectionPath: String
        /// The validation rules for a select field.
        public let selectValidation: SelectValidation?
        /// The validation rules for a text field.
        public let textValidation: TextValidation?

        public init(displayHints: RegistrationFieldDisplayHints, fieldPath: String, fieldRequirement: FieldRequirement, fieldType: FieldType, sectionPath: String, selectValidation: SelectValidation? = nil, textValidation: TextValidation? = nil) {
            self.displayHints = displayHints
            self.fieldPath = fieldPath
            self.fieldRequirement = fieldRequirement
            self.fieldType = fieldType
            self.sectionPath = sectionPath
            self.selectValidation = selectValidation
            self.textValidation = textValidation
        }

        private enum CodingKeys: String, CodingKey {
            case displayHints = "DisplayHints"
            case fieldPath = "FieldPath"
            case fieldRequirement = "FieldRequirement"
            case fieldType = "FieldType"
            case sectionPath = "SectionPath"
            case selectValidation = "SelectValidation"
            case textValidation = "TextValidation"
        }
    }

    public struct RegistrationFieldDisplayHints: AWSDecodableShape {
        /// The link to the document the display hint is associated with.
        public let documentationLink: String?
        /// The title of the document the display hint is associated with.
        public let documentationTitle: String?
        /// Example text of what the value of a field should contain.
        public let exampleTextValue: String?
        /// A full description of the display hint.
        public let longDescription: String?
        /// An array of SelectOptionDescription objects.
        public let selectOptionDescriptions: [SelectOptionDescription]?
        /// A short description of the display hint.
        public let shortDescription: String
        /// The validation rules for the text field.
        public let textValidationDescription: String?
        /// The title of the display hint.
        public let title: String

        public init(documentationLink: String? = nil, documentationTitle: String? = nil, exampleTextValue: String? = nil, longDescription: String? = nil, selectOptionDescriptions: [SelectOptionDescription]? = nil, shortDescription: String, textValidationDescription: String? = nil, title: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.exampleTextValue = exampleTextValue
            self.longDescription = longDescription
            self.selectOptionDescriptions = selectOptionDescriptions
            self.shortDescription = shortDescription
            self.textValidationDescription = textValidationDescription
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case exampleTextValue = "ExampleTextValue"
            case longDescription = "LongDescription"
            case selectOptionDescriptions = "SelectOptionDescriptions"
            case shortDescription = "ShortDescription"
            case textValidationDescription = "TextValidationDescription"
            case title = "Title"
        }
    }

    public struct RegistrationFieldValueInformation: AWSDecodableShape {
        /// A description of why the registration was denied.
        public let deniedReason: String?
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?

        public init(deniedReason: String? = nil, fieldPath: String, registrationAttachmentId: String? = nil, selectChoices: [String]? = nil, textValue: String? = nil) {
            self.deniedReason = deniedReason
            self.fieldPath = fieldPath
            self.registrationAttachmentId = registrationAttachmentId
            self.selectChoices = selectChoices
            self.textValue = textValue
        }

        private enum CodingKeys: String, CodingKey {
            case deniedReason = "DeniedReason"
            case fieldPath = "FieldPath"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
        }
    }

    public struct RegistrationFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationFilterName
        /// An array of values to filter on.
        public let values: [String]

        public init(name: RegistrationFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationInformation: AWSDecodableShape {
        /// Metadata about a given registration which is specific to that registration type.
        public let additionalAttributes: [String: String]?
        /// The version number of the registration that was approved.
        public let approvedVersionNumber: Int64?
        /// The time when the registration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The current version number of the registration.
        public let currentVersionNumber: Int64
        /// The latest version number of the registration that was denied.
        public let latestDeniedVersionNumber: Int64?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    CREATED: Your registration is created but not submitted.    SUBMITTED: Your registration has been submitted and is awaiting review.    REVIEWING: Your registration has been accepted and is being reviewed.    PROVISIONING: Your registration has been approved and your origination identity is being created.    COMPLETE: Your registration has been approved and and your origination identity has been created.    REQUIRES_UPDATES: You must fix your registration and resubmit it.    CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.    DELETED: The registration has been deleted.
        public let registrationStatus: RegistrationStatus
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        public init(additionalAttributes: [String: String]? = nil, approvedVersionNumber: Int64? = nil, createdTimestamp: Date, currentVersionNumber: Int64, latestDeniedVersionNumber: Int64? = nil, registrationArn: String, registrationId: String, registrationStatus: RegistrationStatus, registrationType: String) {
            self.additionalAttributes = additionalAttributes
            self.approvedVersionNumber = approvedVersionNumber
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.latestDeniedVersionNumber = latestDeniedVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "AdditionalAttributes"
            case approvedVersionNumber = "ApprovedVersionNumber"
            case createdTimestamp = "CreatedTimestamp"
            case currentVersionNumber = "CurrentVersionNumber"
            case latestDeniedVersionNumber = "LatestDeniedVersionNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationStatus = "RegistrationStatus"
            case registrationType = "RegistrationType"
        }
    }

    public struct RegistrationSectionDefinition: AWSDecodableShape {
        /// The path to the section of the registration.
        public let displayHints: RegistrationSectionDisplayHints
        /// The path to the section of the registration.
        public let sectionPath: String

        public init(displayHints: RegistrationSectionDisplayHints, sectionPath: String) {
            self.displayHints = displayHints
            self.sectionPath = sectionPath
        }

        private enum CodingKeys: String, CodingKey {
            case displayHints = "DisplayHints"
            case sectionPath = "SectionPath"
        }
    }

    public struct RegistrationSectionDisplayHints: AWSDecodableShape {
        /// The link to the document the display hint is associated with.
        public let documentationLink: String?
        /// The title of the document the display hint is associated with.
        public let documentationTitle: String?
        /// A full description of the display hint.
        public let longDescription: String?
        /// A short description of the display hint.
        public let shortDescription: String
        /// The title of the display hint.
        public let title: String

        public init(documentationLink: String? = nil, documentationTitle: String? = nil, longDescription: String? = nil, shortDescription: String, title: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case longDescription = "LongDescription"
            case shortDescription = "ShortDescription"
            case title = "Title"
        }
    }

    public struct RegistrationTypeDefinition: AWSDecodableShape {
        /// Provides help information on the registration.
        public let displayHints: RegistrationTypeDisplayHints
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// The supported association behavior for the registration type.
        public let supportedAssociations: [SupportedAssociation]?

        public init(displayHints: RegistrationTypeDisplayHints, registrationType: String, supportedAssociations: [SupportedAssociation]? = nil) {
            self.displayHints = displayHints
            self.registrationType = registrationType
            self.supportedAssociations = supportedAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case displayHints = "DisplayHints"
            case registrationType = "RegistrationType"
            case supportedAssociations = "SupportedAssociations"
        }
    }

    public struct RegistrationTypeDisplayHints: AWSDecodableShape {
        /// The link to the document the display hint is associated with.
        public let documentationLink: String?
        /// The title of the document the display hint is associated with.
        public let documentationTitle: String?
        /// A full description of the display hint.
        public let longDescription: String?
        /// A short description of the display hint.
        public let shortDescription: String?
        /// The title of the display hint.
        public let title: String

        public init(documentationLink: String? = nil, documentationTitle: String? = nil, longDescription: String? = nil, shortDescription: String? = nil, title: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case longDescription = "LongDescription"
            case shortDescription = "ShortDescription"
            case title = "Title"
        }
    }

    public struct RegistrationTypeFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationTypeFilterName
        /// An array of values to filter on.
        public let values: [String]

        public init(name: RegistrationTypeFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationVersionFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationVersionFilterName
        /// An array of values to filter on.
        public let values: [String]

        public init(name: RegistrationVersionFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationVersionInformation: AWSDecodableShape {
        /// An array of RegistrationDeniedReasonInformation objects.
        public let deniedReasons: [RegistrationDeniedReasonInformation]?
        /// The status of the registration.    DRAFT: The initial status of a registration version after it’s created.    SUBMITTED: Your registration has been submitted.    REVIEWING: Your registration has been accepted and is being reviewed.    APPROVED: Your registration has been approved.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DENIED: You must fix your registration and resubmit it.    REVOKED: Your previously approved registration has been revoked.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The version number of the registration.
        public let versionNumber: Int64

        public init(deniedReasons: [RegistrationDeniedReasonInformation]? = nil, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.deniedReasons = deniedReasons
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case deniedReasons = "DeniedReasons"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct RegistrationVersionStatusHistory: AWSDecodableShape {
        /// The time when the registration was in the approved state, in UNIX epoch time format.
        public let approvedTimestamp: Date?
        /// The time when the registration was in the archived state, in UNIX epoch time format.
        public let archivedTimestamp: Date?
        /// The time when the registration was in the denied state, in UNIX epoch time format.
        public let deniedTimestamp: Date?
        /// The time when the registration was in the discarded state, in UNIX epoch time format.
        public let discardedTimestamp: Date?
        /// The time when the registration was in the draft state, in UNIX epoch time format.
        public let draftTimestamp: Date
        /// The time when the registration was in the reviewing state, in UNIX epoch time format.
        public let reviewingTimestamp: Date?
        /// The time when the registration was in the revoked state, in UNIX epoch time format.
        public let revokedTimestamp: Date?
        /// The time when the registration was in the submitted state, in UNIX epoch time format.
        public let submittedTimestamp: Date?

        public init(approvedTimestamp: Date? = nil, archivedTimestamp: Date? = nil, deniedTimestamp: Date? = nil, discardedTimestamp: Date? = nil, draftTimestamp: Date, reviewingTimestamp: Date? = nil, revokedTimestamp: Date? = nil, submittedTimestamp: Date? = nil) {
            self.approvedTimestamp = approvedTimestamp
            self.archivedTimestamp = archivedTimestamp
            self.deniedTimestamp = deniedTimestamp
            self.discardedTimestamp = discardedTimestamp
            self.draftTimestamp = draftTimestamp
            self.reviewingTimestamp = reviewingTimestamp
            self.revokedTimestamp = revokedTimestamp
            self.submittedTimestamp = submittedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case approvedTimestamp = "ApprovedTimestamp"
            case archivedTimestamp = "ArchivedTimestamp"
            case deniedTimestamp = "DeniedTimestamp"
            case discardedTimestamp = "DiscardedTimestamp"
            case draftTimestamp = "DraftTimestamp"
            case reviewingTimestamp = "ReviewingTimestamp"
            case revokedTimestamp = "RevokedTimestamp"
            case submittedTimestamp = "SubmittedTimestamp"
        }
    }

    public struct ReleasePhoneNumberRequest: AWSEncodableShape {
        /// The PhoneNumberId or PhoneNumberArn of the phone number to release. You can use DescribePhoneNumbers to get the values for PhoneNumberId and PhoneNumberArn.
        public let phoneNumberId: String

        public init(phoneNumberId: String) {
            self.phoneNumberId = phoneNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, max: 256)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, min: 1)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct ReleasePhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The message type that was associated with the phone number.
        public let messageType: MessageType?
        /// The monthly price of the phone number, in US dollars.
        public let monthlyLeasingPrice: String?
        /// Specifies if the number could be used for text messages, voice, or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was released.
        public let numberType: NumberType?
        /// The name of the OptOutList that was associated with the phone number.
        public let optOutListName: String?
        /// The phone number that was released.
        public let phoneNumber: String?
        /// The PhoneNumberArn of the phone number that was released.
        public let phoneNumberArn: String?
        /// The PhoneNumberId of the phone number that was released.
        public let phoneNumberId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// The Amazon Resource Name (ARN) of the TwoWayChannel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: NumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct ReleaseSenderIdRequest: AWSEncodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The sender ID to release.
        public let senderId: String

        public init(isoCountryCode: String, senderId: String) {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 256)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case senderId = "SenderId"
        }
    }

    public struct ReleaseSenderIdResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly price, in US dollars, to lease the sender ID.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered.
        public let registered: Bool
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// The sender ID that was released.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String

        public init(isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, registrationId: String? = nil, senderId: String, senderIdArn: String) {
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case registrationId = "RegistrationId"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
        }
    }

    public struct RequestPhoneNumberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// Indicates if the phone number will be used for text messages, voice messages, or both.
        public let numberCapabilities: [NumberCapability]
        /// The type of phone number to request.
        public let numberType: RequestableNumberType
        /// The name of the OptOutList to associate with the phone number. You can use the OptOutListName or OptOutListArn.
        public let optOutListName: String?
        /// The pool to associated with the phone number. You can use the PoolId or PoolArn.
        public let poolId: String?
        /// Use this field to attach your phone number for an external registration process.
        public let registrationId: String?
        /// An array of tags (key and value pairs) associate with the requested phone number.
        public let tags: [Tag]?

        public init(clientToken: String? = RequestPhoneNumberRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageType: MessageType, numberCapabilities: [NumberCapability], numberType: RequestableNumberType, optOutListName: String? = nil, poolId: String? = nil, registrationId: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.poolId = poolId
            self.registrationId = registrationId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.numberCapabilities, name: "numberCapabilities", parent: name, max: 2)
            try self.validate(self.numberCapabilities, name: "numberCapabilities", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case poolId = "PoolId"
            case registrationId = "RegistrationId"
            case tags = "Tags"
        }
    }

    public struct RequestPhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The monthly price, in US dollars, to lease the phone number.
        public let monthlyLeasingPrice: String?
        /// Indicates if the phone number will be used for text messages, voice messages or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was released.
        public let numberType: RequestableNumberType?
        /// The name of the OptOutList that is associated with the requested phone number.
        public let optOutListName: String?
        /// The new phone number that was requested.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the requested phone number.
        public let phoneNumberArn: String?
        /// The unique identifier of the new phone number.
        public let phoneNumberId: String?
        /// The unique identifier of the pool associated with the phone number
        public let poolId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// An array of key and value pair tags that are associated with the phone number.
        public let tags: [Tag]?
        /// The ARN used to identify the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: RequestableNumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, poolId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, tags: [Tag]? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.tags = tags
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case poolId = "PoolId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case tags = "Tags"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct RequestSenderIdRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]?
        /// The sender ID string to request.
        public let senderId: String
        /// An array of tags (key and value pairs) to associate with the sender ID.
        public let tags: [Tag]?

        public init(clientToken: String? = RequestSenderIdRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageTypes: [MessageType]? = nil, senderId: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.senderId = senderId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.messageTypes, name: "messageTypes", parent: name, max: 2)
            try self.validate(self.senderId, name: "senderId", parent: name, max: 11)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case senderId = "SenderId"
            case tags = "Tags"
        }
    }

    public struct RequestSenderIdResult: AWSDecodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly price, in US dollars, to lease the sender ID.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered.
        public let registered: Bool
        /// The sender ID that was requested.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String
        /// An array of tags (key and value pairs) to associate with the sender ID.
        public let tags: [Tag]?

        public init(deletionProtectionEnabled: Bool, isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, senderId: String, senderIdArn: String, tags: [Tag]? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.senderId = senderId
            self.senderIdArn = senderIdArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
            case tags = "Tags"
        }
    }

    public struct SelectOptionDescription: AWSDecodableShape {
        /// A description of the option meaning.
        public let description: String?
        /// The value of the option.
        public let option: String
        /// The title of the select option.
        public let title: String?

        public init(description: String? = nil, option: String, title: String? = nil) {
            self.description = description
            self.option = option
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case option = "Option"
            case title = "Title"
        }
    }

    public struct SelectValidation: AWSDecodableShape {
        /// The maximum number of choices for the select.
        public let maxChoices: Int
        /// The minimum number of choices for the select.
        public let minChoices: Int
        /// An array of strings for the possible selection options.
        public let options: [String]

        public init(maxChoices: Int, minChoices: Int, options: [String]) {
            self.maxChoices = maxChoices
            self.minChoices = minChoices
            self.options = options
        }

        private enum CodingKeys: String, CodingKey {
            case maxChoices = "MaxChoices"
            case minChoices = "MinChoices"
            case options = "Options"
        }
    }

    public struct SendDestinationNumberVerificationCodeRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see Special requirements for sending SMS messages to recipients in India.
        public let destinationCountryParameters: [DestinationCountryParameterKey: String]?
        /// Choose the language to use for the message.
        public let languageCode: LanguageCode?
        /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.
        public let originationIdentity: String?
        /// Choose to send the verification code as an SMS or voice message.
        public let verificationChannel: VerificationChannel
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationCountryParameters: [DestinationCountryParameterKey: String]? = nil, languageCode: LanguageCode? = nil, originationIdentity: String? = nil, verificationChannel: VerificationChannel, verifiedDestinationNumberId: String) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationCountryParameters = destinationCountryParameters
            self.languageCode = languageCode
            self.originationIdentity = originationIdentity
            self.verificationChannel = verificationChannel
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^(?!\\s)^[\\s\\S]+(?<!\\s)$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.destinationCountryParameters?.forEach {
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, max: 64)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.destinationCountryParameters, name: "destinationCountryParameters", parent: name, max: 10)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, max: 256)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, min: 1)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationCountryParameters = "DestinationCountryParameters"
            case languageCode = "LanguageCode"
            case originationIdentity = "OriginationIdentity"
            case verificationChannel = "VerificationChannel"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct SendDestinationNumberVerificationCodeResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String

        public init(messageId: String) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendTextMessageRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see Special requirements for sending SMS messages to recipients in India.
        public let destinationCountryParameters: [DestinationCountryParameterKey: String]?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
        public let dryRun: Bool?
        /// When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.
        public let keyword: String?
        /// The maximum amount that you want to spend, in US dollars, per each text message part. A text message can contain multiple parts.
        public let maxPrice: String?
        /// The body of the text message.
        public let messageBody: String?
        /// The type of message. Valid values are            for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.
        public let originationIdentity: String?
        /// How long the text message is valid for. By default this is 72 hours.
        public let timeToLive: Int?

        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationCountryParameters: [DestinationCountryParameterKey: String]? = nil, destinationPhoneNumber: String, dryRun: Bool? = nil, keyword: String? = nil, maxPrice: String? = nil, messageBody: String? = nil, messageType: MessageType? = nil, originationIdentity: String? = nil, timeToLive: Int? = nil) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationCountryParameters = destinationCountryParameters
            self.destinationPhoneNumber = destinationPhoneNumber
            self.dryRun = dryRun
            self.keyword = keyword
            self.maxPrice = maxPrice
            self.messageBody = messageBody
            self.messageType = messageType
            self.originationIdentity = originationIdentity
            self.timeToLive = timeToLive
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^(?!\\s)^[\\s\\S]+(?<!\\s)$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.destinationCountryParameters?.forEach {
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, max: 64)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.destinationCountryParameters, name: "destinationCountryParameters", parent: name, max: 10)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, max: 8)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, min: 2)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, pattern: "^[0-9]{0,2}\\.[0-9]{1,5}$")
            try self.validate(self.messageBody, name: "messageBody", parent: name, max: 1600)
            try self.validate(self.messageBody, name: "messageBody", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, max: 259200)
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationCountryParameters = "DestinationCountryParameters"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case dryRun = "DryRun"
            case keyword = "Keyword"
            case maxPrice = "MaxPrice"
            case messageBody = "MessageBody"
            case messageType = "MessageType"
            case originationIdentity = "OriginationIdentity"
            case timeToLive = "TimeToLive"
        }
    }

    public struct SendTextMessageResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String?

        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendVoiceMessageRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
        public let dryRun: Bool?
        /// The maximum amount to spend per voice message, in US dollars.
        public let maxPricePerMinute: String?
        /// The text to convert to a voice message.
        public let messageBody: String?
        /// Specifies if the MessageBody field contains text or speech synthesis markup language (SSML).   TEXT: This is the default value. When used the maximum character limit is 3000.   SSML: When used the maximum character limit is 6000 including SSML tagging.
        public let messageBodyTextType: VoiceMessageBodyTextType?
        /// The origination identity to use for the voice call. This can be the PhoneNumber, PhoneNumberId, PhoneNumberArn, PoolId, or PoolArn.
        public let originationIdentity: String
        /// How long the voice message is valid for. By default this is 72 hours.
        public let timeToLive: Int?
        /// The voice for the Amazon Polly service to use. By default this is set to "MATTHEW".
        public let voiceId: VoiceId?

        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationPhoneNumber: String, dryRun: Bool? = nil, maxPricePerMinute: String? = nil, messageBody: String? = nil, messageBodyTextType: VoiceMessageBodyTextType? = nil, originationIdentity: String, timeToLive: Int? = nil, voiceId: VoiceId? = nil) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationPhoneNumber = destinationPhoneNumber
            self.dryRun = dryRun
            self.maxPricePerMinute = maxPricePerMinute
            self.messageBody = messageBody
            self.messageBodyTextType = messageBodyTextType
            self.originationIdentity = originationIdentity
            self.timeToLive = timeToLive
            self.voiceId = voiceId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^(?!\\s)^[\\s\\S]+(?<!\\s)$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, max: 8)
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, min: 2)
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, pattern: "^[0-9]{0,2}\\.[0-9]{1,5}$")
            try self.validate(self.messageBody, name: "messageBody", parent: name, max: 6000)
            try self.validate(self.messageBody, name: "messageBody", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, max: 259200)
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case dryRun = "DryRun"
            case maxPricePerMinute = "MaxPricePerMinute"
            case messageBody = "MessageBody"
            case messageBodyTextType = "MessageBodyTextType"
            case originationIdentity = "OriginationIdentity"
            case timeToLive = "TimeToLive"
            case voiceId = "VoiceId"
        }
    }

    public struct SendVoiceMessageResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String?

        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SenderIdAndCountry: AWSEncodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The unique identifier of the sender.
        public let senderId: String

        public init(isoCountryCode: String, senderId: String) {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 256)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case senderId = "SenderId"
        }
    }

    public struct SenderIdFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: SenderIdFilterName
        /// An array of values to filter for.
        public let values: [String]

        public init(name: SenderIdFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct SenderIdInformation: AWSDecodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly leasing price, in US dollars.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered.
        public let registered: Bool
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// The alphanumeric sender ID in a specific country that you'd like to describe.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String

        public init(deletionProtectionEnabled: Bool, isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, registrationId: String? = nil, senderId: String, senderIdArn: String) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case registrationId = "RegistrationId"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
        }
    }

    public struct SetDefaultMessageTypeRequest: AWSEncodableShape {
        /// The configuration set to update with a new default message type. This field can be the ConsigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType

        public init(configurationSetName: String, messageType: MessageType) {
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct SetDefaultMessageTypeResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set that was updated.
        public let configurationSetName: String?
        /// The new default message type of the configuration set.
        public let messageType: MessageType?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, messageType: MessageType? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct SetDefaultSenderIdRequest: AWSEncodableShape {
        /// The configuration set to updated with a new default SenderId. This field can be the ConsigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// The current sender ID for the configuration set. When sending a text message to a destination country which supports SenderIds, the default sender ID on the configuration set specified on SendTextMessage will be used if no dedicated origination phone numbers or registered SenderIds are available in your account, instead of a generic sender ID, such as 'NOTICE'.
        public let senderId: String

        public init(configurationSetName: String, senderId: String) {
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 11)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct SetDefaultSenderIdResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set that was updated.
        public let configurationSetName: String?
        /// The default sender ID to set for the ConfigurationSet.
        public let senderId: String?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, senderId: String? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct SetTextMessageSpendLimitOverrideRequest: AWSEncodableShape {
        /// The new monthly limit to enforce on text messages.
        public let monthlyLimit: Int64

        public init(monthlyLimit: Int64) {
            self.monthlyLimit = monthlyLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, max: 1000000000)
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetTextMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit to enforce on sending text messages.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetVoiceMessageSpendLimitOverrideRequest: AWSEncodableShape {
        /// The new monthly limit to enforce on voice messages.
        public let monthlyLimit: Int64

        public init(monthlyLimit: Int64) {
            self.monthlyLimit = monthlyLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, max: 1000000000)
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetVoiceMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit to enforce on sending voice messages.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SnsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        public let topicArn: String

        public init(topicArn: String) {
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, max: 2048)
            try self.validate(self.topicArn, name: "topicArn", parent: name, min: 20)
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct SpendLimit: AWSDecodableShape {
        /// The maximum amount of money, in US dollars, that you want to be able to spend sending messages each month. This value has to be less than or equal to the amount in MaxLimit. To use this custom limit, Overridden must be set to true.
        public let enforcedLimit: Int64
        ///  The maximum amount of money that you are able to spend to send messages each month, in US dollars.
        public let maxLimit: Int64
        /// The name for the SpendLimit.
        public let name: SpendLimitName
        /// When set to True, the value that has been specified in the EnforcedLimit is used to determine the maximum amount in US dollars that can be spent to send messages each month, in US dollars.
        public let overridden: Bool

        public init(enforcedLimit: Int64, maxLimit: Int64, name: SpendLimitName, overridden: Bool) {
            self.enforcedLimit = enforcedLimit
            self.maxLimit = maxLimit
            self.name = name
            self.overridden = overridden
        }

        private enum CodingKeys: String, CodingKey {
            case enforcedLimit = "EnforcedLimit"
            case maxLimit = "MaxLimit"
            case name = "Name"
            case overridden = "Overridden"
        }
    }

    public struct SubmitRegistrationVersionRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct SubmitRegistrationVersionResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration version.    DRAFT: The initial status of a registration version after it’s created.    SUBMITTED: Your registration has been submitted.    REVIEWING: Your registration has been accepted and is being reviewed.    APPROVED: Your registration has been approved.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DENIED: You must fix your registration and resubmit it.    REVOKED: Your previously approved registration has been revoked.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The version number of the registration.
        public let versionNumber: Int64

        public init(registrationArn: String, registrationId: String, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SupportedAssociation: AWSDecodableShape {
        /// The association behavior.    ASSOCIATE_BEFORE_SUBMIT The origination identity has to be supplied when creating a registration.    ASSOCIATE_ON_APPROVAL This applies to all short code registrations. The short code will be automatically provisioned once the registration is approved.    ASSOCIATE_AFTER_COMPLETE This applies to phone number registrations when you must complete a registration first, then associate one or more phone numbers later. For example 10DLC campaigns and long codes.
        public let associationBehavior: RegistrationAssociationBehavior
        /// The disassociation behavior.    DISASSOCIATE_ALL_CLOSES_REGISTRATION All origination identities must be disassociated from the registration before the registration can be closed.    DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION All origination identities must be disassociated from the registration before the registration can be deleted.    DELETE_REGISTRATION_DISASSOCIATES The registration can be deleted and all origination identities will be disasscoiated.
        public let disassociationBehavior: RegistrationDisassociationBehavior
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// Defines the behavior of when an origination identity and registration can be associated with each other.
        public let resourceType: String

        public init(associationBehavior: RegistrationAssociationBehavior, disassociationBehavior: RegistrationDisassociationBehavior, isoCountryCode: String? = nil, resourceType: String) {
            self.associationBehavior = associationBehavior
            self.disassociationBehavior = disassociationBehavior
            self.isoCountryCode = isoCountryCode
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case associationBehavior = "AssociationBehavior"
            case disassociationBehavior = "DisassociationBehavior"
            case isoCountryCode = "IsoCountryCode"
            case resourceType = "ResourceType"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key identifier, or name, of the tag.
        public let key: String
        /// The string value associated with the key of the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^.+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct TextValidation: AWSDecodableShape {
        /// The maximum number of characters for the text field.
        public let maxLength: Int
        /// The minimum number of characters for the text field.
        public let minLength: Int
        /// The regular expression used to validate the text field.
        public let pattern: String

        public init(maxLength: Int, minLength: Int, pattern: String) {
            self.maxLength = maxLength
            self.minLength = minLength
            self.pattern = pattern
        }

        private enum CodingKeys: String, CodingKey {
            case maxLength = "MaxLength"
            case minLength = "MinLength"
            case pattern = "Pattern"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// An array of tag key values to unassociate with the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventDestinationRequest: AWSEncodableShape {
        /// An object that contains information about an event destination that sends data to CloudWatch Logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// The configuration set to update with the new event destination. Valid values for this can be the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// When set to true logging is enabled.
        public let enabled: Bool?
        /// The name to use for the event destination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Kinesis Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log.  The TEXT_SENT event type is not supported.
        public let matchingEventTypes: [EventType]?
        /// An object that contains information about an event destination that sends data to Amazon SNS.
        public let snsDestination: SnsDestination?

        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, configurationSetName: String, enabled: Bool? = nil, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType]? = nil, snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.configurationSetName = configurationSetName
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsDestination?.validate(name: "\(name).cloudWatchLogsDestination")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.kinesisFirehoseDestination?.validate(name: "\(name).kinesisFirehoseDestination")
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, max: 25)
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, min: 1)
            try self.snsDestination?.validate(name: "\(name).snsDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case configurationSetName = "ConfigurationSetName"
            case enabled = "Enabled"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct UpdateEventDestinationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the ConfigurationSet that was updated.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// An EventDestination object containing the details of where events will be logged.
        public let eventDestination: EventDestination?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct UpdatePhoneNumberRequest: AWSEncodableShape {
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The OptOutList to add the phone number to. Valid values for this field can be either the OutOutListName or OutOutListArn.
        public let optOutListName: String?
        /// The unique identifier of the phone number. Valid values for this field can be either the PhoneNumberId or PhoneNumberArn.
        public let phoneNumberId: String
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(deletionProtectionEnabled: Bool? = nil, optOutListName: String? = nil, phoneNumberId: String, selfManagedOptOutsEnabled: Bool? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.optOutListName = optOutListName
            self.phoneNumberId = phoneNumberId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, max: 256)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, min: 1)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, max: 2048)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, min: 20)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, pattern: "^\\S+$")
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, max: 2048)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, min: 20)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case optOutListName = "OptOutListName"
            case phoneNumberId = "PhoneNumberId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The monthly leasing price of the phone number, in US dollars.
        public let monthlyLeasingPrice: String?
        /// Specifies if the number could be used for text messages, voice or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was requested.
        public let numberType: NumberType?
        /// The name of the OptOutList associated with the phone number.
        public let optOutListName: String?
        /// The phone number that was updated.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the updated phone number.
        public let phoneNumberArn: String?
        /// The unique identifier of the phone number.
        public let phoneNumberId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// This is true if self managed opt-out are enabled.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: NumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePoolRequest: AWSEncodableShape {
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The OptOutList to associate with the pool. Valid values are either OptOutListName or OptOutListArn.
        public let optOutListName: String?
        /// The unique identifier of the pool to update. Valid values are either the PoolId or PoolArn.
        public let poolId: String
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(deletionProtectionEnabled: Bool? = nil, optOutListName: String? = nil, poolId: String, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.optOutListName = optOutListName
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, max: 2048)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, min: 20)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, pattern: "^\\S+$")
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, max: 2048)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, min: 20)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case optOutListName = "OptOutListName"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The type of message for the pool to use.
        public let messageType: MessageType?
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String?
        /// The ARN of the pool.
        public let poolArn: String?
        /// The unique identifier of the pool.
        public let poolId: String?
        /// When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool update request.
        public let status: PoolStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdateSenderIdRequest: AWSEncodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The sender ID to update.
        public let senderId: String

        public init(deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, senderId: String) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 256)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case senderId = "SenderId"
        }
    }

    public struct UpdateSenderIdResult: AWSDecodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly price, in US dollars, to lease the sender ID.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered..
        public let registered: Bool
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// The sender ID that was updated.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String

        public init(deletionProtectionEnabled: Bool, isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, registrationId: String? = nil, senderId: String, senderIdArn: String) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case registrationId = "RegistrationId"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
        }
    }

    public struct VerifiedDestinationNumberFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: VerifiedDestinationNumberFilterName
        /// An array of values to filter on.
        public let values: [String]

        public init(name: VerifiedDestinationNumberFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\.:A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct VerifiedDestinationNumberInformation: AWSDecodableShape {
        /// The time when the destination phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// The status of the verified destination phone number.    PENDING: The phone number hasn't been verified yet.    VERIFIED: The phone number is verified and can receive messages.
        public let status: VerificationStatus
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        public init(createdTimestamp: Date, destinationPhoneNumber: String, status: VerificationStatus, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case status = "Status"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct VerifyDestinationNumberRequest: AWSEncodableShape {
        /// The verification code that was received by the verified destination phone number.
        public let verificationCode: String
        /// The unique identifier for the verififed destination phone number.
        public let verifiedDestinationNumberId: String

        public init(verificationCode: String, verifiedDestinationNumberId: String) {
            self.verificationCode = verificationCode
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.verificationCode, name: "verificationCode", parent: name, max: 20)
            try self.validate(self.verificationCode, name: "verificationCode", parent: name, min: 1)
            try self.validate(self.verificationCode, name: "verificationCode", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, max: 256)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, min: 1)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case verificationCode = "VerificationCode"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct VerifyDestinationNumberResult: AWSDecodableShape {
        /// The time when the destination phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// The status for being able to send messages to the phone number.
        public let status: VerificationStatus
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        public init(createdTimestamp: Date, destinationPhoneNumber: String, status: VerificationStatus, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case status = "Status"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }
}

// MARK: - Errors

/// Error enum for PinpointSMSVoiceV2
public struct PinpointSMSVoiceV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PinpointSMSVoiceV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied because you don't have sufficient permissions to access the resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time or it could be that the requested action isn't valid for the current state or configuration of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A requested resource couldn't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// An error that occurred because too many requests were sent during a certain amount of time.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// A validation exception for a field.
    public static var validationException: Self { .init(.validationException) }
}

extension PinpointSMSVoiceV2ErrorType: Equatable {
    public static func == (lhs: PinpointSMSVoiceV2ErrorType, rhs: PinpointSMSVoiceV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PinpointSMSVoiceV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
