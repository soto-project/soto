//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PinpointSMSVoiceV2 {
    // MARK: Enums

    public enum AccessDeniedExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountDisabled = "ACCOUNT_DISABLED"
        case insufficientAccountReputation = "INSUFFICIENT_ACCOUNT_REPUTATION"
        public var description: String { return self.rawValue }
    }

    public enum AccountAttributeName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountTier = "ACCOUNT_TIER"
        case defaultProtectConfigurationId = "DEFAULT_PROTECT_CONFIGURATION_ID"
        public var description: String { return self.rawValue }
    }

    public enum AccountLimitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationSets = "CONFIGURATION_SETS"
        case optOutLists = "OPT_OUT_LISTS"
        case phoneNumbers = "PHONE_NUMBERS"
        case pools = "POOLS"
        case registrations = "REGISTRATIONS"
        case registrationAttachments = "REGISTRATION_ATTACHMENTS"
        case senderIds = "SENDER_IDS"
        case verifiedDestinationNumbers = "VERIFIED_DESTINATION_NUMBERS"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case uploadComplete = "UPLOAD_COMPLETE"
        case uploadFailed = "UPLOAD_FAILED"
        case uploadInProgress = "UPLOAD_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentUploadErrorReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationSetFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case defaultMessageFeedbackEnabled = "default-message-feedback-enabled"
        case defaultMessageType = "default-message-type"
        case defaultSenderId = "default-sender-id"
        case eventDestinationName = "event-destination-name"
        case matchingEventTypes = "matching-event-types"
        case protectConfigurationId = "protect-configuration-id"
        public var description: String { return self.rawValue }
    }

    public enum ConflictExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createRegistrationVersionNotAllowed = "CREATE_REGISTRATION_VERSION_NOT_ALLOWED"
        case deletionProtectionEnabled = "DELETION_PROTECTION_ENABLED"
        case destinationCountryBlockedByProtectConfiguration = "DESTINATION_COUNTRY_BLOCKED_BY_PROTECT_CONFIGURATION"
        case destinationPhoneNumberBlockedByProtectNumberOverride = "DESTINATION_PHONE_NUMBER_BLOCKED_BY_PROTECT_NUMBER_OVERRIDE"
        case destinationPhoneNumberNotVerified = "DESTINATION_PHONE_NUMBER_NOT_VERIFIED"
        case destinationPhoneNumberOptedOut = "DESTINATION_PHONE_NUMBER_OPTED_OUT"
        case disassociateRegistrationNotAllowed = "DISASSOCIATE_REGISTRATION_NOT_ALLOWED"
        case discardRegistrationVersionNotAllowed = "DISCARD_REGISTRATION_VERSION_NOT_ALLOWED"
        case editRegistrationFieldValuesNotAllowed = "EDIT_REGISTRATION_FIELD_VALUES_NOT_ALLOWED"
        case eventDestinationMismatch = "EVENT_DESTINATION_MISMATCH"
        case keywordMismatch = "KEYWORD_MISMATCH"
        case lastPhoneNumber = "LAST_PHONE_NUMBER"
        case messageTypeMismatch = "MESSAGE_TYPE_MISMATCH"
        case noOriginationIdentitiesFound = "NO_ORIGINATION_IDENTITIES_FOUND"
        case numberCapabilitiesMismatch = "NUMBER_CAPABILITIES_MISMATCH"
        case optOutListMismatch = "OPT_OUT_LIST_MISMATCH"
        case phoneNumberAssociatedToPool = "PHONE_NUMBER_ASSOCIATED_TO_POOL"
        case phoneNumberAssociatedToRegistration = "PHONE_NUMBER_ASSOCIATED_TO_REGISTRATION"
        case phoneNumberNotAssociatedToPool = "PHONE_NUMBER_NOT_ASSOCIATED_TO_POOL"
        case phoneNumberNotInRegistrationRegion = "PHONE_NUMBER_NOT_IN_REGISTRATION_REGION"
        case protectConfigurationAssociatedWithConfigurationSet = "PROTECT_CONFIGURATION_ASSOCIATED_WITH_CONFIGURATION_SET"
        case protectConfigurationIsAccountDefault = "PROTECT_CONFIGURATION_IS_ACCOUNT_DEFAULT"
        case protectConfigurationNotAssociatedWithConfigurationSet = "PROTECT_CONFIGURATION_NOT_ASSOCIATED_WITH_CONFIGURATION_SET"
        case registrationAlreadySubmitted = "REGISTRATION_ALREADY_SUBMITTED"
        case registrationNotComplete = "REGISTRATION_NOT_COMPLETE"
        case resourceAlreadyExists = "RESOURCE_ALREADY_EXISTS"
        case resourceDeletionNotAllowed = "RESOURCE_DELETION_NOT_ALLOWED"
        case resourceModificationNotAllowed = "RESOURCE_MODIFICATION_NOT_ALLOWED"
        case resourceNotActive = "RESOURCE_NOT_ACTIVE"
        case resourceNotEmpty = "RESOURCE_NOT_EMPTY"
        case selfManagedOptOutsMismatch = "SELF_MANAGED_OPT_OUTS_MISMATCH"
        case senderIdAssociatedToPool = "SENDER_ID_ASSOCIATED_TO_POOL"
        case submitRegistrationVersionNotAllowed = "SUBMIT_REGISTRATION_VERSION_NOT_ALLOWED"
        case twoWayConfigMismatch = "TWO_WAY_CONFIG_MISMATCH"
        case verificationAlreadyComplete = "VERIFICATION_ALREADY_COMPLETE"
        case verificationCodeExpired = "VERIFICATION_CODE_EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum DestinationCountryParameterKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inEntityId = "IN_ENTITY_ID"
        case inTemplateId = "IN_TEMPLATE_ID"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case mediaAll = "MEDIA_ALL"
        case mediaBlocked = "MEDIA_BLOCKED"
        case mediaCarrierBlocked = "MEDIA_CARRIER_BLOCKED"
        case mediaCarrierUnreachable = "MEDIA_CARRIER_UNREACHABLE"
        case mediaDelivered = "MEDIA_DELIVERED"
        case mediaFileInaccessible = "MEDIA_FILE_INACCESSIBLE"
        case mediaFileSizeExceeded = "MEDIA_FILE_SIZE_EXCEEDED"
        case mediaFileTypeUnsupported = "MEDIA_FILE_TYPE_UNSUPPORTED"
        case mediaInvalid = "MEDIA_INVALID"
        case mediaInvalidMessage = "MEDIA_INVALID_MESSAGE"
        case mediaPending = "MEDIA_PENDING"
        case mediaQueued = "MEDIA_QUEUED"
        case mediaSpam = "MEDIA_SPAM"
        case mediaSuccessful = "MEDIA_SUCCESSFUL"
        case mediaTtlExpired = "MEDIA_TTL_EXPIRED"
        case mediaUnknown = "MEDIA_UNKNOWN"
        case mediaUnreachable = "MEDIA_UNREACHABLE"
        case textAll = "TEXT_ALL"
        case textBlocked = "TEXT_BLOCKED"
        case textCarrierBlocked = "TEXT_CARRIER_BLOCKED"
        case textCarrierUnreachable = "TEXT_CARRIER_UNREACHABLE"
        case textDelivered = "TEXT_DELIVERED"
        case textInvalid = "TEXT_INVALID"
        case textInvalidMessage = "TEXT_INVALID_MESSAGE"
        case textPending = "TEXT_PENDING"
        case textProtectBlocked = "TEXT_PROTECT_BLOCKED"
        case textQueued = "TEXT_QUEUED"
        case textSent = "TEXT_SENT"
        case textSpam = "TEXT_SPAM"
        case textSuccessful = "TEXT_SUCCESSFUL"
        case textTtlExpired = "TEXT_TTL_EXPIRED"
        case textUnknown = "TEXT_UNKNOWN"
        case textUnreachable = "TEXT_UNREACHABLE"
        case voiceAll = "VOICE_ALL"
        case voiceAnswered = "VOICE_ANSWERED"
        case voiceBusy = "VOICE_BUSY"
        case voiceCompleted = "VOICE_COMPLETED"
        case voiceFailed = "VOICE_FAILED"
        case voiceInitiated = "VOICE_INITIATED"
        case voiceNoAnswer = "VOICE_NO_ANSWER"
        case voiceRinging = "VOICE_RINGING"
        case voiceTtlExpired = "VOICE_TTL_EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum FieldRequirement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditional = "CONDITIONAL"
        case optional = "OPTIONAL"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum FieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachment = "ATTACHMENT"
        case select = "SELECT"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum KeywordAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automaticResponse = "AUTOMATIC_RESPONSE"
        case optIn = "OPT_IN"
        case optOut = "OPT_OUT"
        public var description: String { return self.rawValue }
    }

    public enum KeywordFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case keywordAction = "keyword-action"
        public var description: String { return self.rawValue }
    }

    public enum LanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deDe = "DE_DE"
        case enGb = "EN_GB"
        case enUs = "EN_US"
        case es419 = "ES_419"
        case esEs = "ES_ES"
        case frCa = "FR_CA"
        case frFr = "FR_FR"
        case itIt = "IT_IT"
        case jaJp = "JA_JP"
        case koKr = "KO_KR"
        case ptBr = "PT_BR"
        case zhCn = "ZH_CN"
        case zhTw = "ZH_TW"
        public var description: String { return self.rawValue }
    }

    public enum MessageFeedbackStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case received = "RECEIVED"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case promotional = "PROMOTIONAL"
        case transactional = "TRANSACTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum NumberCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mms = "MMS"
        case sms = "SMS"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum NumberStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case associating = "ASSOCIATING"
        case deleted = "DELETED"
        case disassociating = "DISASSOCIATING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum NumberType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case longCode = "LONG_CODE"
        case shortCode = "SHORT_CODE"
        case simulator = "SIMULATOR"
        case tenDlc = "TEN_DLC"
        case tollFree = "TOLL_FREE"
        public var description: String { return self.rawValue }
    }

    public enum OptedOutFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case endUserOptedOut = "end-user-opted-out"
        public var description: String { return self.rawValue }
    }

    public enum Owner: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case _self = "SELF"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case isoCountryCode = "iso-country-code"
        case messageType = "message-type"
        case numberCapability = "number-capability"
        case numberType = "number-type"
        case optOutListName = "opt-out-list-name"
        case selfManagedOptOutsEnabled = "self-managed-opt-outs-enabled"
        case status = "status"
        case twoWayChannelArn = "two-way-channel-arn"
        case twoWayEnabled = "two-way-enabled"
        public var description: String { return self.rawValue }
    }

    public enum PoolFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case messageType = "message-type"
        case optOutListName = "opt-out-list-name"
        case selfManagedOptOutsEnabled = "self-managed-opt-outs-enabled"
        case sharedRoutesEnabled = "shared-routes-enabled"
        case status = "status"
        case twoWayChannelArn = "two-way-channel-arn"
        case twoWayEnabled = "two-way-enabled"
        public var description: String { return self.rawValue }
    }

    public enum PoolOriginationIdentitiesFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isoCountryCode = "iso-country-code"
        case numberCapability = "number-capability"
        public var description: String { return self.rawValue }
    }

    public enum PoolStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ProtectConfigurationFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountDefault = "account-default"
        case deletionProtectionEnabled = "deletion-protection-enabled"
        public var description: String { return self.rawValue }
    }

    public enum ProtectConfigurationRuleOverrideAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case block = "BLOCK"
        public var description: String { return self.rawValue }
    }

    public enum ProtectConfigurationRuleSetNumberOverrideFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case action = "action"
        case createdAfter = "created-after"
        case createdBefore = "created-before"
        case destinationPhoneNumberBeginsWith = "destination-phone-number-begins-with"
        case expiresAfter = "expires-after"
        case expiresBefore = "expires-before"
        case isoCountryCode = "iso-country-code"
        public var description: String { return self.rawValue }
    }

    public enum ProtectStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case block = "BLOCK"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationAssociationBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associateAfterComplete = "ASSOCIATE_AFTER_COMPLETE"
        case associateBeforeSubmit = "ASSOCIATE_BEFORE_SUBMIT"
        case associateOnApproval = "ASSOCIATE_ON_APPROVAL"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationAssociationFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isoCountryCode = "iso-country-code"
        case resourceType = "resource-type"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationAttachmentFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachmentStatus = "attachment-status"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationDisassociationBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteRegistrationDisassociates = "DELETE_REGISTRATION_DISASSOCIATES"
        case disassociateAllAllowsDeleteRegistration = "DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION"
        case disassociateAllClosesRegistration = "DISASSOCIATE_ALL_CLOSES_REGISTRATION"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case registrationStatus = "registration-status"
        case registrationType = "registration-type"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closed = "CLOSED"
        case complete = "COMPLETE"
        case created = "CREATED"
        case deleted = "DELETED"
        case provisioning = "PROVISIONING"
        case requiresAuthentication = "REQUIRES_AUTHENTICATION"
        case requiresUpdates = "REQUIRES_UPDATES"
        case reviewing = "REVIEWING"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationTypeFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case supportedAssociationIsoCountryCode = "supported-association-iso-country-code"
        case supportedAssociationResourceType = "supported-association-resource-type"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationVersionFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case registrationVersionStatus = "registration-version-status"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case archived = "ARCHIVED"
        case denied = "DENIED"
        case discarded = "DISCARDED"
        case draft = "DRAFT"
        case requiresAuthentication = "REQUIRES_AUTHENTICATION"
        case reviewing = "REVIEWING"
        case revoked = "REVOKED"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum RequestableNumberType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case longCode = "LONG_CODE"
        case simulator = "SIMULATOR"
        case tenDlc = "TEN_DLC"
        case tollFree = "TOLL_FREE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "account"
        case configurationSet = "configuration-set"
        case eventDestination = "event-destination"
        case keyword = "keyword"
        case message = "message"
        case optOutList = "opt-out-list"
        case optedOutNumber = "opted-out-number"
        case phoneNumber = "phone-number"
        case policy = "policy"
        case pool = "pool"
        case protectConfiguration = "protect-configuration"
        case registration = "registration"
        case registrationAttachment = "registration-attachment"
        case senderId = "sender-id"
        case verifiedDestinationNumber = "verified-destination-number"
        public var description: String { return self.rawValue }
    }

    public enum SenderIdFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case isoCountryCode = "iso-country-code"
        case messageType = "message-type"
        case registered = "registered"
        case senderId = "sender-id"
        public var description: String { return self.rawValue }
    }

    public enum ServiceQuotaExceededExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associationsPerRegistration = "ASSOCIATIONS_PER_REGISTRATION"
        case configurationSetsPerAccount = "CONFIGURATION_SETS_PER_ACCOUNT"
        case dailyDestinationCallLimit = "DAILY_DESTINATION_CALL_LIMIT"
        case eventDestinationsPerConfigurationSet = "EVENT_DESTINATIONS_PER_CONFIGURATION_SET"
        case keywordsPerPhoneNumber = "KEYWORDS_PER_PHONE_NUMBER"
        case keywordsPerPool = "KEYWORDS_PER_POOL"
        case monthlySpendLimitReachedForMedia = "MONTHLY_SPEND_LIMIT_REACHED_FOR_MEDIA"
        case monthlySpendLimitReachedForText = "MONTHLY_SPEND_LIMIT_REACHED_FOR_TEXT"
        case monthlySpendLimitReachedForVoice = "MONTHLY_SPEND_LIMIT_REACHED_FOR_VOICE"
        case optOutListsPerAccount = "OPT_OUT_LISTS_PER_ACCOUNT"
        case originationIdentitiesPerPool = "ORIGINATION_IDENTITIES_PER_POOL"
        case phoneNumbersPerAccount = "PHONE_NUMBERS_PER_ACCOUNT"
        case phoneNumbersPerRegistration = "PHONE_NUMBERS_PER_REGISTRATION"
        case poolsPerAccount = "POOLS_PER_ACCOUNT"
        case protectConfigurationsPerAccount = "PROTECT_CONFIGURATIONS_PER_ACCOUNT"
        case registrationsPerAccount = "REGISTRATIONS_PER_ACCOUNT"
        case registrationAttachmentsCreatedPerDay = "REGISTRATION_ATTACHMENTS_CREATED_PER_DAY"
        case registrationAttachmentsPerAccount = "REGISTRATION_ATTACHMENTS_PER_ACCOUNT"
        case registrationVersionsCreatedPerDay = "REGISTRATION_VERSIONS_CREATED_PER_DAY"
        case senderIdsPerAccount = "SENDER_IDS_PER_ACCOUNT"
        case tagsPerResource = "TAGS_PER_RESOURCE"
        case verificationAttemptsPerDay = "VERIFICATION_ATTEMPTS_PER_DAY"
        case verifiedDestinationNumbersPerAccount = "VERIFIED_DESTINATION_NUMBERS_PER_ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum SpendLimitName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mediaMessageMonthlySpendLimit = "MEDIA_MESSAGE_MONTHLY_SPEND_LIMIT"
        case textMessageMonthlySpendLimit = "TEXT_MESSAGE_MONTHLY_SPEND_LIMIT"
        case voiceMessageMonthlySpendLimit = "VOICE_MESSAGE_MONTHLY_SPEND_LIMIT"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachmentTypeNotSupported = "ATTACHMENT_TYPE_NOT_SUPPORTED"
        case cannotAddOptedOutNumber = "CANNOT_ADD_OPTED_OUT_NUMBER"
        case cannotParse = "CANNOT_PARSE"
        case countryCodeMismatch = "COUNTRY_CODE_MISMATCH"
        case destinationCountryBlocked = "DESTINATION_COUNTRY_BLOCKED"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case invalidArn = "INVALID_ARN"
        case invalidFilterValues = "INVALID_FILTER_VALUES"
        case invalidIdentityForDestinationCountry = "INVALID_IDENTITY_FOR_DESTINATION_COUNTRY"
        case invalidNextToken = "INVALID_NEXT_TOKEN"
        case invalidParameter = "INVALID_PARAMETER"
        case invalidRegistrationAssociation = "INVALID_REGISTRATION_ASSOCIATION"
        case invalidRequest = "INVALID_REQUEST"
        case maximumSizeExceeded = "MAXIMUM_SIZE_EXCEEDED"
        case mediaTypeNotSupported = "MEDIA_TYPE_NOT_SUPPORTED"
        case missingParameter = "MISSING_PARAMETER"
        case other = "OTHER"
        case parametersCannotBeUsedTogether = "PARAMETERS_CANNOT_BE_USED_TOGETHER"
        case phoneNumberCannotBeOptedIn = "PHONE_NUMBER_CANNOT_BE_OPTED_IN"
        case phoneNumberCannotBeReleased = "PHONE_NUMBER_CANNOT_BE_RELEASED"
        case priceOverThreshold = "PRICE_OVER_THRESHOLD"
        case registrationFieldCannotBeDeleted = "REGISTRATION_FIELD_CANNOT_BE_DELETED"
        case requestedSpendLimitHigherThanServiceLimit = "REQUESTED_SPEND_LIMIT_HIGHER_THAN_SERVICE_LIMIT"
        case resourceNotAccessible = "RESOURCE_NOT_ACCESSIBLE"
        case senderIdNotRegistered = "SENDER_ID_NOT_REGISTERED"
        case senderIdNotSupported = "SENDER_ID_NOT_SUPPORTED"
        case senderIdRequiresRegistration = "SENDER_ID_REQUIRES_REGISTRATION"
        case twoWayChannelNotPresent = "TWO_WAY_CHANNEL_NOT_PRESENT"
        case twoWayNotEnabled = "TWO_WAY_NOT_ENABLED"
        case twoWayNotSupportedInCountry = "TWO_WAY_NOT_SUPPORTED_IN_COUNTRY"
        case twoWayNotSupportedInRegion = "TWO_WAY_NOT_SUPPORTED_IN_REGION"
        case twoWayTopicNotPresent = "TWO_WAY_TOPIC_NOT_PRESENT"
        case unknownOperation = "UNKNOWN_OPERATION"
        case unknownRegistrationField = "UNKNOWN_REGISTRATION_FIELD"
        case unknownRegistrationSection = "UNKNOWN_REGISTRATION_SECTION"
        case unknownRegistrationType = "UNKNOWN_REGISTRATION_TYPE"
        case unknownRegistrationVersion = "UNKNOWN_REGISTRATION_VERSION"
        case unspecifiedParameterNotSupported = "UNSPECIFIED_PARAMETER_NOT_SUPPORTED"
        case verificationCodeMismatch = "VERIFICATION_CODE_MISMATCH"
        case voiceCapabilityNotAvailable = "VOICE_CAPABILITY_NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum VerificationChannel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case text = "TEXT"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum VerificationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pending = "PENDING"
        case verified = "VERIFIED"
        public var description: String { return self.rawValue }
    }

    public enum VerifiedDestinationNumberFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case status = "status"
        public var description: String { return self.rawValue }
    }

    public enum VoiceId: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amy = "AMY"
        case astrid = "ASTRID"
        case bianca = "BIANCA"
        case brian = "BRIAN"
        case camila = "CAMILA"
        case carla = "CARLA"
        case carmen = "CARMEN"
        case celine = "CELINE"
        case chantal = "CHANTAL"
        case conchita = "CONCHITA"
        case cristiano = "CRISTIANO"
        case dora = "DORA"
        case emma = "EMMA"
        case enrique = "ENRIQUE"
        case ewa = "EWA"
        case filiz = "FILIZ"
        case geraint = "GERAINT"
        case giorgio = "GIORGIO"
        case gwyneth = "GWYNETH"
        case hans = "HANS"
        case ines = "INES"
        case ivy = "IVY"
        case jacek = "JACEK"
        case jan = "JAN"
        case joanna = "JOANNA"
        case joey = "JOEY"
        case justin = "JUSTIN"
        case karl = "KARL"
        case kendra = "KENDRA"
        case kimberly = "KIMBERLY"
        case lea = "LEA"
        case liv = "LIV"
        case lotte = "LOTTE"
        case lucia = "LUCIA"
        case lupe = "LUPE"
        case mads = "MADS"
        case maja = "MAJA"
        case marlene = "MARLENE"
        case mathieu = "MATHIEU"
        case matthew = "MATTHEW"
        case maxim = "MAXIM"
        case mia = "MIA"
        case miguel = "MIGUEL"
        case mizuki = "MIZUKI"
        case naja = "NAJA"
        case nicole = "NICOLE"
        case penelope = "PENELOPE"
        case raveena = "RAVEENA"
        case ricardo = "RICARDO"
        case ruben = "RUBEN"
        case russell = "RUSSELL"
        case salli = "SALLI"
        case seoyeon = "SEOYEON"
        case takumi = "TAKUMI"
        case tatyana = "TATYANA"
        case vicki = "VICKI"
        case vitoria = "VITORIA"
        case zeina = "ZEINA"
        case zhiyu = "ZHIYU"
        public var description: String { return self.rawValue }
    }

    public enum VoiceMessageBodyTextType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ssml = "SSML"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let message: String?
        /// The reason for the exception.
        public let reason: AccessDeniedExceptionReason?

        @inlinable
        public init(message: String? = nil, reason: AccessDeniedExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct AccountAttribute: AWSDecodableShape {
        /// The name of the account attribute.
        public let name: AccountAttributeName
        /// The value associated with the account attribute name.
        public let value: String

        @inlinable
        public init(name: AccountAttributeName, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AccountLimit: AWSDecodableShape {
        /// The Amazon Web Services set limit for that resource type, in US dollars.
        public let max: Int64
        /// The name of the attribute to apply the account limit to.
        public let name: AccountLimitName
        /// The current amount that has been spent, in US dollars.
        public let used: Int64

        @inlinable
        public init(max: Int64, name: AccountLimitName, used: Int64) {
            self.max = max
            self.name = name
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case name = "Name"
            case used = "Used"
        }
    }

    public struct AssociateOriginationIdentityRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the origination identity.
        public let isoCountryCode: String
        /// The origination identity to use, such as PhoneNumberId, PhoneNumberArn, SenderId, or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn, while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String
        /// The pool to update with the new Identity. This value can be either the PoolId or PoolArn, and you can find these values using DescribePools.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let poolId: String

        @inlinable
        public init(clientToken: String? = AssociateOriginationIdentityRequest.idempotencyToken(), isoCountryCode: String, originationIdentity: String, poolId: String) {
            self.clientToken = clientToken
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case poolId = "PoolId"
        }
    }

    public struct AssociateOriginationIdentityResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The PhoneNumberId or SenderId of the origination identity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or SenderIdArn of the origination identity.
        public let originationIdentityArn: String?
        /// The Amazon Resource Name (ARN) of the pool that is now associated with the origination identity.
        public let poolArn: String?
        /// The PoolId of the pool that is now associated with the origination identity.
        public let poolId: String?

        @inlinable
        public init(isoCountryCode: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct AssociateProtectConfigurationRequest: AWSEncodableShape {
        /// The name of the ConfigurationSet.
        public let configurationSetName: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(configurationSetName: String, protectConfigurationId: String) {
            self.configurationSetName = configurationSetName
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct AssociateProtectConfigurationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String
        /// The name of the ConfigurationSet.
        public let configurationSetName: String
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(configurationSetArn: String, configurationSetName: String, protectConfigurationArn: String, protectConfigurationId: String) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct CloudWatchLogsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Identity and Access Management role that is able to write event data to an Amazon CloudWatch destination.
        public let iamRoleArn: String
        /// The name of the Amazon CloudWatch log group that you want to record events in.
        public let logGroupArn: String

        @inlinable
        public init(iamRoleArn: String, logGroupArn: String) {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 2048)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 20)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn:\\S+$")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, max: 2048)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, min: 20)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case logGroupArn = "LogGroupArn"
        }
    }

    public struct ConfigurationSetFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: ConfigurationSetFilterName
        /// An array values to filter for.
        public let values: [String]

        @inlinable
        public init(name: ConfigurationSetFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ConfigurationSetInformation: AWSDecodableShape {
        /// The Resource Name (ARN) of the ConfigurationSet.
        public let configurationSetArn: String
        /// The name of the ConfigurationSet.
        public let configurationSetName: String
        /// The time when the ConfigurationSet was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// True if message feedback is enabled.
        public let defaultMessageFeedbackEnabled: Bool?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let defaultMessageType: MessageType?
        /// The default sender ID used by the ConfigurationSet.
        public let defaultSenderId: String?
        /// An array of EventDestination objects that describe any events to log and where to log them.
        public let eventDestinations: [EventDestination]
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String?

        @inlinable
        public init(configurationSetArn: String, configurationSetName: String, createdTimestamp: Date, defaultMessageFeedbackEnabled: Bool? = nil, defaultMessageType: MessageType? = nil, defaultSenderId: String? = nil, eventDestinations: [EventDestination], protectConfigurationId: String? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageFeedbackEnabled = defaultMessageFeedbackEnabled
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case defaultMessageFeedbackEnabled = "DefaultMessageFeedbackEnabled"
            case defaultMessageType = "DefaultMessageType"
            case defaultSenderId = "DefaultSenderId"
            case eventDestinations = "EventDestinations"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String?
        /// The reason for the exception.
        public let reason: ConflictExceptionReason?
        /// The unique identifier of the request.
        public let resourceId: String?
        /// The type of resource that caused the exception.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String? = nil, reason: ConflictExceptionReason? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.reason = reason
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateConfigurationSetRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The name to use for the new configuration set.
        public let configurationSetName: String
        /// An array of key and value pair tags that's associated with the new configuration set.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateConfigurationSetRequest.idempotencyToken(), configurationSetName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.configurationSetName = configurationSetName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 64)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case configurationSetName = "ConfigurationSetName"
            case tags = "Tags"
        }
    }

    public struct CreateConfigurationSetResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created configuration set.
        public let configurationSetArn: String?
        /// The name of the new configuration set.
        public let configurationSetName: String?
        /// The time when the configuration set was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// An array of key and value pair tags that's associated with the configuration set.
        public let tags: [Tag]?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, createdTimestamp: Date? = nil, tags: [Tag]? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case tags = "Tags"
        }
    }

    public struct CreateEventDestinationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// An object that contains information about an event destination for logging to Amazon CloudWatch Logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// Either the name of the configuration set or the configuration set ARN to apply event logging to. The ConfigurateSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String
        /// The name that identifies the event destination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Amazon Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log. If "ALL" is used, then AWS End User Messaging SMS and Voice logs every event type.  The TEXT_SENT event type is not supported.
        public let matchingEventTypes: [EventType]
        /// An object that contains information about an event destination for logging to Amazon SNS.
        public let snsDestination: SnsDestination?

        @inlinable
        public init(clientToken: String? = CreateEventDestinationRequest.idempotencyToken(), cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, configurationSetName: String, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType], snsDestination: SnsDestination? = nil) {
            self.clientToken = clientToken
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.configurationSetName = configurationSetName
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.cloudWatchLogsDestination?.validate(name: "\(name).cloudWatchLogsDestination")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.kinesisFirehoseDestination?.validate(name: "\(name).kinesisFirehoseDestination")
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, max: 43)
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, min: 1)
            try self.snsDestination?.validate(name: "\(name).snsDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case configurationSetName = "ConfigurationSetName"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct CreateEventDestinationResult: AWSDecodableShape {
        /// The ARN of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The details of the destination where events are logged.
        public let eventDestination: EventDestination?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct CreateOptOutListRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The name of the new OptOutList.
        public let optOutListName: String
        /// An array of tags (key and value pairs) to associate with the new OptOutList.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateOptOutListRequest.idempotencyToken(), optOutListName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.optOutListName = optOutListName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 64)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case optOutListName = "OptOutListName"
            case tags = "Tags"
        }
    }

    public struct CreateOptOutListResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) for the OptOutList.
        public let optOutListArn: String?
        /// The name of the new OptOutList.
        public let optOutListName: String?
        /// An array of tags (key and value pairs) associated with the new OptOutList.
        public let tags: [Tag]?

        @inlinable
        public init(createdTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil, tags: [Tag]? = nil) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
            case tags = "Tags"
        }
    }

    public struct CreatePoolRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the pool can't be deleted. You can change this value using the UpdatePool action.
        public let deletionProtectionEnabled: Bool?
        /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the new pool.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive. After the pool is created the MessageType can't be changed.
        public let messageType: MessageType
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn. After the pool is created you can add more origination identities to the pool by using AssociateOriginationIdentity.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String
        /// An array of tags (key and value pairs) associated with the pool.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreatePoolRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageType: MessageType, originationIdentity: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.originationIdentity = originationIdentity
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case originationIdentity = "OriginationIdentity"
            case tags = "Tags"
        }
    }

    public struct CreatePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool?
        /// The type of message for the pool to use.
        public let messageType: MessageType?
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String?
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String?
        /// The unique identifier for the pool.
        public let poolId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool. Set to false and only origination identities in this pool are used to send messages.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool.   CREATING: The pool is currently being created and isn't yet available for use.   ACTIVE: The pool is active and available for use.   DELETING: The pool is being deleted.
        public let status: PoolStatus?
        /// An array of tags (key and value pairs) associated with the pool.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, tags: [Tag]? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.tags = tags
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case tags = "Tags"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct CreateProtectConfigurationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool?
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateProtectConfigurationRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case tags = "Tags"
        }
    }

    public struct CreateProtectConfigurationResult: AWSDecodableShape {
        /// This is true if the protect configuration is set as your account default protect configuration.
        public let accountDefault: Bool
        /// The time when the protect configuration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]?

        @inlinable
        public init(accountDefault: Bool, createdTimestamp: Date, deletionProtectionEnabled: Bool, protectConfigurationArn: String, protectConfigurationId: String, tags: [Tag]? = nil) {
            self.accountDefault = accountDefault
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountDefault = "AccountDefault"
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationAssociationRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        public let resourceId: String

        @inlinable
        public init(registrationId: String, resourceId: String) {
            self.registrationId = registrationId
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 256)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
            case resourceId = "ResourceId"
        }
    }

    public struct CreateRegistrationAssociationResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The phone number associated with the registration in E.164 format.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
        public let resourceArn: String
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        public let resourceId: String
        /// The registration type or origination identity type.
        public let resourceType: String

        @inlinable
        public init(isoCountryCode: String? = nil, phoneNumber: String? = nil, registrationArn: String, registrationId: String, registrationType: String, resourceArn: String, resourceId: String, resourceType: String) {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationType = registrationType
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case phoneNumber = "PhoneNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationType = "RegistrationType"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateRegistrationAttachmentRequest: AWSEncodableShape {
        /// The registration file to upload. The maximum file size is 500KB and valid file extensions are PDF, JPEG and PNG.
        public let attachmentBody: AWSBase64Data?
        /// Registration files have to be stored in an Amazon S3 bucket. The URI to use when sending is in the format s3://BucketName/FileName.
        public let attachmentUrl: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// An array of tags (key and value pairs) to associate with the registration attachment.
        public let tags: [Tag]?

        @inlinable
        public init(attachmentBody: AWSBase64Data? = nil, attachmentUrl: String? = nil, clientToken: String? = CreateRegistrationAttachmentRequest.idempotencyToken(), tags: [Tag]? = nil) {
            self.attachmentBody = attachmentBody
            self.attachmentUrl = attachmentUrl
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentBody, name: "attachmentBody", parent: name, max: 1572864)
            try self.validate(self.attachmentBody, name: "attachmentBody", parent: name, min: 1)
            try self.validate(self.attachmentUrl, name: "attachmentUrl", parent: name, max: 2048)
            try self.validate(self.attachmentUrl, name: "attachmentUrl", parent: name, min: 1)
            try self.validate(self.attachmentUrl, name: "attachmentUrl", parent: name, pattern: "^\\S+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentBody = "AttachmentBody"
            case attachmentUrl = "AttachmentUrl"
            case clientToken = "ClientToken"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationAttachmentResult: AWSDecodableShape {
        /// The status of the registration attachment.     UPLOAD_IN_PROGRESS The attachment is being uploaded.    UPLOAD_COMPLETE The attachment has been uploaded.    UPLOAD_FAILED The attachment failed to uploaded.    DELETED The attachment has been deleted..
        public let attachmentStatus: AttachmentStatus
        /// The time when the registration attachment was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) for the registration attachment.
        public let registrationAttachmentArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String
        /// An array of tags (key and value pairs) to associate with the registration attachment.
        public let tags: [Tag]?

        @inlinable
        public init(attachmentStatus: AttachmentStatus, createdTimestamp: Date, registrationAttachmentArn: String, registrationAttachmentId: String, tags: [Tag]? = nil) {
            self.attachmentStatus = attachmentStatus
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentStatus = "AttachmentStatus"
            case createdTimestamp = "CreatedTimestamp"
            case registrationAttachmentArn = "RegistrationAttachmentArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The type of registration form to create. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// An array of tags (key and value pairs) to associate with the registration.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateRegistrationRequest.idempotencyToken(), registrationType: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.registrationType = registrationType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.registrationType, name: "registrationType", parent: name, max: 64)
            try self.validate(self.registrationType, name: "registrationType", parent: name, min: 1)
            try self.validate(self.registrationType, name: "registrationType", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case registrationType = "RegistrationType"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationResult: AWSDecodableShape {
        /// Metadata about a given registration which is specific to that registration type.
        public let additionalAttributes: [String: String]?
        /// The time when the registration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The current version number of the registration.
        public let currentVersionNumber: Int64
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.    CREATED: Your registration is created but not submitted.    COMPLETE: Your registration has been approved and your origination identity has been created.    DELETED: The registration has been deleted.    PROVISIONING: Your registration has been approved and your origination identity is being created.    REQUIRES_AUTHENTICATION: You need to complete email authentication.    REQUIRES_UPDATES: You must fix your registration and resubmit it.    REVIEWING: Your registration has been accepted and is being reviewed.    SUBMITTED: Your registration has been submitted and is awaiting review.
        public let registrationStatus: RegistrationStatus
        /// The type of registration form to create. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// An array of tags (key and value pairs) to associate with the registration.
        public let tags: [Tag]?

        @inlinable
        public init(additionalAttributes: [String: String]? = nil, createdTimestamp: Date, currentVersionNumber: Int64, registrationArn: String, registrationId: String, registrationStatus: RegistrationStatus, registrationType: String, tags: [Tag]? = nil) {
            self.additionalAttributes = additionalAttributes
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "AdditionalAttributes"
            case createdTimestamp = "CreatedTimestamp"
            case currentVersionNumber = "CurrentVersionNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationStatus = "RegistrationStatus"
            case registrationType = "RegistrationType"
            case tags = "Tags"
        }
    }

    public struct CreateRegistrationVersionRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct CreateRegistrationVersionResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    APPROVED: Your registration has been approved.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.    DENIED: You must fix your registration and resubmit it.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DRAFT: The initial status of a registration version after its created.    REQUIRES_AUTHENTICATION: You need to complete email authentication.    REVIEWING: Your registration has been accepted and is being reviewed.    REVOKED: Your previously approved registration has been revoked.    SUBMITTED: Your registration has been submitted.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// A RegistrationVersionStatusHistory object that contains timestamps for the registration.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The new version number of the registration.
        public let versionNumber: Int64

        @inlinable
        public init(registrationArn: String, registrationId: String, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct CreateVerifiedDestinationNumberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// An array of tags (key and value pairs) to associate with the destination number.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateVerifiedDestinationNumberRequest.idempotencyToken(), destinationPhoneNumber: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.destinationPhoneNumber = destinationPhoneNumber
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case tags = "Tags"
        }
    }

    public struct CreateVerifiedDestinationNumberResult: AWSDecodableShape {
        /// The time when the verified phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// The status of the verified destination phone number.    PENDING: The phone number hasn't been verified yet.    VERIFIED: The phone number is verified and can receive messages.
        public let status: VerificationStatus
        /// An array of tags (key and value pairs) to associate with the destination number.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        @inlinable
        public init(createdTimestamp: Date, destinationPhoneNumber: String, status: VerificationStatus, tags: [Tag]? = nil, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.tags = tags
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case status = "Status"
            case tags = "Tags"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct DeleteAccountDefaultProtectConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteAccountDefaultProtectConfigurationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the account default protect configuration.
        public let defaultProtectConfigurationArn: String
        /// The unique identifier of the account default protect configuration.
        public let defaultProtectConfigurationId: String

        @inlinable
        public init(defaultProtectConfigurationArn: String, defaultProtectConfigurationId: String) {
            self.defaultProtectConfigurationArn = defaultProtectConfigurationArn
            self.defaultProtectConfigurationId = defaultProtectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case defaultProtectConfigurationArn = "DefaultProtectConfigurationArn"
            case defaultProtectConfigurationId = "DefaultProtectConfigurationId"
        }
    }

    public struct DeleteConfigurationSetRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set ARN that you want to delete. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        @inlinable
        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteConfigurationSetResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted configuration set.
        public let configurationSetArn: String?
        /// The name of the deleted configuration set.
        public let configurationSetName: String?
        /// The time that the deleted configuration set was created in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// True if the configuration set has message feedback enabled. By default this is set to false.
        public let defaultMessageFeedbackEnabled: Bool?
        /// The default message type of the configuration set that was deleted.
        public let defaultMessageType: MessageType?
        /// The default Sender ID of the configuration set that was deleted.
        public let defaultSenderId: String?
        /// An array of any EventDestination objects that were associated with the deleted configuration set.
        public let eventDestinations: [EventDestination]?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, createdTimestamp: Date? = nil, defaultMessageFeedbackEnabled: Bool? = nil, defaultMessageType: MessageType? = nil, defaultSenderId: String? = nil, eventDestinations: [EventDestination]? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageFeedbackEnabled = defaultMessageFeedbackEnabled
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case defaultMessageFeedbackEnabled = "DefaultMessageFeedbackEnabled"
            case defaultMessageType = "DefaultMessageType"
            case defaultSenderId = "DefaultSenderId"
            case eventDestinations = "EventDestinations"
        }
    }

    public struct DeleteDefaultMessageTypeRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default message type from. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        @inlinable
        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteDefaultMessageTypeResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The current message type for the configuration set.
        public let messageType: MessageType?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, messageType: MessageType? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct DeleteDefaultSenderIdRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default sender ID from. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        @inlinable
        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteDefaultSenderIdResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The current sender ID for the configuration set.
        public let senderId: String?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, senderId: String? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct DeleteEventDestinationRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set's Amazon Resource Name (ARN) to remove the event destination from. The ConfigurateSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String
        /// The name of the event destination to delete.
        public let eventDestinationName: String

        @inlinable
        public init(configurationSetName: String, eventDestinationName: String) {
            self.configurationSetName = configurationSetName
            self.eventDestinationName = eventDestinationName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case eventDestinationName = "EventDestinationName"
        }
    }

    public struct DeleteEventDestinationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set the event destination was deleted from.
        public let configurationSetName: String?
        /// The event destination object that was deleted.
        public let eventDestination: EventDestination?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct DeleteKeywordRequest: AWSEncodableShape {
        /// The keyword to delete.
        public let keyword: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, PoolId or PoolArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn and DescribePools to find the values of PoolId and PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String

        @inlinable
        public init(keyword: String, originationIdentity: String) {
            self.keyword = keyword
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct DeleteKeywordResult: AWSDecodableShape {
        /// The keyword that was deleted.
        public let keyword: String?
        /// The action that was associated with the deleted keyword.
        public let keywordAction: KeywordAction?
        /// The message that was associated with the deleted keyword.
        public let keywordMessage: String?
        /// The PhoneNumberId or PoolId that the keyword was associated with.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that the keyword was associated with.
        public let originationIdentityArn: String?

        @inlinable
        public init(keyword: String? = nil, keywordAction: KeywordAction? = nil, keywordMessage: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct DeleteMediaMessageSpendLimitOverrideRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteMediaMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit, in US dollars.
        public let monthlyLimit: Int64?

        @inlinable
        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct DeleteOptOutListRequest: AWSEncodableShape {
        /// The OptOutListName or OptOutListArn of the OptOutList to delete. You can use DescribeOptOutLists to find the values for OptOutListName and OptOutListArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let optOutListName: String

        @inlinable
        public init(optOutListName: String) {
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptOutListResult: AWSDecodableShape {
        /// The time when the OptOutList was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the OptOutList that was removed.
        public let optOutListArn: String?
        /// The name of the OptOutList that was removed.
        public let optOutListName: String?

        @inlinable
        public init(createdTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptedOutNumberRequest: AWSEncodableShape {
        /// The phone number, in E.164 format, to remove from the OptOutList.
        public let optedOutNumber: String
        /// The OptOutListName or OptOutListArn to remove the phone number from.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let optOutListName: String

        @inlinable
        public init(optedOutNumber: String, optOutListName: String) {
            self.optedOutNumber = optedOutNumber
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, max: 20)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, min: 1)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optedOutNumber = "OptedOutNumber"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptedOutNumberResult: AWSDecodableShape {
        /// This is true if it was the end user who requested their phone number be removed.
        public let endUserOptedOut: Bool?
        /// The phone number that was removed from the OptOutList.
        public let optedOutNumber: String?
        /// The time that the number was removed at, in UNIX epoch time format.
        public let optedOutTimestamp: Date?
        /// The OptOutListArn that the phone number was removed from.
        public let optOutListArn: String?
        /// The OptOutListName that the phone number was removed from.
        public let optOutListName: String?

        @inlinable
        public init(endUserOptedOut: Bool? = nil, optedOutNumber: String? = nil, optedOutTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeletePoolRequest: AWSEncodableShape {
        /// The PoolId or PoolArn of the pool to delete. You can use DescribePools to find the values for PoolId and PoolArn .  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let poolId: String

        @inlinable
        public init(poolId: String) {
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case poolId = "PoolId"
        }
    }

    public struct DeletePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The message type that was associated with the deleted pool.
        public let messageType: MessageType?
        /// The name of the OptOutList that was associated with the deleted pool.
        public let optOutListName: String?
        /// The Amazon Resource Name (ARN) of the pool that was deleted.
        public let poolArn: String?
        /// The PoolId of the pool that was deleted.
        public let poolId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool.   CREATING: The pool is currently being created and isn't yet available for use.   ACTIVE: The pool is active and available for use.   DELETING: The pool is being deleted.
        public let status: PoolStatus?
        /// The Amazon Resource Name (ARN) of the TwoWayChannel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(createdTimestamp: Date? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct DeleteProtectConfigurationRequest: AWSEncodableShape {
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(protectConfigurationId: String) {
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct DeleteProtectConfigurationResult: AWSDecodableShape {
        /// This is true if the protect configuration is set as your account default protect configuration.
        public let accountDefault: Bool
        /// The time when the protect configuration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The status of deletion protection for the protect configuration. When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(accountDefault: Bool, createdTimestamp: Date, deletionProtectionEnabled: Bool, protectConfigurationArn: String, protectConfigurationId: String) {
            self.accountDefault = accountDefault
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case accountDefault = "AccountDefault"
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct DeleteProtectConfigurationRuleSetNumberOverrideRequest: AWSEncodableShape {
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(destinationPhoneNumber: String, protectConfigurationId: String) {
            self.destinationPhoneNumber = destinationPhoneNumber
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct DeleteProtectConfigurationRuleSetNumberOverrideResult: AWSDecodableShape {
        /// The action associated with the rule.
        public let action: ProtectConfigurationRuleOverrideAction
        /// The time when the rule was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// The time when the resource-based policy was created, in UNIX epoch time format.
        public let expirationTimestamp: Date?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(action: ProtectConfigurationRuleOverrideAction, createdTimestamp: Date, destinationPhoneNumber: String, expirationTimestamp: Date? = nil, isoCountryCode: String? = nil, protectConfigurationArn: String, protectConfigurationId: String) {
            self.action = action
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.expirationTimestamp = expirationTimestamp
            self.isoCountryCode = isoCountryCode
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case expirationTimestamp = "ExpirationTimestamp"
            case isoCountryCode = "IsoCountryCode"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct DeleteRegistrationAttachmentRequest: AWSEncodableShape {
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String

        @inlinable
        public init(registrationAttachmentId: String) {
            self.registrationAttachmentId = registrationAttachmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, max: 256)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, min: 1)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationAttachmentId = "RegistrationAttachmentId"
        }
    }

    public struct DeleteRegistrationAttachmentResult: AWSDecodableShape {
        /// The status of the registration attachment.     UPLOAD_IN_PROGRESS The attachment is being uploaded.    UPLOAD_COMPLETE The attachment has been uploaded.    UPLOAD_FAILED The attachment failed to uploaded.    DELETED The attachment has been deleted..
        public let attachmentStatus: AttachmentStatus
        /// The error message if the upload failed.
        public let attachmentUploadErrorReason: AttachmentUploadErrorReason?
        /// The time when the registration attachment was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) for the registration attachment.
        public let registrationAttachmentArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String

        @inlinable
        public init(attachmentStatus: AttachmentStatus, attachmentUploadErrorReason: AttachmentUploadErrorReason? = nil, createdTimestamp: Date, registrationAttachmentArn: String, registrationAttachmentId: String) {
            self.attachmentStatus = attachmentStatus
            self.attachmentUploadErrorReason = attachmentUploadErrorReason
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentStatus = "AttachmentStatus"
            case attachmentUploadErrorReason = "AttachmentUploadErrorReason"
            case createdTimestamp = "CreatedTimestamp"
            case registrationAttachmentArn = "RegistrationAttachmentArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
        }
    }

    public struct DeleteRegistrationFieldValueRequest: AWSEncodableShape {
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The unique identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(fieldPath: String, registrationId: String) {
            self.fieldPath = fieldPath
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, max: 100)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, min: 1)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationId = "RegistrationId"
        }
    }

    public struct DeleteRegistrationFieldValueResult: AWSDecodableShape {
        /// The path to the registration form field.
        public let fieldPath: String
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?
        /// The version number of the registration.
        public let versionNumber: Int64

        @inlinable
        public init(fieldPath: String, registrationArn: String, registrationAttachmentId: String? = nil, registrationId: String, selectChoices: [String]? = nil, textValue: String? = nil, versionNumber: Int64) {
            self.fieldPath = fieldPath
            self.registrationArn = registrationArn
            self.registrationAttachmentId = registrationAttachmentId
            self.registrationId = registrationId
            self.selectChoices = selectChoices
            self.textValue = textValue
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationArn = "RegistrationArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case registrationId = "RegistrationId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DeleteRegistrationRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct DeleteRegistrationResult: AWSDecodableShape {
        /// Metadata about a given registration which is specific to that registration type.
        public let additionalAttributes: [String: String]?
        /// The version number of the registration that was approved.
        public let approvedVersionNumber: Int64?
        /// The time when the registration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The current version number of the registration.
        public let currentVersionNumber: Int64
        /// The latest version number of the registration that was denied.
        public let latestDeniedVersionNumber: Int64?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.    CREATED: Your registration is created but not submitted.    COMPLETE: Your registration has been approved and your origination identity has been created.    DELETED: The registration has been deleted.    PROVISIONING: Your registration has been approved and your origination identity is being created.    REQUIRES_AUTHENTICATION: You need to complete email authentication.    REQUIRES_UPDATES: You must fix your registration and resubmit it.    REVIEWING: Your registration has been accepted and is being reviewed.    SUBMITTED: Your registration has been submitted and is awaiting review.
        public let registrationStatus: RegistrationStatus
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        @inlinable
        public init(additionalAttributes: [String: String]? = nil, approvedVersionNumber: Int64? = nil, createdTimestamp: Date, currentVersionNumber: Int64, latestDeniedVersionNumber: Int64? = nil, registrationArn: String, registrationId: String, registrationStatus: RegistrationStatus, registrationType: String) {
            self.additionalAttributes = additionalAttributes
            self.approvedVersionNumber = approvedVersionNumber
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.latestDeniedVersionNumber = latestDeniedVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "AdditionalAttributes"
            case approvedVersionNumber = "ApprovedVersionNumber"
            case createdTimestamp = "CreatedTimestamp"
            case currentVersionNumber = "CurrentVersionNumber"
            case latestDeniedVersionNumber = "LatestDeniedVersionNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationStatus = "RegistrationStatus"
            case registrationType = "RegistrationType"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource you're deleting the resource-based policy from.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct DeleteResourcePolicyResult: AWSDecodableShape {
        /// The time when the resource-based policy was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The JSON formatted resource-based policy that was deleted.
        public let policy: String?
        /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource that the resource-based policy was deleted from.
        public let resourceArn: String?

        @inlinable
        public init(createdTimestamp: Date? = nil, policy: String? = nil, resourceArn: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.policy = policy
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case policy = "Policy"
            case resourceArn = "ResourceArn"
        }
    }

    public struct DeleteTextMessageSpendLimitOverrideRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteTextMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit, in US dollars.
        public let monthlyLimit: Int64?

        @inlinable
        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct DeleteVerifiedDestinationNumberRequest: AWSEncodableShape {
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        @inlinable
        public init(verifiedDestinationNumberId: String) {
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, max: 256)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, min: 1)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct DeleteVerifiedDestinationNumberResult: AWSDecodableShape {
        /// The time when the destination phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        @inlinable
        public init(createdTimestamp: Date, destinationPhoneNumber: String, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct DeleteVoiceMessageSpendLimitOverrideRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteVoiceMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit, in US dollars.
        public let monthlyLimit: Int64?

        @inlinable
        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct DescribeAccountAttributesRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountAttributesResult: AWSDecodableShape {
        /// An array of AccountAttributes objects.
        public let accountAttributes: [AccountAttribute]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        @inlinable
        public init(accountAttributes: [AccountAttribute]? = nil, nextToken: String? = nil) {
            self.accountAttributes = accountAttributes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accountAttributes = "AccountAttributes"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountLimitsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountLimitsResult: AWSDecodableShape {
        /// An array of AccountLimit objects that show the current spend limits.
        public let accountLimits: [AccountLimit]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        @inlinable
        public init(accountLimits: [AccountLimit]? = nil, nextToken: String? = nil) {
            self.accountLimits = accountLimits
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accountLimits = "AccountLimits"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationSetsRequest: AWSEncodableShape {
        /// An array of strings. Each element can be either a ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetNames: [String]?
        /// An array of filters to apply to the results that are returned.
        public let filters: [ConfigurationSetFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        @inlinable
        public init(configurationSetNames: [String]? = nil, filters: [ConfigurationSetFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationSetNames = configurationSetNames
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configurationSetNames?.forEach {
                try validate($0, name: "configurationSetNames[]", parent: name, max: 256)
                try validate($0, name: "configurationSetNames[]", parent: name, min: 1)
                try validate($0, name: "configurationSetNames[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.configurationSetNames, name: "configurationSetNames", parent: name, max: 5)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetNames = "ConfigurationSetNames"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationSetsResult: AWSDecodableShape {
        /// An array of ConfigurationSets objects.
        public let configurationSets: [ConfigurationSetInformation]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        @inlinable
        public init(configurationSets: [ConfigurationSetInformation]? = nil, nextToken: String? = nil) {
            self.configurationSets = configurationSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSets = "ConfigurationSets"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeKeywordsRequest: AWSEncodableShape {
        /// An array of keyword filters to filter the results.
        public let filters: [KeywordFilter]?
        /// An array of keywords to search for.
        public let keywords: [String]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String

        @inlinable
        public init(filters: [KeywordFilter]? = nil, keywords: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, originationIdentity: String) {
            self.filters = filters
            self.keywords = keywords
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.keywords?.forEach {
                try validate($0, name: "keywords[]", parent: name, max: 30)
                try validate($0, name: "keywords[]", parent: name, min: 1)
                try validate($0, name: "keywords[]", parent: name, pattern: "^[ \\S]+$")
            }
            try self.validate(self.keywords, name: "keywords", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case keywords = "Keywords"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct DescribeKeywordsResult: AWSDecodableShape {
        /// An array of KeywordInformation objects that contain the results.
        public let keywords: [KeywordInformation]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// The PhoneNumberId or PoolId that is associated with the OriginationIdentity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that is associated with the OriginationIdentity.
        public let originationIdentityArn: String?

        @inlinable
        public init(keywords: [KeywordInformation]? = nil, nextToken: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keywords = keywords
            self.nextToken = nextToken
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keywords = "Keywords"
            case nextToken = "NextToken"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct DescribeOptOutListsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The OptOutLists to show the details of. This is an array of strings that can be either the OptOutListName or OptOutListArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let optOutListNames: [String]?
        /// Use SELF to filter the list of Opt-Out List to ones your account owns or use SHARED to filter on Opt-Out List shared with your account. The Owner and OptOutListNames parameters can't be used at the same time.
        public let owner: Owner?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, optOutListNames: [String]? = nil, owner: Owner? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.optOutListNames = optOutListNames
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.optOutListNames?.forEach {
                try validate($0, name: "optOutListNames[]", parent: name, max: 256)
                try validate($0, name: "optOutListNames[]", parent: name, min: 1)
                try validate($0, name: "optOutListNames[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.optOutListNames, name: "optOutListNames", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case optOutListNames = "OptOutListNames"
            case owner = "Owner"
        }
    }

    public struct DescribeOptOutListsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of OptOutListInformation objects that contain the details for the requested OptOutLists.
        public let optOutLists: [OptOutListInformation]?

        @inlinable
        public init(nextToken: String? = nil, optOutLists: [OptOutListInformation]? = nil) {
            self.nextToken = nextToken
            self.optOutLists = optOutLists
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case optOutLists = "OptOutLists"
        }
    }

    public struct DescribeOptedOutNumbersRequest: AWSEncodableShape {
        /// An array of OptedOutFilter objects to filter the results on.
        public let filters: [OptedOutFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of phone numbers to search for in the OptOutList. If you specify an opted out number that isn't valid, an exception is returned.
        public let optedOutNumbers: [String]?
        /// The OptOutListName or OptOutListArn of the OptOutList. You can use DescribeOptOutLists to find the values for OptOutListName and OptOutListArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let optOutListName: String

        @inlinable
        public init(filters: [OptedOutFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, optedOutNumbers: [String]? = nil, optOutListName: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.optedOutNumbers = optedOutNumbers
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.optedOutNumbers?.forEach {
                try validate($0, name: "optedOutNumbers[]", parent: name, max: 20)
                try validate($0, name: "optedOutNumbers[]", parent: name, min: 1)
                try validate($0, name: "optedOutNumbers[]", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            }
            try self.validate(self.optedOutNumbers, name: "optedOutNumbers", parent: name, max: 5)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case optedOutNumbers = "OptedOutNumbers"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DescribeOptedOutNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of OptedOutNumbersInformation objects that provide information about the requested OptedOutNumbers.
        public let optedOutNumbers: [OptedOutNumberInformation]?
        /// The Amazon Resource Name (ARN) of the OptOutList.
        public let optOutListArn: String?
        /// The name of the OptOutList.
        public let optOutListName: String?

        @inlinable
        public init(nextToken: String? = nil, optedOutNumbers: [OptedOutNumberInformation]? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.nextToken = nextToken
            self.optedOutNumbers = optedOutNumbers
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case optedOutNumbers = "OptedOutNumbers"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DescribePhoneNumbersRequest: AWSEncodableShape {
        /// An array of PhoneNumberFilter objects to filter the results.
        public let filters: [PhoneNumberFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// Use SELF to filter the list of phone numbers to ones your account owns or use SHARED to filter on phone numbers shared with your account. The Owner and PhoneNumberIds parameters can't be used at the same time.
        public let owner: Owner?
        /// The unique identifier of phone numbers to find information about. This is an array of strings that can be either the PhoneNumberId or PhoneNumberArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let phoneNumberIds: [String]?

        @inlinable
        public init(filters: [PhoneNumberFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Owner? = nil, phoneNumberIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
            self.phoneNumberIds = phoneNumberIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.phoneNumberIds?.forEach {
                try validate($0, name: "phoneNumberIds[]", parent: name, max: 256)
                try validate($0, name: "phoneNumberIds[]", parent: name, min: 1)
                try validate($0, name: "phoneNumberIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.phoneNumberIds, name: "phoneNumberIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case owner = "Owner"
            case phoneNumberIds = "PhoneNumberIds"
        }
    }

    public struct DescribePhoneNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of PhoneNumberInformation objects that contain the details for the requested phone numbers.
        public let phoneNumbers: [PhoneNumberInformation]?

        @inlinable
        public init(nextToken: String? = nil, phoneNumbers: [PhoneNumberInformation]? = nil) {
            self.nextToken = nextToken
            self.phoneNumbers = phoneNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case phoneNumbers = "PhoneNumbers"
        }
    }

    public struct DescribePoolsRequest: AWSEncodableShape {
        /// An array of PoolFilter objects to filter the results.
        public let filters: [PoolFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// Use SELF to filter the list of Pools to ones your account owns or use SHARED to filter on Pools shared with your account. The Owner and PoolIds parameters can't be used at the same time.
        public let owner: Owner?
        /// The unique identifier of pools to find. This is an array of strings that can be either the PoolId or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let poolIds: [String]?

        @inlinable
        public init(filters: [PoolFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Owner? = nil, poolIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
            self.poolIds = poolIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.poolIds?.forEach {
                try validate($0, name: "poolIds[]", parent: name, max: 256)
                try validate($0, name: "poolIds[]", parent: name, min: 1)
                try validate($0, name: "poolIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.poolIds, name: "poolIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case owner = "Owner"
            case poolIds = "PoolIds"
        }
    }

    public struct DescribePoolsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of PoolInformation objects that contain the details for the requested pools.
        public let pools: [PoolInformation]?

        @inlinable
        public init(nextToken: String? = nil, pools: [PoolInformation]? = nil) {
            self.nextToken = nextToken
            self.pools = pools
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pools = "Pools"
        }
    }

    public struct DescribeProtectConfigurationsRequest: AWSEncodableShape {
        /// An array of ProtectConfigurationFilter objects to filter the results.
        public let filters: [ProtectConfigurationFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of protect configuration identifiers to search for.
        public let protectConfigurationIds: [String]?

        @inlinable
        public init(filters: [ProtectConfigurationFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, protectConfigurationIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.protectConfigurationIds = protectConfigurationIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.protectConfigurationIds?.forEach {
                try validate($0, name: "protectConfigurationIds[]", parent: name, max: 256)
                try validate($0, name: "protectConfigurationIds[]", parent: name, min: 1)
                try validate($0, name: "protectConfigurationIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.protectConfigurationIds, name: "protectConfigurationIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case protectConfigurationIds = "ProtectConfigurationIds"
        }
    }

    public struct DescribeProtectConfigurationsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of ProtectConfigurationInformation objects that contain the details for the request.
        public let protectConfigurations: [ProtectConfigurationInformation]?

        @inlinable
        public init(nextToken: String? = nil, protectConfigurations: [ProtectConfigurationInformation]? = nil) {
            self.nextToken = nextToken
            self.protectConfigurations = protectConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case protectConfigurations = "ProtectConfigurations"
        }
    }

    public struct DescribeRegistrationAttachmentsRequest: AWSEncodableShape {
        /// An array of RegistrationAttachmentFilter objects to filter the results.
        public let filters: [RegistrationAttachmentFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier of registration attachments to find. This is an array of RegistrationAttachmentId.
        public let registrationAttachmentIds: [String]?

        @inlinable
        public init(filters: [RegistrationAttachmentFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationAttachmentIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationAttachmentIds = registrationAttachmentIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.registrationAttachmentIds?.forEach {
                try validate($0, name: "registrationAttachmentIds[]", parent: name, max: 256)
                try validate($0, name: "registrationAttachmentIds[]", parent: name, min: 1)
                try validate($0, name: "registrationAttachmentIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.registrationAttachmentIds, name: "registrationAttachmentIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationAttachmentIds = "RegistrationAttachmentIds"
        }
    }

    public struct DescribeRegistrationAttachmentsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of RegistrationAttachments objects that contain the details for the requested registration attachments.
        public let registrationAttachments: [RegistrationAttachmentsInformation]

        @inlinable
        public init(nextToken: String? = nil, registrationAttachments: [RegistrationAttachmentsInformation]) {
            self.nextToken = nextToken
            self.registrationAttachments = registrationAttachments
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationAttachments = "RegistrationAttachments"
        }
    }

    public struct DescribeRegistrationFieldDefinitionsRequest: AWSEncodableShape {
        /// An array of paths to the registration form field.
        public let fieldPaths: [String]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// The path to the section of the registration.
        public let sectionPath: String?

        @inlinable
        public init(fieldPaths: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationType: String, sectionPath: String? = nil) {
            self.fieldPaths = fieldPaths
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationType = registrationType
            self.sectionPath = sectionPath
        }

        public func validate(name: String) throws {
            try self.fieldPaths?.forEach {
                try validate($0, name: "fieldPaths[]", parent: name, max: 100)
                try validate($0, name: "fieldPaths[]", parent: name, min: 1)
                try validate($0, name: "fieldPaths[]", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            }
            try self.validate(self.fieldPaths, name: "fieldPaths", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationType, name: "registrationType", parent: name, max: 64)
            try self.validate(self.registrationType, name: "registrationType", parent: name, min: 1)
            try self.validate(self.registrationType, name: "registrationType", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, max: 100)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, min: 1)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, pattern: "^[A-Za-z0-9_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPaths = "FieldPaths"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationType = "RegistrationType"
            case sectionPath = "SectionPath"
        }
    }

    public struct DescribeRegistrationFieldDefinitionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of RegistrationFieldDefinitions objects that contain the details for the requested fields.
        public let registrationFieldDefinitions: [RegistrationFieldDefinition]
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        @inlinable
        public init(nextToken: String? = nil, registrationFieldDefinitions: [RegistrationFieldDefinition], registrationType: String) {
            self.nextToken = nextToken
            self.registrationFieldDefinitions = registrationFieldDefinitions
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationFieldDefinitions = "RegistrationFieldDefinitions"
            case registrationType = "RegistrationType"
        }
    }

    public struct DescribeRegistrationFieldValuesRequest: AWSEncodableShape {
        /// An array of paths to the registration form field.
        public let fieldPaths: [String]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The path to the section of the registration.
        public let sectionPath: String?
        /// The version number of the registration.
        public let versionNumber: Int64?

        @inlinable
        public init(fieldPaths: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationId: String, sectionPath: String? = nil, versionNumber: Int64? = nil) {
            self.fieldPaths = fieldPaths
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationId = registrationId
            self.sectionPath = sectionPath
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.fieldPaths?.forEach {
                try validate($0, name: "fieldPaths[]", parent: name, max: 100)
                try validate($0, name: "fieldPaths[]", parent: name, min: 1)
                try validate($0, name: "fieldPaths[]", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            }
            try self.validate(self.fieldPaths, name: "fieldPaths", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, max: 100)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, min: 1)
            try self.validate(self.sectionPath, name: "sectionPath", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, max: 100000)
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPaths = "FieldPaths"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationId = "RegistrationId"
            case sectionPath = "SectionPath"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DescribeRegistrationFieldValuesResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// An array of RegistrationFieldValues objects that contain the values for the requested registration.
        public let registrationFieldValues: [RegistrationFieldValueInformation]
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The current version of the registration.
        public let versionNumber: Int64

        @inlinable
        public init(nextToken: String? = nil, registrationArn: String, registrationFieldValues: [RegistrationFieldValueInformation], registrationId: String, versionNumber: Int64) {
            self.nextToken = nextToken
            self.registrationArn = registrationArn
            self.registrationFieldValues = registrationFieldValues
            self.registrationId = registrationId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationArn = "RegistrationArn"
            case registrationFieldValues = "RegistrationFieldValues"
            case registrationId = "RegistrationId"
            case versionNumber = "VersionNumber"
        }
    }

    public struct DescribeRegistrationSectionDefinitionsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// An array of paths for the registration form section.
        public let sectionPaths: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, registrationType: String, sectionPaths: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationType = registrationType
            self.sectionPaths = sectionPaths
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationType, name: "registrationType", parent: name, max: 64)
            try self.validate(self.registrationType, name: "registrationType", parent: name, min: 1)
            try self.validate(self.registrationType, name: "registrationType", parent: name, pattern: "^[A-Za-z0-9_]+$")
            try self.sectionPaths?.forEach {
                try validate($0, name: "sectionPaths[]", parent: name, max: 100)
                try validate($0, name: "sectionPaths[]", parent: name, min: 1)
                try validate($0, name: "sectionPaths[]", parent: name, pattern: "^[A-Za-z0-9_]+$")
            }
            try self.validate(self.sectionPaths, name: "sectionPaths", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationType = "RegistrationType"
            case sectionPaths = "SectionPaths"
        }
    }

    public struct DescribeRegistrationSectionDefinitionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of  RegistrationSectionDefinition objects.
        public let registrationSectionDefinitions: [RegistrationSectionDefinition]
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        @inlinable
        public init(nextToken: String? = nil, registrationSectionDefinitions: [RegistrationSectionDefinition], registrationType: String) {
            self.nextToken = nextToken
            self.registrationSectionDefinitions = registrationSectionDefinitions
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationSectionDefinitions = "RegistrationSectionDefinitions"
            case registrationType = "RegistrationType"
        }
    }

    public struct DescribeRegistrationTypeDefinitionsRequest: AWSEncodableShape {
        /// An array of RegistrationFilter objects to filter the results.
        public let filters: [RegistrationTypeFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationTypes: [String]?

        @inlinable
        public init(filters: [RegistrationTypeFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationTypes: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationTypes = registrationTypes
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.registrationTypes?.forEach {
                try validate($0, name: "registrationTypes[]", parent: name, max: 64)
                try validate($0, name: "registrationTypes[]", parent: name, min: 1)
                try validate($0, name: "registrationTypes[]", parent: name, pattern: "^[A-Za-z0-9_]+$")
            }
            try self.validate(self.registrationTypes, name: "registrationTypes", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationTypes = "RegistrationTypes"
        }
    }

    public struct DescribeRegistrationTypeDefinitionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationTypeDefinitions: [RegistrationTypeDefinition]

        @inlinable
        public init(nextToken: String? = nil, registrationTypeDefinitions: [RegistrationTypeDefinition]) {
            self.nextToken = nextToken
            self.registrationTypeDefinitions = registrationTypeDefinitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationTypeDefinitions = "RegistrationTypeDefinitions"
        }
    }

    public struct DescribeRegistrationVersionsRequest: AWSEncodableShape {
        /// An array of RegistrationVersionFilter objects to filter the results.
        public let filters: [RegistrationVersionFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of registration version numbers.
        public let versionNumbers: [Int64]?

        @inlinable
        public init(filters: [RegistrationVersionFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationId: String, versionNumbers: [Int64]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationId = registrationId
            self.versionNumbers = versionNumbers
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.versionNumbers?.forEach {
                try validate($0, name: "versionNumbers[]", parent: name, max: 100000)
                try validate($0, name: "versionNumbers[]", parent: name, min: 1)
            }
            try self.validate(self.versionNumbers, name: "versionNumbers", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationId = "RegistrationId"
            case versionNumbers = "VersionNumbers"
        }
    }

    public struct DescribeRegistrationVersionsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of RegistrationVersions objects.
        public let registrationVersions: [RegistrationVersionInformation]

        @inlinable
        public init(nextToken: String? = nil, registrationArn: String, registrationId: String, registrationVersions: [RegistrationVersionInformation]) {
            self.nextToken = nextToken
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersions = registrationVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersions = "RegistrationVersions"
        }
    }

    public struct DescribeRegistrationsRequest: AWSEncodableShape {
        /// An array of RegistrationFilter objects to filter the results.
        public let filters: [RegistrationFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of unique identifiers for each registration.
        public let registrationIds: [String]?

        @inlinable
        public init(filters: [RegistrationFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationIds = registrationIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.registrationIds?.forEach {
                try validate($0, name: "registrationIds[]", parent: name, max: 256)
                try validate($0, name: "registrationIds[]", parent: name, min: 1)
                try validate($0, name: "registrationIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.registrationIds, name: "registrationIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationIds = "RegistrationIds"
        }
    }

    public struct DescribeRegistrationsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of RegistrationInformation objects.
        public let registrations: [RegistrationInformation]

        @inlinable
        public init(nextToken: String? = nil, registrations: [RegistrationInformation]) {
            self.nextToken = nextToken
            self.registrations = registrations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrations = "Registrations"
        }
    }

    public struct DescribeSenderIdsRequest: AWSEncodableShape {
        /// An array of SenderIdFilter objects to filter the results.
        public let filters: [SenderIdFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// Use SELF to filter the list of Sender Ids to ones your account owns or use SHARED to filter on Sender Ids shared with your account. The Owner and SenderIds parameters can't be used at the same time.
        public let owner: Owner?
        /// An array of SenderIdAndCountry objects to search for.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let senderIds: [SenderIdAndCountry]?

        @inlinable
        public init(filters: [SenderIdFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Owner? = nil, senderIds: [SenderIdAndCountry]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
            self.senderIds = senderIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.senderIds?.forEach {
                try $0.validate(name: "\(name).senderIds[]")
            }
            try self.validate(self.senderIds, name: "senderIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case owner = "Owner"
            case senderIds = "SenderIds"
        }
    }

    public struct DescribeSenderIdsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of SernderIdInformation objects that contain the details for the requested SenderIds.
        public let senderIds: [SenderIdInformation]?

        @inlinable
        public init(nextToken: String? = nil, senderIds: [SenderIdInformation]? = nil) {
            self.nextToken = nextToken
            self.senderIds = senderIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case senderIds = "SenderIds"
        }
    }

    public struct DescribeSpendLimitsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeSpendLimitsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of SpendLimit objects that contain the details for the requested spend limits.
        public let spendLimits: [SpendLimit]?

        @inlinable
        public init(nextToken: String? = nil, spendLimits: [SpendLimit]? = nil) {
            self.nextToken = nextToken
            self.spendLimits = spendLimits
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case spendLimits = "SpendLimits"
        }
    }

    public struct DescribeVerifiedDestinationNumbersRequest: AWSEncodableShape {
        /// An array of verified destination phone number, in E.164 format.
        public let destinationPhoneNumbers: [String]?
        /// An array of VerifiedDestinationNumberFilter objects to filter the results.
        public let filters: [VerifiedDestinationNumberFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of VerifiedDestinationNumberid to retrieve.
        public let verifiedDestinationNumberIds: [String]?

        @inlinable
        public init(destinationPhoneNumbers: [String]? = nil, filters: [VerifiedDestinationNumberFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, verifiedDestinationNumberIds: [String]? = nil) {
            self.destinationPhoneNumbers = destinationPhoneNumbers
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.verifiedDestinationNumberIds = verifiedDestinationNumberIds
        }

        public func validate(name: String) throws {
            try self.destinationPhoneNumbers?.forEach {
                try validate($0, name: "destinationPhoneNumbers[]", parent: name, max: 20)
                try validate($0, name: "destinationPhoneNumbers[]", parent: name, min: 1)
                try validate($0, name: "destinationPhoneNumbers[]", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            }
            try self.validate(self.destinationPhoneNumbers, name: "destinationPhoneNumbers", parent: name, max: 5)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.verifiedDestinationNumberIds?.forEach {
                try validate($0, name: "verifiedDestinationNumberIds[]", parent: name, max: 256)
                try validate($0, name: "verifiedDestinationNumberIds[]", parent: name, min: 1)
                try validate($0, name: "verifiedDestinationNumberIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.verifiedDestinationNumberIds, name: "verifiedDestinationNumberIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPhoneNumbers = "DestinationPhoneNumbers"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case verifiedDestinationNumberIds = "VerifiedDestinationNumberIds"
        }
    }

    public struct DescribeVerifiedDestinationNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of VerifiedDestinationNumberInformation objects
        public let verifiedDestinationNumbers: [VerifiedDestinationNumberInformation]

        @inlinable
        public init(nextToken: String? = nil, verifiedDestinationNumbers: [VerifiedDestinationNumberInformation]) {
            self.nextToken = nextToken
            self.verifiedDestinationNumbers = verifiedDestinationNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case verifiedDestinationNumbers = "VerifiedDestinationNumbers"
        }
    }

    public struct DisassociateOriginationIdentityRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers find the values for PhoneNumberId and PhoneNumberArn, or use DescribeSenderIds to get the values for SenderId and SenderIdArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String
        /// The unique identifier for the pool to disassociate with the origination identity. This value can be either the PoolId or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let poolId: String

        @inlinable
        public init(clientToken: String? = DisassociateOriginationIdentityRequest.idempotencyToken(), isoCountryCode: String, originationIdentity: String, poolId: String) {
            self.clientToken = clientToken
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case poolId = "PoolId"
        }
    }

    public struct DisassociateOriginationIdentityResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The PhoneNumberId or SenderId of the origination identity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or SenderIdArn of the origination identity.
        public let originationIdentityArn: String?
        /// The Amazon Resource Name (ARN) of the pool.
        public let poolArn: String?
        /// The PoolId of the pool no longer associated with the origination identity.
        public let poolId: String?

        @inlinable
        public init(isoCountryCode: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct DisassociateProtectConfigurationRequest: AWSEncodableShape {
        /// The name of the ConfigurationSet.
        public let configurationSetName: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(configurationSetName: String, protectConfigurationId: String) {
            self.configurationSetName = configurationSetName
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct DisassociateProtectConfigurationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String
        /// The name of the ConfigurationSet.
        public let configurationSetName: String
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(configurationSetArn: String, configurationSetName: String, protectConfigurationArn: String, protectConfigurationId: String) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct DiscardRegistrationVersionRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct DiscardRegistrationVersionResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration version.    APPROVED: Your registration has been approved.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.    DENIED: You must fix your registration and resubmit it.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DRAFT: The initial status of a registration version after its created.    REQUIRES_AUTHENTICATION: You need to complete email authentication.    REVIEWING: Your registration has been accepted and is being reviewed.    REVOKED: Your previously approved registration has been revoked.    SUBMITTED: Your registration has been submitted.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The version number of the registration.
        public let versionNumber: Int64

        @inlinable
        public init(registrationArn: String, registrationId: String, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct EventDestination: AWSDecodableShape {
        /// An object that contains information about an event destination that sends logging events to Amazon CloudWatch logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// When set to true events will be logged.
        public let enabled: Bool
        /// The name of the EventDestination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Amazon Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log.  The TEXT_SENT event type is not supported.
        public let matchingEventTypes: [EventType]
        /// An object that contains information about an event destination that sends logging events to Amazon SNS.
        public let snsDestination: SnsDestination?

        @inlinable
        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, enabled: Bool, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType], snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case enabled = "Enabled"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct GetProtectConfigurationCountryRuleSetRequest: AWSEncodableShape {
        /// The capability type to return the CountryRuleSet for. Valid values are SMS, VOICE, or MMS.
        public let numberCapability: NumberCapability
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(numberCapability: NumberCapability, protectConfigurationId: String) {
            self.numberCapability = numberCapability
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case numberCapability = "NumberCapability"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct GetProtectConfigurationCountryRuleSetResult: AWSDecodableShape {
        /// A map of ProtectConfigurationCountryRuleSetInformation objects that contain the details for the requested NumberCapability. The Key is the two-letter ISO country code. For a list of supported ISO country codes, see Supported countries and regions (SMS channel) in the AWS End User Messaging SMS User Guide.
        public let countryRuleSet: [String: ProtectConfigurationCountryRuleSetInformation]
        /// The capability type associated with the returned ProtectConfigurationCountryRuleSetInformation objects.
        public let numberCapability: NumberCapability
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(countryRuleSet: [String: ProtectConfigurationCountryRuleSetInformation], numberCapability: NumberCapability, protectConfigurationArn: String, protectConfigurationId: String) {
            self.countryRuleSet = countryRuleSet
            self.numberCapability = numberCapability
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case countryRuleSet = "CountryRuleSet"
            case numberCapability = "NumberCapability"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource attached to the resource-based policy.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetResourcePolicyResult: AWSDecodableShape {
        /// The time when the resource-based policy was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The JSON formatted string that contains the resource-based policy attached to the AWS End User Messaging SMS and Voice resource.
        public let policy: String?
        /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource attached to the resource-based policy.
        public let resourceArn: String?

        @inlinable
        public init(createdTimestamp: Date? = nil, policy: String? = nil, resourceArn: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.policy = policy
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case policy = "Policy"
            case resourceArn = "ResourceArn"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String?
        /// The unique identifier of the request.
        public let requestId: String?

        @inlinable
        public init(message: String? = nil, requestId: String? = nil) {
            self.message = message
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case requestId = "RequestId"
        }
    }

    public struct KeywordFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: KeywordFilterName
        /// An array values to filter for.
        public let values: [String]

        @inlinable
        public init(name: KeywordFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct KeywordInformation: AWSDecodableShape {
        /// The keyword as a string.
        public let keyword: String
        /// The action to perform for the keyword.
        public let keywordAction: KeywordAction
        /// A custom message that can be used with the keyword.
        public let keywordMessage: String

        @inlinable
        public init(keyword: String, keywordAction: KeywordAction, keywordMessage: String) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
        }
    }

    public struct KinesisFirehoseDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let deliveryStreamArn: String
        /// The ARN of an Identity and Access Management role that is able to write event data to an Amazon Data Firehose destination.
        public let iamRoleArn: String

        @inlinable
        public init(deliveryStreamArn: String, iamRoleArn: String) {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, max: 2048)
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, min: 20)
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, pattern: "^arn:\\S+$")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 2048)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 20)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStreamArn = "DeliveryStreamArn"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct ListPoolOriginationIdentitiesRequest: AWSEncodableShape {
        /// An array of PoolOriginationIdentitiesFilter objects to filter the results..
        public let filters: [PoolOriginationIdentitiesFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the pool. This value can be either the PoolId or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let poolId: String

        @inlinable
        public init(filters: [PoolOriginationIdentitiesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, poolId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case poolId = "PoolId"
        }
    }

    public struct ListPoolOriginationIdentitiesResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of any OriginationIdentityMetadata objects.
        public let originationIdentities: [OriginationIdentityMetadata]?
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String?
        /// The unique PoolId of the pool.
        public let poolId: String?

        @inlinable
        public init(nextToken: String? = nil, originationIdentities: [OriginationIdentityMetadata]? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.nextToken = nextToken
            self.originationIdentities = originationIdentities
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case originationIdentities = "OriginationIdentities"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct ListProtectConfigurationRuleSetNumberOverridesRequest: AWSEncodableShape {
        /// An array of ProtectConfigurationRuleSetNumberOverrideFilterItem objects to filter the results.
        public let filters: [ProtectConfigurationRuleSetNumberOverrideFilterItem]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(filters: [ProtectConfigurationRuleSetNumberOverrideFilterItem]? = nil, maxResults: Int? = nil, nextToken: String? = nil, protectConfigurationId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct ListProtectConfigurationRuleSetNumberOverridesResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String
        /// An array of RuleSetNumberOverrides objects.
        public let ruleSetNumberOverrides: [ProtectConfigurationRuleSetNumberOverride]?

        @inlinable
        public init(nextToken: String? = nil, protectConfigurationArn: String, protectConfigurationId: String, ruleSetNumberOverrides: [ProtectConfigurationRuleSetNumberOverride]? = nil) {
            self.nextToken = nextToken
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
            self.ruleSetNumberOverrides = ruleSetNumberOverrides
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
            case ruleSetNumberOverrides = "RuleSetNumberOverrides"
        }
    }

    public struct ListRegistrationAssociationsRequest: AWSEncodableShape {
        /// An array of RegistrationAssociationFilter to apply to the results that are returned.
        public let filters: [RegistrationAssociationFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(filters: [RegistrationAssociationFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, registrationId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registrationId = "RegistrationId"
        }
    }

    public struct ListRegistrationAssociationsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// An array of RegistrationAssociationMetadata objects.
        public let registrationAssociations: [RegistrationAssociationMetadata]
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        @inlinable
        public init(nextToken: String? = nil, registrationArn: String, registrationAssociations: [RegistrationAssociationMetadata], registrationId: String, registrationType: String) {
            self.nextToken = nextToken
            self.registrationArn = registrationArn
            self.registrationAssociations = registrationAssociations
            self.registrationId = registrationId
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registrationArn = "RegistrationArn"
            case registrationAssociations = "RegistrationAssociations"
            case registrationId = "RegistrationId"
            case registrationType = "RegistrationType"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to query for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// The ARN of the resource.
        public let resourceArn: String?
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]?

        @inlinable
        public init(resourceArn: String? = nil, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct OptOutListInformation: AWSDecodableShape {
        /// The time when the OutOutList was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) of the OptOutList.
        public let optOutListArn: String
        /// The name of the OptOutList.
        public let optOutListName: String

        @inlinable
        public init(createdTimestamp: Date, optOutListArn: String, optOutListName: String) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct OptedOutFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: OptedOutFilterName
        /// An array of values to filter for.
        public let values: [String]

        @inlinable
        public init(name: OptedOutFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct OptedOutNumberInformation: AWSDecodableShape {
        /// This is set to true if it was the end recipient that opted out.
        public let endUserOptedOut: Bool
        /// The phone number that is opted out.
        public let optedOutNumber: String
        /// The time that the op tout occurred, in UNIX epoch time format.
        public let optedOutTimestamp: Date

        @inlinable
        public init(endUserOptedOut: Bool, optedOutNumber: String, optedOutTimestamp: Date) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
        }
    }

    public struct OriginationIdentityMetadata: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        public let numberCapabilities: [NumberCapability]
        /// The unique identifier of the origination identity.
        public let originationIdentity: String
        /// The Amazon Resource Name (ARN) associated with the origination identity.
        public let originationIdentityArn: String
        /// The phone number in E.164 format.
        public let phoneNumber: String?

        @inlinable
        public init(isoCountryCode: String, numberCapabilities: [NumberCapability], originationIdentity: String, originationIdentityArn: String, phoneNumber: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.numberCapabilities = numberCapabilities
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.phoneNumber = phoneNumber
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case numberCapabilities = "NumberCapabilities"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct PhoneNumberFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PhoneNumberFilterName
        /// An array values to filter for.
        public let values: [String]

        @inlinable
        public init(name: PhoneNumberFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PhoneNumberInformation: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The price, in US dollars, to lease the phone number.
        public let monthlyLeasingPrice: String
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        public let numberCapabilities: [NumberCapability]
        /// The type of phone number.
        public let numberType: NumberType
        /// The name of the OptOutList associated with the phone number.
        public let optOutListName: String
        /// The phone number in E.164 format.
        public let phoneNumber: String
        /// The Amazon Resource Name (ARN) associated with the phone number.
        public let phoneNumberArn: String
        /// The unique identifier for the phone number.
        public let phoneNumberId: String?
        /// The unique identifier of the pool associated with the phone number.
        public let poolId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// When set to false an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out request. For more information see Self-managed opt-outs
        public let selfManagedOptOutsEnabled: Bool
        /// The current status of the phone number.
        public let status: NumberStatus
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        public let twoWayEnabled: Bool

        @inlinable
        public init(createdTimestamp: Date, deletionProtectionEnabled: Bool, isoCountryCode: String, messageType: MessageType, monthlyLeasingPrice: String, numberCapabilities: [NumberCapability], numberType: NumberType, optOutListName: String, phoneNumber: String, phoneNumberArn: String, phoneNumberId: String? = nil, poolId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool, status: NumberStatus, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case poolId = "PoolId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct PoolFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PoolFilterName
        /// An array values to filter for.
        public let values: [String]

        @inlinable
        public init(name: PoolFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PoolInformation: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String
        /// The unique identifier for the pool.
        public let poolId: String
        /// When set to false, an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests. For more information see Self-managed opt-outs
        public let selfManagedOptOutsEnabled: Bool
        /// Allows you to enable shared routes on your pool. By default, this is set to False. If you set this value to True, your messages are sent using phone numbers or sender IDs (depending on the country) that are shared with other users. In some countries, such as the United States, senders aren't allowed to use shared routes and must use a dedicated phone number or short code.
        public let sharedRoutesEnabled: Bool
        /// The current status of the pool.
        public let status: PoolStatus
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        public let twoWayEnabled: Bool

        @inlinable
        public init(createdTimestamp: Date, deletionProtectionEnabled: Bool, messageType: MessageType, optOutListName: String, poolArn: String, poolId: String, selfManagedOptOutsEnabled: Bool, sharedRoutesEnabled: Bool, status: PoolStatus, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct PoolOriginationIdentitiesFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PoolOriginationIdentitiesFilterName
        /// An array values to filter for.
        public let values: [String]

        @inlinable
        public init(name: PoolOriginationIdentitiesFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ProtectConfigurationCountryRuleSetInformation: AWSEncodableShape & AWSDecodableShape {
        /// The types of protection that can be used.
        public let protectStatus: ProtectStatus

        @inlinable
        public init(protectStatus: ProtectStatus) {
            self.protectStatus = protectStatus
        }

        private enum CodingKeys: String, CodingKey {
            case protectStatus = "ProtectStatus"
        }
    }

    public struct ProtectConfigurationFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: ProtectConfigurationFilterName
        /// An array of values to filter for.
        public let values: [String]

        @inlinable
        public init(name: ProtectConfigurationFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ProtectConfigurationInformation: AWSDecodableShape {
        /// This is true if the protect configuration is set as your account default protect configuration.
        public let accountDefault: Bool
        /// The time when the protect configuration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The status of deletion protection for the protect configuration. When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(accountDefault: Bool, createdTimestamp: Date, deletionProtectionEnabled: Bool, protectConfigurationArn: String, protectConfigurationId: String) {
            self.accountDefault = accountDefault
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case accountDefault = "AccountDefault"
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct ProtectConfigurationRuleSetNumberOverride: AWSDecodableShape {
        /// The action for the rule to perform of either blocking or allowing messages to the destination phone number.
        public let action: ProtectConfigurationRuleOverrideAction
        /// The time when the rule was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// The time the rule will expire at. If ExpirationTimestamp is not set then the rule will not expire.
        public let expirationTimestamp: Date?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?

        @inlinable
        public init(action: ProtectConfigurationRuleOverrideAction, createdTimestamp: Date, destinationPhoneNumber: String, expirationTimestamp: Date? = nil, isoCountryCode: String? = nil) {
            self.action = action
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.expirationTimestamp = expirationTimestamp
            self.isoCountryCode = isoCountryCode
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case expirationTimestamp = "ExpirationTimestamp"
            case isoCountryCode = "IsoCountryCode"
        }
    }

    public struct ProtectConfigurationRuleSetNumberOverrideFilterItem: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: ProtectConfigurationRuleSetNumberOverrideFilterName
        /// An array values to filter for.
        public let values: [String]

        @inlinable
        public init(name: ProtectConfigurationRuleSetNumberOverrideFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PutKeywordRequest: AWSEncodableShape {
        /// The new keyword to add.
        public let keyword: String
        /// The action to perform for the new keyword when it is received.   AUTOMATIC_RESPONSE: A message is sent to the recipient.   OPT_OUT: Keeps the recipient from receiving future messages.   OPT_IN: The recipient wants to receive future messages.
        public let keywordAction: KeywordAction?
        /// The message associated with the keyword.
        public let keywordMessage: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers get the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String

        @inlinable
        public init(keyword: String, keywordAction: KeywordAction? = nil, keywordMessage: String, originationIdentity: String) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, max: 1600)
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, min: 1)
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct PutKeywordResult: AWSDecodableShape {
        /// The keyword that was added.
        public let keyword: String?
        /// The action to perform when the keyword is used.
        public let keywordAction: KeywordAction?
        /// The message associated with the keyword.
        public let keywordMessage: String?
        /// The PhoneNumberId or PoolId that the keyword was associated with.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that the keyword was associated with.
        public let originationIdentityArn: String?

        @inlinable
        public init(keyword: String? = nil, keywordAction: KeywordAction? = nil, keywordMessage: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct PutMessageFeedbackRequest: AWSEncodableShape {
        /// Set the message feedback to be either RECEIVED or FAILED.
        public let messageFeedbackStatus: MessageFeedbackStatus
        /// The unique identifier for the message.
        public let messageId: String

        @inlinable
        public init(messageFeedbackStatus: MessageFeedbackStatus, messageId: String) {
            self.messageFeedbackStatus = messageFeedbackStatus
            self.messageId = messageId
        }

        public func validate(name: String) throws {
            try self.validate(self.messageId, name: "messageId", parent: name, max: 64)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case messageFeedbackStatus = "MessageFeedbackStatus"
            case messageId = "MessageId"
        }
    }

    public struct PutMessageFeedbackResult: AWSDecodableShape {
        /// The current status of the message.
        public let messageFeedbackStatus: MessageFeedbackStatus
        /// The unique identifier for the message.
        public let messageId: String

        @inlinable
        public init(messageFeedbackStatus: MessageFeedbackStatus, messageId: String) {
            self.messageFeedbackStatus = messageFeedbackStatus
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageFeedbackStatus = "MessageFeedbackStatus"
            case messageId = "MessageId"
        }
    }

    public struct PutOptedOutNumberRequest: AWSEncodableShape {
        /// The phone number to add to the OptOutList in E.164 format.
        public let optedOutNumber: String
        /// The OptOutListName or OptOutListArn to add the phone number to.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let optOutListName: String

        @inlinable
        public init(optedOutNumber: String, optOutListName: String) {
            self.optedOutNumber = optedOutNumber
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, max: 20)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, min: 1)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optedOutNumber = "OptedOutNumber"
            case optOutListName = "OptOutListName"
        }
    }

    public struct PutOptedOutNumberResult: AWSDecodableShape {
        /// This is true if it was the end user who requested their phone number be removed.
        public let endUserOptedOut: Bool?
        /// The phone number that was added to the OptOutList.
        public let optedOutNumber: String?
        /// The time that the phone number was added to the OptOutList, in UNIX epoch time format.
        public let optedOutTimestamp: Date?
        /// The OptOutListArn that the phone number was removed from.
        public let optOutListArn: String?
        /// The OptOutListName that the phone number was removed from.
        public let optOutListName: String?

        @inlinable
        public init(endUserOptedOut: Bool? = nil, optedOutNumber: String? = nil, optedOutTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct PutProtectConfigurationRuleSetNumberOverrideRequest: AWSEncodableShape {
        /// The action for the rule to either block or allow messages to the destination phone number.
        public let action: ProtectConfigurationRuleOverrideAction
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// The time the rule will expire at. If ExpirationTimestamp is not set then the rule does not expire.
        public let expirationTimestamp: Date?
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(action: ProtectConfigurationRuleOverrideAction, clientToken: String? = PutProtectConfigurationRuleSetNumberOverrideRequest.idempotencyToken(), destinationPhoneNumber: String, expirationTimestamp: Date? = nil, protectConfigurationId: String) {
            self.action = action
            self.clientToken = clientToken
            self.destinationPhoneNumber = destinationPhoneNumber
            self.expirationTimestamp = expirationTimestamp
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case clientToken = "ClientToken"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case expirationTimestamp = "ExpirationTimestamp"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct PutProtectConfigurationRuleSetNumberOverrideResult: AWSDecodableShape {
        /// The action for the rule to take.
        public let action: ProtectConfigurationRuleOverrideAction
        /// The time when the rule was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// The time the rule will expire at.
        public let expirationTimestamp: Date?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(action: ProtectConfigurationRuleOverrideAction, createdTimestamp: Date, destinationPhoneNumber: String, expirationTimestamp: Date? = nil, isoCountryCode: String? = nil, protectConfigurationArn: String, protectConfigurationId: String) {
            self.action = action
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.expirationTimestamp = expirationTimestamp
            self.isoCountryCode = isoCountryCode
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case expirationTimestamp = "ExpirationTimestamp"
            case isoCountryCode = "IsoCountryCode"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct PutRegistrationFieldValueRequest: AWSEncodableShape {
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?

        @inlinable
        public init(fieldPath: String, registrationAttachmentId: String? = nil, registrationId: String, selectChoices: [String]? = nil, textValue: String? = nil) {
            self.fieldPath = fieldPath
            self.registrationAttachmentId = registrationAttachmentId
            self.registrationId = registrationId
            self.selectChoices = selectChoices
            self.textValue = textValue
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, max: 100)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, min: 1)
            try self.validate(self.fieldPath, name: "fieldPath", parent: name, pattern: "^[A-Za-z0-9_\\.]+$")
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, max: 256)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, min: 1)
            try self.validate(self.registrationAttachmentId, name: "registrationAttachmentId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.selectChoices?.forEach {
                try validate($0, name: "selectChoices[]", parent: name, max: 256)
                try validate($0, name: "selectChoices[]", parent: name, min: 1)
            }
            try self.validate(self.selectChoices, name: "selectChoices", parent: name, max: 100)
            try self.validate(self.textValue, name: "textValue", parent: name, max: 2048)
            try self.validate(self.textValue, name: "textValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case registrationId = "RegistrationId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
        }
    }

    public struct PutRegistrationFieldValueResult: AWSDecodableShape {
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// The unique identifier for the registration.
        public let registrationId: String
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?
        /// The version number of the registration.
        public let versionNumber: Int64

        @inlinable
        public init(fieldPath: String, registrationArn: String, registrationAttachmentId: String? = nil, registrationId: String, selectChoices: [String]? = nil, textValue: String? = nil, versionNumber: Int64) {
            self.fieldPath = fieldPath
            self.registrationArn = registrationArn
            self.registrationAttachmentId = registrationAttachmentId
            self.registrationId = registrationId
            self.selectChoices = selectChoices
            self.textValue = textValue
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case fieldPath = "FieldPath"
            case registrationArn = "RegistrationArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case registrationId = "RegistrationId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
            case versionNumber = "VersionNumber"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// The JSON formatted resource-based policy to attach.
        public let policy: String
        /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource to attach the resource-based policy to.
        public let resourceArn: String

        @inlinable
        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 10000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
            case resourceArn = "ResourceArn"
        }
    }

    public struct PutResourcePolicyResult: AWSDecodableShape {
        /// The time when the resource-based policy was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The JSON formatted Resource Policy.
        public let policy: String?
        /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource attached to the resource-based policy.
        public let resourceArn: String?

        @inlinable
        public init(createdTimestamp: Date? = nil, policy: String? = nil, resourceArn: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.policy = policy
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case policy = "Policy"
            case resourceArn = "ResourceArn"
        }
    }

    public struct RegistrationAssociationFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationAssociationFilterName
        /// An array of values to filter for.
        public let values: [String]

        @inlinable
        public init(name: RegistrationAssociationFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationAssociationMetadata: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The phone number associated with the registration in E.164 format.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
        public let resourceArn: String
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        public let resourceId: String
        /// The origination identity type.
        public let resourceType: String

        @inlinable
        public init(isoCountryCode: String? = nil, phoneNumber: String? = nil, resourceArn: String, resourceId: String, resourceType: String) {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case phoneNumber = "PhoneNumber"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RegistrationAttachmentFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationAttachmentFilterName
        /// An array of values to filter on.
        public let values: [String]

        @inlinable
        public init(name: RegistrationAttachmentFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationAttachmentsInformation: AWSDecodableShape {
        /// The status of the registration attachment.     UPLOAD_IN_PROGRESS The attachment is being uploaded.    UPLOAD_COMPLETE The attachment has been uploaded.    UPLOAD_FAILED The attachment failed to uploaded.    DELETED The attachment has been deleted..
        public let attachmentStatus: AttachmentStatus
        /// A description of why the upload didn't successfully complete.
        public let attachmentUploadErrorReason: AttachmentUploadErrorReason?
        /// The time when the registration attachment was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) for the registration attachment.
        public let registrationAttachmentArn: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String

        @inlinable
        public init(attachmentStatus: AttachmentStatus, attachmentUploadErrorReason: AttachmentUploadErrorReason? = nil, createdTimestamp: Date, registrationAttachmentArn: String, registrationAttachmentId: String) {
            self.attachmentStatus = attachmentStatus
            self.attachmentUploadErrorReason = attachmentUploadErrorReason
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentStatus = "AttachmentStatus"
            case attachmentUploadErrorReason = "AttachmentUploadErrorReason"
            case createdTimestamp = "CreatedTimestamp"
            case registrationAttachmentArn = "RegistrationAttachmentArn"
            case registrationAttachmentId = "RegistrationAttachmentId"
        }
    }

    public struct RegistrationDeniedReasonInformation: AWSDecodableShape {
        /// The link to the document.
        public let documentationLink: String?
        /// The title of the document.
        public let documentationTitle: String?
        /// A long description of the rejection reason.
        public let longDescription: String?
        /// The reason a registration was rejected.
        public let reason: String
        /// A short description of the rejection reason.
        public let shortDescription: String

        @inlinable
        public init(documentationLink: String? = nil, documentationTitle: String? = nil, longDescription: String? = nil, reason: String, shortDescription: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.reason = reason
            self.shortDescription = shortDescription
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case longDescription = "LongDescription"
            case reason = "Reason"
            case shortDescription = "ShortDescription"
        }
    }

    public struct RegistrationFieldDefinition: AWSDecodableShape {
        /// An array of RegistrationFieldDisplayHints objects for the field.
        public let displayHints: RegistrationFieldDisplayHints
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// Specifies if the field for the registration form is required, conditional or optional.
        public let fieldRequirement: FieldRequirement
        /// The type of field.
        public let fieldType: FieldType
        /// The section path of the field.
        public let sectionPath: String
        /// The validation rules for a select field.
        public let selectValidation: SelectValidation?
        /// The validation rules for a text field.
        public let textValidation: TextValidation?

        @inlinable
        public init(displayHints: RegistrationFieldDisplayHints, fieldPath: String, fieldRequirement: FieldRequirement, fieldType: FieldType, sectionPath: String, selectValidation: SelectValidation? = nil, textValidation: TextValidation? = nil) {
            self.displayHints = displayHints
            self.fieldPath = fieldPath
            self.fieldRequirement = fieldRequirement
            self.fieldType = fieldType
            self.sectionPath = sectionPath
            self.selectValidation = selectValidation
            self.textValidation = textValidation
        }

        private enum CodingKeys: String, CodingKey {
            case displayHints = "DisplayHints"
            case fieldPath = "FieldPath"
            case fieldRequirement = "FieldRequirement"
            case fieldType = "FieldType"
            case sectionPath = "SectionPath"
            case selectValidation = "SelectValidation"
            case textValidation = "TextValidation"
        }
    }

    public struct RegistrationFieldDisplayHints: AWSDecodableShape {
        /// The link to the document the display hint is associated with.
        public let documentationLink: String?
        /// The title of the document the display hint is associated with.
        public let documentationTitle: String?
        /// Example text of what the value of a field should contain.
        public let exampleTextValue: String?
        /// A full description of the display hint.
        public let longDescription: String?
        /// An array of SelectOptionDescription objects.
        public let selectOptionDescriptions: [SelectOptionDescription]?
        /// A short description of the display hint.
        public let shortDescription: String
        /// The validation rules for the text field.
        public let textValidationDescription: String?
        /// The title of the display hint.
        public let title: String

        @inlinable
        public init(documentationLink: String? = nil, documentationTitle: String? = nil, exampleTextValue: String? = nil, longDescription: String? = nil, selectOptionDescriptions: [SelectOptionDescription]? = nil, shortDescription: String, textValidationDescription: String? = nil, title: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.exampleTextValue = exampleTextValue
            self.longDescription = longDescription
            self.selectOptionDescriptions = selectOptionDescriptions
            self.shortDescription = shortDescription
            self.textValidationDescription = textValidationDescription
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case exampleTextValue = "ExampleTextValue"
            case longDescription = "LongDescription"
            case selectOptionDescriptions = "SelectOptionDescriptions"
            case shortDescription = "ShortDescription"
            case textValidationDescription = "TextValidationDescription"
            case title = "Title"
        }
    }

    public struct RegistrationFieldValueInformation: AWSDecodableShape {
        /// A description of why the registration was denied.
        public let deniedReason: String?
        /// The path to the registration form field. You can use DescribeRegistrationFieldDefinitions for a list of FieldPaths.
        public let fieldPath: String
        /// The unique identifier for the registration attachment.
        public let registrationAttachmentId: String?
        /// An array of values for the form field.
        public let selectChoices: [String]?
        /// The text data for a free form field.
        public let textValue: String?

        @inlinable
        public init(deniedReason: String? = nil, fieldPath: String, registrationAttachmentId: String? = nil, selectChoices: [String]? = nil, textValue: String? = nil) {
            self.deniedReason = deniedReason
            self.fieldPath = fieldPath
            self.registrationAttachmentId = registrationAttachmentId
            self.selectChoices = selectChoices
            self.textValue = textValue
        }

        private enum CodingKeys: String, CodingKey {
            case deniedReason = "DeniedReason"
            case fieldPath = "FieldPath"
            case registrationAttachmentId = "RegistrationAttachmentId"
            case selectChoices = "SelectChoices"
            case textValue = "TextValue"
        }
    }

    public struct RegistrationFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationFilterName
        /// An array of values to filter on.
        public let values: [String]

        @inlinable
        public init(name: RegistrationFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationInformation: AWSDecodableShape {
        /// Metadata about a given registration which is specific to that registration type.
        public let additionalAttributes: [String: String]?
        /// The version number of the registration that was approved.
        public let approvedVersionNumber: Int64?
        /// The time when the registration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The current version number of the registration.
        public let currentVersionNumber: Int64
        /// The latest version number of the registration that was denied.
        public let latestDeniedVersionNumber: Int64?
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration.    CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.    CREATED: Your registration is created but not submitted.    COMPLETE: Your registration has been approved and your origination identity has been created.    DELETED: The registration has been deleted.    PROVISIONING: Your registration has been approved and your origination identity is being created.    REQUIRES_AUTHENTICATION: You need to complete email authentication.    REQUIRES_UPDATES: You must fix your registration and resubmit it.    REVIEWING: Your registration has been accepted and is being reviewed.    SUBMITTED: Your registration has been submitted and is awaiting review.
        public let registrationStatus: RegistrationStatus
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String

        @inlinable
        public init(additionalAttributes: [String: String]? = nil, approvedVersionNumber: Int64? = nil, createdTimestamp: Date, currentVersionNumber: Int64, latestDeniedVersionNumber: Int64? = nil, registrationArn: String, registrationId: String, registrationStatus: RegistrationStatus, registrationType: String) {
            self.additionalAttributes = additionalAttributes
            self.approvedVersionNumber = approvedVersionNumber
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.latestDeniedVersionNumber = latestDeniedVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "AdditionalAttributes"
            case approvedVersionNumber = "ApprovedVersionNumber"
            case createdTimestamp = "CreatedTimestamp"
            case currentVersionNumber = "CurrentVersionNumber"
            case latestDeniedVersionNumber = "LatestDeniedVersionNumber"
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationStatus = "RegistrationStatus"
            case registrationType = "RegistrationType"
        }
    }

    public struct RegistrationSectionDefinition: AWSDecodableShape {
        /// The path to the section of the registration.
        public let displayHints: RegistrationSectionDisplayHints
        /// The path to the section of the registration.
        public let sectionPath: String

        @inlinable
        public init(displayHints: RegistrationSectionDisplayHints, sectionPath: String) {
            self.displayHints = displayHints
            self.sectionPath = sectionPath
        }

        private enum CodingKeys: String, CodingKey {
            case displayHints = "DisplayHints"
            case sectionPath = "SectionPath"
        }
    }

    public struct RegistrationSectionDisplayHints: AWSDecodableShape {
        /// The link to the document the display hint is associated with.
        public let documentationLink: String?
        /// The title of the document the display hint is associated with.
        public let documentationTitle: String?
        /// A full description of the display hint.
        public let longDescription: String?
        /// A short description of the display hint.
        public let shortDescription: String
        /// The title of the display hint.
        public let title: String

        @inlinable
        public init(documentationLink: String? = nil, documentationTitle: String? = nil, longDescription: String? = nil, shortDescription: String, title: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case longDescription = "LongDescription"
            case shortDescription = "ShortDescription"
            case title = "Title"
        }
    }

    public struct RegistrationTypeDefinition: AWSDecodableShape {
        /// Provides help information on the registration.
        public let displayHints: RegistrationTypeDisplayHints
        /// The type of registration form. The list of RegistrationTypes can be found using the DescribeRegistrationTypeDefinitions action.
        public let registrationType: String
        /// The supported association behavior for the registration type.
        public let supportedAssociations: [SupportedAssociation]?

        @inlinable
        public init(displayHints: RegistrationTypeDisplayHints, registrationType: String, supportedAssociations: [SupportedAssociation]? = nil) {
            self.displayHints = displayHints
            self.registrationType = registrationType
            self.supportedAssociations = supportedAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case displayHints = "DisplayHints"
            case registrationType = "RegistrationType"
            case supportedAssociations = "SupportedAssociations"
        }
    }

    public struct RegistrationTypeDisplayHints: AWSDecodableShape {
        /// The link to the document the display hint is associated with.
        public let documentationLink: String?
        /// The title of the document the display hint is associated with.
        public let documentationTitle: String?
        /// A full description of the display hint.
        public let longDescription: String?
        /// A short description of the display hint.
        public let shortDescription: String?
        /// The title of the display hint.
        public let title: String

        @inlinable
        public init(documentationLink: String? = nil, documentationTitle: String? = nil, longDescription: String? = nil, shortDescription: String? = nil, title: String) {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case documentationLink = "DocumentationLink"
            case documentationTitle = "DocumentationTitle"
            case longDescription = "LongDescription"
            case shortDescription = "ShortDescription"
            case title = "Title"
        }
    }

    public struct RegistrationTypeFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationTypeFilterName
        /// An array of values to filter on.
        public let values: [String]

        @inlinable
        public init(name: RegistrationTypeFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationVersionFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: RegistrationVersionFilterName
        /// An array of values to filter on.
        public let values: [String]

        @inlinable
        public init(name: RegistrationVersionFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct RegistrationVersionInformation: AWSDecodableShape {
        /// An array of RegistrationDeniedReasonInformation objects.
        public let deniedReasons: [RegistrationDeniedReasonInformation]?
        /// The status of the registration.    APPROVED: Your registration has been approved.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.    DENIED: You must fix your registration and resubmit it.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DRAFT: The initial status of a registration version after its created.    REQUIRES_AUTHENTICATION: You need to complete email authentication.    REVIEWING: Your registration has been accepted and is being reviewed.    REVOKED: Your previously approved registration has been revoked.    SUBMITTED: Your registration has been submitted.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The version number of the registration.
        public let versionNumber: Int64

        @inlinable
        public init(deniedReasons: [RegistrationDeniedReasonInformation]? = nil, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.deniedReasons = deniedReasons
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case deniedReasons = "DeniedReasons"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct RegistrationVersionStatusHistory: AWSDecodableShape {
        /// The time when the registration was in the approved state, in UNIX epoch time format.
        public let approvedTimestamp: Date?
        /// The time when the registration was in the archived state, in UNIX epoch time format.
        public let archivedTimestamp: Date?
        /// The time when the registration was in the denied state, in UNIX epoch time format.
        public let deniedTimestamp: Date?
        /// The time when the registration was in the discarded state, in UNIX epoch time format.
        public let discardedTimestamp: Date?
        /// The time when the registration was in the draft state, in UNIX epoch time format.
        public let draftTimestamp: Date
        /// The time when the registration was in the requires authentication state, in UNIX epoch time format.
        public let requiresAuthenticationTimestamp: Date?
        /// The time when the registration was in the reviewing state, in UNIX epoch time format.
        public let reviewingTimestamp: Date?
        /// The time when the registration was in the revoked state, in UNIX epoch time format.
        public let revokedTimestamp: Date?
        /// The time when the registration was in the submitted state, in UNIX epoch time format.
        public let submittedTimestamp: Date?

        @inlinable
        public init(approvedTimestamp: Date? = nil, archivedTimestamp: Date? = nil, deniedTimestamp: Date? = nil, discardedTimestamp: Date? = nil, draftTimestamp: Date, requiresAuthenticationTimestamp: Date? = nil, reviewingTimestamp: Date? = nil, revokedTimestamp: Date? = nil, submittedTimestamp: Date? = nil) {
            self.approvedTimestamp = approvedTimestamp
            self.archivedTimestamp = archivedTimestamp
            self.deniedTimestamp = deniedTimestamp
            self.discardedTimestamp = discardedTimestamp
            self.draftTimestamp = draftTimestamp
            self.requiresAuthenticationTimestamp = requiresAuthenticationTimestamp
            self.reviewingTimestamp = reviewingTimestamp
            self.revokedTimestamp = revokedTimestamp
            self.submittedTimestamp = submittedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case approvedTimestamp = "ApprovedTimestamp"
            case archivedTimestamp = "ArchivedTimestamp"
            case deniedTimestamp = "DeniedTimestamp"
            case discardedTimestamp = "DiscardedTimestamp"
            case draftTimestamp = "DraftTimestamp"
            case requiresAuthenticationTimestamp = "RequiresAuthenticationTimestamp"
            case reviewingTimestamp = "ReviewingTimestamp"
            case revokedTimestamp = "RevokedTimestamp"
            case submittedTimestamp = "SubmittedTimestamp"
        }
    }

    public struct ReleasePhoneNumberRequest: AWSEncodableShape {
        /// The PhoneNumberId or PhoneNumberArn of the phone number to release. You can use DescribePhoneNumbers to get the values for PhoneNumberId and PhoneNumberArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let phoneNumberId: String

        @inlinable
        public init(phoneNumberId: String) {
            self.phoneNumberId = phoneNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, max: 256)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, min: 1)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct ReleasePhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The message type that was associated with the phone number.
        public let messageType: MessageType?
        /// The monthly price of the phone number, in US dollars.
        public let monthlyLeasingPrice: String?
        /// Specifies if the number could be used for text messages, voice, or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was released.
        public let numberType: NumberType?
        /// The name of the OptOutList that was associated with the phone number.
        public let optOutListName: String?
        /// The phone number that was released.
        public let phoneNumber: String?
        /// The PhoneNumberArn of the phone number that was released.
        public let phoneNumberArn: String?
        /// The PhoneNumberId of the phone number that was released.
        public let phoneNumberId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// The Amazon Resource Name (ARN) of the TwoWayChannel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(createdTimestamp: Date? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: NumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct ReleaseSenderIdRequest: AWSEncodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The sender ID to release.
        public let senderId: String

        @inlinable
        public init(isoCountryCode: String, senderId: String) {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 256)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case senderId = "SenderId"
        }
    }

    public struct ReleaseSenderIdResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly price, in US dollars, to lease the sender ID.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered.
        public let registered: Bool
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// The sender ID that was released.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String

        @inlinable
        public init(isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, registrationId: String? = nil, senderId: String, senderIdArn: String) {
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case registrationId = "RegistrationId"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
        }
    }

    public struct RequestPhoneNumberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// Indicates if the phone number will be used for text messages, voice messages, or both.
        public let numberCapabilities: [NumberCapability]
        /// The type of phone number to request.
        public let numberType: RequestableNumberType
        /// The name of the OptOutList to associate with the phone number. You can use the OptOutListName or OptOutListArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let optOutListName: String?
        /// The pool to associated with the phone number. You can use the PoolId or PoolArn.   If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let poolId: String?
        /// Use this field to attach your phone number for an external registration process.
        public let registrationId: String?
        /// An array of tags (key and value pairs) associate with the requested phone number.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = RequestPhoneNumberRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageType: MessageType, numberCapabilities: [NumberCapability], numberType: RequestableNumberType, optOutListName: String? = nil, poolId: String? = nil, registrationId: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.poolId = poolId
            self.registrationId = registrationId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.numberCapabilities, name: "numberCapabilities", parent: name, max: 3)
            try self.validate(self.numberCapabilities, name: "numberCapabilities", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case poolId = "PoolId"
            case registrationId = "RegistrationId"
            case tags = "Tags"
        }
    }

    public struct RequestPhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The monthly price, in US dollars, to lease the phone number.
        public let monthlyLeasingPrice: String?
        /// Indicates if the phone number will be used for text messages, voice messages or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was released.
        public let numberType: RequestableNumberType?
        /// The name of the OptOutList that is associated with the requested phone number.
        public let optOutListName: String?
        /// The new phone number that was requested.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the requested phone number.
        public let phoneNumberArn: String?
        /// The unique identifier of the new phone number.
        public let phoneNumberId: String?
        /// The unique identifier of the pool associated with the phone number
        public let poolId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// An array of key and value pair tags that are associated with the phone number.
        public let tags: [Tag]?
        /// The ARN used to identify the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: RequestableNumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, poolId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, tags: [Tag]? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.tags = tags
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case poolId = "PoolId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case tags = "Tags"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct RequestSenderIdRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]?
        /// The sender ID string to request.
        public let senderId: String
        /// An array of tags (key and value pairs) to associate with the sender ID.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = RequestSenderIdRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageTypes: [MessageType]? = nil, senderId: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.senderId = senderId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.messageTypes, name: "messageTypes", parent: name, max: 2)
            try self.validate(self.senderId, name: "senderId", parent: name, max: 11)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case senderId = "SenderId"
            case tags = "Tags"
        }
    }

    public struct RequestSenderIdResult: AWSDecodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly price, in US dollars, to lease the sender ID.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered.
        public let registered: Bool
        /// The sender ID that was requested.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String
        /// An array of tags (key and value pairs) to associate with the sender ID.
        public let tags: [Tag]?

        @inlinable
        public init(deletionProtectionEnabled: Bool, isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, senderId: String, senderIdArn: String, tags: [Tag]? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.senderId = senderId
            self.senderIdArn = senderIdArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
            case tags = "Tags"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The unique identifier of the resource.
        public let resourceId: String?
        /// The type of resource that caused the exception.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct SelectOptionDescription: AWSDecodableShape {
        /// A description of the option meaning.
        public let description: String?
        /// The value of the option.
        public let option: String
        /// The title of the select option.
        public let title: String?

        @inlinable
        public init(description: String? = nil, option: String, title: String? = nil) {
            self.description = description
            self.option = option
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case option = "Option"
            case title = "Title"
        }
    }

    public struct SelectValidation: AWSDecodableShape {
        /// The maximum number of choices for the select.
        public let maxChoices: Int
        /// The minimum number of choices for the select.
        public let minChoices: Int
        /// An array of strings for the possible selection options.
        public let options: [String]

        @inlinable
        public init(maxChoices: Int, minChoices: Int, options: [String]) {
            self.maxChoices = maxChoices
            self.minChoices = minChoices
            self.options = options
        }

        private enum CodingKeys: String, CodingKey {
            case maxChoices = "MaxChoices"
            case minChoices = "MinChoices"
            case options = "Options"
        }
    }

    public struct SendDestinationNumberVerificationCodeRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see Special requirements for sending SMS messages to recipients in India.
        public let destinationCountryParameters: [DestinationCountryParameterKey: String]?
        /// Choose the language to use for the message.
        public let languageCode: LanguageCode?
        /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String?
        /// Choose to send the verification code as an SMS or voice message.
        public let verificationChannel: VerificationChannel
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        @inlinable
        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationCountryParameters: [DestinationCountryParameterKey: String]? = nil, languageCode: LanguageCode? = nil, originationIdentity: String? = nil, verificationChannel: VerificationChannel, verifiedDestinationNumberId: String) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationCountryParameters = destinationCountryParameters
            self.languageCode = languageCode
            self.originationIdentity = originationIdentity
            self.verificationChannel = verificationChannel
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^(?!\\s)^[\\s\\S]+(?<!\\s)$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.destinationCountryParameters?.forEach {
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, max: 64)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.destinationCountryParameters, name: "destinationCountryParameters", parent: name, max: 10)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, max: 256)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, min: 1)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationCountryParameters = "DestinationCountryParameters"
            case languageCode = "LanguageCode"
            case originationIdentity = "OriginationIdentity"
            case verificationChannel = "VerificationChannel"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct SendDestinationNumberVerificationCodeResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String

        @inlinable
        public init(messageId: String) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendMediaMessageRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
        public let dryRun: Bool?
        /// The maximum amount that you want to spend, in US dollars, per each MMS message.
        public let maxPrice: String?
        /// An array of URLs to each media file to send.  The media files have to be stored in a publicly available S3 bucket. Supported media file formats are listed in MMS file types, size and character limits. For more information on creating an S3 bucket and managing objects, see Creating a bucket and Uploading objects in the S3 user guide.
        public let mediaUrls: [String]?
        /// The text body of the message.
        public let messageBody: String?
        /// Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using PutMessageFeedback.
        public let messageFeedbackEnabled: Bool?
        /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String
        /// The unique identifier of the protect configuration to use.
        public let protectConfigurationId: String?
        /// How long the media message is valid for. By default this is 72 hours.
        public let timeToLive: Int?

        @inlinable
        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationPhoneNumber: String, dryRun: Bool? = nil, maxPrice: String? = nil, mediaUrls: [String]? = nil, messageBody: String? = nil, messageFeedbackEnabled: Bool? = nil, originationIdentity: String, protectConfigurationId: String? = nil, timeToLive: Int? = nil) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationPhoneNumber = destinationPhoneNumber
            self.dryRun = dryRun
            self.maxPrice = maxPrice
            self.mediaUrls = mediaUrls
            self.messageBody = messageBody
            self.messageFeedbackEnabled = messageFeedbackEnabled
            self.originationIdentity = originationIdentity
            self.protectConfigurationId = protectConfigurationId
            self.timeToLive = timeToLive
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^(?!\\s)^[\\s\\S]+(?<!\\s)$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, max: 8)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, min: 2)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, pattern: "^[0-9]{0,2}\\.[0-9]{1,5}$")
            try self.mediaUrls?.forEach {
                try validate($0, name: "mediaUrls[]", parent: name, max: 2048)
                try validate($0, name: "mediaUrls[]", parent: name, min: 1)
                try validate($0, name: "mediaUrls[]", parent: name, pattern: "^s3://([a-z0-9\\.-]{3,63})/(.+)$")
            }
            try self.validate(self.mediaUrls, name: "mediaUrls", parent: name, max: 1)
            try self.validate(self.mediaUrls, name: "mediaUrls", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, max: 1600)
            try self.validate(self.messageBody, name: "messageBody", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, max: 259200)
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case dryRun = "DryRun"
            case maxPrice = "MaxPrice"
            case mediaUrls = "MediaUrls"
            case messageBody = "MessageBody"
            case messageFeedbackEnabled = "MessageFeedbackEnabled"
            case originationIdentity = "OriginationIdentity"
            case protectConfigurationId = "ProtectConfigurationId"
            case timeToLive = "TimeToLive"
        }
    }

    public struct SendMediaMessageResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String?

        @inlinable
        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendTextMessageRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see Special requirements for sending SMS messages to recipients in India.     IN_ENTITY_ID The entity ID or Principal Entity (PE) ID that you received after completing the sender ID registration process.    IN_TEMPLATE_ID The template ID that you received after completing the sender ID registration process.  Make sure that the Template ID that you specify matches your message template exactly. If your message doesn't match the template that you provided during the registration process, the mobile carriers might reject your message.
        public let destinationCountryParameters: [DestinationCountryParameterKey: String]?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// When set to true, the message is checked and validated, but isn't sent to the end recipient. You are not charged for using DryRun. The Message Parts per Second (MPS) limit when using DryRun is five. If your origination identity has a lower MPS limit then the lower MPS limit is used. For more information about MPS limits, see Message Parts per Second (MPS) limits in the AWS End User Messaging SMS User Guide..
        public let dryRun: Bool?
        /// When you register a short code in the US, you must specify a program name. If you dont have a US short code, omit this attribute.
        public let keyword: String?
        /// The maximum amount that you want to spend, in US dollars, per each text message. If the calculated amount to send the text message is greater than MaxPrice, the message is not sent and an error is returned.
        public let maxPrice: String?
        /// The body of the text message.
        public let messageBody: String?
        /// Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using PutMessageFeedback.
        public let messageFeedbackEnabled: Bool?
        /// The type of message. Valid values are            for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String?
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String?
        /// How long the text message is valid for, in seconds. By default this is 72 hours. If the messages isn't handed off before the TTL expires we stop attempting to hand off the message and return TTL_EXPIRED event.
        public let timeToLive: Int?

        @inlinable
        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationCountryParameters: [DestinationCountryParameterKey: String]? = nil, destinationPhoneNumber: String, dryRun: Bool? = nil, keyword: String? = nil, maxPrice: String? = nil, messageBody: String? = nil, messageFeedbackEnabled: Bool? = nil, messageType: MessageType? = nil, originationIdentity: String? = nil, protectConfigurationId: String? = nil, timeToLive: Int? = nil) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationCountryParameters = destinationCountryParameters
            self.destinationPhoneNumber = destinationPhoneNumber
            self.dryRun = dryRun
            self.keyword = keyword
            self.maxPrice = maxPrice
            self.messageBody = messageBody
            self.messageFeedbackEnabled = messageFeedbackEnabled
            self.messageType = messageType
            self.originationIdentity = originationIdentity
            self.protectConfigurationId = protectConfigurationId
            self.timeToLive = timeToLive
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^(?!\\s)^[\\s\\S]+(?<!\\s)$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.destinationCountryParameters?.forEach {
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, max: 64)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.destinationCountryParameters, name: "destinationCountryParameters", parent: name, max: 10)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, max: 8)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, min: 2)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, pattern: "^[0-9]{0,2}\\.[0-9]{1,5}$")
            try self.validate(self.messageBody, name: "messageBody", parent: name, max: 1600)
            try self.validate(self.messageBody, name: "messageBody", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, max: 259200)
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationCountryParameters = "DestinationCountryParameters"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case dryRun = "DryRun"
            case keyword = "Keyword"
            case maxPrice = "MaxPrice"
            case messageBody = "MessageBody"
            case messageFeedbackEnabled = "MessageFeedbackEnabled"
            case messageType = "MessageType"
            case originationIdentity = "OriginationIdentity"
            case protectConfigurationId = "ProtectConfigurationId"
            case timeToLive = "TimeToLive"
        }
    }

    public struct SendTextMessageResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String?

        @inlinable
        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendVoiceMessageRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
        public let dryRun: Bool?
        /// The maximum amount to spend per voice message, in US dollars.
        public let maxPricePerMinute: String?
        /// The text to convert to a voice message.
        public let messageBody: String?
        /// Specifies if the MessageBody field contains text or speech synthesis markup language (SSML).   TEXT: This is the default value. When used the maximum character limit is 3000.   SSML: When used the maximum character limit is 6000 including SSML tagging.
        public let messageBodyTextType: VoiceMessageBodyTextType?
        /// Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using PutMessageFeedback.
        public let messageFeedbackEnabled: Bool?
        /// The origination identity to use for the voice call. This can be the PhoneNumber, PhoneNumberId, PhoneNumberArn, PoolId, or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let originationIdentity: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String?
        /// How long the voice message is valid for. By default this is 72 hours.
        public let timeToLive: Int?
        /// The voice for the Amazon Polly service to use. By default this is set to "MATTHEW".
        public let voiceId: VoiceId?

        @inlinable
        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationPhoneNumber: String, dryRun: Bool? = nil, maxPricePerMinute: String? = nil, messageBody: String? = nil, messageBodyTextType: VoiceMessageBodyTextType? = nil, messageFeedbackEnabled: Bool? = nil, originationIdentity: String, protectConfigurationId: String? = nil, timeToLive: Int? = nil, voiceId: VoiceId? = nil) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationPhoneNumber = destinationPhoneNumber
            self.dryRun = dryRun
            self.maxPricePerMinute = maxPricePerMinute
            self.messageBody = messageBody
            self.messageBodyTextType = messageBodyTextType
            self.messageFeedbackEnabled = messageFeedbackEnabled
            self.originationIdentity = originationIdentity
            self.protectConfigurationId = protectConfigurationId
            self.timeToLive = timeToLive
            self.voiceId = voiceId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^(?!\\s)^[\\s\\S]+(?<!\\s)$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, max: 8)
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, min: 2)
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, pattern: "^[0-9]{0,2}\\.[0-9]{1,5}$")
            try self.validate(self.messageBody, name: "messageBody", parent: name, max: 6000)
            try self.validate(self.messageBody, name: "messageBody", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, max: 259200)
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case dryRun = "DryRun"
            case maxPricePerMinute = "MaxPricePerMinute"
            case messageBody = "MessageBody"
            case messageBodyTextType = "MessageBodyTextType"
            case messageFeedbackEnabled = "MessageFeedbackEnabled"
            case originationIdentity = "OriginationIdentity"
            case protectConfigurationId = "ProtectConfigurationId"
            case timeToLive = "TimeToLive"
            case voiceId = "VoiceId"
        }
    }

    public struct SendVoiceMessageResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String?

        @inlinable
        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SenderIdAndCountry: AWSEncodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The unique identifier of the sender.
        public let senderId: String

        @inlinable
        public init(isoCountryCode: String, senderId: String) {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 256)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case senderId = "SenderId"
        }
    }

    public struct SenderIdFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: SenderIdFilterName
        /// An array of values to filter for.
        public let values: [String]

        @inlinable
        public init(name: SenderIdFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct SenderIdInformation: AWSDecodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly leasing price, in US dollars.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered.
        public let registered: Bool
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// The alphanumeric sender ID in a specific country that you'd like to describe.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String

        @inlinable
        public init(deletionProtectionEnabled: Bool, isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, registrationId: String? = nil, senderId: String, senderIdArn: String) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case registrationId = "RegistrationId"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String?
        /// The reason for the exception.
        public let reason: ServiceQuotaExceededExceptionReason?

        @inlinable
        public init(message: String? = nil, reason: ServiceQuotaExceededExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct SetAccountDefaultProtectConfigurationRequest: AWSEncodableShape {
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(protectConfigurationId: String) {
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct SetAccountDefaultProtectConfigurationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the account default protect configuration.
        public let defaultProtectConfigurationArn: String
        /// The unique identifier of the account default protect configuration.
        public let defaultProtectConfigurationId: String

        @inlinable
        public init(defaultProtectConfigurationArn: String, defaultProtectConfigurationId: String) {
            self.defaultProtectConfigurationArn = defaultProtectConfigurationArn
            self.defaultProtectConfigurationId = defaultProtectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case defaultProtectConfigurationArn = "DefaultProtectConfigurationArn"
            case defaultProtectConfigurationId = "DefaultProtectConfigurationId"
        }
    }

    public struct SetDefaultMessageFeedbackEnabledRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// Set to true to enable message feedback.
        public let messageFeedbackEnabled: Bool

        @inlinable
        public init(configurationSetName: String, messageFeedbackEnabled: Bool) {
            self.configurationSetName = configurationSetName
            self.messageFeedbackEnabled = messageFeedbackEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case messageFeedbackEnabled = "MessageFeedbackEnabled"
        }
    }

    public struct SetDefaultMessageFeedbackEnabledResult: AWSDecodableShape {
        /// The arn of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration.
        public let configurationSetName: String?
        /// True if message feedback is enabled.
        public let messageFeedbackEnabled: Bool?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, messageFeedbackEnabled: Bool? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.messageFeedbackEnabled = messageFeedbackEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case messageFeedbackEnabled = "MessageFeedbackEnabled"
        }
    }

    public struct SetDefaultMessageTypeRequest: AWSEncodableShape {
        /// The configuration set to update with a new default message type. This field can be the ConsigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType

        @inlinable
        public init(configurationSetName: String, messageType: MessageType) {
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct SetDefaultMessageTypeResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set that was updated.
        public let configurationSetName: String?
        /// The new default message type of the configuration set.
        public let messageType: MessageType?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, messageType: MessageType? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct SetDefaultSenderIdRequest: AWSEncodableShape {
        /// The configuration set to updated with a new default SenderId. This field can be the ConsigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// The current sender ID for the configuration set. When sending a text message to a destination country which supports SenderIds, the default sender ID on the configuration set specified on SendTextMessage will be used if no dedicated origination phone numbers or registered SenderIds are available in your account, instead of a generic sender ID, such as 'NOTICE'.
        public let senderId: String

        @inlinable
        public init(configurationSetName: String, senderId: String) {
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 11)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct SetDefaultSenderIdResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set that was updated.
        public let configurationSetName: String?
        /// The default sender ID to set for the ConfigurationSet.
        public let senderId: String?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, senderId: String? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct SetMediaMessageSpendLimitOverrideRequest: AWSEncodableShape {
        /// The new monthly limit to enforce on text messages.
        public let monthlyLimit: Int64

        @inlinable
        public init(monthlyLimit: Int64) {
            self.monthlyLimit = monthlyLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, max: 1000000000)
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetMediaMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit to enforce on sending text messages.
        public let monthlyLimit: Int64?

        @inlinable
        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetTextMessageSpendLimitOverrideRequest: AWSEncodableShape {
        /// The new monthly limit to enforce on text messages.
        public let monthlyLimit: Int64

        @inlinable
        public init(monthlyLimit: Int64) {
            self.monthlyLimit = monthlyLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, max: 1000000000)
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetTextMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit to enforce on sending text messages.
        public let monthlyLimit: Int64?

        @inlinable
        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetVoiceMessageSpendLimitOverrideRequest: AWSEncodableShape {
        /// The new monthly limit to enforce on voice messages.
        public let monthlyLimit: Int64

        @inlinable
        public init(monthlyLimit: Int64) {
            self.monthlyLimit = monthlyLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, max: 1000000000)
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetVoiceMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit to enforce on sending voice messages.
        public let monthlyLimit: Int64?

        @inlinable
        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SnsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        public let topicArn: String

        @inlinable
        public init(topicArn: String) {
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, max: 2048)
            try self.validate(self.topicArn, name: "topicArn", parent: name, min: 20)
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct SpendLimit: AWSDecodableShape {
        /// The maximum amount of money, in US dollars, that you want to be able to spend sending messages each month. This value has to be less than or equal to the amount in MaxLimit. To use this custom limit, Overridden must be set to true.
        public let enforcedLimit: Int64
        ///  The maximum amount of money that you are able to spend to send messages each month, in US dollars.
        public let maxLimit: Int64
        /// The name for the SpendLimit.
        public let name: SpendLimitName
        /// When set to True, the value that has been specified in the EnforcedLimit is used to determine the maximum amount in US dollars that can be spent to send messages each month, in US dollars.
        public let overridden: Bool

        @inlinable
        public init(enforcedLimit: Int64, maxLimit: Int64, name: SpendLimitName, overridden: Bool) {
            self.enforcedLimit = enforcedLimit
            self.maxLimit = maxLimit
            self.name = name
            self.overridden = overridden
        }

        private enum CodingKeys: String, CodingKey {
            case enforcedLimit = "EnforcedLimit"
            case maxLimit = "MaxLimit"
            case name = "Name"
            case overridden = "Overridden"
        }
    }

    public struct SubmitRegistrationVersionRequest: AWSEncodableShape {
        /// The unique identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct SubmitRegistrationVersionResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the registration.
        public let registrationArn: String
        /// The unique identifier for the registration.
        public let registrationId: String
        /// The status of the registration version.    APPROVED: Your registration has been approved.    ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.    DENIED: You must fix your registration and resubmit it.    DISCARDED: You've abandon this version of their registration to start over with a new version.     DRAFT: The initial status of a registration version after its created.    REQUIRES_AUTHENTICATION: You need to complete email authentication.    REVIEWING: Your registration has been accepted and is being reviewed.    REVOKED: Your previously approved registration has been revoked.    SUBMITTED: Your registration has been submitted.
        public let registrationVersionStatus: RegistrationVersionStatus
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        public let registrationVersionStatusHistory: RegistrationVersionStatusHistory
        /// The version number of the registration.
        public let versionNumber: Int64

        @inlinable
        public init(registrationArn: String, registrationId: String, registrationVersionStatus: RegistrationVersionStatus, registrationVersionStatusHistory: RegistrationVersionStatusHistory, versionNumber: Int64) {
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case registrationArn = "RegistrationArn"
            case registrationId = "RegistrationId"
            case registrationVersionStatus = "RegistrationVersionStatus"
            case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SupportedAssociation: AWSDecodableShape {
        /// The association behavior.    ASSOCIATE_BEFORE_SUBMIT The origination identity has to be supplied when creating a registration.    ASSOCIATE_ON_APPROVAL This applies to all short code registrations. The short code will be automatically provisioned once the registration is approved.    ASSOCIATE_AFTER_COMPLETE This applies to phone number registrations when you must complete a registration first, then associate one or more phone numbers later. For example 10DLC campaigns and long codes.
        public let associationBehavior: RegistrationAssociationBehavior
        /// The disassociation behavior.    DISASSOCIATE_ALL_CLOSES_REGISTRATION All origination identities must be disassociated from the registration before the registration can be closed.    DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION All origination identities must be disassociated from the registration before the registration can be deleted.    DELETE_REGISTRATION_DISASSOCIATES The registration can be deleted and all origination identities will be disasscoiated.
        public let disassociationBehavior: RegistrationDisassociationBehavior
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// Defines the behavior of when an origination identity and registration can be associated with each other.
        public let resourceType: String

        @inlinable
        public init(associationBehavior: RegistrationAssociationBehavior, disassociationBehavior: RegistrationDisassociationBehavior, isoCountryCode: String? = nil, resourceType: String) {
            self.associationBehavior = associationBehavior
            self.disassociationBehavior = disassociationBehavior
            self.isoCountryCode = isoCountryCode
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case associationBehavior = "AssociationBehavior"
            case disassociationBehavior = "DisassociationBehavior"
            case isoCountryCode = "IsoCountryCode"
            case resourceType = "ResourceType"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key identifier, or name, of the tag.
        public let key: String
        /// The string value associated with the key of the tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^.+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct TextValidation: AWSDecodableShape {
        /// The maximum number of characters for the text field.
        public let maxLength: Int
        /// The minimum number of characters for the text field.
        public let minLength: Int
        /// The regular expression used to validate the text field.
        public let pattern: String

        @inlinable
        public init(maxLength: Int, minLength: Int, pattern: String) {
            self.maxLength = maxLength
            self.minLength = minLength
            self.pattern = pattern
        }

        private enum CodingKeys: String, CodingKey {
            case maxLength = "MaxLength"
            case minLength = "MinLength"
            case pattern = "Pattern"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// An array of tag key values to unassociate with the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventDestinationRequest: AWSEncodableShape {
        /// An object that contains information about an event destination that sends data to CloudWatch Logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// The configuration set to update with the new event destination. Valid values for this can be the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// When set to true logging is enabled.
        public let enabled: Bool?
        /// The name to use for the event destination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log.  The TEXT_SENT event type is not supported.
        public let matchingEventTypes: [EventType]?
        /// An object that contains information about an event destination that sends data to Amazon SNS.
        public let snsDestination: SnsDestination?

        @inlinable
        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, configurationSetName: String, enabled: Bool? = nil, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType]? = nil, snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.configurationSetName = configurationSetName
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsDestination?.validate(name: "\(name).cloudWatchLogsDestination")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.kinesisFirehoseDestination?.validate(name: "\(name).kinesisFirehoseDestination")
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, max: 43)
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, min: 1)
            try self.snsDestination?.validate(name: "\(name).snsDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case configurationSetName = "ConfigurationSetName"
            case enabled = "Enabled"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct UpdateEventDestinationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the ConfigurationSet that was updated.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// An EventDestination object containing the details of where events will be logged.
        public let eventDestination: EventDestination?

        @inlinable
        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct UpdatePhoneNumberRequest: AWSEncodableShape {
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The OptOutList to add the phone number to. Valid values for this field can be either the OutOutListName or OutOutListArn.
        public let optOutListName: String?
        /// The unique identifier of the phone number. Valid values for this field can be either the PhoneNumberId or PhoneNumberArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let phoneNumberId: String
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(deletionProtectionEnabled: Bool? = nil, optOutListName: String? = nil, phoneNumberId: String, selfManagedOptOutsEnabled: Bool? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.optOutListName = optOutListName
            self.phoneNumberId = phoneNumberId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, max: 256)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, min: 1)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, max: 2048)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, min: 20)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, pattern: "^\\S+$")
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, max: 2048)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, min: 20)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case optOutListName = "OptOutListName"
            case phoneNumberId = "PhoneNumberId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The monthly leasing price of the phone number, in US dollars.
        public let monthlyLeasingPrice: String?
        /// Specifies if the number could be used for text messages, voice or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was requested.
        public let numberType: NumberType?
        /// The name of the OptOutList associated with the phone number.
        public let optOutListName: String?
        /// The phone number that was updated.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the updated phone number.
        public let phoneNumberArn: String?
        /// The unique identifier of the phone number.
        public let phoneNumberId: String?
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// This is true if self managed opt-out are enabled.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: NumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, registrationId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case registrationId = "RegistrationId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePoolRequest: AWSEncodableShape {
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The OptOutList to associate with the pool. Valid values are either OptOutListName or OptOutListArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let optOutListName: String?
        /// The unique identifier of the pool to update. Valid values are either the PoolId or PoolArn.  If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
        public let poolId: String
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(deletionProtectionEnabled: Bool? = nil, optOutListName: String? = nil, poolId: String, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.optOutListName = optOutListName
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, max: 2048)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, min: 20)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, pattern: "^\\S+$")
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, max: 2048)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, min: 20)
            try self.validate(self.twoWayChannelRole, name: "twoWayChannelRole", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case optOutListName = "OptOutListName"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The type of message for the pool to use.
        public let messageType: MessageType?
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String?
        /// The ARN of the pool.
        public let poolArn: String?
        /// The unique identifier of the pool.
        public let poolId: String?
        /// When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool update request.
        public let status: PoolStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public let twoWayChannelRole: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        @inlinable
        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, twoWayChannelArn: String? = nil, twoWayChannelRole: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayChannelRole = "TwoWayChannelRole"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdateProtectConfigurationCountryRuleSetRequest: AWSEncodableShape {
        /// A map of ProtectConfigurationCountryRuleSetInformation objects that contain the details for the requested NumberCapability. The Key is the two-letter ISO country code. For a list of supported ISO country codes, see Supported countries and regions (SMS channel) in the AWS End User Messaging SMS User Guide.
        public let countryRuleSetUpdates: [String: ProtectConfigurationCountryRuleSetInformation]
        /// The number capability to apply the CountryRuleSetUpdates updates to.
        public let numberCapability: NumberCapability
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(countryRuleSetUpdates: [String: ProtectConfigurationCountryRuleSetInformation], numberCapability: NumberCapability, protectConfigurationId: String) {
            self.countryRuleSetUpdates = countryRuleSetUpdates
            self.numberCapability = numberCapability
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.countryRuleSetUpdates.forEach {
                try validate($0.key, name: "countryRuleSetUpdates.key", parent: name, max: 2)
                try validate($0.key, name: "countryRuleSetUpdates.key", parent: name, min: 2)
                try validate($0.key, name: "countryRuleSetUpdates.key", parent: name, pattern: "^[A-Z]{2}$")
            }
            try self.validate(self.countryRuleSetUpdates, name: "countryRuleSetUpdates", parent: name, max: 300)
            try self.validate(self.countryRuleSetUpdates, name: "countryRuleSetUpdates", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case countryRuleSetUpdates = "CountryRuleSetUpdates"
            case numberCapability = "NumberCapability"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct UpdateProtectConfigurationCountryRuleSetResult: AWSDecodableShape {
        /// An array of ProtectConfigurationCountryRuleSetInformation containing the rules for the NumberCapability.
        public let countryRuleSet: [String: ProtectConfigurationCountryRuleSetInformation]
        /// The number capability that was updated
        public let numberCapability: NumberCapability
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(countryRuleSet: [String: ProtectConfigurationCountryRuleSetInformation], numberCapability: NumberCapability, protectConfigurationArn: String, protectConfigurationId: String) {
            self.countryRuleSet = countryRuleSet
            self.numberCapability = numberCapability
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case countryRuleSet = "CountryRuleSet"
            case numberCapability = "NumberCapability"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct UpdateProtectConfigurationRequest: AWSEncodableShape {
        /// When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool?
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(deletionProtectionEnabled: Bool? = nil, protectConfigurationId: String) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.protectConfigurationId = protectConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, max: 256)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, min: 1)
            try self.validate(self.protectConfigurationId, name: "protectConfigurationId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct UpdateProtectConfigurationResult: AWSDecodableShape {
        /// This is true if the protect configuration is set as your account default protect configuration.
        public let accountDefault: Bool
        /// The time when the protect configuration was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The status of deletion protection for the protect configuration. When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool
        /// The Amazon Resource Name (ARN) of the protect configuration.
        public let protectConfigurationArn: String
        /// The unique identifier for the protect configuration.
        public let protectConfigurationId: String

        @inlinable
        public init(accountDefault: Bool, createdTimestamp: Date, deletionProtectionEnabled: Bool, protectConfigurationArn: String, protectConfigurationId: String) {
            self.accountDefault = accountDefault
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case accountDefault = "AccountDefault"
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case protectConfigurationArn = "ProtectConfigurationArn"
            case protectConfigurationId = "ProtectConfigurationId"
        }
    }

    public struct UpdateSenderIdRequest: AWSEncodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The sender ID to update.
        public let senderId: String

        @inlinable
        public init(deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, senderId: String) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 256)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case senderId = "SenderId"
        }
    }

    public struct UpdateSenderIdResult: AWSDecodableShape {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly price, in US dollars, to lease the sender ID.
        public let monthlyLeasingPrice: String
        /// True if the sender ID is registered..
        public let registered: Bool
        /// The unique identifier for the registration.
        public let registrationId: String?
        /// The sender ID that was updated.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String

        @inlinable
        public init(deletionProtectionEnabled: Bool, isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, registered: Bool, registrationId: String? = nil, senderId: String, senderIdArn: String) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case registered = "Registered"
            case registrationId = "RegistrationId"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field that failed validation.
        public let fields: [ValidationExceptionField]?
        public let message: String?
        /// The reason for the exception.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fields: [ValidationExceptionField]? = nil, message: String? = nil, reason: ValidationExceptionReason? = nil) {
            self.fields = fields
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The message associated with the validation exception with information to help determine its cause.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }

    public struct VerifiedDestinationNumberFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: VerifiedDestinationNumberFilterName
        /// An array of values to filter on.
        public let values: [String]

        @inlinable
        public init(name: VerifiedDestinationNumberFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[/\\.:A-Za-z0-9+_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct VerifiedDestinationNumberInformation: AWSDecodableShape {
        /// The time when the destination phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The verified destination phone number, in E.164 format.
        public let destinationPhoneNumber: String
        /// The status of the verified destination phone number.    PENDING: The phone number hasn't been verified yet.    VERIFIED: The phone number is verified and can receive messages.
        public let status: VerificationStatus
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        @inlinable
        public init(createdTimestamp: Date, destinationPhoneNumber: String, status: VerificationStatus, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case status = "Status"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct VerifyDestinationNumberRequest: AWSEncodableShape {
        /// The verification code that was received by the verified destination phone number.
        public let verificationCode: String
        /// The unique identifier for the verififed destination phone number.
        public let verifiedDestinationNumberId: String

        @inlinable
        public init(verificationCode: String, verifiedDestinationNumberId: String) {
            self.verificationCode = verificationCode
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.verificationCode, name: "verificationCode", parent: name, max: 20)
            try self.validate(self.verificationCode, name: "verificationCode", parent: name, min: 1)
            try self.validate(self.verificationCode, name: "verificationCode", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, max: 256)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, min: 1)
            try self.validate(self.verifiedDestinationNumberId, name: "verifiedDestinationNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case verificationCode = "VerificationCode"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }

    public struct VerifyDestinationNumberResult: AWSDecodableShape {
        /// The time when the destination phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// The status for being able to send messages to the phone number.
        public let status: VerificationStatus
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        public let verifiedDestinationNumberArn: String
        /// The unique identifier for the verified destination phone number.
        public let verifiedDestinationNumberId: String

        @inlinable
        public init(createdTimestamp: Date, destinationPhoneNumber: String, status: VerificationStatus, verifiedDestinationNumberArn: String, verifiedDestinationNumberId: String) {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case status = "Status"
            case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
            case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
        }
    }
}

// MARK: - Errors

/// Error enum for PinpointSMSVoiceV2
public struct PinpointSMSVoiceV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PinpointSMSVoiceV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied because you don't have sufficient permissions to access the resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time or it could be that the requested action isn't valid for the current state or configuration of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A requested resource couldn't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// An error that occurred because too many requests were sent during a certain amount of time.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// A validation exception for a field.
    public static var validationException: Self { .init(.validationException) }
}

extension PinpointSMSVoiceV2ErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": PinpointSMSVoiceV2.AccessDeniedException.self,
        "ConflictException": PinpointSMSVoiceV2.ConflictException.self,
        "InternalServerException": PinpointSMSVoiceV2.InternalServerException.self,
        "ResourceNotFoundException": PinpointSMSVoiceV2.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": PinpointSMSVoiceV2.ServiceQuotaExceededException.self,
        "ValidationException": PinpointSMSVoiceV2.ValidationException.self
    ]
}

extension PinpointSMSVoiceV2ErrorType: Equatable {
    public static func == (lhs: PinpointSMSVoiceV2ErrorType, rhs: PinpointSMSVoiceV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PinpointSMSVoiceV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
