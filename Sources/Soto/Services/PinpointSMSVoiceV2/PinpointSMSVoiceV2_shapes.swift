//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension PinpointSMSVoiceV2 {
    // MARK: Enums

    public enum AccountAttributeName: String, CustomStringConvertible, Codable, _SotoSendable {
        case accountTier = "ACCOUNT_TIER"
        public var description: String { return self.rawValue }
    }

    public enum AccountLimitName: String, CustomStringConvertible, Codable, _SotoSendable {
        case configurationSets = "CONFIGURATION_SETS"
        case optOutLists = "OPT_OUT_LISTS"
        case phoneNumbers = "PHONE_NUMBERS"
        case pools = "POOLS"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationSetFilterName: String, CustomStringConvertible, Codable, _SotoSendable {
        case defaultMessageType = "default-message-type"
        case defaultSenderId = "default-sender-id"
        case eventDestinationName = "event-destination-name"
        case matchingEventTypes = "matching-event-types"
        public var description: String { return self.rawValue }
    }

    public enum DestinationCountryParameterKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case inEntityId = "IN_ENTITY_ID"
        case inTemplateId = "IN_TEMPLATE_ID"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case textAll = "TEXT_ALL"
        case textBlocked = "TEXT_BLOCKED"
        case textCarrierBlocked = "TEXT_CARRIER_BLOCKED"
        case textCarrierUnreachable = "TEXT_CARRIER_UNREACHABLE"
        case textDelivered = "TEXT_DELIVERED"
        case textInvalid = "TEXT_INVALID"
        case textInvalidMessage = "TEXT_INVALID_MESSAGE"
        case textPending = "TEXT_PENDING"
        case textQueued = "TEXT_QUEUED"
        case textSent = "TEXT_SENT"
        case textSpam = "TEXT_SPAM"
        case textSuccessful = "TEXT_SUCCESSFUL"
        case textTtlExpired = "TEXT_TTL_EXPIRED"
        case textUnknown = "TEXT_UNKNOWN"
        case textUnreachable = "TEXT_UNREACHABLE"
        case voiceAll = "VOICE_ALL"
        case voiceAnswered = "VOICE_ANSWERED"
        case voiceBusy = "VOICE_BUSY"
        case voiceCompleted = "VOICE_COMPLETED"
        case voiceFailed = "VOICE_FAILED"
        case voiceInitiated = "VOICE_INITIATED"
        case voiceNoAnswer = "VOICE_NO_ANSWER"
        case voiceRinging = "VOICE_RINGING"
        case voiceTtlExpired = "VOICE_TTL_EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum KeywordAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case automaticResponse = "AUTOMATIC_RESPONSE"
        case optIn = "OPT_IN"
        case optOut = "OPT_OUT"
        public var description: String { return self.rawValue }
    }

    public enum KeywordFilterName: String, CustomStringConvertible, Codable, _SotoSendable {
        case keywordAction = "keyword-action"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case promotional = "PROMOTIONAL"
        case transactional = "TRANSACTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum NumberCapability: String, CustomStringConvertible, Codable, _SotoSendable {
        case sms = "SMS"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum NumberStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case associating = "ASSOCIATING"
        case deleted = "DELETED"
        case disassociating = "DISASSOCIATING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum NumberType: String, CustomStringConvertible, Codable, _SotoSendable {
        case longCode = "LONG_CODE"
        case shortCode = "SHORT_CODE"
        case tenDlc = "TEN_DLC"
        case tollFree = "TOLL_FREE"
        public var description: String { return self.rawValue }
    }

    public enum OptedOutFilterName: String, CustomStringConvertible, Codable, _SotoSendable {
        case endUserOptedOut = "end-user-opted-out"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberFilterName: String, CustomStringConvertible, Codable, _SotoSendable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case isoCountryCode = "iso-country-code"
        case messageType = "message-type"
        case numberCapability = "number-capability"
        case numberType = "number-type"
        case optOutListName = "opt-out-list-name"
        case selfManagedOptOutsEnabled = "self-managed-opt-outs-enabled"
        case status
        case twoWayEnabled = "two-way-enabled"
        public var description: String { return self.rawValue }
    }

    public enum PoolFilterName: String, CustomStringConvertible, Codable, _SotoSendable {
        case deletionProtectionEnabled = "deletion-protection-enabled"
        case messageType = "message-type"
        case optOutListName = "opt-out-list-name"
        case selfManagedOptOutsEnabled = "self-managed-opt-outs-enabled"
        case sharedRoutesEnabled = "shared-routes-enabled"
        case status
        case twoWayEnabled = "two-way-enabled"
        public var description: String { return self.rawValue }
    }

    public enum PoolOriginationIdentitiesFilterName: String, CustomStringConvertible, Codable, _SotoSendable {
        case isoCountryCode = "iso-country-code"
        case numberCapability = "number-capability"
        public var description: String { return self.rawValue }
    }

    public enum PoolStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum RequestableNumberType: String, CustomStringConvertible, Codable, _SotoSendable {
        case longCode = "LONG_CODE"
        case tenDlc = "TEN_DLC"
        case tollFree = "TOLL_FREE"
        public var description: String { return self.rawValue }
    }

    public enum SenderIdFilterName: String, CustomStringConvertible, Codable, _SotoSendable {
        case isoCountryCode = "iso-country-code"
        case messageType = "message-type"
        case senderId = "sender-id"
        public var description: String { return self.rawValue }
    }

    public enum SpendLimitName: String, CustomStringConvertible, Codable, _SotoSendable {
        case textMessageMonthlySpendLimit = "TEXT_MESSAGE_MONTHLY_SPEND_LIMIT"
        case voiceMessageMonthlySpendLimit = "VOICE_MESSAGE_MONTHLY_SPEND_LIMIT"
        public var description: String { return self.rawValue }
    }

    public enum VoiceId: String, CustomStringConvertible, Codable, _SotoSendable {
        case amy = "AMY"
        case astrid = "ASTRID"
        case bianca = "BIANCA"
        case brian = "BRIAN"
        case camila = "CAMILA"
        case carla = "CARLA"
        case carmen = "CARMEN"
        case celine = "CELINE"
        case chantal = "CHANTAL"
        case conchita = "CONCHITA"
        case cristiano = "CRISTIANO"
        case dora = "DORA"
        case emma = "EMMA"
        case enrique = "ENRIQUE"
        case ewa = "EWA"
        case filiz = "FILIZ"
        case geraint = "GERAINT"
        case giorgio = "GIORGIO"
        case gwyneth = "GWYNETH"
        case hans = "HANS"
        case ines = "INES"
        case ivy = "IVY"
        case jacek = "JACEK"
        case jan = "JAN"
        case joanna = "JOANNA"
        case joey = "JOEY"
        case justin = "JUSTIN"
        case karl = "KARL"
        case kendra = "KENDRA"
        case kimberly = "KIMBERLY"
        case lea = "LEA"
        case liv = "LIV"
        case lotte = "LOTTE"
        case lucia = "LUCIA"
        case lupe = "LUPE"
        case mads = "MADS"
        case maja = "MAJA"
        case marlene = "MARLENE"
        case mathieu = "MATHIEU"
        case matthew = "MATTHEW"
        case maxim = "MAXIM"
        case mia = "MIA"
        case miguel = "MIGUEL"
        case mizuki = "MIZUKI"
        case naja = "NAJA"
        case nicole = "NICOLE"
        case penelope = "PENELOPE"
        case raveena = "RAVEENA"
        case ricardo = "RICARDO"
        case ruben = "RUBEN"
        case russell = "RUSSELL"
        case salli = "SALLI"
        case seoyeon = "SEOYEON"
        case takumi = "TAKUMI"
        case tatyana = "TATYANA"
        case vicki = "VICKI"
        case vitoria = "VITORIA"
        case zeina = "ZEINA"
        case zhiyu = "ZHIYU"
        public var description: String { return self.rawValue }
    }

    public enum VoiceMessageBodyTextType: String, CustomStringConvertible, Codable, _SotoSendable {
        case ssml = "SSML"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountAttribute: AWSDecodableShape {
        /// The name of the account attribute.
        public let name: AccountAttributeName
        /// The value associated with the account attribute name.
        public let value: String

        public init(name: AccountAttributeName, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AccountLimit: AWSDecodableShape {
        /// The Amazon Web Services set limit for that resource type, in US dollars.
        public let max: Int64
        /// The name of the attribute to apply the account limit to.
        public let name: AccountLimitName
        /// The current amount that has been spent, in US dollars.
        public let used: Int64

        public init(max: Int64, name: AccountLimitName, used: Int64) {
            self.max = max
            self.name = name
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case name = "Name"
            case used = "Used"
        }
    }

    public struct AssociateOriginationIdentityRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the origination identity.
        public let isoCountryCode: String
        /// The origination identity to use, such as PhoneNumberId, PhoneNumberArn, SenderId, or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn, while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String
        /// The pool to update with the new Identity. This value can be either the PoolId or PoolArn, and you can find these values using DescribePools.
        public let poolId: String

        public init(clientToken: String? = AssociateOriginationIdentityRequest.idempotencyToken(), isoCountryCode: String, originationIdentity: String, poolId: String) {
            self.clientToken = clientToken
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case poolId = "PoolId"
        }
    }

    public struct AssociateOriginationIdentityResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The PhoneNumberId or SenderId of the origination identity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or SenderIdArn of the origination identity.
        public let originationIdentityArn: String?
        /// The Amazon Resource Name (ARN) of the pool that is now associated with the origination identity.
        public let poolArn: String?
        /// The PoolId of the pool that is now associated with the origination identity.
        public let poolId: String?

        public init(isoCountryCode: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct CloudWatchLogsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
        public let iamRoleArn: String
        /// The name of the Amazon CloudWatch log group that you want to record events in.
        public let logGroupArn: String

        public init(iamRoleArn: String, logGroupArn: String) {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 2048)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 20)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn:\\S+$")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, max: 2048)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, min: 20)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case logGroupArn = "LogGroupArn"
        }
    }

    public struct ConfigurationSetFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: ConfigurationSetFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: ConfigurationSetFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ConfigurationSetInformation: AWSDecodableShape {
        /// The Resource Name (ARN) of the ConfigurationSet.
        public let configurationSetArn: String
        /// The name of the ConfigurationSet.
        public let configurationSetName: String
        /// The time when the ConfigurationSet was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let defaultMessageType: MessageType?
        /// The default sender ID used by the ConfigurationSet.
        public let defaultSenderId: String?
        /// An array of EventDestination objects that describe any events to log and where to log them.
        public let eventDestinations: [EventDestination]

        public init(configurationSetArn: String, configurationSetName: String, createdTimestamp: Date, defaultMessageType: MessageType? = nil, defaultSenderId: String? = nil, eventDestinations: [EventDestination]) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case defaultMessageType = "DefaultMessageType"
            case defaultSenderId = "DefaultSenderId"
            case eventDestinations = "EventDestinations"
        }
    }

    public struct CreateConfigurationSetRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The name to use for the new configuration set.
        public let configurationSetName: String
        /// An array of key and value pair tags that's associated with the new configuration set.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateConfigurationSetRequest.idempotencyToken(), configurationSetName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.configurationSetName = configurationSetName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 64)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case configurationSetName = "ConfigurationSetName"
            case tags = "Tags"
        }
    }

    public struct CreateConfigurationSetResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created configuration set.
        public let configurationSetArn: String?
        /// The name of the new configuration set.
        public let configurationSetName: String?
        /// The time when the configuration set was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// An array of key and value pair tags that's associated with the configuration set.
        public let tags: [Tag]?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, createdTimestamp: Date? = nil, tags: [Tag]? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case tags = "Tags"
        }
    }

    public struct CreateEventDestinationRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// An object that contains information about an event destination for logging to Amazon CloudWatch logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// Either the name of the configuration set or the configuration set ARN to apply event logging to. The ConfigurateSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String
        /// The name that identifies the event destination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log. If "ALL" is used, then Amazon Pinpoint logs every event type.
        public let matchingEventTypes: [EventType]
        /// An object that contains information about an event destination for logging to Amazon SNS.
        public let snsDestination: SnsDestination?

        public init(clientToken: String? = CreateEventDestinationRequest.idempotencyToken(), cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, configurationSetName: String, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType], snsDestination: SnsDestination? = nil) {
            self.clientToken = clientToken
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.configurationSetName = configurationSetName
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.cloudWatchLogsDestination?.validate(name: "\(name).cloudWatchLogsDestination")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.kinesisFirehoseDestination?.validate(name: "\(name).kinesisFirehoseDestination")
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, max: 25)
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, min: 1)
            try self.snsDestination?.validate(name: "\(name).snsDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case configurationSetName = "ConfigurationSetName"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct CreateEventDestinationResult: AWSDecodableShape {
        /// The ARN of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The details of the destination where events are logged.
        public let eventDestination: EventDestination?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct CreateOptOutListRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The name of the new OptOutList.
        public let optOutListName: String
        /// An array of tags (key and value pairs) to associate with the new OptOutList.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateOptOutListRequest.idempotencyToken(), optOutListName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.optOutListName = optOutListName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 64)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case optOutListName = "OptOutListName"
            case tags = "Tags"
        }
    }

    public struct CreateOptOutListResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) for the OptOutList.
        public let optOutListArn: String?
        /// The name of the new OptOutList.
        public let optOutListName: String?
        /// An array of tags (key and value pairs) associated with the new OptOutList.
        public let tags: [Tag]?

        public init(createdTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil, tags: [Tag]? = nil) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
            case tags = "Tags"
        }
    }

    public struct CreatePoolRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the pool can't be deleted. You can change this value using the UpdatePool action.
        public let deletionProtectionEnabled: Bool?
        /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the new pool.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String
        /// An array of tags (key and value pairs) associated with the pool.
        public let tags: [Tag]?

        public init(clientToken: String? = CreatePoolRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageType: MessageType, originationIdentity: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.originationIdentity = originationIdentity
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case originationIdentity = "OriginationIdentity"
            case tags = "Tags"
        }
    }

    public struct CreatePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true deletion protection is enabled. By default this is set to false.
        public let deletionProtectionEnabled: Bool?
        /// The type of message for the pool to use.
        public let messageType: MessageType?
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String?
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String?
        /// The unique identifier for the pool.
        public let poolId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool.   CREATING: The pool is currently being created and isn't yet available for use.   ACTIVE: The pool is active and available for use.   DELETING: The pool is being deleted.
        public let status: PoolStatus?
        /// An array of tags (key and value pairs) associated with the pool.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, tags: [Tag]? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.tags = tags
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case tags = "Tags"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct DeleteConfigurationSetRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set ARN that you want to delete. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteConfigurationSetResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted configuration set.
        public let configurationSetArn: String?
        /// The name of the deleted configuration set.
        public let configurationSetName: String?
        /// The time that the deleted configuration set was created in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The default message type of the configuration set that was deleted.
        public let defaultMessageType: MessageType?
        /// The default Sender ID of the configuration set that was deleted.
        public let defaultSenderId: String?
        /// An array of any EventDestination objects that were associated with the deleted configuration set.
        public let eventDestinations: [EventDestination]?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, createdTimestamp: Date? = nil, defaultMessageType: MessageType? = nil, defaultSenderId: String? = nil, eventDestinations: [EventDestination]? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case createdTimestamp = "CreatedTimestamp"
            case defaultMessageType = "DefaultMessageType"
            case defaultSenderId = "DefaultSenderId"
            case eventDestinations = "EventDestinations"
        }
    }

    public struct DeleteDefaultMessageTypeRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default message type from. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteDefaultMessageTypeResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The current message type for the configuration set.
        public let messageType: MessageType?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, messageType: MessageType? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct DeleteDefaultSenderIdRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default sender ID from. The ConfigurationSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String

        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct DeleteDefaultSenderIdResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// The current sender ID for the configuration set.
        public let senderId: String?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, senderId: String? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct DeleteEventDestinationRequest: AWSEncodableShape {
        /// The name of the configuration set or the configuration set's Amazon Resource Name (ARN) to remove the event destination from. The ConfigurateSetName and ConfigurationSetArn can be found using the DescribeConfigurationSets action.
        public let configurationSetName: String
        /// The name of the event destination to delete.
        public let eventDestinationName: String

        public init(configurationSetName: String, eventDestinationName: String) {
            self.configurationSetName = configurationSetName
            self.eventDestinationName = eventDestinationName
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case eventDestinationName = "EventDestinationName"
        }
    }

    public struct DeleteEventDestinationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set the event destination was deleted from.
        public let configurationSetName: String?
        /// The event destination object that was deleted.
        public let eventDestination: EventDestination?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct DeleteKeywordRequest: AWSEncodableShape {
        /// The keyword to delete.
        public let keyword: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, PoolId or PoolArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn and DescribePools to find the values of PoolId and PoolArn.
        public let originationIdentity: String

        public init(keyword: String, originationIdentity: String) {
            self.keyword = keyword
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct DeleteKeywordResult: AWSDecodableShape {
        /// The keyword that was deleted.
        public let keyword: String?
        /// The action that was associated with the deleted keyword.
        public let keywordAction: KeywordAction?
        /// The message that was associated with the deleted keyword.
        public let keywordMessage: String?
        /// The PhoneNumberId or PoolId that the keyword was associated with.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that the keyword was associated with.
        public let originationIdentityArn: String?

        public init(keyword: String? = nil, keywordAction: KeywordAction? = nil, keywordMessage: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct DeleteOptOutListRequest: AWSEncodableShape {
        /// The OptOutListName or OptOutListArn of the OptOutList to delete. You can use DescribeOptOutLists to find the values for OptOutListName and OptOutListArn.
        public let optOutListName: String

        public init(optOutListName: String) {
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptOutListResult: AWSDecodableShape {
        /// The time when the OptOutList was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the OptOutList that was removed.
        public let optOutListArn: String?
        /// The name of the OptOutList that was removed.
        public let optOutListName: String?

        public init(createdTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptedOutNumberRequest: AWSEncodableShape {
        /// The phone number, in E.164 format, to remove from the OptOutList.
        public let optedOutNumber: String
        /// The OptOutListName or OptOutListArn to remove the phone number from.
        public let optOutListName: String

        public init(optedOutNumber: String, optOutListName: String) {
            self.optedOutNumber = optedOutNumber
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, max: 20)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, min: 1)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optedOutNumber = "OptedOutNumber"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeleteOptedOutNumberResult: AWSDecodableShape {
        /// This is true if it was the end user who requested their phone number be removed.
        public let endUserOptedOut: Bool?
        /// The phone number that was removed from the OptOutList.
        public let optedOutNumber: String?
        /// The time that the number was removed at, in UNIX epoch time format.
        public let optedOutTimestamp: Date?
        /// The OptOutListArn that the phone number was removed from.
        public let optOutListArn: String?
        /// The OptOutListName that the phone number was removed from.
        public let optOutListName: String?

        public init(endUserOptedOut: Bool? = nil, optedOutNumber: String? = nil, optedOutTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DeletePoolRequest: AWSEncodableShape {
        /// The PoolId or PoolArn of the pool to delete. You can use DescribePools to find the values for PoolId and PoolArn .
        public let poolId: String

        public init(poolId: String) {
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case poolId = "PoolId"
        }
    }

    public struct DeletePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The message type that was associated with the deleted pool.
        public let messageType: MessageType?
        /// The name of the OptOutList that was associated with the deleted pool.
        public let optOutListName: String?
        /// The Amazon Resource Name (ARN) of the pool that was deleted.
        public let poolArn: String?
        /// The PoolId of the pool that was deleted.
        public let poolId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool.   CREATING: The pool is currently being created and isn't yet available for use.   ACTIVE: The pool is active and available for use.   DELETING: The pool is being deleted.
        public let status: PoolStatus?
        /// The Amazon Resource Name (ARN) of the TwoWayChannel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct DeleteTextMessageSpendLimitOverrideRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteTextMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit, in US dollars.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct DeleteVoiceMessageSpendLimitOverrideRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteVoiceMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit, in US dollars.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct DescribeAccountAttributesRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountAttributesResult: AWSDecodableShape {
        /// An array of AccountAttributes objects.
        public let accountAttributes: [AccountAttribute]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        public init(accountAttributes: [AccountAttribute]? = nil, nextToken: String? = nil) {
            self.accountAttributes = accountAttributes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accountAttributes = "AccountAttributes"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountLimitsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeAccountLimitsResult: AWSDecodableShape {
        /// An array of AccountLimit objects that show the current spend limits.
        public let accountLimits: [AccountLimit]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        public init(accountLimits: [AccountLimit]? = nil, nextToken: String? = nil) {
            self.accountLimits = accountLimits
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accountLimits = "AccountLimits"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationSetsRequest: AWSEncodableShape {
        /// An array of strings. Each element can be either a ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetNames: [String]?
        /// An array of filters to apply to the results that are returned.
        public let filters: [ConfigurationSetFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(configurationSetNames: [String]? = nil, filters: [ConfigurationSetFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.configurationSetNames = configurationSetNames
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.configurationSetNames?.forEach {
                try validate($0, name: "configurationSetNames[]", parent: name, max: 256)
                try validate($0, name: "configurationSetNames[]", parent: name, min: 1)
                try validate($0, name: "configurationSetNames[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.configurationSetNames, name: "configurationSetNames", parent: name, max: 5)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetNames = "ConfigurationSetNames"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeConfigurationSetsResult: AWSDecodableShape {
        /// An array of ConfigurationSets objects.
        public let configurationSets: [ConfigurationSetInformation]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?

        public init(configurationSets: [ConfigurationSetInformation]? = nil, nextToken: String? = nil) {
            self.configurationSets = configurationSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSets = "ConfigurationSets"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeKeywordsRequest: AWSEncodableShape {
        /// An array of keyword filters to filter the results.
        public let filters: [KeywordFilter]?
        /// An array of keywords to search for.
        public let keywords: [String]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers to find the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String

        public init(filters: [KeywordFilter]? = nil, keywords: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, originationIdentity: String) {
            self.filters = filters
            self.keywords = keywords
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.keywords?.forEach {
                try validate($0, name: "keywords[]", parent: name, max: 30)
                try validate($0, name: "keywords[]", parent: name, min: 1)
                try validate($0, name: "keywords[]", parent: name, pattern: "^[ \\S]+$")
            }
            try self.validate(self.keywords, name: "keywords", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case keywords = "Keywords"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct DescribeKeywordsResult: AWSDecodableShape {
        /// An array of KeywordInformation objects that contain the results.
        public let keywords: [KeywordInformation]?
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// The PhoneNumberId or PoolId that is associated with the OriginationIdentity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that is associated with the OriginationIdentity.
        public let originationIdentityArn: String?

        public init(keywords: [KeywordInformation]? = nil, nextToken: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keywords = keywords
            self.nextToken = nextToken
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keywords = "Keywords"
            case nextToken = "NextToken"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct DescribeOptOutListsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The OptOutLists to show the details of. This is an array of strings that can be either the OptOutListName or OptOutListArn.
        public let optOutListNames: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, optOutListNames: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.optOutListNames = optOutListNames
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.optOutListNames?.forEach {
                try validate($0, name: "optOutListNames[]", parent: name, max: 256)
                try validate($0, name: "optOutListNames[]", parent: name, min: 1)
                try validate($0, name: "optOutListNames[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.optOutListNames, name: "optOutListNames", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case optOutListNames = "OptOutListNames"
        }
    }

    public struct DescribeOptOutListsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of OptOutListInformation objects that contain the details for the requested OptOutLists.
        public let optOutLists: [OptOutListInformation]?

        public init(nextToken: String? = nil, optOutLists: [OptOutListInformation]? = nil) {
            self.nextToken = nextToken
            self.optOutLists = optOutLists
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case optOutLists = "OptOutLists"
        }
    }

    public struct DescribeOptedOutNumbersRequest: AWSEncodableShape {
        /// An array of OptedOutFilter objects to filter the results on.
        public let filters: [OptedOutFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of phone numbers to search for in the OptOutList.
        public let optedOutNumbers: [String]?
        /// The OptOutListName or OptOutListArn of the OptOutList. You can use DescribeOptOutLists to find the values for OptOutListName and OptOutListArn.
        public let optOutListName: String

        public init(filters: [OptedOutFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, optedOutNumbers: [String]? = nil, optOutListName: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.optedOutNumbers = optedOutNumbers
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.optedOutNumbers?.forEach {
                try validate($0, name: "optedOutNumbers[]", parent: name, max: 20)
                try validate($0, name: "optedOutNumbers[]", parent: name, min: 1)
                try validate($0, name: "optedOutNumbers[]", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            }
            try self.validate(self.optedOutNumbers, name: "optedOutNumbers", parent: name, max: 5)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case optedOutNumbers = "OptedOutNumbers"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DescribeOptedOutNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of OptedOutNumbersInformation objects that provide information about the requested OptedOutNumbers.
        public let optedOutNumbers: [OptedOutNumberInformation]?
        /// The Amazon Resource Name (ARN) of the OptOutList.
        public let optOutListArn: String?
        /// The name of the OptOutList.
        public let optOutListName: String?

        public init(nextToken: String? = nil, optedOutNumbers: [OptedOutNumberInformation]? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.nextToken = nextToken
            self.optedOutNumbers = optedOutNumbers
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case optedOutNumbers = "OptedOutNumbers"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct DescribePhoneNumbersRequest: AWSEncodableShape {
        /// An array of PhoneNumberFilter objects to filter the results.
        public let filters: [PhoneNumberFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier of phone numbers to find information about. This is an array of strings that can be either the PhoneNumberId or PhoneNumberArn.
        public let phoneNumberIds: [String]?

        public init(filters: [PhoneNumberFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, phoneNumberIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberIds = phoneNumberIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.phoneNumberIds?.forEach {
                try validate($0, name: "phoneNumberIds[]", parent: name, max: 256)
                try validate($0, name: "phoneNumberIds[]", parent: name, min: 1)
                try validate($0, name: "phoneNumberIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.phoneNumberIds, name: "phoneNumberIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case phoneNumberIds = "PhoneNumberIds"
        }
    }

    public struct DescribePhoneNumbersResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of PhoneNumberInformation objects that contain the details for the requested phone numbers.
        public let phoneNumbers: [PhoneNumberInformation]?

        public init(nextToken: String? = nil, phoneNumbers: [PhoneNumberInformation]? = nil) {
            self.nextToken = nextToken
            self.phoneNumbers = phoneNumbers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case phoneNumbers = "PhoneNumbers"
        }
    }

    public struct DescribePoolsRequest: AWSEncodableShape {
        /// An array of PoolFilter objects to filter the results.
        public let filters: [PoolFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier of pools to find. This is an array of strings that can be either the PoolId or PoolArn.
        public let poolIds: [String]?

        public init(filters: [PoolFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, poolIds: [String]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.poolIds = poolIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.poolIds?.forEach {
                try validate($0, name: "poolIds[]", parent: name, max: 256)
                try validate($0, name: "poolIds[]", parent: name, min: 1)
                try validate($0, name: "poolIds[]", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            }
            try self.validate(self.poolIds, name: "poolIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case poolIds = "PoolIds"
        }
    }

    public struct DescribePoolsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of PoolInformation objects that contain the details for the requested pools.
        public let pools: [PoolInformation]?

        public init(nextToken: String? = nil, pools: [PoolInformation]? = nil) {
            self.nextToken = nextToken
            self.pools = pools
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case pools = "Pools"
        }
    }

    public struct DescribeSenderIdsRequest: AWSEncodableShape {
        /// An array of SenderIdFilter objects to filter the results.
        public let filters: [SenderIdFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// An array of SenderIdAndCountry objects to search for.
        public let senderIds: [SenderIdAndCountry]?

        public init(filters: [SenderIdFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, senderIds: [SenderIdAndCountry]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.senderIds = senderIds
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.senderIds?.forEach {
                try $0.validate(name: "\(name).senderIds[]")
            }
            try self.validate(self.senderIds, name: "senderIds", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case senderIds = "SenderIds"
        }
    }

    public struct DescribeSenderIdsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of SernderIdInformation objects that contain the details for the requested SenderIds.
        public let senderIds: [SenderIdInformation]?

        public init(nextToken: String? = nil, senderIds: [SenderIdInformation]? = nil) {
            self.nextToken = nextToken
            self.senderIds = senderIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case senderIds = "SenderIds"
        }
    }

    public struct DescribeSpendLimitsRequest: AWSEncodableShape {
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeSpendLimitsResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of SpendLimit objects that contain the details for the requested spend limits.
        public let spendLimits: [SpendLimit]?

        public init(nextToken: String? = nil, spendLimits: [SpendLimit]? = nil) {
            self.nextToken = nextToken
            self.spendLimits = spendLimits
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case spendLimits = "SpendLimits"
        }
    }

    public struct DisassociateOriginationIdentityRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers find the values for PhoneNumberId and PhoneNumberArn, or use DescribeSenderIds to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String
        /// The unique identifier for the pool to disassociate with the origination identity. This value can be either the PoolId or PoolArn.
        public let poolId: String

        public init(clientToken: String? = DisassociateOriginationIdentityRequest.idempotencyToken(), isoCountryCode: String, originationIdentity: String, poolId: String) {
            self.clientToken = clientToken
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case poolId = "PoolId"
        }
    }

    public struct DisassociateOriginationIdentityResult: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The PhoneNumberId or SenderId of the origination identity.
        public let originationIdentity: String?
        /// The PhoneNumberArn or SenderIdArn of the origination identity.
        public let originationIdentityArn: String?
        /// The Amazon Resource Name (ARN) of the pool.
        public let poolArn: String?
        /// The PoolId of the pool no longer associated with the origination identity.
        public let poolId: String?

        public init(isoCountryCode: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct EventDestination: AWSDecodableShape {
        /// An object that contains information about an event destination that sends logging events to Amazon CloudWatch logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// When set to true events will be logged.
        public let enabled: Bool
        /// The name of the EventDestination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log.
        public let matchingEventTypes: [EventType]
        /// An object that contains information about an event destination that sends logging events to Amazon SNS.
        public let snsDestination: SnsDestination?

        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, enabled: Bool, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType], snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case enabled = "Enabled"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct KeywordFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: KeywordFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: KeywordFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct KeywordInformation: AWSDecodableShape {
        /// The keyword as a string.
        public let keyword: String
        /// The action to perform for the keyword.
        public let keywordAction: KeywordAction
        /// A custom message that can be used with the keyword.
        public let keywordMessage: String

        public init(keyword: String, keywordAction: KeywordAction, keywordMessage: String) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
        }
    }

    public struct KinesisFirehoseDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let deliveryStreamArn: String
        /// The ARN of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon Firehose destination.
        public let iamRoleArn: String

        public init(deliveryStreamArn: String, iamRoleArn: String) {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, max: 2048)
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, min: 20)
            try self.validate(self.deliveryStreamArn, name: "deliveryStreamArn", parent: name, pattern: "^arn:\\S+$")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, max: 2048)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, min: 20)
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStreamArn = "DeliveryStreamArn"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct ListPoolOriginationIdentitiesRequest: AWSEncodableShape {
        /// An array of PoolOriginationIdentitiesFilter objects to filter the results..
        public let filters: [PoolOriginationIdentitiesFilter]?
        /// The maximum number of results to return per each request.
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
        public let nextToken: String?
        /// The unique identifier for the pool. This value can be either the PoolId or PoolArn.
        public let poolId: String

        public init(filters: [PoolOriginationIdentitiesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, poolId: String) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.poolId = poolId
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case poolId = "PoolId"
        }
    }

    public struct ListPoolOriginationIdentitiesResult: AWSDecodableShape {
        /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
        public let nextToken: String?
        /// An array of any OriginationIdentityMetadata objects.
        public let originationIdentities: [OriginationIdentityMetadata]?
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String?
        /// The unique PoolId of the pool.
        public let poolId: String?

        public init(nextToken: String? = nil, originationIdentities: [OriginationIdentityMetadata]? = nil, poolArn: String? = nil, poolId: String? = nil) {
            self.nextToken = nextToken
            self.originationIdentities = originationIdentities
            self.poolArn = poolArn
            self.poolId = poolId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case originationIdentities = "OriginationIdentities"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to query for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// The ARN of the resource.
        public let resourceArn: String?
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]?

        public init(resourceArn: String? = nil, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct OptOutListInformation: AWSDecodableShape {
        /// The time when the OutOutList was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// The Amazon Resource Name (ARN) of the OptOutList.
        public let optOutListArn: String
        /// The name of the OptOutList.
        public let optOutListName: String

        public init(createdTimestamp: Date, optOutListArn: String, optOutListName: String) {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct OptedOutFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: OptedOutFilterName
        /// An array of values to filter for.
        public let values: [String]

        public init(name: OptedOutFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct OptedOutNumberInformation: AWSDecodableShape {
        /// This is set to true if it was the end recipient that opted out.
        public let endUserOptedOut: Bool
        /// The phone number that is opted out.
        public let optedOutNumber: String
        /// The time that the op tout occurred, in UNIX epoch time format.
        public let optedOutTimestamp: Date

        public init(endUserOptedOut: Bool, optedOutNumber: String, optedOutTimestamp: Date) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
        }
    }

    public struct OriginationIdentityMetadata: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        public let numberCapabilities: [NumberCapability]
        /// The unique identifier of the origination identity.
        public let originationIdentity: String
        /// The Amazon Resource Name (ARN) associated with the origination identity.
        public let originationIdentityArn: String

        public init(isoCountryCode: String, numberCapabilities: [NumberCapability], originationIdentity: String, originationIdentityArn: String) {
            self.isoCountryCode = isoCountryCode
            self.numberCapabilities = numberCapabilities
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case numberCapabilities = "NumberCapabilities"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct PhoneNumberFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PhoneNumberFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: PhoneNumberFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PhoneNumberInformation: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The price, in US dollars, to lease the phone number.
        public let monthlyLeasingPrice: String
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        public let numberCapabilities: [NumberCapability]
        /// The type of phone number.
        public let numberType: NumberType
        /// The name of the OptOutList associated with the phone number.
        public let optOutListName: String
        /// The phone number in E.164 format.
        public let phoneNumber: String
        /// The Amazon Resource Name (ARN) associated with the phone number.
        public let phoneNumberArn: String
        /// The unique identifier for the phone number.
        public let phoneNumberId: String?
        /// The unique identifier of the pool associated with the phone number.
        public let poolId: String?
        /// When set to false an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out request. For more information see Self-managed opt-outs
        public let selfManagedOptOutsEnabled: Bool
        /// The current status of the phone number.
        public let status: NumberStatus
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        public let twoWayEnabled: Bool

        public init(createdTimestamp: Date, deletionProtectionEnabled: Bool, isoCountryCode: String, messageType: MessageType, monthlyLeasingPrice: String, numberCapabilities: [NumberCapability], numberType: NumberType, optOutListName: String, phoneNumber: String, phoneNumberArn: String, phoneNumberId: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool, status: NumberStatus, twoWayChannelArn: String? = nil, twoWayEnabled: Bool) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct PoolFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PoolFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: PoolFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PoolInformation: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String
        /// The Amazon Resource Name (ARN) for the pool.
        public let poolArn: String
        /// The unique identifier for the pool.
        public let poolId: String
        /// When set to false, an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests. For more information see Self-managed opt-outs
        public let selfManagedOptOutsEnabled: Bool
        /// Allows you to enable shared routes on your pool. By default, this is set to False. If you set this value to True, your messages are sent using phone numbers or sender IDs (depending on the country) that are shared with other Amazon Pinpoint users. In some countries, such as the United States, senders aren't allowed to use shared routes and must use a dedicated phone number or short code.
        public let sharedRoutesEnabled: Bool
        /// The current status of the pool.
        public let status: PoolStatus
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        public let twoWayEnabled: Bool

        public init(createdTimestamp: Date, deletionProtectionEnabled: Bool, messageType: MessageType, optOutListName: String, poolArn: String, poolId: String, selfManagedOptOutsEnabled: Bool, sharedRoutesEnabled: Bool, status: PoolStatus, twoWayChannelArn: String? = nil, twoWayEnabled: Bool) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct PoolOriginationIdentitiesFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: PoolOriginationIdentitiesFilterName
        /// An array values to filter for.
        public let values: [String]

        public init(name: PoolOriginationIdentitiesFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PutKeywordRequest: AWSEncodableShape {
        /// The new keyword to add.
        public let keyword: String
        /// The action to perform for the new keyword when it is received.
        public let keywordAction: KeywordAction?
        /// The message associated with the keyword.   AUTOMATIC_RESPONSE: A message is sent to the recipient.   OPT_OUT: Keeps the recipient from receiving future messages.   OPT_IN: The recipient wants to receive future messages.
        public let keywordMessage: String
        /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use DescribePhoneNumbers get the values for PhoneNumberId and PhoneNumberArn while DescribeSenderIds can be used to get the values for SenderId and SenderIdArn.
        public let originationIdentity: String

        public init(keyword: String, keywordAction: KeywordAction? = nil, keywordMessage: String, originationIdentity: String) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, max: 1600)
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, min: 1)
            try self.validate(self.keywordMessage, name: "keywordMessage", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
        }
    }

    public struct PutKeywordResult: AWSDecodableShape {
        /// The keyword that was added.
        public let keyword: String?
        /// The action to perform when the keyword is used.
        public let keywordAction: KeywordAction?
        /// The message associated with the keyword.
        public let keywordMessage: String?
        /// The PhoneNumberId or PoolId that the keyword was associated with.
        public let originationIdentity: String?
        /// The PhoneNumberArn or PoolArn that the keyword was associated with.
        public let originationIdentityArn: String?

        public init(keyword: String? = nil, keywordAction: KeywordAction? = nil, keywordMessage: String? = nil, originationIdentity: String? = nil, originationIdentityArn: String? = nil) {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case keywordAction = "KeywordAction"
            case keywordMessage = "KeywordMessage"
            case originationIdentity = "OriginationIdentity"
            case originationIdentityArn = "OriginationIdentityArn"
        }
    }

    public struct PutOptedOutNumberRequest: AWSEncodableShape {
        /// The phone number to add to the OptOutList in E.164 format.
        public let optedOutNumber: String
        /// The OptOutListName or OptOutListArn to add the phone number to.
        public let optOutListName: String

        public init(optedOutNumber: String, optOutListName: String) {
            self.optedOutNumber = optedOutNumber
            self.optOutListName = optOutListName
        }

        public func validate(name: String) throws {
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, max: 20)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, min: 1)
            try self.validate(self.optedOutNumber, name: "optedOutNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case optedOutNumber = "OptedOutNumber"
            case optOutListName = "OptOutListName"
        }
    }

    public struct PutOptedOutNumberResult: AWSDecodableShape {
        /// This is true if it was the end user who requested their phone number be removed.
        public let endUserOptedOut: Bool?
        /// The phone number that was added to the OptOutList.
        public let optedOutNumber: String?
        /// The time that the phone number was added to the OptOutList, in UNIX epoch time format.
        public let optedOutTimestamp: Date?
        /// The OptOutListArn that the phone number was removed from.
        public let optOutListArn: String?
        /// The OptOutListName that the phone number was removed from.
        public let optOutListName: String?

        public init(endUserOptedOut: Bool? = nil, optedOutNumber: String? = nil, optedOutTimestamp: Date? = nil, optOutListArn: String? = nil, optOutListName: String? = nil) {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }

        private enum CodingKeys: String, CodingKey {
            case endUserOptedOut = "EndUserOptedOut"
            case optedOutNumber = "OptedOutNumber"
            case optedOutTimestamp = "OptedOutTimestamp"
            case optOutListArn = "OptOutListArn"
            case optOutListName = "OptOutListName"
        }
    }

    public struct ReleasePhoneNumberRequest: AWSEncodableShape {
        /// The PhoneNumberId or PhoneNumberArn of the phone number to release. You can use DescribePhoneNumbers to get the values for PhoneNumberId and PhoneNumberArn.
        public let phoneNumberId: String

        public init(phoneNumberId: String) {
            self.phoneNumberId = phoneNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, max: 256)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, min: 1)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct ReleasePhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The message type that was associated with the phone number.
        public let messageType: MessageType?
        /// The monthly price of the phone number, in US dollars.
        public let monthlyLeasingPrice: String?
        /// Specifies if the number could be used for text messages, voice, or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was released.
        public let numberType: NumberType?
        /// The name of the OptOutList that was associated with the phone number.
        public let optOutListName: String?
        /// The phone number that was released.
        public let phoneNumber: String?
        /// The PhoneNumberArn of the phone number that was released.
        public let phoneNumberArn: String?
        /// The PhoneNumberId of the phone number that was released.
        public let phoneNumberId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// The Amazon Resource Name (ARN) of the TwoWayChannel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: NumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct RequestPhoneNumberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
        public let clientToken: String?
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType
        /// Indicates if the phone number will be used for text messages, voice messages, or both.
        public let numberCapabilities: [NumberCapability]
        /// The type of phone number to request.
        public let numberType: RequestableNumberType
        /// The name of the OptOutList to associate with the phone number. You can use the OutOutListName or OptPutListArn.
        public let optOutListName: String?
        /// The pool to associated with the phone number. You can use the PoolId or PoolArn.
        public let poolId: String?
        /// Use this field to attach your phone number for an external registration process.
        public let registrationId: String?
        /// An array of tags (key and value pairs) associate with the requested phone number.
        public let tags: [Tag]?

        public init(clientToken: String? = RequestPhoneNumberRequest.idempotencyToken(), deletionProtectionEnabled: Bool? = nil, isoCountryCode: String, messageType: MessageType, numberCapabilities: [NumberCapability], numberType: RequestableNumberType, optOutListName: String? = nil, poolId: String? = nil, registrationId: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.poolId = poolId
            self.registrationId = registrationId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.numberCapabilities, name: "numberCapabilities", parent: name, max: 2)
            try self.validate(self.numberCapabilities, name: "numberCapabilities", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 64)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^\\S+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case poolId = "PoolId"
            case registrationId = "RegistrationId"
            case tags = "Tags"
        }
    }

    public struct RequestPhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The monthly price, in US dollars, to lease the phone number.
        public let monthlyLeasingPrice: String?
        /// Indicates if the phone number will be used for text messages, voice messages or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was released.
        public let numberType: RequestableNumberType?
        /// The name of the OptOutList that is associated with the requested phone number.
        public let optOutListName: String?
        /// The new phone number that was requested.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the requested phone number.
        public let phoneNumberArn: String?
        /// The unique identifier of the new phone number.
        public let phoneNumberId: String?
        /// The unique identifier of the pool associated with the phone number
        public let poolId: String?
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// An array of key and value pair tags that are associated with the phone number.
        public let tags: [Tag]?
        /// The ARN used to identify the two way channel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: RequestableNumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, tags: [Tag]? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.tags = tags
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case tags = "Tags"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct SendTextMessageRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see Special requirements for sending SMS messages to recipients in India.
        public let destinationCountryParameters: [DestinationCountryParameterKey: String]?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
        public let dryRun: Bool?
        /// When you register a short code in the US, you must specify a program name. If you dont have a US short code, omit this attribute.
        public let keyword: String?
        /// The maximum amount that you want to spend, in US dollars, per each text message part. A text message can contain multiple parts.
        public let maxPrice: String?
        /// The body of the text message.
        public let messageBody: String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.
        public let originationIdentity: String?
        /// How long the text message is valid for. By default this is 72 hours.
        public let timeToLive: Int?

        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationCountryParameters: [DestinationCountryParameterKey: String]? = nil, destinationPhoneNumber: String, dryRun: Bool? = nil, keyword: String? = nil, maxPrice: String? = nil, messageBody: String? = nil, messageType: MessageType? = nil, originationIdentity: String? = nil, timeToLive: Int? = nil) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationCountryParameters = destinationCountryParameters
            self.destinationPhoneNumber = destinationPhoneNumber
            self.dryRun = dryRun
            self.keyword = keyword
            self.maxPrice = maxPrice
            self.messageBody = messageBody
            self.messageType = messageType
            self.originationIdentity = originationIdentity
            self.timeToLive = timeToLive
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.destinationCountryParameters?.forEach {
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, max: 64)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "destinationCountryParameters[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.destinationCountryParameters, name: "destinationCountryParameters", parent: name, max: 10)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.keyword, name: "keyword", parent: name, max: 30)
            try self.validate(self.keyword, name: "keyword", parent: name, min: 1)
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "^[ \\S]+$")
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, max: 8)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, min: 2)
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, pattern: "^[0-9]{0,2}\\.[0-9]{1,5}$")
            try self.validate(self.messageBody, name: "messageBody", parent: name, max: 1600)
            try self.validate(self.messageBody, name: "messageBody", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, max: 259_200)
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationCountryParameters = "DestinationCountryParameters"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case dryRun = "DryRun"
            case keyword = "Keyword"
            case maxPrice = "MaxPrice"
            case messageBody = "MessageBody"
            case messageType = "MessageType"
            case originationIdentity = "OriginationIdentity"
            case timeToLive = "TimeToLive"
        }
    }

    public struct SendTextMessageResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String?

        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendVoiceMessageRequest: AWSEncodableShape {
        /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String?
        /// You can specify custom data in this field. If you do, that data is logged to the event destination.
        public let context: [String: String]?
        /// The destination phone number in E.164 format.
        public let destinationPhoneNumber: String
        /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
        public let dryRun: Bool?
        /// The maximum amount to spend per voice message, in US dollars.
        public let maxPricePerMinute: String?
        /// The text to convert to a voice message.
        public let messageBody: String?
        /// Specifies if the MessageBody field contains text or speech synthesis markup language (SSML).   TEXT: This is the default value. When used the maximum character limit is 3000.   SSML: When used the maximum character limit is 6000 including SSML tagging.
        public let messageBodyTextType: VoiceMessageBodyTextType?
        /// The origination identity to use for the voice call. This can be the PhoneNumber, PhoneNumberId, PhoneNumberArn, PoolId, or PoolArn.
        public let originationIdentity: String
        /// How long the voice message is valid for. By default this is 72 hours.
        public let timeToLive: Int?
        /// The voice for the Amazon Polly service to use. By default this is set to "MATTHEW".
        public let voiceId: VoiceId?

        public init(configurationSetName: String? = nil, context: [String: String]? = nil, destinationPhoneNumber: String, dryRun: Bool? = nil, maxPricePerMinute: String? = nil, messageBody: String? = nil, messageBodyTextType: VoiceMessageBodyTextType? = nil, originationIdentity: String, timeToLive: Int? = nil, voiceId: VoiceId? = nil) {
            self.configurationSetName = configurationSetName
            self.context = context
            self.destinationPhoneNumber = destinationPhoneNumber
            self.dryRun = dryRun
            self.maxPricePerMinute = maxPricePerMinute
            self.messageBody = messageBody
            self.messageBodyTextType = messageBodyTextType
            self.originationIdentity = originationIdentity
            self.timeToLive = timeToLive
            self.voiceId = voiceId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.context?.forEach {
                try validate($0.key, name: "context.key", parent: name, max: 100)
                try validate($0.key, name: "context.key", parent: name, min: 1)
                try validate($0.key, name: "context.key", parent: name, pattern: "^\\S+$")
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "context[\"\($0.key)\"]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.context, name: "context", parent: name, max: 5)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, max: 20)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, min: 1)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\+?[1-9][0-9]{1,18}$")
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, max: 8)
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, min: 2)
            try self.validate(self.maxPricePerMinute, name: "maxPricePerMinute", parent: name, pattern: "^[0-9]{0,2}\\.[0-9]{1,5}$")
            try self.validate(self.messageBody, name: "messageBody", parent: name, max: 6000)
            try self.validate(self.messageBody, name: "messageBody", parent: name, min: 1)
            try self.validate(self.messageBody, name: "messageBody", parent: name, pattern: "^(?!\\s*$)[\\s\\S]+$")
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, max: 256)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, min: 1)
            try self.validate(self.originationIdentity, name: "originationIdentity", parent: name, pattern: "^[A-Za-z0-9_:/\\+-]+$")
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, max: 259_200)
            try self.validate(self.timeToLive, name: "timeToLive", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case context = "Context"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case dryRun = "DryRun"
            case maxPricePerMinute = "MaxPricePerMinute"
            case messageBody = "MessageBody"
            case messageBodyTextType = "MessageBodyTextType"
            case originationIdentity = "OriginationIdentity"
            case timeToLive = "TimeToLive"
            case voiceId = "VoiceId"
        }
    }

    public struct SendVoiceMessageResult: AWSDecodableShape {
        /// The unique identifier for the message.
        public let messageId: String?

        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SenderIdAndCountry: AWSEncodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The unique identifier of the sender.
        public let senderId: String

        public init(isoCountryCode: String, senderId: String) {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, max: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, min: 2)
            try self.validate(self.isoCountryCode, name: "isoCountryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 256)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case senderId = "SenderId"
        }
    }

    public struct SenderIdFilter: AWSEncodableShape {
        /// The name of the attribute to filter on.
        public let name: SenderIdFilterName
        /// An array of values to filter for.
        public let values: [String]

        public init(name: SenderIdFilterName, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct SenderIdInformation: AWSDecodableShape {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageTypes: [MessageType]
        /// The monthly leasing price, in US dollars.
        public let monthlyLeasingPrice: String
        /// The alphanumeric sender ID in a specific country that you'd like to describe.
        public let senderId: String
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        public let senderIdArn: String

        public init(isoCountryCode: String, messageTypes: [MessageType], monthlyLeasingPrice: String, senderId: String, senderIdArn: String) {
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case messageTypes = "MessageTypes"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case senderId = "SenderId"
            case senderIdArn = "SenderIdArn"
        }
    }

    public struct SetDefaultMessageTypeRequest: AWSEncodableShape {
        /// The configuration set to update with a new default message type. This field can be the ConsigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType

        public init(configurationSetName: String, messageType: MessageType) {
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct SetDefaultMessageTypeResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set that was updated.
        public let configurationSetName: String?
        /// The new default message type of the configuration set.
        public let messageType: MessageType?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, messageType: MessageType? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.messageType = messageType
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case messageType = "MessageType"
        }
    }

    public struct SetDefaultSenderIdRequest: AWSEncodableShape {
        /// The configuration set to updated with a new default SenderId. This field can be the ConsigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// The current sender ID for the configuration set. When sending a text message to a destination country which supports SenderIds, the default sender ID on the configuration set specified on SendTextMessage will be used if no dedicated origination phone numbers or registered SenderIds are available in your account, instead of a generic sender ID, such as 'NOTICE'.
        public let senderId: String

        public init(configurationSetName: String, senderId: String) {
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.senderId, name: "senderId", parent: name, max: 11)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[A-Za-z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct SetDefaultSenderIdResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated configuration set.
        public let configurationSetArn: String?
        /// The name of the configuration set that was updated.
        public let configurationSetName: String?
        /// The default sender ID to set for the ConfigurationSet.
        public let senderId: String?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, senderId: String? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case senderId = "SenderId"
        }
    }

    public struct SetTextMessageSpendLimitOverrideRequest: AWSEncodableShape {
        /// The new monthly limit to enforce on text messages.
        public let monthlyLimit: Int64

        public init(monthlyLimit: Int64) {
            self.monthlyLimit = monthlyLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, max: 1_000_000_000)
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetTextMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit to enforce on sending text messages.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetVoiceMessageSpendLimitOverrideRequest: AWSEncodableShape {
        /// The new monthly limit to enforce on voice messages.
        public let monthlyLimit: Int64

        public init(monthlyLimit: Int64) {
            self.monthlyLimit = monthlyLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, max: 1_000_000_000)
            try self.validate(self.monthlyLimit, name: "monthlyLimit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SetVoiceMessageSpendLimitOverrideResult: AWSDecodableShape {
        /// The current monthly limit to enforce on sending voice messages.
        public let monthlyLimit: Int64?

        public init(monthlyLimit: Int64? = nil) {
            self.monthlyLimit = monthlyLimit
        }

        private enum CodingKeys: String, CodingKey {
            case monthlyLimit = "MonthlyLimit"
        }
    }

    public struct SnsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        public let topicArn: String

        public init(topicArn: String) {
            self.topicArn = topicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.topicArn, name: "topicArn", parent: name, max: 2048)
            try self.validate(self.topicArn, name: "topicArn", parent: name, min: 20)
            try self.validate(self.topicArn, name: "topicArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct SpendLimit: AWSDecodableShape {
        /// The maximum amount of money, in US dollars, that you want to be able to spend sending messages each month. This value has to be less than or equal to the amount in MaxLimit. To use this custom limit, Overridden must be set to true.
        public let enforcedLimit: Int64
        ///  The maximum amount of money that you are able to spend to send messages each month, in US dollars.
        public let maxLimit: Int64
        /// The name for the SpendLimit.
        public let name: SpendLimitName
        /// When set to True, the value that has been specified in the EnforcedLimit is used to determine the maximum amount in US dollars that can be spent to send messages each month, in US dollars.
        public let overridden: Bool

        public init(enforcedLimit: Int64, maxLimit: Int64, name: SpendLimitName, overridden: Bool) {
            self.enforcedLimit = enforcedLimit
            self.maxLimit = maxLimit
            self.name = name
            self.overridden = overridden
        }

        private enum CodingKeys: String, CodingKey {
            case enforcedLimit = "EnforcedLimit"
            case maxLimit = "MaxLimit"
            case name = "Name"
            case overridden = "Overridden"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key identifier, or name, of the tag.
        public let key: String
        /// The string value associated with the key of the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^.+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// An array of key and value pair tags that are associated with the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// An array of tag key values to unassociate with the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[A-Za-z0-9_:/-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^.+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEventDestinationRequest: AWSEncodableShape {
        /// An object that contains information about an event destination that sends data to CloudWatch Logs.
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// The configuration set to update with the new event destination. Valid values for this can be the ConfigurationSetName or ConfigurationSetArn.
        public let configurationSetName: String
        /// When set to true logging is enabled.
        public let enabled: Bool?
        /// The name to use for the event destination.
        public let eventDestinationName: String
        /// An object that contains information about an event destination for logging to Kinesis Data Firehose.
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        /// An array of event types that determine which events to log.
        public let matchingEventTypes: [EventType]?
        /// An object that contains information about an event destination that sends data to Amazon SNS.
        public let snsDestination: SnsDestination?

        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, configurationSetName: String, enabled: Bool? = nil, eventDestinationName: String, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType]? = nil, snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.configurationSetName = configurationSetName
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsDestination?.validate(name: "\(name).cloudWatchLogsDestination")
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, max: 256)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, min: 1)
            try self.validate(self.configurationSetName, name: "configurationSetName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, max: 64)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, min: 1)
            try self.validate(self.eventDestinationName, name: "eventDestinationName", parent: name, pattern: "^[A-Za-z0-9_-]+$")
            try self.kinesisFirehoseDestination?.validate(name: "\(name).kinesisFirehoseDestination")
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, max: 25)
            try self.validate(self.matchingEventTypes, name: "matchingEventTypes", parent: name, min: 1)
            try self.snsDestination?.validate(name: "\(name).snsDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case configurationSetName = "ConfigurationSetName"
            case enabled = "Enabled"
            case eventDestinationName = "EventDestinationName"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct UpdateEventDestinationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the ConfigurationSet that was updated.
        public let configurationSetArn: String?
        /// The name of the configuration set.
        public let configurationSetName: String?
        /// An EventDestination object containing the details of where events will be logged.
        public let eventDestination: EventDestination?

        public init(configurationSetArn: String? = nil, configurationSetName: String? = nil, eventDestination: EventDestination? = nil) {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetArn = "ConfigurationSetArn"
            case configurationSetName = "ConfigurationSetName"
            case eventDestination = "EventDestination"
        }
    }

    public struct UpdatePhoneNumberRequest: AWSEncodableShape {
        /// By default this is set to false. When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The OptOutList to add the phone number to. Valid values for this field can be either the OutOutListName or OutOutListArn.
        public let optOutListName: String?
        /// The unique identifier of the phone number. Valid values for this field can be either the PhoneNumberId or PhoneNumberArn.
        public let phoneNumberId: String
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(deletionProtectionEnabled: Bool? = nil, optOutListName: String? = nil, phoneNumberId: String, selfManagedOptOutsEnabled: Bool? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.optOutListName = optOutListName
            self.phoneNumberId = phoneNumberId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, max: 256)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, min: 1)
            try self.validate(self.phoneNumberId, name: "phoneNumberId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, max: 2048)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, min: 20)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case optOutListName = "OptOutListName"
            case phoneNumberId = "PhoneNumberId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePhoneNumberResult: AWSDecodableShape {
        /// The time when the phone number was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true the phone number can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public let isoCountryCode: String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public let messageType: MessageType?
        /// The monthly leasing price of the phone number, in US dollars.
        public let monthlyLeasingPrice: String?
        /// Specifies if the number could be used for text messages, voice or both.
        public let numberCapabilities: [NumberCapability]?
        /// The type of number that was requested.
        public let numberType: NumberType?
        /// The name of the OptOutList associated with the phone number.
        public let optOutListName: String?
        /// The phone number that was updated.
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the updated phone number.
        public let phoneNumberArn: String?
        /// The unique identifier of the phone number.
        public let phoneNumberId: String?
        /// This is true if self managed opt-out are enabled.
        public let selfManagedOptOutsEnabled: Bool?
        /// The current status of the request.
        public let status: NumberStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, isoCountryCode: String? = nil, messageType: MessageType? = nil, monthlyLeasingPrice: String? = nil, numberCapabilities: [NumberCapability]? = nil, numberType: NumberType? = nil, optOutListName: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, status: NumberStatus? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case isoCountryCode = "IsoCountryCode"
            case messageType = "MessageType"
            case monthlyLeasingPrice = "MonthlyLeasingPrice"
            case numberCapabilities = "NumberCapabilities"
            case numberType = "NumberType"
            case optOutListName = "OptOutListName"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePoolRequest: AWSEncodableShape {
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The OptOutList to associate with the pool. Valid values are either OptOutListName or OptOutListArn.
        public let optOutListName: String?
        /// The unique identifier of the pool to update. Valid values are either the PoolId or PoolArn.
        public let poolId: String
        /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(deletionProtectionEnabled: Bool? = nil, optOutListName: String? = nil, poolId: String, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.optOutListName = optOutListName
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, max: 256)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, min: 1)
            try self.validate(self.optOutListName, name: "optOutListName", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.poolId, name: "poolId", parent: name, max: 256)
            try self.validate(self.poolId, name: "poolId", parent: name, min: 1)
            try self.validate(self.poolId, name: "poolId", parent: name, pattern: "^[A-Za-z0-9_:/-]+$")
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, max: 2048)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, min: 20)
            try self.validate(self.twoWayChannelArn, name: "twoWayChannelArn", parent: name, pattern: "^arn:\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case optOutListName = "OptOutListName"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }

    public struct UpdatePoolResult: AWSDecodableShape {
        /// The time when the pool was created, in UNIX epoch time format.
        public let createdTimestamp: Date?
        /// When set to true the pool can't be deleted.
        public let deletionProtectionEnabled: Bool?
        /// The type of message for the pool to use.
        public let messageType: MessageType?
        /// The name of the OptOutList associated with the pool.
        public let optOutListName: String?
        /// The ARN of the pool.
        public let poolArn: String?
        /// The unique identifier of the pool.
        public let poolId: String?
        /// When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
        public let selfManagedOptOutsEnabled: Bool?
        /// Indicates whether shared routes are enabled for the pool.
        public let sharedRoutesEnabled: Bool?
        /// The current status of the pool update request.
        public let status: PoolStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public let twoWayChannelArn: String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
        public let twoWayEnabled: Bool?

        public init(createdTimestamp: Date? = nil, deletionProtectionEnabled: Bool? = nil, messageType: MessageType? = nil, optOutListName: String? = nil, poolArn: String? = nil, poolId: String? = nil, selfManagedOptOutsEnabled: Bool? = nil, sharedRoutesEnabled: Bool? = nil, status: PoolStatus? = nil, twoWayChannelArn: String? = nil, twoWayEnabled: Bool? = nil) {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case messageType = "MessageType"
            case optOutListName = "OptOutListName"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
            case sharedRoutesEnabled = "SharedRoutesEnabled"
            case status = "Status"
            case twoWayChannelArn = "TwoWayChannelArn"
            case twoWayEnabled = "TwoWayEnabled"
        }
    }
}

// MARK: - Errors

/// Error enum for PinpointSMSVoiceV2
public struct PinpointSMSVoiceV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PinpointSMSVoiceV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied because you don&#39;t have sufficient permissions to access the resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Your request has conflicting operations. This can occur if you&#39;re trying to perform more than one operation on the same resource at the same time or it could be that the requested action isn&#39;t valid for the current state or configuration of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The API encountered an unexpected error and couldn&#39;t complete the request. You might be able to successfully issue the request again in the future.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A requested resource couldn&#39;t be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// An error that occurred because too many requests were sent during a certain amount of time.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// A validation exception for a field.
    public static var validationException: Self { .init(.validationException) }
}

extension PinpointSMSVoiceV2ErrorType: Equatable {
    public static func == (lhs: PinpointSMSVoiceV2ErrorType, rhs: PinpointSMSVoiceV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PinpointSMSVoiceV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
