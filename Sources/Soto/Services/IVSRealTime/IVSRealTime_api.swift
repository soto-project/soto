//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS IVSRealTime service.
///
/// The Amazon Interactive Video Service (IVS) real-time API is REST compatible, using a standard HTTP
/// 	  API and an AWS EventBridge event stream for responses. JSON is used for both requests and responses,
/// 	  including errors.   Key Concepts     Stage — A virtual space where participants can exchange video in real time.    Participant token — A token that authenticates a participant when they join a stage.    Participant object — Represents participants (people) in the stage and contains information about them. When a token is created, it includes a participant ID; when a participant uses that token to join a stage, the participant is associated with that participant ID. There is a 1:1 mapping between participant tokens and participants.   For server-side composition:    Composition process — Composites participants of a stage into a single video and forwards it to a set of outputs (e.g., IVS channels). Composition operations support this process.    Composition — Controls the look of the outputs, including how participants are positioned in the video.   For more information about your IVS live stream, also see Getting Started with Amazon IVS Real-Time Streaming.  Tagging  A tag is a metadata label that you assign to an AWS resource. A tag comprises a key and a value, both set by you. For example, you might set a tag as topic:nature to label a particular video category. See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS stages has no service-specific constraints beyond what is documented there. Tags can help you identify and organize your AWS resources. For example, you can use the same tag for different resources to indicate that they are related. You can also use tags to manage access (see Access Tags). The Amazon IVS real-time API has these tag-related operations: TagResource, UntagResource, and ListTagsForResource. The following resource supports tagging: Stage. At most 50 tags can be applied to a resource.
public struct IVSRealTime: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the IVSRealTime client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "IVSRealTime",
            serviceIdentifier: "ivsrealtime",
            signingName: "ivs",
            serviceProtocol: .restjson,
            apiVersion: "2020-07-14",
            endpoint: endpoint,
            errorType: IVSRealTimeErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates an EncoderConfiguration object.
    @Sendable
    @inlinable
    public func createEncoderConfiguration(_ input: CreateEncoderConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEncoderConfigurationResponse {
        try await self.client.execute(
            operation: "CreateEncoderConfiguration", 
            path: "/CreateEncoderConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an EncoderConfiguration object.
    ///
    /// Parameters:
    ///   - name: Optional name to identify the resource.
    ///   - tags: Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    ///   - video: Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps.
    ///   - logger: Logger use during operation
    @inlinable
    public func createEncoderConfiguration(
        name: String? = nil,
        tags: [String: String]? = nil,
        video: Video? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEncoderConfigurationResponse {
        let input = CreateEncoderConfigurationRequest(
            name: name, 
            tags: tags, 
            video: video
        )
        return try await self.createEncoderConfiguration(input, logger: logger)
    }

    /// Creates a new IngestConfiguration resource, used to specify the ingest protocol for a stage.
    @Sendable
    @inlinable
    public func createIngestConfiguration(_ input: CreateIngestConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIngestConfigurationResponse {
        try await self.client.execute(
            operation: "CreateIngestConfiguration", 
            path: "/CreateIngestConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new IngestConfiguration resource, used to specify the ingest protocol for a stage.
    ///
    /// Parameters:
    ///   - attributes: Application-provided attributes to store in the IngestConfiguration and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    ///   - ingestProtocol: Type of ingest protocol that the user employs to broadcast. If this is set to RTMP, insecureIngest must be set to true.
    ///   - insecureIngest: Whether the stage allows insecure RTMP ingest. This must be set to true, if ingestProtocol is set to RTMP. Default: false.
    ///   - name: Optional name that can be specified for the IngestConfiguration being created.
    ///   - stageArn: ARN of the stage with which the IngestConfiguration is associated.
    ///   - tags: Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented
    ///   - userId: Customer-assigned name to help identify the participant using the IngestConfiguration; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIngestConfiguration(
        attributes: [String: String]? = nil,
        ingestProtocol: IngestProtocol,
        insecureIngest: Bool? = nil,
        name: String? = nil,
        stageArn: String? = nil,
        tags: [String: String]? = nil,
        userId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIngestConfigurationResponse {
        let input = CreateIngestConfigurationRequest(
            attributes: attributes, 
            ingestProtocol: ingestProtocol, 
            insecureIngest: insecureIngest, 
            name: name, 
            stageArn: stageArn, 
            tags: tags, 
            userId: userId
        )
        return try await self.createIngestConfiguration(input, logger: logger)
    }

    /// Creates an additional token for a specified stage. This can be done after stage creation or when tokens expire. Tokens always are scoped to the stage for which they are created. Encryption keys are owned by Amazon IVS and never used directly by your application.
    @Sendable
    @inlinable
    public func createParticipantToken(_ input: CreateParticipantTokenRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateParticipantTokenResponse {
        try await self.client.execute(
            operation: "CreateParticipantToken", 
            path: "/CreateParticipantToken", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an additional token for a specified stage. This can be done after stage creation or when tokens expire. Tokens always are scoped to the stage for which they are created. Encryption keys are owned by Amazon IVS and never used directly by your application.
    ///
    /// Parameters:
    ///   - attributes: Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    ///   - capabilities: Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
    ///   - duration: Duration (in minutes), after which the token expires. Default: 720 (12 hours).
    ///   - stageArn: ARN of the stage to which this token is scoped.
    ///   - userId: Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    ///   - logger: Logger use during operation
    @inlinable
    public func createParticipantToken(
        attributes: [String: String]? = nil,
        capabilities: [ParticipantTokenCapability]? = nil,
        duration: Int? = nil,
        stageArn: String,
        userId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateParticipantTokenResponse {
        let input = CreateParticipantTokenRequest(
            attributes: attributes, 
            capabilities: capabilities, 
            duration: duration, 
            stageArn: stageArn, 
            userId: userId
        )
        return try await self.createParticipantToken(input, logger: logger)
    }

    /// Creates a new stage (and optionally participant tokens).
    @Sendable
    @inlinable
    public func createStage(_ input: CreateStageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStageResponse {
        try await self.client.execute(
            operation: "CreateStage", 
            path: "/CreateStage", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new stage (and optionally participant tokens).
    ///
    /// Parameters:
    ///   - autoParticipantRecordingConfiguration: Configuration object for individual participant recording, to attach to the new stage.
    ///   - name: Optional name that can be specified for the stage being created.
    ///   - participantTokenConfigurations: Array of participant token configuration objects to attach to the new stage.
    ///   - tags: Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStage(
        autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration? = nil,
        name: String? = nil,
        participantTokenConfigurations: [ParticipantTokenConfiguration]? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStageResponse {
        let input = CreateStageRequest(
            autoParticipantRecordingConfiguration: autoParticipantRecordingConfiguration, 
            name: name, 
            participantTokenConfigurations: participantTokenConfigurations, 
            tags: tags
        )
        return try await self.createStage(input, logger: logger)
    }

    /// Creates a new storage configuration, used to enable recording to Amazon S3.
    /// 	  When a StorageConfiguration is created, IVS will modify the S3 bucketPolicy of the provided bucket.
    /// 	  This will ensure that IVS has sufficient permissions to write content to the provided bucket.
    @Sendable
    @inlinable
    public func createStorageConfiguration(_ input: CreateStorageConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStorageConfigurationResponse {
        try await self.client.execute(
            operation: "CreateStorageConfiguration", 
            path: "/CreateStorageConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new storage configuration, used to enable recording to Amazon S3.
    /// 	  When a StorageConfiguration is created, IVS will modify the S3 bucketPolicy of the provided bucket.
    /// 	  This will ensure that IVS has sufficient permissions to write content to the provided bucket.
    ///
    /// Parameters:
    ///   - name: Storage configuration name. The value does not need to be unique.
    ///   - s3: A complex type that contains a storage configuration for where recorded video will be stored.
    ///   - tags: Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies
    ///   - logger: Logger use during operation
    @inlinable
    public func createStorageConfiguration(
        name: String? = nil,
        s3: S3StorageConfiguration,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStorageConfigurationResponse {
        let input = CreateStorageConfigurationRequest(
            name: name, 
            s3: s3, 
            tags: tags
        )
        return try await self.createStorageConfiguration(input, logger: logger)
    }

    /// Deletes an EncoderConfiguration resource. Ensures that no Compositions are using this template; otherwise, returns an error.
    @Sendable
    @inlinable
    public func deleteEncoderConfiguration(_ input: DeleteEncoderConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEncoderConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteEncoderConfiguration", 
            path: "/DeleteEncoderConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an EncoderConfiguration resource. Ensures that no Compositions are using this template; otherwise, returns an error.
    ///
    /// Parameters:
    ///   - arn: ARN of the EncoderConfiguration.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteEncoderConfiguration(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteEncoderConfigurationResponse {
        let input = DeleteEncoderConfigurationRequest(
            arn: arn
        )
        return try await self.deleteEncoderConfiguration(input, logger: logger)
    }

    /// Deletes a specified IngestConfiguration, so it can no longer be used to broadcast. An IngestConfiguration cannot be deleted if the publisher is actively streaming to a stage, unless force is set to true.
    @Sendable
    @inlinable
    public func deleteIngestConfiguration(_ input: DeleteIngestConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIngestConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteIngestConfiguration", 
            path: "/DeleteIngestConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified IngestConfiguration, so it can no longer be used to broadcast. An IngestConfiguration cannot be deleted if the publisher is actively streaming to a stage, unless force is set to true.
    ///
    /// Parameters:
    ///   - arn: ARN of the IngestConfiguration.
    ///   - force: Optional field to force deletion of the IngestConfiguration. If this is set to true when a participant is actively publishing, the participant is disconnected from the stage, followed by deletion of the IngestConfiguration. Default: false.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIngestConfiguration(
        arn: String,
        force: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIngestConfigurationResponse {
        let input = DeleteIngestConfigurationRequest(
            arn: arn, 
            force: force
        )
        return try await self.deleteIngestConfiguration(input, logger: logger)
    }

    /// Deletes the specified public key used to sign stage participant tokens.
    /// 	  This invalidates future participant tokens generated using the key pair’s private key.
    @Sendable
    @inlinable
    public func deletePublicKey(_ input: DeletePublicKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePublicKeyResponse {
        try await self.client.execute(
            operation: "DeletePublicKey", 
            path: "/DeletePublicKey", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified public key used to sign stage participant tokens.
    /// 	  This invalidates future participant tokens generated using the key pair’s private key.
    ///
    /// Parameters:
    ///   - arn: ARN of the public key to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePublicKey(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePublicKeyResponse {
        let input = DeletePublicKeyRequest(
            arn: arn
        )
        return try await self.deletePublicKey(input, logger: logger)
    }

    /// Shuts down and deletes the specified stage (disconnecting all participants). This operation also removes the stageArn from the associated IngestConfiguration, if there are participants
    /// 	    using the IngestConfiguration to publish to the stage.
    @Sendable
    @inlinable
    public func deleteStage(_ input: DeleteStageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStageResponse {
        try await self.client.execute(
            operation: "DeleteStage", 
            path: "/DeleteStage", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Shuts down and deletes the specified stage (disconnecting all participants). This operation also removes the stageArn from the associated IngestConfiguration, if there are participants
    /// 	    using the IngestConfiguration to publish to the stage.
    ///
    /// Parameters:
    ///   - arn: ARN of the stage to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStage(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStageResponse {
        let input = DeleteStageRequest(
            arn: arn
        )
        return try await self.deleteStage(input, logger: logger)
    }

    /// Deletes the storage configuration for the specified ARN. If you try to delete a storage configuration that is used by a Composition, you will get an error (409 ConflictException).
    /// 	  To avoid this, for all Compositions that reference the storage configuration, first use StopComposition and wait for it to complete,
    /// 	  then use DeleteStorageConfiguration.
    @Sendable
    @inlinable
    public func deleteStorageConfiguration(_ input: DeleteStorageConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStorageConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteStorageConfiguration", 
            path: "/DeleteStorageConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the storage configuration for the specified ARN. If you try to delete a storage configuration that is used by a Composition, you will get an error (409 ConflictException).
    /// 	  To avoid this, for all Compositions that reference the storage configuration, first use StopComposition and wait for it to complete,
    /// 	  then use DeleteStorageConfiguration.
    ///
    /// Parameters:
    ///   - arn: ARN of the storage configuration to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStorageConfiguration(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStorageConfigurationResponse {
        let input = DeleteStorageConfigurationRequest(
            arn: arn
        )
        return try await self.deleteStorageConfiguration(input, logger: logger)
    }

    /// Disconnects a specified participant from a specified stage. If the participant is publishing using an IngestConfiguration, DisconnectParticipant also updates the stageArn
    /// 	    in the IngestConfiguration to be an empty string.
    @Sendable
    @inlinable
    public func disconnectParticipant(_ input: DisconnectParticipantRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisconnectParticipantResponse {
        try await self.client.execute(
            operation: "DisconnectParticipant", 
            path: "/DisconnectParticipant", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disconnects a specified participant from a specified stage. If the participant is publishing using an IngestConfiguration, DisconnectParticipant also updates the stageArn
    /// 	    in the IngestConfiguration to be an empty string.
    ///
    /// Parameters:
    ///   - participantId: Identifier of the participant to be disconnected. IVS assigns this; it is returned by CreateParticipantToken (for streams using WebRTC ingest) or CreateIngestConfiguration (for
    ///   - reason: Description of why this participant is being disconnected.
    ///   - stageArn: ARN of the stage to which the participant is attached.
    ///   - logger: Logger use during operation
    @inlinable
    public func disconnectParticipant(
        participantId: String,
        reason: String? = nil,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisconnectParticipantResponse {
        let input = DisconnectParticipantRequest(
            participantId: participantId, 
            reason: reason, 
            stageArn: stageArn
        )
        return try await self.disconnectParticipant(input, logger: logger)
    }

    /// Get information about the specified Composition resource.
    @Sendable
    @inlinable
    public func getComposition(_ input: GetCompositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCompositionResponse {
        try await self.client.execute(
            operation: "GetComposition", 
            path: "/GetComposition", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get information about the specified Composition resource.
    ///
    /// Parameters:
    ///   - arn: ARN of the Composition resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func getComposition(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCompositionResponse {
        let input = GetCompositionRequest(
            arn: arn
        )
        return try await self.getComposition(input, logger: logger)
    }

    /// Gets information about the specified EncoderConfiguration resource.
    @Sendable
    @inlinable
    public func getEncoderConfiguration(_ input: GetEncoderConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEncoderConfigurationResponse {
        try await self.client.execute(
            operation: "GetEncoderConfiguration", 
            path: "/GetEncoderConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified EncoderConfiguration resource.
    ///
    /// Parameters:
    ///   - arn: ARN of the EncoderConfiguration resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEncoderConfiguration(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEncoderConfigurationResponse {
        let input = GetEncoderConfigurationRequest(
            arn: arn
        )
        return try await self.getEncoderConfiguration(input, logger: logger)
    }

    /// Gets information about the specified IngestConfiguration.
    @Sendable
    @inlinable
    public func getIngestConfiguration(_ input: GetIngestConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIngestConfigurationResponse {
        try await self.client.execute(
            operation: "GetIngestConfiguration", 
            path: "/GetIngestConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified IngestConfiguration.
    ///
    /// Parameters:
    ///   - arn: ARN of the ingest for which the information is to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIngestConfiguration(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIngestConfigurationResponse {
        let input = GetIngestConfigurationRequest(
            arn: arn
        )
        return try await self.getIngestConfiguration(input, logger: logger)
    }

    /// Gets information about the specified participant token.
    @Sendable
    @inlinable
    public func getParticipant(_ input: GetParticipantRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetParticipantResponse {
        try await self.client.execute(
            operation: "GetParticipant", 
            path: "/GetParticipant", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about the specified participant token.
    ///
    /// Parameters:
    ///   - participantId: Unique identifier for the participant. This is assigned by IVS and returned by CreateParticipantToken.
    ///   - sessionId: ID of a session within the stage.
    ///   - stageArn: Stage ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func getParticipant(
        participantId: String,
        sessionId: String,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetParticipantResponse {
        let input = GetParticipantRequest(
            participantId: participantId, 
            sessionId: sessionId, 
            stageArn: stageArn
        )
        return try await self.getParticipant(input, logger: logger)
    }

    /// Gets information for the specified public key.
    @Sendable
    @inlinable
    public func getPublicKey(_ input: GetPublicKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPublicKeyResponse {
        try await self.client.execute(
            operation: "GetPublicKey", 
            path: "/GetPublicKey", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information for the specified public key.
    ///
    /// Parameters:
    ///   - arn: ARN of the public key for which the information is to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPublicKey(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPublicKeyResponse {
        let input = GetPublicKeyRequest(
            arn: arn
        )
        return try await self.getPublicKey(input, logger: logger)
    }

    /// Gets information for the specified stage.
    @Sendable
    @inlinable
    public func getStage(_ input: GetStageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStageResponse {
        try await self.client.execute(
            operation: "GetStage", 
            path: "/GetStage", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information for the specified stage.
    ///
    /// Parameters:
    ///   - arn: ARN of the stage for which the information is to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStage(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStageResponse {
        let input = GetStageRequest(
            arn: arn
        )
        return try await self.getStage(input, logger: logger)
    }

    /// Gets information for the specified stage session.
    @Sendable
    @inlinable
    public func getStageSession(_ input: GetStageSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStageSessionResponse {
        try await self.client.execute(
            operation: "GetStageSession", 
            path: "/GetStageSession", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information for the specified stage session.
    ///
    /// Parameters:
    ///   - sessionId: ID of a session within the stage.
    ///   - stageArn: ARN of the stage for which the information is to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStageSession(
        sessionId: String,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStageSessionResponse {
        let input = GetStageSessionRequest(
            sessionId: sessionId, 
            stageArn: stageArn
        )
        return try await self.getStageSession(input, logger: logger)
    }

    /// Gets the storage configuration for the specified ARN.
    @Sendable
    @inlinable
    public func getStorageConfiguration(_ input: GetStorageConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStorageConfigurationResponse {
        try await self.client.execute(
            operation: "GetStorageConfiguration", 
            path: "/GetStorageConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the storage configuration for the specified ARN.
    ///
    /// Parameters:
    ///   - arn: ARN of the storage configuration to be retrieved.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStorageConfiguration(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStorageConfigurationResponse {
        let input = GetStorageConfigurationRequest(
            arn: arn
        )
        return try await self.getStorageConfiguration(input, logger: logger)
    }

    /// Import a public key to be used for signing stage participant tokens.
    @Sendable
    @inlinable
    public func importPublicKey(_ input: ImportPublicKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportPublicKeyResponse {
        try await self.client.execute(
            operation: "ImportPublicKey", 
            path: "/ImportPublicKey", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Import a public key to be used for signing stage participant tokens.
    ///
    /// Parameters:
    ///   - name: Name of the public key to be imported.
    ///   - publicKeyMaterial: The content of the public key to be imported.
    ///   - tags: Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    ///   - logger: Logger use during operation
    @inlinable
    public func importPublicKey(
        name: String? = nil,
        publicKeyMaterial: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportPublicKeyResponse {
        let input = ImportPublicKeyRequest(
            name: name, 
            publicKeyMaterial: publicKeyMaterial, 
            tags: tags
        )
        return try await self.importPublicKey(input, logger: logger)
    }

    /// Gets summary information about all Compositions in your account, in the AWS region where the API request is processed.
    @Sendable
    @inlinable
    public func listCompositions(_ input: ListCompositionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCompositionsResponse {
        try await self.client.execute(
            operation: "ListCompositions", 
            path: "/ListCompositions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets summary information about all Compositions in your account, in the AWS region where the API request is processed.
    ///
    /// Parameters:
    ///   - filterByEncoderConfigurationArn: Filters the Composition list to match the specified EncoderConfiguration attached to at least one of its output.
    ///   - filterByStageArn: Filters the Composition list to match the specified Stage ARN.
    ///   - maxResults: Maximum number of results to return. Default: 100.
    ///   - nextToken: The first Composition to retrieve. This is used for pagination; see the nextToken response field.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCompositions(
        filterByEncoderConfigurationArn: String? = nil,
        filterByStageArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCompositionsResponse {
        let input = ListCompositionsRequest(
            filterByEncoderConfigurationArn: filterByEncoderConfigurationArn, 
            filterByStageArn: filterByStageArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listCompositions(input, logger: logger)
    }

    /// Gets summary information about all EncoderConfigurations in your account, in the AWS region where the API request is processed.
    @Sendable
    @inlinable
    public func listEncoderConfigurations(_ input: ListEncoderConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEncoderConfigurationsResponse {
        try await self.client.execute(
            operation: "ListEncoderConfigurations", 
            path: "/ListEncoderConfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets summary information about all EncoderConfigurations in your account, in the AWS region where the API request is processed.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 100.
    ///   - nextToken: The first encoder configuration to retrieve. This is used for pagination; see the nextToken response field.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEncoderConfigurations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEncoderConfigurationsResponse {
        let input = ListEncoderConfigurationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listEncoderConfigurations(input, logger: logger)
    }

    /// Lists all IngestConfigurations in your account, in the AWS region where the API request is processed.
    @Sendable
    @inlinable
    public func listIngestConfigurations(_ input: ListIngestConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIngestConfigurationsResponse {
        try await self.client.execute(
            operation: "ListIngestConfigurations", 
            path: "/ListIngestConfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all IngestConfigurations in your account, in the AWS region where the API request is processed.
    ///
    /// Parameters:
    ///   - filterByStageArn: Filters the response list to match the specified stage ARN. Only one filter (by stage ARN or by state) can be used at a time.
    ///   - filterByState: Filters the response list to match the specified state. Only one filter (by stage ARN or by state) can be used at a time.
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - nextToken: The first IngestConfiguration to retrieve. This is used for pagination; see the nextToken response field.
    ///   - logger: Logger use during operation
    @inlinable
    public func listIngestConfigurations(
        filterByStageArn: String? = nil,
        filterByState: IngestConfigurationState? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIngestConfigurationsResponse {
        let input = ListIngestConfigurationsRequest(
            filterByStageArn: filterByStageArn, 
            filterByState: filterByState, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listIngestConfigurations(input, logger: logger)
    }

    /// Lists events for a specified participant that occurred during a specified stage session.
    @Sendable
    @inlinable
    public func listParticipantEvents(_ input: ListParticipantEventsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListParticipantEventsResponse {
        try await self.client.execute(
            operation: "ListParticipantEvents", 
            path: "/ListParticipantEvents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists events for a specified participant that occurred during a specified stage session.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - nextToken: The first participant event to retrieve. This is used for pagination; see the nextToken response field.
    ///   - participantId: Unique identifier for this participant. This is assigned by IVS and returned by CreateParticipantToken.
    ///   - sessionId: ID of a session within the stage.
    ///   - stageArn: Stage ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func listParticipantEvents(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        participantId: String,
        sessionId: String,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListParticipantEventsResponse {
        let input = ListParticipantEventsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            participantId: participantId, 
            sessionId: sessionId, 
            stageArn: stageArn
        )
        return try await self.listParticipantEvents(input, logger: logger)
    }

    /// Lists all participants in a specified stage session.
    @Sendable
    @inlinable
    public func listParticipants(_ input: ListParticipantsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListParticipantsResponse {
        try await self.client.execute(
            operation: "ListParticipants", 
            path: "/ListParticipants", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all participants in a specified stage session.
    ///
    /// Parameters:
    ///   - filterByPublished: Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - filterByRecordingState: Filters the response list to only show participants with the specified recording state. Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - filterByState: Filters the response list to only show participants in the specified state.  Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - filterByUserId: Filters the response list to match the specified user ID.  Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - nextToken: The first participant to retrieve. This is used for pagination; see the nextToken response field.
    ///   - sessionId: ID of the session within the stage.
    ///   - stageArn: Stage ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func listParticipants(
        filterByPublished: Bool? = nil,
        filterByRecordingState: ParticipantRecordingFilterByRecordingState? = nil,
        filterByState: ParticipantState? = nil,
        filterByUserId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sessionId: String,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListParticipantsResponse {
        let input = ListParticipantsRequest(
            filterByPublished: filterByPublished, 
            filterByRecordingState: filterByRecordingState, 
            filterByState: filterByState, 
            filterByUserId: filterByUserId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sessionId: sessionId, 
            stageArn: stageArn
        )
        return try await self.listParticipants(input, logger: logger)
    }

    /// Gets summary information about all public keys in your account, in the AWS region where the API request is processed.
    @Sendable
    @inlinable
    public func listPublicKeys(_ input: ListPublicKeysRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPublicKeysResponse {
        try await self.client.execute(
            operation: "ListPublicKeys", 
            path: "/ListPublicKeys", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets summary information about all public keys in your account, in the AWS region where the API request is processed.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - nextToken: The first public key to retrieve. This is used for pagination; see the nextToken response field.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPublicKeys(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPublicKeysResponse {
        let input = ListPublicKeysRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listPublicKeys(input, logger: logger)
    }

    /// Gets all sessions for a specified stage.
    @Sendable
    @inlinable
    public func listStageSessions(_ input: ListStageSessionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStageSessionsResponse {
        try await self.client.execute(
            operation: "ListStageSessions", 
            path: "/ListStageSessions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets all sessions for a specified stage.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - nextToken: The first stage session to retrieve. This is used for pagination; see the nextToken response field.
    ///   - stageArn: Stage ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStageSessions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStageSessionsResponse {
        let input = ListStageSessionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            stageArn: stageArn
        )
        return try await self.listStageSessions(input, logger: logger)
    }

    /// Gets summary information about all stages in your account, in the AWS region where the API request is processed.
    @Sendable
    @inlinable
    public func listStages(_ input: ListStagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStagesResponse {
        try await self.client.execute(
            operation: "ListStages", 
            path: "/ListStages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets summary information about all stages in your account, in the AWS region where the API request is processed.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - nextToken: The first stage to retrieve. This is used for pagination; see the nextToken response field.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStages(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStagesResponse {
        let input = ListStagesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listStages(input, logger: logger)
    }

    /// Gets summary information about all storage configurations in your account,
    /// 	  in the AWS region where the API request is processed.
    @Sendable
    @inlinable
    public func listStorageConfigurations(_ input: ListStorageConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStorageConfigurationsResponse {
        try await self.client.execute(
            operation: "ListStorageConfigurations", 
            path: "/ListStorageConfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets summary information about all storage configurations in your account,
    /// 	  in the AWS region where the API request is processed.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of storage configurations to return. Default: your service quota or 100,
    ///   - nextToken: The first storage configuration to retrieve. This is used for pagination;
    ///   - logger: Logger use during operation
    @inlinable
    public func listStorageConfigurations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStorageConfigurationsResponse {
        let input = ListStorageConfigurationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listStorageConfigurations(input, logger: logger)
    }

    /// Gets information about AWS tags for the specified ARN.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets information about AWS tags for the specified ARN.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Starts a Composition from a stage based on the configuration provided in the request. A Composition is an ephemeral resource that exists after this operation returns successfully. Composition stops and the resource is deleted:   When StopComposition is called.   After a 1-minute timeout, when all participants are disconnected from the stage.   After a 1-minute timeout, if there are no participants in the stage when StartComposition is called.   When broadcasting to the IVS channel fails and all retries are exhausted.   When broadcasting is disconnected and all attempts to reconnect are exhausted.
    @Sendable
    @inlinable
    public func startComposition(_ input: StartCompositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartCompositionResponse {
        try await self.client.execute(
            operation: "StartComposition", 
            path: "/StartComposition", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a Composition from a stage based on the configuration provided in the request. A Composition is an ephemeral resource that exists after this operation returns successfully. Composition stops and the resource is deleted:   When StopComposition is called.   After a 1-minute timeout, when all participants are disconnected from the stage.   After a 1-minute timeout, if there are no participants in the stage when StartComposition is called.   When broadcasting to the IVS channel fails and all retries are exhausted.   When broadcasting is disconnected and all attempts to reconnect are exhausted.
    ///
    /// Parameters:
    ///   - destinations: Array of destination configuration.
    ///   - idempotencyToken: Idempotency token.
    ///   - layout: Layout object to configure composition parameters.
    ///   - stageArn: ARN of the stage to be used for compositing.
    ///   - tags: Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    ///   - logger: Logger use during operation
    @inlinable
    public func startComposition(
        destinations: [DestinationConfiguration],
        idempotencyToken: String? = StartCompositionRequest.idempotencyToken(),
        layout: LayoutConfiguration? = nil,
        stageArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartCompositionResponse {
        let input = StartCompositionRequest(
            destinations: destinations, 
            idempotencyToken: idempotencyToken, 
            layout: layout, 
            stageArn: stageArn, 
            tags: tags
        )
        return try await self.startComposition(input, logger: logger)
    }

    /// Stops and deletes a Composition resource. Any broadcast from the Composition resource is stopped.
    @Sendable
    @inlinable
    public func stopComposition(_ input: StopCompositionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopCompositionResponse {
        try await self.client.execute(
            operation: "StopComposition", 
            path: "/StopComposition", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops and deletes a Composition resource. Any broadcast from the Composition resource is stopped.
    ///
    /// Parameters:
    ///   - arn: ARN of the Composition.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopComposition(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopCompositionResponse {
        let input = StopCompositionRequest(
            arn: arn
        )
        return try await self.stopComposition(input, logger: logger)
    }

    /// Adds or updates tags for the AWS resource with the specified ARN.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds or updates tags for the AWS resource with the specified ARN.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to be tagged. The ARN must be URL-encoded.
    ///   - tags: Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes tags from the resource with the specified ARN.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags from the resource with the specified ARN.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to be untagged. The ARN must be URL-encoded.
    ///   - tagKeys: Array of tag keys (strings) for the tags to be removed. See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a specified IngestConfiguration. Only the stage ARN attached to the IngestConfiguration can be updated. An IngestConfiguration that is active cannot be updated.
    @Sendable
    @inlinable
    public func updateIngestConfiguration(_ input: UpdateIngestConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIngestConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateIngestConfiguration", 
            path: "/UpdateIngestConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a specified IngestConfiguration. Only the stage ARN attached to the IngestConfiguration can be updated. An IngestConfiguration that is active cannot be updated.
    ///
    /// Parameters:
    ///   - arn: ARN of the IngestConfiguration, for which the related stage ARN needs to be updated.
    ///   - stageArn: Stage ARN that needs to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIngestConfiguration(
        arn: String,
        stageArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIngestConfigurationResponse {
        let input = UpdateIngestConfigurationRequest(
            arn: arn, 
            stageArn: stageArn
        )
        return try await self.updateIngestConfiguration(input, logger: logger)
    }

    /// Updates a stage’s configuration.
    @Sendable
    @inlinable
    public func updateStage(_ input: UpdateStageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStageResponse {
        try await self.client.execute(
            operation: "UpdateStage", 
            path: "/UpdateStage", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a stage’s configuration.
    ///
    /// Parameters:
    ///   - arn: ARN of the stage to be updated.
    ///   - autoParticipantRecordingConfiguration: Configuration object for individual participant recording, to attach to the stage. Note that this cannot be updated while recording is active.
    ///   - name: Name of the stage to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStage(
        arn: String,
        autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration? = nil,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStageResponse {
        let input = UpdateStageRequest(
            arn: arn, 
            autoParticipantRecordingConfiguration: autoParticipantRecordingConfiguration, 
            name: name
        )
        return try await self.updateStage(input, logger: logger)
    }
}

extension IVSRealTime {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: IVSRealTime, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension IVSRealTime {
    /// Return PaginatorSequence for operation ``listCompositions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCompositionsPaginator(
        _ input: ListCompositionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCompositionsRequest, ListCompositionsResponse> {
        return .init(
            input: input,
            command: self.listCompositions,
            inputKey: \ListCompositionsRequest.nextToken,
            outputKey: \ListCompositionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCompositions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filterByEncoderConfigurationArn: Filters the Composition list to match the specified EncoderConfiguration attached to at least one of its output.
    ///   - filterByStageArn: Filters the Composition list to match the specified Stage ARN.
    ///   - maxResults: Maximum number of results to return. Default: 100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCompositionsPaginator(
        filterByEncoderConfigurationArn: String? = nil,
        filterByStageArn: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCompositionsRequest, ListCompositionsResponse> {
        let input = ListCompositionsRequest(
            filterByEncoderConfigurationArn: filterByEncoderConfigurationArn, 
            filterByStageArn: filterByStageArn, 
            maxResults: maxResults
        )
        return self.listCompositionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEncoderConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEncoderConfigurationsPaginator(
        _ input: ListEncoderConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEncoderConfigurationsRequest, ListEncoderConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listEncoderConfigurations,
            inputKey: \ListEncoderConfigurationsRequest.nextToken,
            outputKey: \ListEncoderConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEncoderConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEncoderConfigurationsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEncoderConfigurationsRequest, ListEncoderConfigurationsResponse> {
        let input = ListEncoderConfigurationsRequest(
            maxResults: maxResults
        )
        return self.listEncoderConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIngestConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIngestConfigurationsPaginator(
        _ input: ListIngestConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIngestConfigurationsRequest, ListIngestConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listIngestConfigurations,
            inputKey: \ListIngestConfigurationsRequest.nextToken,
            outputKey: \ListIngestConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIngestConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filterByStageArn: Filters the response list to match the specified stage ARN. Only one filter (by stage ARN or by state) can be used at a time.
    ///   - filterByState: Filters the response list to match the specified state. Only one filter (by stage ARN or by state) can be used at a time.
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIngestConfigurationsPaginator(
        filterByStageArn: String? = nil,
        filterByState: IngestConfigurationState? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIngestConfigurationsRequest, ListIngestConfigurationsResponse> {
        let input = ListIngestConfigurationsRequest(
            filterByStageArn: filterByStageArn, 
            filterByState: filterByState, 
            maxResults: maxResults
        )
        return self.listIngestConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listParticipantEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listParticipantEventsPaginator(
        _ input: ListParticipantEventsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListParticipantEventsRequest, ListParticipantEventsResponse> {
        return .init(
            input: input,
            command: self.listParticipantEvents,
            inputKey: \ListParticipantEventsRequest.nextToken,
            outputKey: \ListParticipantEventsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listParticipantEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - participantId: Unique identifier for this participant. This is assigned by IVS and returned by CreateParticipantToken.
    ///   - sessionId: ID of a session within the stage.
    ///   - stageArn: Stage ARN.
    ///   - logger: Logger used for logging
    @inlinable
    public func listParticipantEventsPaginator(
        maxResults: Int? = nil,
        participantId: String,
        sessionId: String,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListParticipantEventsRequest, ListParticipantEventsResponse> {
        let input = ListParticipantEventsRequest(
            maxResults: maxResults, 
            participantId: participantId, 
            sessionId: sessionId, 
            stageArn: stageArn
        )
        return self.listParticipantEventsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listParticipants(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listParticipantsPaginator(
        _ input: ListParticipantsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListParticipantsRequest, ListParticipantsResponse> {
        return .init(
            input: input,
            command: self.listParticipants,
            inputKey: \ListParticipantsRequest.nextToken,
            outputKey: \ListParticipantsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listParticipants(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filterByPublished: Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - filterByRecordingState: Filters the response list to only show participants with the specified recording state. Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - filterByState: Filters the response list to only show participants in the specified state.  Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - filterByUserId: Filters the response list to match the specified user ID.  Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - sessionId: ID of the session within the stage.
    ///   - stageArn: Stage ARN.
    ///   - logger: Logger used for logging
    @inlinable
    public func listParticipantsPaginator(
        filterByPublished: Bool? = nil,
        filterByRecordingState: ParticipantRecordingFilterByRecordingState? = nil,
        filterByState: ParticipantState? = nil,
        filterByUserId: String? = nil,
        maxResults: Int? = nil,
        sessionId: String,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListParticipantsRequest, ListParticipantsResponse> {
        let input = ListParticipantsRequest(
            filterByPublished: filterByPublished, 
            filterByRecordingState: filterByRecordingState, 
            filterByState: filterByState, 
            filterByUserId: filterByUserId, 
            maxResults: maxResults, 
            sessionId: sessionId, 
            stageArn: stageArn
        )
        return self.listParticipantsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPublicKeys(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPublicKeysPaginator(
        _ input: ListPublicKeysRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPublicKeysRequest, ListPublicKeysResponse> {
        return .init(
            input: input,
            command: self.listPublicKeys,
            inputKey: \ListPublicKeysRequest.nextToken,
            outputKey: \ListPublicKeysResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPublicKeys(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPublicKeysPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPublicKeysRequest, ListPublicKeysResponse> {
        let input = ListPublicKeysRequest(
            maxResults: maxResults
        )
        return self.listPublicKeysPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStageSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStageSessionsPaginator(
        _ input: ListStageSessionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStageSessionsRequest, ListStageSessionsResponse> {
        return .init(
            input: input,
            command: self.listStageSessions,
            inputKey: \ListStageSessionsRequest.nextToken,
            outputKey: \ListStageSessionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStageSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - stageArn: Stage ARN.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStageSessionsPaginator(
        maxResults: Int? = nil,
        stageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStageSessionsRequest, ListStageSessionsResponse> {
        let input = ListStageSessionsRequest(
            maxResults: maxResults, 
            stageArn: stageArn
        )
        return self.listStageSessionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStagesPaginator(
        _ input: ListStagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStagesRequest, ListStagesResponse> {
        return .init(
            input: input,
            command: self.listStages,
            inputKey: \ListStagesRequest.nextToken,
            outputKey: \ListStagesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results to return. Default: 50.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStagesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStagesRequest, ListStagesResponse> {
        let input = ListStagesRequest(
            maxResults: maxResults
        )
        return self.listStagesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStorageConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStorageConfigurationsPaginator(
        _ input: ListStorageConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStorageConfigurationsRequest, ListStorageConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listStorageConfigurations,
            inputKey: \ListStorageConfigurationsRequest.nextToken,
            outputKey: \ListStorageConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStorageConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of storage configurations to return. Default: your service quota or 100,
    ///   - logger: Logger used for logging
    @inlinable
    public func listStorageConfigurationsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStorageConfigurationsRequest, ListStorageConfigurationsResponse> {
        let input = ListStorageConfigurationsRequest(
            maxResults: maxResults
        )
        return self.listStorageConfigurationsPaginator(input, logger: logger)
    }
}

extension IVSRealTime.ListCompositionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListCompositionsRequest {
        return .init(
            filterByEncoderConfigurationArn: self.filterByEncoderConfigurationArn,
            filterByStageArn: self.filterByStageArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IVSRealTime.ListEncoderConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListEncoderConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IVSRealTime.ListIngestConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListIngestConfigurationsRequest {
        return .init(
            filterByStageArn: self.filterByStageArn,
            filterByState: self.filterByState,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IVSRealTime.ListParticipantEventsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListParticipantEventsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            participantId: self.participantId,
            sessionId: self.sessionId,
            stageArn: self.stageArn
        )
    }
}

extension IVSRealTime.ListParticipantsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListParticipantsRequest {
        return .init(
            filterByPublished: self.filterByPublished,
            filterByRecordingState: self.filterByRecordingState,
            filterByState: self.filterByState,
            filterByUserId: self.filterByUserId,
            maxResults: self.maxResults,
            nextToken: token,
            sessionId: self.sessionId,
            stageArn: self.stageArn
        )
    }
}

extension IVSRealTime.ListPublicKeysRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListPublicKeysRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IVSRealTime.ListStageSessionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListStageSessionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            stageArn: self.stageArn
        )
    }
}

extension IVSRealTime.ListStagesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListStagesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IVSRealTime.ListStorageConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IVSRealTime.ListStorageConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
