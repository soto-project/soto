//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IVSRealTime {
    // MARK: Enums

    public enum CompositionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case failed = "FAILED"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum DestinationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case failed = "FAILED"
        case reconnecting = "RECONNECTING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum EventErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bFramePresent = "B_FRAME_PRESENT"
        case bitrateExceeded = "BITRATE_EXCEEDED"
        case insufficientCapabilities = "INSUFFICIENT_CAPABILITIES"
        case internalServerException = "INTERNAL_SERVER_EXCEPTION"
        case invalidAudioCodec = "INVALID_AUDIO_CODEC"
        case invalidInput = "INVALID_INPUT"
        case invalidProtocol = "INVALID_PROTOCOL"
        case invalidStreamKey = "INVALID_STREAM_KEY"
        case invalidVideoCodec = "INVALID_VIDEO_CODEC"
        case publisherNotFound = "PUBLISHER_NOT_FOUND"
        case quotaExceeded = "QUOTA_EXCEEDED"
        case resolutionExceeded = "RESOLUTION_EXCEEDED"
        case reuseOfStreamKey = "REUSE_OF_STREAM_KEY"
        case streamDurationExceeded = "STREAM_DURATION_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum EventName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case joined = "JOINED"
        case joinError = "JOIN_ERROR"
        case left = "LEFT"
        case publishError = "PUBLISH_ERROR"
        case publishStarted = "PUBLISH_STARTED"
        case publishStopped = "PUBLISH_STOPPED"
        case subscribeError = "SUBSCRIBE_ERROR"
        case subscribeStarted = "SUBSCRIBE_STARTED"
        case subscribeStopped = "SUBSCRIBE_STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum IngestConfigurationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum IngestProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rtmp = "RTMP"
        case rtmps = "RTMPS"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rtmp = "RTMP"
        case rtmps = "RTMPS"
        case unknown = "UNKNOWN"
        case whip = "WHIP"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantRecordingFilterByRecordingState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case failed = "FAILED"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantRecordingMediaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audioOnly = "AUDIO_ONLY"
        case audioVideo = "AUDIO_VIDEO"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantRecordingState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case disabled = "DISABLED"
        case failed = "FAILED"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "CONNECTED"
        case disconnected = "DISCONNECTED"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTokenCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case publish = "PUBLISH"
        case subscribe = "SUBSCRIBE"
        public var description: String { return self.rawValue }
    }

    public enum PipBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `static` = "STATIC"
        case dynamic = "DYNAMIC"
        public var description: String { return self.rawValue }
    }

    public enum PipPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottomLeft = "BOTTOM_LEFT"
        case bottomRight = "BOTTOM_RIGHT"
        case topLeft = "TOP_LEFT"
        case topRight = "TOP_RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum RecordingConfigurationFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hls = "HLS"
        public var description: String { return self.rawValue }
    }

    public enum ThumbnailRecordingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case interval = "INTERVAL"
        public var description: String { return self.rawValue }
    }

    public enum ThumbnailStorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case latest = "LATEST"
        case sequential = "SEQUENTIAL"
        public var description: String { return self.rawValue }
    }

    public enum VideoAspectRatio: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case portrait = "PORTRAIT"
        case square = "SQUARE"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public enum VideoFillMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contain = "CONTAIN"
        case cover = "COVER"
        case fill = "FILL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let accessControlAllowOrigin: String?
        public let accessControlExposeHeaders: String?
        public let cacheControl: String?
        public let contentSecurityPolicy: String?
        /// User does not have sufficient access to perform this action.
        public let exceptionMessage: String?
        public let strictTransportSecurity: String?
        public let xAmznErrorType: String?
        public let xContentTypeOptions: String?
        public let xFrameOptions: String?

        @inlinable
        public init(accessControlAllowOrigin: String? = nil, accessControlExposeHeaders: String? = nil, cacheControl: String? = nil, contentSecurityPolicy: String? = nil, exceptionMessage: String? = nil, strictTransportSecurity: String? = nil, xAmznErrorType: String? = nil, xContentTypeOptions: String? = nil, xFrameOptions: String? = nil) {
            self.accessControlAllowOrigin = accessControlAllowOrigin
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.cacheControl = cacheControl
            self.contentSecurityPolicy = contentSecurityPolicy
            self.exceptionMessage = exceptionMessage
            self.strictTransportSecurity = strictTransportSecurity
            self.xAmznErrorType = xAmznErrorType
            self.xContentTypeOptions = xContentTypeOptions
            self.xFrameOptions = xFrameOptions
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessControlAllowOrigin = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Allow-Origin")
            self.accessControlExposeHeaders = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Expose-Headers")
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentSecurityPolicy = try response.decodeHeaderIfPresent(String.self, key: "Content-Security-Policy")
            self.exceptionMessage = try container.decodeIfPresent(String.self, forKey: .exceptionMessage)
            self.strictTransportSecurity = try response.decodeHeaderIfPresent(String.self, key: "Strict-Transport-Security")
            self.xAmznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.xContentTypeOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Content-Type-Options")
            self.xFrameOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Frame-Options")
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionMessage = "exceptionMessage"
        }
    }

    public struct AutoParticipantRecordingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// HLS configuration object for individual participant recording.
        public let hlsConfiguration: ParticipantRecordingHlsConfiguration?
        /// Types of media to be recorded. Default: AUDIO_VIDEO.
        public let mediaTypes: [ParticipantRecordingMediaType]?
        /// If a stage publisher disconnects and then reconnects within the specified interval,
        /// 	  the multiple recordings will be considered a single recording and merged together. The default value is 0, which disables merging.
        public let recordingReconnectWindowSeconds: Int?
        /// ARN of the StorageConfiguration resource to use for individual participant recording. Default: "" (empty string, no storage configuration is specified). Individual participant recording cannot be started unless a storage configuration is specified, when a Stage is created or updated. To disable individual participant recording, set this to ""; other fields in this object will get reset to their defaults when sending "".
        public let storageConfigurationArn: String
        /// A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        public let thumbnailConfiguration: ParticipantThumbnailConfiguration?

        @inlinable
        public init(hlsConfiguration: ParticipantRecordingHlsConfiguration? = nil, mediaTypes: [ParticipantRecordingMediaType]? = nil, recordingReconnectWindowSeconds: Int? = nil, storageConfigurationArn: String, thumbnailConfiguration: ParticipantThumbnailConfiguration? = nil) {
            self.hlsConfiguration = hlsConfiguration
            self.mediaTypes = mediaTypes
            self.recordingReconnectWindowSeconds = recordingReconnectWindowSeconds
            self.storageConfigurationArn = storageConfigurationArn
            self.thumbnailConfiguration = thumbnailConfiguration
        }

        public func validate(name: String) throws {
            try self.hlsConfiguration?.validate(name: "\(name).hlsConfiguration")
            try self.validate(self.mediaTypes, name: "mediaTypes", parent: name, max: 1)
            try self.validate(self.recordingReconnectWindowSeconds, name: "recordingReconnectWindowSeconds", parent: name, max: 300)
            try self.validate(self.recordingReconnectWindowSeconds, name: "recordingReconnectWindowSeconds", parent: name, min: 0)
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, max: 128)
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, pattern: "^^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:storage-configuration/[a-zA-Z0-9-]+$$")
            try self.thumbnailConfiguration?.validate(name: "\(name).thumbnailConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case hlsConfiguration = "hlsConfiguration"
            case mediaTypes = "mediaTypes"
            case recordingReconnectWindowSeconds = "recordingReconnectWindowSeconds"
            case storageConfigurationArn = "storageConfigurationArn"
            case thumbnailConfiguration = "thumbnailConfiguration"
        }
    }

    public struct ChannelDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the channel to use for broadcasting. The channel and stage resources must be in the same AWS account and region. The channel must be offline (not broadcasting).
        public let channelArn: String
        /// ARN of the EncoderConfiguration resource. The encoder configuration and stage resources must be in the same AWS account and region.
        public let encoderConfigurationArn: String?

        @inlinable
        public init(channelArn: String, encoderConfigurationArn: String? = nil) {
            self.channelArn = channelArn
            self.encoderConfigurationArn = encoderConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 128)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 1)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
            try self.validate(self.encoderConfigurationArn, name: "encoderConfigurationArn", parent: name, max: 128)
            try self.validate(self.encoderConfigurationArn, name: "encoderConfigurationArn", parent: name, min: 1)
            try self.validate(self.encoderConfigurationArn, name: "encoderConfigurationArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
            case encoderConfigurationArn = "encoderConfigurationArn"
        }
    }

    public struct Composition: AWSDecodableShape {
        /// ARN of the Composition resource.
        public let arn: String
        /// Array of Destination objects. A Composition can contain either one destination (channel or s3) or two (one channel and one s3).
        public let destinations: [Destination]
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Layout object to configure composition parameters.
        public let layout: LayoutConfiguration
        /// ARN of the stage used as input
        public let stageArn: String
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition.
        public let state: CompositionState
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, destinations: [Destination], endTime: Date? = nil, layout: LayoutConfiguration, stageArn: String, startTime: Date? = nil, state: CompositionState, tags: [String: String]? = nil) {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.layout = layout
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinations = "destinations"
            case endTime = "endTime"
            case layout = "layout"
            case stageArn = "stageArn"
            case startTime = "startTime"
            case state = "state"
            case tags = "tags"
        }
    }

    public struct CompositionRecordingHlsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the target duration for recorded segments generated when using composite recording.
        /// 	  Segments may have durations shorter than the specified value when needed to ensure each segment
        /// 	  begins with a keyframe. Default: 2.
        public let targetSegmentDurationSeconds: Int?

        @inlinable
        public init(targetSegmentDurationSeconds: Int? = nil) {
            self.targetSegmentDurationSeconds = targetSegmentDurationSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.targetSegmentDurationSeconds, name: "targetSegmentDurationSeconds", parent: name, max: 10)
            try self.validate(self.targetSegmentDurationSeconds, name: "targetSegmentDurationSeconds", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case targetSegmentDurationSeconds = "targetSegmentDurationSeconds"
        }
    }

    public struct CompositionSummary: AWSDecodableShape {
        /// ARN of the Composition resource.
        public let arn: String
        /// Array of Destination objects.
        public let destinations: [DestinationSummary]
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ARN of the attached stage.
        public let stageArn: String
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition resource.
        public let state: CompositionState
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, destinations: [DestinationSummary], endTime: Date? = nil, stageArn: String, startTime: Date? = nil, state: CompositionState, tags: [String: String]? = nil) {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinations = "destinations"
            case endTime = "endTime"
            case stageArn = "stageArn"
            case startTime = "startTime"
            case state = "state"
            case tags = "tags"
        }
    }

    public struct CompositionThumbnailConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails/(width)x(height) directory, where (width) and (height) are the width and height of the thumbnail. LATEST saves the latest thumbnail in media/latest_thumbnail/(width)x(height)/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        public let storage: [ThumbnailStorageType]?
        /// The targeted thumbnail-generation interval in seconds. Default: 60.
        public let targetIntervalSeconds: Int?

        @inlinable
        public init(storage: [ThumbnailStorageType]? = nil, targetIntervalSeconds: Int? = nil) {
            self.storage = storage
            self.targetIntervalSeconds = targetIntervalSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.storage, name: "storage", parent: name, max: 2)
            try self.validate(self.targetIntervalSeconds, name: "targetIntervalSeconds", parent: name, max: 86400)
            try self.validate(self.targetIntervalSeconds, name: "targetIntervalSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case storage = "storage"
            case targetIntervalSeconds = "targetIntervalSeconds"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let accessControlAllowOrigin: String?
        public let accessControlExposeHeaders: String?
        public let cacheControl: String?
        public let contentSecurityPolicy: String?
        /// Updating or deleting a resource can cause an inconsistent state.
        public let exceptionMessage: String?
        public let strictTransportSecurity: String?
        public let xAmznErrorType: String?
        public let xContentTypeOptions: String?
        public let xFrameOptions: String?

        @inlinable
        public init(accessControlAllowOrigin: String? = nil, accessControlExposeHeaders: String? = nil, cacheControl: String? = nil, contentSecurityPolicy: String? = nil, exceptionMessage: String? = nil, strictTransportSecurity: String? = nil, xAmznErrorType: String? = nil, xContentTypeOptions: String? = nil, xFrameOptions: String? = nil) {
            self.accessControlAllowOrigin = accessControlAllowOrigin
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.cacheControl = cacheControl
            self.contentSecurityPolicy = contentSecurityPolicy
            self.exceptionMessage = exceptionMessage
            self.strictTransportSecurity = strictTransportSecurity
            self.xAmznErrorType = xAmznErrorType
            self.xContentTypeOptions = xContentTypeOptions
            self.xFrameOptions = xFrameOptions
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessControlAllowOrigin = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Allow-Origin")
            self.accessControlExposeHeaders = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Expose-Headers")
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentSecurityPolicy = try response.decodeHeaderIfPresent(String.self, key: "Content-Security-Policy")
            self.exceptionMessage = try container.decodeIfPresent(String.self, forKey: .exceptionMessage)
            self.strictTransportSecurity = try response.decodeHeaderIfPresent(String.self, key: "Strict-Transport-Security")
            self.xAmznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.xContentTypeOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Content-Type-Options")
            self.xFrameOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Frame-Options")
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionMessage = "exceptionMessage"
        }
    }

    public struct CreateEncoderConfigurationRequest: AWSEncodableShape {
        /// Optional name to identify the resource.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?
        /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps.
        public let video: Video?

        @inlinable
        public init(name: String? = nil, tags: [String: String]? = nil, video: Video? = nil) {
            self.name = name
            self.tags = tags
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.video?.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case tags = "tags"
            case video = "video"
        }
    }

    public struct CreateEncoderConfigurationResponse: AWSDecodableShape {
        /// The EncoderConfiguration that was created.
        public let encoderConfiguration: EncoderConfiguration?

        @inlinable
        public init(encoderConfiguration: EncoderConfiguration? = nil) {
            self.encoderConfiguration = encoderConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfiguration = "encoderConfiguration"
        }
    }

    public struct CreateIngestConfigurationRequest: AWSEncodableShape {
        /// Application-provided attributes to store in the IngestConfiguration and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Type of ingest protocol that the user employs to broadcast. If this is set to RTMP, insecureIngest must be set to true.
        public let ingestProtocol: IngestProtocol
        /// Whether the stage allows insecure RTMP ingest. This must be set to true, if ingestProtocol is set to RTMP. Default: false.
        public let insecureIngest: Bool?
        /// Optional name that can be specified for the IngestConfiguration being created.
        public let name: String?
        /// ARN of the stage with which the IngestConfiguration is associated.
        public let stageArn: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented
        /// 	 there.
        public let tags: [String: String]?
        /// Customer-assigned name to help identify the participant using the IngestConfiguration; this can be used to link a participant to a user in the customerâ€™s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(attributes: [String: String]? = nil, ingestProtocol: IngestProtocol, insecureIngest: Bool? = nil, name: String? = nil, stageArn: String? = nil, tags: [String: String]? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.ingestProtocol = ingestProtocol
            self.insecureIngest = insecureIngest
            self.name = name
            self.stageArn = stageArn
            self.tags = tags
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case ingestProtocol = "ingestProtocol"
            case insecureIngest = "insecureIngest"
            case name = "name"
            case stageArn = "stageArn"
            case tags = "tags"
            case userId = "userId"
        }
    }

    public struct CreateIngestConfigurationResponse: AWSDecodableShape {
        /// The IngestConfiguration that was created.
        public let ingestConfiguration: IngestConfiguration?

        @inlinable
        public init(ingestConfiguration: IngestConfiguration? = nil) {
            self.ingestConfiguration = ingestConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case ingestConfiguration = "ingestConfiguration"
        }
    }

    public struct CreateParticipantTokenRequest: AWSEncodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the token expires. Default: 720 (12 hours).
        public let duration: Int?
        /// ARN of the stage to which this token is scoped.
        public let stageArn: String
        /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, stageArn: String, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.stageArn = stageArn
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case stageArn = "stageArn"
            case userId = "userId"
        }
    }

    public struct CreateParticipantTokenResponse: AWSDecodableShape {
        /// The participant token that was created.
        public let participantToken: ParticipantToken?

        @inlinable
        public init(participantToken: ParticipantToken? = nil) {
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case participantToken = "participantToken"
        }
    }

    public struct CreateStageRequest: AWSEncodableShape {
        /// Configuration object for individual participant recording, to attach to the new stage.
        public let autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration?
        /// Optional name that can be specified for the stage being created.
        public let name: String?
        /// Array of participant token configuration objects to attach to the new stage.
        public let participantTokenConfigurations: [ParticipantTokenConfiguration]?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration? = nil, name: String? = nil, participantTokenConfigurations: [ParticipantTokenConfiguration]? = nil, tags: [String: String]? = nil) {
            self.autoParticipantRecordingConfiguration = autoParticipantRecordingConfiguration
            self.name = name
            self.participantTokenConfigurations = participantTokenConfigurations
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.autoParticipantRecordingConfiguration?.validate(name: "\(name).autoParticipantRecordingConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.participantTokenConfigurations?.forEach {
                try $0.validate(name: "\(name).participantTokenConfigurations[]")
            }
            try self.validate(self.participantTokenConfigurations, name: "participantTokenConfigurations", parent: name, max: 12)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case autoParticipantRecordingConfiguration = "autoParticipantRecordingConfiguration"
            case name = "name"
            case participantTokenConfigurations = "participantTokenConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateStageResponse: AWSDecodableShape {
        /// Participant tokens attached to the stage. These correspond to the participants in the request.
        public let participantTokens: [ParticipantToken]?
        /// The stage that was created.
        public let stage: Stage?

        @inlinable
        public init(participantTokens: [ParticipantToken]? = nil, stage: Stage? = nil) {
            self.participantTokens = participantTokens
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case participantTokens = "participantTokens"
            case stage = "stage"
        }
    }

    public struct CreateStorageConfigurationRequest: AWSEncodableShape {
        /// Storage configuration name. The value does not need to be unique.
        public let name: String?
        /// A complex type that contains a storage configuration for where recorded video will be stored.
        public let s3: S3StorageConfiguration
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies
        /// 	 in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(name: String? = nil, s3: S3StorageConfiguration, tags: [String: String]? = nil) {
            self.name = name
            self.s3 = s3
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.s3.validate(name: "\(name).s3")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case s3 = "s3"
            case tags = "tags"
        }
    }

    public struct CreateStorageConfigurationResponse: AWSDecodableShape {
        /// The StorageConfiguration that was created.
        public let storageConfiguration: StorageConfiguration?

        @inlinable
        public init(storageConfiguration: StorageConfiguration? = nil) {
            self.storageConfiguration = storageConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case storageConfiguration = "storageConfiguration"
        }
    }

    public struct DeleteEncoderConfigurationRequest: AWSEncodableShape {
        /// ARN of the EncoderConfiguration.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteEncoderConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIngestConfigurationRequest: AWSEncodableShape {
        /// ARN of the IngestConfiguration.
        public let arn: String
        /// Optional field to force deletion of the IngestConfiguration. If this is set to true when a participant is actively publishing, the participant is disconnected from the stage, followed by deletion of the IngestConfiguration. Default: false.
        public let force: Bool?

        @inlinable
        public init(arn: String, force: Bool? = nil) {
            self.arn = arn
            self.force = force
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:ingest-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case force = "force"
        }
    }

    public struct DeleteIngestConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePublicKeyRequest: AWSEncodableShape {
        /// ARN of the public key to be deleted.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:public-key/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeletePublicKeyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStageRequest: AWSEncodableShape {
        /// ARN of the stage to be deleted.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteStageResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStorageConfigurationRequest: AWSEncodableShape {
        /// ARN of the storage configuration to be deleted.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:storage-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteStorageConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Destination: AWSDecodableShape {
        /// Configuration used to create this destination.
        public let configuration: DestinationConfiguration
        /// Optional details regarding the status of the destination.
        public let detail: DestinationDetail?
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Unique identifier for this destination, assigned by IVS.
        public let id: String
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition Destination.
        public let state: DestinationState

        @inlinable
        public init(configuration: DestinationConfiguration, detail: DestinationDetail? = nil, endTime: Date? = nil, id: String, startTime: Date? = nil, state: DestinationState) {
            self.configuration = configuration
            self.detail = detail
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case detail = "detail"
            case endTime = "endTime"
            case id = "id"
            case startTime = "startTime"
            case state = "state"
        }
    }

    public struct DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An IVS channel to be used for broadcasting, for server-side composition. Either a channel or an s3 must be specified.
        public let channel: ChannelDestinationConfiguration?
        /// Name that can be specified to help identify the destination.
        public let name: String?
        /// An S3 storage configuration to be used for recording video data. Either a channel or an s3 must be specified.
        public let s3: S3DestinationConfiguration?

        @inlinable
        public init(channel: ChannelDestinationConfiguration? = nil, name: String? = nil, s3: S3DestinationConfiguration? = nil) {
            self.channel = channel
            self.name = name
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.channel?.validate(name: "\(name).channel")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
            case name = "name"
            case s3 = "s3"
        }
    }

    public struct DestinationDetail: AWSDecodableShape {
        /// An S3 detail object to return information about the S3 destination.
        public let s3: S3Detail?

        @inlinable
        public init(s3: S3Detail? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct DestinationSummary: AWSDecodableShape {
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Unique identifier for this destination, assigned by IVS.
        public let id: String
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition Destination.
        public let state: DestinationState

        @inlinable
        public init(endTime: Date? = nil, id: String, startTime: Date? = nil, state: DestinationState) {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case id = "id"
            case startTime = "startTime"
            case state = "state"
        }
    }

    public struct DisconnectParticipantRequest: AWSEncodableShape {
        /// Identifier of the participant to be disconnected. IVS assigns this; it is returned by CreateParticipantToken (for streams using WebRTC ingest) or CreateIngestConfiguration (for
        /// 	    streams using RTMP ingest).
        public let participantId: String
        /// Description of why this participant is being disconnected.
        public let reason: String?
        /// ARN of the stage to which the participant is attached.
        public let stageArn: String

        @inlinable
        public init(participantId: String, reason: String? = nil, stageArn: String) {
            self.participantId = participantId
            self.reason = reason
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.reason, name: "reason", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case participantId = "participantId"
            case reason = "reason"
            case stageArn = "stageArn"
        }
    }

    public struct DisconnectParticipantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EncoderConfiguration: AWSDecodableShape {
        /// ARN of the EncoderConfiguration resource.
        public let arn: String
        /// Optional name to identify the resource.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?
        /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        public let video: Video?

        @inlinable
        public init(arn: String, name: String? = nil, tags: [String: String]? = nil, video: Video? = nil) {
            self.arn = arn
            self.name = name
            self.tags = tags
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case tags = "tags"
            case video = "video"
        }
    }

    public struct EncoderConfigurationSummary: AWSDecodableShape {
        /// ARN of the EncoderConfiguration resource.
        public let arn: String
        /// Optional name to identify the resource.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct Event: AWSDecodableShape {
        /// If the event is an error event, the error code is provided to give insight into the specific error that occurred. If the event is not an error event, this field is null.    B_FRAME_PRESENT â€” The participant's stream includes B-frames. For details, see  IVS RTMP Publishing.    BITRATE_EXCEEDED â€” The participant exceeded the maximum supported bitrate. For details, see  Service Quotas.    INSUFFICIENT_CAPABILITIES â€” The participant tried to take an action that the participantâ€™s token is not allowed to do. For details on participant capabilities, see the capabilities field in CreateParticipantToken.    INTERNAL_SERVER_EXCEPTION â€” The participant failed to publish to the stage due to an internal server error.    INVALID_AUDIO_CODEC â€” The participant is using an invalid audio codec. For details, see  Stream Ingest.    INVALID_INPUT â€” The participant is using an invalid input stream.    INVALID_PROTOCOL â€” The participant's IngestConfiguration resource is configured for RTMPS but they tried streaming with RTMP. For details, see IVS RTMP Publishing.    INVALID_STREAM_KEY â€” The participant is using an invalid stream key. For details, see  IVS RTMP Publishing.    INVALID_VIDEO_CODEC â€” The participant is using an invalid video codec. For details, see  Stream Ingest.    PUBLISHER_NOT_FOUND â€” The participant tried to subscribe to a publisher that doesnâ€™t exist.    QUOTA_EXCEEDED â€” The number of participants who want to publish/subscribe to a stage exceeds the quota. For details, see  Service Quotas.    RESOLUTION_EXCEEDED â€” The participant exceeded the maximum supported resolution. For details, see  Service Quotas.    REUSE_OF_STREAM_KEY â€” The participant tried to use a stream key that is associated with another active stage session.    STREAM_DURATION_EXCEEDED â€” The participant exceeded the maximum allowed stream duration. For details, see  Service Quotas.
        public let errorCode: EventErrorCode?
        /// ISO 8601 timestamp (returned as a string) for when the event occurred.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var eventTime: Date?
        /// The name of the event.
        public let name: EventName?
        /// Unique identifier for the participant who triggered the event. This is assigned by IVS.
        public let participantId: String?
        /// Unique identifier for the remote participant. For a subscribe event, this is the publisher. For a publish or join event, this is null. This is assigned by IVS.
        public let remoteParticipantId: String?

        @inlinable
        public init(errorCode: EventErrorCode? = nil, eventTime: Date? = nil, name: EventName? = nil, participantId: String? = nil, remoteParticipantId: String? = nil) {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.name = name
            self.participantId = participantId
            self.remoteParticipantId = remoteParticipantId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case eventTime = "eventTime"
            case name = "name"
            case participantId = "participantId"
            case remoteParticipantId = "remoteParticipantId"
        }
    }

    public struct GetCompositionRequest: AWSEncodableShape {
        /// ARN of the Composition resource.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:composition/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetCompositionResponse: AWSDecodableShape {
        /// The Composition that was returned.
        public let composition: Composition?

        @inlinable
        public init(composition: Composition? = nil) {
            self.composition = composition
        }

        private enum CodingKeys: String, CodingKey {
            case composition = "composition"
        }
    }

    public struct GetEncoderConfigurationRequest: AWSEncodableShape {
        /// ARN of the EncoderConfiguration resource.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetEncoderConfigurationResponse: AWSDecodableShape {
        /// The EncoderConfiguration that was returned.
        public let encoderConfiguration: EncoderConfiguration?

        @inlinable
        public init(encoderConfiguration: EncoderConfiguration? = nil) {
            self.encoderConfiguration = encoderConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfiguration = "encoderConfiguration"
        }
    }

    public struct GetIngestConfigurationRequest: AWSEncodableShape {
        /// ARN of the ingest for which the information is to be retrieved.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:ingest-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetIngestConfigurationResponse: AWSDecodableShape {
        /// The IngestConfiguration that was returned.
        public let ingestConfiguration: IngestConfiguration?

        @inlinable
        public init(ingestConfiguration: IngestConfiguration? = nil) {
            self.ingestConfiguration = ingestConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case ingestConfiguration = "ingestConfiguration"
        }
    }

    public struct GetParticipantRequest: AWSEncodableShape {
        /// Unique identifier for the participant. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// ID of a session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        @inlinable
        public init(participantId: String, sessionId: String, stageArn: String) {
            self.participantId = participantId
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.participantId, name: "participantId", parent: name, max: 64)
            try self.validate(self.participantId, name: "participantId", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case participantId = "participantId"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct GetParticipantResponse: AWSDecodableShape {
        /// The participant that is returned.
        public let participant: Participant?

        @inlinable
        public init(participant: Participant? = nil) {
            self.participant = participant
        }

        private enum CodingKeys: String, CodingKey {
            case participant = "participant"
        }
    }

    public struct GetPublicKeyRequest: AWSEncodableShape {
        /// ARN of the public key for which the information is to be retrieved.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:public-key/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetPublicKeyResponse: AWSDecodableShape {
        /// The public key that is returned.
        public let publicKey: PublicKey?

        @inlinable
        public init(publicKey: PublicKey? = nil) {
            self.publicKey = publicKey
        }

        private enum CodingKeys: String, CodingKey {
            case publicKey = "publicKey"
        }
    }

    public struct GetStageRequest: AWSEncodableShape {
        /// ARN of the stage for which the information is to be retrieved.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetStageResponse: AWSDecodableShape {
        /// The stage that is returned.
        public let stage: Stage?

        @inlinable
        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }

    public struct GetStageSessionRequest: AWSEncodableShape {
        /// ID of a session within the stage.
        public let sessionId: String
        /// ARN of the stage for which the information is to be retrieved.
        public let stageArn: String

        @inlinable
        public init(sessionId: String, stageArn: String) {
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct GetStageSessionResponse: AWSDecodableShape {
        /// The stage session that is returned.
        public let stageSession: StageSession?

        @inlinable
        public init(stageSession: StageSession? = nil) {
            self.stageSession = stageSession
        }

        private enum CodingKeys: String, CodingKey {
            case stageSession = "stageSession"
        }
    }

    public struct GetStorageConfigurationRequest: AWSEncodableShape {
        /// ARN of the storage configuration to be retrieved.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:storage-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetStorageConfigurationResponse: AWSDecodableShape {
        /// The StorageConfiguration that was returned.
        public let storageConfiguration: StorageConfiguration?

        @inlinable
        public init(storageConfiguration: StorageConfiguration? = nil) {
            self.storageConfiguration = storageConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case storageConfiguration = "storageConfiguration"
        }
    }

    public struct GridConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in ParticipantTokenConfiguration is placed in the featured slot. Default: "" (no featured participant).
        public let featuredParticipantAttribute: String?
        /// Specifies the spacing between participant tiles in pixels. Default: 2.
        public let gridGap: Int?
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public let omitStoppedVideo: Bool?
        /// Sets the non-featured participant display mode, to control the aspect ratio of video tiles. VIDEO is 16:9, SQUARE is 1:1, and PORTRAIT is 3:4. Default: VIDEO.
        public let videoAspectRatio: VideoAspectRatio?
        /// Defines how video content fits within the participant tile: FILL (stretched), COVER (cropped), or CONTAIN (letterboxed). When not set, videoFillMode defaults to COVER fill mode for participants in the grid and to CONTAIN fill mode for featured participants.
        public let videoFillMode: VideoFillMode?

        @inlinable
        public init(featuredParticipantAttribute: String? = nil, gridGap: Int? = nil, omitStoppedVideo: Bool? = nil, videoAspectRatio: VideoAspectRatio? = nil, videoFillMode: VideoFillMode? = nil) {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.videoAspectRatio = videoAspectRatio
            self.videoFillMode = videoFillMode
        }

        public func validate(name: String) throws {
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, max: 128)
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.gridGap, name: "gridGap", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case featuredParticipantAttribute = "featuredParticipantAttribute"
            case gridGap = "gridGap"
            case omitStoppedVideo = "omitStoppedVideo"
            case videoAspectRatio = "videoAspectRatio"
            case videoFillMode = "videoFillMode"
        }
    }

    public struct ImportPublicKeyRequest: AWSEncodableShape {
        /// Name of the public key to be imported.
        public let name: String?
        /// The content of the public key to be imported.
        public let publicKeyMaterial: String
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(name: String? = nil, publicKeyMaterial: String, tags: [String: String]? = nil) {
            self.name = name
            self.publicKeyMaterial = publicKeyMaterial
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.publicKeyMaterial, name: "publicKeyMaterial", parent: name, pattern: "-----BEGIN PUBLIC KEY-----\\r?\\n([a-zA-Z0-9+/=\\r\\n]+)\\r?\\n-----END PUBLIC KEY-----(\\r?\\n)?")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case publicKeyMaterial = "publicKeyMaterial"
            case tags = "tags"
        }
    }

    public struct ImportPublicKeyResponse: AWSDecodableShape {
        /// The public key that was imported.
        public let publicKey: PublicKey?

        @inlinable
        public init(publicKey: PublicKey? = nil) {
            self.publicKey = publicKey
        }

        private enum CodingKeys: String, CodingKey {
            case publicKey = "publicKey"
        }
    }

    public struct IngestConfiguration: AWSDecodableShape {
        /// Ingest configuration ARN.
        public let arn: String
        /// Application-provided attributes to to store in the IngestConfiguration and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Type of ingest protocol that the user employs for broadcasting.
        public let ingestProtocol: IngestProtocol
        /// Ingest name
        public let name: String?
        /// ID of the participant within the stage.
        public let participantId: String
        /// ARN of the stage with which the IngestConfiguration is associated.
        public let stageArn: String
        /// State of the ingest configuration. It is ACTIVE if a publisher currently is publishing to the stage associated with the ingest configuration.
        public let state: IngestConfigurationState
        /// Ingest-key value for the RTMP(S) protocol.
        public let streamKey: String
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?
        /// Customer-assigned name to help identify the participant using the IngestConfiguration; this can be used to link a participant to a user in the customerâ€™s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(arn: String, attributes: [String: String]? = nil, ingestProtocol: IngestProtocol, name: String? = nil, participantId: String, stageArn: String, state: IngestConfigurationState, streamKey: String, tags: [String: String]? = nil, userId: String? = nil) {
            self.arn = arn
            self.attributes = attributes
            self.ingestProtocol = ingestProtocol
            self.name = name
            self.participantId = participantId
            self.stageArn = stageArn
            self.state = state
            self.streamKey = streamKey
            self.tags = tags
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case attributes = "attributes"
            case ingestProtocol = "ingestProtocol"
            case name = "name"
            case participantId = "participantId"
            case stageArn = "stageArn"
            case state = "state"
            case streamKey = "streamKey"
            case tags = "tags"
            case userId = "userId"
        }
    }

    public struct IngestConfigurationSummary: AWSDecodableShape {
        /// Ingest configuration ARN.
        public let arn: String
        /// Type of ingest protocol that the user employs for broadcasting.
        public let ingestProtocol: IngestProtocol
        /// Ingest name.
        public let name: String?
        /// ID of the participant within the stage.
        public let participantId: String
        /// ARN of the stage with which the IngestConfiguration is associated.
        public let stageArn: String
        /// State of the ingest configuration. It is ACTIVE if a publisher currently is publishing to the stage associated with the ingest configuration.
        public let state: IngestConfigurationState
        /// Customer-assigned name to help identify the participant using the IngestConfiguration; this can be used to link a participant to a user in the customerâ€™s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(arn: String, ingestProtocol: IngestProtocol, name: String? = nil, participantId: String, stageArn: String, state: IngestConfigurationState, userId: String? = nil) {
            self.arn = arn
            self.ingestProtocol = ingestProtocol
            self.name = name
            self.participantId = participantId
            self.stageArn = stageArn
            self.state = state
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case ingestProtocol = "ingestProtocol"
            case name = "name"
            case participantId = "participantId"
            case stageArn = "stageArn"
            case state = "state"
            case userId = "userId"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let accessControlAllowOrigin: String?
        public let accessControlExposeHeaders: String?
        public let cacheControl: String?
        public let contentSecurityPolicy: String?
        /// Unexpected error during processing of request.
        public let exceptionMessage: String?
        public let strictTransportSecurity: String?
        public let xAmznErrorType: String?
        public let xContentTypeOptions: String?
        public let xFrameOptions: String?

        @inlinable
        public init(accessControlAllowOrigin: String? = nil, accessControlExposeHeaders: String? = nil, cacheControl: String? = nil, contentSecurityPolicy: String? = nil, exceptionMessage: String? = nil, strictTransportSecurity: String? = nil, xAmznErrorType: String? = nil, xContentTypeOptions: String? = nil, xFrameOptions: String? = nil) {
            self.accessControlAllowOrigin = accessControlAllowOrigin
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.cacheControl = cacheControl
            self.contentSecurityPolicy = contentSecurityPolicy
            self.exceptionMessage = exceptionMessage
            self.strictTransportSecurity = strictTransportSecurity
            self.xAmznErrorType = xAmznErrorType
            self.xContentTypeOptions = xContentTypeOptions
            self.xFrameOptions = xFrameOptions
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessControlAllowOrigin = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Allow-Origin")
            self.accessControlExposeHeaders = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Expose-Headers")
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentSecurityPolicy = try response.decodeHeaderIfPresent(String.self, key: "Content-Security-Policy")
            self.exceptionMessage = try container.decodeIfPresent(String.self, forKey: .exceptionMessage)
            self.strictTransportSecurity = try response.decodeHeaderIfPresent(String.self, key: "Strict-Transport-Security")
            self.xAmznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.xContentTypeOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Content-Type-Options")
            self.xFrameOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Frame-Options")
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionMessage = "exceptionMessage"
        }
    }

    public struct LayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration related to grid layout. Default: Grid layout.
        public let grid: GridConfiguration?
        /// Configuration related to PiP layout.
        public let pip: PipConfiguration?

        @inlinable
        public init(grid: GridConfiguration? = nil, pip: PipConfiguration? = nil) {
            self.grid = grid
            self.pip = pip
        }

        public func validate(name: String) throws {
            try self.grid?.validate(name: "\(name).grid")
            try self.pip?.validate(name: "\(name).pip")
        }

        private enum CodingKeys: String, CodingKey {
            case grid = "grid"
            case pip = "pip"
        }
    }

    public struct ListCompositionsRequest: AWSEncodableShape {
        /// Filters the Composition list to match the specified EncoderConfiguration attached to at least one of its output.
        public let filterByEncoderConfigurationArn: String?
        /// Filters the Composition list to match the specified Stage ARN.
        public let filterByStageArn: String?
        /// Maximum number of results to return. Default: 100.
        public let maxResults: Int?
        /// The first Composition to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        @inlinable
        public init(filterByEncoderConfigurationArn: String? = nil, filterByStageArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filterByEncoderConfigurationArn = filterByEncoderConfigurationArn
            self.filterByStageArn = filterByStageArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.filterByEncoderConfigurationArn, name: "filterByEncoderConfigurationArn", parent: name, max: 128)
            try self.validate(self.filterByEncoderConfigurationArn, name: "filterByEncoderConfigurationArn", parent: name, min: 1)
            try self.validate(self.filterByEncoderConfigurationArn, name: "filterByEncoderConfigurationArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, max: 128)
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, min: 1)
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterByEncoderConfigurationArn = "filterByEncoderConfigurationArn"
            case filterByStageArn = "filterByStageArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCompositionsResponse: AWSDecodableShape {
        /// List of the matching Compositions (summary information only).
        public let compositions: [CompositionSummary]
        /// If there are more compositions than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        @inlinable
        public init(compositions: [CompositionSummary], nextToken: String? = nil) {
            self.compositions = compositions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case compositions = "compositions"
            case nextToken = "nextToken"
        }
    }

    public struct ListEncoderConfigurationsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 100.
        public let maxResults: Int?
        /// The first encoder configuration to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEncoderConfigurationsResponse: AWSDecodableShape {
        /// List of the matching EncoderConfigurations (summary information only).
        public let encoderConfigurations: [EncoderConfigurationSummary]
        /// If there are more encoder configurations than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        @inlinable
        public init(encoderConfigurations: [EncoderConfigurationSummary], nextToken: String? = nil) {
            self.encoderConfigurations = encoderConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfigurations = "encoderConfigurations"
            case nextToken = "nextToken"
        }
    }

    public struct ListIngestConfigurationsRequest: AWSEncodableShape {
        /// Filters the response list to match the specified stage ARN. Only one filter (by stage ARN or by state) can be used at a time.
        public let filterByStageArn: String?
        /// Filters the response list to match the specified state. Only one filter (by stage ARN or by state) can be used at a time.
        public let filterByState: IngestConfigurationState?
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first IngestConfiguration to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        @inlinable
        public init(filterByStageArn: String? = nil, filterByState: IngestConfigurationState? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filterByStageArn = filterByStageArn
            self.filterByState = filterByState
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, max: 128)
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, min: 1)
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterByStageArn = "filterByStageArn"
            case filterByState = "filterByState"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListIngestConfigurationsResponse: AWSDecodableShape {
        /// List of the matching ingest configurations (summary information only).
        public let ingestConfigurations: [IngestConfigurationSummary]
        /// If there are more IngestConfigurations than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        @inlinable
        public init(ingestConfigurations: [IngestConfigurationSummary], nextToken: String? = nil) {
            self.ingestConfigurations = ingestConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ingestConfigurations = "ingestConfigurations"
            case nextToken = "nextToken"
        }
    }

    public struct ListParticipantEventsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first participant event to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// Unique identifier for this participant. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// ID of a session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, participantId: String, sessionId: String, stageArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.participantId = participantId
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.participantId, name: "participantId", parent: name, max: 64)
            try self.validate(self.participantId, name: "participantId", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case participantId = "participantId"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct ListParticipantEventsResponse: AWSDecodableShape {
        /// List of the matching events.
        public let events: [Event]
        /// If there are more events than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        @inlinable
        public init(events: [Event], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListParticipantsRequest: AWSEncodableShape {
        /// Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
        public let filterByPublished: Bool?
        /// Filters the response list to only show participants with the specified recording state. Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
        public let filterByRecordingState: ParticipantRecordingFilterByRecordingState?
        /// Filters the response list to only show participants in the specified state.  Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
        public let filterByState: ParticipantState?
        /// Filters the response list to match the specified user ID.  Only one of filterByUserId, filterByPublished,  filterByState, or filterByRecordingState can be provided per request.
        /// 	    A userId is a customer-assigned name to help identify the token; this can be used to link a participant to a user in the customerâ€™s own systems.
        public let filterByUserId: String?
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// ID of the session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        @inlinable
        public init(filterByPublished: Bool? = nil, filterByRecordingState: ParticipantRecordingFilterByRecordingState? = nil, filterByState: ParticipantState? = nil, filterByUserId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sessionId: String, stageArn: String) {
            self.filterByPublished = filterByPublished
            self.filterByRecordingState = filterByRecordingState
            self.filterByState = filterByState
            self.filterByUserId = filterByUserId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.filterByUserId, name: "filterByUserId", parent: name, max: 128)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterByPublished = "filterByPublished"
            case filterByRecordingState = "filterByRecordingState"
            case filterByState = "filterByState"
            case filterByUserId = "filterByUserId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct ListParticipantsResponse: AWSDecodableShape {
        /// If there are more participants than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching participants (summary information only).
        public let participants: [ParticipantSummary]

        @inlinable
        public init(nextToken: String? = nil, participants: [ParticipantSummary]) {
            self.nextToken = nextToken
            self.participants = participants
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case participants = "participants"
        }
    }

    public struct ListPublicKeysRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first public key to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListPublicKeysResponse: AWSDecodableShape {
        /// If there are more public keys than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching public keys (summary information only).
        public let publicKeys: [PublicKeySummary]

        @inlinable
        public init(nextToken: String? = nil, publicKeys: [PublicKeySummary]) {
            self.nextToken = nextToken
            self.publicKeys = publicKeys
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case publicKeys = "publicKeys"
        }
    }

    public struct ListStageSessionsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first stage session to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// Stage ARN.
        public let stageArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, stageArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case stageArn = "stageArn"
        }
    }

    public struct ListStageSessionsResponse: AWSDecodableShape {
        /// If there are more stage sessions than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of matching stage sessions.
        public let stageSessions: [StageSessionSummary]

        @inlinable
        public init(nextToken: String? = nil, stageSessions: [StageSessionSummary]) {
            self.nextToken = nextToken
            self.stageSessions = stageSessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stageSessions = "stageSessions"
        }
    }

    public struct ListStagesRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStagesResponse: AWSDecodableShape {
        /// If there are more stages than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching stages (summary information only).
        public let stages: [StageSummary]

        @inlinable
        public init(nextToken: String? = nil, stages: [StageSummary]) {
            self.nextToken = nextToken
            self.stages = stages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stages = "stages"
        }
    }

    public struct ListStorageConfigurationsRequest: AWSEncodableShape {
        /// Maximum number of storage configurations to return. Default: your service quota or 100,
        /// 	  whichever is smaller.
        public let maxResults: Int?
        /// The first storage configuration to retrieve. This is used for pagination;
        /// 	  see the nextToken response field.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStorageConfigurationsResponse: AWSDecodableShape {
        /// If there are more storage configurations than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching storage configurations.
        public let storageConfigurations: [StorageConfigurationSummary]

        @inlinable
        public init(nextToken: String? = nil, storageConfigurations: [StorageConfigurationSummary]) {
            self.nextToken = nextToken
            self.storageConfigurations = storageConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case storageConfigurations = "storageConfigurations"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Participant: AWSDecodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// The participantâ€™s browser.
        public let browserName: String?
        /// The participantâ€™s browser version.
        public let browserVersion: String?
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var firstJoinTime: Date?
        /// The participantâ€™s Internet Service Provider.
        public let ispName: String?
        /// The participantâ€™s operating system.
        public let osName: String?
        /// The participantâ€™s operating system version.
        public let osVersion: String?
        /// Unique identifier for this participant, assigned by IVS.
        public let participantId: String?
        /// Type of ingest protocol that the participant employs for broadcasting.
        public let `protocol`: ParticipantProtocol?
        /// Whether the participant ever published to the stage session.
        public let published: Bool?
        /// Name of the S3 bucket to where the participant is being recorded, if individual participant recording is enabled, or "" (empty string), if recording is not enabled.
        public let recordingS3BucketName: String?
        /// S3 prefix of the S3 bucket where the participant is being recorded, if individual participant recording is enabled, or "" (empty string), if recording is not enabled.
        public let recordingS3Prefix: String?
        /// The participantâ€™s recording state.
        public let recordingState: ParticipantRecordingState?
        /// The participantâ€™s SDK version.
        public let sdkVersion: String?
        /// Whether the participant is connected to or disconnected from the stage.
        public let state: ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customerâ€™s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(attributes: [String: String]? = nil, browserName: String? = nil, browserVersion: String? = nil, firstJoinTime: Date? = nil, ispName: String? = nil, osName: String? = nil, osVersion: String? = nil, participantId: String? = nil, protocol: ParticipantProtocol? = nil, published: Bool? = nil, recordingS3BucketName: String? = nil, recordingS3Prefix: String? = nil, recordingState: ParticipantRecordingState? = nil, sdkVersion: String? = nil, state: ParticipantState? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.browserName = browserName
            self.browserVersion = browserVersion
            self.firstJoinTime = firstJoinTime
            self.ispName = ispName
            self.osName = osName
            self.osVersion = osVersion
            self.participantId = participantId
            self.`protocol` = `protocol`
            self.published = published
            self.recordingS3BucketName = recordingS3BucketName
            self.recordingS3Prefix = recordingS3Prefix
            self.recordingState = recordingState
            self.sdkVersion = sdkVersion
            self.state = state
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case browserName = "browserName"
            case browserVersion = "browserVersion"
            case firstJoinTime = "firstJoinTime"
            case ispName = "ispName"
            case osName = "osName"
            case osVersion = "osVersion"
            case participantId = "participantId"
            case `protocol` = "protocol"
            case published = "published"
            case recordingS3BucketName = "recordingS3BucketName"
            case recordingS3Prefix = "recordingS3Prefix"
            case recordingState = "recordingState"
            case sdkVersion = "sdkVersion"
            case state = "state"
            case userId = "userId"
        }
    }

    public struct ParticipantRecordingHlsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the target duration for recorded segments generated when recording a stage participant.
        /// 	  Segments may have durations longer than the specified value when needed to ensure each segment begins with a keyframe.
        /// 	  Default: 6.
        public let targetSegmentDurationSeconds: Int?

        @inlinable
        public init(targetSegmentDurationSeconds: Int? = nil) {
            self.targetSegmentDurationSeconds = targetSegmentDurationSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.targetSegmentDurationSeconds, name: "targetSegmentDurationSeconds", parent: name, max: 10)
            try self.validate(self.targetSegmentDurationSeconds, name: "targetSegmentDurationSeconds", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case targetSegmentDurationSeconds = "targetSegmentDurationSeconds"
        }
    }

    public struct ParticipantSummary: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var firstJoinTime: Date?
        /// Unique identifier for this participant, assigned by IVS.
        public let participantId: String?
        /// Whether the participant ever published to the stage session.
        public let published: Bool?
        /// The participantâ€™s recording state.
        public let recordingState: ParticipantRecordingState?
        /// Whether the participant is connected to or disconnected from the stage.
        public let state: ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customerâ€™s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(firstJoinTime: Date? = nil, participantId: String? = nil, published: Bool? = nil, recordingState: ParticipantRecordingState? = nil, state: ParticipantState? = nil, userId: String? = nil) {
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.recordingState = recordingState
            self.state = state
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case firstJoinTime = "firstJoinTime"
            case participantId = "participantId"
            case published = "published"
            case recordingState = "recordingState"
            case state = "state"
            case userId = "userId"
        }
    }

    public struct ParticipantThumbnailConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Thumbnail recording mode. Default: DISABLED.
        public let recordingMode: ThumbnailRecordingMode?
        /// Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails/high directory. LATEST saves the latest thumbnail in media/latest_thumbnail/high/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        public let storage: [ThumbnailStorageType]?
        /// The targeted thumbnail-generation interval in seconds. This is configurable only if recordingMode is INTERVAL. Default: 60.
        public let targetIntervalSeconds: Int?

        @inlinable
        public init(recordingMode: ThumbnailRecordingMode? = nil, storage: [ThumbnailStorageType]? = nil, targetIntervalSeconds: Int? = nil) {
            self.recordingMode = recordingMode
            self.storage = storage
            self.targetIntervalSeconds = targetIntervalSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.storage, name: "storage", parent: name, max: 2)
            try self.validate(self.targetIntervalSeconds, name: "targetIntervalSeconds", parent: name, max: 86400)
            try self.validate(self.targetIntervalSeconds, name: "targetIntervalSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recordingMode = "recordingMode"
            case storage = "storage"
            case targetIntervalSeconds = "targetIntervalSeconds"
        }
    }

    public struct ParticipantToken: AWSDecodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default: 720 (12 hours).
        public let duration: Int?
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public let participantId: String?
        /// The issued client token, encrypted.
        public let token: String?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customerâ€™s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, expirationTime: Date? = nil, participantId: String? = nil, token: String? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case expirationTime = "expirationTime"
            case participantId = "participantId"
            case token = "token"
            case userId = "userId"
        }
    }

    public struct ParticipantTokenConfiguration: AWSEncodableShape {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 720 (12 hours).
        public let duration: Int?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customerâ€™s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        @inlinable
        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case userId = "userId"
        }
    }

    public struct PendingVerification: AWSErrorShape {
        public let accessControlAllowOrigin: String?
        public let accessControlExposeHeaders: String?
        public let cacheControl: String?
        public let contentSecurityPolicy: String?
        ///  Your account is pending verification.
        public let exceptionMessage: String?
        public let strictTransportSecurity: String?
        public let xAmznErrorType: String?
        public let xContentTypeOptions: String?
        public let xFrameOptions: String?

        @inlinable
        public init(accessControlAllowOrigin: String? = nil, accessControlExposeHeaders: String? = nil, cacheControl: String? = nil, contentSecurityPolicy: String? = nil, exceptionMessage: String? = nil, strictTransportSecurity: String? = nil, xAmznErrorType: String? = nil, xContentTypeOptions: String? = nil, xFrameOptions: String? = nil) {
            self.accessControlAllowOrigin = accessControlAllowOrigin
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.cacheControl = cacheControl
            self.contentSecurityPolicy = contentSecurityPolicy
            self.exceptionMessage = exceptionMessage
            self.strictTransportSecurity = strictTransportSecurity
            self.xAmznErrorType = xAmznErrorType
            self.xContentTypeOptions = xContentTypeOptions
            self.xFrameOptions = xFrameOptions
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessControlAllowOrigin = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Allow-Origin")
            self.accessControlExposeHeaders = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Expose-Headers")
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentSecurityPolicy = try response.decodeHeaderIfPresent(String.self, key: "Content-Security-Policy")
            self.exceptionMessage = try container.decodeIfPresent(String.self, forKey: .exceptionMessage)
            self.strictTransportSecurity = try response.decodeHeaderIfPresent(String.self, key: "Strict-Transport-Security")
            self.xAmznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.xContentTypeOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Content-Type-Options")
            self.xFrameOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Frame-Options")
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionMessage = "exceptionMessage"
        }
    }

    public struct PipConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in ParticipantTokenConfiguration is placed in the featured slot. Default: "" (no featured participant).
        public let featuredParticipantAttribute: String?
        /// Specifies the spacing between participant tiles in pixels. Default: 0.
        public let gridGap: Int?
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public let omitStoppedVideo: Bool?
        /// Defines PiP behavior when all participants have left: STATIC (maintains original position/size) or DYNAMIC (expands to full composition). Default: STATIC.
        public let pipBehavior: PipBehavior?
        /// Specifies the height of the PiP window in pixels. When this is not set explicitly, pipHeightâ€™s value will be based on the size of the composition and the aspect ratio of the participantâ€™s video.
        public let pipHeight: Int?
        /// Sets the PiP windowâ€™s offset position in pixels from the closest edges determined by PipPosition. Default: 0.
        public let pipOffset: Int?
        /// Specifies the participant for the PiP window. A participant with this attribute set to "true" (as a string value) in ParticipantTokenConfiguration is placed in the PiP slot. Default: "" (no PiP participant).
        public let pipParticipantAttribute: String?
        /// Determines the corner position of the PiP window. Default: BOTTOM_RIGHT.
        public let pipPosition: PipPosition?
        /// Specifies the width of the PiP window in pixels. When this is not set explicitly, pipWidthâ€™s value will be based on the size of the composition and the aspect ratio of the participantâ€™s video.
        public let pipWidth: Int?
        /// Defines how video content fits within the participant tile: FILL (stretched), COVER (cropped), or CONTAIN (letterboxed). Default: COVER.
        public let videoFillMode: VideoFillMode?

        @inlinable
        public init(featuredParticipantAttribute: String? = nil, gridGap: Int? = nil, omitStoppedVideo: Bool? = nil, pipBehavior: PipBehavior? = nil, pipHeight: Int? = nil, pipOffset: Int? = nil, pipParticipantAttribute: String? = nil, pipPosition: PipPosition? = nil, pipWidth: Int? = nil, videoFillMode: VideoFillMode? = nil) {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.pipBehavior = pipBehavior
            self.pipHeight = pipHeight
            self.pipOffset = pipOffset
            self.pipParticipantAttribute = pipParticipantAttribute
            self.pipPosition = pipPosition
            self.pipWidth = pipWidth
            self.videoFillMode = videoFillMode
        }

        public func validate(name: String) throws {
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, max: 128)
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.gridGap, name: "gridGap", parent: name, min: 0)
            try self.validate(self.pipHeight, name: "pipHeight", parent: name, min: 1)
            try self.validate(self.pipOffset, name: "pipOffset", parent: name, min: 0)
            try self.validate(self.pipParticipantAttribute, name: "pipParticipantAttribute", parent: name, max: 128)
            try self.validate(self.pipParticipantAttribute, name: "pipParticipantAttribute", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.pipWidth, name: "pipWidth", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case featuredParticipantAttribute = "featuredParticipantAttribute"
            case gridGap = "gridGap"
            case omitStoppedVideo = "omitStoppedVideo"
            case pipBehavior = "pipBehavior"
            case pipHeight = "pipHeight"
            case pipOffset = "pipOffset"
            case pipParticipantAttribute = "pipParticipantAttribute"
            case pipPosition = "pipPosition"
            case pipWidth = "pipWidth"
            case videoFillMode = "videoFillMode"
        }
    }

    public struct PublicKey: AWSDecodableShape {
        /// Public key ARN.
        public let arn: String?
        /// The public key fingerprint, a short string used to identify or verify the full public key.
        public let fingerprint: String?
        /// Public key name.
        public let name: String?
        /// Public key material.
        public let publicKeyMaterial: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, fingerprint: String? = nil, name: String? = nil, publicKeyMaterial: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.fingerprint = fingerprint
            self.name = name
            self.publicKeyMaterial = publicKeyMaterial
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case fingerprint = "fingerprint"
            case name = "name"
            case publicKeyMaterial = "publicKeyMaterial"
            case tags = "tags"
        }
    }

    public struct PublicKeySummary: AWSDecodableShape {
        /// Public key ARN.
        public let arn: String?
        /// Public key name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct RecordingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The recording format for storing a recording in Amazon S3.
        public let format: RecordingConfigurationFormat?
        /// An HLS configuration object to return information about how the recording will be configured.
        public let hlsConfiguration: CompositionRecordingHlsConfiguration?

        @inlinable
        public init(format: RecordingConfigurationFormat? = nil, hlsConfiguration: CompositionRecordingHlsConfiguration? = nil) {
            self.format = format
            self.hlsConfiguration = hlsConfiguration
        }

        public func validate(name: String) throws {
            try self.hlsConfiguration?.validate(name: "\(name).hlsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case hlsConfiguration = "hlsConfiguration"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let accessControlAllowOrigin: String?
        public let accessControlExposeHeaders: String?
        public let cacheControl: String?
        public let contentSecurityPolicy: String?
        /// Request references a resource which does not exist.
        public let exceptionMessage: String?
        public let strictTransportSecurity: String?
        public let xAmznErrorType: String?
        public let xContentTypeOptions: String?
        public let xFrameOptions: String?

        @inlinable
        public init(accessControlAllowOrigin: String? = nil, accessControlExposeHeaders: String? = nil, cacheControl: String? = nil, contentSecurityPolicy: String? = nil, exceptionMessage: String? = nil, strictTransportSecurity: String? = nil, xAmznErrorType: String? = nil, xContentTypeOptions: String? = nil, xFrameOptions: String? = nil) {
            self.accessControlAllowOrigin = accessControlAllowOrigin
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.cacheControl = cacheControl
            self.contentSecurityPolicy = contentSecurityPolicy
            self.exceptionMessage = exceptionMessage
            self.strictTransportSecurity = strictTransportSecurity
            self.xAmznErrorType = xAmznErrorType
            self.xContentTypeOptions = xContentTypeOptions
            self.xFrameOptions = xFrameOptions
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessControlAllowOrigin = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Allow-Origin")
            self.accessControlExposeHeaders = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Expose-Headers")
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentSecurityPolicy = try response.decodeHeaderIfPresent(String.self, key: "Content-Security-Policy")
            self.exceptionMessage = try container.decodeIfPresent(String.self, forKey: .exceptionMessage)
            self.strictTransportSecurity = try response.decodeHeaderIfPresent(String.self, key: "Strict-Transport-Security")
            self.xAmznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.xContentTypeOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Content-Type-Options")
            self.xFrameOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Frame-Options")
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionMessage = "exceptionMessage"
        }
    }

    public struct S3DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// ARNs of the EncoderConfiguration resource. The encoder configuration and stage resources must be in the same AWS account and region.
        public let encoderConfigurationArns: [String]
        /// Array of maps, each of the form string:string (key:value). This is an optional customer specification, currently used only to specify the recording format for storing a recording in Amazon S3.
        public let recordingConfiguration: RecordingConfiguration?
        /// ARN of the StorageConfiguration where recorded videos will be stored.
        public let storageConfigurationArn: String
        /// A complex type that allows you to enable/disable the recording of thumbnails for a Composition and modify the interval at which thumbnails are generated for the live session.
        public let thumbnailConfigurations: [CompositionThumbnailConfiguration]?

        @inlinable
        public init(encoderConfigurationArns: [String], recordingConfiguration: RecordingConfiguration? = nil, storageConfigurationArn: String, thumbnailConfigurations: [CompositionThumbnailConfiguration]? = nil) {
            self.encoderConfigurationArns = encoderConfigurationArns
            self.recordingConfiguration = recordingConfiguration
            self.storageConfigurationArn = storageConfigurationArn
            self.thumbnailConfigurations = thumbnailConfigurations
        }

        public func validate(name: String) throws {
            try self.encoderConfigurationArns.forEach {
                try validate($0, name: "encoderConfigurationArns[]", parent: name, max: 128)
                try validate($0, name: "encoderConfigurationArns[]", parent: name, min: 1)
                try validate($0, name: "encoderConfigurationArns[]", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
            }
            try self.validate(self.encoderConfigurationArns, name: "encoderConfigurationArns", parent: name, max: 1)
            try self.validate(self.encoderConfigurationArns, name: "encoderConfigurationArns", parent: name, min: 1)
            try self.recordingConfiguration?.validate(name: "\(name).recordingConfiguration")
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, max: 128)
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, min: 1)
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:storage-configuration/[a-zA-Z0-9-]+$")
            try self.thumbnailConfigurations?.forEach {
                try $0.validate(name: "\(name).thumbnailConfigurations[]")
            }
            try self.validate(self.thumbnailConfigurations, name: "thumbnailConfigurations", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfigurationArns = "encoderConfigurationArns"
            case recordingConfiguration = "recordingConfiguration"
            case storageConfigurationArn = "storageConfigurationArn"
            case thumbnailConfigurations = "thumbnailConfigurations"
        }
    }

    public struct S3Detail: AWSDecodableShape {
        /// The S3 bucket prefix under which the recording is stored.
        public let recordingPrefix: String

        @inlinable
        public init(recordingPrefix: String) {
            self.recordingPrefix = recordingPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case recordingPrefix = "recordingPrefix"
        }
    }

    public struct S3StorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        public let bucketName: String

        @inlinable
        public init(bucketName: String) {
            self.bucketName = bucketName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9-.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let accessControlAllowOrigin: String?
        public let accessControlExposeHeaders: String?
        public let cacheControl: String?
        public let contentSecurityPolicy: String?
        /// Request would cause a service quota to be exceeded.
        public let exceptionMessage: String?
        public let strictTransportSecurity: String?
        public let xAmznErrorType: String?
        public let xContentTypeOptions: String?
        public let xFrameOptions: String?

        @inlinable
        public init(accessControlAllowOrigin: String? = nil, accessControlExposeHeaders: String? = nil, cacheControl: String? = nil, contentSecurityPolicy: String? = nil, exceptionMessage: String? = nil, strictTransportSecurity: String? = nil, xAmznErrorType: String? = nil, xContentTypeOptions: String? = nil, xFrameOptions: String? = nil) {
            self.accessControlAllowOrigin = accessControlAllowOrigin
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.cacheControl = cacheControl
            self.contentSecurityPolicy = contentSecurityPolicy
            self.exceptionMessage = exceptionMessage
            self.strictTransportSecurity = strictTransportSecurity
            self.xAmznErrorType = xAmznErrorType
            self.xContentTypeOptions = xContentTypeOptions
            self.xFrameOptions = xFrameOptions
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessControlAllowOrigin = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Allow-Origin")
            self.accessControlExposeHeaders = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Expose-Headers")
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentSecurityPolicy = try response.decodeHeaderIfPresent(String.self, key: "Content-Security-Policy")
            self.exceptionMessage = try container.decodeIfPresent(String.self, forKey: .exceptionMessage)
            self.strictTransportSecurity = try response.decodeHeaderIfPresent(String.self, key: "Strict-Transport-Security")
            self.xAmznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.xContentTypeOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Content-Type-Options")
            self.xFrameOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Frame-Options")
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionMessage = "exceptionMessage"
        }
    }

    public struct Stage: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Configuration object for individual participant recording, attached to the stage.
        public let autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration?
        /// Summary information about various endpoints for a stage.
        public let endpoints: StageEndpoints?
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(activeSessionId: String? = nil, arn: String, autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration? = nil, endpoints: StageEndpoints? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.autoParticipantRecordingConfiguration = autoParticipantRecordingConfiguration
            self.endpoints = endpoints
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case autoParticipantRecordingConfiguration = "autoParticipantRecordingConfiguration"
            case endpoints = "endpoints"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct StageEndpoints: AWSDecodableShape {
        /// Events endpoint.
        public let events: String?
        /// The endpoint to be used for IVS real-time streaming using the RTMP protocol.
        public let rtmp: String?
        /// The endpoint to be used for IVS real-time streaming using the RTMPS protocol.
        public let rtmps: String?
        /// The endpoint to be used for IVS real-time streaming using the WHIP protocol.
        public let whip: String?

        @inlinable
        public init(events: String? = nil, rtmp: String? = nil, rtmps: String? = nil, whip: String? = nil) {
            self.events = events
            self.rtmp = rtmp
            self.rtmps = rtmps
            self.whip = whip
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case rtmp = "rtmp"
            case rtmps = "rtmps"
            case whip = "whip"
        }
    }

    public struct StageSession: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ID of the session within the stage.
        public let sessionId: String?
        ///  ISO 8601 timestamp (returned as a string) when this stage session began.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, sessionId: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case sessionId = "sessionId"
            case startTime = "startTime"
        }
    }

    public struct StageSessionSummary: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ID of the session within the stage.
        public let sessionId: String?
        ///  ISO 8601 timestamp (returned as a string) when this stage session began.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, sessionId: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case sessionId = "sessionId"
            case startTime = "startTime"
        }
    }

    public struct StageSummary: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(activeSessionId: String? = nil, arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct StartCompositionRequest: AWSEncodableShape {
        /// Array of destination configuration.
        public let destinations: [DestinationConfiguration]
        /// Idempotency token.
        public let idempotencyToken: String?
        /// Layout object to configure composition parameters.
        public let layout: LayoutConfiguration?
        /// ARN of the stage to be used for compositing.
        public let stageArn: String
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(destinations: [DestinationConfiguration], idempotencyToken: String? = StartCompositionRequest.idempotencyToken(), layout: LayoutConfiguration? = nil, stageArn: String, tags: [String: String]? = nil) {
            self.destinations = destinations
            self.idempotencyToken = idempotencyToken
            self.layout = layout
            self.stageArn = stageArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.destinations, name: "destinations", parent: name, max: 2)
            try self.validate(self.destinations, name: "destinations", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 64)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.layout?.validate(name: "\(name).layout")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
            case idempotencyToken = "idempotencyToken"
            case layout = "layout"
            case stageArn = "stageArn"
            case tags = "tags"
        }
    }

    public struct StartCompositionResponse: AWSDecodableShape {
        /// The Composition that was created.
        public let composition: Composition?

        @inlinable
        public init(composition: Composition? = nil) {
            self.composition = composition
        }

        private enum CodingKeys: String, CodingKey {
            case composition = "composition"
        }
    }

    public struct StopCompositionRequest: AWSEncodableShape {
        /// ARN of the Composition.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:composition/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct StopCompositionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StorageConfiguration: AWSDecodableShape {
        /// ARN of the storage configuration.
        public let arn: String
        /// Name of the storage configuration.
        public let name: String?
        /// An S3 destination configuration where recorded videos will be stored.
        public let s3: S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, name: String? = nil, s3: S3StorageConfiguration? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case s3 = "s3"
            case tags = "tags"
        }
    }

    public struct StorageConfigurationSummary: AWSDecodableShape {
        /// ARN of the storage configuration.
        public let arn: String
        /// Name of the storage configuration.
        public let name: String?
        /// An S3 destination configuration where recorded videos will be stored.
        public let s3: S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, name: String? = nil, s3: S3StorageConfiguration? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case s3 = "s3"
            case tags = "tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tag keys (strings) for the tags to be removed. See Best practices and strategies in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIngestConfigurationRequest: AWSEncodableShape {
        /// ARN of the IngestConfiguration, for which the related stage ARN needs to be updated.
        public let arn: String
        /// Stage ARN that needs to be updated.
        public let stageArn: String?

        @inlinable
        public init(arn: String, stageArn: String? = nil) {
            self.arn = arn
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:ingest-configuration/[a-zA-Z0-9-]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^^$|^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case stageArn = "stageArn"
        }
    }

    public struct UpdateIngestConfigurationResponse: AWSDecodableShape {
        /// The updated IngestConfiguration.
        public let ingestConfiguration: IngestConfiguration?

        @inlinable
        public init(ingestConfiguration: IngestConfiguration? = nil) {
            self.ingestConfiguration = ingestConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case ingestConfiguration = "ingestConfiguration"
        }
    }

    public struct UpdateStageRequest: AWSEncodableShape {
        /// ARN of the stage to be updated.
        public let arn: String
        /// Configuration object for individual participant recording, to attach to the stage. Note that this cannot be updated while recording is active.
        public let autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration?
        /// Name of the stage to be updated.
        public let name: String?

        @inlinable
        public init(arn: String, autoParticipantRecordingConfiguration: AutoParticipantRecordingConfiguration? = nil, name: String? = nil) {
            self.arn = arn
            self.autoParticipantRecordingConfiguration = autoParticipantRecordingConfiguration
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.autoParticipantRecordingConfiguration?.validate(name: "\(name).autoParticipantRecordingConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case autoParticipantRecordingConfiguration = "autoParticipantRecordingConfiguration"
            case name = "name"
        }
    }

    public struct UpdateStageResponse: AWSDecodableShape {
        /// The updated stage.
        public let stage: Stage?

        @inlinable
        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let accessControlAllowOrigin: String?
        public let accessControlExposeHeaders: String?
        public let cacheControl: String?
        public let contentSecurityPolicy: String?
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public let exceptionMessage: String?
        public let strictTransportSecurity: String?
        public let xAmznErrorType: String?
        public let xContentTypeOptions: String?
        public let xFrameOptions: String?

        @inlinable
        public init(accessControlAllowOrigin: String? = nil, accessControlExposeHeaders: String? = nil, cacheControl: String? = nil, contentSecurityPolicy: String? = nil, exceptionMessage: String? = nil, strictTransportSecurity: String? = nil, xAmznErrorType: String? = nil, xContentTypeOptions: String? = nil, xFrameOptions: String? = nil) {
            self.accessControlAllowOrigin = accessControlAllowOrigin
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.cacheControl = cacheControl
            self.contentSecurityPolicy = contentSecurityPolicy
            self.exceptionMessage = exceptionMessage
            self.strictTransportSecurity = strictTransportSecurity
            self.xAmznErrorType = xAmznErrorType
            self.xContentTypeOptions = xContentTypeOptions
            self.xFrameOptions = xFrameOptions
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.accessControlAllowOrigin = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Allow-Origin")
            self.accessControlExposeHeaders = try response.decodeHeaderIfPresent(String.self, key: "Access-Control-Expose-Headers")
            self.cacheControl = try response.decodeHeaderIfPresent(String.self, key: "Cache-Control")
            self.contentSecurityPolicy = try response.decodeHeaderIfPresent(String.self, key: "Content-Security-Policy")
            self.exceptionMessage = try container.decodeIfPresent(String.self, forKey: .exceptionMessage)
            self.strictTransportSecurity = try response.decodeHeaderIfPresent(String.self, key: "Strict-Transport-Security")
            self.xAmznErrorType = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-ErrorType")
            self.xContentTypeOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Content-Type-Options")
            self.xFrameOptions = try response.decodeHeaderIfPresent(String.self, key: "X-Frame-Options")
        }

        private enum CodingKeys: String, CodingKey {
            case exceptionMessage = "exceptionMessage"
        }
    }

    public struct Video: AWSEncodableShape & AWSDecodableShape {
        /// Bitrate for generated output, in bps. Default: 2500000.
        public let bitrate: Int?
        /// Video frame rate, in fps. Default: 30.
        public let framerate: Float?
        /// Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        public let height: Int?
        /// Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        public let width: Int?

        @inlinable
        public init(bitrate: Int? = nil, framerate: Float? = nil, height: Int? = nil, width: Int? = nil) {
            self.bitrate = bitrate
            self.framerate = framerate
            self.height = height
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.bitrate, name: "bitrate", parent: name, max: 8500000)
            try self.validate(self.bitrate, name: "bitrate", parent: name, min: 1)
            try self.validate(self.framerate, name: "framerate", parent: name, max: 60.0)
            try self.validate(self.framerate, name: "framerate", parent: name, min: 1.0)
            try self.validate(self.height, name: "height", parent: name, max: 1920)
            try self.validate(self.height, name: "height", parent: name, min: 2)
            try self.validate(self.width, name: "width", parent: name, max: 1920)
            try self.validate(self.width, name: "width", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case bitrate = "bitrate"
            case framerate = "framerate"
            case height = "height"
            case width = "width"
        }
    }
}

// MARK: - Errors

/// Error enum for IVSRealTime
public struct IVSRealTimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case pendingVerification = "PendingVerification"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IVSRealTime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    public static var conflictException: Self { .init(.conflictException) }
    public static var internalServerException: Self { .init(.internalServerException) }
    public static var pendingVerification: Self { .init(.pendingVerification) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    public static var validationException: Self { .init(.validationException) }
}

extension IVSRealTimeErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": IVSRealTime.AccessDeniedException.self,
        "ConflictException": IVSRealTime.ConflictException.self,
        "InternalServerException": IVSRealTime.InternalServerException.self,
        "PendingVerification": IVSRealTime.PendingVerification.self,
        "ResourceNotFoundException": IVSRealTime.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": IVSRealTime.ServiceQuotaExceededException.self,
        "ValidationException": IVSRealTime.ValidationException.self
    ]
}

extension IVSRealTimeErrorType: Equatable {
    public static func == (lhs: IVSRealTimeErrorType, rhs: IVSRealTimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IVSRealTimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
