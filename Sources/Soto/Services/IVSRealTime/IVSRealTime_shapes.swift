//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension IVSRealTime {
    // MARK: Enums

    public enum ParticipantTokenCapability: String, CustomStringConvertible, Codable, Sendable {
        case publish = "PUBLISH"
        case subscribe = "SUBSCRIBE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateParticipantTokenRequest: AWSEncodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8
        /// 	        encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and
        /// 			should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the token expires. Default: 60 (1 hour).
        public let duration: Int?
        /// ARN of the stage to which this token is scoped.
        public let stageArn: String
        /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage
        /// 	        participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, stageArn: String, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.stageArn = stageArn
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case stageArn = "stageArn"
            case userId = "userId"
        }
    }

    public struct CreateParticipantTokenResponse: AWSDecodableShape {
        /// The participant token that was created.
        public let participantToken: ParticipantToken?

        public init(participantToken: ParticipantToken? = nil) {
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case participantToken = "participantToken"
        }
    }

    public struct CreateStageRequest: AWSEncodableShape {
        /// Optional name that can be specified for the stage being created.
        public let name: String?
        /// Array of participant token configuration objects to attach to the new stage.
        public let participantTokenConfigurations: [ParticipantTokenConfiguration]?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(name: String? = nil, participantTokenConfigurations: [ParticipantTokenConfiguration]? = nil, tags: [String: String]? = nil) {
            self.name = name
            self.participantTokenConfigurations = participantTokenConfigurations
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.participantTokenConfigurations?.forEach {
                try $0.validate(name: "\(name).participantTokenConfigurations[]")
            }
            try self.validate(self.participantTokenConfigurations, name: "participantTokenConfigurations", parent: name, max: 12)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case participantTokenConfigurations = "participantTokenConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateStageResponse: AWSDecodableShape {
        /// Participant tokens attached to the stage. These correspond to the participants in the request.
        public let participantTokens: [ParticipantToken]?
        /// The stage that was created.
        public let stage: Stage?

        public init(participantTokens: [ParticipantToken]? = nil, stage: Stage? = nil) {
            self.participantTokens = participantTokens
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case participantTokens = "participantTokens"
            case stage = "stage"
        }
    }

    public struct DeleteStageRequest: AWSEncodableShape {
        /// ARN of the stage to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteStageResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisconnectParticipantRequest: AWSEncodableShape {
        /// Identifier of the participant to be disconnected. This is returned by CreateParticipantToken.
        public let participantId: String
        /// Description of why this participant is being disconnected.
        public let reason: String?
        /// ARN of the stage to which the participant is attached.
        public let stageArn: String

        public init(participantId: String, reason: String? = nil, stageArn: String) {
            self.participantId = participantId
            self.reason = reason
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.reason, name: "reason", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case participantId = "participantId"
            case reason = "reason"
            case stageArn = "stageArn"
        }
    }

    public struct DisconnectParticipantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetStageRequest: AWSEncodableShape {
        /// ARN of the stage for which the information is to be retrieved.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetStageResponse: AWSDecodableShape {
        public let stage: Stage?

        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }

    public struct ListStagesRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStagesResponse: AWSDecodableShape {
        /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching stages (summary information only).
        public let stages: [StageSummary]

        public init(nextToken: String? = nil, stages: [StageSummary]) {
            self.nextToken = nextToken
            self.stages = stages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stages = "stages"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ParticipantToken: AWSDecodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all  stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default: 60 (1 hour).
        public let duration: Int?
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public let participantId: String?
        /// The issued client token, encrypted.
        public let token: String?
        /// Name to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all  stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, expirationTime: Date? = nil, participantId: String? = nil, token: String? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case expirationTime = "expirationTime"
            case participantId = "participantId"
            case token = "token"
            case userId = "userId"
        }
    }

    public struct ParticipantTokenConfiguration: AWSEncodableShape {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text.  The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally  identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 60 (1 hour).
        public let duration: Int?
        /// Name that can be specified to help identify the corresponding participant token. This can be any UTF-8 encoded text. This field is exposed to all  stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case userId = "userId"
        }
    }

    public struct Stage: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(activeSessionId: String? = nil, arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct StageSummary: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(activeSessionId: String? = nil, arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStageRequest: AWSEncodableShape {
        /// ARN of the stage to be updated.
        public let arn: String
        /// Name of the stage to be updated.
        public let name: String?

        public init(arn: String, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateStageResponse: AWSDecodableShape {
        /// The updated stage.
        public let stage: Stage?

        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }
}

// MARK: - Errors

/// Error enum for IVSRealTime
public struct IVSRealTimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case pendingVerification = "PendingVerification"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IVSRealTime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    public static var conflictException: Self { .init(.conflictException) }
    public static var internalServerException: Self { .init(.internalServerException) }
    public static var pendingVerification: Self { .init(.pendingVerification) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    public static var validationException: Self { .init(.validationException) }
}

extension IVSRealTimeErrorType: Equatable {
    public static func == (lhs: IVSRealTimeErrorType, rhs: IVSRealTimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IVSRealTimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
