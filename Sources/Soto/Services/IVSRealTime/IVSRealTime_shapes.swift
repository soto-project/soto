//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IVSRealTime {
    // MARK: Enums

    public enum EventErrorCode: String, CustomStringConvertible, Codable, Sendable {
        case insufficientCapabilities = "INSUFFICIENT_CAPABILITIES"
        public var description: String { return self.rawValue }
    }

    public enum EventName: String, CustomStringConvertible, Codable, Sendable {
        case joined = "JOINED"
        case joinError = "JOIN_ERROR"
        case left = "LEFT"
        case publishError = "PUBLISH_ERROR"
        case publishStarted = "PUBLISH_STARTED"
        case publishStopped = "PUBLISH_STOPPED"
        case subscribeError = "SUBSCRIBE_ERROR"
        case subscribeStarted = "SUBSCRIBE_STARTED"
        case subscribeStopped = "SUBSCRIBE_STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantState: String, CustomStringConvertible, Codable, Sendable {
        case connected = "CONNECTED"
        case disconnected = "DISCONNECTED"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTokenCapability: String, CustomStringConvertible, Codable, Sendable {
        case publish = "PUBLISH"
        case subscribe = "SUBSCRIBE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateParticipantTokenRequest: AWSEncodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the token expires. Default:  720 (12 hours).
        public let duration: Int?
        /// ARN of the stage to which this token is scoped.
        public let stageArn: String
        /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, stageArn: String, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.stageArn = stageArn
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case stageArn = "stageArn"
            case userId = "userId"
        }
    }

    public struct CreateParticipantTokenResponse: AWSDecodableShape {
        /// The participant token that was created.
        public let participantToken: ParticipantToken?

        public init(participantToken: ParticipantToken? = nil) {
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case participantToken = "participantToken"
        }
    }

    public struct CreateStageRequest: AWSEncodableShape {
        /// Optional name that can be specified for the stage being created.
        public let name: String?
        /// Array of participant token configuration objects to attach to the new stage.
        public let participantTokenConfigurations: [ParticipantTokenConfiguration]?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(name: String? = nil, participantTokenConfigurations: [ParticipantTokenConfiguration]? = nil, tags: [String: String]? = nil) {
            self.name = name
            self.participantTokenConfigurations = participantTokenConfigurations
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.participantTokenConfigurations?.forEach {
                try $0.validate(name: "\(name).participantTokenConfigurations[]")
            }
            try self.validate(self.participantTokenConfigurations, name: "participantTokenConfigurations", parent: name, max: 12)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case participantTokenConfigurations = "participantTokenConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateStageResponse: AWSDecodableShape {
        /// Participant tokens attached to the stage. These correspond to the participants in the request.
        public let participantTokens: [ParticipantToken]?
        /// The stage that was created.
        public let stage: Stage?

        public init(participantTokens: [ParticipantToken]? = nil, stage: Stage? = nil) {
            self.participantTokens = participantTokens
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case participantTokens = "participantTokens"
            case stage = "stage"
        }
    }

    public struct DeleteStageRequest: AWSEncodableShape {
        /// ARN of the stage to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteStageResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisconnectParticipantRequest: AWSEncodableShape {
        /// Identifier of the participant to be disconnected. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// Description of why this participant is being disconnected.
        public let reason: String?
        /// ARN of the stage to which the participant is attached.
        public let stageArn: String

        public init(participantId: String, reason: String? = nil, stageArn: String) {
            self.participantId = participantId
            self.reason = reason
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.reason, name: "reason", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case participantId = "participantId"
            case reason = "reason"
            case stageArn = "stageArn"
        }
    }

    public struct DisconnectParticipantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Event: AWSDecodableShape {
        /// If the event is an error event, the error code is provided to give insight into the specific error that occurred. If the event is not an error event, this field is null. INSUFFICIENT_CAPABILITIES indicates that the participant tried to take an action that the participant’s token is not allowed to do. For more information about participant capabilities, see the capabilities field in CreateParticipantToken.
        public let errorCode: EventErrorCode?
        /// ISO 8601 timestamp (returned as a string) for when the event occurred.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var eventTime: Date?
        /// The name of the event.
        public let name: EventName?
        /// Unique identifier for the participant who triggered the event. This is assigned by IVS.
        public let participantId: String?
        /// Unique identifier for the remote participant. For a subscribe event, this is the publisher. For a publish or join event, this is null. This is assigned by IVS.
        public let remoteParticipantId: String?

        public init(errorCode: EventErrorCode? = nil, eventTime: Date? = nil, name: EventName? = nil, participantId: String? = nil, remoteParticipantId: String? = nil) {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.name = name
            self.participantId = participantId
            self.remoteParticipantId = remoteParticipantId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case eventTime = "eventTime"
            case name = "name"
            case participantId = "participantId"
            case remoteParticipantId = "remoteParticipantId"
        }
    }

    public struct GetParticipantRequest: AWSEncodableShape {
        /// Unique identifier for the participant. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// ID of a session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        public init(participantId: String, sessionId: String, stageArn: String) {
            self.participantId = participantId
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case participantId = "participantId"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct GetParticipantResponse: AWSDecodableShape {
        /// The participant that is returned.
        public let participant: Participant?

        public init(participant: Participant? = nil) {
            self.participant = participant
        }

        private enum CodingKeys: String, CodingKey {
            case participant = "participant"
        }
    }

    public struct GetStageRequest: AWSEncodableShape {
        /// ARN of the stage for which the information is to be retrieved.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetStageResponse: AWSDecodableShape {
        /// The stage that is returned.
        public let stage: Stage?

        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }

    public struct GetStageSessionRequest: AWSEncodableShape {
        /// ID of a session within the stage.
        public let sessionId: String
        /// ARN of the stage for which the information is to be retrieved.
        public let stageArn: String

        public init(sessionId: String, stageArn: String) {
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct GetStageSessionResponse: AWSDecodableShape {
        /// The stage session that is returned.
        public let stageSession: StageSession?

        public init(stageSession: StageSession? = nil) {
            self.stageSession = stageSession
        }

        private enum CodingKeys: String, CodingKey {
            case stageSession = "stageSession"
        }
    }

    public struct ListParticipantEventsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// Unique identifier for this participant. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// ID of a session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, participantId: String, sessionId: String, stageArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.participantId = participantId
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case participantId = "participantId"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct ListParticipantEventsResponse: AWSDecodableShape {
        /// List of the matching events.
        public let events: [Event]
        /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        public init(events: [Event], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListParticipantsRequest: AWSEncodableShape {
        /// Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
        public let filterByPublished: Bool?
        /// Filters the response list to only show participants in the specified state. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
        public let filterByState: ParticipantState?
        /// Filters the response list to match the specified user ID. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request. A userId is a customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems.
        public let filterByUserId: String?
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// ID of the session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        public init(filterByPublished: Bool? = nil, filterByState: ParticipantState? = nil, filterByUserId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sessionId: String, stageArn: String) {
            self.filterByPublished = filterByPublished
            self.filterByState = filterByState
            self.filterByUserId = filterByUserId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.filterByUserId, name: "filterByUserId", parent: name, max: 128)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterByPublished = "filterByPublished"
            case filterByState = "filterByState"
            case filterByUserId = "filterByUserId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct ListParticipantsResponse: AWSDecodableShape {
        /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching participants (summary information only).
        public let participants: [ParticipantSummary]

        public init(nextToken: String? = nil, participants: [ParticipantSummary]) {
            self.nextToken = nextToken
            self.participants = participants
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case participants = "participants"
        }
    }

    public struct ListStageSessionsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// Stage ARN.
        public let stageArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, stageArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case stageArn = "stageArn"
        }
    }

    public struct ListStageSessionsResponse: AWSDecodableShape {
        /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of matching stage sessions.
        public let stageSessions: [StageSessionSummary]

        public init(nextToken: String? = nil, stageSessions: [StageSessionSummary]) {
            self.nextToken = nextToken
            self.stageSessions = stageSessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stageSessions = "stageSessions"
        }
    }

    public struct ListStagesRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStagesResponse: AWSDecodableShape {
        /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching stages (summary information only).
        public let stages: [StageSummary]

        public init(nextToken: String? = nil, stages: [StageSummary]) {
            self.nextToken = nextToken
            self.stages = stages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stages = "stages"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Participant: AWSDecodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var firstJoinTime: Date?
        /// Unique identifier for this participant, assigned by IVS.
        public let participantId: String?
        /// Whether the participant ever published to the stage session.
        public let published: Bool?
        /// Whether the participant is connected to or disconnected from the stage.
        public let state: ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, firstJoinTime: Date? = nil, participantId: String? = nil, published: Bool? = nil, state: ParticipantState? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.state = state
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case firstJoinTime = "firstJoinTime"
            case participantId = "participantId"
            case published = "published"
            case state = "state"
            case userId = "userId"
        }
    }

    public struct ParticipantSummary: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var firstJoinTime: Date?
        /// Unique identifier for this participant, assigned by IVS.
        public let participantId: String?
        /// Whether the participant ever published to the stage session.
        public let published: Bool?
        /// Whether the participant is connected to or disconnected from the stage.
        public let state: ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(firstJoinTime: Date? = nil, participantId: String? = nil, published: Bool? = nil, state: ParticipantState? = nil, userId: String? = nil) {
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.state = state
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case firstJoinTime = "firstJoinTime"
            case participantId = "participantId"
            case published = "published"
            case state = "state"
            case userId = "userId"
        }
    }

    public struct ParticipantToken: AWSDecodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default:  720 (12 hours).
        public let duration: Int?
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public let participantId: String?
        /// The issued client token, encrypted.
        public let token: String?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, expirationTime: Date? = nil, participantId: String? = nil, token: String? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case expirationTime = "expirationTime"
            case participantId = "participantId"
            case token = "token"
            case userId = "userId"
        }
    }

    public struct ParticipantTokenConfiguration: AWSEncodableShape {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 720 (12 hours).
        public let duration: Int?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case userId = "userId"
        }
    }

    public struct Stage: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(activeSessionId: String? = nil, arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct StageSession: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ID of the session within the stage.
        public let sessionId: String?
        ///  ISO 8601 timestamp (returned as a string) when this stage session began.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(endTime: Date? = nil, sessionId: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case sessionId = "sessionId"
            case startTime = "startTime"
        }
    }

    public struct StageSessionSummary: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ID of the session within the stage.
        public let sessionId: String?
        ///  ISO 8601 timestamp (returned as a string) when this stage session began.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(endTime: Date? = nil, sessionId: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case sessionId = "sessionId"
            case startTime = "startTime"
        }
    }

    public struct StageSummary: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(activeSessionId: String? = nil, arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStageRequest: AWSEncodableShape {
        /// ARN of the stage to be updated.
        public let arn: String
        /// Name of the stage to be updated.
        public let name: String?

        public init(arn: String, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateStageResponse: AWSDecodableShape {
        /// The updated stage.
        public let stage: Stage?

        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }
}

// MARK: - Errors

/// Error enum for IVSRealTime
public struct IVSRealTimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case pendingVerification = "PendingVerification"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IVSRealTime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    public static var conflictException: Self { .init(.conflictException) }
    public static var internalServerException: Self { .init(.internalServerException) }
    public static var pendingVerification: Self { .init(.pendingVerification) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    public static var validationException: Self { .init(.validationException) }
}

extension IVSRealTimeErrorType: Equatable {
    public static func == (lhs: IVSRealTimeErrorType, rhs: IVSRealTimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IVSRealTimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
