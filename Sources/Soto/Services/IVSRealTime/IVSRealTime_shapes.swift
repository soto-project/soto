//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IVSRealTime {
    // MARK: Enums

    public enum CompositionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case failed = "FAILED"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum DestinationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case failed = "FAILED"
        case reconnecting = "RECONNECTING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum EventErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case insufficientCapabilities = "INSUFFICIENT_CAPABILITIES"
        case publisherNotFound = "PUBLISHER_NOT_FOUND"
        case quotaExceeded = "QUOTA_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum EventName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case joined = "JOINED"
        case joinError = "JOIN_ERROR"
        case left = "LEFT"
        case publishError = "PUBLISH_ERROR"
        case publishStarted = "PUBLISH_STARTED"
        case publishStopped = "PUBLISH_STOPPED"
        case subscribeError = "SUBSCRIBE_ERROR"
        case subscribeStarted = "SUBSCRIBE_STARTED"
        case subscribeStopped = "SUBSCRIBE_STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "CONNECTED"
        case disconnected = "DISCONNECTED"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTokenCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case publish = "PUBLISH"
        case subscribe = "SUBSCRIBE"
        public var description: String { return self.rawValue }
    }

    public enum PipBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `static` = "STATIC"
        case dynamic = "DYNAMIC"
        public var description: String { return self.rawValue }
    }

    public enum PipPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottomLeft = "BOTTOM_LEFT"
        case bottomRight = "BOTTOM_RIGHT"
        case topLeft = "TOP_LEFT"
        case topRight = "TOP_RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum RecordingConfigurationFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hls = "HLS"
        public var description: String { return self.rawValue }
    }

    public enum VideoAspectRatio: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case portrait = "PORTRAIT"
        case square = "SQUARE"
        case video = "VIDEO"
        public var description: String { return self.rawValue }
    }

    public enum VideoFillMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contain = "CONTAIN"
        case cover = "COVER"
        case fill = "FILL"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ChannelDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the channel to use for broadcasting. The channel and stage resources must be in the same AWS account and region. The channel must be offline (not broadcasting).
        public let channelArn: String
        /// ARN of the EncoderConfiguration resource. The encoder configuration and stage resources must be in the same AWS account and region.
        public let encoderConfigurationArn: String?

        public init(channelArn: String, encoderConfigurationArn: String? = nil) {
            self.channelArn = channelArn
            self.encoderConfigurationArn = encoderConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 128)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 1)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
            try self.validate(self.encoderConfigurationArn, name: "encoderConfigurationArn", parent: name, max: 128)
            try self.validate(self.encoderConfigurationArn, name: "encoderConfigurationArn", parent: name, min: 1)
            try self.validate(self.encoderConfigurationArn, name: "encoderConfigurationArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
            case encoderConfigurationArn = "encoderConfigurationArn"
        }
    }

    public struct Composition: AWSDecodableShape {
        /// ARN of the Composition resource.
        public let arn: String
        /// Array of Destination objects. A Composition can contain either one destination
        /// 	        (channel or s3) or two (one channel and one s3).
        public let destinations: [Destination]
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Layout object to configure composition parameters.
        public let layout: LayoutConfiguration
        /// ARN of the stage used as input
        public let stageArn: String
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition.
        public let state: CompositionState
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(arn: String, destinations: [Destination], endTime: Date? = nil, layout: LayoutConfiguration, stageArn: String, startTime: Date? = nil, state: CompositionState, tags: [String: String]? = nil) {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.layout = layout
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinations = "destinations"
            case endTime = "endTime"
            case layout = "layout"
            case stageArn = "stageArn"
            case startTime = "startTime"
            case state = "state"
            case tags = "tags"
        }
    }

    public struct CompositionSummary: AWSDecodableShape {
        /// ARN of the Composition resource.
        public let arn: String
        /// Array of Destination objects.
        public let destinations: [DestinationSummary]
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ARN of the attached stage.
        public let stageArn: String
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition resource.
        public let state: CompositionState
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(arn: String, destinations: [DestinationSummary], endTime: Date? = nil, stageArn: String, startTime: Date? = nil, state: CompositionState, tags: [String: String]? = nil) {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinations = "destinations"
            case endTime = "endTime"
            case stageArn = "stageArn"
            case startTime = "startTime"
            case state = "state"
            case tags = "tags"
        }
    }

    public struct CreateEncoderConfigurationRequest: AWSEncodableShape {
        /// Optional name to identify the resource.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?
        /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps.
        public let video: Video?

        public init(name: String? = nil, tags: [String: String]? = nil, video: Video? = nil) {
            self.name = name
            self.tags = tags
            self.video = video
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.video?.validate(name: "\(name).video")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case tags = "tags"
            case video = "video"
        }
    }

    public struct CreateEncoderConfigurationResponse: AWSDecodableShape {
        /// The EncoderConfiguration that was created.
        public let encoderConfiguration: EncoderConfiguration?

        public init(encoderConfiguration: EncoderConfiguration? = nil) {
            self.encoderConfiguration = encoderConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfiguration = "encoderConfiguration"
        }
    }

    public struct CreateParticipantTokenRequest: AWSEncodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the token expires. Default: 720 (12 hours).
        public let duration: Int?
        /// ARN of the stage to which this token is scoped.
        public let stageArn: String
        /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, stageArn: String, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.stageArn = stageArn
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case stageArn = "stageArn"
            case userId = "userId"
        }
    }

    public struct CreateParticipantTokenResponse: AWSDecodableShape {
        /// The participant token that was created.
        public let participantToken: ParticipantToken?

        public init(participantToken: ParticipantToken? = nil) {
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case participantToken = "participantToken"
        }
    }

    public struct CreateStageRequest: AWSEncodableShape {
        /// Optional name that can be specified for the stage being created.
        public let name: String?
        /// Array of participant token configuration objects to attach to the new stage.
        public let participantTokenConfigurations: [ParticipantTokenConfiguration]?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(name: String? = nil, participantTokenConfigurations: [ParticipantTokenConfiguration]? = nil, tags: [String: String]? = nil) {
            self.name = name
            self.participantTokenConfigurations = participantTokenConfigurations
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.participantTokenConfigurations?.forEach {
                try $0.validate(name: "\(name).participantTokenConfigurations[]")
            }
            try self.validate(self.participantTokenConfigurations, name: "participantTokenConfigurations", parent: name, max: 12)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case participantTokenConfigurations = "participantTokenConfigurations"
            case tags = "tags"
        }
    }

    public struct CreateStageResponse: AWSDecodableShape {
        /// Participant tokens attached to the stage. These correspond to the participants in the request.
        public let participantTokens: [ParticipantToken]?
        /// The stage that was created.
        public let stage: Stage?

        public init(participantTokens: [ParticipantToken]? = nil, stage: Stage? = nil) {
            self.participantTokens = participantTokens
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case participantTokens = "participantTokens"
            case stage = "stage"
        }
    }

    public struct CreateStorageConfigurationRequest: AWSEncodableShape {
        /// Storage configuration name. The value does not need to be unique.
        public let name: String?
        /// A complex type that contains a storage configuration for where recorded video will be stored.
        public let s3: S3StorageConfiguration
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(name: String? = nil, s3: S3StorageConfiguration, tags: [String: String]? = nil) {
            self.name = name
            self.s3 = s3
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.s3.validate(name: "\(name).s3")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case s3 = "s3"
            case tags = "tags"
        }
    }

    public struct CreateStorageConfigurationResponse: AWSDecodableShape {
        /// The StorageConfiguration that was created.
        public let storageConfiguration: StorageConfiguration?

        public init(storageConfiguration: StorageConfiguration? = nil) {
            self.storageConfiguration = storageConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case storageConfiguration = "storageConfiguration"
        }
    }

    public struct DeleteEncoderConfigurationRequest: AWSEncodableShape {
        /// ARN of the EncoderConfiguration.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteEncoderConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStageRequest: AWSEncodableShape {
        /// ARN of the stage to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteStageResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStorageConfigurationRequest: AWSEncodableShape {
        /// ARN of the storage configuration to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:storage-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteStorageConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Destination: AWSDecodableShape {
        /// Configuration used to create this destination.
        public let configuration: DestinationConfiguration
        /// Optional details regarding the status of the destination.
        public let detail: DestinationDetail?
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Unique identifier for this destination, assigned by IVS.
        public let id: String
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition Destination.
        public let state: DestinationState

        public init(configuration: DestinationConfiguration, detail: DestinationDetail? = nil, endTime: Date? = nil, id: String, startTime: Date? = nil, state: DestinationState) {
            self.configuration = configuration
            self.detail = detail
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case detail = "detail"
            case endTime = "endTime"
            case id = "id"
            case startTime = "startTime"
            case state = "state"
        }
    }

    public struct DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An IVS channel to be used for broadcasting, for server-side composition. Either a channel or an
        /// 	  s3 must be specified.
        public let channel: ChannelDestinationConfiguration?
        /// Name that can be specified to help identify the destination.
        public let name: String?
        /// An S3 storage configuration to be used for recording video data. Either a channel
        /// 	  or an s3 must be specified.
        public let s3: S3DestinationConfiguration?

        public init(channel: ChannelDestinationConfiguration? = nil, name: String? = nil, s3: S3DestinationConfiguration? = nil) {
            self.channel = channel
            self.name = name
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.channel?.validate(name: "\(name).channel")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
            case name = "name"
            case s3 = "s3"
        }
    }

    public struct DestinationDetail: AWSDecodableShape {
        /// An S3 detail object to return information about the S3 destination.
        public let s3: S3Detail?

        public init(s3: S3Detail? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct DestinationSummary: AWSDecodableShape {
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Unique identifier for this destination, assigned by IVS.
        public let id: String
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// State of the Composition Destination.
        public let state: DestinationState

        public init(endTime: Date? = nil, id: String, startTime: Date? = nil, state: DestinationState) {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case id = "id"
            case startTime = "startTime"
            case state = "state"
        }
    }

    public struct DisconnectParticipantRequest: AWSEncodableShape {
        /// Identifier of the participant to be disconnected. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// Description of why this participant is being disconnected.
        public let reason: String?
        /// ARN of the stage to which the participant is attached.
        public let stageArn: String

        public init(participantId: String, reason: String? = nil, stageArn: String) {
            self.participantId = participantId
            self.reason = reason
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.reason, name: "reason", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case participantId = "participantId"
            case reason = "reason"
            case stageArn = "stageArn"
        }
    }

    public struct DisconnectParticipantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EncoderConfiguration: AWSDecodableShape {
        /// ARN of the EncoderConfiguration resource.
        public let arn: String
        /// Optional name to identify the resource.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?
        /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        public let video: Video?

        public init(arn: String, name: String? = nil, tags: [String: String]? = nil, video: Video? = nil) {
            self.arn = arn
            self.name = name
            self.tags = tags
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case tags = "tags"
            case video = "video"
        }
    }

    public struct EncoderConfigurationSummary: AWSDecodableShape {
        /// ARN of the EncoderConfiguration resource.
        public let arn: String
        /// Optional name to identify the resource.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct Event: AWSDecodableShape {
        /// If the event is an error event, the error code is provided to give insight into the specific error that occurred. If the event is not an error event, this field is null. INSUFFICIENT_CAPABILITIES indicates that the participant tried to take an action that the participant’s token is not allowed to do. For more information about participant capabilities, see the capabilities field in CreateParticipantToken. QUOTA_EXCEEDED indicates that the number of participants who want to publish/subscribe to a stage exceeds the quota; for more information, see Service Quotas. PUBLISHER_NOT_FOUND indicates that the participant tried to subscribe to a publisher that doesn’t exist.
        public let errorCode: EventErrorCode?
        /// ISO 8601 timestamp (returned as a string) for when the event occurred.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var eventTime: Date?
        /// The name of the event.
        public let name: EventName?
        /// Unique identifier for the participant who triggered the event. This is assigned by IVS.
        public let participantId: String?
        /// Unique identifier for the remote participant. For a subscribe event, this is the publisher. For a publish or join event, this is null. This is assigned by IVS.
        public let remoteParticipantId: String?

        public init(errorCode: EventErrorCode? = nil, eventTime: Date? = nil, name: EventName? = nil, participantId: String? = nil, remoteParticipantId: String? = nil) {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.name = name
            self.participantId = participantId
            self.remoteParticipantId = remoteParticipantId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case eventTime = "eventTime"
            case name = "name"
            case participantId = "participantId"
            case remoteParticipantId = "remoteParticipantId"
        }
    }

    public struct GetCompositionRequest: AWSEncodableShape {
        /// ARN of the Composition resource.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:composition/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetCompositionResponse: AWSDecodableShape {
        /// The Composition that was returned.
        public let composition: Composition?

        public init(composition: Composition? = nil) {
            self.composition = composition
        }

        private enum CodingKeys: String, CodingKey {
            case composition = "composition"
        }
    }

    public struct GetEncoderConfigurationRequest: AWSEncodableShape {
        /// ARN of the EncoderConfiguration resource.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetEncoderConfigurationResponse: AWSDecodableShape {
        /// The EncoderConfiguration that was returned.
        public let encoderConfiguration: EncoderConfiguration?

        public init(encoderConfiguration: EncoderConfiguration? = nil) {
            self.encoderConfiguration = encoderConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfiguration = "encoderConfiguration"
        }
    }

    public struct GetParticipantRequest: AWSEncodableShape {
        /// Unique identifier for the participant. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// ID of a session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        public init(participantId: String, sessionId: String, stageArn: String) {
            self.participantId = participantId
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.participantId, name: "participantId", parent: name, max: 64)
            try self.validate(self.participantId, name: "participantId", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case participantId = "participantId"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct GetParticipantResponse: AWSDecodableShape {
        /// The participant that is returned.
        public let participant: Participant?

        public init(participant: Participant? = nil) {
            self.participant = participant
        }

        private enum CodingKeys: String, CodingKey {
            case participant = "participant"
        }
    }

    public struct GetStageRequest: AWSEncodableShape {
        /// ARN of the stage for which the information is to be retrieved.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetStageResponse: AWSDecodableShape {
        /// The stage that is returned.
        public let stage: Stage?

        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }

    public struct GetStageSessionRequest: AWSEncodableShape {
        /// ID of a session within the stage.
        public let sessionId: String
        /// ARN of the stage for which the information is to be retrieved.
        public let stageArn: String

        public init(sessionId: String, stageArn: String) {
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct GetStageSessionResponse: AWSDecodableShape {
        /// The stage session that is returned.
        public let stageSession: StageSession?

        public init(stageSession: StageSession? = nil) {
            self.stageSession = stageSession
        }

        private enum CodingKeys: String, CodingKey {
            case stageSession = "stageSession"
        }
    }

    public struct GetStorageConfigurationRequest: AWSEncodableShape {
        /// ARN of the storage configuration to be retrieved.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:storage-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetStorageConfigurationResponse: AWSDecodableShape {
        /// The StorageConfiguration that was returned.
        public let storageConfiguration: StorageConfiguration?

        public init(storageConfiguration: StorageConfiguration? = nil) {
            self.storageConfiguration = storageConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case storageConfiguration = "storageConfiguration"
        }
    }

    public struct GridConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in ParticipantTokenConfiguration is placed in the featured slot.
        public let featuredParticipantAttribute: String?
        /// Specifies the spacing between participant tiles in pixels. Default: 2.
        public let gridGap: Int?
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public let omitStoppedVideo: Bool?
        /// Sets the non-featured participant display mode. Default: VIDEO.
        public let videoAspectRatio: VideoAspectRatio?
        /// Defines how video fits within the participant tile. When not set,
        /// 	  videoFillMode defaults to COVER fill mode for participants in the grid
        /// 	  and to CONTAIN fill mode for featured participants.
        public let videoFillMode: VideoFillMode?

        public init(featuredParticipantAttribute: String? = nil, gridGap: Int? = nil, omitStoppedVideo: Bool? = nil, videoAspectRatio: VideoAspectRatio? = nil, videoFillMode: VideoFillMode? = nil) {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.videoAspectRatio = videoAspectRatio
            self.videoFillMode = videoFillMode
        }

        public func validate(name: String) throws {
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, max: 128)
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.gridGap, name: "gridGap", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case featuredParticipantAttribute = "featuredParticipantAttribute"
            case gridGap = "gridGap"
            case omitStoppedVideo = "omitStoppedVideo"
            case videoAspectRatio = "videoAspectRatio"
            case videoFillMode = "videoFillMode"
        }
    }

    public struct LayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration related to grid layout. Default: Grid layout.
        public let grid: GridConfiguration?
        /// Configuration related to PiP layout.
        public let pip: PipConfiguration?

        public init(grid: GridConfiguration? = nil, pip: PipConfiguration? = nil) {
            self.grid = grid
            self.pip = pip
        }

        public func validate(name: String) throws {
            try self.grid?.validate(name: "\(name).grid")
            try self.pip?.validate(name: "\(name).pip")
        }

        private enum CodingKeys: String, CodingKey {
            case grid = "grid"
            case pip = "pip"
        }
    }

    public struct ListCompositionsRequest: AWSEncodableShape {
        /// Filters the Composition list to match the specified EncoderConfiguration attached to at least one of its output.
        public let filterByEncoderConfigurationArn: String?
        /// Filters the Composition list to match the specified Stage ARN.
        public let filterByStageArn: String?
        /// Maximum number of results to return. Default: 100.
        public let maxResults: Int?
        /// The first Composition to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(filterByEncoderConfigurationArn: String? = nil, filterByStageArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filterByEncoderConfigurationArn = filterByEncoderConfigurationArn
            self.filterByStageArn = filterByStageArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.filterByEncoderConfigurationArn, name: "filterByEncoderConfigurationArn", parent: name, max: 128)
            try self.validate(self.filterByEncoderConfigurationArn, name: "filterByEncoderConfigurationArn", parent: name, min: 1)
            try self.validate(self.filterByEncoderConfigurationArn, name: "filterByEncoderConfigurationArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, max: 128)
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, min: 1)
            try self.validate(self.filterByStageArn, name: "filterByStageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterByEncoderConfigurationArn = "filterByEncoderConfigurationArn"
            case filterByStageArn = "filterByStageArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCompositionsResponse: AWSDecodableShape {
        /// List of the matching Compositions (summary information only).
        public let compositions: [CompositionSummary]
        /// If there are more compositions than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        public init(compositions: [CompositionSummary], nextToken: String? = nil) {
            self.compositions = compositions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case compositions = "compositions"
            case nextToken = "nextToken"
        }
    }

    public struct ListEncoderConfigurationsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 100.
        public let maxResults: Int?
        /// The first encoder configuration to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEncoderConfigurationsResponse: AWSDecodableShape {
        /// List of the matching EncoderConfigurations (summary information only).
        public let encoderConfigurations: [EncoderConfigurationSummary]
        /// If there are more encoder configurations than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        public init(encoderConfigurations: [EncoderConfigurationSummary], nextToken: String? = nil) {
            self.encoderConfigurations = encoderConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfigurations = "encoderConfigurations"
            case nextToken = "nextToken"
        }
    }

    public struct ListParticipantEventsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first participant event to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// Unique identifier for this participant. This is assigned by IVS and returned by CreateParticipantToken.
        public let participantId: String
        /// ID of a session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, participantId: String, sessionId: String, stageArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.participantId = participantId
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.participantId, name: "participantId", parent: name, max: 64)
            try self.validate(self.participantId, name: "participantId", parent: name, pattern: "^[a-zA-Z0-9-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case participantId = "participantId"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct ListParticipantEventsResponse: AWSDecodableShape {
        /// List of the matching events.
        public let events: [Event]
        /// If there are more events than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        public init(events: [Event], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListParticipantsRequest: AWSEncodableShape {
        /// Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
        public let filterByPublished: Bool?
        /// Filters the response list to only show participants in the specified state. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
        public let filterByState: ParticipantState?
        /// Filters the response list to match the specified user ID. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request. A userId is a customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems.
        public let filterByUserId: String?
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// ID of the session within the stage.
        public let sessionId: String
        /// Stage ARN.
        public let stageArn: String

        public init(filterByPublished: Bool? = nil, filterByState: ParticipantState? = nil, filterByUserId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sessionId: String, stageArn: String) {
            self.filterByPublished = filterByPublished
            self.filterByState = filterByState
            self.filterByUserId = filterByUserId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sessionId = sessionId
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.filterByUserId, name: "filterByUserId", parent: name, max: 128)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 16)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^st-[a-zA-Z0-9]+$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filterByPublished = "filterByPublished"
            case filterByState = "filterByState"
            case filterByUserId = "filterByUserId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sessionId = "sessionId"
            case stageArn = "stageArn"
        }
    }

    public struct ListParticipantsResponse: AWSDecodableShape {
        /// If there are more participants than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching participants (summary information only).
        public let participants: [ParticipantSummary]

        public init(nextToken: String? = nil, participants: [ParticipantSummary]) {
            self.nextToken = nextToken
            self.participants = participants
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case participants = "participants"
        }
    }

    public struct ListStageSessionsRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first stage session to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// Stage ARN.
        public let stageArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, stageArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stageArn = stageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case stageArn = "stageArn"
        }
    }

    public struct ListStageSessionsResponse: AWSDecodableShape {
        /// If there are more stage sessions than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of matching stage sessions.
        public let stageSessions: [StageSessionSummary]

        public init(nextToken: String? = nil, stageSessions: [StageSessionSummary]) {
            self.nextToken = nextToken
            self.stageSessions = stageSessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stageSessions = "stageSessions"
        }
    }

    public struct ListStagesRequest: AWSEncodableShape {
        /// Maximum number of results to return. Default: 50.
        public let maxResults: Int?
        /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStagesResponse: AWSDecodableShape {
        /// If there are more stages than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching stages (summary information only).
        public let stages: [StageSummary]

        public init(nextToken: String? = nil, stages: [StageSummary]) {
            self.nextToken = nextToken
            self.stages = stages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stages = "stages"
        }
    }

    public struct ListStorageConfigurationsRequest: AWSEncodableShape {
        /// Maximum number of storage configurations to return. Default: your service quota or 100,
        /// 	  whichever is smaller.
        public let maxResults: Int?
        /// The first storage configuration to retrieve. This is used for pagination;
        /// 	  see the nextToken response field.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9+/=_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStorageConfigurationsResponse: AWSDecodableShape {
        /// If there are more storage configurations than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of the matching storage configurations.
        public let storageConfigurations: [StorageConfigurationSummary]

        public init(nextToken: String? = nil, storageConfigurations: [StorageConfigurationSummary]) {
            self.nextToken = nextToken
            self.storageConfigurations = storageConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case storageConfigurations = "storageConfigurations"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Participant: AWSDecodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// The participant’s browser.
        public let browserName: String?
        /// The participant’s browser version.
        public let browserVersion: String?
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var firstJoinTime: Date?
        /// The participant’s Internet Service Provider.
        public let ispName: String?
        /// The participant’s operating system.
        public let osName: String?
        /// The participant’s operating system version.
        public let osVersion: String?
        /// Unique identifier for this participant, assigned by IVS.
        public let participantId: String?
        /// Whether the participant ever published to the stage session.
        public let published: Bool?
        /// The participant’s SDK version.
        public let sdkVersion: String?
        /// Whether the participant is connected to or disconnected from the stage.
        public let state: ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, browserName: String? = nil, browserVersion: String? = nil, firstJoinTime: Date? = nil, ispName: String? = nil, osName: String? = nil, osVersion: String? = nil, participantId: String? = nil, published: Bool? = nil, sdkVersion: String? = nil, state: ParticipantState? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.browserName = browserName
            self.browserVersion = browserVersion
            self.firstJoinTime = firstJoinTime
            self.ispName = ispName
            self.osName = osName
            self.osVersion = osVersion
            self.participantId = participantId
            self.published = published
            self.sdkVersion = sdkVersion
            self.state = state
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case browserName = "browserName"
            case browserVersion = "browserVersion"
            case firstJoinTime = "firstJoinTime"
            case ispName = "ispName"
            case osName = "osName"
            case osVersion = "osVersion"
            case participantId = "participantId"
            case published = "published"
            case sdkVersion = "sdkVersion"
            case state = "state"
            case userId = "userId"
        }
    }

    public struct ParticipantSummary: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var firstJoinTime: Date?
        /// Unique identifier for this participant, assigned by IVS.
        public let participantId: String?
        /// Whether the participant ever published to the stage session.
        public let published: Bool?
        /// Whether the participant is connected to or disconnected from the stage.
        public let state: ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(firstJoinTime: Date? = nil, participantId: String? = nil, published: Bool? = nil, state: ParticipantState? = nil, userId: String? = nil) {
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.state = state
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case firstJoinTime = "firstJoinTime"
            case participantId = "participantId"
            case published = "published"
            case state = "state"
            case userId = "userId"
        }
    }

    public struct ParticipantToken: AWSDecodableShape {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default: 720 (12 hours).
        public let duration: Int?
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public let participantId: String?
        /// The issued client token, encrypted.
        public let token: String?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, expirationTime: Date? = nil, participantId: String? = nil, token: String? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case expirationTime = "expirationTime"
            case participantId = "participantId"
            case token = "token"
            case userId = "userId"
        }
    }

    public struct ParticipantTokenConfiguration: AWSEncodableShape {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let attributes: [String: String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public let capabilities: [ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 720 (12 hours).
        public let duration: Int?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public let userId: String?

        public init(attributes: [String: String]? = nil, capabilities: [ParticipantTokenCapability]? = nil, duration: Int? = nil, userId: String? = nil) {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 2)
            try self.validate(self.duration, name: "duration", parent: name, max: 20160)
            try self.validate(self.duration, name: "duration", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case capabilities = "capabilities"
            case duration = "duration"
            case userId = "userId"
        }
    }

    public struct PipConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in ParticipantTokenConfiguration is placed in the featured slot.
        public let featuredParticipantAttribute: String?
        /// Specifies the spacing between participant tiles in pixels. Default: 0.
        public let gridGap: Int?
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public let omitStoppedVideo: Bool?
        /// Defines PiP behavior when all participants have left. Default: STATIC.
        public let pipBehavior: PipBehavior?
        /// Specifies the height of the PiP window in pixels. When this is not set explicitly,
        /// 	        pipHeight’s value will be based on the size of the composition and the
        /// 			aspect ratio of the participant’s video.
        public let pipHeight: Int?
        /// Sets the PiP window’s offset position in pixels from the closest edges determined by PipPosition.
        /// 	  Default: 0.
        public let pipOffset: Int?
        /// Identifies the PiP slot. A participant with this attribute set to "true" (as a string value) in ParticipantTokenConfiguration
        /// 		 is placed in the PiP slot.
        public let pipParticipantAttribute: String?
        /// Determines the corner position of the PiP window. Default: BOTTOM_RIGHT.
        public let pipPosition: PipPosition?
        /// Specifies the width of the PiP window in pixels. When this is not set explicitly,
        /// 	        pipWidth’s value will be based on the size of the composition and the
        /// 			aspect ratio of the participant’s video.
        public let pipWidth: Int?
        /// Defines how video fits within the participant tile. Default: COVER.
        public let videoFillMode: VideoFillMode?

        public init(featuredParticipantAttribute: String? = nil, gridGap: Int? = nil, omitStoppedVideo: Bool? = nil, pipBehavior: PipBehavior? = nil, pipHeight: Int? = nil, pipOffset: Int? = nil, pipParticipantAttribute: String? = nil, pipPosition: PipPosition? = nil, pipWidth: Int? = nil, videoFillMode: VideoFillMode? = nil) {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.pipBehavior = pipBehavior
            self.pipHeight = pipHeight
            self.pipOffset = pipOffset
            self.pipParticipantAttribute = pipParticipantAttribute
            self.pipPosition = pipPosition
            self.pipWidth = pipWidth
            self.videoFillMode = videoFillMode
        }

        public func validate(name: String) throws {
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, max: 128)
            try self.validate(self.featuredParticipantAttribute, name: "featuredParticipantAttribute", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.gridGap, name: "gridGap", parent: name, min: 0)
            try self.validate(self.pipHeight, name: "pipHeight", parent: name, min: 1)
            try self.validate(self.pipOffset, name: "pipOffset", parent: name, min: 0)
            try self.validate(self.pipParticipantAttribute, name: "pipParticipantAttribute", parent: name, max: 128)
            try self.validate(self.pipParticipantAttribute, name: "pipParticipantAttribute", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.validate(self.pipWidth, name: "pipWidth", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case featuredParticipantAttribute = "featuredParticipantAttribute"
            case gridGap = "gridGap"
            case omitStoppedVideo = "omitStoppedVideo"
            case pipBehavior = "pipBehavior"
            case pipHeight = "pipHeight"
            case pipOffset = "pipOffset"
            case pipParticipantAttribute = "pipParticipantAttribute"
            case pipPosition = "pipPosition"
            case pipWidth = "pipWidth"
            case videoFillMode = "videoFillMode"
        }
    }

    public struct RecordingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The recording format for storing a recording in Amazon S3.
        public let format: RecordingConfigurationFormat?

        public init(format: RecordingConfigurationFormat? = nil) {
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
        }
    }

    public struct S3DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// ARNs of the EncoderConfiguration resource. The encoder configuration and stage resources
        /// 	  must be in the same AWS account and region.
        public let encoderConfigurationArns: [String]
        /// Array of maps, each of the form string:string (key:value).
        /// 	  This is an optional customer specification, currently used only to specify
        /// 	  the recording format for storing a recording in Amazon S3.
        public let recordingConfiguration: RecordingConfiguration?
        /// ARN of the StorageConfiguration where recorded videos will be stored.
        public let storageConfigurationArn: String

        public init(encoderConfigurationArns: [String], recordingConfiguration: RecordingConfiguration? = nil, storageConfigurationArn: String) {
            self.encoderConfigurationArns = encoderConfigurationArns
            self.recordingConfiguration = recordingConfiguration
            self.storageConfigurationArn = storageConfigurationArn
        }

        public func validate(name: String) throws {
            try self.encoderConfigurationArns.forEach {
                try validate($0, name: "encoderConfigurationArns[]", parent: name, max: 128)
                try validate($0, name: "encoderConfigurationArns[]", parent: name, min: 1)
                try validate($0, name: "encoderConfigurationArns[]", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:encoder-configuration/[a-zA-Z0-9-]+$")
            }
            try self.validate(self.encoderConfigurationArns, name: "encoderConfigurationArns", parent: name, max: 1)
            try self.validate(self.encoderConfigurationArns, name: "encoderConfigurationArns", parent: name, min: 1)
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, max: 128)
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, min: 1)
            try self.validate(self.storageConfigurationArn, name: "storageConfigurationArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:storage-configuration/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case encoderConfigurationArns = "encoderConfigurationArns"
            case recordingConfiguration = "recordingConfiguration"
            case storageConfigurationArn = "storageConfigurationArn"
        }
    }

    public struct S3Detail: AWSDecodableShape {
        /// The S3 bucket prefix under which the recording is stored.
        public let recordingPrefix: String

        public init(recordingPrefix: String) {
            self.recordingPrefix = recordingPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case recordingPrefix = "recordingPrefix"
        }
    }

    public struct S3StorageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Location (S3 bucket name) where recorded videos will be stored.  Note that the StorageConfiguration
        /// 	  and S3 bucket must be in the same region as the Composition.
        public let bucketName: String

        public init(bucketName: String) {
            self.bucketName = bucketName
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[a-z0-9-.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
        }
    }

    public struct Stage: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(activeSessionId: String? = nil, arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct StageSession: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ID of the session within the stage.
        public let sessionId: String?
        ///  ISO 8601 timestamp (returned as a string) when this stage session began.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(endTime: Date? = nil, sessionId: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case sessionId = "sessionId"
            case startTime = "startTime"
        }
    }

    public struct StageSessionSummary: AWSDecodableShape {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ID of the session within the stage.
        public let sessionId: String?
        ///  ISO 8601 timestamp (returned as a string) when this stage session began.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(endTime: Date? = nil, sessionId: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case sessionId = "sessionId"
            case startTime = "startTime"
        }
    }

    public struct StageSummary: AWSDecodableShape {
        /// ID of the active session within the stage.
        public let activeSessionId: String?
        /// Stage ARN.
        public let arn: String
        /// Stage name.
        public let name: String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(activeSessionId: String? = nil, arn: String, name: String? = nil, tags: [String: String]? = nil) {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeSessionId = "activeSessionId"
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct StartCompositionRequest: AWSEncodableShape {
        /// Array of destination configuration.
        public let destinations: [DestinationConfiguration]
        /// Idempotency token.
        public let idempotencyToken: String?
        /// Layout object to configure composition parameters.
        public let layout: LayoutConfiguration?
        /// ARN of the stage to be used for compositing.
        public let stageArn: String
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(destinations: [DestinationConfiguration], idempotencyToken: String? = StartCompositionRequest.idempotencyToken(), layout: LayoutConfiguration? = nil, stageArn: String, tags: [String: String]? = nil) {
            self.destinations = destinations
            self.idempotencyToken = idempotencyToken
            self.layout = layout
            self.stageArn = stageArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.destinations, name: "destinations", parent: name, max: 2)
            try self.validate(self.destinations, name: "destinations", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 64)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.layout?.validate(name: "\(name).layout")
            try self.validate(self.stageArn, name: "stageArn", parent: name, max: 128)
            try self.validate(self.stageArn, name: "stageArn", parent: name, min: 1)
            try self.validate(self.stageArn, name: "stageArn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
            case idempotencyToken = "idempotencyToken"
            case layout = "layout"
            case stageArn = "stageArn"
            case tags = "tags"
        }
    }

    public struct StartCompositionResponse: AWSDecodableShape {
        /// The Composition that was created.
        public let composition: Composition?

        public init(composition: Composition? = nil) {
            self.composition = composition
        }

        private enum CodingKeys: String, CodingKey {
            case composition = "composition"
        }
    }

    public struct StopCompositionRequest: AWSEncodableShape {
        /// ARN of the Composition.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:composition/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct StopCompositionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StorageConfiguration: AWSDecodableShape {
        /// ARN of the storage configuration.
        public let arn: String
        /// Name of the storage configuration.
        public let name: String?
        /// An S3 destination configuration where recorded videos will be stored.
        public let s3: S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(arn: String, name: String? = nil, s3: S3StorageConfiguration? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case s3 = "s3"
            case tags = "tags"
        }
    }

    public struct StorageConfigurationSummary: AWSDecodableShape {
        /// ARN of the storage configuration.
        public let arn: String
        /// Name of the storage configuration.
        public let name: String?
        /// An S3 destination configuration where recorded videos will be stored.
        public let s3: S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public let tags: [String: String]?

        public init(arn: String, name: String? = nil, s3: S3StorageConfiguration? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case s3 = "s3"
            case tags = "tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
        public let resourceArn: String
        /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See Tagging AWS Resources for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStageRequest: AWSEncodableShape {
        /// ARN of the stage to be updated.
        public let arn: String
        /// Name of the stage to be updated.
        public let name: String?

        public init(arn: String, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:ivs:[a-z0-9-]+:[0-9]+:stage/[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateStageResponse: AWSDecodableShape {
        /// The updated stage.
        public let stage: Stage?

        public init(stage: Stage? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
        }
    }

    public struct Video: AWSEncodableShape & AWSDecodableShape {
        /// Bitrate for generated output, in bps. Default: 2500000.
        public let bitrate: Int?
        /// Video frame rate, in fps. Default: 30.
        public let framerate: Float?
        /// Video-resolution height. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        public let height: Int?
        /// Video-resolution width. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        public let width: Int?

        public init(bitrate: Int? = nil, framerate: Float? = nil, height: Int? = nil, width: Int? = nil) {
            self.bitrate = bitrate
            self.framerate = framerate
            self.height = height
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.bitrate, name: "bitrate", parent: name, max: 8500000)
            try self.validate(self.bitrate, name: "bitrate", parent: name, min: 1)
            try self.validate(self.framerate, name: "framerate", parent: name, max: 60.0)
            try self.validate(self.framerate, name: "framerate", parent: name, min: 1.0)
            try self.validate(self.height, name: "height", parent: name, max: 1920)
            try self.validate(self.height, name: "height", parent: name, min: 1)
            try self.validate(self.width, name: "width", parent: name, max: 1920)
            try self.validate(self.width, name: "width", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bitrate = "bitrate"
            case framerate = "framerate"
            case height = "height"
            case width = "width"
        }
    }
}

// MARK: - Errors

/// Error enum for IVSRealTime
public struct IVSRealTimeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case pendingVerification = "PendingVerification"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IVSRealTime
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    public static var conflictException: Self { .init(.conflictException) }
    public static var internalServerException: Self { .init(.internalServerException) }
    public static var pendingVerification: Self { .init(.pendingVerification) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    public static var validationException: Self { .init(.validationException) }
}

extension IVSRealTimeErrorType: Equatable {
    public static func == (lhs: IVSRealTimeErrorType, rhs: IVSRealTimeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IVSRealTimeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
