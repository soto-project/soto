//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Imagebuilder {
    // MARK: Enums

    public enum ComponentFormat: String, CustomStringConvertible, Codable {
        case shell = "SHELL"
        public var description: String { return self.rawValue }
    }

    public enum ComponentType: String, CustomStringConvertible, Codable {
        case build = "BUILD"
        case test = "TEST"
        public var description: String { return self.rawValue }
    }

    public enum ContainerRepositoryService: String, CustomStringConvertible, Codable {
        case ecr = "ECR"
        public var description: String { return self.rawValue }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable {
        case docker = "DOCKER"
        public var description: String { return self.rawValue }
    }

    public enum EbsVolumeType: String, CustomStringConvertible, Codable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        public var description: String { return self.rawValue }
    }

    public enum ImageStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case building = "BUILDING"
        case cancelled = "CANCELLED"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deprecated = "DEPRECATED"
        case distributing = "DISTRIBUTING"
        case failed = "FAILED"
        case integrating = "INTEGRATING"
        case pending = "PENDING"
        case testing = "TESTING"
        public var description: String { return self.rawValue }
    }

    public enum ImageType: String, CustomStringConvertible, Codable {
        case ami = "AMI"
        case docker = "DOCKER"
        public var description: String { return self.rawValue }
    }

    public enum Ownership: String, CustomStringConvertible, Codable {
        case amazon = "Amazon"
        case `self` = "Self"
        case shared = "Shared"
        public var description: String { return self.rawValue }
    }

    public enum PipelineExecutionStartCondition: String, CustomStringConvertible, Codable {
        case expressionMatchAndDependencyUpdatesAvailable = "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
        case expressionMatchOnly = "EXPRESSION_MATCH_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum PipelineStatus: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Platform: String, CustomStringConvertible, Codable {
        case linux = "Linux"
        case windows = "Windows"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AdditionalInstanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains settings for the SSM agent on your build instance.
        public let systemsManagerAgent: SystemsManagerAgent?
        /// Use this property to provide commands or a command script to run when you launch your build instance.  The userDataOverride property replaces any commands that Image Builder might have added to ensure that SSM is installed on your Linux build instance. If you override the user data, make sure that you add commands to install SSM, if it is not pre-installed on your source image.
        public let userDataOverride: String?

        public init(systemsManagerAgent: SystemsManagerAgent? = nil, userDataOverride: String? = nil) {
            self.systemsManagerAgent = systemsManagerAgent
            self.userDataOverride = userDataOverride
        }

        public func validate(name: String) throws {
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, max: 21847)
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, min: 1)
            try self.validate(self.userDataOverride, name: "userDataOverride", parent: name, pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case systemsManagerAgent
            case userDataOverride
        }
    }

    public struct Ami: AWSDecodableShape {
        /// The account ID of the owner of the AMI.
        public let accountId: String?
        /// The description of the Amazon EC2 AMI. Minimum and maximum length are in characters.
        public let description: String?
        /// The AMI ID of the Amazon EC2 AMI.
        public let image: String?
        /// The name of the Amazon EC2 AMI.
        public let name: String?
        /// The Region of the Amazon EC2 AMI.
        public let region: String?
        public let state: ImageState?

        public init(accountId: String? = nil, description: String? = nil, image: String? = nil, name: String? = nil, region: String? = nil, state: ImageState? = nil) {
            self.accountId = accountId
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case description
            case image
            case name
            case region
            case state
        }
    }

    public struct AmiDistributionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The tags to apply to AMIs distributed to this Region.
        public let amiTags: [String: String]?
        /// The description of the distribution configuration. Minimum and maximum length are in characters.
        public let description: String?
        /// The KMS key identifier used to encrypt the distributed image.
        public let kmsKeyId: String?
        ///  Launch permissions can be used to configure which accounts can use the AMI to launch instances.
        public let launchPermission: LaunchPermissionConfiguration?
        /// The name of the distribution configuration.
        public let name: String?
        /// The ID of an account to which you want to distribute an image.
        public let targetAccountIds: [String]?

        public init(amiTags: [String: String]? = nil, description: String? = nil, kmsKeyId: String? = nil, launchPermission: LaunchPermissionConfiguration? = nil, name: String? = nil, targetAccountIds: [String]? = nil) {
            self.amiTags = amiTags
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.launchPermission = launchPermission
            self.name = name
            self.targetAccountIds = targetAccountIds
        }

        public func validate(name: String) throws {
            try self.amiTags?.forEach {
                try validate($0.key, name: "amiTags.key", parent: name, max: 128)
                try validate($0.key, name: "amiTags.key", parent: name, min: 1)
                try validate($0.key, name: "amiTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "amiTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.launchPermission?.validate(name: "\(name).launchPermission")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z0-9{][-_A-Za-z0-9\\s:{}\\.]+[-_A-Za-z0-9}]$")
            try self.targetAccountIds?.forEach {
                try validate($0, name: "targetAccountIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.targetAccountIds, name: "targetAccountIds", parent: name, max: 1536)
            try self.validate(self.targetAccountIds, name: "targetAccountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amiTags
            case description
            case kmsKeyId
            case launchPermission
            case name
            case targetAccountIds
        }
    }

    public struct CancelImageCreationRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image whose creation you want to cancel.
        public let imageBuildVersionArn: String

        public init(clientToken: String = CancelImageCreationRequest.idempotencyToken(), imageBuildVersionArn: String) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
        }
    }

    public struct CancelImageCreationResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image whose creation has been cancelled.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct Component: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The change description of the component.
        public let changeDescription: String?
        /// The data of the component.
        public let data: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The encryption status of the component.
        public let encrypted: Bool?
        /// The KMS key identifier used to encrypt the component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// Contains parameter details for each of the parameters that are defined for the component.
        public let parameters: [ComponentParameterDetail]?
        /// The platform of the component.
        public let platform: Platform?
        /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation.
        public let supportedOsVersions: [String]?
        /// The tags associated with the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public let type: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, data: String? = nil, dateCreated: String? = nil, description: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, name: String? = nil, owner: String? = nil, parameters: [ComponentParameterDetail]? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case changeDescription
            case data
            case dateCreated
            case description
            case encrypted
            case kmsKeyId
            case name
            case owner
            case parameters
            case platform
            case supportedOsVersions
            case tags
            case type
            case version
        }
    }

    public struct ComponentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let componentArn: String
        /// A group of parameter settings that are used to configure the component for a specific recipe.
        public let parameters: [ComponentParameter]?

        public init(componentArn: String, parameters: [ComponentParameter]? = nil) {
            self.componentArn = componentArn
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
            try self.parameters?.forEach {
                try $0.validate(name: "\(name).parameters[]")
            }
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn
            case parameters
        }
    }

    public struct ComponentParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of the component parameter to set.
        public let name: String
        /// Sets the value for the named component parameter.
        public let value: [String]

        public init(name: String, value: [String]) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\x00]+")
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, min: 1)
                try validate($0, name: "value[]", parent: name, pattern: "[^\\x00]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct ComponentParameterDetail: AWSDecodableShape {
        /// The default value of this parameter if no input is provided.
        public let defaultValue: [String]?
        /// Describes this parameter.
        public let description: String?
        /// The name of this input parameter.
        public let name: String
        /// The type of input this parameter provides. The currently supported value is "string".
        public let type: String

        public init(defaultValue: [String]? = nil, description: String? = nil, name: String, type: String) {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue
            case description
            case name
            case type
        }
    }

    public struct ComponentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The change description of the component.
        public let changeDescription: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation.
        public let supportedOsVersions: [String]?
        /// The tags associated with the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public let type: ComponentType?
        /// The version of the component.
        public let version: String?

        public init(arn: String? = nil, changeDescription: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case changeDescription
            case dateCreated
            case description
            case name
            case owner
            case platform
            case supportedOsVersions
            case tags
            case type
            case version
        }
    }

    public struct ComponentVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component.
        public let arn: String?
        /// The date that the component was created.
        public let dateCreated: String?
        /// The description of the component.
        public let description: String?
        /// The name of the component.
        public let name: String?
        /// The owner of the component.
        public let owner: String?
        /// The platform of the component.
        public let platform: Platform?
        /// he operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation.
        public let supportedOsVersions: [String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public let type: ComponentType?
        /// The semantic version of the component.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, platform: Platform? = nil, supportedOsVersions: [String]? = nil, type: ComponentType? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case description
            case name
            case owner
            case platform
            case supportedOsVersions
            case type
            case version
        }
    }

    public struct Container: AWSDecodableShape {
        /// A list of URIs for containers created in the context Region.
        public let imageUris: [String]?
        /// Containers and container images are Region-specific. This is the Region context for the container.
        public let region: String?

        public init(imageUris: [String]? = nil, region: String? = nil) {
            self.imageUris = imageUris
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case imageUris
            case region
        }
    }

    public struct ContainerDistributionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Tags that are attached to the container distribution configuration.
        public let containerTags: [String]?
        /// The description of the container distribution configuration.
        public let description: String?
        /// The destination repository for the container distribution configuration.
        public let targetRepository: TargetContainerRepository

        public init(containerTags: [String]? = nil, description: String? = nil, targetRepository: TargetContainerRepository) {
            self.containerTags = containerTags
            self.description = description
            self.targetRepository = targetRepository
        }

        public func validate(name: String) throws {
            try self.containerTags?.forEach {
                try validate($0, name: "containerTags[]", parent: name, max: 1024)
                try validate($0, name: "containerTags[]", parent: name, min: 1)
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.targetRepository.validate(name: "\(name).targetRepository")
        }

        private enum CodingKeys: String, CodingKey {
            case containerTags
            case description
            case targetRepository
        }
    }

    public struct ContainerRecipe: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public let arn: String?
        /// Components for build and test that are included in the container recipe.
        public let components: [ComponentConfiguration]?
        /// Specifies the type of container, such as Docker.
        public let containerType: ContainerType?
        /// The date when this container recipe was created.
        public let dateCreated: String?
        /// The description of the container recipe.
        public let description: String?
        /// Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
        public let dockerfileTemplateData: String?
        /// A flag that indicates if the target container is encrypted.
        public let encrypted: Bool?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public let instanceConfiguration: InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image for distribution to the target Region.
        public let kmsKeyId: String?
        /// The name of the container recipe.
        public let name: String?
        /// The owner of the container recipe.
        public let owner: String?
        /// The source image for the container recipe.
        public let parentImage: String?
        /// The system platform for the container, such as Windows or Linux.
        public let platform: Platform?
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?
        /// The destination repository for the container image.
        public let targetRepository: TargetContainerRepository?
        /// The semantic version of the container recipe (&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;).
        public let version: String?
        /// The working directory for use during build and test workflows.
        public let workingDirectory: String?

        public init(arn: String? = nil, components: [ComponentConfiguration]? = nil, containerType: ContainerType? = nil, dateCreated: String? = nil, description: String? = nil, dockerfileTemplateData: String? = nil, encrypted: Bool? = nil, instanceConfiguration: InstanceConfiguration? = nil, kmsKeyId: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil, targetRepository: TargetContainerRepository? = nil, version: String? = nil, workingDirectory: String? = nil) {
            self.arn = arn
            self.components = components
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.encrypted = encrypted
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.targetRepository = targetRepository
            self.version = version
            self.workingDirectory = workingDirectory
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case components
            case containerType
            case dateCreated
            case description
            case dockerfileTemplateData
            case encrypted
            case instanceConfiguration
            case kmsKeyId
            case name
            case owner
            case parentImage
            case platform
            case tags
            case targetRepository
            case version
            case workingDirectory
        }
    }

    public struct ContainerRecipeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public let arn: String?
        /// Specifies the type of container, such as "Docker".
        public let containerType: ContainerType?
        /// The date when this container recipe was created.
        public let dateCreated: String?
        /// The name of the container recipe.
        public let name: String?
        /// The owner of the container recipe.
        public let owner: String?
        /// The source image for the container recipe.
        public let parentImage: String?
        /// The system platform for the container, such as Windows or Linux.
        public let platform: Platform?
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?

        public init(arn: String? = nil, containerType: ContainerType? = nil, dateCreated: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case containerType
            case dateCreated
            case name
            case owner
            case parentImage
            case platform
            case tags
        }
    }

    public struct CreateComponentRequest: AWSEncodableShape {
        /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.
        public let changeDescription: String?
        /// The idempotency token of the component.
        public let clientToken: String
        /// The data of the component. Used to specify the data inline. Either data or uri can be used to specify the data within the component.
        public let data: String?
        /// The description of the component. Describes the contents of the component.
        public let description: String?
        /// The ID of the KMS key that should be used to encrypt this component.
        public let kmsKeyId: String?
        /// The name of the component.
        public let name: String
        /// The platform of the component.
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version syntax. For example, major.minor.patch. This could be versioned like software (2.0.1) or like a date (2019.12.01).
        public let semanticVersion: String
        ///  The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the parent image OS version during image recipe creation.
        public let supportedOsVersions: [String]?
        /// The tags of the component.
        public let tags: [String: String]?
        /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either data or uri can be used to specify the data within the component.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = CreateComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, supportedOsVersions: [String]? = nil, tags: [String: String]? = nil, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, max: 16000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, pattern: "[^\\x00]+")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.supportedOsVersions?.forEach {
                try validate($0, name: "supportedOsVersions[]", parent: name, min: 1)
            }
            try self.validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, max: 25)
            try self.validate(self.supportedOsVersions, name: "supportedOsVersions", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription
            case clientToken
            case data
            case description
            case kmsKeyId
            case name
            case platform
            case semanticVersion
            case supportedOsVersions
            case tags
            case uri
        }
    }

    public struct CreateComponentResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the component that was created by this request.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case componentBuildVersionArn
            case requestId
        }
    }

    public struct CreateContainerRecipeRequest: AWSEncodableShape {
        /// The client token used to make this request idempotent.
        public let clientToken: String
        /// Components for build and test that are included in the container recipe.
        public let components: [ComponentConfiguration]
        /// The type of container to create.
        public let containerType: ContainerType
        /// The description of the container recipe.
        public let description: String?
        /// The Dockerfile template used to build your image as an inline data blob.
        public let dockerfileTemplateData: String?
        /// The Amazon S3 URI for the Dockerfile that will be used to build your container image.
        public let dockerfileTemplateUri: String?
        /// Specifies the operating system version for the source image.
        public let imageOsVersionOverride: String?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public let instanceConfiguration: InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image.
        public let kmsKeyId: String?
        /// The name of the container recipe.
        public let name: String
        /// The source image for the container recipe.
        public let parentImage: String
        /// Specifies the operating system platform when you use a custom source image.
        public let platformOverride: Platform?
        /// The semantic version of the container recipe (&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;).
        public let semanticVersion: String
        /// Tags that are attached to the container recipe.
        public let tags: [String: String]?
        /// The destination repository for the container image.
        public let targetRepository: TargetContainerRepository
        /// The working directory for use during build and test workflows.
        public let workingDirectory: String?

        public init(clientToken: String = CreateContainerRecipeRequest.idempotencyToken(), components: [ComponentConfiguration], containerType: ContainerType, description: String? = nil, dockerfileTemplateData: String? = nil, dockerfileTemplateUri: String? = nil, imageOsVersionOverride: String? = nil, instanceConfiguration: InstanceConfiguration? = nil, kmsKeyId: String? = nil, name: String, parentImage: String, platformOverride: Platform? = nil, semanticVersion: String, tags: [String: String]? = nil, targetRepository: TargetContainerRepository, workingDirectory: String? = nil) {
            self.clientToken = clientToken
            self.components = components
            self.containerType = containerType
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.dockerfileTemplateUri = dockerfileTemplateUri
            self.imageOsVersionOverride = imageOsVersionOverride
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.parentImage = parentImage
            self.platformOverride = platformOverride
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.targetRepository = targetRepository
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.components.forEach {
                try $0.validate(name: "\(name).components[]")
            }
            try self.validate(self.components, name: "components", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, max: 16000)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, min: 1)
            try self.validate(self.dockerfileTemplateData, name: "dockerfileTemplateData", parent: name, pattern: "[^\\x00]+")
            try self.validate(self.imageOsVersionOverride, name: "imageOsVersionOverride", parent: name, max: 1024)
            try self.validate(self.imageOsVersionOverride, name: "imageOsVersionOverride", parent: name, min: 1)
            try self.instanceConfiguration?.validate(name: "\(name).instanceConfiguration")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.parentImage, name: "parentImage", parent: name, max: 1024)
            try self.validate(self.parentImage, name: "parentImage", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.targetRepository.validate(name: "\(name).targetRepository")
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1024)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case components
            case containerType
            case description
            case dockerfileTemplateData
            case dockerfileTemplateUri
            case imageOsVersionOverride
            case instanceConfiguration
            case kmsKeyId
            case name
            case parentImage
            case platformOverride
            case semanticVersion
            case tags
            case targetRepository
            case workingDirectory
        }
    }

    public struct CreateContainerRecipeResponse: AWSDecodableShape {
        /// The client token used to make this request idempotent.
        public let clientToken: String?
        /// Returns the Amazon Resource Name (ARN) of the container recipe that the request created.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case requestId
        }
    }

    public struct CreateDistributionConfigurationRequest: AWSEncodableShape {
        ///  The idempotency token of the distribution configuration.
        public let clientToken: String
        ///  The description of the distribution configuration.
        public let description: String?
        ///  The distributions of the distribution configuration.
        public let distributions: [Distribution]
        ///  The name of the distribution configuration.
        public let name: String
        ///  The tags of the distribution configuration.
        public let tags: [String: String]?

        public init(clientToken: String = CreateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributions: [Distribution], name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case distributions
            case name
            case tags
        }
    }

    public struct CreateDistributionConfigurationResponse: AWSDecodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that was created by this request.
        public let distributionConfigurationArn: String?
        ///  The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case distributionConfigurationArn
            case requestId
        }
    }

    public struct CreateImagePipelineRequest: AWSEncodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.
        public let containerRecipeArn: String?
        ///  The description of the image pipeline.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images created by this image pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        ///  The Amazon Resource Name (ARN) of the image recipe that will be used to configure images created by this image pipeline.
        public let imageRecipeArn: String?
        ///  The image test configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        ///  The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images created by this image pipeline.
        public let infrastructureConfigurationArn: String
        ///  The name of the image pipeline.
        public let name: String
        ///  The schedule of the image pipeline.
        public let schedule: Schedule?
        ///  The status of the image pipeline.
        public let status: PipelineStatus?
        ///  The tags of the image pipeline.
        public let tags: [String: String]?

        public init(clientToken: String = CreateImagePipelineRequest.idempotencyToken(), containerRecipeArn: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, name: String, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.schedule?.validate(name: "\(name).schedule")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case description
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case name
            case schedule
            case status
            case tags
        }
    }

    public struct CreateImagePipelineResponse: AWSDecodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the image pipeline that was created by this request.
        public let imagePipelineArn: String?
        ///  The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imagePipelineArn
            case requestId
        }
    }

    public struct CreateImageRecipeRequest: AWSEncodableShape {
        /// Specify additional settings and launch scripts for your build instances.
        public let additionalInstanceConfiguration: AdditionalInstanceConfiguration?
        /// The block device mappings of the image recipe.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The components of the image recipe.
        public let components: [ComponentConfiguration]
        ///  The description of the image recipe.
        public let description: String?
        ///  The name of the image recipe.
        public let name: String
        /// The parent image of the image recipe. The value of the string can be the ARN of the parent image or an AMI ID. The format for the ARN follows this example: arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x. You can provide the specific version that you want to use, or you can use a wildcard in all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI, and the AMI must be in the same Region in which you are using Image Builder.
        public let parentImage: String
        /// The semantic version of the image recipe.
        public let semanticVersion: String
        ///  The tags of the image recipe.
        public let tags: [String: String]?
        /// The working directory used during build and test workflows.
        public let workingDirectory: String?

        public init(additionalInstanceConfiguration: AdditionalInstanceConfiguration? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, clientToken: String = CreateImageRecipeRequest.idempotencyToken(), components: [ComponentConfiguration], description: String? = nil, name: String, parentImage: String, semanticVersion: String, tags: [String: String]? = nil, workingDirectory: String? = nil) {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.blockDeviceMappings = blockDeviceMappings
            self.clientToken = clientToken
            self.components = components
            self.description = description
            self.name = name
            self.parentImage = parentImage
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.additionalInstanceConfiguration?.validate(name: "\(name).additionalInstanceConfiguration")
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.components.forEach {
                try $0.validate(name: "\(name).components[]")
            }
            try self.validate(self.components, name: "components", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.parentImage, name: "parentImage", parent: name, max: 1024)
            try self.validate(self.parentImage, name: "parentImage", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, max: 1024)
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInstanceConfiguration
            case blockDeviceMappings
            case clientToken
            case components
            case description
            case name
            case parentImage
            case semanticVersion
            case tags
            case workingDirectory
        }
    }

    public struct CreateImageRecipeResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image recipe that was created by this request.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageRecipeArn
            case requestId
        }
    }

    public struct CreateImageRequest: AWSEncodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.
        public let containerRecipeArn: String?
        ///  The Amazon Resource Name (ARN) of the distribution configuration that defines and configures the outputs of your pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        ///  The Amazon Resource Name (ARN) of the image recipe that defines how images are configured, tested, and assessed.
        public let imageRecipeArn: String?
        ///  The image tests configuration of the image.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        ///  The Amazon Resource Name (ARN) of the infrastructure configuration that defines the environment in which your image will be built and tested.
        public let infrastructureConfigurationArn: String
        ///  The tags of the image.
        public let tags: [String: String]?

        public init(clientToken: String = CreateImageRequest.idempotencyToken(), containerRecipeArn: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case tags
        }
    }

    public struct CreateImageResponse: AWSDecodableShape {
        ///  The idempotency token used to make this request idempotent.
        public let clientToken: String?
        ///  The Amazon Resource Name (ARN) of the image that was created by this request.
        public let imageBuildVersionArn: String?
        ///  The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct CreateInfrastructureConfigurationRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. This can be used to log on to and debug the instance used to create your image.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The name of the infrastructure configuration.
        public let name: String
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
        public let securityGroupIds: [String]?
        /// The SNS topic on which to send image build events.
        public let snsTopicArn: String?
        /// The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
        public let subnetId: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = CreateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 256)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "^[\\w+=,.@-]+$")
            try self.validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try self.validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:[0-9]{12}:[a-zA-Z0-9-_]{1,256}$")
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case instanceProfileName
            case instanceTypes
            case keyPair
            case logging
            case name
            case resourceTags
            case securityGroupIds
            case snsTopicArn
            case subnetId
            case tags
            case terminateInstanceOnFailure
        }
    }

    public struct CreateInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by this request.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case infrastructureConfigurationArn
            case requestId
        }
    }

    public struct DeleteComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentBuildVersionArn", location: .querystring(locationName: "componentBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component build version to delete.
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteComponentResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component build version that was deleted.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentBuildVersionArn
            case requestId
        }
    }

    public struct DeleteContainerRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "containerRecipeArn", location: .querystring(locationName: "containerRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the container recipe to delete.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContainerRecipeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that was deleted.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn
            case requestId
        }
    }

    public struct DeleteDistributionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "distributionConfigurationArn", location: .querystring(locationName: "distributionConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the distribution configuration to delete.
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDistributionConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration that was deleted.
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationArn
            case requestId
        }
    }

    public struct DeleteImagePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imagePipelineArn", location: .querystring(locationName: "imagePipelineArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image pipeline to delete.
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImagePipelineResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline that was deleted.
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineArn
            case requestId
        }
    }

    public struct DeleteImageRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring(locationName: "imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe to delete.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageRecipeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that was deleted.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn
            case requestId
        }
    }

    public struct DeleteImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageBuildVersionArn", location: .querystring(locationName: "imageBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image to delete.
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImageResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image that was deleted.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct DeleteInfrastructureConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "infrastructureConfigurationArn", location: .querystring(locationName: "infrastructureConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationArn
            case requestId
        }
    }

    public struct Distribution: AWSEncodableShape & AWSDecodableShape {
        /// The specific AMI settings; for example, launch permissions or AMI tags.
        public let amiDistributionConfiguration: AmiDistributionConfiguration?
        /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
        public let containerDistributionConfiguration: ContainerDistributionConfiguration?
        /// A group of launchTemplateConfiguration settings that apply to image distribution for specified accounts.
        public let launchTemplateConfigurations: [LaunchTemplateConfiguration]?
        /// The License Manager Configuration to associate with the AMI in the specified Region.
        public let licenseConfigurationArns: [String]?
        /// The target Region.
        public let region: String

        public init(amiDistributionConfiguration: AmiDistributionConfiguration? = nil, containerDistributionConfiguration: ContainerDistributionConfiguration? = nil, launchTemplateConfigurations: [LaunchTemplateConfiguration]? = nil, licenseConfigurationArns: [String]? = nil, region: String) {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.containerDistributionConfiguration = containerDistributionConfiguration
            self.launchTemplateConfigurations = launchTemplateConfigurations
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
        }

        public func validate(name: String) throws {
            try self.amiDistributionConfiguration?.validate(name: "\(name).amiDistributionConfiguration")
            try self.containerDistributionConfiguration?.validate(name: "\(name).containerDistributionConfiguration")
            try self.launchTemplateConfigurations?.forEach {
                try $0.validate(name: "\(name).launchTemplateConfigurations[]")
            }
            try self.validate(self.launchTemplateConfigurations, name: "launchTemplateConfigurations", parent: name, max: 100)
            try self.validate(self.launchTemplateConfigurations, name: "launchTemplateConfigurations", parent: name, min: 1)
            try self.licenseConfigurationArns?.forEach {
                try validate($0, name: "licenseConfigurationArns[]", parent: name, pattern: "^arn:aws[^:]*:license-manager:[^:]+:[0-9]{12}:license-configuration:lic-[a-z0-9-_]{32}$")
            }
            try self.validate(self.licenseConfigurationArns, name: "licenseConfigurationArns", parent: name, max: 50)
            try self.validate(self.licenseConfigurationArns, name: "licenseConfigurationArns", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, max: 1024)
            try self.validate(self.region, name: "region", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amiDistributionConfiguration
            case containerDistributionConfiguration
            case launchTemplateConfigurations
            case licenseConfigurationArns
            case region
        }
    }

    public struct DistributionConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which this distribution configuration was created.
        public let dateCreated: String?
        /// The date on which this distribution configuration was last updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The distribution objects that apply Region-specific settings for the deployment of the image to targeted Regions.
        public let distributions: [Distribution]?
        /// The name of the distribution configuration.
        public let name: String?
        /// The tags of the distribution configuration.
        public let tags: [String: String]?
        /// The maximum duration in minutes for this distribution configuration.
        public let timeoutMinutes: Int

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributions: [Distribution]? = nil, name: String? = nil, tags: [String: String]? = nil, timeoutMinutes: Int) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case distributions
            case name
            case tags
            case timeoutMinutes
        }
    }

    public struct DistributionConfigurationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public let arn: String?
        /// The date on which the distribution configuration was created.
        public let dateCreated: String?
        /// The date on which the distribution configuration was updated.
        public let dateUpdated: String?
        /// The description of the distribution configuration.
        public let description: String?
        /// The name of the distribution configuration.
        public let name: String?
        /// A list of Regions where the container image is distributed to.
        public let regions: [String]?
        /// The tags associated with the distribution configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, name: String? = nil, regions: [String]? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.regions = regions
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case name
            case regions
            case tags
        }
    }

    public struct EbsInstanceBlockDeviceSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Use to configure delete on termination of the associated device.
        public let deleteOnTermination: Bool?
        /// Use to configure device encryption.
        public let encrypted: Bool?
        /// Use to configure device IOPS.
        public let iops: Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public let kmsKeyId: String?
        /// The snapshot that defines the device contents.
        public let snapshotId: String?
        /// Use to override the device's volume size.
        public let volumeSize: Int?
        /// Use to override the device's volume type.
        public let volumeType: EbsVolumeType?

        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, snapshotId: String? = nil, volumeSize: Int? = nil, volumeType: EbsVolumeType? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, max: 10000)
            try self.validate(self.iops, name: "iops", parent: name, min: 100)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 1024)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 1)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, max: 16000)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination
            case encrypted
            case iops
            case kmsKeyId
            case snapshotId
            case volumeSize
            case volumeType
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter. Filter names are case-sensitive.
        public let name: String?
        /// The filter values. Filter values are case-sensitive.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z]{1,1024}$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, pattern: "^[0-9a-zA-Z./_ :-]{1,1024}$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case values
        }
    }

    public struct GetComponentPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentArn", location: .querystring(locationName: "componentArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.
        public let componentArn: String

        public init(componentArn: String) {
            self.componentArn = componentArn
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentPolicyResponse: AWSDecodableShape {
        /// The component policy.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "componentBuildVersionArn", location: .querystring(locationName: "componentBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the component that you want to retrieve. Regex requires "/\d+$" suffix.
        public let componentBuildVersionArn: String

        public init(componentBuildVersionArn: String) {
            self.componentBuildVersionArn = componentBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.componentBuildVersionArn, name: "componentBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetComponentResponse: AWSDecodableShape {
        /// The component object associated with the specified ARN.
        public let component: Component?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(component: Component? = nil, requestId: String? = nil) {
            self.component = component
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case component
            case requestId
        }
    }

    public struct GetContainerRecipePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "containerRecipeArn", location: .querystring(locationName: "containerRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the container recipe for the policy being requested.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContainerRecipePolicyResponse: AWSDecodableShape {
        /// The container recipe policy object that is returned.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetContainerRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "containerRecipeArn", location: .querystring(locationName: "containerRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the container recipe to retrieve.
        public let containerRecipeArn: String

        public init(containerRecipeArn: String) {
            self.containerRecipeArn = containerRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContainerRecipeResponse: AWSDecodableShape {
        /// The container recipe object that is returned.
        public let containerRecipe: ContainerRecipe?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipe: ContainerRecipe? = nil, requestId: String? = nil) {
            self.containerRecipe = containerRecipe
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipe
            case requestId
        }
    }

    public struct GetDistributionConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "distributionConfigurationArn", location: .querystring(locationName: "distributionConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to retrieve.
        public let distributionConfigurationArn: String

        public init(distributionConfigurationArn: String) {
            self.distributionConfigurationArn = distributionConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDistributionConfigurationResponse: AWSDecodableShape {
        /// The distribution configuration object.
        public let distributionConfiguration: DistributionConfiguration?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfiguration: DistributionConfiguration? = nil, requestId: String? = nil) {
            self.distributionConfiguration = distributionConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfiguration
            case requestId
        }
    }

    public struct GetImagePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imagePipelineArn", location: .querystring(locationName: "imagePipelineArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
        public let imagePipelineArn: String

        public init(imagePipelineArn: String) {
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePipelineResponse: AWSDecodableShape {
        /// The image pipeline object.
        public let imagePipeline: ImagePipeline?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipeline: ImagePipeline? = nil, requestId: String? = nil) {
            self.imagePipeline = imagePipeline
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipeline
            case requestId
        }
    }

    public struct GetImagePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageArn", location: .querystring(locationName: "imageArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
        public let imageArn: String

        public init(imageArn: String) {
            self.imageArn = imageArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImagePolicyResponse: AWSDecodableShape {
        /// The image policy object.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetImageRecipePolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring(locationName: "imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipePolicyResponse: AWSDecodableShape {
        /// The image recipe policy object.
        public let policy: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(policy: String? = nil, requestId: String? = nil) {
            self.policy = policy
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case requestId
        }
    }

    public struct GetImageRecipeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageRecipeArn", location: .querystring(locationName: "imageRecipeArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
        public let imageRecipeArn: String

        public init(imageRecipeArn: String) {
            self.imageRecipeArn = imageRecipeArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageRecipeResponse: AWSDecodableShape {
        /// The image recipe object.
        public let imageRecipe: ImageRecipe?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipe: ImageRecipe? = nil, requestId: String? = nil) {
            self.imageRecipe = imageRecipe
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipe
            case requestId
        }
    }

    public struct GetImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "imageBuildVersionArn", location: .querystring(locationName: "imageBuildVersionArn"))
        ]

        /// The Amazon Resource Name (ARN) of the image that you want to retrieve.
        public let imageBuildVersionArn: String

        public init(imageBuildVersionArn: String) {
            self.imageBuildVersionArn = imageBuildVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/(?:(?:([0-9]+|x)\\.([0-9]+|x)\\.([0-9]+|x))|(?:[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImageResponse: AWSDecodableShape {
        /// The image object.
        public let image: Image?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(image: Image? = nil, requestId: String? = nil) {
            self.image = image
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case image
            case requestId
        }
    }

    public struct GetInfrastructureConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "infrastructureConfigurationArn", location: .querystring(locationName: "infrastructureConfigurationArn"))
        ]

        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to retrieve.
        public let infrastructureConfigurationArn: String

        public init(infrastructureConfigurationArn: String) {
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The infrastructure configuration object.
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfiguration: InfrastructureConfiguration? = nil, requestId: String? = nil) {
            self.infrastructureConfiguration = infrastructureConfiguration
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfiguration
            case requestId
        }
    }

    public struct Image: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image.
        public let arn: String?
        /// The container recipe used to create the container image type.
        public let containerRecipe: ContainerRecipe?
        /// The date on which this image was created.
        public let dateCreated: String?
        /// The distribution configuration used when creating this image.
        public let distributionConfiguration: DistributionConfiguration?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The image recipe used when creating the image.
        public let imageRecipe: ImageRecipe?
        /// The image tests configuration used when creating this image.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The infrastructure used when creating this image.
        public let infrastructureConfiguration: InfrastructureConfiguration?
        /// The name of the image.
        public let name: String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The output resources produced when creating this image.
        public let outputResources: OutputResources?
        /// The platform of the image.
        public let platform: Platform?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public let sourcePipelineArn: String?
        /// The name of the image pipeline that created this image.
        public let sourcePipelineName: String?
        /// The state of the image.
        public let state: ImageState?
        /// The tags of the image.
        public let tags: [String: String]?
        /// Specifies whether this is an AMI or container image.
        public let type: ImageType?
        /// The semantic version of the image.
        public let version: String?

        public init(arn: String? = nil, containerRecipe: ContainerRecipe? = nil, dateCreated: String? = nil, distributionConfiguration: DistributionConfiguration? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipe: ImageRecipe? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfiguration: InfrastructureConfiguration? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, platform: Platform? = nil, sourcePipelineArn: String? = nil, sourcePipelineName: String? = nil, state: ImageState? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.containerRecipe = containerRecipe
            self.dateCreated = dateCreated
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipe = imageRecipe
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case containerRecipe
            case dateCreated
            case distributionConfiguration
            case enhancedImageMetadataEnabled
            case imageRecipe
            case imageTestsConfiguration
            case infrastructureConfiguration
            case name
            case osVersion
            case outputResources
            case platform
            case sourcePipelineArn
            case sourcePipelineName
            case state
            case tags
            case type
            case version
        }
    }

    public struct ImagePackage: AWSDecodableShape {
        /// The name of the package as reported to the operating system package manager.
        public let packageName: String?
        /// The version of the package as reported to the operating system package manager.
        public let packageVersion: String?

        public init(packageName: String? = nil, packageVersion: String? = nil) {
            self.packageName = packageName
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case packageName
            case packageVersion
        }
    }

    public struct ImagePipeline: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image pipeline.
        public let arn: String?
        /// The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.
        public let containerRecipeArn: String?
        /// The date on which this image pipeline was created.
        public let dateCreated: String?
        /// The date on which this image pipeline was last run.
        public let dateLastRun: String?
        /// The date on which this image pipeline will next be run.
        public let dateNextRun: String?
        /// The date on which this image pipeline was last updated.
        public let dateUpdated: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this image pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image pipeline.
        public let imageRecipeArn: String?
        /// The image tests configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with this image pipeline.
        public let infrastructureConfigurationArn: String?
        /// The name of the image pipeline.
        public let name: String?
        /// The platform of the image pipeline.
        public let platform: Platform?
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?
        /// The tags of this image pipeline.
        public let tags: [String: String]?

        public init(arn: String? = nil, containerRecipeArn: String? = nil, dateCreated: String? = nil, dateLastRun: String? = nil, dateNextRun: String? = nil, dateUpdated: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String? = nil, name: String? = nil, platform: Platform? = nil, schedule: Schedule? = nil, status: PipelineStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.containerRecipeArn = containerRecipeArn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case containerRecipeArn
            case dateCreated
            case dateLastRun
            case dateNextRun
            case dateUpdated
            case description
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case name
            case platform
            case schedule
            case status
            case tags
        }
    }

    public struct ImageRecipe: AWSDecodableShape {
        /// Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to build and test your image configuration. Instance configuration adds a layer of control over those instances. You can define settings and add scripts to run when an instance is launched from your AMI.
        public let additionalInstanceConfiguration: AdditionalInstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The block device mappings to apply when creating images from this recipe.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The components of the image recipe.
        public let components: [ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The description of the image recipe.
        public let description: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The parent image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?
        /// Specifies which type of image is created by the recipe - an AMI or a container image.
        public let type: ImageType?
        /// The version of the image recipe.
        public let version: String?
        /// The working directory to be used during build and test workflows.
        public let workingDirectory: String?

        public init(additionalInstanceConfiguration: AdditionalInstanceConfiguration? = nil, arn: String? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, components: [ComponentConfiguration]? = nil, dateCreated: String? = nil, description: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil, workingDirectory: String? = nil) {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.type = type
            self.version = version
            self.workingDirectory = workingDirectory
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInstanceConfiguration
            case arn
            case blockDeviceMappings
            case components
            case dateCreated
            case description
            case name
            case owner
            case parentImage
            case platform
            case tags
            case type
            case version
            case workingDirectory
        }
    }

    public struct ImageRecipeSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe.
        public let arn: String?
        /// The date on which this image recipe was created.
        public let dateCreated: String?
        /// The name of the image recipe.
        public let name: String?
        /// The owner of the image recipe.
        public let owner: String?
        /// The parent image of the image recipe.
        public let parentImage: String?
        /// The platform of the image recipe.
        public let platform: Platform?
        /// The tags of the image recipe.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, owner: String? = nil, parentImage: String? = nil, platform: Platform? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case name
            case owner
            case parentImage
            case platform
            case tags
        }
    }

    public struct ImageState: AWSDecodableShape {
        /// The reason for the image's status.
        public let reason: String?
        /// The status of the image.
        public let status: ImageStatus?

        public init(reason: String? = nil, status: ImageStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason
            case status
        }
    }

    public struct ImageSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image.
        public let arn: String?
        /// The date on which this image was created.
        public let dateCreated: String?
        /// The name of the image.
        public let name: String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The output resources produced when creating this image.
        public let outputResources: OutputResources?
        /// The owner of the image.
        public let owner: String?
        /// The platform of the image.
        public let platform: Platform?
        /// The state of the image.
        public let state: ImageState?
        /// The tags of the image.
        public let tags: [String: String]?
        /// Specifies whether this is an AMI or container image.
        public let type: ImageType?
        /// The version of the image.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, osVersion: String? = nil, outputResources: OutputResources? = nil, owner: String? = nil, platform: Platform? = nil, state: ImageState? = nil, tags: [String: String]? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case name
            case osVersion
            case outputResources
            case owner
            case platform
            case state
            case tags
            case type
            case version
        }
    }

    public struct ImageTestsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines if tests should be executed when building this image.
        public let imageTestsEnabled: Bool?
        /// The maximum time in minutes that tests are permitted to run.
        public let timeoutMinutes: Int?

        public init(imageTestsEnabled: Bool? = nil, timeoutMinutes: Int? = nil) {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, max: 1440)
            try self.validate(self.timeoutMinutes, name: "timeoutMinutes", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case imageTestsEnabled
            case timeoutMinutes
        }
    }

    public struct ImageVersion: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image semantic version.
        public let arn: String?
        /// The date at which this image semantic version was created.
        public let dateCreated: String?
        /// The name of the image semantic version.
        public let name: String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public let osVersion: String?
        /// The owner of the image semantic version.
        public let owner: String?
        /// The platform of the image semantic version.
        public let platform: Platform?
        /// Specifies whether this is an AMI or container image.
        public let type: ImageType?
        /// The semantic version of the image semantic version.
        public let version: String?

        public init(arn: String? = nil, dateCreated: String? = nil, name: String? = nil, osVersion: String? = nil, owner: String? = nil, platform: Platform? = nil, type: ImageType? = nil, version: String? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case name
            case osVersion
            case owner
            case platform
            case type
            case version
        }
    }

    public struct ImportComponentRequest: AWSEncodableShape {
        /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.
        public let changeDescription: String?
        /// The idempotency token of the component.
        public let clientToken: String
        /// The data of the component. Used to specify the data inline. Either data or uri can be used to specify the data within the component.
        public let data: String?
        /// The description of the component. Describes the contents of the component.
        public let description: String?
        /// The format of the resource that you want to import as a component.
        public let format: ComponentFormat
        /// The ID of the KMS key that should be used to encrypt this component.
        public let kmsKeyId: String?
        ///  The name of the component.
        public let name: String
        /// The platform of the component.
        public let platform: Platform
        /// The semantic version of the component. This version follows the semantic version syntax. For example, major.minor.patch. This could be versioned like software (2.0.1) or like a date (2019.12.01).
        public let semanticVersion: String
        /// The tags of the component.
        public let tags: [String: String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public let type: ComponentType
        /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either data or uri can be used to specify the data within the component.
        public let uri: String?

        public init(changeDescription: String? = nil, clientToken: String = ImportComponentRequest.idempotencyToken(), data: String? = nil, description: String? = nil, format: ComponentFormat, kmsKeyId: String? = nil, name: String, platform: Platform, semanticVersion: String, tags: [String: String]? = nil, type: ComponentType, uri: String? = nil) {
            self.changeDescription = changeDescription
            self.clientToken = clientToken
            self.data = data
            self.description = description
            self.format = format
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.platform = platform
            self.semanticVersion = semanticVersion
            self.tags = tags
            self.type = type
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, max: 1024)
            try self.validate(self.changeDescription, name: "changeDescription", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.data, name: "data", parent: name, max: 1024)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 1024)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[-_A-Za-z-0-9][-_A-Za-z0-9 ]{1,126}[-_A-Za-z-0-9]$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case changeDescription
            case clientToken
            case data
            case description
            case format
            case kmsKeyId
            case name
            case platform
            case semanticVersion
            case tags
            case type
            case uri
        }
    }

    public struct ImportComponentResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the imported component.
        public let componentBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, componentBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.componentBuildVersionArn = componentBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case componentBuildVersionArn
            case requestId
        }
    }

    public struct InfrastructureConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance profile of the infrastructure configuration.
        public let instanceProfileName: String?
        /// The instance types of the infrastructure configuration.
        public let instanceTypes: [String]?
        /// The Amazon EC2 key pair of the infrastructure configuration.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs of the infrastructure configuration.
        public let securityGroupIds: [String]?
        /// The SNS topic Amazon Resource Name (ARN) of the infrastructure configuration.
        public let snsTopicArn: String?
        /// The subnet ID of the infrastructure configuration.
        public let subnetId: String?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?
        /// The terminate instance on failure configuration of the infrastructure configuration.
        public let terminateInstanceOnFailure: Bool?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, instanceProfileName: String? = nil, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, name: String? = nil, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, tags: [String: String]? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case instanceProfileName
            case instanceTypes
            case keyPair
            case logging
            case name
            case resourceTags
            case securityGroupIds
            case snsTopicArn
            case subnetId
            case tags
            case terminateInstanceOnFailure
        }
    }

    public struct InfrastructureConfigurationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public let arn: String?
        /// The date on which the infrastructure configuration was created.
        public let dateCreated: String?
        /// The date on which the infrastructure configuration was last updated.
        public let dateUpdated: String?
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The instance profile of the infrastructure configuration.
        public let instanceProfileName: String?
        /// The instance types of the infrastructure configuration.
        public let instanceTypes: [String]?
        /// The name of the infrastructure configuration.
        public let name: String?
        /// The tags attached to the image created by Image Builder.
        public let resourceTags: [String: String]?
        /// The tags of the infrastructure configuration.
        public let tags: [String: String]?

        public init(arn: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, instanceProfileName: String? = nil, instanceTypes: [String]? = nil, name: String? = nil, resourceTags: [String: String]? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.name = name
            self.resourceTags = resourceTags
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case dateCreated
            case dateUpdated
            case description
            case instanceProfileName
            case instanceTypes
            case name
            case resourceTags
            case tags
        }
    }

    public struct InstanceBlockDeviceMapping: AWSEncodableShape & AWSDecodableShape {
        /// The device to which these mappings apply.
        public let deviceName: String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public let ebs: EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the parent image.
        public let noDevice: String?
        /// Use to manage instance ephemeral devices.
        public let virtualName: String?

        public init(deviceName: String? = nil, ebs: EbsInstanceBlockDeviceSpecification? = nil, noDevice: String? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 1024)
            try self.validate(self.deviceName, name: "deviceName", parent: name, min: 1)
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.noDevice, name: "noDevice", parent: name, max: 0)
            try self.validate(self.noDevice, name: "noDevice", parent: name, min: 0)
            try self.validate(self.virtualName, name: "virtualName", parent: name, max: 1024)
            try self.validate(self.virtualName, name: "virtualName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName
            case ebs
            case noDevice
            case virtualName
        }
    }

    public struct InstanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the block devices to attach for building an instance from this Image Builder AMI.
        public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
        /// The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        public let image: String?

        public init(blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, image: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.image = image
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.image, name: "image", parent: name, max: 1024)
            try self.validate(self.image, name: "image", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case blockDeviceMappings
            case image
        }
    }

    public struct LaunchPermissionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the group.
        public let userGroups: [String]?
        /// The account ID.
        public let userIds: [String]?

        public init(userGroups: [String]? = nil, userIds: [String]? = nil) {
            self.userGroups = userGroups
            self.userIds = userIds
        }

        public func validate(name: String) throws {
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 1024)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.userIds?.forEach {
                try validate($0, name: "userIds[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.userIds, name: "userIds", parent: name, max: 1536)
            try self.validate(self.userIds, name: "userIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case userGroups
            case userIds
        }
    }

    public struct LaunchTemplateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The account ID that this configuration applies to.
        public let accountId: String?
        /// Identifies the Amazon EC2 launch template to use.
        public let launchTemplateId: String
        /// Set the specified Amazon EC2 launch template as the default launch template for the specified account.
        public let setDefaultVersion: Bool?

        public init(accountId: String? = nil, launchTemplateId: String, setDefaultVersion: Bool? = nil) {
            self.accountId = accountId
            self.launchTemplateId = launchTemplateId
            self.setDefaultVersion = setDefaultVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "^lt-[a-z0-9-_]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case launchTemplateId
            case setDefaultVersion
        }
    }

    public struct ListComponentBuildVersionsRequest: AWSEncodableShape {
        /// The component version Amazon Resource Name (ARN) whose versions you want to list.
        public let componentVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(componentVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.componentVersionArn = componentVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.componentVersionArn, name: "componentVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionArn
            case maxResults
            case nextToken
        }
    }

    public struct ListComponentBuildVersionsResponse: AWSDecodableShape {
        /// The list of component summaries for the specified semantic version.
        public let componentSummaryList: [ComponentSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentSummaryList: [ComponentSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentSummaryList = componentSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListComponentsRequest: AWSEncodableShape {
        /// Returns the list of component build versions for the specified semantic version.
        public let byName: Bool?
        /// The filters.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// The owner defines which components you want to list. By default, this request will only show components owned by your account. You can use this field to specify if you want to view components owned by yourself, by Amazon, or those components that have been shared with you by other customers.
        public let owner: Ownership?

        public init(byName: Bool? = nil, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.byName = byName
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byName
            case filters
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListComponentsResponse: AWSDecodableShape {
        /// The list of component semantic versions.
        public let componentVersionList: [ComponentVersion]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentVersionList: [ComponentVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.componentVersionList = componentVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentVersionList
            case nextToken
            case requestId
        }
    }

    public struct ListContainerRecipesRequest: AWSEncodableShape {
        /// Request filters that are used to narrow the list of container images that are returned.
        public let filters: [Filter]?
        /// The maximum number of results to return in the list.
        public let maxResults: Int?
        /// Provides a token for pagination, which determines where to begin the next set of results when the current set reaches the maximum for one request.
        public let nextToken: String?
        /// Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListContainerRecipesResponse: AWSDecodableShape {
        /// The list of container recipes returned for the request.
        public let containerRecipeSummaryList: [ContainerRecipeSummary]?
        /// The next token field is used for paginated responses. When this is not empty, there are additional container recipes that the service has not included in this response. Use this token with the next request to retrieve additional list items.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeSummaryList: [ContainerRecipeSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.containerRecipeSummaryList = containerRecipeSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListDistributionConfigurationsRequest: AWSEncodableShape {
        /// The filters.    name - The name of this distribution configuration.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListDistributionConfigurationsResponse: AWSDecodableShape {
        /// The list of distributions.
        public let distributionConfigurationSummaryList: [DistributionConfigurationSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(distributionConfigurationSummaryList: [DistributionConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case distributionConfigurationSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImageBuildVersionsRequest: AWSEncodableShape {
        /// The filters.
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.
        public let imageVersionArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imageVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imageVersionArn = imageVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.imageVersionArn, name: "imageVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case imageVersionArn
            case maxResults
            case nextToken
        }
    }

    public struct ListImageBuildVersionsResponse: AWSDecodableShape {
        /// The list of image build versions.
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImagePackagesRequest: AWSEncodableShape {
        /// Filter results for the ListImagePackages request by the Image Build Version ARN
        public let imageBuildVersionArn: String
        /// The maxiumum number of results to return from the ListImagePackages request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(imageBuildVersionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.imageBuildVersionArn = imageBuildVersionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.imageBuildVersionArn, name: "imageBuildVersionArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuildVersionArn
            case maxResults
            case nextToken
        }
    }

    public struct ListImagePackagesResponse: AWSDecodableShape {
        /// The list of Image Packages returned in the response.
        public let imagePackageList: [ImagePackage]?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePackageList: [ImagePackage]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imagePackageList = imagePackageList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePackageList
            case nextToken
            case requestId
        }
    }

    public struct ListImagePipelineImagesRequest: AWSEncodableShape {
        /// The filters.
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.
        public let imagePipelineArn: String
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, imagePipelineArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.imagePipelineArn = imagePipelineArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case imagePipelineArn
            case maxResults
            case nextToken
        }
    }

    public struct ListImagePipelineImagesResponse: AWSDecodableShape {
        /// The list of images built by this pipeline.
        public let imageSummaryList: [ImageSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageSummaryList: [ImageSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageSummaryList = imageSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImagePipelinesRequest: AWSEncodableShape {
        /// The filters.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListImagePipelinesResponse: AWSDecodableShape {
        /// The list of image pipelines.
        public let imagePipelineList: [ImagePipeline]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imagePipelineList: [ImagePipeline]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imagePipelineList = imagePipelineList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePipelineList
            case nextToken
            case requestId
        }
    }

    public struct ListImageRecipesRequest: AWSEncodableShape {
        /// The filters.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// The owner defines which image recipes you want to list. By default, this request will only show image recipes owned by your account. You can use this field to specify if you want to view image recipes owned by yourself, by Amazon, or those image recipes that have been shared with you by other customers.
        public let owner: Ownership?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListImageRecipesResponse: AWSDecodableShape {
        /// The list of image pipelines.
        public let imageRecipeSummaryList: [ImageRecipeSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeSummaryList: [ImageRecipeSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageRecipeSummaryList = imageRecipeSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListImagesRequest: AWSEncodableShape {
        /// Requests a list of images with a specific recipe name.
        public let byName: Bool?
        /// The filters.
        public let filters: [Filter]?
        /// Includes deprecated images in the response list.
        public let includeDeprecated: Bool?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?
        /// The owner defines which images you want to list. By default, this request will only show images owned by your account. You can use this field to specify if you want to view images owned by yourself, by Amazon, or those images that have been shared with you by other customers.
        public let owner: Ownership?

        public init(byName: Bool? = nil, filters: [Filter]? = nil, includeDeprecated: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, owner: Ownership? = nil) {
            self.byName = byName
            self.filters = filters
            self.includeDeprecated = includeDeprecated
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case byName
            case filters
            case includeDeprecated
            case maxResults
            case nextToken
            case owner
        }
    }

    public struct ListImagesResponse: AWSDecodableShape {
        /// The list of image semantic versions.
        public let imageVersionList: [ImageVersion]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageVersionList: [ImageVersion]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.imageVersionList = imageVersionList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageVersionList
            case nextToken
            case requestId
        }
    }

    public struct ListInfrastructureConfigurationsRequest: AWSEncodableShape {
        /// The filters.
        public let filters: [Filter]?
        /// The maximum items to return in a request.
        public let maxResults: Int?
        /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListInfrastructureConfigurationsResponse: AWSDecodableShape {
        /// The list of infrastructure configurations.
        public let infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]?
        /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
        public let nextToken: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]? = nil, nextToken: String? = nil, requestId: String? = nil) {
            self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
            self.nextToken = nextToken
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case infrastructureConfigurationSummaryList
            case nextToken
            case requestId
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Logging: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 logging configuration.
        public let s3Logs: S3Logs?

        public init(s3Logs: S3Logs? = nil) {
            self.s3Logs = s3Logs
        }

        public func validate(name: String) throws {
            try self.s3Logs?.validate(name: "\(name).s3Logs")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Logs
        }
    }

    public struct OutputResources: AWSDecodableShape {
        /// The Amazon EC2 AMIs created by this image.
        public let amis: [Ami]?
        /// Container images that the pipeline has generated and stored in the output repository.
        public let containers: [Container]?

        public init(amis: [Ami]? = nil, containers: [Container]? = nil) {
            self.amis = amis
            self.containers = containers
        }

        private enum CodingKeys: String, CodingKey {
            case amis
            case containers
        }
    }

    public struct PutComponentPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the component that this policy should be applied to.
        public let componentArn: String
        /// The policy to apply.
        public let policy: String

        public init(componentArn: String, policy: String) {
            self.componentArn = componentArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.componentArn, name: "componentArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):component/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn
            case policy
        }
    }

    public struct PutComponentPolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the component that this policy was applied to.
        public let componentArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(componentArn: String? = nil, requestId: String? = nil) {
            self.componentArn = componentArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case componentArn
            case requestId
        }
    }

    public struct PutContainerRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.
        public let containerRecipeArn: String
        /// The policy to apply to the container recipe.
        public let policy: String

        public init(containerRecipeArn: String, policy: String) {
            self.containerRecipeArn = containerRecipeArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn
            case policy
        }
    }

    public struct PutContainerRecipePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the container recipe that this policy was applied to.
        public let containerRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(containerRecipeArn: String? = nil, requestId: String? = nil) {
            self.containerRecipeArn = containerRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case containerRecipeArn
            case requestId
        }
    }

    public struct PutImagePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image that this policy should be applied to.
        public let imageArn: String
        /// The policy to apply.
        public let policy: String

        public init(imageArn: String, policy: String) {
            self.imageArn = imageArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.imageArn, name: "imageArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn
            case policy
        }
    }

    public struct PutImagePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image that this policy was applied to.
        public let imageArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageArn: String? = nil, requestId: String? = nil) {
            self.imageArn = imageArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageArn
            case requestId
        }
    }

    public struct PutImageRecipePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.
        public let imageRecipeArn: String
        /// The policy to apply.
        public let policy: String

        public init(imageRecipeArn: String, policy: String) {
            self.imageRecipeArn = imageRecipeArn
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 30000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn
            case policy
        }
    }

    public struct PutImageRecipePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied to.
        public let imageRecipeArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(imageRecipeArn: String? = nil, requestId: String? = nil) {
            self.imageRecipeArn = imageRecipeArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case imageRecipeArn
            case requestId
        }
    }

    public struct S3Logs: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket in which to store the logs.
        public let s3BucketName: String?
        /// The Amazon S3 path in which to store the logs.
        public let s3KeyPrefix: String?

        public init(s3BucketName: String? = nil, s3KeyPrefix: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 1024)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, max: 1024)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName
            case s3KeyPrefix
        }
    }

    public struct Schedule: AWSEncodableShape & AWSDecodableShape {
        /// The condition configures when the pipeline should trigger a new image build. When the pipelineExecutionStartCondition is set to EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, and you use semantic version filters on the source image or components in your image recipe, EC2 Image Builder will build a new image only when there are new versions of the image or components in your recipe that match the semantic version filter. When it is set to EXPRESSION_MATCH_ONLY, it will build a new image every time the CRON expression matches the current time. For semantic version syntax, see CreateComponent in the  EC2 Image Builder API Reference.
        public let pipelineExecutionStartCondition: PipelineExecutionStartCondition?
        /// The cron expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition. For information on how to format a cron expression in Image Builder, see Use cron expressions in EC2 Image Builder.
        public let scheduleExpression: String?
        /// The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the IANA timezone format. If not specified this defaults to UTC.
        public let timezone: String?

        public init(pipelineExecutionStartCondition: PipelineExecutionStartCondition? = nil, scheduleExpression: String? = nil, timezone: String? = nil) {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 1024)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, min: 1)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 100)
            try self.validate(self.timezone, name: "timezone", parent: name, min: 3)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "[a-zA-Z0-9]{2,}(?:\\/[a-zA-z0-9-_+]+)*")
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineExecutionStartCondition
            case scheduleExpression
            case timezone
        }
    }

    public struct StartImagePipelineExecutionRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.
        public let imagePipelineArn: String

        public init(clientToken: String = StartImagePipelineExecutionRequest.idempotencyToken(), imagePipelineArn: String) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imagePipelineArn
        }
    }

    public struct StartImagePipelineExecutionResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image that was created by this request.
        public let imageBuildVersionArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imageBuildVersionArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imageBuildVersionArn = imageBuildVersionArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imageBuildVersionArn
            case requestId
        }
    }

    public struct SystemsManagerAgent: AWSEncodableShape & AWSDecodableShape {
        /// This property defaults to true. If Image Builder installs the SSM agent on a build instance, it removes the agent before creating a snapshot for the AMI. To ensure that the AMI you create includes the SSM agent, set this property to false.
        public let uninstallAfterBuild: Bool?

        public init(uninstallAfterBuild: Bool? = nil) {
            self.uninstallAfterBuild = uninstallAfterBuild
        }

        private enum CodingKeys: String, CodingKey {
            case uninstallAfterBuild
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// The tags to apply to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetContainerRepository: AWSEncodableShape & AWSDecodableShape {
        /// The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        public let repositoryName: String
        /// Specifies the service in which this image was registered.
        public let service: ContainerRepositoryService

        public init(repositoryName: String, service: ContainerRepositoryService) {
            self.repositoryName = repositoryName
            self.service = service
        }

        public func validate(name: String) throws {
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 1024)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName
            case service
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):(?:image-recipe|container-recipe|infrastructure-configuration|distribution-configuration|component|image|image-pipeline)/[a-z0-9-_]+(?:/(?:(?:x|[0-9]+)\\.(?:x|[0-9]+)\\.(?:x|[0-9]+))(?:/[0-9]+)?)?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDistributionConfigurationRequest: AWSEncodableShape {
        /// The idempotency token of the distribution configuration.
        public let clientToken: String
        /// The description of the distribution configuration.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that you want to update.
        public let distributionConfigurationArn: String
        /// The distributions of the distribution configuration.
        public let distributions: [Distribution]

        public init(clientToken: String = UpdateDistributionConfigurationRequest.idempotencyToken(), description: String? = nil, distributionConfigurationArn: String, distributions: [Distribution]) {
            self.clientToken = clientToken
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case distributionConfigurationArn
            case distributions
        }
    }

    public struct UpdateDistributionConfigurationResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by this request.
        public let distributionConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, distributionConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.distributionConfigurationArn = distributionConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case distributionConfigurationArn
            case requestId
        }
    }

    public struct UpdateImagePipelineRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The Amazon Resource Name (ARN) of the container pipeline to update.
        public let containerRecipeArn: String?
        /// The description of the image pipeline.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images updated by this image pipeline.
        public let distributionConfigurationArn: String?
        ///  Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public let enhancedImageMetadataEnabled: Bool?
        /// The Amazon Resource Name (ARN) of the image pipeline that you want to update.
        public let imagePipelineArn: String
        /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images updated by this image pipeline.
        public let imageRecipeArn: String?
        /// The image test configuration of the image pipeline.
        public let imageTestsConfiguration: ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images updated by this image pipeline.
        public let infrastructureConfigurationArn: String
        /// The schedule of the image pipeline.
        public let schedule: Schedule?
        /// The status of the image pipeline.
        public let status: PipelineStatus?

        public init(clientToken: String = UpdateImagePipelineRequest.idempotencyToken(), containerRecipeArn: String? = nil, description: String? = nil, distributionConfigurationArn: String? = nil, enhancedImageMetadataEnabled: Bool? = nil, imagePipelineArn: String, imageRecipeArn: String? = nil, imageTestsConfiguration: ImageTestsConfiguration? = nil, infrastructureConfigurationArn: String, schedule: Schedule? = nil, status: PipelineStatus? = nil) {
            self.clientToken = clientToken
            self.containerRecipeArn = containerRecipeArn
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imagePipelineArn = imagePipelineArn
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.schedule = schedule
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.containerRecipeArn, name: "containerRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):container-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.distributionConfigurationArn, name: "distributionConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):distribution-configuration/[a-z0-9-_]+$")
            try self.validate(self.imagePipelineArn, name: "imagePipelineArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-pipeline/[a-z0-9-_]+$")
            try self.validate(self.imageRecipeArn, name: "imageRecipeArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):image-recipe/[a-z0-9-_]+/[0-9]+\\.[0-9]+\\.[0-9]+$")
            try self.imageTestsConfiguration?.validate(name: "\(name).imageTestsConfiguration")
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.schedule?.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case containerRecipeArn
            case description
            case distributionConfigurationArn
            case enhancedImageMetadataEnabled
            case imagePipelineArn
            case imageRecipeArn
            case imageTestsConfiguration
            case infrastructureConfigurationArn
            case schedule
            case status
        }
    }

    public struct UpdateImagePipelineResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this request.
        public let imagePipelineArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, imagePipelineArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.imagePipelineArn = imagePipelineArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case imagePipelineArn
            case requestId
        }
    }

    public struct UpdateInfrastructureConfigurationRequest: AWSEncodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String
        /// The description of the infrastructure configuration.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to update.
        public let infrastructureConfigurationArn: String
        /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
        public let instanceProfileName: String
        /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
        public let instanceTypes: [String]?
        /// The key pair of the infrastructure configuration. This can be used to log on to and debug the instance used to create your image.
        public let keyPair: String?
        /// The logging configuration of the infrastructure configuration.
        public let logging: Logging?
        /// The tags attached to the resource created by Image Builder.
        public let resourceTags: [String: String]?
        /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
        public let securityGroupIds: [String]?
        /// The SNS topic on which to send image build events.
        public let snsTopicArn: String?
        /// The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
        public let subnetId: String?
        /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
        public let terminateInstanceOnFailure: Bool?

        public init(clientToken: String = UpdateInfrastructureConfigurationRequest.idempotencyToken(), description: String? = nil, infrastructureConfigurationArn: String, instanceProfileName: String, instanceTypes: [String]? = nil, keyPair: String? = nil, logging: Logging? = nil, resourceTags: [String: String]? = nil, securityGroupIds: [String]? = nil, snsTopicArn: String? = nil, subnetId: String? = nil, terminateInstanceOnFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.infrastructureConfigurationArn, name: "infrastructureConfigurationArn", parent: name, pattern: "^arn:aws[^:]*:imagebuilder:[^:]+:(?:[0-9]{12}|aws):infrastructure-configuration/[a-z0-9-_]+$")
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, max: 256)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, min: 1)
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "^[\\w+=,.@-]+$")
            try self.validate(self.keyPair, name: "keyPair", parent: name, max: 1024)
            try self.validate(self.keyPair, name: "keyPair", parent: name, min: 1)
            try self.logging?.validate(name: "\(name).logging")
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, min: 1)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 1024)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws[^:]*:sns:[^:]+:[0-9]{12}:[a-zA-Z0-9-_]{1,256}$")
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 1024)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case infrastructureConfigurationArn
            case instanceProfileName
            case instanceTypes
            case keyPair
            case logging
            case resourceTags
            case securityGroupIds
            case snsTopicArn
            case subnetId
            case terminateInstanceOnFailure
        }
    }

    public struct UpdateInfrastructureConfigurationResponse: AWSDecodableShape {
        /// The idempotency token used to make this request idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by this request.
        public let infrastructureConfigurationArn: String?
        /// The request ID that uniquely identifies this request.
        public let requestId: String?

        public init(clientToken: String? = nil, infrastructureConfigurationArn: String? = nil, requestId: String? = nil) {
            self.clientToken = clientToken
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case infrastructureConfigurationArn
            case requestId
        }
    }
}
