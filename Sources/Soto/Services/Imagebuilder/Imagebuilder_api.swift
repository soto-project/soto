//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS Imagebuilder service.
///
/// EC2 Image Builder is a fully managed Amazon Web Services service that makes it easier to automate the
/// 			creation, management, and deployment of customized, secure, and up-to-date
/// 			"golden" server images that are pre-installed and pre-configured with software
/// 			and settings to meet specific IT standards.
public struct Imagebuilder: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Imagebuilder client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Imagebuilder",
            serviceIdentifier: "imagebuilder",
            serviceProtocol: .restjson,
            apiVersion: "2019-12-02",
            endpoint: endpoint,
            errorType: ImagebuilderErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// CancelImageCreation cancels the creation of Image. This operation can only be used on
    /// 			images in a non-terminal state.
    @Sendable
    public func cancelImageCreation(_ input: CancelImageCreationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelImageCreationResponse {
        return try await self.client.execute(
            operation: "CancelImageCreation", 
            path: "/CancelImageCreation", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Cancel a specific image lifecycle policy runtime instance.
    @Sendable
    public func cancelLifecycleExecution(_ input: CancelLifecycleExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelLifecycleExecutionResponse {
        return try await self.client.execute(
            operation: "CancelLifecycleExecution", 
            path: "/CancelLifecycleExecution", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new component that can be used to build, validate, test, and assess your
    /// 			image. The component is based on a YAML document that you specify using exactly one of
    /// 			the following methods:   Inline, using the data property in the request body.   A URL that points to a YAML document file stored in Amazon S3, using the
    /// 						uri property in the request body.
    @Sendable
    public func createComponent(_ input: CreateComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateComponentResponse {
        return try await self.client.execute(
            operation: "CreateComponent", 
            path: "/CreateComponent", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new container recipe. Container recipes define how images are configured,
    /// 			tested, and assessed.
    @Sendable
    public func createContainerRecipe(_ input: CreateContainerRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateContainerRecipeResponse {
        return try await self.client.execute(
            operation: "CreateContainerRecipe", 
            path: "/CreateContainerRecipe", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new distribution configuration. Distribution configurations define and
    /// 			configure the outputs of your pipeline.
    @Sendable
    public func createDistributionConfiguration(_ input: CreateDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDistributionConfigurationResponse {
        return try await self.client.execute(
            operation: "CreateDistributionConfiguration", 
            path: "/CreateDistributionConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new image. This request will create a new image along with all of the
    /// 			configured output resources defined in the distribution configuration. You must specify
    /// 			exactly one recipe for your image, using either a ContainerRecipeArn or an
    /// 			ImageRecipeArn.
    @Sendable
    public func createImage(_ input: CreateImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateImageResponse {
        return try await self.client.execute(
            operation: "CreateImage", 
            path: "/CreateImage", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images.
    @Sendable
    public func createImagePipeline(_ input: CreateImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateImagePipelineResponse {
        return try await self.client.execute(
            operation: "CreateImagePipeline", 
            path: "/CreateImagePipeline", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new image recipe. Image recipes define how images are configured, tested,
    /// 			and assessed.
    @Sendable
    public func createImageRecipe(_ input: CreateImageRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateImageRecipeResponse {
        return try await self.client.execute(
            operation: "CreateImageRecipe", 
            path: "/CreateImageRecipe", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a new infrastructure configuration. An infrastructure configuration defines
    /// 			the environment in which your image will be built and tested.
    @Sendable
    public func createInfrastructureConfiguration(_ input: CreateInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInfrastructureConfigurationResponse {
        return try await self.client.execute(
            operation: "CreateInfrastructureConfiguration", 
            path: "/CreateInfrastructureConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Create a lifecycle policy resource.
    @Sendable
    public func createLifecyclePolicy(_ input: CreateLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLifecyclePolicyResponse {
        return try await self.client.execute(
            operation: "CreateLifecyclePolicy", 
            path: "/CreateLifecyclePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Create a new workflow or a new version of an existing workflow.
    @Sendable
    public func createWorkflow(_ input: CreateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkflowResponse {
        return try await self.client.execute(
            operation: "CreateWorkflow", 
            path: "/CreateWorkflow", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a component build version.
    @Sendable
    public func deleteComponent(_ input: DeleteComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteComponentResponse {
        return try await self.client.execute(
            operation: "DeleteComponent", 
            path: "/DeleteComponent", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a container recipe.
    @Sendable
    public func deleteContainerRecipe(_ input: DeleteContainerRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteContainerRecipeResponse {
        return try await self.client.execute(
            operation: "DeleteContainerRecipe", 
            path: "/DeleteContainerRecipe", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a distribution configuration.
    @Sendable
    public func deleteDistributionConfiguration(_ input: DeleteDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDistributionConfigurationResponse {
        return try await self.client.execute(
            operation: "DeleteDistributionConfiguration", 
            path: "/DeleteDistributionConfiguration", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an Image Builder image resource. This does not delete any EC2 AMIs or ECR container
    /// 			images that are created during the image build process. You must clean those up
    /// 			separately, using the appropriate Amazon EC2 or Amazon ECR console actions, or API or CLI
    /// 			commands.   To deregister an EC2 Linux AMI, see Deregister your
    /// 						Linux AMI in the  Amazon EC2 User Guide .   To deregister an EC2 Windows AMI, see Deregister your
    /// 						Windows AMI in the  Amazon EC2 Windows Guide .   To delete a container image from Amazon ECR, see Deleting
    /// 						an image in the Amazon ECR User Guide.
    @Sendable
    public func deleteImage(_ input: DeleteImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImageResponse {
        return try await self.client.execute(
            operation: "DeleteImage", 
            path: "/DeleteImage", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an image pipeline.
    @Sendable
    public func deleteImagePipeline(_ input: DeleteImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImagePipelineResponse {
        return try await self.client.execute(
            operation: "DeleteImagePipeline", 
            path: "/DeleteImagePipeline", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an image recipe.
    @Sendable
    public func deleteImageRecipe(_ input: DeleteImageRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImageRecipeResponse {
        return try await self.client.execute(
            operation: "DeleteImageRecipe", 
            path: "/DeleteImageRecipe", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an infrastructure configuration.
    @Sendable
    public func deleteInfrastructureConfiguration(_ input: DeleteInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteInfrastructureConfigurationResponse {
        return try await self.client.execute(
            operation: "DeleteInfrastructureConfiguration", 
            path: "/DeleteInfrastructureConfiguration", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Delete the specified lifecycle policy resource.
    @Sendable
    public func deleteLifecyclePolicy(_ input: DeleteLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLifecyclePolicyResponse {
        return try await self.client.execute(
            operation: "DeleteLifecyclePolicy", 
            path: "/DeleteLifecyclePolicy", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a specific workflow resource.
    @Sendable
    public func deleteWorkflow(_ input: DeleteWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWorkflowResponse {
        return try await self.client.execute(
            operation: "DeleteWorkflow", 
            path: "/DeleteWorkflow", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a component object.
    @Sendable
    public func getComponent(_ input: GetComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetComponentResponse {
        return try await self.client.execute(
            operation: "GetComponent", 
            path: "/GetComponent", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a component policy.
    @Sendable
    public func getComponentPolicy(_ input: GetComponentPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetComponentPolicyResponse {
        return try await self.client.execute(
            operation: "GetComponentPolicy", 
            path: "/GetComponentPolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves a container recipe.
    @Sendable
    public func getContainerRecipe(_ input: GetContainerRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetContainerRecipeResponse {
        return try await self.client.execute(
            operation: "GetContainerRecipe", 
            path: "/GetContainerRecipe", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Retrieves the policy for a container recipe.
    @Sendable
    public func getContainerRecipePolicy(_ input: GetContainerRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetContainerRecipePolicyResponse {
        return try await self.client.execute(
            operation: "GetContainerRecipePolicy", 
            path: "/GetContainerRecipePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets a distribution configuration.
    @Sendable
    public func getDistributionConfiguration(_ input: GetDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDistributionConfigurationResponse {
        return try await self.client.execute(
            operation: "GetDistributionConfiguration", 
            path: "/GetDistributionConfiguration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets an image.
    @Sendable
    public func getImage(_ input: GetImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImageResponse {
        return try await self.client.execute(
            operation: "GetImage", 
            path: "/GetImage", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets an image pipeline.
    @Sendable
    public func getImagePipeline(_ input: GetImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImagePipelineResponse {
        return try await self.client.execute(
            operation: "GetImagePipeline", 
            path: "/GetImagePipeline", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets an image policy.
    @Sendable
    public func getImagePolicy(_ input: GetImagePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImagePolicyResponse {
        return try await self.client.execute(
            operation: "GetImagePolicy", 
            path: "/GetImagePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets an image recipe.
    @Sendable
    public func getImageRecipe(_ input: GetImageRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImageRecipeResponse {
        return try await self.client.execute(
            operation: "GetImageRecipe", 
            path: "/GetImageRecipe", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets an image recipe policy.
    @Sendable
    public func getImageRecipePolicy(_ input: GetImageRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImageRecipePolicyResponse {
        return try await self.client.execute(
            operation: "GetImageRecipePolicy", 
            path: "/GetImageRecipePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Gets an infrastructure configuration.
    @Sendable
    public func getInfrastructureConfiguration(_ input: GetInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetInfrastructureConfigurationResponse {
        return try await self.client.execute(
            operation: "GetInfrastructureConfiguration", 
            path: "/GetInfrastructureConfiguration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get the runtime information that was logged for a specific runtime instance of the lifecycle policy.
    @Sendable
    public func getLifecycleExecution(_ input: GetLifecycleExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLifecycleExecutionResponse {
        return try await self.client.execute(
            operation: "GetLifecycleExecution", 
            path: "/GetLifecycleExecution", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get details for the specified image lifecycle policy.
    @Sendable
    public func getLifecyclePolicy(_ input: GetLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLifecyclePolicyResponse {
        return try await self.client.execute(
            operation: "GetLifecyclePolicy", 
            path: "/GetLifecyclePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get a workflow resource object.
    @Sendable
    public func getWorkflow(_ input: GetWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowResponse {
        return try await self.client.execute(
            operation: "GetWorkflow", 
            path: "/GetWorkflow", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get the runtime information that was logged for a specific runtime instance
    /// 			of the workflow.
    @Sendable
    public func getWorkflowExecution(_ input: GetWorkflowExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowExecutionResponse {
        return try await self.client.execute(
            operation: "GetWorkflowExecution", 
            path: "/GetWorkflowExecution", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get the runtime information that was logged for a specific runtime instance of
    /// 			the workflow step.
    @Sendable
    public func getWorkflowStepExecution(_ input: GetWorkflowStepExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowStepExecutionResponse {
        return try await self.client.execute(
            operation: "GetWorkflowStepExecution", 
            path: "/GetWorkflowStepExecution", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Imports a component and transforms its data into a component document.
    @Sendable
    public func importComponent(_ input: ImportComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportComponentResponse {
        return try await self.client.execute(
            operation: "ImportComponent", 
            path: "/ImportComponent", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// When you export your virtual machine (VM) from its virtualization environment, that
    /// 			process creates a set of one or more disk container files that act as snapshots of your
    /// 			VM’s environment, settings, and data. The Amazon EC2 API ImportImage
    /// 			action uses those files to import your VM and create an AMI. To import using the CLI
    /// 			command, see import-image  You can reference the task ID from the VM import to pull in the AMI that the import
    /// 			created as the base image for your Image Builder recipe.
    @Sendable
    public func importVmImage(_ input: ImportVmImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportVmImageResponse {
        return try await self.client.execute(
            operation: "ImportVmImage", 
            path: "/ImportVmImage", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns the list of component build versions for the specified semantic
    /// 			version.  The semantic version has four nodes: ../.
    /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    @Sendable
    public func listComponentBuildVersions(_ input: ListComponentBuildVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListComponentBuildVersionsResponse {
        return try await self.client.execute(
            operation: "ListComponentBuildVersions", 
            path: "/ListComponentBuildVersions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns the list of components that can be filtered by name, or by using the listed
    /// 				filters to streamline results. Newly created components can take up to
    /// 			two minutes to appear in the ListComponents API Results.  The semantic version has four nodes: ../.
    /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    @Sendable
    public func listComponents(_ input: ListComponentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListComponentsResponse {
        return try await self.client.execute(
            operation: "ListComponents", 
            path: "/ListComponents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of container recipes.
    @Sendable
    public func listContainerRecipes(_ input: ListContainerRecipesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListContainerRecipesResponse {
        return try await self.client.execute(
            operation: "ListContainerRecipes", 
            path: "/ListContainerRecipes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of distribution configurations.
    @Sendable
    public func listDistributionConfigurations(_ input: ListDistributionConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDistributionConfigurationsResponse {
        return try await self.client.execute(
            operation: "ListDistributionConfigurations", 
            path: "/ListDistributionConfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of image build versions.
    @Sendable
    public func listImageBuildVersions(_ input: ListImageBuildVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageBuildVersionsResponse {
        return try await self.client.execute(
            operation: "ListImageBuildVersions", 
            path: "/ListImageBuildVersions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// List the Packages that are associated with an Image Build Version, as determined by
    /// 			Amazon Web Services Systems Manager Inventory at build time.
    @Sendable
    public func listImagePackages(_ input: ListImagePackagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagePackagesResponse {
        return try await self.client.execute(
            operation: "ListImagePackages", 
            path: "/ListImagePackages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of images created by the specified pipeline.
    @Sendable
    public func listImagePipelineImages(_ input: ListImagePipelineImagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagePipelineImagesResponse {
        return try await self.client.execute(
            operation: "ListImagePipelineImages", 
            path: "/ListImagePipelineImages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of image pipelines.
    @Sendable
    public func listImagePipelines(_ input: ListImagePipelinesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagePipelinesResponse {
        return try await self.client.execute(
            operation: "ListImagePipelines", 
            path: "/ListImagePipelines", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of image recipes.
    @Sendable
    public func listImageRecipes(_ input: ListImageRecipesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageRecipesResponse {
        return try await self.client.execute(
            operation: "ListImageRecipes", 
            path: "/ListImageRecipes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of image scan aggregations for your account. You can filter by the type
    /// 			of key that Image Builder uses to group results. For example, if you want to get a list of
    /// 			findings by severity level for one of your pipelines, you might specify your pipeline
    /// 			with the imagePipelineArn filter. If you don't specify a filter, Image Builder
    /// 			returns an aggregation for your account. To streamline results, you can use the following filters in your request:    accountId     imageBuildVersionArn     imagePipelineArn     vulnerabilityId
    @Sendable
    public func listImageScanFindingAggregations(_ input: ListImageScanFindingAggregationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageScanFindingAggregationsResponse {
        return try await self.client.execute(
            operation: "ListImageScanFindingAggregations", 
            path: "/ListImageScanFindingAggregations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of image scan findings for your account.
    @Sendable
    public func listImageScanFindings(_ input: ListImageScanFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageScanFindingsResponse {
        return try await self.client.execute(
            operation: "ListImageScanFindings", 
            path: "/ListImageScanFindings", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns the list of images that you have access to. Newly created images can take up
    /// 			to two minutes to appear in the ListImages API Results.
    @Sendable
    public func listImages(_ input: ListImagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagesResponse {
        return try await self.client.execute(
            operation: "ListImages", 
            path: "/ListImages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of infrastructure configurations.
    @Sendable
    public func listInfrastructureConfigurations(_ input: ListInfrastructureConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInfrastructureConfigurationsResponse {
        return try await self.client.execute(
            operation: "ListInfrastructureConfigurations", 
            path: "/ListInfrastructureConfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// List resources that the runtime instance of the image lifecycle identified for lifecycle actions.
    @Sendable
    public func listLifecycleExecutionResources(_ input: ListLifecycleExecutionResourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLifecycleExecutionResourcesResponse {
        return try await self.client.execute(
            operation: "ListLifecycleExecutionResources", 
            path: "/ListLifecycleExecutionResources", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get the lifecycle runtime history for the specified resource.
    @Sendable
    public func listLifecycleExecutions(_ input: ListLifecycleExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLifecycleExecutionsResponse {
        return try await self.client.execute(
            operation: "ListLifecycleExecutions", 
            path: "/ListLifecycleExecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get a list of lifecycle policies in your Amazon Web Services account.
    @Sendable
    public func listLifecyclePolicies(_ input: ListLifecyclePoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLifecyclePoliciesResponse {
        return try await self.client.execute(
            operation: "ListLifecyclePolicies", 
            path: "/ListLifecyclePolicies", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns the list of tags for the specified resource.
    @Sendable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        return try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Get a list of workflow steps that are waiting for action for workflows
    /// 			in your Amazon Web Services account.
    @Sendable
    public func listWaitingWorkflowSteps(_ input: ListWaitingWorkflowStepsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWaitingWorkflowStepsResponse {
        return try await self.client.execute(
            operation: "ListWaitingWorkflowSteps", 
            path: "/ListWaitingWorkflowSteps", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of build versions for a specific workflow resource.
    @Sendable
    public func listWorkflowBuildVersions(_ input: ListWorkflowBuildVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowBuildVersionsResponse {
        return try await self.client.execute(
            operation: "ListWorkflowBuildVersions", 
            path: "/ListWorkflowBuildVersions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of workflow runtime instance metadata objects for a specific image build
    /// 			version.
    @Sendable
    public func listWorkflowExecutions(_ input: ListWorkflowExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowExecutionsResponse {
        return try await self.client.execute(
            operation: "ListWorkflowExecutions", 
            path: "/ListWorkflowExecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns runtime data for each step in a runtime instance of the workflow
    /// 			that you specify in the request.
    @Sendable
    public func listWorkflowStepExecutions(_ input: ListWorkflowStepExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowStepExecutionsResponse {
        return try await self.client.execute(
            operation: "ListWorkflowStepExecutions", 
            path: "/ListWorkflowStepExecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists workflow build versions based on filtering parameters.
    @Sendable
    public func listWorkflows(_ input: ListWorkflowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowsResponse {
        return try await self.client.execute(
            operation: "ListWorkflows", 
            path: "/ListWorkflows", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Applies a policy to a component. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutComponentPolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    @Sendable
    public func putComponentPolicy(_ input: PutComponentPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutComponentPolicyResponse {
        return try await self.client.execute(
            operation: "PutComponentPolicy", 
            path: "/PutComponentPolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Applies a policy to a container image. We recommend that you call the RAM API
    /// 			CreateResourceShare
    /// 			(https://docs.aws.amazon.com//ram/latest/APIReference/API_CreateResourceShare.html) to share
    /// 			resources. If you call the Image Builder API PutContainerImagePolicy, you must also
    /// 			call the RAM API PromoteResourceShareCreatedFromPolicy
    /// 			(https://docs.aws.amazon.com//ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html)
    /// 			in order for the resource to be visible to all principals with whom the resource is
    /// 			shared.
    @Sendable
    public func putContainerRecipePolicy(_ input: PutContainerRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutContainerRecipePolicyResponse {
        return try await self.client.execute(
            operation: "PutContainerRecipePolicy", 
            path: "/PutContainerRecipePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Applies a policy to an image. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutImagePolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    @Sendable
    public func putImagePolicy(_ input: PutImagePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutImagePolicyResponse {
        return try await self.client.execute(
            operation: "PutImagePolicy", 
            path: "/PutImagePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Applies a policy to an image recipe. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutImageRecipePolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    @Sendable
    public func putImageRecipePolicy(_ input: PutImageRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutImageRecipePolicyResponse {
        return try await self.client.execute(
            operation: "PutImageRecipePolicy", 
            path: "/PutImageRecipePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Pauses or resumes image creation when the associated workflow runs a
    /// 			WaitForAction step.
    @Sendable
    public func sendWorkflowStepAction(_ input: SendWorkflowStepActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SendWorkflowStepActionResponse {
        return try await self.client.execute(
            operation: "SendWorkflowStepAction", 
            path: "/SendWorkflowStepAction", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Manually triggers a pipeline to create an image.
    @Sendable
    public func startImagePipelineExecution(_ input: StartImagePipelineExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartImagePipelineExecutionResponse {
        return try await self.client.execute(
            operation: "StartImagePipelineExecution", 
            path: "/StartImagePipelineExecution", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Begin asynchronous resource state update for lifecycle changes to the
    /// 			specified image resources.
    @Sendable
    public func startResourceStateUpdate(_ input: StartResourceStateUpdateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartResourceStateUpdateResponse {
        return try await self.client.execute(
            operation: "StartResourceStateUpdate", 
            path: "/StartResourceStateUpdate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Adds a tag to a resource.
    @Sendable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        return try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes a tag from a resource.
    @Sendable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        return try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates a new distribution configuration. Distribution configurations define and
    /// 			configure the outputs of your pipeline.
    @Sendable
    public func updateDistributionConfiguration(_ input: UpdateDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDistributionConfigurationResponse {
        return try await self.client.execute(
            operation: "UpdateDistributionConfiguration", 
            path: "/UpdateDistributionConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates an image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images. You must specify exactly one recipe for your image, using either
    /// 			a containerRecipeArn or an imageRecipeArn.  UpdateImagePipeline does not support selective updates for the pipeline. You must
    /// 				specify all of the required properties in the update request, not just the
    /// 				properties that have changed.
    @Sendable
    public func updateImagePipeline(_ input: UpdateImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateImagePipelineResponse {
        return try await self.client.execute(
            operation: "UpdateImagePipeline", 
            path: "/UpdateImagePipeline", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Updates a new infrastructure configuration. An infrastructure configuration defines
    /// 			the environment in which your image will be built and tested.
    @Sendable
    public func updateInfrastructureConfiguration(_ input: UpdateInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateInfrastructureConfigurationResponse {
        return try await self.client.execute(
            operation: "UpdateInfrastructureConfiguration", 
            path: "/UpdateInfrastructureConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Update the specified lifecycle policy.
    @Sendable
    public func updateLifecyclePolicy(_ input: UpdateLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLifecyclePolicyResponse {
        return try await self.client.execute(
            operation: "UpdateLifecyclePolicy", 
            path: "/UpdateLifecyclePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
}

extension Imagebuilder {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Imagebuilder, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Imagebuilder {
    /// Returns the list of component build versions for the specified semantic
    /// 			version.  The semantic version has four nodes: ../.
    /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listComponentBuildVersionsPaginator(
        _ input: ListComponentBuildVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListComponentBuildVersionsRequest, ListComponentBuildVersionsResponse> {
        return .init(
            input: input,
            command: self.listComponentBuildVersions,
            inputKey: \ListComponentBuildVersionsRequest.nextToken,
            outputKey: \ListComponentBuildVersionsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns the list of components that can be filtered by name, or by using the listed
    /// 				filters to streamline results. Newly created components can take up to
    /// 			two minutes to appear in the ListComponents API Results.  The semantic version has four nodes: ../.
    /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listComponentsPaginator(
        _ input: ListComponentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListComponentsRequest, ListComponentsResponse> {
        return .init(
            input: input,
            command: self.listComponents,
            inputKey: \ListComponentsRequest.nextToken,
            outputKey: \ListComponentsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of container recipes.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listContainerRecipesPaginator(
        _ input: ListContainerRecipesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListContainerRecipesRequest, ListContainerRecipesResponse> {
        return .init(
            input: input,
            command: self.listContainerRecipes,
            inputKey: \ListContainerRecipesRequest.nextToken,
            outputKey: \ListContainerRecipesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of distribution configurations.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listDistributionConfigurationsPaginator(
        _ input: ListDistributionConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDistributionConfigurationsRequest, ListDistributionConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listDistributionConfigurations,
            inputKey: \ListDistributionConfigurationsRequest.nextToken,
            outputKey: \ListDistributionConfigurationsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of image build versions.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImageBuildVersionsPaginator(
        _ input: ListImageBuildVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageBuildVersionsRequest, ListImageBuildVersionsResponse> {
        return .init(
            input: input,
            command: self.listImageBuildVersions,
            inputKey: \ListImageBuildVersionsRequest.nextToken,
            outputKey: \ListImageBuildVersionsResponse.nextToken,
            logger: logger
        )
    }

    /// List the Packages that are associated with an Image Build Version, as determined by
    /// 			Amazon Web Services Systems Manager Inventory at build time.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImagePackagesPaginator(
        _ input: ListImagePackagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagePackagesRequest, ListImagePackagesResponse> {
        return .init(
            input: input,
            command: self.listImagePackages,
            inputKey: \ListImagePackagesRequest.nextToken,
            outputKey: \ListImagePackagesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of images created by the specified pipeline.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImagePipelineImagesPaginator(
        _ input: ListImagePipelineImagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagePipelineImagesRequest, ListImagePipelineImagesResponse> {
        return .init(
            input: input,
            command: self.listImagePipelineImages,
            inputKey: \ListImagePipelineImagesRequest.nextToken,
            outputKey: \ListImagePipelineImagesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of image pipelines.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImagePipelinesPaginator(
        _ input: ListImagePipelinesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagePipelinesRequest, ListImagePipelinesResponse> {
        return .init(
            input: input,
            command: self.listImagePipelines,
            inputKey: \ListImagePipelinesRequest.nextToken,
            outputKey: \ListImagePipelinesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of image recipes.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImageRecipesPaginator(
        _ input: ListImageRecipesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageRecipesRequest, ListImageRecipesResponse> {
        return .init(
            input: input,
            command: self.listImageRecipes,
            inputKey: \ListImageRecipesRequest.nextToken,
            outputKey: \ListImageRecipesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of image scan aggregations for your account. You can filter by the type
    /// 			of key that Image Builder uses to group results. For example, if you want to get a list of
    /// 			findings by severity level for one of your pipelines, you might specify your pipeline
    /// 			with the imagePipelineArn filter. If you don't specify a filter, Image Builder
    /// 			returns an aggregation for your account. To streamline results, you can use the following filters in your request:    accountId     imageBuildVersionArn     imagePipelineArn     vulnerabilityId
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImageScanFindingAggregationsPaginator(
        _ input: ListImageScanFindingAggregationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageScanFindingAggregationsRequest, ListImageScanFindingAggregationsResponse> {
        return .init(
            input: input,
            command: self.listImageScanFindingAggregations,
            inputKey: \ListImageScanFindingAggregationsRequest.nextToken,
            outputKey: \ListImageScanFindingAggregationsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of image scan findings for your account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImageScanFindingsPaginator(
        _ input: ListImageScanFindingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageScanFindingsRequest, ListImageScanFindingsResponse> {
        return .init(
            input: input,
            command: self.listImageScanFindings,
            inputKey: \ListImageScanFindingsRequest.nextToken,
            outputKey: \ListImageScanFindingsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns the list of images that you have access to. Newly created images can take up
    /// 			to two minutes to appear in the ListImages API Results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listImagesPaginator(
        _ input: ListImagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagesRequest, ListImagesResponse> {
        return .init(
            input: input,
            command: self.listImages,
            inputKey: \ListImagesRequest.nextToken,
            outputKey: \ListImagesResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of infrastructure configurations.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listInfrastructureConfigurationsPaginator(
        _ input: ListInfrastructureConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInfrastructureConfigurationsRequest, ListInfrastructureConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listInfrastructureConfigurations,
            inputKey: \ListInfrastructureConfigurationsRequest.nextToken,
            outputKey: \ListInfrastructureConfigurationsResponse.nextToken,
            logger: logger
        )
    }

    /// List resources that the runtime instance of the image lifecycle identified for lifecycle actions.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listLifecycleExecutionResourcesPaginator(
        _ input: ListLifecycleExecutionResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLifecycleExecutionResourcesRequest, ListLifecycleExecutionResourcesResponse> {
        return .init(
            input: input,
            command: self.listLifecycleExecutionResources,
            inputKey: \ListLifecycleExecutionResourcesRequest.nextToken,
            outputKey: \ListLifecycleExecutionResourcesResponse.nextToken,
            logger: logger
        )
    }

    /// Get the lifecycle runtime history for the specified resource.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listLifecycleExecutionsPaginator(
        _ input: ListLifecycleExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLifecycleExecutionsRequest, ListLifecycleExecutionsResponse> {
        return .init(
            input: input,
            command: self.listLifecycleExecutions,
            inputKey: \ListLifecycleExecutionsRequest.nextToken,
            outputKey: \ListLifecycleExecutionsResponse.nextToken,
            logger: logger
        )
    }

    /// Get a list of lifecycle policies in your Amazon Web Services account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listLifecyclePoliciesPaginator(
        _ input: ListLifecyclePoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLifecyclePoliciesRequest, ListLifecyclePoliciesResponse> {
        return .init(
            input: input,
            command: self.listLifecyclePolicies,
            inputKey: \ListLifecyclePoliciesRequest.nextToken,
            outputKey: \ListLifecyclePoliciesResponse.nextToken,
            logger: logger
        )
    }

    /// Get a list of workflow steps that are waiting for action for workflows
    /// 			in your Amazon Web Services account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listWaitingWorkflowStepsPaginator(
        _ input: ListWaitingWorkflowStepsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWaitingWorkflowStepsRequest, ListWaitingWorkflowStepsResponse> {
        return .init(
            input: input,
            command: self.listWaitingWorkflowSteps,
            inputKey: \ListWaitingWorkflowStepsRequest.nextToken,
            outputKey: \ListWaitingWorkflowStepsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of build versions for a specific workflow resource.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listWorkflowBuildVersionsPaginator(
        _ input: ListWorkflowBuildVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowBuildVersionsRequest, ListWorkflowBuildVersionsResponse> {
        return .init(
            input: input,
            command: self.listWorkflowBuildVersions,
            inputKey: \ListWorkflowBuildVersionsRequest.nextToken,
            outputKey: \ListWorkflowBuildVersionsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of workflow runtime instance metadata objects for a specific image build
    /// 			version.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listWorkflowExecutionsPaginator(
        _ input: ListWorkflowExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowExecutionsRequest, ListWorkflowExecutionsResponse> {
        return .init(
            input: input,
            command: self.listWorkflowExecutions,
            inputKey: \ListWorkflowExecutionsRequest.nextToken,
            outputKey: \ListWorkflowExecutionsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns runtime data for each step in a runtime instance of the workflow
    /// 			that you specify in the request.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listWorkflowStepExecutionsPaginator(
        _ input: ListWorkflowStepExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowStepExecutionsRequest, ListWorkflowStepExecutionsResponse> {
        return .init(
            input: input,
            command: self.listWorkflowStepExecutions,
            inputKey: \ListWorkflowStepExecutionsRequest.nextToken,
            outputKey: \ListWorkflowStepExecutionsResponse.nextToken,
            logger: logger
        )
    }

    /// Lists workflow build versions based on filtering parameters.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func listWorkflowsPaginator(
        _ input: ListWorkflowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        return .init(
            input: input,
            command: self.listWorkflows,
            inputKey: \ListWorkflowsRequest.nextToken,
            outputKey: \ListWorkflowsResponse.nextToken,
            logger: logger
        )
    }
}

extension Imagebuilder.ListComponentBuildVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListComponentBuildVersionsRequest {
        return .init(
            componentVersionArn: self.componentVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListComponentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListComponentsRequest {
        return .init(
            byName: self.byName,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListContainerRecipesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListContainerRecipesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListDistributionConfigurationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListDistributionConfigurationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImageBuildVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageBuildVersionsRequest {
        return .init(
            filters: self.filters,
            imageVersionArn: self.imageVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagePackagesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagePackagesRequest {
        return .init(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagePipelineImagesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagePipelineImagesRequest {
        return .init(
            filters: self.filters,
            imagePipelineArn: self.imagePipelineArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagePipelinesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagePipelinesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImageRecipesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageRecipesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListImageScanFindingAggregationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageScanFindingAggregationsRequest {
        return .init(
            filter: self.filter,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImageScanFindingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageScanFindingsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagesRequest {
        return .init(
            byName: self.byName,
            filters: self.filters,
            includeDeprecated: self.includeDeprecated,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListInfrastructureConfigurationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListInfrastructureConfigurationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListLifecycleExecutionResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListLifecycleExecutionResourcesRequest {
        return .init(
            lifecycleExecutionId: self.lifecycleExecutionId,
            maxResults: self.maxResults,
            nextToken: token,
            parentResourceId: self.parentResourceId
        )
    }
}

extension Imagebuilder.ListLifecycleExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListLifecycleExecutionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension Imagebuilder.ListLifecyclePoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListLifecyclePoliciesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListWaitingWorkflowStepsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWaitingWorkflowStepsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListWorkflowBuildVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowBuildVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workflowVersionArn: self.workflowVersionArn
        )
    }
}

extension Imagebuilder.ListWorkflowExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowExecutionsRequest {
        return .init(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListWorkflowStepExecutionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowStepExecutionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workflowExecutionId: self.workflowExecutionId
        )
    }
}

extension Imagebuilder.ListWorkflowsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowsRequest {
        return .init(
            byName: self.byName,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}
