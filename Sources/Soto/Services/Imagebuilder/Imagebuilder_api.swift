//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Imagebuilder service.
///
/// EC2 Image Builder is a fully managed Amazon Web Services service that makes it easier to automate the
/// 			creation, management, and deployment of customized, secure, and up-to-date
/// 			"golden" server images that are pre-installed and pre-configured with software
/// 			and settings to meet specific IT standards.
public struct Imagebuilder: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Imagebuilder client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Imagebuilder",
            serviceIdentifier: "imagebuilder",
            serviceProtocol: .restjson,
            apiVersion: "2019-12-02",
            endpoint: endpoint,
            errorType: ImagebuilderErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// CancelImageCreation cancels the creation of Image. This operation can only be used on
    /// 			images in a non-terminal state.
    @Sendable
    @inlinable
    public func cancelImageCreation(_ input: CancelImageCreationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelImageCreationResponse {
        try await self.client.execute(
            operation: "CancelImageCreation", 
            path: "/CancelImageCreation", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// CancelImageCreation cancels the creation of Image. This operation can only be used on
    /// 			images in a non-terminal state.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - imageBuildVersionArn: The Amazon Resource Name (ARN) of the image that you want to cancel creation
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelImageCreation(
        clientToken: String = CancelImageCreationRequest.idempotencyToken(),
        imageBuildVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelImageCreationResponse {
        let input = CancelImageCreationRequest(
            clientToken: clientToken, 
            imageBuildVersionArn: imageBuildVersionArn
        )
        return try await self.cancelImageCreation(input, logger: logger)
    }

    /// Cancel a specific image lifecycle policy runtime instance.
    @Sendable
    @inlinable
    public func cancelLifecycleExecution(_ input: CancelLifecycleExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelLifecycleExecutionResponse {
        try await self.client.execute(
            operation: "CancelLifecycleExecution", 
            path: "/CancelLifecycleExecution", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancel a specific image lifecycle policy runtime instance.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - lifecycleExecutionId: Identifies the specific runtime instance of the image lifecycle to cancel.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelLifecycleExecution(
        clientToken: String = CancelLifecycleExecutionRequest.idempotencyToken(),
        lifecycleExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelLifecycleExecutionResponse {
        let input = CancelLifecycleExecutionRequest(
            clientToken: clientToken, 
            lifecycleExecutionId: lifecycleExecutionId
        )
        return try await self.cancelLifecycleExecution(input, logger: logger)
    }

    /// Creates a new component that can be used to build, validate, test, and assess your
    /// 			image. The component is based on a YAML document that you specify using exactly one of
    /// 			the following methods:   Inline, using the data property in the request body.   A URL that points to a YAML document file stored in Amazon S3, using the
    /// 						uri property in the request body.
    @Sendable
    @inlinable
    public func createComponent(_ input: CreateComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateComponentResponse {
        try await self.client.execute(
            operation: "CreateComponent", 
            path: "/CreateComponent", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new component that can be used to build, validate, test, and assess your
    /// 			image. The component is based on a YAML document that you specify using exactly one of
    /// 			the following methods:   Inline, using the data property in the request body.   A URL that points to a YAML document file stored in Amazon S3, using the
    /// 						uri property in the request body.
    ///
    /// Parameters:
    ///   - changeDescription: The change description of the component. Describes what change has been made in this
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - data: Component data contains inline YAML document content for the component.
    ///   - description: Describes the contents of the component.
    ///   - kmsKeyId: The ID of the KMS key that is used to encrypt this component.
    ///   - name: The name of the component.
    ///   - platform: The operating system platform of the component.
    ///   - semanticVersion: The semantic version of the component. This version follows the semantic version
    ///   - supportedOsVersions: The operating system (OS) version supported by the component. If the OS information is
    ///   - tags: The tags that apply to the component.
    ///   - uri: The uri of a YAML component document file. This must be an S3 URL
    ///   - logger: Logger use during operation
    @inlinable
    public func createComponent(
        changeDescription: String? = nil,
        clientToken: String = CreateComponentRequest.idempotencyToken(),
        data: String? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        name: String,
        platform: Platform,
        semanticVersion: String,
        supportedOsVersions: [String]? = nil,
        tags: [String: String]? = nil,
        uri: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateComponentResponse {
        let input = CreateComponentRequest(
            changeDescription: changeDescription, 
            clientToken: clientToken, 
            data: data, 
            description: description, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            platform: platform, 
            semanticVersion: semanticVersion, 
            supportedOsVersions: supportedOsVersions, 
            tags: tags, 
            uri: uri
        )
        return try await self.createComponent(input, logger: logger)
    }

    /// Creates a new container recipe. Container recipes define how images are configured,
    /// 			tested, and assessed.
    @Sendable
    @inlinable
    public func createContainerRecipe(_ input: CreateContainerRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateContainerRecipeResponse {
        try await self.client.execute(
            operation: "CreateContainerRecipe", 
            path: "/CreateContainerRecipe", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new container recipe. Container recipes define how images are configured,
    /// 			tested, and assessed.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - components: Components for build and test that are included in the container recipe.
    ///   - containerType: The type of container to create.
    ///   - description: The description of the container recipe.
    ///   - dockerfileTemplateData: The Dockerfile template used to build your image as an inline data blob.
    ///   - dockerfileTemplateUri: The Amazon S3 URI for the Dockerfile that will be used to build your container
    ///   - imageOsVersionOverride: Specifies the operating system version for the base image.
    ///   - instanceConfiguration: A group of options that can be used to configure an instance for building and testing
    ///   - kmsKeyId: Identifies which KMS key is used to encrypt the Dockerfile template.
    ///   - name: The name of the container recipe.
    ///   - parentImage: The base image for the container recipe.
    ///   - platformOverride: Specifies the operating system platform when you use a custom base image.
    ///   - semanticVersion: The semantic version of the container recipe. This version follows the semantic
    ///   - tags: Tags that are attached to the container recipe.
    ///   - targetRepository: The destination repository for the container image.
    ///   - workingDirectory: The working directory for use during build and test workflows.
    ///   - logger: Logger use during operation
    @inlinable
    public func createContainerRecipe(
        clientToken: String = CreateContainerRecipeRequest.idempotencyToken(),
        components: [ComponentConfiguration],
        containerType: ContainerType,
        description: String? = nil,
        dockerfileTemplateData: String? = nil,
        dockerfileTemplateUri: String? = nil,
        imageOsVersionOverride: String? = nil,
        instanceConfiguration: InstanceConfiguration? = nil,
        kmsKeyId: String? = nil,
        name: String,
        parentImage: String,
        platformOverride: Platform? = nil,
        semanticVersion: String,
        tags: [String: String]? = nil,
        targetRepository: TargetContainerRepository,
        workingDirectory: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateContainerRecipeResponse {
        let input = CreateContainerRecipeRequest(
            clientToken: clientToken, 
            components: components, 
            containerType: containerType, 
            description: description, 
            dockerfileTemplateData: dockerfileTemplateData, 
            dockerfileTemplateUri: dockerfileTemplateUri, 
            imageOsVersionOverride: imageOsVersionOverride, 
            instanceConfiguration: instanceConfiguration, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            parentImage: parentImage, 
            platformOverride: platformOverride, 
            semanticVersion: semanticVersion, 
            tags: tags, 
            targetRepository: targetRepository, 
            workingDirectory: workingDirectory
        )
        return try await self.createContainerRecipe(input, logger: logger)
    }

    /// Creates a new distribution configuration. Distribution configurations define and
    /// 			configure the outputs of your pipeline.
    @Sendable
    @inlinable
    public func createDistributionConfiguration(_ input: CreateDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDistributionConfigurationResponse {
        try await self.client.execute(
            operation: "CreateDistributionConfiguration", 
            path: "/CreateDistributionConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new distribution configuration. Distribution configurations define and
    /// 			configure the outputs of your pipeline.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: The description of the distribution configuration.
    ///   - distributions: The distributions of the distribution configuration.
    ///   - name: The name of the distribution configuration.
    ///   - tags: The tags of the distribution configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDistributionConfiguration(
        clientToken: String = CreateDistributionConfigurationRequest.idempotencyToken(),
        description: String? = nil,
        distributions: [Distribution],
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDistributionConfigurationResponse {
        let input = CreateDistributionConfigurationRequest(
            clientToken: clientToken, 
            description: description, 
            distributions: distributions, 
            name: name, 
            tags: tags
        )
        return try await self.createDistributionConfiguration(input, logger: logger)
    }

    /// Creates a new image. This request will create a new image along with all of the
    /// 			configured output resources defined in the distribution configuration. You must specify
    /// 			exactly one recipe for your image, using either a ContainerRecipeArn or an
    /// 			ImageRecipeArn.
    @Sendable
    @inlinable
    public func createImage(_ input: CreateImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateImageResponse {
        try await self.client.execute(
            operation: "CreateImage", 
            path: "/CreateImage", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new image. This request will create a new image along with all of the
    /// 			configured output resources defined in the distribution configuration. You must specify
    /// 			exactly one recipe for your image, using either a ContainerRecipeArn or an
    /// 			ImageRecipeArn.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - containerRecipeArn: The Amazon Resource Name (ARN) of the container recipe that defines how images are
    ///   - distributionConfigurationArn: The Amazon Resource Name (ARN) of the distribution configuration that defines and
    ///   - enhancedImageMetadataEnabled: Collects additional information about the image being created, including the operating
    ///   - executionRole: The name or Amazon Resource Name (ARN) for the IAM role you create that grants
    ///   - imageRecipeArn: The Amazon Resource Name (ARN) of the image recipe that defines how images are
    ///   - imageScanningConfiguration: Contains settings for vulnerability scans.
    ///   - imageTestsConfiguration: The image tests configuration of the image.
    ///   - infrastructureConfigurationArn: The Amazon Resource Name (ARN) of the infrastructure configuration that defines the
    ///   - tags: The tags of the image.
    ///   - workflows: Contains an array of workflow configuration objects.
    ///   - logger: Logger use during operation
    @inlinable
    public func createImage(
        clientToken: String = CreateImageRequest.idempotencyToken(),
        containerRecipeArn: String? = nil,
        distributionConfigurationArn: String? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        executionRole: String? = nil,
        imageRecipeArn: String? = nil,
        imageScanningConfiguration: ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: String,
        tags: [String: String]? = nil,
        workflows: [WorkflowConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateImageResponse {
        let input = CreateImageRequest(
            clientToken: clientToken, 
            containerRecipeArn: containerRecipeArn, 
            distributionConfigurationArn: distributionConfigurationArn, 
            enhancedImageMetadataEnabled: enhancedImageMetadataEnabled, 
            executionRole: executionRole, 
            imageRecipeArn: imageRecipeArn, 
            imageScanningConfiguration: imageScanningConfiguration, 
            imageTestsConfiguration: imageTestsConfiguration, 
            infrastructureConfigurationArn: infrastructureConfigurationArn, 
            tags: tags, 
            workflows: workflows
        )
        return try await self.createImage(input, logger: logger)
    }

    /// Creates a new image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images.
    @Sendable
    @inlinable
    public func createImagePipeline(_ input: CreateImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateImagePipelineResponse {
        try await self.client.execute(
            operation: "CreateImagePipeline", 
            path: "/CreateImagePipeline", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - containerRecipeArn: The Amazon Resource Name (ARN) of the container recipe that is used to configure
    ///   - description: The description of the image pipeline.
    ///   - distributionConfigurationArn: The Amazon Resource Name (ARN) of the distribution configuration that will be used to
    ///   - enhancedImageMetadataEnabled: Collects additional information about the image being created, including the operating
    ///   - executionRole: The name or Amazon Resource Name (ARN) for the IAM role you create that grants
    ///   - imageRecipeArn: The Amazon Resource Name (ARN) of the image recipe that will be used to configure
    ///   - imageScanningConfiguration: Contains settings for vulnerability scans.
    ///   - imageTestsConfiguration: The image test configuration of the image pipeline.
    ///   - infrastructureConfigurationArn: The Amazon Resource Name (ARN) of the infrastructure configuration that will be used
    ///   - name: The name of the image pipeline.
    ///   - schedule: The schedule of the image pipeline.
    ///   - status: The status of the image pipeline.
    ///   - tags: The tags of the image pipeline.
    ///   - workflows: Contains an array of workflow configuration objects.
    ///   - logger: Logger use during operation
    @inlinable
    public func createImagePipeline(
        clientToken: String = CreateImagePipelineRequest.idempotencyToken(),
        containerRecipeArn: String? = nil,
        description: String? = nil,
        distributionConfigurationArn: String? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        executionRole: String? = nil,
        imageRecipeArn: String? = nil,
        imageScanningConfiguration: ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: String,
        name: String,
        schedule: Schedule? = nil,
        status: PipelineStatus? = nil,
        tags: [String: String]? = nil,
        workflows: [WorkflowConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateImagePipelineResponse {
        let input = CreateImagePipelineRequest(
            clientToken: clientToken, 
            containerRecipeArn: containerRecipeArn, 
            description: description, 
            distributionConfigurationArn: distributionConfigurationArn, 
            enhancedImageMetadataEnabled: enhancedImageMetadataEnabled, 
            executionRole: executionRole, 
            imageRecipeArn: imageRecipeArn, 
            imageScanningConfiguration: imageScanningConfiguration, 
            imageTestsConfiguration: imageTestsConfiguration, 
            infrastructureConfigurationArn: infrastructureConfigurationArn, 
            name: name, 
            schedule: schedule, 
            status: status, 
            tags: tags, 
            workflows: workflows
        )
        return try await self.createImagePipeline(input, logger: logger)
    }

    /// Creates a new image recipe. Image recipes define how images are configured, tested,
    /// 			and assessed.
    @Sendable
    @inlinable
    public func createImageRecipe(_ input: CreateImageRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateImageRecipeResponse {
        try await self.client.execute(
            operation: "CreateImageRecipe", 
            path: "/CreateImageRecipe", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new image recipe. Image recipes define how images are configured, tested,
    /// 			and assessed.
    ///
    /// Parameters:
    ///   - additionalInstanceConfiguration: Specify additional settings and launch scripts for your build instances.
    ///   - blockDeviceMappings: The block device mappings of the image recipe.
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - components: The components included in the image recipe.
    ///   - description: The description of the image recipe.
    ///   - name: The name of the image recipe.
    ///   - parentImage: The base image of the image recipe. The value of the string can be the ARN of the base
    ///   - semanticVersion: The semantic version of the image recipe. This version follows the semantic version
    ///   - tags: The tags of the image recipe.
    ///   - workingDirectory: The working directory used during build and test workflows.
    ///   - logger: Logger use during operation
    @inlinable
    public func createImageRecipe(
        additionalInstanceConfiguration: AdditionalInstanceConfiguration? = nil,
        blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil,
        clientToken: String = CreateImageRecipeRequest.idempotencyToken(),
        components: [ComponentConfiguration],
        description: String? = nil,
        name: String,
        parentImage: String,
        semanticVersion: String,
        tags: [String: String]? = nil,
        workingDirectory: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateImageRecipeResponse {
        let input = CreateImageRecipeRequest(
            additionalInstanceConfiguration: additionalInstanceConfiguration, 
            blockDeviceMappings: blockDeviceMappings, 
            clientToken: clientToken, 
            components: components, 
            description: description, 
            name: name, 
            parentImage: parentImage, 
            semanticVersion: semanticVersion, 
            tags: tags, 
            workingDirectory: workingDirectory
        )
        return try await self.createImageRecipe(input, logger: logger)
    }

    /// Creates a new infrastructure configuration. An infrastructure configuration defines
    /// 			the environment in which your image will be built and tested.
    @Sendable
    @inlinable
    public func createInfrastructureConfiguration(_ input: CreateInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInfrastructureConfigurationResponse {
        try await self.client.execute(
            operation: "CreateInfrastructureConfiguration", 
            path: "/CreateInfrastructureConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new infrastructure configuration. An infrastructure configuration defines
    /// 			the environment in which your image will be built and tested.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: The description of the infrastructure configuration.
    ///   - instanceMetadataOptions: The instance metadata options that you can set for the HTTP requests that pipeline
    ///   - instanceProfileName: The instance profile to associate with the instance used to customize your Amazon EC2
    ///   - instanceTypes: The instance types of the infrastructure configuration. You can specify one or more
    ///   - keyPair: The key pair of the infrastructure configuration. You can use this to log on to and
    ///   - logging: The logging configuration of the infrastructure configuration.
    ///   - name: The name of the infrastructure configuration.
    ///   - placement: The instance placement settings that define where the instances that are launched
    ///   - resourceTags: The metadata tags to assign to the Amazon EC2 instance that Image Builder launches during the build process.
    ///   - securityGroupIds: The security group IDs to associate with the instance used to customize your Amazon EC2
    ///   - snsTopicArn: The Amazon Resource Name (ARN) for the SNS topic to which we send image build event
    ///   - subnetId: The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
    ///   - tags: The metadata tags to assign to the infrastructure configuration resource that Image Builder
    ///   - terminateInstanceOnFailure: The terminate instance on failure setting of the infrastructure configuration. Set to
    ///   - logger: Logger use during operation
    @inlinable
    public func createInfrastructureConfiguration(
        clientToken: String = CreateInfrastructureConfigurationRequest.idempotencyToken(),
        description: String? = nil,
        instanceMetadataOptions: InstanceMetadataOptions? = nil,
        instanceProfileName: String,
        instanceTypes: [String]? = nil,
        keyPair: String? = nil,
        logging: Logging? = nil,
        name: String,
        placement: Placement? = nil,
        resourceTags: [String: String]? = nil,
        securityGroupIds: [String]? = nil,
        snsTopicArn: String? = nil,
        subnetId: String? = nil,
        tags: [String: String]? = nil,
        terminateInstanceOnFailure: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateInfrastructureConfigurationResponse {
        let input = CreateInfrastructureConfigurationRequest(
            clientToken: clientToken, 
            description: description, 
            instanceMetadataOptions: instanceMetadataOptions, 
            instanceProfileName: instanceProfileName, 
            instanceTypes: instanceTypes, 
            keyPair: keyPair, 
            logging: logging, 
            name: name, 
            placement: placement, 
            resourceTags: resourceTags, 
            securityGroupIds: securityGroupIds, 
            snsTopicArn: snsTopicArn, 
            subnetId: subnetId, 
            tags: tags, 
            terminateInstanceOnFailure: terminateInstanceOnFailure
        )
        return try await self.createInfrastructureConfiguration(input, logger: logger)
    }

    /// Create a lifecycle policy resource.
    @Sendable
    @inlinable
    public func createLifecyclePolicy(_ input: CreateLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLifecyclePolicyResponse {
        try await self.client.execute(
            operation: "CreateLifecyclePolicy", 
            path: "/CreateLifecyclePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a lifecycle policy resource.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: Optional description for the lifecycle policy.
    ///   - executionRole: The name or Amazon Resource Name (ARN) for the IAM role you create that grants
    ///   - name: The name of the  lifecycle policy to create.
    ///   - policyDetails: Configuration details for the lifecycle policy rules.
    ///   - resourceSelection: Selection criteria for the resources that the lifecycle policy applies to.
    ///   - resourceType: The type of Image Builder resource that the lifecycle policy applies to.
    ///   - status: Indicates whether the lifecycle policy resource is enabled.
    ///   - tags: Tags to apply to the lifecycle policy resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLifecyclePolicy(
        clientToken: String = CreateLifecyclePolicyRequest.idempotencyToken(),
        description: String? = nil,
        executionRole: String,
        name: String,
        policyDetails: [LifecyclePolicyDetail],
        resourceSelection: LifecyclePolicyResourceSelection,
        resourceType: LifecyclePolicyResourceType,
        status: LifecyclePolicyStatus? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLifecyclePolicyResponse {
        let input = CreateLifecyclePolicyRequest(
            clientToken: clientToken, 
            description: description, 
            executionRole: executionRole, 
            name: name, 
            policyDetails: policyDetails, 
            resourceSelection: resourceSelection, 
            resourceType: resourceType, 
            status: status, 
            tags: tags
        )
        return try await self.createLifecyclePolicy(input, logger: logger)
    }

    /// Create a new workflow or a new version of an existing workflow.
    @Sendable
    @inlinable
    public func createWorkflow(_ input: CreateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkflowResponse {
        try await self.client.execute(
            operation: "CreateWorkflow", 
            path: "/CreateWorkflow", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new workflow or a new version of an existing workflow.
    ///
    /// Parameters:
    ///   - changeDescription: Describes what change has been made in this version of the workflow, or
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - data: Contains the UTF-8 encoded YAML document content for the workflow.
    ///   - description: Describes the workflow.
    ///   - kmsKeyId: The ID of the KMS key that is used to encrypt this workflow resource.
    ///   - name: The name of the workflow to create.
    ///   - semanticVersion: The semantic version of this workflow resource. The semantic version syntax
    ///   - tags: Tags that apply to the workflow resource.
    ///   - type: The phase in the image build process for which the workflow resource
    ///   - uri: The uri of a YAML component document file. This must be an S3 URL
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkflow(
        changeDescription: String? = nil,
        clientToken: String = CreateWorkflowRequest.idempotencyToken(),
        data: String? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        name: String,
        semanticVersion: String,
        tags: [String: String]? = nil,
        type: WorkflowType,
        uri: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkflowResponse {
        let input = CreateWorkflowRequest(
            changeDescription: changeDescription, 
            clientToken: clientToken, 
            data: data, 
            description: description, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            semanticVersion: semanticVersion, 
            tags: tags, 
            type: type, 
            uri: uri
        )
        return try await self.createWorkflow(input, logger: logger)
    }

    /// Deletes a component build version.
    @Sendable
    @inlinable
    public func deleteComponent(_ input: DeleteComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteComponentResponse {
        try await self.client.execute(
            operation: "DeleteComponent", 
            path: "/DeleteComponent", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a component build version.
    ///
    /// Parameters:
    ///   - componentBuildVersionArn: The Amazon Resource Name (ARN) of the component build version to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteComponent(
        componentBuildVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteComponentResponse {
        let input = DeleteComponentRequest(
            componentBuildVersionArn: componentBuildVersionArn
        )
        return try await self.deleteComponent(input, logger: logger)
    }

    /// Deletes a container recipe.
    @Sendable
    @inlinable
    public func deleteContainerRecipe(_ input: DeleteContainerRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteContainerRecipeResponse {
        try await self.client.execute(
            operation: "DeleteContainerRecipe", 
            path: "/DeleteContainerRecipe", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a container recipe.
    ///
    /// Parameters:
    ///   - containerRecipeArn: The Amazon Resource Name (ARN) of the container recipe to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteContainerRecipe(
        containerRecipeArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteContainerRecipeResponse {
        let input = DeleteContainerRecipeRequest(
            containerRecipeArn: containerRecipeArn
        )
        return try await self.deleteContainerRecipe(input, logger: logger)
    }

    /// Deletes a distribution configuration.
    @Sendable
    @inlinable
    public func deleteDistributionConfiguration(_ input: DeleteDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDistributionConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteDistributionConfiguration", 
            path: "/DeleteDistributionConfiguration", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a distribution configuration.
    ///
    /// Parameters:
    ///   - distributionConfigurationArn: The Amazon Resource Name (ARN) of the distribution configuration to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDistributionConfiguration(
        distributionConfigurationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDistributionConfigurationResponse {
        let input = DeleteDistributionConfigurationRequest(
            distributionConfigurationArn: distributionConfigurationArn
        )
        return try await self.deleteDistributionConfiguration(input, logger: logger)
    }

    /// Deletes an Image Builder image resource. This does not delete any EC2 AMIs or ECR container
    /// 			images that are created during the image build process. You must clean those up
    /// 			separately, using the appropriate Amazon EC2 or Amazon ECR console actions, or API or CLI
    /// 			commands.   To deregister an EC2 Linux AMI, see Deregister your
    /// 						Linux AMI in the  Amazon EC2 User Guide .   To deregister an EC2 Windows AMI, see Deregister your
    /// 						Windows AMI in the  Amazon EC2 Windows Guide .   To delete a container image from Amazon ECR, see Deleting
    /// 						an image in the Amazon ECR User Guide.
    @Sendable
    @inlinable
    public func deleteImage(_ input: DeleteImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImageResponse {
        try await self.client.execute(
            operation: "DeleteImage", 
            path: "/DeleteImage", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Image Builder image resource. This does not delete any EC2 AMIs or ECR container
    /// 			images that are created during the image build process. You must clean those up
    /// 			separately, using the appropriate Amazon EC2 or Amazon ECR console actions, or API or CLI
    /// 			commands.   To deregister an EC2 Linux AMI, see Deregister your
    /// 						Linux AMI in the  Amazon EC2 User Guide .   To deregister an EC2 Windows AMI, see Deregister your
    /// 						Windows AMI in the  Amazon EC2 Windows Guide .   To delete a container image from Amazon ECR, see Deleting
    /// 						an image in the Amazon ECR User Guide.
    ///
    /// Parameters:
    ///   - imageBuildVersionArn: The Amazon Resource Name (ARN) of the Image Builder image resource to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteImage(
        imageBuildVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteImageResponse {
        let input = DeleteImageRequest(
            imageBuildVersionArn: imageBuildVersionArn
        )
        return try await self.deleteImage(input, logger: logger)
    }

    /// Deletes an image pipeline.
    @Sendable
    @inlinable
    public func deleteImagePipeline(_ input: DeleteImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImagePipelineResponse {
        try await self.client.execute(
            operation: "DeleteImagePipeline", 
            path: "/DeleteImagePipeline", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an image pipeline.
    ///
    /// Parameters:
    ///   - imagePipelineArn: The Amazon Resource Name (ARN) of the image pipeline to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteImagePipeline(
        imagePipelineArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteImagePipelineResponse {
        let input = DeleteImagePipelineRequest(
            imagePipelineArn: imagePipelineArn
        )
        return try await self.deleteImagePipeline(input, logger: logger)
    }

    /// Deletes an image recipe.
    @Sendable
    @inlinable
    public func deleteImageRecipe(_ input: DeleteImageRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteImageRecipeResponse {
        try await self.client.execute(
            operation: "DeleteImageRecipe", 
            path: "/DeleteImageRecipe", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an image recipe.
    ///
    /// Parameters:
    ///   - imageRecipeArn: The Amazon Resource Name (ARN) of the image recipe to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteImageRecipe(
        imageRecipeArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteImageRecipeResponse {
        let input = DeleteImageRecipeRequest(
            imageRecipeArn: imageRecipeArn
        )
        return try await self.deleteImageRecipe(input, logger: logger)
    }

    /// Deletes an infrastructure configuration.
    @Sendable
    @inlinable
    public func deleteInfrastructureConfiguration(_ input: DeleteInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteInfrastructureConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteInfrastructureConfiguration", 
            path: "/DeleteInfrastructureConfiguration", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an infrastructure configuration.
    ///
    /// Parameters:
    ///   - infrastructureConfigurationArn: The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteInfrastructureConfiguration(
        infrastructureConfigurationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteInfrastructureConfigurationResponse {
        let input = DeleteInfrastructureConfigurationRequest(
            infrastructureConfigurationArn: infrastructureConfigurationArn
        )
        return try await self.deleteInfrastructureConfiguration(input, logger: logger)
    }

    /// Delete the specified lifecycle policy resource.
    @Sendable
    @inlinable
    public func deleteLifecyclePolicy(_ input: DeleteLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLifecyclePolicyResponse {
        try await self.client.execute(
            operation: "DeleteLifecyclePolicy", 
            path: "/DeleteLifecyclePolicy", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete the specified lifecycle policy resource.
    ///
    /// Parameters:
    ///   - lifecyclePolicyArn: The Amazon Resource Name (ARN) of the lifecycle policy resource to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLifecyclePolicy(
        lifecyclePolicyArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLifecyclePolicyResponse {
        let input = DeleteLifecyclePolicyRequest(
            lifecyclePolicyArn: lifecyclePolicyArn
        )
        return try await self.deleteLifecyclePolicy(input, logger: logger)
    }

    /// Deletes a specific workflow resource.
    @Sendable
    @inlinable
    public func deleteWorkflow(_ input: DeleteWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWorkflowResponse {
        try await self.client.execute(
            operation: "DeleteWorkflow", 
            path: "/DeleteWorkflow", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specific workflow resource.
    ///
    /// Parameters:
    ///   - workflowBuildVersionArn: The Amazon Resource Name (ARN) of the workflow resource to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkflow(
        workflowBuildVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteWorkflowResponse {
        let input = DeleteWorkflowRequest(
            workflowBuildVersionArn: workflowBuildVersionArn
        )
        return try await self.deleteWorkflow(input, logger: logger)
    }

    /// Gets a component object.
    @Sendable
    @inlinable
    public func getComponent(_ input: GetComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetComponentResponse {
        try await self.client.execute(
            operation: "GetComponent", 
            path: "/GetComponent", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a component object.
    ///
    /// Parameters:
    ///   - componentBuildVersionArn: The Amazon Resource Name (ARN) of the component that you want to get. Regex requires
    ///   - logger: Logger use during operation
    @inlinable
    public func getComponent(
        componentBuildVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetComponentResponse {
        let input = GetComponentRequest(
            componentBuildVersionArn: componentBuildVersionArn
        )
        return try await self.getComponent(input, logger: logger)
    }

    /// Gets a component policy.
    @Sendable
    @inlinable
    public func getComponentPolicy(_ input: GetComponentPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetComponentPolicyResponse {
        try await self.client.execute(
            operation: "GetComponentPolicy", 
            path: "/GetComponentPolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a component policy.
    ///
    /// Parameters:
    ///   - componentArn: The Amazon Resource Name (ARN) of the component whose policy you want to
    ///   - logger: Logger use during operation
    @inlinable
    public func getComponentPolicy(
        componentArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetComponentPolicyResponse {
        let input = GetComponentPolicyRequest(
            componentArn: componentArn
        )
        return try await self.getComponentPolicy(input, logger: logger)
    }

    /// Retrieves a container recipe.
    @Sendable
    @inlinable
    public func getContainerRecipe(_ input: GetContainerRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetContainerRecipeResponse {
        try await self.client.execute(
            operation: "GetContainerRecipe", 
            path: "/GetContainerRecipe", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a container recipe.
    ///
    /// Parameters:
    ///   - containerRecipeArn: The Amazon Resource Name (ARN) of the container recipe to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getContainerRecipe(
        containerRecipeArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetContainerRecipeResponse {
        let input = GetContainerRecipeRequest(
            containerRecipeArn: containerRecipeArn
        )
        return try await self.getContainerRecipe(input, logger: logger)
    }

    /// Retrieves the policy for a container recipe.
    @Sendable
    @inlinable
    public func getContainerRecipePolicy(_ input: GetContainerRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetContainerRecipePolicyResponse {
        try await self.client.execute(
            operation: "GetContainerRecipePolicy", 
            path: "/GetContainerRecipePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the policy for a container recipe.
    ///
    /// Parameters:
    ///   - containerRecipeArn: The Amazon Resource Name (ARN) of the container recipe for the policy being
    ///   - logger: Logger use during operation
    @inlinable
    public func getContainerRecipePolicy(
        containerRecipeArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetContainerRecipePolicyResponse {
        let input = GetContainerRecipePolicyRequest(
            containerRecipeArn: containerRecipeArn
        )
        return try await self.getContainerRecipePolicy(input, logger: logger)
    }

    /// Gets a distribution configuration.
    @Sendable
    @inlinable
    public func getDistributionConfiguration(_ input: GetDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDistributionConfigurationResponse {
        try await self.client.execute(
            operation: "GetDistributionConfiguration", 
            path: "/GetDistributionConfiguration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a distribution configuration.
    ///
    /// Parameters:
    ///   - distributionConfigurationArn: The Amazon Resource Name (ARN) of the distribution configuration that you want to
    ///   - logger: Logger use during operation
    @inlinable
    public func getDistributionConfiguration(
        distributionConfigurationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDistributionConfigurationResponse {
        let input = GetDistributionConfigurationRequest(
            distributionConfigurationArn: distributionConfigurationArn
        )
        return try await self.getDistributionConfiguration(input, logger: logger)
    }

    /// Gets an image.
    @Sendable
    @inlinable
    public func getImage(_ input: GetImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImageResponse {
        try await self.client.execute(
            operation: "GetImage", 
            path: "/GetImage", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an image.
    ///
    /// Parameters:
    ///   - imageBuildVersionArn: The Amazon Resource Name (ARN) of the image that you want to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func getImage(
        imageBuildVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetImageResponse {
        let input = GetImageRequest(
            imageBuildVersionArn: imageBuildVersionArn
        )
        return try await self.getImage(input, logger: logger)
    }

    /// Gets an image pipeline.
    @Sendable
    @inlinable
    public func getImagePipeline(_ input: GetImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImagePipelineResponse {
        try await self.client.execute(
            operation: "GetImagePipeline", 
            path: "/GetImagePipeline", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an image pipeline.
    ///
    /// Parameters:
    ///   - imagePipelineArn: The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getImagePipeline(
        imagePipelineArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetImagePipelineResponse {
        let input = GetImagePipelineRequest(
            imagePipelineArn: imagePipelineArn
        )
        return try await self.getImagePipeline(input, logger: logger)
    }

    /// Gets an image policy.
    @Sendable
    @inlinable
    public func getImagePolicy(_ input: GetImagePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImagePolicyResponse {
        try await self.client.execute(
            operation: "GetImagePolicy", 
            path: "/GetImagePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an image policy.
    ///
    /// Parameters:
    ///   - imageArn: The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getImagePolicy(
        imageArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetImagePolicyResponse {
        let input = GetImagePolicyRequest(
            imageArn: imageArn
        )
        return try await self.getImagePolicy(input, logger: logger)
    }

    /// Gets an image recipe.
    @Sendable
    @inlinable
    public func getImageRecipe(_ input: GetImageRecipeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImageRecipeResponse {
        try await self.client.execute(
            operation: "GetImageRecipe", 
            path: "/GetImageRecipe", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an image recipe.
    ///
    /// Parameters:
    ///   - imageRecipeArn: The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getImageRecipe(
        imageRecipeArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetImageRecipeResponse {
        let input = GetImageRecipeRequest(
            imageRecipeArn: imageRecipeArn
        )
        return try await self.getImageRecipe(input, logger: logger)
    }

    /// Gets an image recipe policy.
    @Sendable
    @inlinable
    public func getImageRecipePolicy(_ input: GetImageRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetImageRecipePolicyResponse {
        try await self.client.execute(
            operation: "GetImageRecipePolicy", 
            path: "/GetImageRecipePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an image recipe policy.
    ///
    /// Parameters:
    ///   - imageRecipeArn: The Amazon Resource Name (ARN) of the image recipe whose policy you want to
    ///   - logger: Logger use during operation
    @inlinable
    public func getImageRecipePolicy(
        imageRecipeArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetImageRecipePolicyResponse {
        let input = GetImageRecipePolicyRequest(
            imageRecipeArn: imageRecipeArn
        )
        return try await self.getImageRecipePolicy(input, logger: logger)
    }

    /// Gets an infrastructure configuration.
    @Sendable
    @inlinable
    public func getInfrastructureConfiguration(_ input: GetInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetInfrastructureConfigurationResponse {
        try await self.client.execute(
            operation: "GetInfrastructureConfiguration", 
            path: "/GetInfrastructureConfiguration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an infrastructure configuration.
    ///
    /// Parameters:
    ///   - infrastructureConfigurationArn: The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
    ///   - logger: Logger use during operation
    @inlinable
    public func getInfrastructureConfiguration(
        infrastructureConfigurationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetInfrastructureConfigurationResponse {
        let input = GetInfrastructureConfigurationRequest(
            infrastructureConfigurationArn: infrastructureConfigurationArn
        )
        return try await self.getInfrastructureConfiguration(input, logger: logger)
    }

    /// Get the runtime information that was logged for a specific runtime instance of the lifecycle policy.
    @Sendable
    @inlinable
    public func getLifecycleExecution(_ input: GetLifecycleExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLifecycleExecutionResponse {
        try await self.client.execute(
            operation: "GetLifecycleExecution", 
            path: "/GetLifecycleExecution", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the runtime information that was logged for a specific runtime instance of the lifecycle policy.
    ///
    /// Parameters:
    ///   - lifecycleExecutionId: Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLifecycleExecution(
        lifecycleExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLifecycleExecutionResponse {
        let input = GetLifecycleExecutionRequest(
            lifecycleExecutionId: lifecycleExecutionId
        )
        return try await self.getLifecycleExecution(input, logger: logger)
    }

    /// Get details for the specified image lifecycle policy.
    @Sendable
    @inlinable
    public func getLifecyclePolicy(_ input: GetLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLifecyclePolicyResponse {
        try await self.client.execute(
            operation: "GetLifecyclePolicy", 
            path: "/GetLifecyclePolicy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get details for the specified image lifecycle policy.
    ///
    /// Parameters:
    ///   - lifecyclePolicyArn: Specifies the Amazon Resource Name (ARN) of the image lifecycle policy resource to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLifecyclePolicy(
        lifecyclePolicyArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLifecyclePolicyResponse {
        let input = GetLifecyclePolicyRequest(
            lifecyclePolicyArn: lifecyclePolicyArn
        )
        return try await self.getLifecyclePolicy(input, logger: logger)
    }

    /// Verify the subscription and perform resource dependency checks on the requested
    /// 			Amazon Web Services Marketplace resource. For Amazon Web Services Marketplace components, the response contains fields to download the
    /// 			components and their artifacts.
    @Sendable
    @inlinable
    public func getMarketplaceResource(_ input: GetMarketplaceResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMarketplaceResourceResponse {
        try await self.client.execute(
            operation: "GetMarketplaceResource", 
            path: "/GetMarketplaceResource", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Verify the subscription and perform resource dependency checks on the requested
    /// 			Amazon Web Services Marketplace resource. For Amazon Web Services Marketplace components, the response contains fields to download the
    /// 			components and their artifacts.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) that uniquely identifies an Amazon Web Services Marketplace resource.
    ///   - resourceLocation: The bucket path that you can specify to download the resource from Amazon S3.
    ///   - resourceType: Specifies which type of Amazon Web Services Marketplace resource Image Builder retrieves.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMarketplaceResource(
        resourceArn: String,
        resourceLocation: String? = nil,
        resourceType: MarketplaceResourceType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMarketplaceResourceResponse {
        let input = GetMarketplaceResourceRequest(
            resourceArn: resourceArn, 
            resourceLocation: resourceLocation, 
            resourceType: resourceType
        )
        return try await self.getMarketplaceResource(input, logger: logger)
    }

    /// Get a workflow resource object.
    @Sendable
    @inlinable
    public func getWorkflow(_ input: GetWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowResponse {
        try await self.client.execute(
            operation: "GetWorkflow", 
            path: "/GetWorkflow", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a workflow resource object.
    ///
    /// Parameters:
    ///   - workflowBuildVersionArn: The Amazon Resource Name (ARN) of the workflow resource that you want to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflow(
        workflowBuildVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowResponse {
        let input = GetWorkflowRequest(
            workflowBuildVersionArn: workflowBuildVersionArn
        )
        return try await self.getWorkflow(input, logger: logger)
    }

    /// Get the runtime information that was logged for a specific runtime instance
    /// 			of the workflow.
    @Sendable
    @inlinable
    public func getWorkflowExecution(_ input: GetWorkflowExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowExecutionResponse {
        try await self.client.execute(
            operation: "GetWorkflowExecution", 
            path: "/GetWorkflowExecution", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the runtime information that was logged for a specific runtime instance
    /// 			of the workflow.
    ///
    /// Parameters:
    ///   - workflowExecutionId: Use the unique identifier for a runtime instance of the workflow to get
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflowExecution(
        workflowExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowExecutionResponse {
        let input = GetWorkflowExecutionRequest(
            workflowExecutionId: workflowExecutionId
        )
        return try await self.getWorkflowExecution(input, logger: logger)
    }

    /// Get the runtime information that was logged for a specific runtime instance of
    /// 			the workflow step.
    @Sendable
    @inlinable
    public func getWorkflowStepExecution(_ input: GetWorkflowStepExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowStepExecutionResponse {
        try await self.client.execute(
            operation: "GetWorkflowStepExecution", 
            path: "/GetWorkflowStepExecution", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the runtime information that was logged for a specific runtime instance of
    /// 			the workflow step.
    ///
    /// Parameters:
    ///   - stepExecutionId: Use the unique identifier for a specific runtime instance of the workflow step to
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflowStepExecution(
        stepExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowStepExecutionResponse {
        let input = GetWorkflowStepExecutionRequest(
            stepExecutionId: stepExecutionId
        )
        return try await self.getWorkflowStepExecution(input, logger: logger)
    }

    /// Imports a component and transforms its data into a component document.
    @Sendable
    @inlinable
    public func importComponent(_ input: ImportComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportComponentResponse {
        try await self.client.execute(
            operation: "ImportComponent", 
            path: "/ImportComponent", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Imports a component and transforms its data into a component document.
    ///
    /// Parameters:
    ///   - changeDescription: The change description of the component. This description indicates the change that
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - data: The data of the component. Used to specify the data inline. Either data
    ///   - description: The description of the component. Describes the contents of the component.
    ///   - format: The format of the resource that you want to import as a component.
    ///   - kmsKeyId: The ID of the KMS key that should be used to encrypt this component.
    ///   - name: The name of the component.
    ///   - platform: The platform of the component.
    ///   - semanticVersion: The semantic version of the component. This version follows the semantic version
    ///   - tags: The tags of the component.
    ///   - type: The type of the component denotes whether the component is used to build the image, or
    ///   - uri: The uri of the component. Must be an Amazon S3 URL and the requester must have permission
    ///   - logger: Logger use during operation
    @inlinable
    public func importComponent(
        changeDescription: String? = nil,
        clientToken: String = ImportComponentRequest.idempotencyToken(),
        data: String? = nil,
        description: String? = nil,
        format: ComponentFormat,
        kmsKeyId: String? = nil,
        name: String,
        platform: Platform,
        semanticVersion: String,
        tags: [String: String]? = nil,
        type: ComponentType,
        uri: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportComponentResponse {
        let input = ImportComponentRequest(
            changeDescription: changeDescription, 
            clientToken: clientToken, 
            data: data, 
            description: description, 
            format: format, 
            kmsKeyId: kmsKeyId, 
            name: name, 
            platform: platform, 
            semanticVersion: semanticVersion, 
            tags: tags, 
            type: type, 
            uri: uri
        )
        return try await self.importComponent(input, logger: logger)
    }

    /// Import a Windows operating system image from a verified Microsoft ISO disk
    /// 			file. The following disk images are supported:   Windows 11 Enterprise
    @Sendable
    @inlinable
    public func importDiskImage(_ input: ImportDiskImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportDiskImageResponse {
        try await self.client.execute(
            operation: "ImportDiskImage", 
            path: "/ImportDiskImage", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Import a Windows operating system image from a verified Microsoft ISO disk
    /// 			file. The following disk images are supported:   Windows 11 Enterprise
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: The description for your disk image import.
    ///   - executionRole: The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access
    ///   - infrastructureConfigurationArn: The Amazon Resource Name (ARN) of the infrastructure configuration resource that's used for
    ///   - name: The name of the image resource that's created from the import.
    ///   - osVersion: The operating system version for the imported image. Allowed values include
    ///   - platform: The operating system platform for the imported image. Allowed values include
    ///   - semanticVersion: The semantic version to attach to the image that's created during the import
    ///   - tags: Tags that are attached to image resources created from the import.
    ///   - uri: The uri of the ISO disk file that's stored in Amazon S3.
    ///   - logger: Logger use during operation
    @inlinable
    public func importDiskImage(
        clientToken: String = ImportDiskImageRequest.idempotencyToken(),
        description: String? = nil,
        executionRole: String? = nil,
        infrastructureConfigurationArn: String,
        name: String,
        osVersion: String,
        platform: String,
        semanticVersion: String,
        tags: [String: String]? = nil,
        uri: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportDiskImageResponse {
        let input = ImportDiskImageRequest(
            clientToken: clientToken, 
            description: description, 
            executionRole: executionRole, 
            infrastructureConfigurationArn: infrastructureConfigurationArn, 
            name: name, 
            osVersion: osVersion, 
            platform: platform, 
            semanticVersion: semanticVersion, 
            tags: tags, 
            uri: uri
        )
        return try await self.importDiskImage(input, logger: logger)
    }

    /// When you export your virtual machine (VM) from its virtualization environment, that
    /// 			process creates a set of one or more disk container files that act as snapshots of your
    /// 			VMs environment, settings, and data. The Amazon EC2 API ImportImage
    /// 			action uses those files to import your VM and create an AMI. To import using the CLI
    /// 			command, see import-image  You can reference the task ID from the VM import to pull in the AMI that the import
    /// 			created as the base image for your Image Builder recipe.
    @Sendable
    @inlinable
    public func importVmImage(_ input: ImportVmImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportVmImageResponse {
        try await self.client.execute(
            operation: "ImportVmImage", 
            path: "/ImportVmImage", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// When you export your virtual machine (VM) from its virtualization environment, that
    /// 			process creates a set of one or more disk container files that act as snapshots of your
    /// 			VMs environment, settings, and data. The Amazon EC2 API ImportImage
    /// 			action uses those files to import your VM and create an AMI. To import using the CLI
    /// 			command, see import-image  You can reference the task ID from the VM import to pull in the AMI that the import
    /// 			created as the base image for your Image Builder recipe.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: The description for the base image that is created by the import process.
    ///   - name: The name of the base image that is created by the import process.
    ///   - osVersion: The operating system version for the imported VM.
    ///   - platform: The operating system platform for the imported VM.
    ///   - semanticVersion: The semantic version to attach to the base image that was created during the import
    ///   - tags: Tags that are attached to the import resources.
    ///   - vmImportTaskId: The importTaskId (API) or ImportTaskId (CLI) from the
    ///   - logger: Logger use during operation
    @inlinable
    public func importVmImage(
        clientToken: String = ImportVmImageRequest.idempotencyToken(),
        description: String? = nil,
        name: String,
        osVersion: String? = nil,
        platform: Platform,
        semanticVersion: String,
        tags: [String: String]? = nil,
        vmImportTaskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportVmImageResponse {
        let input = ImportVmImageRequest(
            clientToken: clientToken, 
            description: description, 
            name: name, 
            osVersion: osVersion, 
            platform: platform, 
            semanticVersion: semanticVersion, 
            tags: tags, 
            vmImportTaskId: vmImportTaskId
        )
        return try await self.importVmImage(input, logger: logger)
    }

    /// Returns the list of component build versions for the specified component
    /// 			version Amazon Resource Name (ARN).
    @Sendable
    @inlinable
    public func listComponentBuildVersions(_ input: ListComponentBuildVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListComponentBuildVersionsResponse {
        try await self.client.execute(
            operation: "ListComponentBuildVersions", 
            path: "/ListComponentBuildVersions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the list of component build versions for the specified component
    /// 			version Amazon Resource Name (ARN).
    ///
    /// Parameters:
    ///   - componentVersionArn: The component version Amazon Resource Name (ARN) whose versions you want to
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listComponentBuildVersions(
        componentVersionArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListComponentBuildVersionsResponse {
        let input = ListComponentBuildVersionsRequest(
            componentVersionArn: componentVersionArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listComponentBuildVersions(input, logger: logger)
    }

    /// Returns the list of components that can be filtered by name, or by using the listed
    /// 				filters to streamline results. Newly created components can take up to
    /// 			two minutes to appear in the ListComponents API Results.  The semantic version has four nodes: ../.
    /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    @Sendable
    @inlinable
    public func listComponents(_ input: ListComponentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListComponentsResponse {
        try await self.client.execute(
            operation: "ListComponents", 
            path: "/ListComponents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the list of components that can be filtered by name, or by using the listed
    /// 				filters to streamline results. Newly created components can take up to
    /// 			two minutes to appear in the ListComponents API Results.  The semantic version has four nodes: ../.
    /// 	You can assign values for the first three, and can filter on all of them.  Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    ///
    /// Parameters:
    ///   - byName: Returns the list of components for the specified name.
    ///   - filters: Use the following filters to streamline results:    description     name     platform     supportedOsVersion     type     version
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - owner: Filters results based on the type of owner for the component. By default, this request
    ///   - logger: Logger use during operation
    @inlinable
    public func listComponents(
        byName: Bool? = nil,
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListComponentsResponse {
        let input = ListComponentsRequest(
            byName: byName, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            owner: owner
        )
        return try await self.listComponents(input, logger: logger)
    }

    /// Returns a list of container recipes.
    @Sendable
    @inlinable
    public func listContainerRecipes(_ input: ListContainerRecipesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListContainerRecipesResponse {
        try await self.client.execute(
            operation: "ListContainerRecipes", 
            path: "/ListContainerRecipes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of container recipes.
    ///
    /// Parameters:
    ///   - filters: Use the following filters to streamline results:    containerType     name     parentImage     platform
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - owner: Returns container recipes belonging to the specified owner, that have been shared with
    ///   - logger: Logger use during operation
    @inlinable
    public func listContainerRecipes(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListContainerRecipesResponse {
        let input = ListContainerRecipesRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            owner: owner
        )
        return try await self.listContainerRecipes(input, logger: logger)
    }

    /// Returns a list of distribution configurations.
    @Sendable
    @inlinable
    public func listDistributionConfigurations(_ input: ListDistributionConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDistributionConfigurationsResponse {
        try await self.client.execute(
            operation: "ListDistributionConfigurations", 
            path: "/ListDistributionConfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of distribution configurations.
    ///
    /// Parameters:
    ///   - filters: You can filter on name to streamline results.
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listDistributionConfigurations(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDistributionConfigurationsResponse {
        let input = ListDistributionConfigurationsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDistributionConfigurations(input, logger: logger)
    }

    /// Returns a list of image build versions.
    @Sendable
    @inlinable
    public func listImageBuildVersions(_ input: ListImageBuildVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageBuildVersionsResponse {
        try await self.client.execute(
            operation: "ListImageBuildVersions", 
            path: "/ListImageBuildVersions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of image build versions.
    ///
    /// Parameters:
    ///   - filters: Use the following filters to streamline results:    name     osVersion     platform     type     version
    ///   - imageVersionArn: The Amazon Resource Name (ARN) of the image whose build versions you want to
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listImageBuildVersions(
        filters: [Filter]? = nil,
        imageVersionArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImageBuildVersionsResponse {
        let input = ListImageBuildVersionsRequest(
            filters: filters, 
            imageVersionArn: imageVersionArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImageBuildVersions(input, logger: logger)
    }

    /// List the Packages that are associated with an Image Build Version, as determined by
    /// 			Amazon Web Services Systems Manager Inventory at build time.
    @Sendable
    @inlinable
    public func listImagePackages(_ input: ListImagePackagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagePackagesResponse {
        try await self.client.execute(
            operation: "ListImagePackages", 
            path: "/ListImagePackages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the Packages that are associated with an Image Build Version, as determined by
    /// 			Amazon Web Services Systems Manager Inventory at build time.
    ///
    /// Parameters:
    ///   - imageBuildVersionArn: Filter results for the ListImagePackages request by the Image Build Version ARN
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listImagePackages(
        imageBuildVersionArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImagePackagesResponse {
        let input = ListImagePackagesRequest(
            imageBuildVersionArn: imageBuildVersionArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImagePackages(input, logger: logger)
    }

    /// Returns a list of images created by the specified pipeline.
    @Sendable
    @inlinable
    public func listImagePipelineImages(_ input: ListImagePipelineImagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagePipelineImagesResponse {
        try await self.client.execute(
            operation: "ListImagePipelineImages", 
            path: "/ListImagePipelineImages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of images created by the specified pipeline.
    ///
    /// Parameters:
    ///   - filters: Use the following filters to streamline results:    name     version
    ///   - imagePipelineArn: The Amazon Resource Name (ARN) of the image pipeline whose images you want to
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listImagePipelineImages(
        filters: [Filter]? = nil,
        imagePipelineArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImagePipelineImagesResponse {
        let input = ListImagePipelineImagesRequest(
            filters: filters, 
            imagePipelineArn: imagePipelineArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImagePipelineImages(input, logger: logger)
    }

    /// Returns a list of image pipelines.
    @Sendable
    @inlinable
    public func listImagePipelines(_ input: ListImagePipelinesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagePipelinesResponse {
        try await self.client.execute(
            operation: "ListImagePipelines", 
            path: "/ListImagePipelines", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of image pipelines.
    ///
    /// Parameters:
    ///   - filters: Use the following filters to streamline results:    description     distributionConfigurationArn     imageRecipeArn     infrastructureConfigurationArn     name     status
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listImagePipelines(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImagePipelinesResponse {
        let input = ListImagePipelinesRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImagePipelines(input, logger: logger)
    }

    /// Returns a list of image recipes.
    @Sendable
    @inlinable
    public func listImageRecipes(_ input: ListImageRecipesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageRecipesResponse {
        try await self.client.execute(
            operation: "ListImageRecipes", 
            path: "/ListImageRecipes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of image recipes.
    ///
    /// Parameters:
    ///   - filters: Use the following filters to streamline results:    name     parentImage     platform
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - owner: The owner defines which image recipes you want to list. By default, this request will
    ///   - logger: Logger use during operation
    @inlinable
    public func listImageRecipes(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImageRecipesResponse {
        let input = ListImageRecipesRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            owner: owner
        )
        return try await self.listImageRecipes(input, logger: logger)
    }

    /// Returns a list of image scan aggregations for your account. You can filter by the type
    /// 			of key that Image Builder uses to group results. For example, if you want to get a list of
    /// 			findings by severity level for one of your pipelines, you might specify your pipeline
    /// 			with the imagePipelineArn filter. If you don't specify a filter, Image Builder
    /// 			returns an aggregation for your account. To streamline results, you can use the following filters in your request:    accountId     imageBuildVersionArn     imagePipelineArn     vulnerabilityId
    @Sendable
    @inlinable
    public func listImageScanFindingAggregations(_ input: ListImageScanFindingAggregationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageScanFindingAggregationsResponse {
        try await self.client.execute(
            operation: "ListImageScanFindingAggregations", 
            path: "/ListImageScanFindingAggregations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of image scan aggregations for your account. You can filter by the type
    /// 			of key that Image Builder uses to group results. For example, if you want to get a list of
    /// 			findings by severity level for one of your pipelines, you might specify your pipeline
    /// 			with the imagePipelineArn filter. If you don't specify a filter, Image Builder
    /// 			returns an aggregation for your account. To streamline results, you can use the following filters in your request:    accountId     imageBuildVersionArn     imagePipelineArn     vulnerabilityId
    ///
    /// Parameters:
    ///   - filter: 
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listImageScanFindingAggregations(
        filter: Filter? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImageScanFindingAggregationsResponse {
        let input = ListImageScanFindingAggregationsRequest(
            filter: filter, 
            nextToken: nextToken
        )
        return try await self.listImageScanFindingAggregations(input, logger: logger)
    }

    /// Returns a list of image scan findings for your account.
    @Sendable
    @inlinable
    public func listImageScanFindings(_ input: ListImageScanFindingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImageScanFindingsResponse {
        try await self.client.execute(
            operation: "ListImageScanFindings", 
            path: "/ListImageScanFindings", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of image scan findings for your account.
    ///
    /// Parameters:
    ///   - filters: An array of name value pairs that you can use to filter your results. You can use the
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listImageScanFindings(
        filters: [ImageScanFindingsFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImageScanFindingsResponse {
        let input = ListImageScanFindingsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listImageScanFindings(input, logger: logger)
    }

    /// Returns the list of images that you have access to. Newly created images can take up
    /// 			to two minutes to appear in the ListImages API Results.
    @Sendable
    @inlinable
    public func listImages(_ input: ListImagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListImagesResponse {
        try await self.client.execute(
            operation: "ListImages", 
            path: "/ListImages", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the list of images that you have access to. Newly created images can take up
    /// 			to two minutes to appear in the ListImages API Results.
    ///
    /// Parameters:
    ///   - byName: Requests a list of images with a specific recipe name.
    ///   - filters: Use the following filters to streamline results:    name     osVersion     platform     type     version
    ///   - includeDeprecated: Includes deprecated images in the response list.
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - owner: The owner defines which images you want to list. By default, this request will only
    ///   - logger: Logger use during operation
    @inlinable
    public func listImages(
        byName: Bool? = nil,
        filters: [Filter]? = nil,
        includeDeprecated: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListImagesResponse {
        let input = ListImagesRequest(
            byName: byName, 
            filters: filters, 
            includeDeprecated: includeDeprecated, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            owner: owner
        )
        return try await self.listImages(input, logger: logger)
    }

    /// Returns a list of infrastructure configurations.
    @Sendable
    @inlinable
    public func listInfrastructureConfigurations(_ input: ListInfrastructureConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInfrastructureConfigurationsResponse {
        try await self.client.execute(
            operation: "ListInfrastructureConfigurations", 
            path: "/ListInfrastructureConfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of infrastructure configurations.
    ///
    /// Parameters:
    ///   - filters: You can filter on name to streamline results.
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listInfrastructureConfigurations(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInfrastructureConfigurationsResponse {
        let input = ListInfrastructureConfigurationsRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listInfrastructureConfigurations(input, logger: logger)
    }

    /// List resources that the runtime instance of the image lifecycle identified for lifecycle actions.
    @Sendable
    @inlinable
    public func listLifecycleExecutionResources(_ input: ListLifecycleExecutionResourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLifecycleExecutionResourcesResponse {
        try await self.client.execute(
            operation: "ListLifecycleExecutionResources", 
            path: "/ListLifecycleExecutionResources", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List resources that the runtime instance of the image lifecycle identified for lifecycle actions.
    ///
    /// Parameters:
    ///   - lifecycleExecutionId: Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - parentResourceId: You can  leave this empty to get a list of Image Builder resources that were identified for lifecycle actions. To get a list of associated resources that are impacted for an individual resource (the parent), specify
    ///   - logger: Logger use during operation
    @inlinable
    public func listLifecycleExecutionResources(
        lifecycleExecutionId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        parentResourceId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLifecycleExecutionResourcesResponse {
        let input = ListLifecycleExecutionResourcesRequest(
            lifecycleExecutionId: lifecycleExecutionId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            parentResourceId: parentResourceId
        )
        return try await self.listLifecycleExecutionResources(input, logger: logger)
    }

    /// Get the lifecycle runtime history for the specified resource.
    @Sendable
    @inlinable
    public func listLifecycleExecutions(_ input: ListLifecycleExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLifecycleExecutionsResponse {
        try await self.client.execute(
            operation: "ListLifecycleExecutions", 
            path: "/ListLifecycleExecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the lifecycle runtime history for the specified resource.
    ///
    /// Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which to get a list of lifecycle runtime instances.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLifecycleExecutions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLifecycleExecutionsResponse {
        let input = ListLifecycleExecutionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceArn: resourceArn
        )
        return try await self.listLifecycleExecutions(input, logger: logger)
    }

    /// Get a list of lifecycle policies in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listLifecyclePolicies(_ input: ListLifecyclePoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLifecyclePoliciesResponse {
        try await self.client.execute(
            operation: "ListLifecyclePolicies", 
            path: "/ListLifecyclePolicies", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a list of lifecycle policies in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - filters: Streamline results based on one of the following values: Name,
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listLifecyclePolicies(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLifecyclePoliciesResponse {
        let input = ListLifecyclePoliciesRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listLifecyclePolicies(input, logger: logger)
    }

    /// Returns the list of tags for the specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the list of tags for the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Get a list of workflow steps that are waiting for action for workflows
    /// 			in your Amazon Web Services account.
    @Sendable
    @inlinable
    public func listWaitingWorkflowSteps(_ input: ListWaitingWorkflowStepsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWaitingWorkflowStepsResponse {
        try await self.client.execute(
            operation: "ListWaitingWorkflowSteps", 
            path: "/ListWaitingWorkflowSteps", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a list of workflow steps that are waiting for action for workflows
    /// 			in your Amazon Web Services account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listWaitingWorkflowSteps(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWaitingWorkflowStepsResponse {
        let input = ListWaitingWorkflowStepsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWaitingWorkflowSteps(input, logger: logger)
    }

    /// Returns a list of build versions for a specific workflow resource.
    @Sendable
    @inlinable
    public func listWorkflowBuildVersions(_ input: ListWorkflowBuildVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowBuildVersionsResponse {
        try await self.client.execute(
            operation: "ListWorkflowBuildVersions", 
            path: "/ListWorkflowBuildVersions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of build versions for a specific workflow resource.
    ///
    /// Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - workflowVersionArn: The Amazon Resource Name (ARN) of the workflow resource for which to get a list of build versions.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkflowBuildVersions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workflowVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkflowBuildVersionsResponse {
        let input = ListWorkflowBuildVersionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workflowVersionArn: workflowVersionArn
        )
        return try await self.listWorkflowBuildVersions(input, logger: logger)
    }

    /// Returns a list of workflow runtime instance metadata objects for a specific image build
    /// 			version.
    @Sendable
    @inlinable
    public func listWorkflowExecutions(_ input: ListWorkflowExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowExecutionsResponse {
        try await self.client.execute(
            operation: "ListWorkflowExecutions", 
            path: "/ListWorkflowExecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of workflow runtime instance metadata objects for a specific image build
    /// 			version.
    ///
    /// Parameters:
    ///   - imageBuildVersionArn: List all workflow runtime instances for the specified image build version
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkflowExecutions(
        imageBuildVersionArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkflowExecutionsResponse {
        let input = ListWorkflowExecutionsRequest(
            imageBuildVersionArn: imageBuildVersionArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWorkflowExecutions(input, logger: logger)
    }

    /// Returns runtime data for each step in a runtime instance of the workflow
    /// 			that you specify in the request.
    @Sendable
    @inlinable
    public func listWorkflowStepExecutions(_ input: ListWorkflowStepExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowStepExecutionsResponse {
        try await self.client.execute(
            operation: "ListWorkflowStepExecutions", 
            path: "/ListWorkflowStepExecutions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns runtime data for each step in a runtime instance of the workflow
    /// 			that you specify in the request.
    ///
    /// Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - workflowExecutionId: The unique identifier that Image Builder assigned to keep track of runtime details
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkflowStepExecutions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workflowExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkflowStepExecutionsResponse {
        let input = ListWorkflowStepExecutionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workflowExecutionId: workflowExecutionId
        )
        return try await self.listWorkflowStepExecutions(input, logger: logger)
    }

    /// Lists workflow build versions based on filtering parameters.
    @Sendable
    @inlinable
    public func listWorkflows(_ input: ListWorkflowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowsResponse {
        try await self.client.execute(
            operation: "ListWorkflows", 
            path: "/ListWorkflows", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists workflow build versions based on filtering parameters.
    ///
    /// Parameters:
    ///   - byName: Specify all or part of the workflow name to streamline results.
    ///   - filters: Used to streamline search results.
    ///   - maxResults: The maximum items to return in a request.
    ///   - nextToken: A token to specify where to start paginating. This is the nextToken
    ///   - owner: Used to get a list of workflow build version filtered by the identity of the creator.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkflows(
        byName: Bool? = nil,
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkflowsResponse {
        let input = ListWorkflowsRequest(
            byName: byName, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            owner: owner
        )
        return try await self.listWorkflows(input, logger: logger)
    }

    /// Applies a policy to a component. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutComponentPolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    @Sendable
    @inlinable
    public func putComponentPolicy(_ input: PutComponentPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutComponentPolicyResponse {
        try await self.client.execute(
            operation: "PutComponentPolicy", 
            path: "/PutComponentPolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Applies a policy to a component. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutComponentPolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    ///
    /// Parameters:
    ///   - componentArn: The Amazon Resource Name (ARN) of the component that this policy should be applied
    ///   - policy: The policy to apply.
    ///   - logger: Logger use during operation
    @inlinable
    public func putComponentPolicy(
        componentArn: String,
        policy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutComponentPolicyResponse {
        let input = PutComponentPolicyRequest(
            componentArn: componentArn, 
            policy: policy
        )
        return try await self.putComponentPolicy(input, logger: logger)
    }

    /// Applies a policy to a container image. We recommend that you call the RAM API
    /// 			CreateResourceShare
    /// 			(https://docs.aws.amazon.com//ram/latest/APIReference/API_CreateResourceShare.html) to share
    /// 			resources. If you call the Image Builder API PutContainerImagePolicy, you must also
    /// 			call the RAM API PromoteResourceShareCreatedFromPolicy
    /// 			(https://docs.aws.amazon.com//ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html)
    /// 			in order for the resource to be visible to all principals with whom the resource is
    /// 			shared.
    @Sendable
    @inlinable
    public func putContainerRecipePolicy(_ input: PutContainerRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutContainerRecipePolicyResponse {
        try await self.client.execute(
            operation: "PutContainerRecipePolicy", 
            path: "/PutContainerRecipePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Applies a policy to a container image. We recommend that you call the RAM API
    /// 			CreateResourceShare
    /// 			(https://docs.aws.amazon.com//ram/latest/APIReference/API_CreateResourceShare.html) to share
    /// 			resources. If you call the Image Builder API PutContainerImagePolicy, you must also
    /// 			call the RAM API PromoteResourceShareCreatedFromPolicy
    /// 			(https://docs.aws.amazon.com//ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html)
    /// 			in order for the resource to be visible to all principals with whom the resource is
    /// 			shared.
    ///
    /// Parameters:
    ///   - containerRecipeArn: The Amazon Resource Name (ARN) of the container recipe that this policy should be
    ///   - policy: The policy to apply to the container recipe.
    ///   - logger: Logger use during operation
    @inlinable
    public func putContainerRecipePolicy(
        containerRecipeArn: String,
        policy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutContainerRecipePolicyResponse {
        let input = PutContainerRecipePolicyRequest(
            containerRecipeArn: containerRecipeArn, 
            policy: policy
        )
        return try await self.putContainerRecipePolicy(input, logger: logger)
    }

    /// Applies a policy to an image. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutImagePolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    @Sendable
    @inlinable
    public func putImagePolicy(_ input: PutImagePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutImagePolicyResponse {
        try await self.client.execute(
            operation: "PutImagePolicy", 
            path: "/PutImagePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Applies a policy to an image. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutImagePolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    ///
    /// Parameters:
    ///   - imageArn: The Amazon Resource Name (ARN) of the image that this policy should be applied
    ///   - policy: The policy to apply.
    ///   - logger: Logger use during operation
    @inlinable
    public func putImagePolicy(
        imageArn: String,
        policy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutImagePolicyResponse {
        let input = PutImagePolicyRequest(
            imageArn: imageArn, 
            policy: policy
        )
        return try await self.putImagePolicy(input, logger: logger)
    }

    /// Applies a policy to an image recipe. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutImageRecipePolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    @Sendable
    @inlinable
    public func putImageRecipePolicy(_ input: PutImageRecipePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutImageRecipePolicyResponse {
        try await self.client.execute(
            operation: "PutImageRecipePolicy", 
            path: "/PutImageRecipePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Applies a policy to an image recipe. We recommend that you call the RAM API CreateResourceShare to share resources. If you call the Image Builder API
    /// 				PutImageRecipePolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy in order for the resource to be
    /// 			visible to all principals with whom the resource is shared.
    ///
    /// Parameters:
    ///   - imageRecipeArn: The Amazon Resource Name (ARN) of the image recipe that this policy should be applied
    ///   - policy: The policy to apply.
    ///   - logger: Logger use during operation
    @inlinable
    public func putImageRecipePolicy(
        imageRecipeArn: String,
        policy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutImageRecipePolicyResponse {
        let input = PutImageRecipePolicyRequest(
            imageRecipeArn: imageRecipeArn, 
            policy: policy
        )
        return try await self.putImageRecipePolicy(input, logger: logger)
    }

    /// Pauses or resumes image creation when the associated workflow runs a
    /// 			WaitForAction step.
    @Sendable
    @inlinable
    public func sendWorkflowStepAction(_ input: SendWorkflowStepActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SendWorkflowStepActionResponse {
        try await self.client.execute(
            operation: "SendWorkflowStepAction", 
            path: "/SendWorkflowStepAction", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Pauses or resumes image creation when the associated workflow runs a
    /// 			WaitForAction step.
    ///
    /// Parameters:
    ///   - action: The action for the image creation process to take while a workflow
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - imageBuildVersionArn: The Amazon Resource Name (ARN) of the image build version to send action for.
    ///   - reason: The reason why this action is sent.
    ///   - stepExecutionId: Uniquely identifies the workflow step that sent the step action.
    ///   - logger: Logger use during operation
    @inlinable
    public func sendWorkflowStepAction(
        action: WorkflowStepActionType,
        clientToken: String = SendWorkflowStepActionRequest.idempotencyToken(),
        imageBuildVersionArn: String,
        reason: String? = nil,
        stepExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SendWorkflowStepActionResponse {
        let input = SendWorkflowStepActionRequest(
            action: action, 
            clientToken: clientToken, 
            imageBuildVersionArn: imageBuildVersionArn, 
            reason: reason, 
            stepExecutionId: stepExecutionId
        )
        return try await self.sendWorkflowStepAction(input, logger: logger)
    }

    /// Manually triggers a pipeline to create an image.
    @Sendable
    @inlinable
    public func startImagePipelineExecution(_ input: StartImagePipelineExecutionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartImagePipelineExecutionResponse {
        try await self.client.execute(
            operation: "StartImagePipelineExecution", 
            path: "/StartImagePipelineExecution", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Manually triggers a pipeline to create an image.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - imagePipelineArn: The Amazon Resource Name (ARN) of the image pipeline that you want to manually
    ///   - logger: Logger use during operation
    @inlinable
    public func startImagePipelineExecution(
        clientToken: String = StartImagePipelineExecutionRequest.idempotencyToken(),
        imagePipelineArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartImagePipelineExecutionResponse {
        let input = StartImagePipelineExecutionRequest(
            clientToken: clientToken, 
            imagePipelineArn: imagePipelineArn
        )
        return try await self.startImagePipelineExecution(input, logger: logger)
    }

    /// Begin asynchronous resource state update for lifecycle changes to the
    /// 			specified image resources.
    @Sendable
    @inlinable
    public func startResourceStateUpdate(_ input: StartResourceStateUpdateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartResourceStateUpdateResponse {
        try await self.client.execute(
            operation: "StartResourceStateUpdate", 
            path: "/StartResourceStateUpdate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Begin asynchronous resource state update for lifecycle changes to the
    /// 			specified image resources.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - exclusionRules: Skip action on the image resource and associated resources if specified
    ///   - executionRole: The name or Amazon Resource Name (ARN) of the IAM role thats used to update image state.
    ///   - includeResources: A list of image resources to update state for.
    ///   - resourceArn: The ARN of the Image Builder resource that is updated. The state update might also
    ///   - state: Indicates the lifecycle action to take for this request.
    ///   - updateAt: The timestamp that indicates when resources are updated by a lifecycle action.
    ///   - logger: Logger use during operation
    @inlinable
    public func startResourceStateUpdate(
        clientToken: String = StartResourceStateUpdateRequest.idempotencyToken(),
        exclusionRules: ResourceStateUpdateExclusionRules? = nil,
        executionRole: String? = nil,
        includeResources: ResourceStateUpdateIncludeResources? = nil,
        resourceArn: String,
        state: ResourceState,
        updateAt: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartResourceStateUpdateResponse {
        let input = StartResourceStateUpdateRequest(
            clientToken: clientToken, 
            exclusionRules: exclusionRules, 
            executionRole: executionRole, 
            includeResources: includeResources, 
            resourceArn: resourceArn, 
            state: state, 
            updateAt: updateAt
        )
        return try await self.startResourceStateUpdate(input, logger: logger)
    }

    /// Adds a tag to a resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a tag to a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to tag.
    ///   - tags: The tags to apply to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a tag from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that you want to untag.
    ///   - tagKeys: The tag keys to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a new distribution configuration. Distribution configurations define and
    /// 			configure the outputs of your pipeline.
    @Sendable
    @inlinable
    public func updateDistributionConfiguration(_ input: UpdateDistributionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDistributionConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateDistributionConfiguration", 
            path: "/UpdateDistributionConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a new distribution configuration. Distribution configurations define and
    /// 			configure the outputs of your pipeline.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: The description of the distribution configuration.
    ///   - distributionConfigurationArn: The Amazon Resource Name (ARN) of the distribution configuration that you want to
    ///   - distributions: The distributions of the distribution configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDistributionConfiguration(
        clientToken: String = UpdateDistributionConfigurationRequest.idempotencyToken(),
        description: String? = nil,
        distributionConfigurationArn: String,
        distributions: [Distribution],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDistributionConfigurationResponse {
        let input = UpdateDistributionConfigurationRequest(
            clientToken: clientToken, 
            description: description, 
            distributionConfigurationArn: distributionConfigurationArn, 
            distributions: distributions
        )
        return try await self.updateDistributionConfiguration(input, logger: logger)
    }

    /// Updates an image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images. You must specify exactly one recipe for your image, using either
    /// 			a containerRecipeArn or an imageRecipeArn.  UpdateImagePipeline does not support selective updates for the pipeline. You must
    /// 				specify all of the required properties in the update request, not just the
    /// 				properties that have changed.
    @Sendable
    @inlinable
    public func updateImagePipeline(_ input: UpdateImagePipelineRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateImagePipelineResponse {
        try await self.client.execute(
            operation: "UpdateImagePipeline", 
            path: "/UpdateImagePipeline", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images. You must specify exactly one recipe for your image, using either
    /// 			a containerRecipeArn or an imageRecipeArn.  UpdateImagePipeline does not support selective updates for the pipeline. You must
    /// 				specify all of the required properties in the update request, not just the
    /// 				properties that have changed.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - containerRecipeArn: The Amazon Resource Name (ARN) of the container pipeline to update.
    ///   - description: The description of the image pipeline.
    ///   - distributionConfigurationArn: The Amazon Resource Name (ARN) of the distribution configuration that Image Builder uses to
    ///   - enhancedImageMetadataEnabled: Collects additional information about the image being created, including the operating
    ///   - executionRole: The name or Amazon Resource Name (ARN) for the IAM role you create that grants
    ///   - imagePipelineArn: The Amazon Resource Name (ARN) of the image pipeline that you want to update.
    ///   - imageRecipeArn: The Amazon Resource Name (ARN) of the image recipe that will be used to configure
    ///   - imageScanningConfiguration: Contains settings for vulnerability scans.
    ///   - imageTestsConfiguration: The image test configuration of the image pipeline.
    ///   - infrastructureConfigurationArn: The Amazon Resource Name (ARN) of the infrastructure configuration that Image Builder uses to
    ///   - schedule: The schedule of the image pipeline.
    ///   - status: The status of the image pipeline.
    ///   - workflows: Contains the workflows to run for the pipeline.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateImagePipeline(
        clientToken: String = UpdateImagePipelineRequest.idempotencyToken(),
        containerRecipeArn: String? = nil,
        description: String? = nil,
        distributionConfigurationArn: String? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        executionRole: String? = nil,
        imagePipelineArn: String,
        imageRecipeArn: String? = nil,
        imageScanningConfiguration: ImageScanningConfiguration? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: String,
        schedule: Schedule? = nil,
        status: PipelineStatus? = nil,
        workflows: [WorkflowConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateImagePipelineResponse {
        let input = UpdateImagePipelineRequest(
            clientToken: clientToken, 
            containerRecipeArn: containerRecipeArn, 
            description: description, 
            distributionConfigurationArn: distributionConfigurationArn, 
            enhancedImageMetadataEnabled: enhancedImageMetadataEnabled, 
            executionRole: executionRole, 
            imagePipelineArn: imagePipelineArn, 
            imageRecipeArn: imageRecipeArn, 
            imageScanningConfiguration: imageScanningConfiguration, 
            imageTestsConfiguration: imageTestsConfiguration, 
            infrastructureConfigurationArn: infrastructureConfigurationArn, 
            schedule: schedule, 
            status: status, 
            workflows: workflows
        )
        return try await self.updateImagePipeline(input, logger: logger)
    }

    /// Updates a new infrastructure configuration. An infrastructure configuration defines
    /// 			the environment in which your image will be built and tested.
    @Sendable
    @inlinable
    public func updateInfrastructureConfiguration(_ input: UpdateInfrastructureConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateInfrastructureConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateInfrastructureConfiguration", 
            path: "/UpdateInfrastructureConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a new infrastructure configuration. An infrastructure configuration defines
    /// 			the environment in which your image will be built and tested.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: The description of the infrastructure configuration.
    ///   - infrastructureConfigurationArn: The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
    ///   - instanceMetadataOptions: The instance metadata options that you can set for the HTTP requests that pipeline
    ///   - instanceProfileName: The instance profile to associate with the instance used to customize your Amazon EC2
    ///   - instanceTypes: The instance types of the infrastructure configuration. You can specify one or more
    ///   - keyPair: The key pair of the infrastructure configuration. You can use this to log on to and
    ///   - logging: The logging configuration of the infrastructure configuration.
    ///   - placement: The instance placement settings that define where the instances that are launched
    ///   - resourceTags: The tags attached to the resource created by Image Builder.
    ///   - securityGroupIds: The security group IDs to associate with the instance used to customize your Amazon EC2
    ///   - snsTopicArn: The Amazon Resource Name (ARN) for the SNS topic to which we send image build event
    ///   - subnetId: The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
    ///   - terminateInstanceOnFailure: The terminate instance on failure setting of the infrastructure configuration. Set to
    ///   - logger: Logger use during operation
    @inlinable
    public func updateInfrastructureConfiguration(
        clientToken: String = UpdateInfrastructureConfigurationRequest.idempotencyToken(),
        description: String? = nil,
        infrastructureConfigurationArn: String,
        instanceMetadataOptions: InstanceMetadataOptions? = nil,
        instanceProfileName: String,
        instanceTypes: [String]? = nil,
        keyPair: String? = nil,
        logging: Logging? = nil,
        placement: Placement? = nil,
        resourceTags: [String: String]? = nil,
        securityGroupIds: [String]? = nil,
        snsTopicArn: String? = nil,
        subnetId: String? = nil,
        terminateInstanceOnFailure: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateInfrastructureConfigurationResponse {
        let input = UpdateInfrastructureConfigurationRequest(
            clientToken: clientToken, 
            description: description, 
            infrastructureConfigurationArn: infrastructureConfigurationArn, 
            instanceMetadataOptions: instanceMetadataOptions, 
            instanceProfileName: instanceProfileName, 
            instanceTypes: instanceTypes, 
            keyPair: keyPair, 
            logging: logging, 
            placement: placement, 
            resourceTags: resourceTags, 
            securityGroupIds: securityGroupIds, 
            snsTopicArn: snsTopicArn, 
            subnetId: subnetId, 
            terminateInstanceOnFailure: terminateInstanceOnFailure
        )
        return try await self.updateInfrastructureConfiguration(input, logger: logger)
    }

    /// Update the specified lifecycle policy.
    @Sendable
    @inlinable
    public func updateLifecyclePolicy(_ input: UpdateLifecyclePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLifecyclePolicyResponse {
        try await self.client.execute(
            operation: "UpdateLifecyclePolicy", 
            path: "/UpdateLifecyclePolicy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update the specified lifecycle policy.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see Ensuring idempotency  in the Amazon EC2 API Reference.
    ///   - description: Optional description for the lifecycle policy.
    ///   - executionRole: The name or Amazon Resource Name (ARN) of the IAM role that Image Builder uses to update the
    ///   - lifecyclePolicyArn: The Amazon Resource Name (ARN) of the lifecycle policy resource.
    ///   - policyDetails: The configuration details for a lifecycle policy resource.
    ///   - resourceSelection: Selection criteria for resources that the lifecycle policy applies to.
    ///   - resourceType: The type of image resource that the lifecycle policy applies to.
    ///   - status: Indicates whether the lifecycle policy resource is enabled.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLifecyclePolicy(
        clientToken: String = UpdateLifecyclePolicyRequest.idempotencyToken(),
        description: String? = nil,
        executionRole: String,
        lifecyclePolicyArn: String,
        policyDetails: [LifecyclePolicyDetail],
        resourceSelection: LifecyclePolicyResourceSelection,
        resourceType: LifecyclePolicyResourceType,
        status: LifecyclePolicyStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLifecyclePolicyResponse {
        let input = UpdateLifecyclePolicyRequest(
            clientToken: clientToken, 
            description: description, 
            executionRole: executionRole, 
            lifecyclePolicyArn: lifecyclePolicyArn, 
            policyDetails: policyDetails, 
            resourceSelection: resourceSelection, 
            resourceType: resourceType, 
            status: status
        )
        return try await self.updateLifecyclePolicy(input, logger: logger)
    }
}

extension Imagebuilder {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Imagebuilder, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Imagebuilder {
    /// Return PaginatorSequence for operation ``listComponentBuildVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listComponentBuildVersionsPaginator(
        _ input: ListComponentBuildVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListComponentBuildVersionsRequest, ListComponentBuildVersionsResponse> {
        return .init(
            input: input,
            command: self.listComponentBuildVersions,
            inputKey: \ListComponentBuildVersionsRequest.nextToken,
            outputKey: \ListComponentBuildVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listComponentBuildVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - componentVersionArn: The component version Amazon Resource Name (ARN) whose versions you want to
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listComponentBuildVersionsPaginator(
        componentVersionArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListComponentBuildVersionsRequest, ListComponentBuildVersionsResponse> {
        let input = ListComponentBuildVersionsRequest(
            componentVersionArn: componentVersionArn, 
            maxResults: maxResults
        )
        return self.listComponentBuildVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listComponents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listComponentsPaginator(
        _ input: ListComponentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListComponentsRequest, ListComponentsResponse> {
        return .init(
            input: input,
            command: self.listComponents,
            inputKey: \ListComponentsRequest.nextToken,
            outputKey: \ListComponentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listComponents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - byName: Returns the list of components for the specified name.
    ///   - filters: Use the following filters to streamline results:    description     name     platform     supportedOsVersion     type     version
    ///   - maxResults: The maximum items to return in a request.
    ///   - owner: Filters results based on the type of owner for the component. By default, this request
    ///   - logger: Logger used for logging
    @inlinable
    public func listComponentsPaginator(
        byName: Bool? = nil,
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListComponentsRequest, ListComponentsResponse> {
        let input = ListComponentsRequest(
            byName: byName, 
            filters: filters, 
            maxResults: maxResults, 
            owner: owner
        )
        return self.listComponentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listContainerRecipes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listContainerRecipesPaginator(
        _ input: ListContainerRecipesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListContainerRecipesRequest, ListContainerRecipesResponse> {
        return .init(
            input: input,
            command: self.listContainerRecipes,
            inputKey: \ListContainerRecipesRequest.nextToken,
            outputKey: \ListContainerRecipesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listContainerRecipes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Use the following filters to streamline results:    containerType     name     parentImage     platform
    ///   - maxResults: The maximum items to return in a request.
    ///   - owner: Returns container recipes belonging to the specified owner, that have been shared with
    ///   - logger: Logger used for logging
    @inlinable
    public func listContainerRecipesPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListContainerRecipesRequest, ListContainerRecipesResponse> {
        let input = ListContainerRecipesRequest(
            filters: filters, 
            maxResults: maxResults, 
            owner: owner
        )
        return self.listContainerRecipesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDistributionConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDistributionConfigurationsPaginator(
        _ input: ListDistributionConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDistributionConfigurationsRequest, ListDistributionConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listDistributionConfigurations,
            inputKey: \ListDistributionConfigurationsRequest.nextToken,
            outputKey: \ListDistributionConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDistributionConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: You can filter on name to streamline results.
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDistributionConfigurationsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDistributionConfigurationsRequest, ListDistributionConfigurationsResponse> {
        let input = ListDistributionConfigurationsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listDistributionConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImageBuildVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageBuildVersionsPaginator(
        _ input: ListImageBuildVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageBuildVersionsRequest, ListImageBuildVersionsResponse> {
        return .init(
            input: input,
            command: self.listImageBuildVersions,
            inputKey: \ListImageBuildVersionsRequest.nextToken,
            outputKey: \ListImageBuildVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImageBuildVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Use the following filters to streamline results:    name     osVersion     platform     type     version
    ///   - imageVersionArn: The Amazon Resource Name (ARN) of the image whose build versions you want to
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageBuildVersionsPaginator(
        filters: [Filter]? = nil,
        imageVersionArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImageBuildVersionsRequest, ListImageBuildVersionsResponse> {
        let input = ListImageBuildVersionsRequest(
            filters: filters, 
            imageVersionArn: imageVersionArn, 
            maxResults: maxResults
        )
        return self.listImageBuildVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImagePackages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagePackagesPaginator(
        _ input: ListImagePackagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagePackagesRequest, ListImagePackagesResponse> {
        return .init(
            input: input,
            command: self.listImagePackages,
            inputKey: \ListImagePackagesRequest.nextToken,
            outputKey: \ListImagePackagesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImagePackages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - imageBuildVersionArn: Filter results for the ListImagePackages request by the Image Build Version ARN
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagePackagesPaginator(
        imageBuildVersionArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImagePackagesRequest, ListImagePackagesResponse> {
        let input = ListImagePackagesRequest(
            imageBuildVersionArn: imageBuildVersionArn, 
            maxResults: maxResults
        )
        return self.listImagePackagesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImagePipelineImages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagePipelineImagesPaginator(
        _ input: ListImagePipelineImagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagePipelineImagesRequest, ListImagePipelineImagesResponse> {
        return .init(
            input: input,
            command: self.listImagePipelineImages,
            inputKey: \ListImagePipelineImagesRequest.nextToken,
            outputKey: \ListImagePipelineImagesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImagePipelineImages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Use the following filters to streamline results:    name     version
    ///   - imagePipelineArn: The Amazon Resource Name (ARN) of the image pipeline whose images you want to
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagePipelineImagesPaginator(
        filters: [Filter]? = nil,
        imagePipelineArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImagePipelineImagesRequest, ListImagePipelineImagesResponse> {
        let input = ListImagePipelineImagesRequest(
            filters: filters, 
            imagePipelineArn: imagePipelineArn, 
            maxResults: maxResults
        )
        return self.listImagePipelineImagesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImagePipelines(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagePipelinesPaginator(
        _ input: ListImagePipelinesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagePipelinesRequest, ListImagePipelinesResponse> {
        return .init(
            input: input,
            command: self.listImagePipelines,
            inputKey: \ListImagePipelinesRequest.nextToken,
            outputKey: \ListImagePipelinesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImagePipelines(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Use the following filters to streamline results:    description     distributionConfigurationArn     imageRecipeArn     infrastructureConfigurationArn     name     status
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagePipelinesPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImagePipelinesRequest, ListImagePipelinesResponse> {
        let input = ListImagePipelinesRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listImagePipelinesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImageRecipes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageRecipesPaginator(
        _ input: ListImageRecipesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageRecipesRequest, ListImageRecipesResponse> {
        return .init(
            input: input,
            command: self.listImageRecipes,
            inputKey: \ListImageRecipesRequest.nextToken,
            outputKey: \ListImageRecipesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImageRecipes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Use the following filters to streamline results:    name     parentImage     platform
    ///   - maxResults: The maximum items to return in a request.
    ///   - owner: The owner defines which image recipes you want to list. By default, this request will
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageRecipesPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImageRecipesRequest, ListImageRecipesResponse> {
        let input = ListImageRecipesRequest(
            filters: filters, 
            maxResults: maxResults, 
            owner: owner
        )
        return self.listImageRecipesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImageScanFindingAggregations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageScanFindingAggregationsPaginator(
        _ input: ListImageScanFindingAggregationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageScanFindingAggregationsRequest, ListImageScanFindingAggregationsResponse> {
        return .init(
            input: input,
            command: self.listImageScanFindingAggregations,
            inputKey: \ListImageScanFindingAggregationsRequest.nextToken,
            outputKey: \ListImageScanFindingAggregationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImageScanFindingAggregations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageScanFindingAggregationsPaginator(
        filter: Filter? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImageScanFindingAggregationsRequest, ListImageScanFindingAggregationsResponse> {
        let input = ListImageScanFindingAggregationsRequest(
            filter: filter
        )
        return self.listImageScanFindingAggregationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImageScanFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageScanFindingsPaginator(
        _ input: ListImageScanFindingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImageScanFindingsRequest, ListImageScanFindingsResponse> {
        return .init(
            input: input,
            command: self.listImageScanFindings,
            inputKey: \ListImageScanFindingsRequest.nextToken,
            outputKey: \ListImageScanFindingsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImageScanFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: An array of name value pairs that you can use to filter your results. You can use the
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listImageScanFindingsPaginator(
        filters: [ImageScanFindingsFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImageScanFindingsRequest, ListImageScanFindingsResponse> {
        let input = ListImageScanFindingsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listImageScanFindingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listImages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagesPaginator(
        _ input: ListImagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListImagesRequest, ListImagesResponse> {
        return .init(
            input: input,
            command: self.listImages,
            inputKey: \ListImagesRequest.nextToken,
            outputKey: \ListImagesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listImages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - byName: Requests a list of images with a specific recipe name.
    ///   - filters: Use the following filters to streamline results:    name     osVersion     platform     type     version
    ///   - includeDeprecated: Includes deprecated images in the response list.
    ///   - maxResults: The maximum items to return in a request.
    ///   - owner: The owner defines which images you want to list. By default, this request will only
    ///   - logger: Logger used for logging
    @inlinable
    public func listImagesPaginator(
        byName: Bool? = nil,
        filters: [Filter]? = nil,
        includeDeprecated: Bool? = nil,
        maxResults: Int? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListImagesRequest, ListImagesResponse> {
        let input = ListImagesRequest(
            byName: byName, 
            filters: filters, 
            includeDeprecated: includeDeprecated, 
            maxResults: maxResults, 
            owner: owner
        )
        return self.listImagesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInfrastructureConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInfrastructureConfigurationsPaginator(
        _ input: ListInfrastructureConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInfrastructureConfigurationsRequest, ListInfrastructureConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listInfrastructureConfigurations,
            inputKey: \ListInfrastructureConfigurationsRequest.nextToken,
            outputKey: \ListInfrastructureConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInfrastructureConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: You can filter on name to streamline results.
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listInfrastructureConfigurationsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInfrastructureConfigurationsRequest, ListInfrastructureConfigurationsResponse> {
        let input = ListInfrastructureConfigurationsRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listInfrastructureConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLifecycleExecutionResources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLifecycleExecutionResourcesPaginator(
        _ input: ListLifecycleExecutionResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLifecycleExecutionResourcesRequest, ListLifecycleExecutionResourcesResponse> {
        return .init(
            input: input,
            command: self.listLifecycleExecutionResources,
            inputKey: \ListLifecycleExecutionResourcesRequest.nextToken,
            outputKey: \ListLifecycleExecutionResourcesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLifecycleExecutionResources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - lifecycleExecutionId: Use the unique identifier for a runtime instance of the lifecycle policy to get runtime details.
    ///   - maxResults: The maximum items to return in a request.
    ///   - parentResourceId: You can  leave this empty to get a list of Image Builder resources that were identified for lifecycle actions. To get a list of associated resources that are impacted for an individual resource (the parent), specify
    ///   - logger: Logger used for logging
    @inlinable
    public func listLifecycleExecutionResourcesPaginator(
        lifecycleExecutionId: String,
        maxResults: Int? = nil,
        parentResourceId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLifecycleExecutionResourcesRequest, ListLifecycleExecutionResourcesResponse> {
        let input = ListLifecycleExecutionResourcesRequest(
            lifecycleExecutionId: lifecycleExecutionId, 
            maxResults: maxResults, 
            parentResourceId: parentResourceId
        )
        return self.listLifecycleExecutionResourcesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLifecycleExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLifecycleExecutionsPaginator(
        _ input: ListLifecycleExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLifecycleExecutionsRequest, ListLifecycleExecutionsResponse> {
        return .init(
            input: input,
            command: self.listLifecycleExecutions,
            inputKey: \ListLifecycleExecutionsRequest.nextToken,
            outputKey: \ListLifecycleExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLifecycleExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which to get a list of lifecycle runtime instances.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLifecycleExecutionsPaginator(
        maxResults: Int? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLifecycleExecutionsRequest, ListLifecycleExecutionsResponse> {
        let input = ListLifecycleExecutionsRequest(
            maxResults: maxResults, 
            resourceArn: resourceArn
        )
        return self.listLifecycleExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLifecyclePolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLifecyclePoliciesPaginator(
        _ input: ListLifecyclePoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLifecyclePoliciesRequest, ListLifecyclePoliciesResponse> {
        return .init(
            input: input,
            command: self.listLifecyclePolicies,
            inputKey: \ListLifecyclePoliciesRequest.nextToken,
            outputKey: \ListLifecyclePoliciesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLifecyclePolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Streamline results based on one of the following values: Name,
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLifecyclePoliciesPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLifecyclePoliciesRequest, ListLifecyclePoliciesResponse> {
        let input = ListLifecyclePoliciesRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listLifecyclePoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWaitingWorkflowSteps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWaitingWorkflowStepsPaginator(
        _ input: ListWaitingWorkflowStepsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWaitingWorkflowStepsRequest, ListWaitingWorkflowStepsResponse> {
        return .init(
            input: input,
            command: self.listWaitingWorkflowSteps,
            inputKey: \ListWaitingWorkflowStepsRequest.nextToken,
            outputKey: \ListWaitingWorkflowStepsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWaitingWorkflowSteps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWaitingWorkflowStepsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWaitingWorkflowStepsRequest, ListWaitingWorkflowStepsResponse> {
        let input = ListWaitingWorkflowStepsRequest(
            maxResults: maxResults
        )
        return self.listWaitingWorkflowStepsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkflowBuildVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowBuildVersionsPaginator(
        _ input: ListWorkflowBuildVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowBuildVersionsRequest, ListWorkflowBuildVersionsResponse> {
        return .init(
            input: input,
            command: self.listWorkflowBuildVersions,
            inputKey: \ListWorkflowBuildVersionsRequest.nextToken,
            outputKey: \ListWorkflowBuildVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkflowBuildVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - workflowVersionArn: The Amazon Resource Name (ARN) of the workflow resource for which to get a list of build versions.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowBuildVersionsPaginator(
        maxResults: Int? = nil,
        workflowVersionArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkflowBuildVersionsRequest, ListWorkflowBuildVersionsResponse> {
        let input = ListWorkflowBuildVersionsRequest(
            maxResults: maxResults, 
            workflowVersionArn: workflowVersionArn
        )
        return self.listWorkflowBuildVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkflowExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowExecutionsPaginator(
        _ input: ListWorkflowExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowExecutionsRequest, ListWorkflowExecutionsResponse> {
        return .init(
            input: input,
            command: self.listWorkflowExecutions,
            inputKey: \ListWorkflowExecutionsRequest.nextToken,
            outputKey: \ListWorkflowExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkflowExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - imageBuildVersionArn: List all workflow runtime instances for the specified image build version
    ///   - maxResults: The maximum items to return in a request.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowExecutionsPaginator(
        imageBuildVersionArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkflowExecutionsRequest, ListWorkflowExecutionsResponse> {
        let input = ListWorkflowExecutionsRequest(
            imageBuildVersionArn: imageBuildVersionArn, 
            maxResults: maxResults
        )
        return self.listWorkflowExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkflowStepExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowStepExecutionsPaginator(
        _ input: ListWorkflowStepExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowStepExecutionsRequest, ListWorkflowStepExecutionsResponse> {
        return .init(
            input: input,
            command: self.listWorkflowStepExecutions,
            inputKey: \ListWorkflowStepExecutionsRequest.nextToken,
            outputKey: \ListWorkflowStepExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkflowStepExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum items to return in a request.
    ///   - workflowExecutionId: The unique identifier that Image Builder assigned to keep track of runtime details
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowStepExecutionsPaginator(
        maxResults: Int? = nil,
        workflowExecutionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkflowStepExecutionsRequest, ListWorkflowStepExecutionsResponse> {
        let input = ListWorkflowStepExecutionsRequest(
            maxResults: maxResults, 
            workflowExecutionId: workflowExecutionId
        )
        return self.listWorkflowStepExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowsPaginator(
        _ input: ListWorkflowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        return .init(
            input: input,
            command: self.listWorkflows,
            inputKey: \ListWorkflowsRequest.nextToken,
            outputKey: \ListWorkflowsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - byName: Specify all or part of the workflow name to streamline results.
    ///   - filters: Used to streamline search results.
    ///   - maxResults: The maximum items to return in a request.
    ///   - owner: Used to get a list of workflow build version filtered by the identity of the creator.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowsPaginator(
        byName: Bool? = nil,
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        owner: Ownership? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        let input = ListWorkflowsRequest(
            byName: byName, 
            filters: filters, 
            maxResults: maxResults, 
            owner: owner
        )
        return self.listWorkflowsPaginator(input, logger: logger)
    }
}

extension Imagebuilder.ListComponentBuildVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListComponentBuildVersionsRequest {
        return .init(
            componentVersionArn: self.componentVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListComponentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListComponentsRequest {
        return .init(
            byName: self.byName,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListContainerRecipesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListContainerRecipesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListDistributionConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListDistributionConfigurationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImageBuildVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageBuildVersionsRequest {
        return .init(
            filters: self.filters,
            imageVersionArn: self.imageVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagePackagesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagePackagesRequest {
        return .init(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagePipelineImagesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagePipelineImagesRequest {
        return .init(
            filters: self.filters,
            imagePipelineArn: self.imagePipelineArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagePipelinesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagePipelinesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImageRecipesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageRecipesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListImageScanFindingAggregationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageScanFindingAggregationsRequest {
        return .init(
            filter: self.filter,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImageScanFindingsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImageScanFindingsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListImagesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListImagesRequest {
        return .init(
            byName: self.byName,
            filters: self.filters,
            includeDeprecated: self.includeDeprecated,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}

extension Imagebuilder.ListInfrastructureConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListInfrastructureConfigurationsRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListLifecycleExecutionResourcesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListLifecycleExecutionResourcesRequest {
        return .init(
            lifecycleExecutionId: self.lifecycleExecutionId,
            maxResults: self.maxResults,
            nextToken: token,
            parentResourceId: self.parentResourceId
        )
    }
}

extension Imagebuilder.ListLifecycleExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListLifecycleExecutionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension Imagebuilder.ListLifecyclePoliciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListLifecyclePoliciesRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListWaitingWorkflowStepsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWaitingWorkflowStepsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListWorkflowBuildVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowBuildVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workflowVersionArn: self.workflowVersionArn
        )
    }
}

extension Imagebuilder.ListWorkflowExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowExecutionsRequest {
        return .init(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Imagebuilder.ListWorkflowStepExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowStepExecutionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workflowExecutionId: self.workflowExecutionId
        )
    }
}

extension Imagebuilder.ListWorkflowsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Imagebuilder.ListWorkflowsRequest {
        return .init(
            byName: self.byName,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )
    }
}
